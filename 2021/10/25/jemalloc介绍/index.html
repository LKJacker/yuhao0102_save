<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zn-ch">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-center-simple.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="C++,">










<meta name="description" content="1 - 简介Jemalloc最初是Jason Evans为FreeBSD开发的新一代内存分配器，用来替代原来的phkmalloc，最早投入使用是在2005年。到目前为止，除了原版Je，还有很多变种被用在各种项目里。Google在android5.0里将bionic中的默认分配器从Dl替换为Je，也是看中了其强大的多核多线程分配能力。 相对经典分配器，Je最大的优势还是其强大的多核/多线程分配能力。">
<meta name="keywords" content="C++">
<meta property="og:type" content="article">
<meta property="og:title" content="Inside of Jemalloc">
<meta property="og:url" content="http://yoursite.com/2021/10/25/jemalloc介绍/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="1 - 简介Jemalloc最初是Jason Evans为FreeBSD开发的新一代内存分配器，用来替代原来的phkmalloc，最早投入使用是在2005年。到目前为止，除了原版Je，还有很多变种被用在各种项目里。Google在android5.0里将bionic中的默认分配器从Dl替换为Je，也是看中了其强大的多核多线程分配能力。 相对经典分配器，Je最大的优势还是其强大的多核/多线程分配能力。">
<meta property="og:locale" content="zn-ch">
<meta property="og:updated_time" content="2021-11-02T06:42:08.033Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Inside of Jemalloc">
<meta name="twitter:description" content="1 - 简介Jemalloc最初是Jason Evans为FreeBSD开发的新一代内存分配器，用来替代原来的phkmalloc，最早投入使用是在2005年。到目前为止，除了原版Je，还有很多变种被用在各种项目里。Google在android5.0里将bionic中的默认分配器从Dl替换为Je，也是看中了其强大的多核多线程分配能力。 相对经典分配器，Je最大的优势还是其强大的多核/多线程分配能力。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2021/10/25/jemalloc介绍/">





  <title>Inside of Jemalloc | Hao Yu's blog</title>
  








 
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zn-ch">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hao Yu's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">The program monkey was eaten by the siege lion.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/resume.pdf" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-mybetterhalf">
          <a href="/mybetterhalf/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>
            
            mybetterhalf
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/10/25/jemalloc介绍/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Inside of Jemalloc</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-10-25T10:48:00+08:00">
                2021-10-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1 - 简介"></a>1 - 简介</h1><p>Jemalloc最初是Jason Evans为FreeBSD开发的新一代内存分配器，用来替代原来的phkmalloc，最早投入使用是在2005年。到目前为止，除了原版Je，还有很多变种被用在各种项目里。Google在android5.0里将bionic中的默认分配器从Dl替换为Je，也是看中了其强大的多核多线程分配能力。</p>
<p>相对经典分配器，Je最大的优势还是其强大的多核/多线程分配能力。以现代计算机硬件架构来说，最大的瓶颈已经不再是内存容量或cpu速度，而是多核/多线程下的lock contention。因为无论核心数量如何多，通常情况下内存只有一份。可以说，如果内存足够大，CPU的核心数量越多，程序线程数越多，Je的分配速度越快。而这一点是经典分配器所无法达到的。</p>
<h1 id="2-Basic-structures"><a href="#2-Basic-structures" class="headerlink" title="2 - Basic structures"></a>2 - Basic structures</h1><p>相对于Dl, Je引入了更多更复杂的分配结构，如arena，chunk，bin，run，region，tcache等等。其中有些类似Dl，但更多的具有不同含义，本节将对它们做一一介绍。</p>
<h2 id="2-1-Overview"><a href="#2-1-Overview" class="headerlink" title="2.1 - Overview"></a>2.1 - Overview</h2><p>首先，先给出一个整体的概念。Je对内存划分按照如下由高到低的顺序，</p>
<ol>
<li>内存是由一定数量的arenas进行管理。</li>
<li>一个arena被分割成若干chunks，后者主要负责记录bookkeeping.</li>
<li>chunk内部又包含着若干runs，作为分配小块内存的基本单元。</li>
<li>run由pages组成，最终被划分成一定数量的regions,</li>
<li>对于small size的分配请求来说，这些region就相当于user memory.</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">    Arena #0</span><br><span class="line">+----------------------------------------------------------------------------+</span><br><span class="line">|                                                                            |</span><br><span class="line">|    Chunk #0                             Chunk #1                           |</span><br><span class="line">|  +---------------------------------+  +---------------------------------+  |</span><br><span class="line">|  |                                 |  |                                 |  |</span><br><span class="line">|  |   Run #0          Run #1        |  |   Run #0          Run #1        |  |</span><br><span class="line">|  | +-------------+ +-------------+ |  | +-------------+ +-------------+ |  |</span><br><span class="line">|  | |             | |             | |  | |             | |             | |  |</span><br><span class="line">|  | |   Page      | |   Page      | |  | |   Page      | |   Page      | |  |</span><br><span class="line">|  | | +---------+ | | +---------+ | |  | | +---------+ | | +---------+ | |  |</span><br><span class="line">|  | | |         | | | |         | | |  | | |         | | | |         | | |  |</span><br><span class="line">|  | | | Regions | | | | Regions | | |  | | | Regions | | | | Regions | | |  |</span><br><span class="line">|  | | |[] [] [] | | | |[] [] [] | | |  | | |[] [] [] | | | |[] [] [] | | |  |</span><br><span class="line">|  | | |         | | | |         | | |  | | |         | | | |         | | |  |</span><br><span class="line">|  | | +---------+ | | +---------+ | |  | | +---------+ | | +---------+ | |  |  </span><br><span class="line">|  | |             | |             | |  | |             | |             | |  |</span><br><span class="line">|  | |   Page      | |   Page      | |  | |   Page      | |   Page      | |  |</span><br><span class="line">|  | | +---------+ | | +---------+ | |  | | +---------+ | | +---------+ | |  |</span><br><span class="line">|  | | |         | | | |         | | |  | | |         | | | |         | | |  |</span><br><span class="line">|  | | | ...     | | | | ...     | | |  | | | ...     | | | | ...     | | |  |</span><br><span class="line">|  | | +---------+ | | +---------+ | |  | | +---------+ | | +---------+ | |  |</span><br><span class="line">|  | +-------------+ +-------------+ |  | +-------------+ +-------------+ |  |</span><br><span class="line">|  +---------------------------------+  +---------------------------------+  |</span><br><span class="line">+----------------------------------------------------------------------------+</span><br></pre></td></tr></table></figure>
<h2 id="2-2-Arena-arena-t"><a href="#2-2-Arena-arena-t" class="headerlink" title="2.2 - Arena (arena_t)"></a>2.2 - Arena (arena_t)</h2><p>如前所述，Arena是Je中最大或者说最顶层的基础结构。这个概念其实上是针对”对称多处理机(SMP)”产生的。在SMP中，导致性能劣化的一个重要原因在于”false sharing”导致cache-line失效。</p>
<p>为了解决cache-line共享问题，同时保证更少的内部碎片(internal fragmentation)，Je使用了arena。</p>
<h3 id="2-2-1-CPU-Cache-Line"><a href="#2-2-1-CPU-Cache-Line" class="headerlink" title="2.2.1 - CPU Cache-Line"></a>2.2.1 - CPU Cache-Line</h3><p>Cache是嵌入到cpu内部的一组SRAM，速度是主存的N倍，但造价较高，因此一般容量很小。有些cpu设计了容量逐级逐渐增大的多级cache，但速度逐级递减。多级处理更复杂，但原理类似，为了简化，仅讨论L1 data cache。</p>
<p>cache同主存进行数据交换有一个最小粒度，称为cache-line，通常这个值为64。例如在一个ILP32的机器上，一次cache交换可以读写连续16个int型数据。因此当访问数组#0元素时，后面15个元素也被同时”免费”读到了cache中，这对于数组的连续访问是非常有利的。</p>
<p>然而这种免费加载不总是会带来好处，有时候甚至起到反效果，所谓”false sharing”。试想两个线程A和B分别执行在不同的cpu核心中并分别操作各自上下文中的变量x和y，如果因为某种原因(比如x，y可能位于同一个class内部，或者分别是数组中的两个相邻元素)，两者位于相同的cache-line中，则在两个core的L1 cache里都存在x和y的副本。</p>
<p>倘若线程A修改了x的值，就会导致在B中的x与A中看到的不一致。尽管这个变量x对B可能毫无用处，但cpu为了保证前后的正确和一致性，只能判定core #1的cache失效。因此core #0必须将cache-line回写到主存，然后core #1再重新加载cache-line，反之亦然。如果恰好两个线程交替操作同一cache-line中的数据，将对cache将造成极大的损害，导致严重的性能退化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">+-----------------------+        +-----------------------+</span><br><span class="line">| core #0               |        | core #1               |</span><br><span class="line">|                       |        |                       |</span><br><span class="line">|  +----------+         |        |  +----------+         |</span><br><span class="line">|  | ThreadA  |         |        |  | ThreadB  |         |</span><br><span class="line">|  +----------+         |        |  +----------+         |</span><br><span class="line">|        |              |        |        |              |</span><br><span class="line">|    +---+              |        |        |              |</span><br><span class="line">|    |                  |        |        |              |</span><br><span class="line">|    v        D-cache   |        |        v     D-cache  |</span><br><span class="line">|  +-----------------+  |        |  +-----------------+  |</span><br><span class="line">|  | x&apos;| y | ... ... | &lt;---+  +---&gt; | x | y&apos;| ... ... |  |</span><br><span class="line">|  |-----------------|  |  |  |  |  |-----------------|  |</span><br><span class="line">|  |    ... ...      |  |  |  |  |  |    ... ...      |  |</span><br><span class="line">|  |    ... ...      |  |  |  |  |  |    ... ...      |  |</span><br><span class="line">|  |    ... ...      |  |  |  |  |  |    ... ...      |  |</span><br><span class="line">|  +-----------------+  |  |  |  |  +-----------------+  |</span><br><span class="line">+-----------------------+  |  |  +-----------------------+</span><br><span class="line">                           |  |  </span><br><span class="line">                    +------+  |</span><br><span class="line">                    |         |</span><br><span class="line">                    v         v</span><br><span class="line">   memory   +-----------------------------</span><br><span class="line">            | ... | x | y |     ... ...     </span><br><span class="line">            +-----------------------------</span><br></pre></td></tr></table></figure>
<p>说到底，从程序的角度看，变量是独立的地址单元，但在CPU看来则是以cache-line为整体的单元。单独的变量竞争可以在代码中增加同步来解决，而cache-line的竞争是透明的，不可控的，只能被动由CPU仲裁。这种观察角度和处理方式的区别，正是false sharing的根源。</p>
<h3 id="2-2-2-Arena原理"><a href="#2-2-2-Arena原理" class="headerlink" title="2.2.2 - Arena原理"></a>2.2.2 - Arena原理</h3><p>回到memory allocator的话题上。对于一个多线程+多CPU核心的运行环境，传统分配器中大量开销被浪费在lock contention和false sharing上，随着线程数量和核心数量增多，这种分配压力将越来越大。</p>
<p>针对多线程，一种解决方法是将一把global lock分散成很多与线程相关的lock。而针对多核心，则要尽量把不同线程下分配的内存隔离开，避免不同线程使用同一个cache-line的情况。按照上面的思路，一个较好的实现方式就是引入arena。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">+---------+     +---------+     +---------+     +---------+     +---------+</span><br><span class="line">| threadA |     | threadB |     | threadC |     | threadD |     | threadE |     </span><br><span class="line">+---------+     +---------+     +---------+     +---------+     +---------+</span><br><span class="line">     |               |               |               |               |</span><br><span class="line">     |               +---------------|---------------|---------+     |</span><br><span class="line">     +------------------+    +-------+        +------+         |     |</span><br><span class="line">      +-----------------|----|----------------|----------------|-----+  </span><br><span class="line">      |                 |    |                |                |</span><br><span class="line">      v                 v    v                v                v</span><br><span class="line">+----------+        +----------+        +----------+        +----------+     </span><br><span class="line">|          |        |          |        |          |        |          |</span><br><span class="line">| Arena #0 |        | Arena #1 |        | Arena #2 |        | Arena #3 |</span><br><span class="line">|          |        |          |        |          |        |          |</span><br><span class="line">+----------+        +----------+        +----------+        +----------+</span><br></pre></td></tr></table></figure>
<p>Je将内存划分成若干数量的arenas，线程最终会与某一个arena绑定。比如上图中的threadA和B就分别绑定到arena #1和#3上。由于两个arena在地址空间上几乎不存在任何联系，就可以在无锁的状态下完成分配。同样由于空间不连续，落到同一个cache-line中的几率也很小，保证了各自独立。</p>
<p>由于arena的数量有限，因此不能保证所有线程都能独占arena，比如，图中threadA和C就都绑定到了arena1上。分享同一个arena的所有线程，由该arena内部的lock保持同步。</p>
<p>Je将arena保存到一个数组中，该数组全局记录了所有arenas，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">arena_t</span>            **arenas;</span><br></pre></td></tr></table></figure></p>
<p>事实上，该数组是动态分配的，arenas仅仅是一个数组指针。默认情况下arenas数组的长度与如下变量相关，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span>    narenas_total;</span><br><span class="line"><span class="keyword">unsigned</span>    narenas_auto;</span><br><span class="line"><span class="keyword">size_t</span>        opt_narenas = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></p>
<p>而它们又与当前cpu核心数量相关。核心数量记录在另外一个全局变量<code>ncpus</code>里，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span>    ncpus;</span><br></pre></td></tr></table></figure></p>
<p>如果<code>ncpus</code>等于1，则有且仅有一个arena，如果大于1，则默认arenas的数量为<code>ncpus</code>的四倍。即双核下8个arena，四核下16个arena，依此类推。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p ncpus</span><br><span class="line">$<span class="number">20</span> = <span class="number">4</span></span><br><span class="line">(gdb) p narenas_total</span><br><span class="line">$<span class="number">21</span> = <span class="number">16</span></span><br></pre></td></tr></table></figure></p>
<p>jemalloc变体很多，不同变体对arenas的数量有所调整，比如firefox中arena固定为1，而android被限定为最大不超过2. 这个限制被写到android jemalloc的mk文件中。</p>
<h3 id="2-2-3-choose-arena"><a href="#2-2-3-choose-arena" class="headerlink" title="2.2.3 - choose_arena"></a>2.2.3 - choose_arena</h3><p>最早引入arena并非由Je首创，但早期线程与arena绑定是通过hash线程id实现的，相对来说随机性比较强。Je改进了绑定的算法，使之更加科学合理。</p>
<p>Je中线程与arena绑定由函数<code>choose_arena</code>完成，被绑定的arena记录在该线程的tls中，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">JEMALLOC_INLINE <span class="keyword">arena_t</span> *</span><br><span class="line">choose_arena(<span class="keyword">arena_t</span> *arena)</span><br><span class="line">&#123;</span><br><span class="line">    ......    </span><br><span class="line">    <span class="comment">// xf: 通常情况下线程所绑定的arena记录在arenas_tls中</span></span><br><span class="line">    <span class="keyword">if</span> ((ret = *arenas_tsd_get()) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// xf: 如果当前thread未绑定arena，则为其指定一个，并保存到tls</span></span><br><span class="line">        ret = choose_arena_hard();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (ret);</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">初次搜索`arenas_tsd_get`可能找不到该函数在何处被定义。实际上，Je使用了一组宏，来生成一个函数族，以达到类似函数模板的目的。`tsd`相关的函数族被定义在`tsd.h`中。</span><br><span class="line"><span class="number">1.</span> `malloc_tsd_protos` - 定义了函数声明，包括初始化函数boot, get/<span class="built_in">set</span>函数</span><br><span class="line"><span class="number">2.</span> `malloc_tsd_externs` - 定义变量声明，包括tls，初始化标志等等</span><br><span class="line"><span class="number">3.</span> `malloc_tsd_data` - tls变量定义</span><br><span class="line"><span class="number">4.</span> `malloc_tsd_funcs` - 定义了<span class="number">1</span>中声明函数的实现。</span><br><span class="line"></span><br><span class="line">与`arena tsd`相关的函数和变量声明如下，</span><br><span class="line">```C</span><br><span class="line">malloc_tsd_protos(JEMALLOC_ATTR(unused), arenas, <span class="keyword">arena_t</span> *)</span><br><span class="line">malloc_tsd_externs(arenas, <span class="keyword">arena_t</span> *)</span><br><span class="line">malloc_tsd_data(, arenas, <span class="keyword">arena_t</span> *, <span class="literal">NULL</span>)</span><br><span class="line">malloc_tsd_funcs(JEMALLOC_ALWAYS_INLINE, arenas, <span class="keyword">arena_t</span> *, <span class="literal">NULL</span>, arenas_cleanup)</span><br></pre></td></tr></table></figure>
<p>当线程还未与任何arena绑定时，会进一步通过<code>choose_arena_hard</code>寻找一个合适的<code>arena</code>进行绑定。Je会遍历arenas数组，并按照优先级由高到低的顺序挑选，</p>
<ol>
<li>如果找到当前线程绑定数为0的arena，则优先使用它。</li>
<li>如果当前已初始化arena中没有线程绑定数为0的，则优先使用剩余空的数组位置构造一个新的arena. 需要说明的是，arenas数组遵循lazy create原则，初始状态整个数组只有0号元素是被初始化的，其他的slot位置都是null指针。因此随着新的线程不断创造出来，arena数组也被逐渐填满。</li>
<li>如果1，2两条都不满足，则选择当前绑定数最小的，且slot位置更靠前的一个arena。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">arena_t</span> * choose_arena_hard(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (narenas_auto &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        ......</span><br><span class="line">        first_null = narenas_auto;</span><br><span class="line">        <span class="comment">// xf: 循环遍历所有arenas，找到绑定thread数量最小的arena，并记录</span></span><br><span class="line">        <span class="comment">// first_null索引值</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; narenas_auto; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arenas[i] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arenas[i]-&gt;nthreads &lt;</span><br><span class="line">                    arenas[choose]-&gt;nthreads)</span><br><span class="line">                    choose = i;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (first_null == narenas_auto) &#123;</span><br><span class="line">                first_null = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// xf: 若选定的arena绑定thread为0，或者当前arena数组中已满，则返回</span></span><br><span class="line">        <span class="comment">// 被选中的arena</span></span><br><span class="line">        <span class="keyword">if</span> (arenas[choose]-&gt;nthreads == <span class="number">0</span></span><br><span class="line">            || first_null == narenas_auto) &#123;</span><br><span class="line">            ret = arenas[choose];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// xf: 否则构造并初始化一个新的arena</span></span><br><span class="line">            ret = arenas_extend(first_null);</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// xf: 若不存在多于一个arena(单核cpu或人为强制设定)，则返回唯一的</span></span><br><span class="line">        <span class="comment">// 0号arena</span></span><br><span class="line">        ret = arenas[<span class="number">0</span>];</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// xf: 将已绑定的arena设置到tsd中</span></span><br><span class="line">    arenas_tsd_set(&amp;ret);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对比早期的绑定方式，Je的算法显然更加公平，尽可能的让各个cpu核心平分当前线程，平衡负载。</p>
<h3 id="2-2-4-Arena结构"><a href="#2-2-4-Arena结构" class="headerlink" title="2.2.4 - Arena结构"></a>2.2.4 - Arena结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">arena_s</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span>        ind;        </span><br><span class="line">    <span class="keyword">unsigned</span>        nthreads;   </span><br><span class="line">    <span class="keyword">malloc_mutex_t</span>        lock;</span><br><span class="line">    <span class="keyword">arena_stats_t</span>        stats;  </span><br><span class="line">    ql_head(<span class="keyword">tcache_t</span>)    tcache_ql;</span><br><span class="line">    <span class="keyword">uint64_t</span>        prof_accumbytes;</span><br><span class="line">    <span class="keyword">dss_prec_t</span>        dss_prec;   </span><br><span class="line">    <span class="keyword">arena_chunk_tree_t</span>    chunks_dirty;</span><br><span class="line">    <span class="keyword">arena_chunk_t</span>        *spare;</span><br><span class="line">    <span class="keyword">size_t</span>            nactive;</span><br><span class="line">    <span class="keyword">size_t</span>            ndirty;</span><br><span class="line">    <span class="keyword">size_t</span>            npurgatory;</span><br><span class="line">    <span class="keyword">arena_avail_tree_t</span>    runs_avail;</span><br><span class="line">    <span class="keyword">chunk_alloc_t</span>        *chunk_alloc;</span><br><span class="line">    <span class="keyword">chunk_dalloc_t</span>        *chunk_dalloc;</span><br><span class="line">    <span class="keyword">arena_bin_t</span>        bins[NBINS];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>ind</code>: 在arenas数组中的索引值。</li>
<li><code>nthreads</code>: 当前绑定的线程数。</li>
<li><code>lock</code>: 局部arena lock，取代传统分配器的global lock。一般地，如下操作需要arena lock同步，<ul>
<li>线程绑定，需要修改nthreads</li>
<li>new chunk alloc</li>
<li>new run alloc</li>
</ul>
</li>
<li><code>stats</code>: 全局统计，需要打开统计功能。</li>
<li><code>tcache_ql</code>: ring queue，注册所有绑定线程的tcache，作为统计用途，需要打开统计功能。</li>
<li><code>dss_prec</code>: 代表当前chunk alloc时对系统内存的使用策略，分为几种情况，　　　　　</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">  dss_prec_disabled  = <span class="number">0</span>,</span><br><span class="line">  dss_prec_primary   = <span class="number">1</span>,</span><br><span class="line">  dss_prec_secondary = <span class="number">2</span>,</span><br><span class="line">  dss_prec_limit     = <span class="number">3</span></span><br><span class="line">&#125; <span class="keyword">dss_prec_t</span>;</span><br></pre></td></tr></table></figure>
<p>第一个代表禁止使用系统DSS，后两种代表是否优先选用DSS。如果使用<code>primary</code>，则本着先<code>dss-&gt;mmap</code>的顺序，否则按照先<code>mmap-&gt;dss</code>。默认使用<code>dss_prec_secondary</code>。</p>
<ul>
<li><code>chunks_dirty</code>: rb tree，代表所有包含dirty page的chunk集合。后面在chunk中会详细介绍。</li>
<li><code>spare</code>: 是一个缓存变量，记录最近一次被释放的chunk。当arena收到一个新的chunk alloc请求时，会优先从spare中开始查找，由此提高频繁分配释放时，可能导致内部chunk利用率下降的情况。</li>
<li><code>runs_avail</code>: rb tree，记录所有未被分配的runs，用来在分配new run时寻找合适的available run。一般作为alloc run时的仓库。</li>
<li><code>chunk_alloc</code>/<code>chunk_dalloc</code>: 用户可定制的chunk分配/释放函数，Je提供了默认的版本，<code>chunk_alloc_default</code>/<code>chunk_dalloc_default</code></li>
<li><code>bins</code>: bins数组，记录不同class size可用free regions的分配信息，后面会详细介绍。</li>
</ul>
<h2 id="2-3-Chunk-arena-chunk-t"><a href="#2-3-Chunk-arena-chunk-t" class="headerlink" title="2.3 - Chunk (arena_chunk_t)"></a>2.3 - Chunk (arena_chunk_t)</h2><p>chunk是仅次于arena的次级内存结构。如果有了解过Dlmalloc，就会知道在Dl中同样定义了名为’chunk’的基础结构。但这个概念在两个分配器中含义完全不同，Dl中的chunk指代最低级分配单元，而Je中则是一个较大的内存区域。</p>
<h3 id="2-3-1-overview"><a href="#2-3-1-overview" class="headerlink" title="2.3.1 - overview"></a>2.3.1 - overview</h3><p>从前面arena的数据结构可以发现，它是一个非常抽象的概念，其大小也不代表实际的内存分配量。原始的内存数据既非挂载在arena外部，也并没有通过内部指针引用，而是记录在chunk中。按照一般的思路，chunk包含原始内存数据，又从属于arena，因此后者应该会有一个数组之类的结构以记录所有chunk信息。但事实上同样找不到这样的记录。那Je又如何获得chunk指针呢?</p>
<p>所谓的chunk结构，只是整个chunk的一个header，bookkeeping以及user memory都挂在header外面。另外Je对chunk又做了规定，默认每个chunk大小为4MB，同时还必须对齐到4MB的边界上。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>    LG_CHUNK_DEFAULT    22</span></span><br></pre></td></tr></table></figure></p>
<p>这个宏定义了chunk的大小。注意到前缀<code>LG_</code>，代表log即指数部分。Je中所有该前缀的代码都是这个含义，便于通过bit操作进行快速的运算。</p>
<p>有了上述规定，获得chunk就变得几乎没有代价。因为返回给user程序的内存地址肯定属于某个chunk，而该chunk header对齐到4M边界上，且不可能超过4M大小，所以只需要对该地址做一个下对齐就得到chunk指针，如下，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>    CHUNK_ADDR2BASE(a)                        \</span></span><br><span class="line">    ((<span class="keyword">void</span> *)((<span class="keyword">uintptr_t</span>)(a) &amp; ~chunksize_mask))</span><br></pre></td></tr></table></figure></p>
<p>计算相对于chunk header的偏移量，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>    CHUNK_ADDR2OFFSET(a)                        \</span></span><br><span class="line">    ((<span class="keyword">size_t</span>)((<span class="keyword">uintptr_t</span>)(a) &amp; chunksize_mask))</span><br></pre></td></tr></table></figure></p>
<p>以及上对齐到chunk边界的计算，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>    CHUNK_CEILING(s)                        \</span></span><br><span class="line">    (((s) + chunksize_mask) &amp; ~chunksize_mask)</span><br></pre></td></tr></table></figure></p>
<p>用图来表示如下，  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">chunk_ptr(4M aligned)                memory for user</span><br><span class="line"> |                                   |</span><br><span class="line"> v                                   v</span><br><span class="line"> +--------------+--------------------------------------------</span><br><span class="line"> | chunk header |        ... ...     | region |   ... ...     </span><br><span class="line"> +--------------+--------------------------------------------</span><br><span class="line"> |&lt;------------- offset ------------&gt;|</span><br></pre></td></tr></table></figure>
<h3 id="2-3-2-Chunk结构"><a href="#2-3-2-Chunk结构" class="headerlink" title="2.3.2 - Chunk结构"></a>2.3.2 - Chunk结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">arena_chunk_s</span> &#123;</span></span><br><span class="line">    <span class="keyword">arena_t</span>            *arena;</span><br><span class="line">    rb_node(<span class="keyword">arena_chunk_t</span>)    dirty_link;</span><br><span class="line">    <span class="keyword">size_t</span>            ndirty;</span><br><span class="line">    <span class="keyword">size_t</span>            nruns_avail;</span><br><span class="line">    <span class="keyword">size_t</span>            nruns_adjac;</span><br><span class="line">    <span class="keyword">arena_chunk_map_t</span>    <span class="built_in">map</span>[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>arena</code>: chunk属于哪个arena</li>
<li><code>dirty_link</code>: 用于rb tree的链接节点。如果某个chunk内部含有任何dirty page，就会被挂载到arena中的chunks_dirty tree上。</li>
<li><code>ndirty</code>: 内部dirty page数量。</li>
<li><code>nruns_avail</code>: 内部available runs数量。</li>
<li><code>nruns_adjac</code>: available runs又分为dirty和clean两种，相邻的两种run是无法合并的，除非其中的dirty runs通过purge才可以。该数值记录的就是可以通过purge合并的run数量。</li>
<li><code>map</code>: 动态数组，每一项对应chunk中的一个page状态(不包含header即map本身的占用)。chunk(包括内部的run)都是由page组成的。<ul>
<li>page又分为unallocated，small，large三种。</li>
<li>unallocated指的那些还未建立run的page。</li>
<li>small/large分别指代该page所属run的类型是small/large run。</li>
<li>这些page的分配状态，属性，偏移量，及其他的标记信息等等，都记录在arena_chunk_map_t中。</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">|&lt;--------- map_bias -----------&gt;|</span><br><span class="line">| page | page |  ... ...  | page |</span><br><span class="line">+-----------------------------------------------------------------------+</span><br><span class="line">| chunk_header |    chunk <span class="built_in">map</span>    | page #<span class="number">0</span>  | page #<span class="number">1</span>  | ... | page <span class="meta">#n  |</span></span><br><span class="line">|    ... ...   | [<span class="number">0</span>] [<span class="number">1</span>] ... [n] |          |          |     |          |</span><br><span class="line">+-----------------|---|-------|-----------------------------------------+</span><br><span class="line">                  |   |       |       ^          ^                 ^</span><br><span class="line">                  +---|-------|-------+          |                 |</span><br><span class="line">                      +-------|------------------+                 |</span><br><span class="line">                              + -----------------------------------+</span><br></pre></td></tr></table></figure>
<p>至于由chunk header和chunk map占用的page数量，保存在map_bias变量中。该变量是Je在arena boot时通过迭代算法预先计算好的，所有chunk都是相同的。迭代方法如下，</p>
<ol>
<li>第一次迭代初始map_bias等于0，计算最大可能大小，即<code>header_size + chunk_npages * map_size</code>获得header+map需要的page数量，结果肯定高于最终的值。</li>
<li>第二次将之前计算的map_bias迭代回去，将最大page数减去map_bias数，重新计算header+map大小，由于第一次迭代map_bias过大，第二次迭代必定小于最终结果。</li>
<li>第三次再将map_bias迭代回去，得到最终大于第二次且小于第一次的计算结果。</li>
</ol>
<p>相关代码如下，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">arena_boot(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    map_bias = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        header_size = offsetof(<span class="keyword">arena_chunk_t</span>, <span class="built_in">map</span>) +</span><br><span class="line">            (<span class="keyword">sizeof</span>(<span class="keyword">arena_chunk_map_t</span>) * (chunk_npages-map_bias));</span><br><span class="line">        map_bias = (header_size &gt;&gt; LG_PAGE) + ((header_size &amp; PAGE_MASK)</span><br><span class="line">            != <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-3-chunk-map-arena-chunk-map-t"><a href="#2-3-3-chunk-map-arena-chunk-map-t" class="headerlink" title="2.3.3 - chunk map (arena_chunk_map_t)"></a>2.3.3 - chunk map (arena_chunk_map_t)</h3><p>chunk记录page状态的结构为<code>arena_chunk_map_t</code>，为了节省空间，使用了bit压缩存储信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">arena_chunk_map_s</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> JEMALLOC_PROF</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        rb_node(<span class="keyword">arena_chunk_map_t</span>)    rb_link;</span><br><span class="line">        ql_elm(<span class="keyword">arena_chunk_map_t</span>)    ql_link;</span><br><span class="line">    &#125; u;</span><br><span class="line">    <span class="keyword">prof_ctx_t</span>            *prof_ctx;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> JEMALLOC_PROF</span></span><br><span class="line">    &#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">size_t</span>                bits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>chunk map内部包含两个link node，分别可以挂载到rb tree或环形队列上，同时为了节省空间又使用了union。由于run本身也是由连续page组成的，因此chunk map除了记录page状态之外，还负责run的基址检索。</p>
<p>举例来说，Je会把所有已分配run记录在内部rb tree上以快速检索，实际地操作是将该run中第一个page对应的chunk_map作为rb node挂载到tree上。检索时也是先找出将相应的chunk map，再进行地址转换得到run的基址。</p>
<p>按照通常的设计思路，我们可能会把run指针作为节点直接保存到rb tree中。但Je中的设计明显要更复杂。究其原因，如果把link node放到run中，后果是bookkeeping和user memory将混淆在一起，这对于分配器的安全性是很不利的。包括Dl在内的传统分配器都具有这样的缺陷。而如果单独用link node记录run，又会造成空间浪费。</p>
<p>正因为Je中无论是chunk还是run都是连续page组成，所以用首个page对应的chunk map就能同时代表该run的基址。</p>
<p>Je中通常用mapelm换算出pageind，再将<code>pageind &lt;&lt; LG_PAGE + chunk_base</code>，就能得到run指针，代码如下，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">arena_chunk_t</span> *run_chunk = CHUNK_ADDR2BASE(mapelm);</span><br><span class="line"><span class="keyword">size_t</span> pageind = arena_mapelm_to_pageind(mapelm);</span><br><span class="line">run = (<span class="keyword">arena_run_t</span> *)((<span class="keyword">uintptr_t</span>)run_chunk + (pageind &lt;&lt;</span><br><span class="line">    LG_PAGE));</span><br><span class="line"></span><br><span class="line">JEMALLOC_INLINE_C <span class="keyword">size_t</span></span><br><span class="line">arena_mapelm_to_pageind(<span class="keyword">arena_chunk_map_t</span> *mapelm)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uintptr_t</span> map_offset =</span><br><span class="line">        CHUNK_ADDR2OFFSET(mapelm) - offsetof(<span class="keyword">arena_chunk_t</span>, <span class="built_in">map</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ((map_offset / <span class="keyword">sizeof</span>(<span class="keyword">arena_chunk_map_t</span>)) + map_bias);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>chunk map对page状态描述都压缩记录到bits中，由于内容较多，直接引用Je代码中的注释，</p>
<ul>
<li>下面是一个假想的ILP32系统下的bits layout,</li>
<li>???????? ???????? ????nnnn nnnndula</li>
<li>“?”的部分分三种情况，分别对应unallocated, small和large.<ul>
<li>Unallocated: 首尾page写入该run的地址，而内部page则不做要求。</li>
<li>Small: 全部是page的偏移量。</li>
<li>Large: 首page是run size，后续的page不做要求。</li>
</ul>
</li>
<li>n : 对于small run指其所在bin的index，对large run写入BININD_INVALID.</li>
<li>d : dirty?</li>
<li>u : unzeroed?</li>
<li>l : large?</li>
<li><p>a : allocated?</p>
</li>
<li><p>下面是对三种类型的run page做的举例，</p>
<ul>
<li>p : run page offset</li>
<li>s : run size</li>
<li>n : binind for size class; large objects set these to BININD_INVALID</li>
<li>x : don’t care</li>
<li><ul>
<li>: 0</li>
</ul>
</li>
<li><ul>
<li>: 1</li>
</ul>
</li>
<li>[DULA] : bit set</li>
<li>[dula] : bit unset</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Unallocated (clean):</span><br><span class="line">  ssssssss ssssssss ssss++++ ++++du-a</span><br><span class="line">  xxxxxxxx xxxxxxxx xxxxxxxx xxxx-Uxx</span><br><span class="line">  ssssssss ssssssss ssss++++ ++++dU-a</span><br><span class="line"></span><br><span class="line">Unallocated (dirty):</span><br><span class="line">  ssssssss ssssssss ssss++++ ++++D--a</span><br><span class="line">  xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx</span><br><span class="line">  ssssssss ssssssss ssss++++ ++++D--a</span><br><span class="line"></span><br><span class="line">Small:      </span><br><span class="line">  pppppppp pppppppp ppppnnnn nnnnd--A</span><br><span class="line">  pppppppp pppppppp ppppnnnn nnnn---A</span><br><span class="line">  pppppppp pppppppp ppppnnnn nnnnd--A</span><br></pre></td></tr></table></figure>
<p>Small page需要注意的是，这里代表的p并非是一个固定值，而是该page相对于其所在run的第一个page的偏移量，比如可能是这样，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  00000000 00000000 0000nnnn nnnnd--A</span><br><span class="line">  00000000 00000000 0001nnnn nnnn---A</span><br><span class="line">  00000000 00000000 0010nnnn nnnn---A</span><br><span class="line">  00000000 00000000 0011nnnn nnnn---A</span><br><span class="line">  ...</span><br><span class="line">  00000000 00000001 1010nnnn nnnnd--A</span><br><span class="line"></span><br><span class="line">Large:</span><br><span class="line">  ssssssss ssssssss ssss++++ ++++D-LA</span><br><span class="line">  xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx</span><br><span class="line">  -------- -------- ----++++ ++++D-LA</span><br><span class="line"></span><br><span class="line">Large (sampled, size &lt;= PAGE):</span><br><span class="line">  ssssssss ssssssss ssssnnnn nnnnD-LA</span><br><span class="line"></span><br><span class="line">Large (not sampled, size == PAGE):</span><br><span class="line">  ssssssss ssssssss ssss++++ ++++D-LA</span><br></pre></td></tr></table></figure></p>
<p>为了提取/设置map bits内部的信息，Je提供了一组函数，这里列举两个最基本的，剩下的都是读取mapbits后做一些位运算而已，</p>
<p>读取mapbits<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">JEMALLOC_ALWAYS_INLINE <span class="keyword">size_t</span></span><br><span class="line">arena_mapbits_get(<span class="keyword">arena_chunk_t</span> *chunk, <span class="keyword">size_t</span> pageind)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (arena_mapbitsp_read(arena_mapbitsp_get(chunk, pageind)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>根据pageind获取对应的chunk map<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JEMALLOC_ALWAYS_INLINE <span class="keyword">arena_chunk_map_t</span> *</span><br><span class="line">arena_mapp_get(<span class="keyword">arena_chunk_t</span> *chunk, <span class="keyword">size_t</span> pageind)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> (&amp;chunk-&gt;<span class="built_in">map</span>[pageind-map_bias]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="2-4-Run-arena-run-t"><a href="#2-4-Run-arena-run-t" class="headerlink" title="2.4 - Run (arena_run_t)"></a>2.4 - Run (arena_run_t)</h2><p>如同在2.1节所述，在Je中run才是真正负责分配的主体(前提是对small region来说)。run的大小对齐到page size上，并且在内部划分成大小相同的region。当有外部分配请求时，run就会从内部挑选一个free region返回。可以认为run就是small region仓库。</p>
<h3 id="2-4-1-Run结构"><a href="#2-4-1-Run结构" class="headerlink" title="2.4.1 - Run结构"></a>2.4.1 - Run结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">arena_run_s</span> &#123;</span></span><br><span class="line">    <span class="keyword">arena_bin_t</span>    *bin;</span><br><span class="line">    <span class="keyword">uint32_t</span>    nextind;</span><br><span class="line">    <span class="keyword">unsigned</span>    nfree;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>run的结构非常简单，但同chunk类似，所谓的arena_run_t不过是整个run的header部分。</p>
<ul>
<li><code>bin</code>:     与该run相关联的bin。每个run都有其所属的bin，详细内容在之后介绍。</li>
<li><code>nextind</code>: 记录下一个clean region的索引。</li>
<li><code>nfree</code>:   记录当前空闲region数量。</li>
</ul>
<p>除了header部分之外，run的真实layout如下，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">              /--------------------\</span><br><span class="line">              | arena_run_t header |</span><br><span class="line">              | ...                |</span><br><span class="line">bitmap_offset | bitmap             |</span><br><span class="line">              | ...                |</span><br><span class="line">              |--------------------|</span><br><span class="line">              | redzone            |</span><br><span class="line">  reg0_offset | region 0           |</span><br><span class="line">              | redzone            |</span><br><span class="line">              |--------------------| \</span><br><span class="line">              | redzone            |  |</span><br><span class="line">              | region 1           |  &gt; reg_interval</span><br><span class="line">              | redzone            | /</span><br><span class="line">              |--------------------|</span><br><span class="line">              | ...                |</span><br><span class="line">              | ...                |</span><br><span class="line">              | ...                |</span><br><span class="line">              |--------------------|</span><br><span class="line">              | redzone            |</span><br><span class="line">              | region nregs-1     |</span><br><span class="line">              | redzone            |</span><br><span class="line">              |--------------------|</span><br><span class="line">              | alignment pad?     |</span><br><span class="line">              \--------------------/</span><br></pre></td></tr></table></figure></p>
<p>正如chunk通过chunk map记录内部所有page状态一样，run通过在header后挂载bitmap来记录其内部的region状态。bitmap之后是regions区域。内部region大小相等，且在前后都有redzone保护(需要在设置里打开redzone选项)。</p>
<p>简单来说，run就是通过查询bitmap来找到可用的region。而传统分配器由于使用boundary tag，空闲region一般是被双向链表管理的。相比之下，传统方式查找速度更快，也更简单。缺点之前也提到过，安全和稳定性都存在缺陷。从这一点可以看到，Je在设计思路上将bookkeeping和user memory分离是贯穿始终的原则，更甚于对性能的影响(事实上这点影响在并发条件下被大大赚回来了).</p>
<h3 id="2-4-2-size-classes"><a href="#2-4-2-size-classes" class="headerlink" title="2.4.2 - size classes"></a>2.4.2 - size classes</h3><p>内存分配器对内部管理的region往往按照某种特殊规律来分配。比如Dl将内存划分成small和large两种类型。small类型从8字节开始每8个字节为一个分割直至256字节。而large类型则从256字节开始，挂载到dst上。这种划分方式有助于分配器对内存进行有效的管理和控制，让已分配的内存更加紧实(tightly packed)，以降低外部碎片率。</p>
<p>Je进一步优化了分配效率。采用了类似于”二分伙伴(Binary Buddy)算法”的分配方式。在Je中将不同大小的类型称为size class。</p>
<p>在Je源码的size_classes.h文件中，定义了不同体系架构下的region size。该文件实际是通过名为size_classes.sh的shell script自动生成的。script按照四种不同量纲定义来区分各个体系平台的区别，然后将它们做排列组合，就可以兼容各个体系。这四种量纲分别是，</p>
<ul>
<li><code>LG_SIZEOF_PTR</code>: 代表指针长度，ILP32下是2, LP64则是3.</li>
<li><code>LG_QUANTUM</code>: 量子，binary buddy分得的最小单位。除了tiny size，其他的size classes都是quantum的整数倍大小。</li>
<li><code>LG_TINY_MIN</code>: 是比quantum更小的size class，且必须对齐到2的指数倍上。它是Je可分配的最小的size class.</li>
<li><code>LG_PAGE</code>: 就是page大小</li>
</ul>
<p>根据binary buddy算法，Je会将内存不断的二平分，每一份称作一个group。同一个group内又做四等分。例如，一个典型的ILP32, tiny等于8byte, quantum为16byte，page为4096byte的系统，其size classes划分是这样的，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#if (LG_SIZEOF_PTR == 2 &amp;&amp; LG_TINY_MIN == 3 &amp;&amp; LG_QUANTUM == 4 &amp;&amp; LG_PAGE == 12)</span><br><span class="line">#define    SIZE_CLASSES \</span><br><span class="line">    index, lg_grp, lg_delta, ndelta,  bin, lg_delta_lookup  \</span><br><span class="line">    SC(  0,      3,        3,      0,   yes,        3) \        </span><br><span class="line">                                                       \</span><br><span class="line">    SC(  1,      3,        3,      1,   yes,        3) \        </span><br><span class="line">    SC(  2,      4,        4,      1,   yes,        4) \        </span><br><span class="line">    SC(  3,      4,        4,      2,   yes,        4) \        </span><br><span class="line">    SC(  4,      4,        4,      3,   yes,        4) \        </span><br><span class="line">                                                       \</span><br><span class="line">    SC(  5,      6,        4,      1,   yes,        4) \        </span><br><span class="line">    SC(  6,      6,        4,      2,   yes,        4) \        </span><br><span class="line">    SC(  7,      6,        4,      3,   yes,        4) \        </span><br><span class="line">    SC(  8,      6,        4,      4,   yes,        4) \        </span><br><span class="line">                                                       \</span><br><span class="line">    SC(  9,      7,        5,      1,   yes,        5) \        </span><br><span class="line">    SC( 10,      7,        5,      2,   yes,        5) \        </span><br><span class="line">    SC( 11,      7,        5,      3,   yes,        5) \        </span><br><span class="line">    SC( 12,      7,        5,      4,   yes,        5) \        </span><br><span class="line">                                                       </span><br><span class="line">    ... ...</span><br></pre></td></tr></table></figure>
<p>宏SIZE_CLASSES主要功能就是可以生成几种类型的table。而SC则根据不同的情况被定义成不同的含义。SC传入的6个参数的含义如下，</p>
<ul>
<li><code>index</code>:      在table中的位置</li>
<li><code>lg_grp</code>:     所在group的指数</li>
<li><code>lg_delta</code>:   group内偏移量指数</li>
<li><code>ndelta</code>:     group内偏移数</li>
<li><code>bin</code>:        是否由bin记录。small region是记录在bins中</li>
<li><code>lg_delta_lookup</code>:    在lookup table中的调用S2B_#的尾数后缀</li>
</ul>
<p>因此得到reg_size的计算公式，<code>reg_size = 1 &lt;&lt; lg_grp + ndelta &lt;&lt; lg_delta</code>根据该公式，可以得到region的范围，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">┌─────────┬─────────┬───────────────────────────────────────┐</span><br><span class="line">│Category │ Spacing │ Size                                  │</span><br><span class="line">├─────────┼─────────┼───────────────────────────────────────┤</span><br><span class="line">│         │      lg │ [8]                                   │</span><br><span class="line">│         ├─────────┼───────────────────────────────────────┤</span><br><span class="line">│         │      16 │ [16, 32, 48, ..., 128]                │</span><br><span class="line">│         ├─────────┼───────────────────────────────────────┤</span><br><span class="line">│         │      32 │ [160, 192, 224, 256]                  │</span><br><span class="line">│         ├─────────┼───────────────────────────────────────┤</span><br><span class="line">│Small    │      64 │ [320, 384, 448, 512]                  │</span><br><span class="line">│         ├─────────┼───────────────────────────────────────┤</span><br><span class="line">│         │     128 │ [640, 768, 896, 1024]                 │</span><br><span class="line">│         ├─────────┼───────────────────────────────────────┤</span><br><span class="line">│         │     256 │ [1280, 1536, 1792, 2048]              │</span><br><span class="line">│         ├─────────┼───────────────────────────────────────┤</span><br><span class="line">│         │     512 │ [2560, 3072, 3584]                    │</span><br><span class="line">├─────────┼─────────┼───────────────────────────────────────┤</span><br><span class="line">│Large    │   4 KiB │ [4 KiB, 8 KiB, 12 KiB, ..., 4072 KiB] │</span><br><span class="line">├─────────┼─────────┼───────────────────────────────────────┤</span><br><span class="line">│Huge     │   4 MiB │ [4 MiB, 8 MiB, 12 MiB, ...]           │</span><br><span class="line">└─────────┴─────────┴───────────────────────────────────────┘</span><br></pre></td></tr></table></figure>
<p>除此之外，在<code>size_classes.h</code>中还定义了一些常量，</p>
<p>tiny bins的数量<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>    NTBINS            1</span></span><br><span class="line">``</span><br><span class="line"></span><br><span class="line">可以通过lookup table查询的bins数量</span><br><span class="line">```C</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>    NLBINS            29</span></span><br></pre></td></tr></table></figure></p>
<p>small bins的数量<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>    NBINS            28</span></span><br></pre></td></tr></table></figure></p>
<p>最大tiny size class的指数<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>    LG_TINY_MAXCLASS    3</span></span><br></pre></td></tr></table></figure></p>
<p>最大lookup size class，也就是NLBINS - 1个bins<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>    LOOKUP_MAXCLASS        ((((size_t)1) &lt;&lt; 11) + (((size_t)4) &lt;&lt; 9))</span></span><br></pre></td></tr></table></figure></p>
<p>最大small size class，也就是NBINS - 1个bins<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>    SMALL_MAXCLASS        ((((size_t)1) &lt;&lt; 11) + (((size_t)3) &lt;&lt; 9))</span></span><br></pre></td></tr></table></figure></p>
<h3 id="2-4-3-size2bin-bin2size"><a href="#2-4-3-size2bin-bin2size" class="headerlink" title="2.4.3 - size2bin/bin2size"></a>2.4.3 - size2bin/bin2size</h3><p>通过SIZE_CLASSES建立的table就是为了在O(1)的时间复杂度内快速进行size2bin或者bin2size切换。同样的技术在Dl中有所体现，来看Je是如何实现的。</p>
<p>size2bin切换提供了两种方式，较快的是通过查询lookup table，较慢的是计算得到。从原理上，只有small size class需要查找bins，但可通过lookup查询的size class数量要小于整个small size class数量。因此，部分size class只能计算得到。在原始Je中统一只采用查表法，但在android版本中可能是考虑减小lookup table size，而增加了直接计算法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">JEMALLOC_ALWAYS_INLINE <span class="keyword">size_t</span></span><br><span class="line">small_size2bin(<span class="keyword">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (size &lt;= LOOKUP_MAXCLASS)</span><br><span class="line">        <span class="keyword">return</span> (small_size2bin_lookup(size));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> (small_size2bin_compute(size));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>小于LOOKUP_MAXCLASS的请求通过small_size2bin_lookup直接查表。查询的算法是这样的，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> ret = ((<span class="keyword">size_t</span>)(small_size2bin_tab[(size<span class="number">-1</span>) &gt;&gt; LG_TINY_MIN]));</span><br></pre></td></tr></table></figure></p>
<p>也就是说，Je通过一个<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(x) = (x - <span class="number">1</span>) / <span class="number">2</span>^LG_TINY_MIN</span><br></pre></td></tr></table></figure></p>
<p>的变换将size映射到lookup table的相应区域。这个table在gdb中可能是这样的，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p  /d small_size2bin</span><br><span class="line">$6 = &#123;0, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 9, 9, 10, 10, 10, 10,</span><br><span class="line">      11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14,</span><br><span class="line">      14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16,</span><br><span class="line">      16, 16, 17 &lt;repeats 16 times&gt;, 18 &lt;repeats 16 times&gt;, 19 &lt;repeats 16 times&gt;,</span><br><span class="line">      20 &lt;repeats 16 times&gt;, 21 &lt;repeats 32 times&gt;, 22 &lt;repeats 32 times&gt;,</span><br><span class="line">      23 &lt;repeats 32 times&gt;, 24 &lt;repeats 32 times&gt;, 25 &lt;repeats 64 times&gt;,</span><br><span class="line">      26 &lt;repeats 64 times&gt;, 27 &lt;repeats 64 times&gt;&#125;</span><br></pre></td></tr></table></figure>
<p>该数组的含义与binary buddy算法是一致的。对应的bin index越高，其在数组中占用的字节数就越多。除了0号bin之外，相邻的4个bin属于同一group，两个group之间相差二倍，因此在数组中占用的字节数也就相差2倍。所以，上面数组的group划分如下，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;, &#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;, &#123;<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>&#125;, &#123;<span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>&#125;, ...</span><br></pre></td></tr></table></figure></p>
<p>以bin#9为例，其所管辖的范围(128, 160]，由于其位于更高一级group，因此相比bin#8在lookup table中多一倍的字节数，假设我们需要查询132，经过映射，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">132</span> - <span class="number">1</span>) &gt;&gt; <span class="number">3</span> = <span class="number">16</span></span><br></pre></td></tr></table></figure></p>
<p>这样可以快速得到其所在的bin #9。如图，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    bin #1     bin #3          132 is HERE!</span><br><span class="line">       |          |                |</span><br><span class="line">       v          v                v</span><br><span class="line"> +----------------------------------------------------------------</span><br><span class="line"> | 0 | 1 | 2 2 | 3 3 | ... | 8 8 | 9 9 9 9 | ... | 16 ... 16 | ...</span><br><span class="line"> +----------------------------------------------------------------</span><br><span class="line">   ^        ^                 ^       ^                ^</span><br><span class="line">   |        |                 |       |                |</span><br><span class="line">bin #0    bin #2            bin #8  bin #9          bin #16</span><br></pre></td></tr></table></figure>
<p>Je巧妙的通过前面介绍CLASS_SIZE宏生成了这个lookup table，代码如下，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">JEMALLOC_ALIGNED(CACHELINE)</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint8_t</span>    small_size2bin_tab[] = &#123;</span><br><span class="line">#define    S2B_3(i)    i,</span><br><span class="line">#define    S2B_4(i)    S2B_3(i) S2B_3(i)</span><br><span class="line">#define    S2B_5(i)    S2B_4(i) S2B_4(i)</span><br><span class="line">#define    S2B_6(i)    S2B_5(i) S2B_5(i)</span><br><span class="line">#define    S2B_7(i)    S2B_6(i) S2B_6(i)</span><br><span class="line">#define    S2B_8(i)    S2B_7(i) S2B_7(i)</span><br><span class="line">#define    S2B_9(i)    S2B_8(i) S2B_8(i)</span><br><span class="line">#define    S2B_no(i)</span><br><span class="line">#define    SC(index, lg_grp, lg_delta, ndelta, bin, lg_delta_lookup) \</span><br><span class="line">    S2B_##lg_delta_lookup(index)</span><br><span class="line">    SIZE_CLASSES</span><br><span class="line">#undef S2B_3</span><br><span class="line">#undef S2B_4</span><br><span class="line">#undef S2B_5</span><br><span class="line">#undef S2B_6</span><br><span class="line">#undef S2B_7</span><br><span class="line">#undef S2B_8</span><br><span class="line">#undef S2B_9</span><br><span class="line">#undef S2B_no</span><br><span class="line">#undef SC</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里的S2B_xx是一系列宏的嵌套展开，最终对应的就是不同group在lookup table中占据的字节数以及bin索引。相信看懂了前面的介绍就不难理解。</p>
<p>另一方面，大于LOOKUP_MAXCLASS但小于SMALL_MAXCLASS的size class不能查表获得，需要进行计算。简言之，一个bin number是三部分组成的，</p>
<p><code>bin_number = NTBIN + group_number &lt;&lt; LG_SIZE_CLASS_GROUP + mod</code></p>
<p>即tiny bin数量加上其所在group再加上group中的偏移(0-2)。源码如下，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">JEMALLOC_INLINE <span class="keyword">size_t</span></span><br><span class="line">small_size2bin_compute(<span class="keyword">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// xf: lg_floor相当于ffs</span></span><br><span class="line">        <span class="keyword">size_t</span> x = lg_floor((size&lt;&lt;<span class="number">1</span>)<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// xf: 计算size class所在group number</span></span><br><span class="line">        <span class="keyword">size_t</span> shift = (x &lt; LG_SIZE_CLASS_GROUP + LG_QUANTUM) ? <span class="number">0</span> :</span><br><span class="line">            x - (LG_SIZE_CLASS_GROUP + LG_QUANTUM);</span><br><span class="line">        <span class="keyword">size_t</span> grp = shift &lt;&lt; LG_SIZE_CLASS_GROUP;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">size_t</span> lg_delta = (x &lt; LG_SIZE_CLASS_GROUP + LG_QUANTUM + <span class="number">1</span>)</span><br><span class="line">            ? LG_QUANTUM : x - LG_SIZE_CLASS_GROUP - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">size_t</span> delta_inverse_mask = ZI(<span class="number">-1</span>) &lt;&lt; lg_delta;</span><br><span class="line">        <span class="comment">// xf: 计算剩余mod部分</span></span><br><span class="line">        <span class="keyword">size_t</span> mod = ((((size<span class="number">-1</span>) &amp; delta_inverse_mask) &gt;&gt; lg_delta)) &amp;</span><br><span class="line">            ((ZU(<span class="number">1</span>) &lt;&lt; LG_SIZE_CLASS_GROUP) - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// xf: 组合计算bin number</span></span><br><span class="line">        <span class="keyword">size_t</span> bin = NTBINS + grp + mod;</span><br><span class="line">        <span class="keyword">return</span> (bin);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中LG_SIZE_CLASS_GROUP是size_classes.h中的定值，代表一个group中包含的bin数量，根据binary buddy算法，该值通常情况下是2。而要找到size class所在的group，与其最高有效位相关。Je通过类似于ffs的函数<br>首先获得size的最高有效位x<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> x = lg_floor((size&lt;&lt;<span class="number">1</span>)<span class="number">-1</span>);</span><br></pre></td></tr></table></figure></p>
<p>至于group number，则与quantum size有关。因为除了tiny class, quantum size位于group #0的第一个。因此不难推出，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">group_number = <span class="number">2</span>^x / quantum_size / <span class="number">2</span>^LG_SIZE_CLASS_GROUP</span><br></pre></td></tr></table></figure></p>
<p>对应代码就是，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> shift = (x &lt; LG_SIZE_CLASS_GROUP + LG_QUANTUM) ? <span class="number">0</span> :</span><br><span class="line">        x - (LG_SIZE_CLASS_GROUP + LG_QUANTUM);</span><br></pre></td></tr></table></figure></p>
<p>而对应group起始位置就是，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> grp = shift &lt;&lt; LG_SIZE_CLASS_GROUP;</span><br></pre></td></tr></table></figure></p>
<p>至于mod部分，与之相关的是最高有效位之后的两个bit。Je在这里经过了复杂的位变换，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> lg_delta = (x &lt; LG_SIZE_CLASS_GROUP + LG_QUANTUM + <span class="number">1</span>) ? LG_QUANTUM : x - LG_SIZE_CLASS_GROUP - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">size_t</span> delta_inverse_mask = ZI(<span class="number">-1</span>) &lt;&lt; lg_delta;</span><br><span class="line"><span class="keyword">size_t</span> mod = ((((size<span class="number">-1</span>) &amp; delta_inverse_mask) &gt;&gt; lg_delta)) &amp; ((ZU(<span class="number">1</span>) &lt;&lt; LG_SIZE_CLASS_GROUP) - <span class="number">1</span>);</span><br></pre></td></tr></table></figure></p>
<p>上面代码直白的翻译，实际上就是要求得如下两个bit,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">                        1 0000</span><br><span class="line">                       10 0000</span><br><span class="line">                       11 0000</span><br><span class="line">group #0              100 0000</span><br><span class="line">-------------------------------------------------</span><br><span class="line">                                      +--+</span><br><span class="line">                      101 0000 - 1 = 1|00| 1111</span><br><span class="line">                      110 0000 - 1 = 1|01| 1111</span><br><span class="line">                      111 0000 - 1 = 1|10| 1111</span><br><span class="line">group #1             1000 0000 - 1 = 1|11| 1111</span><br><span class="line">                                      +--+</span><br><span class="line">--------------------------------------------------                                         </span><br><span class="line">                                      +--+</span><br><span class="line">                     1010 0000 - 1 = 1|00|1 1111    </span><br><span class="line">                     1100 0000 - 1 = 1|01|1 1111</span><br><span class="line">                     1110 0000 - 1 = 1|10|1 1111</span><br><span class="line">group #2            10000 0000 - 1 = 1|11|1 1111</span><br><span class="line">                                      +--+</span><br><span class="line">--------------------------------------------------</span><br></pre></td></tr></table></figure>
<p>根据这个图示再去看Je的代码就不难理解了。mod的计算结果就是从0-3的数值。</p>
<p>而最终的结果是前面三部分的组合即，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> bin = NTBINS + grp + mod;</span><br></pre></td></tr></table></figure></p>
<p>而bin2size查询就简单得多。上一节介绍SIZE_CLASSES时提到过small region的计算公式，只需要根据该公式提前计算出所有bin对应的region size，直接查表即可。</p>
<h2 id="2-5-bins-arena-bin-t"><a href="#2-5-bins-arena-bin-t" class="headerlink" title="2.5 - bins (arena_bin_t)"></a>2.5 - bins (arena_bin_t)</h2><p>run是分配的执行者，而分配的调度者是bin。这个概念同Dl中的bin是类似的，但Je中bin要更复杂一些。直白地说，可以把bin看作non-full run的仓库，bin负责记录当前arena中某一个size class范围内所有non-full run的使用情况。当有分配请求时，arena查找相应size class的bin，找出可用于分配的run，再由run分配region。当然，因为只有small region分配需要run，所以bin也只对应small size class。</p>
<p>与bin相关的数据结构主要有两个，分别是arena_bin_t和arena_bin_info_t。在2.1.3中提到arena_t内部保存了一个bin数组，其中的成员就是arena_bin_t。其结构如下，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">arena_bin_s</span> &#123;</span></span><br><span class="line">    <span class="keyword">malloc_mutex_t</span>        lock;    </span><br><span class="line">    <span class="keyword">arena_run_t</span>            *runcur;</span><br><span class="line">    <span class="keyword">arena_run_tree_t</span>    runs;</span><br><span class="line">    <span class="keyword">malloc_bin_stats_t</span>  stats;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>lock</code>: 该lock同arena内部的lock不同，主要负责保护current run。而对于run本身的分配和释放还是需要依赖arena lock。通常情况下，获得bin lock的前提是获得arena lock，但反之不成立。</li>
<li><code>runcur</code>: 当前可用于分配的run，一般情况下指向地址最低的non-full run，同一时间一个bin只有一个current run用于分配。</li>
<li><code>runs</code>: rb tree，记录当前arena中该bin对应size class的所有non-full runs。因为分配是通过current run完成的，所以也相当于current run的仓库。</li>
<li><code>stats</code>: 统计信息。</li>
</ul>
<p>另一个与bin相关的结构是arena_bin_info_t。与前者不同，bin_info保存的是arena_bin_t的静态信息，包括相对应size class run的bitmap offset，region size，region number，bitmap info等等(此类信息只要class size决定，就固定下来)。所有上述信息在Je中由全局数组arena_bin_info记录。因此与arena无关，全局仅保留一份。</p>
<p>arena_bin_info_t的定义如下，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">arena_bin_info_s</span> &#123;</span></span><br><span class="line">    <span class="keyword">size_t</span>        reg_size;</span><br><span class="line">    <span class="keyword">size_t</span>        redzone_size;</span><br><span class="line">    <span class="keyword">size_t</span>        reg_interval;</span><br><span class="line">    <span class="keyword">size_t</span>        run_size;</span><br><span class="line">    <span class="keyword">uint32_t</span>    nregs;</span><br><span class="line">    <span class="keyword">uint32_t</span>    bitmap_offset;</span><br><span class="line">    <span class="keyword">bitmap_info_t</span>    bitmap_info;</span><br><span class="line">    <span class="keyword">uint32_t</span>    reg0_offset;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>reg_size</code>: 与当前bin的size class相关联的region size.</li>
<li><code>reg_interval</code>: reg_size+redzone_size</li>
<li><code>run_size</code>: 当前bin的size class相关联的run size.</li>
<li><code>nregs</code>: 当前bin的size class相关联的run中region数量。</li>
<li><code>bitmap_offset</code>: 当前bin的size class相关联的run中bitmap偏移。</li>
<li><code>bitmap_info</code>: 记录当前bin的size class相关联的run中bitmap信息。</li>
<li><code>reg0_offset</code>: index为0的region在run中的偏移量。</li>
</ul>
<p>以上记录的静态信息中尤为重要的是bitmap_info和bitmap_offset.</p>
<p>其中bitmap_info_t定义如下，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bitmap_info_s</span> &#123;</span></span><br><span class="line">    <span class="keyword">size_t</span> nbits;</span><br><span class="line">    <span class="keyword">unsigned</span> nlevels;</span><br><span class="line">    <span class="keyword">bitmap_level_t</span> levels[BITMAP_MAX_LEVELS+<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>nbits</code>: bitmap中逻辑bit位数量(特指level#0的bit数)</li>
<li><code>nlevels</code>: bitmap的level数量</li>
<li><code>levels</code>: level偏移量数组，每一项记录该级level在bitmap中的起始index</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bitmap_level_s</span> &#123;</span></span><br><span class="line">    <span class="keyword">size_t</span> group_offset;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在2.3.1节中介绍arena_run_t时曾提到Je通过外挂bitmap将bookkeeping和user memory分离。但bitmap查询速度要慢于boundary tag。为了弥补这个缺陷，Je对此做了改进，通过多级level缓冲以替代线性查找。</p>
<p>Je为bitmap增加了多级level, bottom level同普通bitmap一致，每1bit代表一个region。而高一级level中1bit代表前一级level中一个byte。譬如说，若我们在当前run中存在128个region，则在ILP32系统上，需要128/32 = 4byte来表示这128个region。Je将这4个byte看作level #0。为了进一步表示这4个字节是否被占用，又额外需要1byte以缓存这4byte的内容(仅使用了4bit)，此为level#1。即整个bitmap，一共有2级level，共5byte来描述。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">                  +--------------+              +--------+</span><br><span class="line">      +-----------|------------ +|   +----------|-------+|</span><br><span class="line">      v           v             ||   v          v       ||</span><br><span class="line">+--------------------------------------------------------------------------</span><br><span class="line">| 1101 0010 | 0000 0000 | ... | 10?? ???? | ???? ???? | 1??? ????    | ...</span><br><span class="line">+--------------------------------------------------------------------------</span><br><span class="line">|&lt;--------- level #0 --------&gt;|&lt;----- level #1 ------&gt;|&lt;- level #2 -&gt;|</span><br></pre></td></tr></table></figure>
<h2 id="2-6-Thread-caches-tcache-t"><a href="#2-6-Thread-caches-tcache-t" class="headerlink" title="2.6 - Thread caches (tcache_t)"></a>2.6 - Thread caches (tcache_t)</h2><p>TLS/TSD是另一种针对多线程优化使用的分配技术，Je中称为tcache。tcache解决的是同一cpu core下不同线程对heap的竞争。通过为每个线程指定专属分配区域，来减小线程间的干扰。但显然这种方法会增大整体内存消耗量。为了减小副作用，je将tcache设计成一个bookkeeping结构，在tcache中保存的仅仅是指向外部region的指针，region对象仍然位于各个run当中。换句话说，如果一个region被tcache记录了，那么从run的角度看，它就已经被分配了。</p>
<p>tcache的内容如下，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcache_s</span> &#123;</span></span><br><span class="line">    ql_elm(<span class="keyword">tcache_t</span>) link;        </span><br><span class="line">    <span class="keyword">uint64_t</span>         prof_accumbytes;</span><br><span class="line">    <span class="keyword">arena_t</span>             *arena;        </span><br><span class="line">    <span class="keyword">unsigned</span>         ev_cnt;        </span><br><span class="line">    <span class="keyword">unsigned</span>         next_gc_bin;    </span><br><span class="line">    <span class="keyword">tcache_bin_t</span>     tbins[<span class="number">1</span>];    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>link</code>: 链接节点，用于将同一个arena下的所有tcache链接起来。</li>
<li><code>prof_accumbytes</code>: memory profile相关。</li>
<li><code>arena</code>: 该tcache所属的arena指针。</li>
<li><code>ev_cnt</code>: 是tcache内部的一个周期计数器。每当tcache执行一次分配或释放时，ev_cnt会记录一次。直到周期到来，Je会执行一次incremental gc.这里的gc会清理tcache中多余的region，将它们释放掉。尽管这不意味着系统内存会获得释放，但可以解放更多的region交给其他更饥饿的线程以分配。</li>
<li><code>next_gc_bin</code>: 指向下一次gc的binidx。tcache gc按照一周期清理一个bin执行。</li>
<li><code>tbins</code>: tcache bin数组。同样外挂在tcache后面。</li>
</ul>
<p>同arena bin类似，tcache同样有tcache_bin_t和tcache_bin_info_t。tcache_bin_t作用类似于arena bin，但其结构要比后者更简单。准确的说，tcache bin并没有分配调度的功能，而仅起到记录作用。其内部通过一个stack记录指向外部arena run中的region指针。而一旦region被cache到tbins内，就不能再被其他任何线程所使用，尽管它可能甚至与其他线程tcache中记录的region位于同一个arena run中。</p>
<p>tcache bin结构如下，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcache_bin_s</span> &#123;</span></span><br><span class="line">    <span class="keyword">tcache_bin_stats_t</span> tstats;</span><br><span class="line">    <span class="keyword">int</span>     low_water;</span><br><span class="line">    <span class="keyword">unsigned</span>    lg_fill_div;</span><br><span class="line">    <span class="keyword">unsigned</span>    ncached;</span><br><span class="line">    <span class="keyword">void</span>        **avail;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>tstats</code>: tcache bin内部统计。</li>
<li><code>low_water</code>: 记录两次gc间tcache内部使用的最低水线。该数值与下一次gc时尝试释放的region数量有关。释放量相当于low water数值的3/4.</li>
<li><code>lg_fill_div</code>: 用作tcache refill时作为除数。当tcache耗尽时，会请求arena run进行refill。但refill不会一次性灌满tcache，而是依照其最大容量缩小2^lg_fill_div的倍数。该数值同low_water一样是动态的，两者互相配合确保tcache处于一个合理的充满度。</li>
<li><code>ncached</code>: 指当前缓存的region数量，同时也代表栈顶index.</li>
<li><code>avail</code>: 保存region指针的stack，称为avail-stack.</li>
</ul>
<p>tcache_bin_info_t保存tcache bin的静态信息。其本身只保存了tcache max容量。该数值是在tcache boot时根据相对应的arena bin的nregs决定的。通常等于nregs的二倍，但不得超过TCACHE_NSLOTS_SMALL_MAX。该数值默认为200，但在android中大大提升了该限制，small bins不得超过8, large bins则为16.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcache_bin_info_s</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span>    ncached_max;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>tcache layout如下，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">                +---------------+</span><br><span class="line">              / | link          |</span><br><span class="line">   tcache_t  &lt;  | next_gc_bin   |</span><br><span class="line">              \ | ...           |</span><br><span class="line">                |---------------|</span><br><span class="line">              / | tstats        |</span><br><span class="line">   tbins[0]  &lt;  | ...           |</span><br><span class="line">              | | ncached       |</span><br><span class="line">              \ | avail --------------+</span><br><span class="line">                |---------------|     |</span><br><span class="line">                | ...           |     |  </span><br><span class="line">                | ...           |     |  </span><br><span class="line">                | ...           |     |  </span><br><span class="line">                |---------------|     |</span><br><span class="line">              / | tstats        |     |</span><br><span class="line">  tbins[nhb  &lt;  | ...           |     |</span><br><span class="line">     ins]     | | ncached       |     |                   </span><br><span class="line">              \ | avail --------------|---+               </span><br><span class="line">                |---------------|     |   |               current arena run</span><br><span class="line">                | padding       |     |   |               +----------------+      </span><br><span class="line">                |---------------| &lt;---+   |               | run header     |</span><br><span class="line">              / | stack[0]      |         |               | ...            |</span><br><span class="line">avail-stack  &lt;  | stack[1]      |         |               | bitmap         |</span><br><span class="line">for tbins[0]  | | ...           |         |               | ...            |</span><br><span class="line">              | | ...           |         |               |----------------|</span><br><span class="line">              | | stack[ncached |         |               | region #0      |</span><br><span class="line">              \ | _max - 1]     |         |               | ...            |</span><br><span class="line">                |---------------|         |               |----------------|</span><br><span class="line">                | ...           |         |    +--------&gt; | region #1      |</span><br><span class="line">                | ...           |         |    |          | ...            |</span><br><span class="line">                | ...           |         |    |          |----------------|</span><br><span class="line">                |---------------| &lt;-------+    |          | ...            |</span><br><span class="line">avail-stack   / | stack[0]      |--------------|--+       | ...            |</span><br><span class="line">for tbins[   &lt;  | ...           |              |  |       |----------------|</span><br><span class="line"> nhbins]      | | stack[n]      |--------------|--|-----&gt; | region #n      |</span><br><span class="line">              | | ...           |              |  |       | ...            |</span><br><span class="line">              | | stack[ncached |              |  |       |----------------|</span><br><span class="line">              \ | _max - 1]     |--------------+  |       | ...            |</span><br><span class="line">                +---------------+                 |       | ...            |</span><br><span class="line">                                                  |       |----------------|</span><br><span class="line">                                                  +-----&gt; | region #nregs-1|</span><br><span class="line">                                                          | ...            |</span><br><span class="line">                                                          +----------------+</span><br></pre></td></tr></table></figure>
<h2 id="2-7-Extent-Node-extent-node-t"><a href="#2-7-Extent-Node-extent-node-t" class="headerlink" title="2.7 - Extent Node (extent_node_t)"></a>2.7 - Extent Node (extent_node_t)</h2><p>extent node代表huge region，即大于chunk大小的内存单元。同arena run不同，extent node并非是一个header构造，而是外挂的。因此其本身仍属small region。只不过并不通过bin分配，而由base_nodes直接动态创建。</p>
<p>Je中对所有huge region都是通过rb tree管理。因此extent node同时也是tree node。一个node节点被同时挂载到两棵rb tree上。一棵采用szad的查询方式，另一棵则采用纯ad的方式。作用是当执行chunk recycle时查询到可用region，后面会详述。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">extent_node_s</span> &#123;</span></span><br><span class="line">    rb_node(<span class="keyword">extent_node_t</span>)    link_szad;</span><br><span class="line">    rb_node(<span class="keyword">extent_node_t</span>)    link_ad;</span><br><span class="line">    <span class="keyword">prof_ctx_t</span>        *prof_ctx;</span><br><span class="line">    <span class="keyword">void</span>            *addr;</span><br><span class="line">    <span class="keyword">size_t</span>            size;</span><br><span class="line">    <span class="keyword">arena_t</span>            *arena;</span><br><span class="line">    <span class="keyword">bool</span>            zeroed;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>link_szad</code>: szad tree的link节点。</li>
<li><code>link_ad</code>: ad tree的link节点。</li>
<li><code>prof_ctx</code>: 用于memory profile.</li>
<li><code>addr</code>: 指向huge region的指针。</li>
<li><code>size</code>: region size.</li>
<li><code>arena</code>: huge region所属arena.</li>
<li><code>zeroed</code>: 代表是否zero-filled, chunk recycle时会用到。</li>
</ul>
<h2 id="2-8-Base"><a href="#2-8-Base" class="headerlink" title="2.8 - Base"></a>2.8 - Base</h2><p>base并不是数据类型，而是一块特殊区域，主要服务于内部meta data(例如arena_t，tcache_t，extent_node_t等等)的分配。base区域管理与如下变量相关，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">malloc_mutex_t</span>    base_mtx;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span>        *base_pages;    </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span>        *base_next_addr;     </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span>        *base_past_addr;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">extent_node_t</span>    *base_nodes;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>base_mtx</code>:       base lock</li>
<li><code>base_pages</code>:     base page指针，代表整个区域的起始位置。</li>
<li><code>base_next_addr</code>: 当前base指针，类似于brk指针。</li>
<li><code>base_past_addr</code>: base page的上限指针。</li>
<li><code>base_nodes</code>:     指向extent_node_t链表的外挂头指针。</li>
</ul>
<p>base page源于arena中的空闲chunk，通常情况下，大小相当于chunk。当base耗尽时，会以chunk alloc的名义重新申请新的base pages。 </p>
<p>为了保证内部meta data的快速分配和访问。Je将内部请求大小都对齐到cache-line上，以避免在SMP下的false sharing。而分配方式上，采用了快速移动base_next_addr指针进行高速开采的方法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *</span><br><span class="line">base_alloc(<span class="keyword">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// xf: 将内部分配请求对齐的cache-line上，阻止false sharing</span></span><br><span class="line">    csize = CACHELINE_CEILING(size);</span><br><span class="line"></span><br><span class="line">    malloc_mutex_lock(&amp;base_mtx);</span><br><span class="line">    <span class="comment">// xf: 如果base耗尽，则重新分配base_pages。默认大小为chunksize.</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">uintptr_t</span>)base_next_addr + csize &gt; (<span class="keyword">uintptr_t</span>)base_past_addr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (base_pages_alloc(csize)) &#123;</span><br><span class="line">            malloc_mutex_unlock(&amp;base_mtx);</span><br><span class="line">            <span class="keyword">return</span> (<span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// xf: 快速向前开采</span></span><br><span class="line">    ret = base_next_addr;</span><br><span class="line">    base_next_addr = (<span class="keyword">void</span> *)((<span class="keyword">uintptr_t</span>)base_next_addr + csize);</span><br><span class="line">    malloc_mutex_unlock(&amp;base_mtx);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与通常的base alloc有所不同，分配extent_node_t会优先从一个node链表中获取节点，而base_nodes则为该链表的外挂头指针。只有当其耗尽时，才使用前面的分配方式。这里区别对待extent_node_t与其他类型，主要与chunk recycle机制有关，后面会做详细说明。有意思的是，该链表实际上借用了extent node内部rb tree node的左子树节点指针作为其link指针。如2.7节所述，extent_node_t结构的起始位置存放一个rb node.但在这里，当base_nodes赋值给ret后，会强制将ret转型成(extent_node_t **),实际上就是指向extent_node_t结构体的第一个field的指针，并将其指向的node指针记录到base_nodes里，成为新的header节点。这里需要仔细体会这个强制类型转换的巧妙之处。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ret = base_nodes</span><br><span class="line">     |</span><br><span class="line">     v   +---- (extent_node_t**)ret</span><br><span class="line">     +---|------------------------------ +</span><br><span class="line">     |   |              extent_node      |</span><br><span class="line">     | +-|-------------------------+     |</span><br><span class="line">     | | v       rb_node           |     |</span><br><span class="line">     | | +----------+-----------+  |     |</span><br><span class="line">     | | | rbn_left | rbn_right |  | ... |</span><br><span class="line">     | | +----------+-----------+  |     |</span><br><span class="line">     | +-------|-------------------+     |</span><br><span class="line">     +---------|-------------------------+</span><br><span class="line">               v</span><br><span class="line">base_nodes---&gt; +---------------+</span><br><span class="line">               | extent_node   |</span><br><span class="line">               +---------------+</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extent_node_t</span> *</span><br><span class="line">base_node_alloc(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">extent_node_t</span> *ret;</span><br><span class="line"></span><br><span class="line">    malloc_mutex_lock(&amp;base_mtx);</span><br><span class="line">    <span class="keyword">if</span> (base_nodes != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ret = base_nodes;</span><br><span class="line">        <span class="comment">// xf: 这里也可以理解为，base_nodes = (extent_node_t*)(*ret);</span></span><br><span class="line">        base_nodes = *(<span class="keyword">extent_node_t</span> **)ret;</span><br><span class="line">        malloc_mutex_unlock(&amp;base_mtx);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        malloc_mutex_unlock(&amp;base_mtx);</span><br><span class="line">        ret = (<span class="keyword">extent_node_t</span> *)base_alloc(<span class="keyword">sizeof</span>(<span class="keyword">extent_node_t</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="3-Allocation"><a href="#3-Allocation" class="headerlink" title="3 - Allocation"></a>3 - Allocation</h1><h2 id="3-1-Overview"><a href="#3-1-Overview" class="headerlink" title="3.1 - Overview"></a>3.1 - Overview</h2><p>在2.3.2节中得知，Je将size class划分成small, large, huge三种类型。分配时这三种类型分别按照不同的算法执行。后面的章节也将按照这个类型顺序描述。</p>
<p>总体来说，Je分配函数从je_malloc入口开始，经过，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">je_malloc -&gt; imalloc_body -&gt; imalloc -&gt; imalloct ---&gt; arena_malloc</span><br><span class="line">                                                  |                  </span><br><span class="line">                                                  +-&gt; huge_malloc</span><br></pre></td></tr></table></figure></p>
<p>实际执行分配的分别是对应small/large的arena malloc和对应huge的huge malloc。分配算法可以概括如下，</p>
<ol>
<li>首先检查Je是否初始化，如果没有则初始化Je，并标记全局malloc_initialized标记。</li>
<li>检查请求size是否大于huge，如果是则执行8，否则进入下一步。</li>
<li>执行arena_malloc，首先检查size是否小于等于small maxclass，如果是则下一步，否则执行6.</li>
<li>如果允许且当前线程已绑定tcache，则从tcache分配small，并返回。否则下一步。</li>
<li>choose arena，并执行arena malloc small，返回。</li>
<li>如果允许且当前线程已绑定tcache，则从tcache分配large，并返回。否则下一步。</li>
<li>choose arena，并执行arena malloc large，返回。</li>
<li>执行huge malloc，并返回。</li>
</ol>
<h2 id="3-2-Initialize"><a href="#3-2-Initialize" class="headerlink" title="3.2 - Initialize"></a>3.2 - Initialize</h2><p>Je通过全局标记malloc_initialized指代是否初始化。在每次分配时，需要检查该标记，如果没有则执行malloc_init。</p>
<p>但通常条件下，malloc_init是在Je库被载入之前就调用的。通过gcc的编译扩展属性”constructor”实现，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JEMALLOC_ATTR(constructor)</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">jemalloc_constructor(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    malloc_init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来由malloc_init_hard执行各项初始化工作。这里首先需要考虑的是多线程初始化导致的重入，Je通过malloc_initialized和malloc_initializer两个标记来识别。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">malloc_mutex_lock(&amp;init_lock);</span><br><span class="line"><span class="comment">// xf: 如果在获得init_lock前已经有其他线程完成malloc_init,</span></span><br><span class="line"><span class="comment">// 或者当前线程在初始化过程中执行了malloc，导致递归初始化，则立即退出。</span></span><br><span class="line"><span class="keyword">if</span> (malloc_initialized || IS_INITIALIZER) &#123;</span><br><span class="line">    malloc_mutex_unlock(&amp;init_lock);</span><br><span class="line">    <span class="keyword">return</span> (<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// xf: 如果开启多线程初始化，需要执行busy wait直到malloc_init在另外线程中</span></span><br><span class="line"><span class="comment">// 执行完毕后返回。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> JEMALLOC_THREADED_INIT</span></span><br><span class="line"><span class="keyword">if</span> (malloc_initializer != NO_INITIALIZER &amp;&amp; IS_INITIALIZER == <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        malloc_mutex_unlock(&amp;init_lock);</span><br><span class="line">        CPU_SPINWAIT;</span><br><span class="line">        malloc_mutex_lock(&amp;init_lock);</span><br><span class="line">    &#125; <span class="keyword">while</span> (malloc_initialized == <span class="literal">false</span>);</span><br><span class="line">    malloc_mutex_unlock(&amp;init_lock);</span><br><span class="line">    <span class="keyword">return</span> (<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">// xf: 将当前线程注册为initializer</span></span><br><span class="line">malloc_initializer = INITIALIZER;</span><br></pre></td></tr></table></figure>
<p>初始化工作由各个xxx_boot函数完成。注意的是，boot函数返回false代表成功，否则代表失败。</p>
<ul>
<li><code>tsd boot</code>: Thread specific data初始化，主要负责tsd析构函数数组长度初始化。</li>
<li><code>base boot</code>: base是Je内部用于meta data分配的保留区域，使用内部独立的分配方式。base boot负责base node和base mutex的初始化。</li>
<li><code>chunk boot</code>: 主要有三件工作，<ul>
<li>确认chunk_size和chunk_npages</li>
<li>chunk_dss_boot，chunk dss指chunk分配的dss(Data Storage Segment)方式。其中涉及dss_base，dss_prev指针的初始化工作。</li>
<li>chunk tree的初始化，在chunk recycle时要用到。</li>
</ul>
</li>
<li><code>arena boot</code>: 主要是确认arena_maxclass，这个size代表arena管理的最大region，超过该值被认为huge region.在2.2.2小节中有过介绍，先通过多次迭代计算出map_bias，再用chunksize - (map_bias &lt;&lt; LG_PAGE)即可得到。另外还对另一个重要的静态数组arena_bin_info执行了初始化。可参考2.3.2介绍class size的部分。</li>
<li><code>tcache boot</code>: 分为tcache_boot0和tcache_boot1两个部分执行。前者负责tcache所有静态信息，包含tcache_bin_info，stack_nelms,nhbins等的初始化。后者负责tcache tsd数据的初始化(tcache保存到线程tsd中).</li>
<li><code>huge boot</code>: 负责huge mutex和huge tree的初始化。</li>
</ul>
<p>除此之外，其他重要的初始化还包括分配arenas数组。注意arenas是一个指向指针数组的指针，因此各个arena还需要动态创建。这里Je采取了lazy create的方式，只有当choose_arena时才可能由choose_arena_hard创建真实的arena实例。但在malloc_init中，首个arena还是会在此时创建，以保证基本的分配。</p>
<p>相关代码如下，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">arena_t</span> *init_arenas[<span class="number">1</span>];</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="comment">// xf: 此时narenas_total只有1</span></span><br><span class="line">narenas_total = narenas_auto = <span class="number">1</span>;</span><br><span class="line">arenas = init_arenas;</span><br><span class="line"><span class="built_in">memset</span>(arenas, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">arena_t</span> *) * narenas_auto);</span><br><span class="line"></span><br><span class="line"><span class="comment">// xf: 创建首个arena实例，保存到临时数组init_arenas中</span></span><br><span class="line">arenas_extend(<span class="number">0</span>);</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="comment">// xf: 获得当前系统核心数量</span></span><br><span class="line">ncpus = malloc_ncpus();</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="comment">// xf: 默认的narenas为核心数量的4倍</span></span><br><span class="line"><span class="keyword">if</span> (opt_narenas == <span class="number">0</span>) &#123;    </span><br><span class="line">    <span class="keyword">if</span> (ncpus &gt; <span class="number">1</span>)</span><br><span class="line">        opt_narenas = ncpus &lt;&lt; <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        opt_narenas = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// xf: android中max arenas限制为2，参考mk文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(ANDROID_MAX_ARENAS)</span></span><br><span class="line"><span class="keyword">if</span> (opt_narenas &gt; ANDROID_MAX_ARENAS)</span><br><span class="line">    opt_narenas = ANDROID_MAX_ARENAS;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">narenas_auto = opt_narenas;</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="comment">// xf: 修正narenas_total</span></span><br><span class="line">narenas_total = narenas_auto;</span><br><span class="line"></span><br><span class="line"><span class="comment">// xf: 根据total数量，构造arenas数组，并置空</span></span><br><span class="line">arenas = (<span class="keyword">arena_t</span> **)base_alloc(<span class="keyword">sizeof</span>(<span class="keyword">arena_t</span> *) * narenas_total);</span><br><span class="line">......</span><br><span class="line"><span class="built_in">memset</span>(arenas, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">arena_t</span> *) * narenas_total);</span><br><span class="line"></span><br><span class="line"><span class="comment">// xf: 将之前的首个arena实例指针保存到新构造的arenas数组中</span></span><br><span class="line">arenas[<span class="number">0</span>] = init_arenas[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>
<h2 id="3-3-Small-allocation-Arena"><a href="#3-3-Small-allocation-Arena" class="headerlink" title="3.3 - Small allocation (Arena)"></a>3.3 - Small allocation (Arena)</h2><p>先介绍最复杂的arena malloc small.</p>
<ol>
<li>先通过small_size2bin查到bin index(2.4.3节有述).</li>
<li>若对应bin中current run可用则进入下一步，否则执行4.</li>
<li>由arena_run_reg_alloc在current run中直接分配，并返回。</li>
<li>current run耗尽或不存在，尝试从bin中获得可用run以填充current run，成功则执行9，否则进入下一步。</li>
<li>当前bin的run tree中没有可用run，转而从arena的avail-tree上尝试切割一个可用run，成功则执行9，否则进入下一步。</li>
<li>当前arena没有可用的空闲run，构造一个新的chunk以分配new run. 成功则执行9，否则进入下一步。</li>
<li>chunk分配失败，再次查询arena的avail-tree，查找可用run. 成功则执行9，否则进入下一步。</li>
<li>alloc run尝试彻底失败，则再次查询当前bin的run-tree，尝试获取run。</li>
<li>在使用新获得run之前，重新检查当前bin的current run，如果可用(这里有两种可能，其一是其他线程可能通过free释放了多余的region或run，另一种可能是抢在当前线程之前已经分配了新run)，则使用其分配，并返回。另外，如果当前手中的new run是空的，则将其释放掉。否则若其地址比current run更低，则交换二者，将旧的current run插回avail-tree。</li>
<li>在new run中分配region，并返回。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *</span><br><span class="line">arena_malloc_small(<span class="keyword">arena_t</span> *arena, <span class="keyword">size_t</span> size, <span class="keyword">bool</span> zero)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// xf: 根据size计算bin index</span></span><br><span class="line">    binind = small_size2bin(size);</span><br><span class="line">    assert(binind &lt; NBINS);</span><br><span class="line">    bin = &amp;arena-&gt;bins[binind];</span><br><span class="line">    size = small_bin2size(binind);</span><br><span class="line"></span><br><span class="line">    malloc_mutex_lock(&amp;bin-&gt;lock);</span><br><span class="line">    <span class="comment">// xf: 如果bin中current run不为空，且存在空闲region，则在current</span></span><br><span class="line">    <span class="comment">// run中分配。否则在其他run中分配。</span></span><br><span class="line">    <span class="keyword">if</span> ((run = bin-&gt;runcur) != <span class="literal">NULL</span> &amp;&amp; run-&gt;nfree &gt; <span class="number">0</span>)</span><br><span class="line">        ret = arena_run_reg_alloc(run, &amp;arena_bin_info[binind]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ret = arena_bin_malloc_hard(arena, bin);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// xf: 若返回null，则分配失败。</span></span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        malloc_mutex_unlock(&amp;bin-&gt;lock);</span><br><span class="line">        <span class="keyword">return</span> (<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-3-1-arena-run-reg-alloc"><a href="#3-3-1-arena-run-reg-alloc" class="headerlink" title="3.3.1 - arena_run_reg_alloc"></a>3.3.1 - arena_run_reg_alloc</h3><ol>
<li>首先根据bin_info中的静态信息bitmap_offset计算bitmap基址。</li>
<li>扫描当前run的bitmap，获得第一个free region所在的位置。</li>
<li>region地址 = run基址 + 第一个region的偏移量 + free region索引 * region内部size</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> *</span><br><span class="line">arena_run_reg_alloc(<span class="keyword">arena_run_t</span> *run, <span class="keyword">arena_bin_info_t</span> *bin_info)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// xf: 计算bitmap基址</span></span><br><span class="line">    <span class="keyword">bitmap_t</span> *bitmap = (<span class="keyword">bitmap_t</span> *)((<span class="keyword">uintptr_t</span>)run +</span><br><span class="line">        (<span class="keyword">uintptr_t</span>)bin_info-&gt;bitmap_offset);</span><br><span class="line">    ......</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// xf: 获得当前run中第一个free region所在bitmap中的位置</span></span><br><span class="line">    regind = bitmap_sfu(bitmap, &amp;bin_info-&gt;bitmap_info);</span><br><span class="line">    <span class="comment">// xf: 计算返回值</span></span><br><span class="line">    ret = (<span class="keyword">void</span> *)((<span class="keyword">uintptr_t</span>)run + (<span class="keyword">uintptr_t</span>)bin_info-&gt;reg0_offset +</span><br><span class="line">        (<span class="keyword">uintptr_t</span>)(bin_info-&gt;reg_interval * regind));</span><br><span class="line">    <span class="comment">// xf: free减1</span></span><br><span class="line">    run-&gt;nfree--;</span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中bitmap_sfu是执行bitmap遍历并设置第一个unset bit。如2.5节所述，bitmap由多级组成，遍历由top level开始循环迭代，直至bottom level。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">JEMALLOC_INLINE <span class="keyword">size_t</span></span><br><span class="line">bitmap_sfu(<span class="keyword">bitmap_t</span> *bitmap, <span class="keyword">const</span> <span class="keyword">bitmap_info_t</span> *binfo)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// xf: 找到最高级level，并计算ffs</span></span><br><span class="line">    i = binfo-&gt;nlevels - <span class="number">1</span>;</span><br><span class="line">    g = bitmap[binfo-&gt;levels[i].group_offset];</span><br><span class="line">    bit = jemalloc_ffsl(g) - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// xf: 循环迭代，直到level0</span></span><br><span class="line">    <span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        i--;</span><br><span class="line">        <span class="comment">// xf: 根据上一级level的结果，计算当前level的group</span></span><br><span class="line">        g = bitmap[binfo-&gt;levels[i].group_offset + bit];</span><br><span class="line">        <span class="comment">// xf: 根据当前level group，计算下一级需要的bit</span></span><br><span class="line">        bit = (bit &lt;&lt; LG_BITMAP_GROUP_NBITS) + (jemalloc_ffsl(g) - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// xf: 得到level0的bit，设置bitmap</span></span><br><span class="line">    bitmap_set(bitmap, binfo, bit);</span><br><span class="line">    <span class="keyword">return</span> (bit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>bitmap_set同普通bitmap操作没有什么区别，只是在set/unset之后需要反向迭代更新各个高等级level对应的bit位。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">JEMALLOC_INLINE <span class="keyword">void</span></span><br><span class="line">bitmap_set(<span class="keyword">bitmap_t</span> *bitmap, <span class="keyword">const</span> <span class="keyword">bitmap_info_t</span> *binfo, <span class="keyword">size_t</span> bit)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// xf: 计算该bit所在level0中的group</span></span><br><span class="line">    goff = bit &gt;&gt; LG_BITMAP_GROUP_NBITS;</span><br><span class="line">    <span class="comment">// xf: 得到目标group的值g</span></span><br><span class="line">    gp = &amp;bitmap[goff];</span><br><span class="line">    g = *gp;</span><br><span class="line">    <span class="comment">// xf: 根据remainder，找到target bit，并反转</span></span><br><span class="line">    g ^= <span class="number">1L</span>U &lt;&lt; (bit &amp; BITMAP_GROUP_NBITS_MASK);</span><br><span class="line">    *gp = g;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// xf: 若target bit所在group为0，则需要更新highlevel的相应bit,</span></span><br><span class="line">    <span class="comment">// 是bitmap_sfu的反向操作。</span></span><br><span class="line">    <span class="keyword">if</span> (g == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; binfo-&gt;nlevels; i++) &#123;</span><br><span class="line">            bit = goff;</span><br><span class="line">            goff = bit &gt;&gt; LG_BITMAP_GROUP_NBITS;</span><br><span class="line">            gp = &amp;bitmap[binfo-&gt;levels[i].group_offset + goff];</span><br><span class="line">            g = *gp;</span><br><span class="line">            assert(g &amp; (<span class="number">1L</span>U &lt;&lt; (bit &amp; BITMAP_GROUP_NBITS_MASK)));</span><br><span class="line">            g ^= <span class="number">1L</span>U &lt;&lt; (bit &amp; BITMAP_GROUP_NBITS_MASK);</span><br><span class="line">            *gp = g;</span><br><span class="line">            <span class="keyword">if</span> (g != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-3-2-arena-bin-malloc-hard"><a href="#3-3-2-arena-bin-malloc-hard" class="headerlink" title="3.3.2 - arena_bin_malloc_hard"></a>3.3.2 - arena_bin_malloc_hard</h3><ol>
<li>从bin中获得可用的nonfull run，这个过程中bin-&gt;lock有可能被解锁。</li>
<li>暂不使用new run，返回检查bin-&gt;runcur是否重新可用。如果是，则直接在其中分配region(其他线程在bin lock解锁期间可能提前修改了runcur)。否则，执行4.</li>
<li>重新检查1中得到的new run，如果为空，则释放该run.否则与当前runcur作比较，若地址低于runcur，则与其做交换。将旧的runcur插回run tree。并返回new rigion.</li>
<li>用new run填充runcur，并在其中分配region，返回。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *</span><br><span class="line">arena_bin_malloc_hard(<span class="keyword">arena_t</span> *arena, <span class="keyword">arena_bin_t</span> *bin)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// xf: 获得bin对应的arena_bin_info，并将current run置空</span></span><br><span class="line">    binind = arena_bin_index(arena, bin);</span><br><span class="line">    bin_info = &amp;arena_bin_info[binind];</span><br><span class="line">    bin-&gt;runcur = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// xf: 从指定bin中获得一个可用的run</span></span><br><span class="line">    run = arena_bin_nonfull_run_get(arena, bin);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对bin-&gt;runcur做重新检查。如果可用且未耗尽，则直接分配。</span></span><br><span class="line">    <span class="keyword">if</span> (bin-&gt;runcur != <span class="literal">NULL</span> &amp;&amp; bin-&gt;runcur-&gt;nfree &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ret = arena_run_reg_alloc(bin-&gt;runcur, bin_info);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// xf: 若new run为空，则将其释放。否则重新插入run tree.</span></span><br><span class="line">        <span class="keyword">if</span> (run != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">arena_chunk_t</span> *chunk;</span><br><span class="line">            chunk = (<span class="keyword">arena_chunk_t</span> *)CHUNK_ADDR2BASE(run);</span><br><span class="line">            <span class="keyword">if</span> (run-&gt;nfree == bin_info-&gt;nregs)</span><br><span class="line">                arena_dalloc_bin_run(arena, chunk, run, bin);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                arena_bin_lower_run(arena, chunk, run, bin);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (ret);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (run == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> (<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// xf: 到这里在bin-&gt;runcur中分配失败，用当前新获得的run填充current run</span></span><br><span class="line">    bin-&gt;runcur = run;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// xf: 在new run中分配region</span></span><br><span class="line">    <span class="keyword">return</span> (arena_run_reg_alloc(bin-&gt;runcur, bin_info));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-3-3-arena-bin-nonfull-run-get"><a href="#3-3-3-arena-bin-nonfull-run-get" class="headerlink" title="3.3.3 - arena_bin_nonfull_run_get"></a>3.3.3 - arena_bin_nonfull_run_get</h3><ol>
<li>尝试在当前run tree中寻找可用run，成功则返回，否则进入下一步</li>
<li>解锁bin lock，并加锁arena lock，尝试在当前arena中分配new run。之后重新解锁arena lock，并加锁bin lock。如果成功则返回，否则进入下一步。</li>
<li>分配失败，重新在当前run tree中寻找一遍可用run.</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">arena_run_t</span> *</span><br><span class="line">arena_bin_nonfull_run_get(<span class="keyword">arena_t</span> *arena, <span class="keyword">arena_bin_t</span> *bin)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// xf: 尝试从当前run tree中寻找一个可用run，如果存在就返回</span></span><br><span class="line">    run = arena_bin_nonfull_run_tryget(bin);</span><br><span class="line">    <span class="keyword">if</span> (run != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> (run);    </span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">// xf: 打开bin lock，让其他线程可以操作当前的bin tree</span></span><br><span class="line">    malloc_mutex_unlock(&amp;bin-&gt;lock);</span><br><span class="line">    <span class="comment">// xf: 锁住arena lock，以分配new run</span></span><br><span class="line">    malloc_mutex_lock(&amp;arena-&gt;lock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// xf: 尝试分配new run</span></span><br><span class="line">    run = arena_run_alloc_small(arena, bin_info-&gt;run_size, binind);</span><br><span class="line">    <span class="keyword">if</span> (run != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 初始化new run和bitmap</span></span><br><span class="line">        <span class="keyword">bitmap_t</span> *bitmap = (<span class="keyword">bitmap_t</span> *)((<span class="keyword">uintptr_t</span>)run +</span><br><span class="line">            (<span class="keyword">uintptr_t</span>)bin_info-&gt;bitmap_offset);</span><br><span class="line"></span><br><span class="line">        run-&gt;bin = bin;</span><br><span class="line">        run-&gt;nextind = <span class="number">0</span>;</span><br><span class="line">        run-&gt;nfree = bin_info-&gt;nregs;</span><br><span class="line">        bitmap_init(bitmap, &amp;bin_info-&gt;bitmap_info);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// xf: 解锁arena lock</span></span><br><span class="line">    malloc_mutex_unlock(&amp;arena-&gt;lock);</span><br><span class="line">    <span class="comment">// xf: 重新加锁bin lock</span></span><br><span class="line">    malloc_mutex_lock(&amp;bin-&gt;lock);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (run != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">return</span> (run);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// xf: 如果run alloc失败，则回过头重新try get一次(前面解锁bin lock</span></span><br><span class="line">    <span class="comment">// 给了其他线程机会).</span></span><br><span class="line">    run = arena_bin_nonfull_run_tryget(bin);</span><br><span class="line">    <span class="keyword">if</span> (run != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> (run);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-3-4-Small-Run-Alloc"><a href="#3-3-4-Small-Run-Alloc" class="headerlink" title="3.3.4 - Small Run Alloc"></a>3.3.4 - Small Run Alloc</h3><ol>
<li>从arena avail tree上获得一个可用run，并对其切割。失败进入下一步。</li>
<li>尝试给arena分配新的chunk，以构造new run。此过程可能会解锁arena lock.失败进入下一步。</li>
<li>其他线程可能在此过程中释放了某些run，重新检查avail-tree，尝试获取run。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">arena_run_t</span> *</span><br><span class="line">arena_run_alloc_small(<span class="keyword">arena_t</span> *arena, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> binind)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// xf: 从available tree上尝试寻找并切割一个合适的run，并对其初始化</span></span><br><span class="line">    run = arena_run_alloc_small_helper(arena, size, binind);</span><br><span class="line">    <span class="keyword">if</span> (run != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> (run);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// xf: 当前arena内没有可用的空闲run，构造一个新的chunk以分配new run.</span></span><br><span class="line">    chunk = arena_chunk_alloc(arena);</span><br><span class="line">    <span class="keyword">if</span> (chunk != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        run = (<span class="keyword">arena_run_t</span> *)((<span class="keyword">uintptr_t</span>)chunk + (map_bias &lt;&lt; LG_PAGE));</span><br><span class="line">        arena_run_split_small(arena, run, size, binind);</span><br><span class="line">        <span class="keyword">return</span> (run);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// xf: 重新检查arena avail-tree.</span></span><br><span class="line">    <span class="keyword">return</span> (arena_run_alloc_small_helper(arena, size, binind));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">arena_run_t</span> *</span><br><span class="line">arena_run_alloc_small_helper(<span class="keyword">arena_t</span> *arena, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> binind)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// xf: 在arena的available tree中寻找一个大于等于size大小的最小run</span></span><br><span class="line">    key = (<span class="keyword">arena_chunk_map_t</span> *)(size | CHUNK_MAP_KEY);</span><br><span class="line">    mapelm = arena_avail_tree_nsearch(&amp;arena-&gt;runs_avail, key);</span><br><span class="line">    <span class="keyword">if</span> (mapelm != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">arena_chunk_t</span> *run_chunk = CHUNK_ADDR2BASE(mapelm);</span><br><span class="line">        <span class="keyword">size_t</span> pageind = arena_mapelm_to_pageind(mapelm);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// xf: 计算候选run的地址</span></span><br><span class="line">        run = (<span class="keyword">arena_run_t</span> *)((<span class="keyword">uintptr_t</span>)run_chunk + (pageind &lt;&lt;</span><br><span class="line">            LG_PAGE));</span><br><span class="line">        <span class="comment">// xf: 根据分配需求，切割候选run</span></span><br><span class="line">        arena_run_split_small(arena, run, size, binind);</span><br><span class="line">        <span class="keyword">return</span> (run);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>切割small run主要分为4步，</p>
<ol>
<li>将候选run的arena_chunk_map_t节点从avail-tree上摘除。</li>
<li>根据节点储存的原始page信息，以及need pages信息，切割该run.</li>
<li>更新remainder节点信息(只需更新首尾page)，重新插入avail-tree.</li>
<li>设置切割后new run所有page对应的map节点信息(根据2.3.3节所述).</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">arena_run_split_small(<span class="keyword">arena_t</span> *arena, <span class="keyword">arena_run_t</span> *run, <span class="keyword">size_t</span> size,</span><br><span class="line">    <span class="keyword">size_t</span> binind)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// xf: 获取目标run的dirty flag</span></span><br><span class="line">    chunk = (<span class="keyword">arena_chunk_t</span> *)CHUNK_ADDR2BASE(run);</span><br><span class="line">    run_ind = (<span class="keyword">unsigned</span>)(((<span class="keyword">uintptr_t</span>)run - (<span class="keyword">uintptr_t</span>)chunk) &gt;&gt; LG_PAGE);</span><br><span class="line">    flag_dirty = arena_mapbits_dirty_get(chunk, run_ind);</span><br><span class="line">    need_pages = (size &gt;&gt; LG_PAGE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// xf: 1. 将候选run从available tree上摘除</span></span><br><span class="line">    <span class="comment">//     2. 根据need pages对候选run进行切割</span></span><br><span class="line">    <span class="comment">//     3. 将remainder重新插入available tree    </span></span><br><span class="line">    arena_run_split_remove(arena, chunk, run_ind, flag_dirty, need_pages);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// xf: 设置刚刚被split后的run的第一个page</span></span><br><span class="line">    arena_mapbits_small_set(chunk, run_ind, <span class="number">0</span>, binind, flag_dirty);</span><br><span class="line">    ......</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// xf: 依次设置run中的其他page, run index依次递增</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; need_pages - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        arena_mapbits_small_set(chunk, run_ind+i, i, binind, <span class="number">0</span>);</span><br><span class="line">        .......</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// xf: 设置run中的最后一个page</span></span><br><span class="line">    arena_mapbits_small_set(chunk, run_ind+need_pages<span class="number">-1</span>, need_pages<span class="number">-1</span>,</span><br><span class="line">        binind, flag_dirty);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-3-5-Chunk-Alloc"><a href="#3-3-5-Chunk-Alloc" class="headerlink" title="3.3.5 - Chunk Alloc"></a>3.3.5 - Chunk Alloc</h3><p>arena获取chunk一般有两个途径。其一是通过内部的spare指针。该指针缓存了最近一次chunk被释放的记录。因此该方式速度很快。另一种更加常规，通过内部分配函数分配，最终将由chunk_alloc_core执行。但在Je的设计中，执行arena chunk的分配器是可定制的，你可以替换任何第三方chunk分配器。这里仅讨论默认情况。</p>
<p>Je在chunk_alloc_core中同传统分配器如Dl有较大区别。通常情况下，从系统获取内存无非是morecore或mmap两种方式。Dl中按照先morecore-&gt;mmap的顺序，而Je更为灵活，具体的顺序由dss_prec_t决定。</p>
<p>该类型是一个枚举，定义如下，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">    dss_prec_disabled  = <span class="number">0</span>,</span><br><span class="line">    dss_prec_primary   = <span class="number">1</span>,</span><br><span class="line">    dss_prec_secondary = <span class="number">2</span>,</span><br><span class="line">    dss_prec_limit     = <span class="number">3</span></span><br><span class="line">&#125; <span class="keyword">dss_prec_t</span>;</span><br></pre></td></tr></table></figure>
<p>这里dss和morecore含义是相同的。primary表示优先dss，secondary则优先mmap。Je默认使用后者。</p>
<p>实际分配时，无论采用哪种策略，都会优先执行chunk_recycle，再执行chunk alloc，如下，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *</span><br><span class="line">chunk_alloc_core(<span class="keyword">size_t</span> size, <span class="keyword">size_t</span> alignment, <span class="keyword">bool</span> base, <span class="keyword">bool</span> *zero,</span><br><span class="line">    <span class="keyword">dss_prec_t</span> dss_prec)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> *ret;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (have_dss &amp;&amp; dss_prec == dss_prec_primary) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((ret = chunk_recycle(&amp;chunks_szad_dss, &amp;chunks_ad_dss, size,</span><br><span class="line">            alignment, base, zero)) != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> (ret);</span><br><span class="line">        <span class="keyword">if</span> ((ret = chunk_alloc_dss(size, alignment, zero)) != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> (ret);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((ret = chunk_recycle(&amp;chunks_szad_mmap, &amp;chunks_ad_mmap, size,</span><br><span class="line">        alignment, base, zero)) != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> (ret);</span><br><span class="line">    <span class="keyword">if</span> ((ret = chunk_alloc_mmap(size, alignment, zero)) != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> (ret);</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> (have_dss &amp;&amp; dss_prec == dss_prec_secondary) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((ret = chunk_recycle(&amp;chunks_szad_dss, &amp;chunks_ad_dss, size,</span><br><span class="line">            alignment, base, zero)) != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> (ret);</span><br><span class="line">        <span class="keyword">if</span> ((ret = chunk_alloc_dss(size, alignment, zero)) != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> (ret);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所谓chunk recycle是在alloc chunk之前，优先在废弃的chunk tree上搜索可用chunk，并分配base node以储存meta data的过程。好处是其一可以加快分配速度，其二是使空间分配更加紧凑，并节省内存。</p>
<p>在Je中存在4棵全局的rb tree，分别为，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">extent_tree_t</span>    chunks_szad_mmap;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">extent_tree_t</span>    chunks_ad_mmap;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">extent_tree_t</span>    chunks_szad_dss;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">extent_tree_t</span>    chunks_ad_dss;</span><br></pre></td></tr></table></figure></p>
<p>它们分别对应mmap和dss方式。当一个chunk或huge region被释放后，将收集到这4棵tree中。szad和ad在内容上并无本质区别，只是检索方式不一样。前者采用先size后address的方式，后者则是纯address的检索。</p>
<p>recycle算法概括如下，</p>
<ol>
<li>检查base标志，如果为真则直接返回，否则进入下一步。开始的检查是必要的，因为recycle过程中可能会创建新的extent node，要求调用base allocator分配。另一方面，base alloc可能因为耗尽的原因而反过来调用chunk alloc。如此将导致dead loop.</li>
<li>根据alignment计算分配大小，并在szad tree(mmap还是dss需要上一级决定)上寻找一个大于等于alloc size的最小node.</li>
<li>chunk tree上的node未必对齐到alignment上，将地址对齐，之后将得到leadsize和trailsize.</li>
<li>将原node从chunk tree上remove。若leadsize不为0，则将其作为新的chunk重新insert回chunk tree。trailsize不为0的情况亦然。若leadsize和trailsize同时不为0，则通过base_node_alloc为trailsize生成新的node并插入。若base alloc失败，则整个新分配的region都要销毁。</li>
<li>若leadsize和trailsize都为0，则将node(注意仅仅是节点)释放。返回对齐后的chunk地址。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *</span><br><span class="line">chunk_recycle(<span class="keyword">extent_tree_t</span> *chunks_szad, <span class="keyword">extent_tree_t</span> *chunks_ad, <span class="keyword">size_t</span> size,</span><br><span class="line">    <span class="keyword">size_t</span> alignment, <span class="keyword">bool</span> base, <span class="keyword">bool</span> *zero)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// xf: 由于构造extent_node时可能因为内存不足的原因，同样需要构造chunk,</span></span><br><span class="line">    <span class="comment">// 这样就导致recursively dead loop。因此依靠base标志，区分普通alloc和</span></span><br><span class="line">    <span class="comment">// base node alloc。如果是base alloc，则立即返回。</span></span><br><span class="line">    <span class="keyword">if</span> (base) &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// xf: 计算分配大小</span></span><br><span class="line">    alloc_size = size + alignment - chunksize;</span><br><span class="line">    ......</span><br><span class="line">    key.addr = <span class="literal">NULL</span>;</span><br><span class="line">    key.size = alloc_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// xf: 在指定的szad tree上寻找大于等于alloc size的最小可用node</span></span><br><span class="line">    malloc_mutex_lock(&amp;chunks_mtx);</span><br><span class="line">    node = extent_tree_szad_nsearch(chunks_szad, &amp;key);</span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// xf: 将候选节点基址对齐到分配边界上，并计算leadsize, trailsize</span></span><br><span class="line">    <span class="comment">// 以及返回地址。</span></span><br><span class="line">    leadsize = ALIGNMENT_CEILING((<span class="keyword">uintptr_t</span>)node-&gt;addr, alignment) -</span><br><span class="line">        (<span class="keyword">uintptr_t</span>)node-&gt;addr;</span><br><span class="line">    trailsize = node-&gt;size - leadsize - size;</span><br><span class="line">    ret = (<span class="keyword">void</span> *)((<span class="keyword">uintptr_t</span>)node-&gt;addr + leadsize);</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">// xf: 将原node从szad/ad tree上移除</span></span><br><span class="line">    extent_tree_szad_remove(chunks_szad, node);</span><br><span class="line">    extent_tree_ad_remove(chunks_ad, node);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// xf: 如果存在leadsize，则将前面多余部分作为一个chunk重新插入</span></span><br><span class="line">    <span class="comment">// szad/ad tree上。</span></span><br><span class="line">    <span class="keyword">if</span> (leadsize != <span class="number">0</span>) &#123;</span><br><span class="line">        node-&gt;size = leadsize;</span><br><span class="line">        extent_tree_szad_insert(chunks_szad, node);</span><br><span class="line">        extent_tree_ad_insert(chunks_ad, node);</span><br><span class="line">        node = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// xf: 同样如果存在trailsize，也将后面的多余部分插入。</span></span><br><span class="line">    <span class="keyword">if</span> (trailsize != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// xf: 如果leadsize不为0，这时原来的extent_node已经被用过了，</span></span><br><span class="line">        <span class="comment">// 则必须为trailsize部分重新分配新的extent_node</span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            malloc_mutex_unlock(&amp;chunks_mtx);</span><br><span class="line">            node = base_node_alloc();</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// xf: 计算trail chunk，并插入</span></span><br><span class="line">        node-&gt;addr = (<span class="keyword">void</span> *)((<span class="keyword">uintptr_t</span>)(ret) + size);</span><br><span class="line">        node-&gt;size = trailsize;</span><br><span class="line">        node-&gt;zeroed = zeroed;</span><br><span class="line">        extent_tree_szad_insert(chunks_szad, node);</span><br><span class="line">        extent_tree_ad_insert(chunks_ad, node);</span><br><span class="line">        node = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    malloc_mutex_unlock(&amp;chunks_mtx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// xf: leadsize &amp; basesize都不存在，将node释放。</span></span><br><span class="line">    <span class="keyword">if</span> (node != <span class="literal">NULL</span>)</span><br><span class="line">        base_node_dalloc(node);</span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>常规分配方式先来看dss。由于dss是与当前进程的brk指针相关的，任何线程(包括可能不通过Je执行分配的线程)都有权修改该指针值。因此，首先要把dss指针调整到对齐在chunksize边界的位置，否则很多与chunk相关的计算都会失效。接下来，还要做第二次调整对齐到外界请求的alignment边界。在此基础上再进行分配。</p>
<p>与dss分配相关的变量如下，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">malloc_mutex_t</span>    dss_mtx;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span>        *dss_base;      </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span>        *dss_prev;      </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span>        *dss_max;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>dss_mtx</code>:  dss lock。注意其并不能起到保护dss指针的作用，因为brk是一个系统资源。该lock保护的是dss_prev, dss_max指针。</li>
<li><code>dss_base</code>: 只在chunk_dss_boot时更新一次。主要用作识别chunk在线性地址空间中所处的位置，与mmap作出区别。</li>
<li><code>dss_prev</code>: 当前dss指针，是系统brk指针的副本，值等于-1代表dss耗尽。</li>
<li><code>dss_max</code>:  当前dss区域上限。</li>
</ul>
<p>dss alloc算法如下，</p>
<ol>
<li>获取brk指针，更新到dss_max.</li>
<li>将dss_max对齐到chunksize边界上，计算padding大小gap_size</li>
<li>再将dss_max对齐到aligment边界上，得到cpad_size</li>
<li>计算需要分配的大小，并尝试sbrk。<code>incr = gap_size + cpad_size + size</code></li>
<li>分配成功，检查cpad是否非0，是则将这部分重新回收。而gap_size部分因为不可用则被废弃。</li>
<li>如果分配失败，则检查dss是否耗尽，如果没有则返回1重新尝试。否则返回。</li>
</ol>
<p>示意图，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">chunk_base             cpad        ret        dss_next</span><br><span class="line">    |                   |           |            |</span><br><span class="line">    v                   v           v            v</span><br><span class="line">    +--------+----------+-----------+------   ---+</span><br><span class="line">    |  used  | gap_size | cpad_size | size ...   |</span><br><span class="line">    +--------+----------+-----------+------   ---+</span><br><span class="line">             |&lt;------------- incr --------------&gt;|            </span><br><span class="line">             ^          ^           ^  </span><br><span class="line">             |          |           |</span><br><span class="line">          dss_max  chunk_base +     +-- chunk_base +</span><br><span class="line">                     chunk_size          alignment</span><br></pre></td></tr></table></figure>
<p>源码注释，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *</span><br><span class="line">chunk_alloc_dss(<span class="keyword">size_t</span> size, <span class="keyword">size_t</span> alignment, <span class="keyword">bool</span> *zero)</span><br><span class="line">&#123;</span><br><span class="line">    ......    </span><br><span class="line">    <span class="comment">// xf: dss是否耗尽</span></span><br><span class="line">    malloc_mutex_lock(&amp;dss_mtx);</span><br><span class="line">    <span class="keyword">if</span> (dss_prev != (<span class="keyword">void</span> *)<span class="number">-1</span>) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// xf: 获取当前dss指针</span></span><br><span class="line">            dss_max = chunk_dss_sbrk(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// xf: 计算对齐到chunk size边界需要的padding大小</span></span><br><span class="line">            gap_size = (chunksize - CHUNK_ADDR2OFFSET(dss_max)) &amp;</span><br><span class="line">                chunksize_mask;</span><br><span class="line">            <span class="comment">// xf: 对齐到chunk边界的chunk起始地址</span></span><br><span class="line">            cpad = (<span class="keyword">void</span> *)((<span class="keyword">uintptr_t</span>)dss_max + gap_size);</span><br><span class="line">            <span class="comment">// xf: 对齐到alignment边界的起始地址</span></span><br><span class="line">            ret = (<span class="keyword">void</span> *)ALIGNMENT_CEILING((<span class="keyword">uintptr_t</span>)dss_max,</span><br><span class="line">                alignment);</span><br><span class="line">            cpad_size = (<span class="keyword">uintptr_t</span>)ret - (<span class="keyword">uintptr_t</span>)cpad;</span><br><span class="line">            <span class="comment">// xf: dss_max分配后的更新地址</span></span><br><span class="line">            dss_next = (<span class="keyword">void</span> *)((<span class="keyword">uintptr_t</span>)ret + size);</span><br><span class="line">            ......</span><br><span class="line">            incr = gap_size + cpad_size + size;</span><br><span class="line">            <span class="comment">// xf: 从dss分配</span></span><br><span class="line">            dss_prev = chunk_dss_sbrk(incr);</span><br><span class="line">            <span class="keyword">if</span> (dss_prev == dss_max) &#123;</span><br><span class="line">                dss_max = dss_next;</span><br><span class="line">                malloc_mutex_unlock(&amp;dss_mtx);</span><br><span class="line">                <span class="comment">// xf: 如果ret和cpad对齐不在同一个位置，则将cpad开始</span></span><br><span class="line">                <span class="comment">// cpad_size大小的内存回收到szad/ad tree中。而以之前</span></span><br><span class="line">                <span class="comment">// dss起始的gap_size大小内存由于本身并非对齐到</span></span><br><span class="line">                <span class="comment">// chunk_size，则被废弃。</span></span><br><span class="line">                <span class="keyword">if</span> (cpad_size != <span class="number">0</span>)</span><br><span class="line">                    chunk_unmap(cpad, cpad_size);</span><br><span class="line">                ......</span><br><span class="line">                <span class="keyword">return</span> (ret);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (dss_prev != (<span class="keyword">void</span> *)<span class="number">-1</span>);   <span class="comment">// xf: 反复尝试直至dss耗尽</span></span><br><span class="line">    &#125;</span><br><span class="line">    malloc_mutex_unlock(&amp;dss_mtx);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后介绍chunk_alloc_mmap。同dss方式类似，mmap也存在对齐的问题。由于系统mmap调用无法指定alignment，因此Je实现了一个可以实现对齐但速度更慢的mmap slow方式。作为弥补，在chunk alloc mmap时先尝试依照普通方式mmap，如果返回值恰好满足对齐要求则直接返回(多数情况下是可行的)。否则将返回值munmap，再调用mmap slow.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *</span><br><span class="line">chunk_alloc_mmap(<span class="keyword">size_t</span> size, <span class="keyword">size_t</span> alignment, <span class="keyword">bool</span> *zero)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    ret = pages_map(<span class="literal">NULL</span>, size);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> (<span class="literal">NULL</span>);</span><br><span class="line">    offset = ALIGNMENT_ADDR2OFFSET(ret, alignment);</span><br><span class="line">    <span class="keyword">if</span> (offset != <span class="number">0</span>) &#123;</span><br><span class="line">        pages_unmap(ret, size);</span><br><span class="line">        <span class="keyword">return</span> (chunk_alloc_mmap_slow(size, alignment, zero));</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mmap slow通过事先分配超量size，对齐后再执行trim，去掉前后余量实现mmap对齐。page trim通过两次munmap将leadsize和trailsize部分分别释放。因此理论上，mmap slow需要最多三次munmap.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">|&lt;-------------alloc_size----------&gt;|</span><br><span class="line">+-----------+-----   --+------------+</span><br><span class="line">| lead_size | size...  | trail_size |</span><br><span class="line">+-----------+-----   --+------------+</span><br><span class="line">^           ^</span><br><span class="line">|           |</span><br><span class="line">pages      ret(alignment)</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *</span><br><span class="line">chunk_alloc_mmap_slow(<span class="keyword">size_t</span> size, <span class="keyword">size_t</span> alignment, <span class="keyword">bool</span> *zero)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    alloc_size = size + alignment - PAGE;</span><br><span class="line">    <span class="keyword">if</span> (alloc_size &lt; size)</span><br><span class="line">        <span class="keyword">return</span> (<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        pages = pages_map(<span class="literal">NULL</span>, alloc_size);</span><br><span class="line">        <span class="keyword">if</span> (pages == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> (<span class="literal">NULL</span>);</span><br><span class="line">        leadsize = ALIGNMENT_CEILING((<span class="keyword">uintptr_t</span>)pages, alignment) -</span><br><span class="line">            (<span class="keyword">uintptr_t</span>)pages;</span><br><span class="line">        ret = pages_trim(pages, alloc_size, leadsize, size);</span><br><span class="line">    &#125; <span class="keyword">while</span> (ret == <span class="literal">NULL</span>);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> (ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *</span><br><span class="line">pages_trim(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> alloc_size, <span class="keyword">size_t</span> leadsize, <span class="keyword">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> *ret = (<span class="keyword">void</span> *)((<span class="keyword">uintptr_t</span>)addr + leadsize);</span><br><span class="line">    ......</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">size_t</span> trailsize = alloc_size - leadsize - size;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (leadsize != <span class="number">0</span>)</span><br><span class="line">            pages_unmap(addr, leadsize);</span><br><span class="line">        <span class="keyword">if</span> (trailsize != <span class="number">0</span>)</span><br><span class="line">            pages_unmap((<span class="keyword">void</span> *)((<span class="keyword">uintptr_t</span>)ret + size), trailsize);</span><br><span class="line">        <span class="keyword">return</span> (ret);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-4-Small-allocation-tcache"><a href="#3-4-Small-allocation-tcache" class="headerlink" title="3.4 - Small allocation (tcache)"></a>3.4 - Small allocation (tcache)</h2><p>tcache内分配按照先easy后hard的方式。easy方式直接从tcache bin的avail-stack中获得可用region。如果tbin耗尽，使用hard方式，先refill avail-stack，再执行easy分配。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">JEMALLOC_ALWAYS_INLINE <span class="keyword">void</span> *</span><br><span class="line">tcache_alloc_small(<span class="keyword">tcache_t</span> *tcache, <span class="keyword">size_t</span> size, <span class="keyword">bool</span> zero)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// xf: 先从tcache bin尝试分配</span></span><br><span class="line">    ret = tcache_alloc_easy(tbin);</span><br><span class="line">    <span class="comment">// xf: 如果尝试失败，则refill tcache bin，并尝试分配</span></span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ret = tcache_alloc_small_hard(tcache, tbin, binind);</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> (<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">// xf: 执行tcache event</span></span><br><span class="line">    tcache_event(tcache);</span><br><span class="line">    <span class="keyword">return</span> (ret);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JEMALLOC_ALWAYS_INLINE <span class="keyword">void</span> *</span><br><span class="line">tcache_alloc_easy(<span class="keyword">tcache_bin_t</span> *tbin)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> *ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// xf: 如果tcache bin耗尽，更新水线为-1</span></span><br><span class="line">    <span class="keyword">if</span> (tbin-&gt;ncached == <span class="number">0</span>) &#123;</span><br><span class="line">        tbin-&gt;low_water = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// xf: pop栈顶的region，如果需要更新水线</span></span><br><span class="line">    tbin-&gt;ncached--;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">int</span>)tbin-&gt;ncached &lt; tbin-&gt;low_water)</span><br><span class="line">        tbin-&gt;low_water = tbin-&gt;ncached;</span><br><span class="line">    ret = tbin-&gt;avail[tbin-&gt;ncached];</span><br><span class="line">    <span class="keyword">return</span> (ret);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *</span><br><span class="line">tcache_alloc_small_hard(<span class="keyword">tcache_t</span> *tcache, <span class="keyword">tcache_bin_t</span> *tbin, <span class="keyword">size_t</span> binind)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> *ret;</span><br><span class="line"></span><br><span class="line">    arena_tcache_fill_small(tcache-&gt;arena, tbin, binind,</span><br><span class="line">        config_prof ? tcache-&gt;prof_accumbytes : <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (config_prof)</span><br><span class="line">        tcache-&gt;prof_accumbytes = <span class="number">0</span>;</span><br><span class="line">    ret = tcache_alloc_easy(tbin);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>tcache fill同普通的arena bin分配类似。首先，获得与tbin相同index的arena bin。之后确定fill值，该数值与2.7节介绍的lg_fill_div有关。如果arena run的runcur可用则直接分配并push stack，否则arena_bin_malloc_hard分配region。push后的顺序按照从低到高排列，低地址的region更靠近栈顶位置。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">arena_tcache_fill_small(<span class="keyword">arena_t</span> *arena, <span class="keyword">tcache_bin_t</span> *tbin, <span class="keyword">size_t</span> binind,</span><br><span class="line">    <span class="keyword">uint64_t</span> prof_accumbytes)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// xf: 得到与tbin同index的arena bin</span></span><br><span class="line">    bin = &amp;arena-&gt;bins[binind];</span><br><span class="line">    malloc_mutex_lock(&amp;bin-&gt;lock);</span><br><span class="line">    <span class="comment">// xf: tbin的充满度与lg_fill_div相关</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, nfill = (tcache_bin_info[binind].ncached_max &gt;&gt;</span><br><span class="line">        tbin-&gt;lg_fill_div); i &lt; nfill; i++) &#123;</span><br><span class="line">        <span class="comment">// xf: 如果current run可用，则从中分配</span></span><br><span class="line">        <span class="keyword">if</span> ((run = bin-&gt;runcur) != <span class="literal">NULL</span> &amp;&amp; run-&gt;nfree &gt; <span class="number">0</span>)</span><br><span class="line">            ptr = arena_run_reg_alloc(run, &amp;arena_bin_info[binind]);</span><br><span class="line">        <span class="keyword">else</span>    <span class="comment">// xf: current run耗尽，则从bin中查找其他run分配</span></span><br><span class="line">            ptr = arena_bin_malloc_hard(arena, bin);</span><br><span class="line">        <span class="keyword">if</span> (ptr == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// xf: 低地址region优先放入栈顶</span></span><br><span class="line">        tbin-&gt;avail[nfill - <span class="number">1</span> - i] = ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    malloc_mutex_unlock(&amp;bin-&gt;lock);</span><br><span class="line">    <span class="comment">// xf: 更新ncached</span></span><br><span class="line">    tbin-&gt;ncached = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外，如2.7节所述，tcache在每次分配和释放后都会更新ev_cnt计数器。当计数周期达到TCACHE_GC_INCR时，就会启动tcache gc。gc过程中会清理相当于low_water 3/4数量的region，并根据当前的low_water和lg_fill_div动态调整下一次refill时，tbin的充满度。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">tcache_bin_flush_small(<span class="keyword">tcache_bin_t</span> *tbin, <span class="keyword">size_t</span> binind, <span class="keyword">unsigned</span> rem,</span><br><span class="line">    <span class="keyword">tcache_t</span> *tcache)</span><br><span class="line">&#123;</span><br><span class="line">    ......   </span><br><span class="line">    <span class="comment">// xf: 循环scan，直到nflush为空。</span></span><br><span class="line">    <span class="comment">// 因为avail-stack中的region可能来自不同arena，因此需要多次scan.</span></span><br><span class="line">    <span class="comment">// 每次scan将不同arena的region移动到栈顶，留到下一轮scan时清理。</span></span><br><span class="line">    <span class="keyword">for</span> (nflush = tbin-&gt;ncached - rem; nflush &gt; <span class="number">0</span>; nflush = ndeferred) &#123;</span><br><span class="line">        <span class="comment">// xf: 获得栈顶region所属的arena和arena bin</span></span><br><span class="line">        <span class="keyword">arena_chunk_t</span> *chunk = (<span class="keyword">arena_chunk_t</span> *)CHUNK_ADDR2BASE(</span><br><span class="line">            tbin-&gt;avail[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">arena_t</span> *arena = chunk-&gt;arena;</span><br><span class="line">        <span class="keyword">arena_bin_t</span> *bin = &amp;arena-&gt;bins[binind];</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// xf: 锁住栈顶region的arena bin</span></span><br><span class="line">        malloc_mutex_lock(&amp;bin-&gt;lock);</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// xf: ndefered代表所属不同arena的region被搬移的位置，默认从0开始。</span></span><br><span class="line">        <span class="comment">// 本意是随着scan进行，nflush逐渐递增，nflush之前的位置空缺出来。</span></span><br><span class="line">        <span class="comment">// 当scan到不同arena region时，将其指针移动到nflush前面的空缺中，</span></span><br><span class="line">        <span class="comment">// 留到下一轮scan, nflush重新开始。直到ndefered和nflush重新为0.</span></span><br><span class="line">        ndeferred = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nflush; i++) &#123;</span><br><span class="line">            ptr = tbin-&gt;avail[i];</span><br><span class="line">            chunk = (<span class="keyword">arena_chunk_t</span> *)CHUNK_ADDR2BASE(ptr);</span><br><span class="line">            <span class="comment">// xf: 如果scan的region与栈顶region位于同一arena，则释放，</span></span><br><span class="line">            <span class="comment">// 否则移动到ndefered标注的位置，留到后面scan.</span></span><br><span class="line">            <span class="keyword">if</span> (chunk-&gt;arena == arena) &#123;</span><br><span class="line">                <span class="keyword">size_t</span> pageind = ((<span class="keyword">uintptr_t</span>)ptr -</span><br><span class="line">                    (<span class="keyword">uintptr_t</span>)chunk) &gt;&gt; LG_PAGE;</span><br><span class="line">                <span class="keyword">arena_chunk_map_t</span> *mapelm =</span><br><span class="line">                    arena_mapp_get(chunk, pageind);</span><br><span class="line">                ......</span><br><span class="line">                <span class="comment">// xf: 释放多余region</span></span><br><span class="line">                arena_dalloc_bin_locked(arena, chunk, ptr,</span><br><span class="line">                    mapelm);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tbin-&gt;avail[ndeferred] = ptr;</span><br><span class="line">                ndeferred++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        malloc_mutex_unlock(&amp;bin-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// xf: 将remainder regions指针移动到栈顶位置，完成gc过程</span></span><br><span class="line">    memmove(tbin-&gt;avail, &amp;tbin-&gt;avail[tbin-&gt;ncached - rem],</span><br><span class="line">        rem * <span class="keyword">sizeof</span>(<span class="keyword">void</span> *));</span><br><span class="line">    <span class="comment">// xf: 修正ncached以及low_water</span></span><br><span class="line">    tbin-&gt;ncached = rem;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">int</span>)tbin-&gt;ncached &lt; tbin-&gt;low_water)</span><br><span class="line">        tbin-&gt;low_water = tbin-&gt;ncached;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-5-Large-allocation"><a href="#3-5-Large-allocation" class="headerlink" title="3.5 - Large allocation"></a>3.5 - Large allocation</h2><p>Arena上的large alloc同small相比除了省去arena bin的部分之外，并无本质区别。基本算法如下，</p>
<ol>
<li>把请求大小对齐到page size上，直接从avail-tree上寻找first-best-fit runs.如果成功，则根据请求大小切割内存。切割过程也同切割small run类似，区别在之后对chunk map的初始化不同。chunk map细节可回顾2.3.3。如果失败，则进入下一步。</li>
<li>没有可用runs，尝试创建new chunk，成功同样切割run，失败进入下一步。</li>
<li>再次尝试从avail-tree上寻找可用runs，并返回。</li>
</ol>
<p>同上面的过程可以看出，所谓large region分配相当于small run的分配。区别仅在于chunk map信息不同。</p>
<p>Tcache上的large alloc同样按照先easy后hard的顺序。尽管常规arena上的分配不存在large bin，但在tcache中却存在large tbin，因此仍然是先查找avail-stack.如果tbin中找不到，就会向arena申请large runs。这里与small alloc的区别在不执行tbin refill，因为考虑到过多large region的占用量问题。large tbin仅在tcache_dalloc_large的时候才负责收集region。当tcache已满或GC周期到时执行tcache gc.</p>
<h2 id="3-6-Huge-allocation"><a href="#3-6-Huge-allocation" class="headerlink" title="3.6 - Huge allocation"></a>3.6 - Huge allocation</h2><p>Huge alloc相对于前面就更加简单。因为对于Je而言，huge region和chunk是等同的，这在前面有过叙述。Huge alloc就是调用chunk alloc，并将extent_node记录在huge tree上。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *</span><br><span class="line">huge_palloc(<span class="keyword">arena_t</span> *arena, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> alignment, <span class="keyword">bool</span> zero)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> *ret;</span><br><span class="line">    <span class="keyword">size_t</span> csize;</span><br><span class="line">    <span class="keyword">extent_node_t</span> *node;</span><br><span class="line">    <span class="keyword">bool</span> is_zeroed;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// xf: huge alloc对齐到chunksize</span></span><br><span class="line">    csize = CHUNK_CEILING(size);</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// xf: create extent node以记录huge region</span></span><br><span class="line">    node = base_node_alloc();</span><br><span class="line">    ......</span><br><span class="line">    arena = choose_arena(arena);</span><br><span class="line">    <span class="comment">// xf: 调用chunk alloc分配</span></span><br><span class="line">    ret = arena_chunk_alloc_huge(arena, csize, alignment, &amp;is_zeroed);</span><br><span class="line">    <span class="comment">// xf: 失败则清除extent node</span></span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        base_node_dalloc(node);</span><br><span class="line">        <span class="keyword">return</span> (<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    node-&gt;addr = ret;</span><br><span class="line">    node-&gt;size = csize;</span><br><span class="line">    node-&gt;arena = arena;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// xf: 插入huge tree上</span></span><br><span class="line">    malloc_mutex_lock(&amp;huge_mtx);</span><br><span class="line">    extent_tree_ad_insert(&amp;huge, node);</span><br><span class="line">    malloc_mutex_unlock(&amp;huge_mtx);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> (ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="4-Deallocation"><a href="#4-Deallocation" class="headerlink" title="4 - Deallocation"></a>4 - Deallocation</h1><h2 id="4-1-Overview"><a href="#4-1-Overview" class="headerlink" title="4.1 - Overview"></a>4.1 - Overview</h2><p>释放同分配过程相反，按照一个从ptr -&gt; run -&gt; bin -&gt; chunk -&gt; arena的路径。但因为涉及page合并和purge，实现更为复杂。dalloc的入口从je_free -&gt; ifree -&gt; iqalloc -&gt; iqalloct -&gt; idalloct.对dalloc的分析从idalloct开始。代码如下，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">JEMALLOC_ALWAYS_INLINE <span class="keyword">void</span></span><br><span class="line">idalloct(<span class="keyword">void</span> *ptr, <span class="keyword">bool</span> try_tcache)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// xf: 获得被释放地址所在的chunk</span></span><br><span class="line">    chunk = (<span class="keyword">arena_chunk_t</span> *)CHUNK_ADDR2BASE(ptr);</span><br><span class="line">    <span class="keyword">if</span> (chunk != ptr)</span><br><span class="line">        arena_dalloc(chunk, ptr, try_tcache);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        huge_dalloc(ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先会检测被释放指针ptr所在chunk的首地址与ptr是否一致，如果是，则一定为huge region，否则为small/large。从这里分为arena和huge两条线。</p>
<p>再看一下arena_dalloc，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">JEMALLOC_ALWAYS_INLINE <span class="keyword">void</span></span><br><span class="line">arena_dalloc(<span class="keyword">arena_chunk_t</span> *chunk, <span class="keyword">void</span> *ptr, <span class="keyword">bool</span> try_tcache)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// xf: 得到页面mapbits</span></span><br><span class="line">    mapbits = arena_mapbits_get(chunk, pageind);</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> ((mapbits &amp; CHUNK_MAP_LARGE) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (try_tcache &amp;&amp; (tcache = tcache_get(<span class="literal">false</span>)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// xf: ptr所在tcache的index</span></span><br><span class="line">            binind = arena_ptr_small_binind_get(ptr, mapbits);</span><br><span class="line">            tcache_dalloc_small(tcache, ptr, binind);</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            arena_dalloc_small(chunk-&gt;arena, chunk, ptr, pageind);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">size_t</span> size = arena_mapbits_large_size_get(chunk, pageind);</span><br><span class="line">        <span class="keyword">if</span> (try_tcache &amp;&amp; size &lt;= tcache_maxclass &amp;&amp; (tcache =</span><br><span class="line">            tcache_get(<span class="literal">false</span>)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            tcache_dalloc_large(tcache, ptr, size);</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            arena_dalloc_large(chunk-&gt;arena, chunk, ptr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里通过得到ptr所在page的mapbits，判断其来自于small还是large。然后再分别作处理。</p>
<p>因此，在dalloc一开始基本上分成了small/large/huge三条路线执行。事实上，结合前面的知识，large/huge可以看作run和chunk的特例。所以，这三条dalloc路线最终会汇到一起，只需要搞清楚其中最为复杂的small region dalloc就可以了。</p>
<p>无论small/large region，都会先尝试释放回tcache，不管其是否从tache中分配而来。所谓tcache dalloc只不过是将region记录在tbin中，并不算真正的释放。除非两种情况，一是如果当前线程tbin已满，会直接执行一次tbin flush，释放出部分tbin空间。二是如果tcache_event触发发了tache gc，也会执行flush。两者的区别在于，前者会回收指定tbin 1/2的空间，而后者则释放next_gc_bin相当于3/4low water数量的空间。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">JEMALLOC_ALWAYS_INLINE <span class="keyword">void</span></span><br><span class="line">tcache_dalloc_small(<span class="keyword">tcache_t</span> *tcache, <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> binind)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    tbin = &amp;tcache-&gt;tbins[binind];</span><br><span class="line">    tbin_info = &amp;tcache_bin_info[binind];</span><br><span class="line">    <span class="comment">// xf: 如果当前tbin已满，则执行flush清理tbin</span></span><br><span class="line">    <span class="keyword">if</span> (tbin-&gt;ncached == tbin_info-&gt;ncached_max) &#123;</span><br><span class="line">        tcache_bin_flush_small(tbin, binind, (tbin_info-&gt;ncached_max &gt;&gt;</span><br><span class="line">            <span class="number">1</span>), tcache);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// xf: 将被释放的ptr重新push进tbin</span></span><br><span class="line">    tbin-&gt;avail[tbin-&gt;ncached] = ptr;</span><br><span class="line">    tbin-&gt;ncached++;</span><br><span class="line"></span><br><span class="line">    tcache_event(tcache);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>tcache gc和tcache flush在2.7和3.4节中已经介绍，不再赘述。</p>
<h2 id="4-2-arena-dalloc-bin"><a href="#4-2-arena-dalloc-bin" class="headerlink" title="4.2 - arena_dalloc_bin"></a>4.2 - arena_dalloc_bin</h2><p>small region dalloc的第一步是尝试将region返还给所属的bin。首要的步骤就是根据用户传入的ptr推算出其所在run的地址。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run addr = chunk base + run page offset &lt;&lt; LG_PAGE</span><br></pre></td></tr></table></figure></p>
<p>而run page offset根据2.3.3小节的说明，可以通过ptr所在page的mapbits获得。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run page offset = ptr page index - ptr page offset</span><br></pre></td></tr></table></figure></p>
<p>得到run后就进一步拿到所属的bin，接着对bin加锁并回收，如下，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">arena_dalloc_bin(<span class="keyword">arena_t</span> *arena, <span class="keyword">arena_chunk_t</span> *chunk, <span class="keyword">void</span> *ptr,</span><br><span class="line">    <span class="keyword">size_t</span> pageind, <span class="keyword">arena_chunk_map_t</span> *mapelm)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// xf: 计算ptr所在run地址。    </span></span><br><span class="line">    run = (<span class="keyword">arena_run_t</span> *)((<span class="keyword">uintptr_t</span>)chunk + (<span class="keyword">uintptr_t</span>)((pageind -</span><br><span class="line">        arena_mapbits_small_runind_get(chunk, pageind)) &lt;&lt; LG_PAGE));</span><br><span class="line">    bin = run-&gt;bin;</span><br><span class="line"> </span><br><span class="line">    malloc_mutex_lock(&amp;bin-&gt;lock);</span><br><span class="line">    arena_dalloc_bin_locked(arena, chunk, ptr, mapelm);</span><br><span class="line">    malloc_mutex_unlock(&amp;bin-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>lock的内容无非是将region在run内部的bitmap上标记为可用。bitmap unset的过程此处省略，请参考3.3.1小节中分配算法的解释。与tcache dalloc类似，通常情况下region并不会真正释放。但如果run内部全部为空闲region，则会进一步触发run的释放。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">arena_dalloc_bin_locked(<span class="keyword">arena_t</span> *arena, <span class="keyword">arena_chunk_t</span> *chunk, <span class="keyword">void</span> *ptr,</span><br><span class="line">    <span class="keyword">arena_chunk_map_t</span> *mapelm)</span><br><span class="line">&#123;</span><br><span class="line">    ......    </span><br><span class="line">    <span class="comment">// xf: 通过run回收region，在bitmap上重新标记region可用。</span></span><br><span class="line">    arena_run_reg_dalloc(run, ptr);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// xf: 如果其所在run完全free，则尝试释放该run.</span></span><br><span class="line">    <span class="comment">// 如果所在run处在将满状态(因为刚刚的释放腾出一个region的空间),</span></span><br><span class="line">    <span class="comment">// 则根据地址高低优先将其交换到current run的位置(MRU).</span></span><br><span class="line">    <span class="keyword">if</span> (run-&gt;nfree == bin_info-&gt;nregs) &#123;</span><br><span class="line">        arena_dissociate_bin_run(chunk, run, bin);</span><br><span class="line">        arena_dalloc_bin_run(arena, chunk, run, bin);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (run-&gt;nfree == <span class="number">1</span> &amp;&amp; run != bin-&gt;runcur)</span><br><span class="line">        arena_bin_lower_run(arena, chunk, run, bin);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此外还有一种情况是，如果原先run本来是满的，因为前面的释放多出一个空闲位置，就会尝试与current run交换位置。若当前run比current run地址更低，会替代后者并成为新的current run，这样的好处显然可以保证低地址的内存更紧实。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">arena_bin_lower_run(<span class="keyword">arena_t</span> *arena, <span class="keyword">arena_chunk_t</span> *chunk, <span class="keyword">arena_run_t</span> *run,</span><br><span class="line">    <span class="keyword">arena_bin_t</span> *bin)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">uintptr_t</span>)run &lt; (<span class="keyword">uintptr_t</span>)bin-&gt;runcur) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bin-&gt;runcur-&gt;nfree &gt; <span class="number">0</span>)</span><br><span class="line">            arena_bin_runs_insert(bin, bin-&gt;runcur);</span><br><span class="line">        bin-&gt;runcur = run;</span><br><span class="line">        <span class="keyword">if</span> (config_stats)</span><br><span class="line">            bin-&gt;stats.reruns++;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        arena_bin_runs_insert(bin, run);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通常情况下，至此一个small region就释放完毕了，准确的说是回收了。但如前面所说，若整个run都为空闲region，则进入run dalloc。这是一个比较复杂的过程。</p>
<h2 id="4-3-small-run-dalloc"><a href="#4-3-small-run-dalloc" class="headerlink" title="4.3 - small run dalloc"></a>4.3 - small run dalloc</h2><p>一个non-full的small run被记录在bin内的run tree上，因此要移除它，首先要移除其在run tree中的信息，即arena_dissociate_bin_run.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">arena_dissociate_bin_run(<span class="keyword">arena_chunk_t</span> *chunk, <span class="keyword">arena_run_t</span> *run,</span><br><span class="line">    <span class="keyword">arena_bin_t</span> *bin)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// xf: 如果当前run为current run，清除runcur。否则，从run tree上remove.</span></span><br><span class="line">    <span class="keyword">if</span> (run == bin-&gt;runcur)</span><br><span class="line">        bin-&gt;runcur = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (bin_info-&gt;nregs != <span class="number">1</span>) &#123;</span><br><span class="line">            arena_bin_runs_remove(bin, run);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来要通过arena_dalloc_bin_run()正式释放run，由于过程稍复杂，这里先给出整个算法的梗概，</p>
<ol>
<li>计算nextind region所在page的index。所谓nextind是run内部clean-dirty region的边界。如果内部存在clean pages则执行下一步，否则执行3.</li>
<li>将原始的small run转化成large run，之后根据上一步得到的nextind将run切割成dirty和clean两部分，且单独释放掉clean部分。  </li>
<li>将待remove的run pages标记为unalloc。且根据传入的dirty和cleaned两个hint决定标记后的page mapbits的dirty flag.</li>
<li>检查unalloc后的run pages是否可以前后合并。合并的标准是，<ol>
<li>不超过chunk范围</li>
<li>前后毗邻的page同样为unalloc</li>
<li>前后毗邻page的dirty flag与run pages相同。</li>
</ol>
</li>
<li>将合并后(也可能没合并)的unalloc run插入avail-tree.</li>
<li>检查如果unalloc run的大小等于chunk size，则将chunk释放掉。</li>
<li>如果之前释放run pages为dirty，则检查当前arena内部的dirty-active pages比例。若dirty数量超过了active的1/8(Android这里的标准有所不同)，则启动arena purge.否则直接返回。</li>
<li>计算当前arena可以清理的dirty pages数量npurgatory.</li>
<li>从dirty tree上依次取出dirty chunk，并检查内部的unalloc dirty pages，将其重新分配为large pages，并插入到临时的queue中。</li>
<li>对临时队列中的dirty pages执行purge，返回值为unzeroed标记。再将purged pages的unzeroed标记设置一遍。</li>
<li>最后对所有purged pages重新执行一遍dalloc run操作，将其重新释放回avail-tree.</li>
</ol>
<p>可以看到，释放run本质上是将其回收至avail-tree。但额外的dirty page机制却增加了整个算法的复杂程度。原因就在于，Je使用了不同以往的内存释放方式。</p>
<p>在Dl这样的经典分配器中，系统内存回收方式更加”古板”。比如在heap区需要top-most space存在大于某个threshold的连续free空间时才能进行auto-trimming。而mmap区则更要等到某个segment全部空闲才能执行munmap。这对于回收系统内存是极为不利的，因为条件过于严格。</p>
<p>而Je使用了更为聪明的方式，并不会直接交还系统内存，而是通过madvise暂时释放掉页面与物理页面之间的映射。本质上这同sbrk/munmap之类的调用要达到的目的是类似的，只不过从进程内部的角度看，该地址仍然被占用。但Je对这些使用过的地址都详细做了记录，因此再分配时可以recycle，并不会导致对线性地址无休止的开采。</p>
<p>另外，为了提高对已释放page的利用率，Je将unalloc pages用dirty flag(注意，这里同page replacement中的含义不同)做了标记。所有pages被分成active, dirty和clean三种。dirty pages表示曾经使用过，且仍可能关联着物理页面，recycle速度较快。而clean则代表尚未使用，或已经通过purge释放了物理页面，较前者速度慢。显然，需要一种内置算法来保持三种page的动态平衡，以兼顾分配速度和内存占用量。如果当前dirty pages数量超过了active pages数量的1/2^opt_lg_dirty_mult，就会启动arena_purge()。这个值默认是1/8，如下，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">arena_maybe_purge(<span class="keyword">arena_t</span> *arena)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// xf: 如果当前dirty pages全部在执行purging，则直接返回。</span></span><br><span class="line">    <span class="keyword">if</span> (arena-&gt;ndirty &lt;= arena-&gt;npurgatory)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// xf: 检查purageable pages是否超出active-dirty比率，超出则</span></span><br><span class="line">    <span class="comment">// 执行purge。google在这里增加了ANDROID_ALWAYS_PURGE开关，</span></span><br><span class="line">    <span class="comment">// 打开则总会执行arena_purge(默认是打开的).</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(ANDROID_ALWAYS_PURGE)</span></span><br><span class="line">    npurgeable = arena-&gt;ndirty - arena-&gt;npurgatory;</span><br><span class="line">    threshold = (arena-&gt;nactive &gt;&gt; opt_lg_dirty_mult);</span><br><span class="line">    <span class="keyword">if</span> (npurgeable &lt;= threshold)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// xf: 执行purge</span></span><br><span class="line">    arena_purge(arena, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但google显然希望对dirty pages管理更严格一些，以适应移动设备上内存偏小的问题。这里增加了一个ALWAYS_PURGE的开关，打开后会强制每次释放时都执行arena_purge.</p>
<p>arena_run_dalloc代码如下，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">arena_run_dalloc(<span class="keyword">arena_t</span> *arena, <span class="keyword">arena_run_t</span> *run, <span class="keyword">bool</span> dirty, <span class="keyword">bool</span> cleaned)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// xf: 如果run pages的dirty flag实际读取为true，且cleaned不为true,</span></span><br><span class="line">    <span class="comment">// 则同样认为该pages在dalloc后是dirty的，否则被视为clean(该情况适用于</span></span><br><span class="line">    <span class="comment">// chunk purge后，重新dalloc时，此时的run pages虽然dirty flag可能为ture,</span></span><br><span class="line">    <span class="comment">// 但经过purge后应该修改为clean).</span></span><br><span class="line">    <span class="keyword">if</span> (cleaned == <span class="literal">false</span> &amp;&amp; arena_mapbits_dirty_get(chunk, run_ind) != <span class="number">0</span>)</span><br><span class="line">        dirty = <span class="literal">true</span>;</span><br><span class="line">    flag_dirty = dirty ? CHUNK_MAP_DIRTY : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// xf: 将被remove的run标记为unalloc pages。前面的判断如果是dirty，则pages</span></span><br><span class="line">    <span class="comment">// mapbits将带有dirty flag，否则将不带有dirty flag.</span></span><br><span class="line">    <span class="keyword">if</span> (dirty) &#123;</span><br><span class="line">        arena_mapbits_unallocated_set(chunk, run_ind, size,</span><br><span class="line">            CHUNK_MAP_DIRTY);</span><br><span class="line">        arena_mapbits_unallocated_set(chunk, run_ind+run_pages<span class="number">-1</span>, size,</span><br><span class="line">            CHUNK_MAP_DIRTY);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        arena_mapbits_unallocated_set(chunk, run_ind, size,</span><br><span class="line">            arena_mapbits_unzeroed_get(chunk, run_ind));</span><br><span class="line">        arena_mapbits_unallocated_set(chunk, run_ind+run_pages<span class="number">-1</span>, size,</span><br><span class="line">            arena_mapbits_unzeroed_get(chunk, run_ind+run_pages<span class="number">-1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// xf: 尝试将被remove run与前后unalloc pages 合并。</span></span><br><span class="line">    arena_run_coalesce(arena, chunk, &amp;size, &amp;run_ind, &amp;run_pages,</span><br><span class="line">        flag_dirty);</span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// xf: 将执行过合并后的run重新insert到avail-tree</span></span><br><span class="line">    arena_avail_insert(arena, chunk, run_ind, run_pages, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// xf: 检查如果合并后的size已经完全unallocated，则dalloc整个chunk</span></span><br><span class="line">    <span class="keyword">if</span> (size == arena_maxclass) &#123;</span><br><span class="line">        ......</span><br><span class="line">        arena_chunk_dalloc(arena, chunk);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dirty)</span><br><span class="line">        arena_maybe_purge(arena);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>coalesce代码如下，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">arena_run_coalesce(<span class="keyword">arena_t</span> *arena, <span class="keyword">arena_chunk_t</span> *chunk, <span class="keyword">size_t</span> *p_size,</span><br><span class="line">    <span class="keyword">size_t</span> *p_run_ind, <span class="keyword">size_t</span> *p_run_pages, <span class="keyword">size_t</span> flag_dirty)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// xf: 尝试与后面的pages合并</span></span><br><span class="line">    <span class="keyword">if</span> (run_ind + run_pages &lt; chunk_npages &amp;&amp;</span><br><span class="line">        arena_mapbits_allocated_get(chunk, run_ind+run_pages) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">        arena_mapbits_dirty_get(chunk, run_ind+run_pages) == flag_dirty) &#123;</span><br><span class="line">        <span class="keyword">size_t</span> nrun_size = arena_mapbits_unallocated_size_get(chunk,</span><br><span class="line">            run_ind+run_pages);</span><br><span class="line">        <span class="keyword">size_t</span> nrun_pages = nrun_size &gt;&gt; LG_PAGE;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// xf: 如果与后面的unalloc pages合并，remove page时后方的adjacent</span></span><br><span class="line">        <span class="comment">// hint应为true</span></span><br><span class="line">        arena_avail_remove(arena, chunk, run_ind+run_pages, nrun_pages,</span><br><span class="line">            <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        size += nrun_size;</span><br><span class="line">        run_pages += nrun_pages;</span><br><span class="line"></span><br><span class="line">        arena_mapbits_unallocated_size_set(chunk, run_ind, size);</span><br><span class="line">        arena_mapbits_unallocated_size_set(chunk, run_ind+run_pages<span class="number">-1</span>, size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// xf: 尝试与前面的pages合并</span></span><br><span class="line">    <span class="keyword">if</span> (run_ind &gt; map_bias &amp;&amp; arena_mapbits_allocated_get(chunk,</span><br><span class="line">        run_ind<span class="number">-1</span>) == <span class="number">0</span> &amp;&amp; arena_mapbits_dirty_get(chunk, run_ind<span class="number">-1</span>) ==</span><br><span class="line">        flag_dirty) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *p_size = size;</span><br><span class="line">    *p_run_ind = run_ind;</span><br><span class="line">    *p_run_pages = run_pages;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>avail-tree remove代码如下，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">arena_avail_remove(<span class="keyword">arena_t</span> *arena, <span class="keyword">arena_chunk_t</span> *chunk, <span class="keyword">size_t</span> pageind,</span><br><span class="line">    <span class="keyword">size_t</span> npages, <span class="keyword">bool</span> maybe_adjac_pred, <span class="keyword">bool</span> maybe_adjac_succ)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// xf: 该调用可能将导致chunk内部的碎片化率改变，从而影响其在dirty tree</span></span><br><span class="line">    <span class="comment">// 中的排序。因此，在正式remove之前需要将chunk首先从dirty tree中remove,</span></span><br><span class="line">    <span class="comment">// 待更新内部ndirty后，再将其重新insert回dirty tree.</span></span><br><span class="line">    <span class="keyword">if</span> (chunk-&gt;ndirty != <span class="number">0</span>)</span><br><span class="line">        arena_chunk_dirty_remove(&amp;arena-&gt;chunks_dirty, chunk);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// xf: maybe_adjac_pred/succ是外界传入的hint，根据该值检查前后是否存在</span></span><br><span class="line">    <span class="comment">// clean-dirty边界。若存在边界，则remove avail pages后边界将减1.</span></span><br><span class="line">    <span class="keyword">if</span> (maybe_adjac_pred &amp;&amp; arena_avail_adjac_pred(chunk, pageind))</span><br><span class="line">        chunk-&gt;nruns_adjac--;</span><br><span class="line">    <span class="keyword">if</span> (maybe_adjac_succ &amp;&amp; arena_avail_adjac_succ(chunk, pageind, npages))</span><br><span class="line">        chunk-&gt;nruns_adjac--;</span><br><span class="line">    chunk-&gt;nruns_avail--;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">// xf: 更新arena及chunk中dirty pages统计。</span></span><br><span class="line">    <span class="keyword">if</span> (arena_mapbits_dirty_get(chunk, pageind) != <span class="number">0</span>) &#123;</span><br><span class="line">        arena-&gt;ndirty -= npages;</span><br><span class="line">        chunk-&gt;ndirty -= npages;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// xf: 如果chunk内部dirty不为0，将其重新insert到arena dirty tree.</span></span><br><span class="line">    <span class="keyword">if</span> (chunk-&gt;ndirty != <span class="number">0</span>)</span><br><span class="line">        arena_chunk_dirty_insert(&amp;arena-&gt;chunks_dirty, chunk);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// xf: 从chunk avail-tree中remove掉unalloc pages.</span></span><br><span class="line">    arena_avail_tree_remove(&amp;arena-&gt;runs_avail, arena_mapp_get(chunk,</span><br><span class="line">        pageind));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从avail-tree上remove pages可能会改变当前chunk内部clean-dirty碎片率，因此一开始要将其所在chunk从dirty tree上remove，再从avail-tree上remove pages。另外，arena_avail_insert()的算法同remove是一样的，只是方向相反，不再赘述。</p>
<h2 id="4-4-arena-purge"><a href="#4-4-arena-purge" class="headerlink" title="4.4 - arena purge"></a>4.4 - arena purge</h2><p>清理arena的方式是按照从小到大的顺序遍历一棵dirty tree，直到将dirty pages降低到threshold以下。dirty tree挂载所有dirty chunks，同其他tree的区别在于它的cmp函数较特殊，决定了最终的purging order，如下，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span></span><br><span class="line">arena_chunk_dirty_comp(<span class="keyword">arena_chunk_t</span> *a, <span class="keyword">arena_chunk_t</span> *b)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (a == b)</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">size_t</span> a_val = (a-&gt;nruns_avail - a-&gt;nruns_adjac) *</span><br><span class="line">            b-&gt;nruns_avail;</span><br><span class="line">        <span class="keyword">size_t</span> b_val = (b-&gt;nruns_avail - b-&gt;nruns_adjac) *</span><br><span class="line">            a-&gt;nruns_avail;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (a_val &lt; b_val)</span><br><span class="line">            <span class="keyword">return</span> (<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (a_val &gt; b_val)</span><br><span class="line">            <span class="keyword">return</span> (<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">uintptr_t</span> a_chunk = (<span class="keyword">uintptr_t</span>)a;</span><br><span class="line">        <span class="keyword">uintptr_t</span> b_chunk = (<span class="keyword">uintptr_t</span>)b;</span><br><span class="line">        <span class="keyword">int</span> ret = ((a_chunk &gt; b_chunk) - (a_chunk &lt; b_chunk));</span><br><span class="line">        <span class="keyword">if</span> (a-&gt;nruns_adjac == <span class="number">0</span>) &#123;</span><br><span class="line">            assert(b-&gt;nruns_adjac == <span class="number">0</span>);</span><br><span class="line">            ret = -ret;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (ret);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Je在这里给出的算法是这样的，</p>
<ol>
<li>首先排除short cut，即a和b相同的特例。</li>
<li>计算a, b的fragmentation，该数值越高，相应的在dirty tree上就越靠前。<br>其计算方法为，</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当前平均avail run大小    所有avail run数量 - 边界数量</span><br><span class="line">--------------------- =  -----------------------------</span><br><span class="line"> 去碎片后的平均大小           所有avail run数量</span><br></pre></td></tr></table></figure>
<p>注意，这个fragment不是通常意义理解的碎片。这里指由于clean-dirty边界形成的所谓碎片，并且是可以通过purge清除掉的，如图，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">nruns_adjac = <span class="number">2</span>    </span><br><span class="line">+--------+----------+--------+-------+---------+----------+--------+-----</span><br><span class="line">| dirty  |  clean   |        | clean |  dirty  |          | dirty  | ...</span><br><span class="line">+--------+----------+--------+-------+---------+----------+--------+-----</span><br><span class="line">         ^                           ^</span><br><span class="line">         |                           |</span><br><span class="line">         +--adjac #<span class="number">0</span>                 +--adjac #<span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<ol>
<li>当a, b的fragmentation相同时，同通常的方法类似，按地址大小排序。但若nruns_adjac为0，即不存在clean-dirty边界时，反而会将低地址chunk排到后面。因为adjac为0的chunk再利用价值是比较高的，所以放到后面可以增加其在purge中的幸存几率，从而提升recycle效率。</li>
</ol>
<p>purge代码如下，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">arena_purge(<span class="keyword">arena_t</span> *arena, <span class="keyword">bool</span> all)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// xf: 计算purgeable pages，结果加入到npurgatory信息中。</span></span><br><span class="line">    npurgatory = arena_compute_npurgatory(arena, all);</span><br><span class="line">    arena-&gt;npurgatory += npurgatory;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// xf: 从dirty chunk tree上逐chunk执行purge，直到期望值npurgatory为0</span></span><br><span class="line">    <span class="keyword">while</span> (npurgatory &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ......</span><br><span class="line">        chunk = arena_chunk_dirty_first(&amp;arena-&gt;chunks_dirty);</span><br><span class="line">        <span class="comment">// xf: traversal结束，当前线程无法完成purge任务，返回。</span></span><br><span class="line">        <span class="keyword">if</span> (chunk == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            arena-&gt;npurgatory -= npurgatory;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        npurgeable = chunk-&gt;ndirty;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// xf:  如果当前chunk中purgeable大于前期计算的purgatory,</span></span><br><span class="line">        <span class="comment">// 且其clean-dirty碎片为0，则让当前线程负责purge所有prgeable pages.</span></span><br><span class="line">        <span class="comment">// 原因是为了尽可能避免避免多个线程对该chunk的purge竞争。</span></span><br><span class="line">        <span class="keyword">if</span> (npurgeable &gt; npurgatory &amp;&amp; chunk-&gt;nruns_adjac == <span class="number">0</span>) &#123;</span><br><span class="line">            arena-&gt;npurgatory += npurgeable - npurgatory;</span><br><span class="line">            npurgatory = npurgeable;</span><br><span class="line">        &#125;</span><br><span class="line">        arena-&gt;npurgatory -= npurgeable;</span><br><span class="line">        npurgatory -= npurgeable;</span><br><span class="line">        npurged = arena_chunk_purge(arena, chunk, all);</span><br><span class="line">        <span class="comment">// xf: 计算purge期望值npurgatory和实际purge值npurged差值</span></span><br><span class="line">        nunpurged = npurgeable - npurged;</span><br><span class="line">        arena-&gt;npurgatory += nunpurged;</span><br><span class="line">        npurgatory += nunpurged;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>chunk purge如下，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">size_t</span></span><br><span class="line">arena_chunk_purge(<span class="keyword">arena_t</span> *arena, <span class="keyword">arena_chunk_t</span> *chunk, <span class="keyword">bool</span> all)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (chunk == arena-&gt;spare) &#123;</span><br><span class="line">        ......</span><br><span class="line">        arena_chunk_alloc(arena);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// xf: 为了减小arena purge时arena lock的暂停时间，先将所有满足</span></span><br><span class="line">    <span class="comment">// 需求的unalloc dirty pages重新"alloc"并保存，待purge结束再重新</span></span><br><span class="line">    <span class="comment">// 释放回avail-tree.</span></span><br><span class="line">    arena_chunk_stash_dirty(arena, chunk, all, &amp;mapelms);</span><br><span class="line">    npurged = arena_chunk_purge_stashed(arena, chunk, &amp;mapelms);</span><br><span class="line">    arena_chunk_unstash_purged(arena, chunk, &amp;mapelms);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (npurged);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>chunk purge重点在于这是一个线性查找dirty pages过程，Je在这里会导致性能下降。更糟糕的是，之前和之后都是在arena lock被锁定的条件下被执行，绑定同一arena的线程不得不停下工作。因此，在正式purge前需要先把unalloc dirtypages全部临时分配出来，当purging时解锁arena lock，而结束后再一次将它们全部释放。</p>
<p>stash dirty代码，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">arena_chunk_stash_dirty(<span class="keyword">arena_t</span> *arena, <span class="keyword">arena_chunk_t</span> *chunk, <span class="keyword">bool</span> all,</span><br><span class="line">    <span class="keyword">arena_chunk_mapelms_t</span> *mapelms)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">for</span> (pageind = map_bias; pageind &lt; chunk_npages; pageind += npages) &#123;</span><br><span class="line">        <span class="keyword">arena_chunk_map_t</span> *mapelm = arena_mapp_get(chunk, pageind);</span><br><span class="line">        <span class="keyword">if</span> (arena_mapbits_allocated_get(chunk, pageind) == <span class="number">0</span>) &#123;</span><br><span class="line">            ......</span><br><span class="line">            <span class="keyword">if</span> (arena_mapbits_dirty_get(chunk, pageind) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">                (all || arena_avail_adjac(chunk, pageind,</span><br><span class="line">                npages))) &#123;</span><br><span class="line">                <span class="keyword">arena_run_t</span> *run = (<span class="keyword">arena_run_t</span> *)((<span class="keyword">uintptr_t</span>)</span><br><span class="line">                    chunk + (<span class="keyword">uintptr_t</span>)(pageind &lt;&lt; LG_PAGE));</span><br><span class="line">                <span class="comment">// xf: 暂时将这些unalloc dirty pages通过split large</span></span><br><span class="line">                <span class="comment">// 重新分配出来。                   </span></span><br><span class="line">                arena_run_split_large(arena, run, run_size,</span><br><span class="line">                    <span class="literal">false</span>);</span><br><span class="line">                <span class="comment">// 加入临时列表，留待后用。   </span></span><br><span class="line">                ql_elm_new(mapelm, u.ql_link);</span><br><span class="line">                ql_tail_insert(mapelms, mapelm, u.ql_link);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;    </span><br><span class="line">            <span class="comment">//xf: 跳过allocated pages</span></span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>stash时会根据传入的hint all判断，如果为false，只会stash存在clean-dirty adjac的pages，否则会全部加入列表。</p>
<p>purge stashed pages代码如下，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">size_t</span></span><br><span class="line">arena_chunk_purge_stashed(<span class="keyword">arena_t</span> *arena, <span class="keyword">arena_chunk_t</span> *chunk,</span><br><span class="line">    <span class="keyword">arena_chunk_mapelms_t</span> *mapelms)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// xf: 暂时解锁arena lock，前面已经realloc过，这里不考虑contention问题。</span></span><br><span class="line">    malloc_mutex_unlock(&amp;arena-&gt;lock);</span><br><span class="line">    ......</span><br><span class="line">    ql_foreach(mapelm, mapelms, u.ql_link) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// xf: 逐个purge dirty page，返回pages是否unzeroed.</span></span><br><span class="line">        unzeroed = pages_purge((<span class="keyword">void</span> *)((<span class="keyword">uintptr_t</span>)chunk + (pageind &lt;&lt;</span><br><span class="line">            LG_PAGE)), (npages &lt;&lt; LG_PAGE));</span><br><span class="line">        flag_unzeroed = unzeroed ? CHUNK_MAP_UNZEROED : <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// xf: 逐pages设置unzeroed标志。</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; npages; i++) &#123;</span><br><span class="line">            arena_mapbits_unzeroed_set(chunk, pageind+i,</span><br><span class="line">                flag_unzeroed);</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// xf: purging结束重新lock arena</span></span><br><span class="line">    malloc_mutex_lock(&amp;arena-&gt;lock);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> (npurged);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里要注意的是，在page purge过后，会逐一设置unzero flag。这是因为有些操作系统在demand page后会有一步zero-fill-on-demand。因此，被purge过的clean page当再一次申请到物理页面时会全部填充为0.</p>
<p>unstash代码，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">arena_chunk_unstash_purged(<span class="keyword">arena_t</span> *arena, <span class="keyword">arena_chunk_t</span> *chunk,</span><br><span class="line">    <span class="keyword">arena_chunk_mapelms_t</span> *mapelms)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">for</span> (mapelm = ql_first(mapelms); mapelm != <span class="literal">NULL</span>;</span><br><span class="line">        mapelm = ql_first(mapelms)) &#123;</span><br><span class="line">        ......</span><br><span class="line">        run = (<span class="keyword">arena_run_t</span> *)((<span class="keyword">uintptr_t</span>)chunk + (<span class="keyword">uintptr_t</span>)(pageind &lt;&lt;</span><br><span class="line">            LG_PAGE));</span><br><span class="line">        ql_remove(mapelms, mapelm, u.ql_link);</span><br><span class="line">        arena_run_dalloc(arena, run, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>unstash需要再一次调用arena_run_dalloc()以释放临时分配的pages。要注意此时我们已经位于arena_run_dalloc调用栈中，而避免无限递归重入依靠参数cleaned flag.</p>
<h2 id="4-5-arena-chunk-dalloc"><a href="#4-5-arena-chunk-dalloc" class="headerlink" title="4.5 - arena chunk dalloc"></a>4.5 - arena chunk dalloc</h2><p>当free chunk被Je释放时，根据局部性原理，会成为下一个spare chunk而保存起来，其真身并未消散。而原先的spare则会根据内部dalloc方法被处理掉。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">arena_chunk_dalloc(<span class="keyword">arena_t</span> *arena, <span class="keyword">arena_chunk_t</span> *chunk)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// xf: 将chunk从avail-tree上remove</span></span><br><span class="line">    arena_avail_remove(arena, chunk, map_bias, chunk_npages-map_bias,</span><br><span class="line">        <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// xf: 如果spare不为空，则将被释放的chunk替换原spare chunk.</span></span><br><span class="line">    <span class="keyword">if</span> (arena-&gt;spare != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">arena_chunk_t</span> *spare = arena-&gt;spare;</span><br><span class="line"></span><br><span class="line">        arena-&gt;spare = chunk;</span><br><span class="line">        arena_chunk_dalloc_internal(arena, spare);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        arena-&gt;spare = chunk;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>同chunk alloc一样，chunk dalloc算法也是可定制的。Je提供的默认算法chunk_dalloc_default最终会调用chunk_unmap，如下，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">chunk_unmap(<span class="keyword">void</span> *chunk, <span class="keyword">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// xf: 如果启用dss，且当前chunk在dss内，将其record在dss tree上。</span></span><br><span class="line">    <span class="comment">// 否则如果就记录在mmap tree上，或者直接munmap释放掉。</span></span><br><span class="line">    <span class="keyword">if</span> (have_dss &amp;&amp; chunk_in_dss(chunk))</span><br><span class="line">        chunk_record(&amp;chunks_szad_dss, &amp;chunks_ad_dss, chunk, size);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (chunk_dalloc_mmap(chunk, size))</span><br><span class="line">        chunk_record(&amp;chunks_szad_mmap, &amp;chunks_ad_mmap, chunk, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在3.3.5小节中alloc时会根据dss和mmap优先执行recycle。源自在dalloc时record在四棵chunk tree上的记录。但同spare记录的不同，这里的记录仅仅只剩下躯壳，record时会强行释放物理页面，因此recycle速度相比spare较慢。</p>
<p>chunk record算法如下，</p>
<ol>
<li>先purge chunk内部所有pages</li>
<li>预分配base node，以记录释放后的chunk。这里分配的node到后面可能没有用，提前分配是因为接下来要加锁chunks_mtx。而如果在临界段内再分配base node,则可能因为base pages不足而申请新的chunk，这样一来就会导致dead lock.</li>
<li>寻找与要插入chunk的毗邻地址。首先尝试与后面的地址合并，成功则用后者的base node记录，之后执行5.</li>
<li>合并失败，用预分配的base node记录chunk.</li>
<li>尝试与前面的地址合并。</li>
<li>如果预分配的base node没有使用，释放掉。</li>
</ol>
<p>代码如下，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">chunk_record(<span class="keyword">extent_tree_t</span> *chunks_szad, <span class="keyword">extent_tree_t</span> *chunks_ad, <span class="keyword">void</span> *chunk,</span><br><span class="line">    <span class="keyword">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// xf: purge all chunk pages</span></span><br><span class="line">    unzeroed = pages_purge(chunk, size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// xf: 预先分配extent_node以记录chunk。如果该chunk可以进行合并，该node</span></span><br><span class="line">    <span class="comment">// 可能并不会使用。这里预先分配主要是避免dead lock。因为某些情况</span></span><br><span class="line">    <span class="comment">// base_node_alloc同样可能会alloc base chunk，由于后面chunk mutex被lock,</span></span><br><span class="line">    <span class="comment">// 那样将导致dead lock.</span></span><br><span class="line">    xnode = base_node_alloc();</span><br><span class="line">    xprev = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    malloc_mutex_lock(&amp;chunks_mtx);</span><br><span class="line">    <span class="comment">// xf: 首先尝试与后面的chunk合并。</span></span><br><span class="line">    key.addr = (<span class="keyword">void</span> *)((<span class="keyword">uintptr_t</span>)chunk + size);</span><br><span class="line">    node = extent_tree_ad_nsearch(chunks_ad, &amp;key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (node != <span class="literal">NULL</span> &amp;&amp; node-&gt;addr == key.addr) &#123;</span><br><span class="line">        extent_tree_szad_remove(chunks_szad, node);</span><br><span class="line">        node-&gt;addr = chunk;</span><br><span class="line">        node-&gt;size += size;</span><br><span class="line">        node-&gt;zeroed = (node-&gt;zeroed &amp;&amp; (unzeroed == <span class="literal">false</span>));</span><br><span class="line">        extent_tree_szad_insert(chunks_szad, node);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;    </span><br><span class="line">        <span class="comment">// xf: 合并失败，用提前分配好的xnode保存当前chunk信息。</span></span><br><span class="line">        <span class="keyword">if</span> (xnode == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> label_return;</span><br><span class="line">        &#125;</span><br><span class="line">        node = xnode;</span><br><span class="line">        xnode = <span class="literal">NULL</span>;</span><br><span class="line">        node-&gt;addr = chunk;</span><br><span class="line">        node-&gt;size = size;</span><br><span class="line">        node-&gt;zeroed = (unzeroed == <span class="literal">false</span>);</span><br><span class="line">        extent_tree_ad_insert(chunks_ad, node);</span><br><span class="line">        extent_tree_szad_insert(chunks_szad, node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// xf: 再尝试与前面的chunk合并</span></span><br><span class="line">    prev = extent_tree_ad_prev(chunks_ad, node);</span><br><span class="line">    <span class="keyword">if</span> (prev != <span class="literal">NULL</span> &amp;&amp; (<span class="keyword">void</span> *)((<span class="keyword">uintptr_t</span>)prev-&gt;addr + prev-&gt;size) ==</span><br><span class="line">        chunk) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">label_return:</span><br><span class="line">    malloc_mutex_unlock(&amp;chunks_mtx);</span><br><span class="line">    <span class="comment">// xf: 如果预先分配的node没有使用，则在此将之销毁</span></span><br><span class="line">    <span class="keyword">if</span> (xnode != <span class="literal">NULL</span>)</span><br><span class="line">        base_node_dalloc(xnode);</span><br><span class="line">    <span class="keyword">if</span> (xprev != <span class="literal">NULL</span>)</span><br><span class="line">        base_node_dalloc(xprev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后顺带一提，对于mmap区的pages, Je也可以直接munmap，前提是需要在jemalloc_internal_defs.h中开启JEMALLOC_MUNMAP，这样就不会执行pages purge.默认该选项是不开启的。但源自dss区中的分配则不存在反向释放一说，默认Je也不会优先选择dss就是了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span></span><br><span class="line">chunk_dalloc_mmap(<span class="keyword">void</span> *chunk, <span class="keyword">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (config_munmap)</span><br><span class="line">        pages_unmap(chunk, size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (config_munmap == <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-6-large-huge-dalloc"><a href="#4-6-large-huge-dalloc" class="headerlink" title="4.6 - large/huge dalloc"></a>4.6 - large/huge dalloc</h2><p>前面说过large/huge相当于以run和chunk为粒度的特例。因此对于arena dalloc large来说，最终就是arena_run_dalloc。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">arena_dalloc_large_locked(<span class="keyword">arena_t</span> *arena, <span class="keyword">arena_chunk_t</span> *chunk, <span class="keyword">void</span> *ptr)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (config_fill || config_stats) &#123;</span><br><span class="line">        <span class="keyword">size_t</span> pageind = ((<span class="keyword">uintptr_t</span>)ptr - (<span class="keyword">uintptr_t</span>)chunk) &gt;&gt; LG_PAGE;</span><br><span class="line">        <span class="keyword">size_t</span> usize = arena_mapbits_large_size_get(chunk, pageind);</span><br><span class="line"></span><br><span class="line">        arena_dalloc_junk_large(ptr, usize);</span><br><span class="line">        <span class="keyword">if</span> (config_stats) &#123;</span><br><span class="line">            arena-&gt;stats.ndalloc_large++;</span><br><span class="line">            arena-&gt;stats.allocated_large -= usize;</span><br><span class="line">            arena-&gt;stats.lstats[(usize &gt;&gt; LG_PAGE) - <span class="number">1</span>].ndalloc++;</span><br><span class="line">            arena-&gt;stats.lstats[(usize &gt;&gt; LG_PAGE) - <span class="number">1</span>].curruns--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    arena_run_dalloc(arena, (<span class="keyword">arena_run_t</span> *)ptr, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而huge dalloc，则是在huge tree上搜寻，最终执行chunk_dalloc,<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">huge_dalloc(<span class="keyword">void</span> *ptr)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    malloc_mutex_lock(&amp;huge_mtx);</span><br><span class="line"></span><br><span class="line">    key.addr = ptr;</span><br><span class="line">    node = extent_tree_ad_search(&amp;huge, &amp;key);</span><br><span class="line">    assert(node != <span class="literal">NULL</span>);</span><br><span class="line">    assert(node-&gt;addr == ptr);</span><br><span class="line">    extent_tree_ad_remove(&amp;huge, node);</span><br><span class="line"></span><br><span class="line">    malloc_mutex_unlock(&amp;huge_mtx);</span><br><span class="line"></span><br><span class="line">    huge_dalloc_junk(node-&gt;addr, node-&gt;size);</span><br><span class="line">    arena_chunk_dalloc_huge(node-&gt;arena, node-&gt;addr, node-&gt;size);</span><br><span class="line">    base_node_dalloc(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">arena_chunk_dalloc_huge(<span class="keyword">arena_t</span> *arena, <span class="keyword">void</span> *chunk, <span class="keyword">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">chunk_dalloc_t</span> *chunk_dalloc;</span><br><span class="line"></span><br><span class="line">    malloc_mutex_lock(&amp;arena-&gt;lock);</span><br><span class="line">    chunk_dalloc = arena-&gt;chunk_dalloc;</span><br><span class="line">    <span class="keyword">if</span> (config_stats) &#123;</span><br><span class="line">        arena-&gt;stats.mapped -= size;</span><br><span class="line">        arena-&gt;stats.allocated_huge -= size;</span><br><span class="line">        arena-&gt;stats.ndalloc_huge++;</span><br><span class="line">        stats_cactive_sub(size);</span><br><span class="line">    &#125;</span><br><span class="line">    arena-&gt;nactive -= (size &gt;&gt; LG_PAGE);</span><br><span class="line">    malloc_mutex_unlock(&amp;arena-&gt;lock);</span><br><span class="line">    chunk_dalloc(chunk, size, arena-&gt;ind);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-总结-与Dl的对比"><a href="#5-总结-与Dl的对比" class="headerlink" title="5 - 总结: 与Dl的对比"></a>5 - 总结: 与Dl的对比</h2><ol>
<li>单核单线程分配能力上两者不相上下，甚至小块内存分配速度理论上Dl还略占优势。原因是Dl利用双向链表组织free chunk可以做到O(1)，而尽管Je在bitmap上做了一定优化，但不能做到常数时间。</li>
<li>多核多线程下，Je可以秒杀Dl。arena的加入既可以避免false sharing，又可以减少线程间lock contention。另外，tcache也是可以大幅加快多线程分配速度的技术。这些Dl完全不具备竞争力。</li>
<li>系统内存交换效率上也是Je占明显优势。Je使用mmap/madvise的组合要比Dl使用sbrk/mmap/munmap灵活的多。实际对系统的压力也更小。另外，Dl使用dss-&gt;mmap,追求的是速度，而Je相反mmap-&gt;dss，为的是灵活性。</li>
<li>小块内存的碎片抑制上双方做的都不错，但总体上个人觉得Je更好一些。首先dalloc时，两者对空闲内存都可以实时coalesce。alloc时Dl依靠dv约束外部碎片，Je更简单暴力，直接在固定的small runs里分配。   <ol>
<li>两相比较，dv的候选者是随机的，大小不固定，如果选择比较小的chunk，效果其实有限。更甚者，当找不到dv时，Dl会随意切割top-most space，通常这不利于heap trim.</li>
<li>而small runs则是固定大小，同时是页面的整数倍，对外部碎片的约束力和规整度上都更好。</li>
<li>但Dl的优势在算法更简单，速度更快。无论是coalesce还是split代价都很低。在Je中有可能因为分配8byte的内存而实际去分配并初始化4k甚至4M的空间。</li>
</ol>
</li>
<li>大块内存分配能力上，Dl使用dst管理，而Je采用rb tree。原理上，据说rb tree的cache亲和力较差，不适合memory allocator。我没有仔细研究Je的rb tree实现有何过人之处，暂且认为各有千秋吧。可以肯定的是Je的large/huge region具有比Dl更高的内部碎片，皆因为其更规整的size class划分导致的。</li>
<li>说到size class，可以看到Je的划分明显比Dl更细致，tiny/small/large/huge四种分类能兼顾更多的内存使用模型。且根据不同架构和配置，可以灵活改变划分方式，具有更好的兼容性。Dl划分的相对粗糙很多且比较固定。一方面可能在当时256byte以上就可以算作大块的分配了吧。另一方面某种程度是碍于算法的限制。比如在boundary tag中为了容纳更多的信息，就不能小于8byte(实际有效的最小chunk是16byte), bin数量不得多余31个也是基于位运算的方式。</li>
<li>bookkeeping占用上Dl因为算法简单，本应该占用更少内存。但由于boundary tag本身导致的占用，chunk数量越多，bookkeeping就越大。再考虑到系统回收效率上的劣势，应该说，应用内存占用越大，尤其是小内存使用量越多，运行时间越长，Dl相对于Je内存使用量倾向越大。</li>
<li>安全健壮性。只说一点，boundary tag是原罪，其他的可以免谈了。</li>
</ol>
<h1 id="附-快速调试Jemalloc"><a href="#附-快速调试Jemalloc" class="headerlink" title="附: 快速调试Jemalloc"></a>附: 快速调试Jemalloc</h1><p>一个简单的调试Je的方法是以静态库的方式将其编译到你的应用程序中。先编译Je的静态库，在源码目录下执行，<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure></p>
<p>就可以编译并安装Je到系统路径。调试还必须打开一些选项，例如，<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --<span class="built_in">enable</span>-debug  --with-jemalloc-prefix=&lt;prefix&gt;</span><br></pre></td></tr></table></figure></p>
<p>这些选项的意义可以参考INSTALL文档。比如，</p>
<ul>
<li><code>--disable-tcache</code> 是否禁用tcache，对调试非tcache流程有用。</li>
<li><code>--disable-prof</code>   是否禁用heap profile.</li>
<li><code>--enable-debug</code>   打开调试模式，启动assert并关闭优化。</li>
<li><code>--with-jemalloc-prefix</code>  将编译出的malloc加上设定的前缀，以区别c库的调用。</li>
</ul>
<p>之后就可以将其编译到你的代码中，如，<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc main.c /usr/<span class="built_in">local</span>/lib/libjemalloc.a -std=c99 -O0 -g3 -pthread -o jhello</span><br></pre></td></tr></table></figure></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/C/" rel="tag"># C++</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/10/15/glibc内存管理ptmalloc源代码分析1/" rel="next" title="glibc内存管理ptmalloc源代码分析1">
                <i class="fa fa-chevron-left"></i> glibc内存管理ptmalloc源代码分析1
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/11/01/jemalloc源码解析/" rel="prev" title="jemalloc源码解析">
                jemalloc源码解析 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/header.jpg" alt="Hao Yu">
            
              <p class="site-author-name" itemprop="name">Hao Yu</p>
              <p class="site-description motion-element" itemprop="description">Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author</p>
          </div>
          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">353</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>
        	<audio controls="controls" loop="loop" preload="auto" src="/resource/xiaomeihao.mp3">
	        </audio>
	

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yuhao0102" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:yuh18@mails.tsinghua.edu.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-简介"><span class="nav-number">1.</span> <span class="nav-text">1 - 简介</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-Basic-structures"><span class="nav-number">2.</span> <span class="nav-text">2 - Basic structures</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-Overview"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 - Overview</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-Arena-arena-t"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 - Arena (arena_t)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-1-CPU-Cache-Line"><span class="nav-number">2.2.1.</span> <span class="nav-text">2.2.1 - CPU Cache-Line</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-2-Arena原理"><span class="nav-number">2.2.2.</span> <span class="nav-text">2.2.2 - Arena原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-3-choose-arena"><span class="nav-number">2.2.3.</span> <span class="nav-text">2.2.3 - choose_arena</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-4-Arena结构"><span class="nav-number">2.2.4.</span> <span class="nav-text">2.2.4 - Arena结构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-Chunk-arena-chunk-t"><span class="nav-number">2.3.</span> <span class="nav-text">2.3 - Chunk (arena_chunk_t)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-1-overview"><span class="nav-number">2.3.1.</span> <span class="nav-text">2.3.1 - overview</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-2-Chunk结构"><span class="nav-number">2.3.2.</span> <span class="nav-text">2.3.2 - Chunk结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-3-chunk-map-arena-chunk-map-t"><span class="nav-number">2.3.3.</span> <span class="nav-text">2.3.3 - chunk map (arena_chunk_map_t)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-4-Run-arena-run-t"><span class="nav-number">2.4.</span> <span class="nav-text">2.4 - Run (arena_run_t)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-1-Run结构"><span class="nav-number">2.4.1.</span> <span class="nav-text">2.4.1 - Run结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-2-size-classes"><span class="nav-number">2.4.2.</span> <span class="nav-text">2.4.2 - size classes</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-3-size2bin-bin2size"><span class="nav-number">2.4.3.</span> <span class="nav-text">2.4.3 - size2bin/bin2size</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-5-bins-arena-bin-t"><span class="nav-number">2.5.</span> <span class="nav-text">2.5 - bins (arena_bin_t)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-6-Thread-caches-tcache-t"><span class="nav-number">2.6.</span> <span class="nav-text">2.6 - Thread caches (tcache_t)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-7-Extent-Node-extent-node-t"><span class="nav-number">2.7.</span> <span class="nav-text">2.7 - Extent Node (extent_node_t)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-8-Base"><span class="nav-number">2.8.</span> <span class="nav-text">2.8 - Base</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-Allocation"><span class="nav-number">3.</span> <span class="nav-text">3 - Allocation</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-Overview"><span class="nav-number">3.1.</span> <span class="nav-text">3.1 - Overview</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-Initialize"><span class="nav-number">3.2.</span> <span class="nav-text">3.2 - Initialize</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-Small-allocation-Arena"><span class="nav-number">3.3.</span> <span class="nav-text">3.3 - Small allocation (Arena)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-1-arena-run-reg-alloc"><span class="nav-number">3.3.1.</span> <span class="nav-text">3.3.1 - arena_run_reg_alloc</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-2-arena-bin-malloc-hard"><span class="nav-number">3.3.2.</span> <span class="nav-text">3.3.2 - arena_bin_malloc_hard</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-3-arena-bin-nonfull-run-get"><span class="nav-number">3.3.3.</span> <span class="nav-text">3.3.3 - arena_bin_nonfull_run_get</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-4-Small-Run-Alloc"><span class="nav-number">3.3.4.</span> <span class="nav-text">3.3.4 - Small Run Alloc</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-5-Chunk-Alloc"><span class="nav-number">3.3.5.</span> <span class="nav-text">3.3.5 - Chunk Alloc</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-4-Small-allocation-tcache"><span class="nav-number">3.4.</span> <span class="nav-text">3.4 - Small allocation (tcache)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-5-Large-allocation"><span class="nav-number">3.5.</span> <span class="nav-text">3.5 - Large allocation</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-6-Huge-allocation"><span class="nav-number">3.6.</span> <span class="nav-text">3.6 - Huge allocation</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-Deallocation"><span class="nav-number">4.</span> <span class="nav-text">4 - Deallocation</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-Overview"><span class="nav-number">4.1.</span> <span class="nav-text">4.1 - Overview</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-arena-dalloc-bin"><span class="nav-number">4.2.</span> <span class="nav-text">4.2 - arena_dalloc_bin</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-3-small-run-dalloc"><span class="nav-number">4.3.</span> <span class="nav-text">4.3 - small run dalloc</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-4-arena-purge"><span class="nav-number">4.4.</span> <span class="nav-text">4.4 - arena purge</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-5-arena-chunk-dalloc"><span class="nav-number">4.5.</span> <span class="nav-text">4.5 - arena chunk dalloc</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-6-large-huge-dalloc"><span class="nav-number">4.6.</span> <span class="nav-text">4.6 - large/huge dalloc</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-总结-与Dl的对比"><span class="nav-number">4.7.</span> <span class="nav-text">5 - 总结: 与Dl的对比</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#附-快速调试Jemalloc"><span class="nav-number">5.</span> <span class="nav-text">附: 快速调试Jemalloc</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>
  <div id="DvelopmentTarget">     
  </div>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart" aria-hidden="false"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>

  
</div>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_uv"> 
  本站访客数<span id="busuanzi_value_site_uv"></span>人次
</span>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  


  <script type="text/javascript" src="/js/src/love.js"></script>

</body>
</html>
