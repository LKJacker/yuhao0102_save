<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zn-ch">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-center-simple.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Linux,">










<meta name="description" content="守护进程守护进程的特征父进程ID为0的各进程通常是内核进程，它们作为系统引导装入过程的一部分而启动。(init是个例外，它是一个由内核在引导装入时启动的用户层次的命令)，内核进程是特殊的，通常存在于系统的整个生命期中。它们以超级用户特权运行，无控制终端，无命令行。 对于需要在进程上下文执行工作但却不被用户层进程上下文调用的每一个内核组件，通常有它自己的内核守护进程。例如，在Linux中，  ksw">
<meta name="keywords" content="Linux">
<meta property="og:type" content="article">
<meta property="og:title" content="UNIX高级编程 笔记6">
<meta property="og:url" content="http://yoursite.com/2021/06/02/UNIX高级编程 笔记6/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="守护进程守护进程的特征父进程ID为0的各进程通常是内核进程，它们作为系统引导装入过程的一部分而启动。(init是个例外，它是一个由内核在引导装入时启动的用户层次的命令)，内核进程是特殊的，通常存在于系统的整个生命期中。它们以超级用户特权运行，无控制终端，无命令行。 对于需要在进程上下文执行工作但却不被用户层进程上下文调用的每一个内核组件，通常有它自己的内核守护进程。例如，在Linux中，  ksw">
<meta property="og:locale" content="zn-ch">
<meta property="og:image" content="http://yoursite.com/img/1622621887.jpg">
<meta property="og:image" content="http://yoursite.com/img/1622627160.jpg">
<meta property="og:image" content="http://yoursite.com/img/1622640114.jpg">
<meta property="og:image" content="http://yoursite.com/img/1622641438.jpg">
<meta property="og:image" content="http://yoursite.com/img/1622642397.jpg">
<meta property="og:image" content="http://yoursite.com/img/1622643609.jpg">
<meta property="og:image" content="http://yoursite.com/img/20210602112207.png">
<meta property="og:image" content="http://yoursite.com/img/20210604122019.png">
<meta property="og:image" content="http://yoursite.com/img/20210604124542.png">
<meta property="og:image" content="http://yoursite.com/img/1622869817.jpg">
<meta property="og:updated_time" content="2021-06-06T10:45:47.715Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="UNIX高级编程 笔记6">
<meta name="twitter:description" content="守护进程守护进程的特征父进程ID为0的各进程通常是内核进程，它们作为系统引导装入过程的一部分而启动。(init是个例外，它是一个由内核在引导装入时启动的用户层次的命令)，内核进程是特殊的，通常存在于系统的整个生命期中。它们以超级用户特权运行，无控制终端，无命令行。 对于需要在进程上下文执行工作但却不被用户层进程上下文调用的每一个内核组件，通常有它自己的内核守护进程。例如，在Linux中，  ksw">
<meta name="twitter:image" content="http://yoursite.com/img/1622621887.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2021/06/02/UNIX高级编程 笔记6/">





  <title>UNIX高级编程 笔记6 | Hao Yu's blog</title>
  








 
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zn-ch">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hao Yu's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">The program monkey was eaten by the siege lion.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-mybetterhalf">
          <a href="/mybetterhalf/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>
            
            mybetterhalf
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="Searching..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/06/02/UNIX高级编程 笔记6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">UNIX高级编程 笔记6</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-06-02T16:20:00+08:00">
                2021-06-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h1><h2 id="守护进程的特征"><a href="#守护进程的特征" class="headerlink" title="守护进程的特征"></a>守护进程的特征</h2><p>父进程ID为0的各进程通常是内核进程，它们作为系统引导装入过程的一部分而启动。(init是个例外，它是一个由内核在引导装入时启动的用户层次的命令)，内核进程是特殊的，通常存在于系统的整个生命期中。它们以超级用户特权运行，无控制终端，无命令行。</p>
<p>对于需要在进程上下文执行工作但却不被用户层进程上下文调用的每一个内核组件，通常有它自己的内核守护进程。例如，在Linux中，</p>
<ul>
<li><code>kswapd</code>守护进程也称为内存换页守护进程。它支持虚拟内存子系统在经过一段时间后将脏页面慢慢地写回磁盘来回收这些页面；</li>
<li><code>flush</code>守护进程在可用内存达到设置的最小阈值时将脏页面冲洗至磁盘，它也定期地将脏页面冲洗回磁盘来减少在系统出现故障时发生的数据丢失，多个冲洗守护进程可以同时存在，每个写回的设备都有一个冲洗守护进程；</li>
<li><code>sync_supers</code>守护进程定期将文件系统元数据冲洗至磁盘。</li>
<li><code>job</code>守护进程帮助实现了ext4文件系统中的日志功能。</li>
</ul>
<p><code>init</code>是一个系统守护进程，除了其他工作外，主要负责启动各运行层次特定的系统服务。这些服务通常是在它们自己拥有的守护进程的帮助下实现的。</p>
<p><code>rpcbind</code>守护进程提供将远程过程调用(Remote Procedure Call, RPC)程序号映射为网络端口号的服务。<code>rsyslogd</code>守护进程可以被由管理员启用的将系统消息记入日志的任何程序使用。可以在一台实际的控制台上打印这些消息，也可将它们写到一个文件中。</p>
<p><code>cron</code>守护进程在定期安排的日期和时间执行命令。许多系统管理任务是通过<code>cron</code>每隔一段固定的时间就运行相关程序而得以实现的。<code>atd</code>守护进程与<code>cron</code>类似，它允许用户在指定的时间执行任务，但是每个任务它只执行一次，而非在定期安排的时间反复执行。<code>cupsd</code>守护进程是个打印假脱机进程，它处理对系统提出的各个打印请求。<code>sshd</code>守护进程提供了安全的远程登录和执行设施。</p>
<p>注意，大多数守护进程都以超级用户(root)特权运行。所有的守护进程都没有控制终端，其终端名设置为问号。内核守护进程以无控制终端方式启动。用户层守护进程缺少控制终端可能是守护进程调用了<code>setsid</code>的结果。大多数用户层守护进程都是进程组的组长进程以及会话的首进程，而且是这些进程组和会话中的唯一进程(<code>rsyslogd</code>是一个例外)。最后，应当引起注意的是用户层守护进程的父进程是<code>init</code>进程。</p>
<h2 id="编程规则"><a href="#编程规则" class="headerlink" title="编程规则"></a>编程规则</h2><p>在编写守护进程程序时需遵循一些基本规则，以防止产生不必要的交互作用。</p>
<ul>
<li>首先要做的是调用<code>umask</code>将文件模式创建屏蔽字设置为一个已知值(通常是0)。由继承得来的文件模式创建屏蔽字可能会被设置为拒绝某些权限。如果守护进程要创建文件，那么它可能要设置特定的权限。例如，若守护进程要创建组可读、组可写的文件，继承的文件模式创建屏蔽字可能会屏蔽上述两种权限中的一 种，而使其无法发挥作用。另一方面，如果守护进程调用的库函数创建了文件，那么将文件模式创建屏蔽字设置为一个限制性更强的值(如007)可能会更明智，因为库函数可能不允许调用者通过一个显式的函数参数来设置权限。</li>
<li>调用<code>fork</code>，然后使父进程<code>exit</code>。这样做实现了下面几点。第一，如果该守护进程是作为一条简单的shell命令启动的，那么父进程终止会让shell认为这条命令已经执行完毕。第二，虽然子进程继承了父进程的进程组ID，但获得了一个新的进程ID，这就保证了子进程不是一个进程组的组长进程。这是下面将要进行的<code>setsid</code>调用的先决条件。</li>
<li>调用<code>setsid</code>创建一个新会话。然后执行3个步骤，使调用进程：<ul>
<li>成为新会话的首进程，</li>
<li>成为一个新进程组的组长进程，</li>
<li>没有控制终端。</li>
</ul>
</li>
<li>将当前工作目录更改为根目录。从父进程处继承过来的当前工作目录可能在一个挂载的文件系统中。因为守护进程通常在系统再引导之前是一直存在的，所以如果守护进程的当前工作目录在一个挂载文件系统中，那么该文件系统就不能被卸载。或者。某些守护进程还可能会把当前工作目录更改到某个指定位置，并在此位置进行它们的全部工作。</li>
<li>关闭不再需要的文件描述符。这使守护进程不再持有从其父进程继承来的任何文件描述符。可以使用<code>open_max</code>函数或<code>getrlimit</code>函数来判定最高文件描述符值，并关闭直到该值的所有描述符。</li>
<li>某些守护进程打开/dev/null使其具有文件描述符0、1和2，这样，任何一个试图读标准输入、写标准输出或标准错误的库例程都不会产生任何效果。因为守护进程并不与终端设备相关联。即使守护进程是从交互式会话启动的，但是守护进程是在后台运行的，所以登录会话的终止并不影响守护进程。</li>
</ul>
<p>函数可由一个想要初始化为守护进程的程序调用。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;syslog.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">daemonize(<span class="keyword">const</span> <span class="keyword">char</span> *cmd)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span>					i, fd0, fd1, fd2;</span><br><span class="line">	<span class="keyword">pid_t</span>				pid;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span>		<span class="title">rl</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span>	<span class="title">sa</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Clear file creation mask.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	umask(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Get maximum number of file descriptors.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (getrlimit(RLIMIT_NOFILE, &amp;rl) &lt; <span class="number">0</span>)</span><br><span class="line">		err_quit(<span class="string">"%s: can't get file limit"</span>, cmd);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Become a session leader to lose controlling TTY.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">		err_quit(<span class="string">"%s: can't fork"</span>, cmd);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (pid != <span class="number">0</span>) <span class="comment">/* parent */</span></span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	setsid();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Ensure future opens won't allocate controlling TTYs.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	sa.sa_handler = SIG_IGN;</span><br><span class="line">	sigemptyset(&amp;sa.sa_mask);</span><br><span class="line">	sa.sa_flags = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (sigaction(SIGHUP, &amp;sa, <span class="literal">NULL</span>) &lt; <span class="number">0</span>)</span><br><span class="line">		err_quit(<span class="string">"%s: can't ignore SIGHUP"</span>, cmd);</span><br><span class="line">	<span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">		err_quit(<span class="string">"%s: can't fork"</span>, cmd);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (pid != <span class="number">0</span>) <span class="comment">/* parent */</span></span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Change the current working directory to the root so</span></span><br><span class="line"><span class="comment">	 * we won't prevent file systems from being unmounted.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (chdir(<span class="string">"/"</span>) &lt; <span class="number">0</span>)</span><br><span class="line">		err_quit(<span class="string">"%s: can't change directory to /"</span>, cmd);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Close all open file descriptors.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (rl.rlim_max == RLIM_INFINITY)</span><br><span class="line">		rl.rlim_max = <span class="number">1024</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; rl.rlim_max; i++)</span><br><span class="line">		close(i);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Attach file descriptors 0, 1, and 2 to /dev/null.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	fd0 = open(<span class="string">"/dev/null"</span>, O_RDWR);</span><br><span class="line">	fd1 = dup(<span class="number">0</span>);</span><br><span class="line">	fd2 = dup(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Initialize the log file.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	openlog(cmd, LOG_CONS, LOG_DAEMON);</span><br><span class="line">	<span class="keyword">if</span> (fd0 != <span class="number">0</span> || fd1 != <span class="number">1</span> || fd2 != <span class="number">2</span>) &#123;</span><br><span class="line">		syslog(LOG_ERR, <span class="string">"unexpected file descriptors %d %d %d"</span>,</span><br><span class="line">		  fd0, fd1, fd2);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>若daemonize函数由main程序调用，然后main程序进入休眠状态，那么可以用ps命令检查该守护进程的状态：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out</span><br><span class="line">$ ps -efj </span><br><span class="line">UID   PID PPID  PGID   SID TTY CMD</span><br><span class="line">sar 13800    1 13799 13799  ?  ./a.out</span><br><span class="line">$ ps -efj | grep 13799</span><br><span class="line">sar 13800    1 13799 13799  ?  ./a.out</span><br></pre></td></tr></table></figure></p>
<p>我们也可用ps命令验证，没有活动进程存在的ID是13799，这意味着，守护进程在一个孤儿进程组中，它不是会话首进程，因此没有机会被分配到一个控制终端。这一结果是在<code>daemonize</code>函数中执行第二个<code>fork</code>造成的。可以看出，守护进程已经被正确地初始化了。</p>
<h2 id="出错记录"><a href="#出错记录" class="headerlink" title="出错记录"></a>出错记录</h2><p>守护进程存在的一个问题是如何处理出错消息。因为它本就不应该有控制终端，所以不能只是简单地写到标准错误上，需要有一个集中的守护进程出错记录设施。</p>
<p>有以下3种产生日志信息的方法，</p>
<ol>
<li>内核例程可以调用<code>log</code>函数。任何一个用户进程都可以通过打开(<code>open</code>)并读取(<code>read</code>)/dev/klog设备来读取这些消息。</li>
<li>大多数用户进程(守护进程)调用<code>syslog</code>(3)函数来产生日志消息。这使消息被发送至UNIX域数据报套接字<code>/dev/log</code>。</li>
<li>无论一个用户进程是在此主机上，还是在通过TCPIP网络连接到此主机的其他主机上，都可将日志消息发向UDP端口514。注意，<code>syslog</code>函数从不产生这些UDP数据报，它们要求产生此日志消息的进程进行显式的网络编程。</li>
</ol>
<p>通常，<code>syslogd</code>守护进程读取所有3种格式的日志消息。此守护进程在启动时读一个配置文件，其文件名一般为<code>/etc/syslog.cont</code>。该文件决定了不同种类的消息应送向何处。例如，紧急消息可发送至系统管理员(着已登录)，并在控制台上打印，而警告消息则可记录到一个文件中。该设施的接口是<code>syslog</code>函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;syslog.h&gt;</span></span></span><br><span class="line">void openlog(const char *ident, int option, int facility) :</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">syslog</span><span class="params">(<span class="keyword">int</span> prionity, <span class="keyword">const</span> <span class="keyword">char</span> *formar, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">closelog</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setlogmask</span><span class="params">(<span class="keyword">int</span> markpri)</span></span>;</span><br><span class="line"><span class="comment">// 返回值，前日志记录优先级屏蔽字值</span></span><br></pre></td></tr></table></figure></p>
<p>调用<code>openlog</code>是可选择的。如果不调用<code>openlog</code>，则在第一次调用<code>syslog</code>时，自动调用<code>openlog</code>。调用<code>closelog</code>也是可选择的，因为它只是关闭曾被用于与<code>synlogd</code>守护进程进行通信的描述符。</p>
<p>调用<code>openlog</code>使我们可以指定一个<code>ident</code>，以后，此<code>ident</code>将被加至每则日志消息中。<code>ident</code>一般是程序的名称，<code>option</code>参数是指定各种选项的位屏蔽。表中介绍了可用的option(选项)。</p>
<p>|<code>option</code>|说明|<br>|<code>LOG_CONS</code>|若日志消息不能通过UNIX域数据报送至<code>syslogd</code>，则将该消息写至控制台|<br>|<code>LOG_NDELAY</code>|立即打开至<code>syslogd</code>守护进程的UNIX域数据报套接字，不要等到第一条消息已经被记录时再打开。通常，在记录第一条消息之前，不打开该套接字|<br>|<code>LOG_NOWATT</code>|不要等待在将消息记入日志过程中可能已创建的子进程。因为在<code>syslog</code>调用<code>wait</code>时，应用程序可能已获得了子进程的状态。这种处理限止了与捕提SIGCKLD信号的应用程序之间产生的冲突|<br>|<code>LOG_OOELAY</code>|在第一条消息被记录之前越迟打开至<code>syslogd</code>守护进程的连接|<br>|<code>LOG_PERROR</code>|除将日志消息发送给<code>syslogd</code>以外，还将它写至标准出错|<br>|<code>LOG_PID</code>|记录每条消息都要包含进程ID。此选项可供对每个不同的请求都<code>fork</code>一个子进程的守护进程使用|</p>
<p><code>openlog</code>的<code>facility</code>参数值选取自下图。设置<code>facility</code>参数的目的是可以让配置文件说明，来自不同设施的消息将以不同的方式进行处理。如果不调用<code>openlog</code>，或者以<code>facility</code>为0来调用它，那么在调用<code>syslog</code>时，可将<code>facility</code>作为<code>priority</code>参数的一个部分进行说明。</p>
<p>调用<code>syslog</code>产生一个日志消息。其<code>priority</code>参数是<code>facility</code>和<code>level</code>的组合，它们可选取的值分别列于<code>facility</code>和<code>level</code>中。<code>level</code>值按优先级从最高到最低依次排列。<br><img src="/img/1622621887.jpg" alt></p>
<p>将<code>format</code>参数以及其他所有参数传至<code>vsprintf</code>函数以便进行格式化。在<code>format</code>中，每个出现的<code>%m</code>字符都先被代换成与errno值对应的出错消息字符串(strerror)。<code>setlogmask</code>函数用于设置进程的记录优先级屏蔽字。它返回调用它之前的屏蔽字。当设置了记录优先级屏蔽字时，各条消息除非已在记录优先级屏蔽字中进行了设置，否则将不被记录。</p>
<p>在一个守护进程中，可能包含有下面的调用序列：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">openlog(<span class="string">"lpd"</span>, LOG_PID, LOG_LPR);</span><br><span class="line">syslog (LOG_ERR, <span class="string">"open error for %s: %m”, filename);</span></span><br></pre></td></tr></table></figure></p>
<p>第一个调用将<code>ident</code>字符串设置为程序名，指定该进程ID要始终被打印。对<code>syslog</code>的调用指定一个出错条件和一个消息字符串。如若不调用<code>openlog</code>，则第二个调用的形式可能是：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">syslog (LOG_ERR | LOG_LPR, <span class="string">"open error for %s: %m"</span>, filename);</span><br></pre></td></tr></table></figure></p>
<p>其中，将<code>priority</code>参数指定为<code>level</code>和<code>facility</code>的组合。</p>
<p>除了<code>syslog</code>，很多平台还提供它的一种变体来处理可变参数列表。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;syslog.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vsyslog</span><span class="params">(<span class="keyword">int</span> priority, <span class="keyword">const</span> <span class="keyword">char</span> *format, va_list arg)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h2 id="单实例守护进程"><a href="#单实例守护进程" class="headerlink" title="单实例守护进程"></a>单实例守护进程</h2><p>为了正常运作，某些守护进程会实现为，在任一时刻只运行该守护进程的一个副本。文件和记录锁机制为一种方法提供了基础，该方法保证一个守护进程只有一个副本在运行，文件和记录锁提供了一种方便的互斥机制。如果守护进程在一个文件的整体上得到一把写锁，那么在该守护进程终止时，这把锁将被自动删除。这就简化了复原所需的处理，去除了对以前的守护进程实例需要进行清理的有关操作。</p>
<p>所示的函数说明了如何使用文件和记录镜来保证只运行一个守护进程的一个副本。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;syslog.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCKFILE <span class="meta-string">"/var/run/daemon.pid"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCKMODE (S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">lockfile</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">already_running(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span>		fd;</span><br><span class="line">	<span class="keyword">char</span>	buf[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line">	fd = open(LOCKFILE, O_RDWR|O_CREAT, LOCKMODE);</span><br><span class="line">	<span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		syslog(LOG_ERR, <span class="string">"can't open %s: %s"</span>, LOCKFILE, strerror(errno));</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (lockfile(fd) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (errno == EACCES || errno == EAGAIN) &#123;</span><br><span class="line">			close(fd);</span><br><span class="line">			<span class="keyword">return</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		syslog(LOG_ERR, <span class="string">"can't lock %s: %s"</span>, LOCKFILE, strerror(errno));</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	ftruncate(fd, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">sprintf</span>(buf, <span class="string">"%ld"</span>, (<span class="keyword">long</span>)getpid());</span><br><span class="line">	write(fd, buf, <span class="built_in">strlen</span>(buf)+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>守护进程的每个副本都将试图创建一个文件，并将其进程ID写到该文件中。这使管理人员易于标识该进程。如果该文件已经加了锁，那么<code>lockfile</code>函数将失败，errno设置为EACCES或EAGAIN，函数返回1，表明该守护进程已在运行。否则将文件长度截断为0，将进程ID写入该文件，函数返回0。</p>
<p>需要将文件长度截断为0，其原因是之前的守护进程实例的进程ID字符串可能长于调用此函数的当前进程的进程ID字符串。例如，若以前的守护进程的进程ID是12345，而新实例的进程ID是9999，那么将此进程ID写入文件后，在文件中留下的是99995。将文件长度截断为0就解决了此问题。</p>
<h2 id="守护进程的惯例"><a href="#守护进程的惯例" class="headerlink" title="守护进程的惯例"></a>守护进程的惯例</h2><ul>
<li>若守护进程使用锁文件，那么该文件通常存储在/var/run目录中。然而需要注意的是，守护进程可能需要具有超级用户权限才能在此目录下创建文件，锁文件的名字通常是<code>name.pid</code>，其中，<code>name</code>是该守护进程或服务的名字，</li>
<li>若守护进程支持配置选项，那么配置文件通常存放在/etc目录中。配置文件的名字通常是<code>name.conf</code>。其中，<code>name</code>是该守护进程或服务的名字。例如，<code>syslogd</code>守护进程的配置文件通常是<code>/etc/syslog.conf</code>。</li>
<li>守护进程可用命令行启动，但通常它们是由系统初始化脚本之一(<code>/etc/rc*</code>或<code>/etc/init.d/*</code>)启动的。如果在守护进程终止时，应当自动地重新启动它，则我们可在<code>/etc/inittab</code>中为该守护进程包括<code>respawn</code>记录项，这样，init就将重新启动该守护进程。</li>
<li>若一个守护进程有一个配置文件，那么当该守护进程启动时会读该文件，但在此之后一般就不会再查看它。若某个管理员更改了配置文件， 那么该守护进程可能需要被停止，然后再启动，以使配置文件的更改生效。为避免此种麻烦，某些守护进程将捕捉<code>SIGHUP</code>信号，当它们接收到该信号时，重新读配置文件。</li>
</ul>
<p>程序说明了守护进程可以重读其配置文件的一种方法。该程序使用<code>sigwait</code>以及多线程。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;syslog.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">sigset_t</span>	mask;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">already_running</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">reread(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *</span><br><span class="line">thr_fn(<span class="keyword">void</span> *arg)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> err, signo;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		err = sigwait(&amp;mask, &amp;signo);</span><br><span class="line">		<span class="keyword">if</span> (err != <span class="number">0</span>) &#123;</span><br><span class="line">			syslog(LOG_ERR, <span class="string">"sigwait failed"</span>);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">switch</span> (signo) &#123;</span><br><span class="line">		<span class="keyword">case</span> SIGHUP:</span><br><span class="line">			syslog(LOG_INFO, <span class="string">"Re-reading configuration file"</span>);</span><br><span class="line">			reread();</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> SIGTERM:</span><br><span class="line">			syslog(LOG_INFO, <span class="string">"got SIGTERM; exiting"</span>);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			syslog(LOG_INFO, <span class="string">"unexpected signal %d\n"</span>, signo);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span>					err;</span><br><span class="line">	<span class="keyword">pthread_t</span>			tid;</span><br><span class="line">	<span class="keyword">char</span>				*cmd;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span>	<span class="title">sa</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((cmd = <span class="built_in">strrchr</span>(argv[<span class="number">0</span>], <span class="string">'/'</span>)) == <span class="literal">NULL</span>)</span><br><span class="line">		cmd = argv[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		cmd++;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Become a daemon.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	daemonize(cmd);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Make sure only one copy of the daemon is running.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (already_running()) &#123;</span><br><span class="line">		syslog(LOG_ERR, <span class="string">"daemon already running"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Restore SIGHUP default and block all signals.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	sa.sa_handler = SIG_DFL;</span><br><span class="line">	sigemptyset(&amp;sa.sa_mask);</span><br><span class="line">	sa.sa_flags = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (sigaction(SIGHUP, &amp;sa, <span class="literal">NULL</span>) &lt; <span class="number">0</span>)</span><br><span class="line">		err_quit(<span class="string">"%s: can't restore SIGHUP default"</span>);</span><br><span class="line">	sigfillset(&amp;mask);</span><br><span class="line">	<span class="keyword">if</span> ((err = pthread_sigmask(SIG_BLOCK, &amp;mask, <span class="literal">NULL</span>)) != <span class="number">0</span>)</span><br><span class="line">		err_exit(err, <span class="string">"SIG_BLOCK error"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Create a thread to handle SIGHUP and SIGTERM.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	err = pthread_create(&amp;tid, <span class="literal">NULL</span>, thr_fn, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (err != <span class="number">0</span>)</span><br><span class="line">		err_exit(err, <span class="string">"can't create thread"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Proceed with the rest of the daemon.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">/* ... */</span></span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该程序调用了<code>daemonize</code>来初始化守护进程。从该函数返回后，调用<code>already_running</code>函数以确保该守护进程只有一个副本在运行。到达这一点时，<code>SIGHUP</code>信号仍被忽略，所以需恢复对该信号的系统默认处理方式；否则调用<code>sigwait</code>的线程决不会见到该信号。如同对多线程程序所推荐的那样，阻塞所有信号，然后创建一个线程处理信号。该线程的唯一工作是等待<code>SIGHUP</code>和<code>SIGTERM</code>。当接收到<code>SIGHUP</code>信号时，该线程调用<code>reread</code>函数重读它的配置文件。当它接收到<code>SIGTERM</code>信号时，会记录消息并退出。</p>
<h1 id="高级I-O"><a href="#高级I-O" class="headerlink" title="高级I/O"></a>高级I/O</h1><h2 id="非阻塞I-O"><a href="#非阻塞I-O" class="headerlink" title="非阻塞I/O"></a>非阻塞I/O</h2><p>对于一个给定的描述符，有两种为其指定非阻塞I/O的方法。</p>
<ol>
<li>如果调用<code>open</code>获得描述符，则可指定<code>O_NONBLOCK</code>标志。</li>
<li>对于已经打开的一个描述符，则可调用<code>fcntl</code>，由该函数打开<code>O_NONBLOCK</code>文件状态标志。</li>
</ol>
<p>程序是一个非阻塞I/O的实例，它从标准输入读500000字节，并试图将它们写到标准输出上。该程序先将标准输出设置为非阻塞的，然后用for循环进行输出，每次write调用的结果都在标准错误上打印。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>	buf[<span class="number">500000</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span>		ntowrite, nwrite;</span><br><span class="line">	<span class="keyword">char</span>	*ptr;</span><br><span class="line"></span><br><span class="line">	ntowrite = read(STDIN_FILENO, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"read %d bytes\n"</span>, ntowrite);</span><br><span class="line"></span><br><span class="line">	set_fl(STDOUT_FILENO, O_NONBLOCK);	<span class="comment">/* set nonblocking */</span></span><br><span class="line"></span><br><span class="line">	ptr = buf;</span><br><span class="line">	<span class="keyword">while</span> (ntowrite &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		errno = <span class="number">0</span>;</span><br><span class="line">		nwrite = write(STDOUT_FILENO, ptr, ntowrite);</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"nwrite = %d, errno = %d\n"</span>, nwrite, errno);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (nwrite &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			ptr += nwrite;</span><br><span class="line">			ntowrite -= nwrite;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	clr_fl(STDOUT_FILENO, O_NONBLOCK);	<span class="comment">/* clear nonblocking */</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>若标准输出是普通文件，则可以期望<code>write</code>只执行一次。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l /etc/services    打印文件长度</span><br><span class="line">-rw-r--r-- 1 root 677959 Jun 23 2009 /etc/services</span><br><span class="line">s ./a.out &lt; /ete/services &gt; temp.file  先试一个普通文件</span><br><span class="line"><span class="built_in">read</span> 500000 bytes</span><br><span class="line">nwrite = 500000, errno = 0   一次写</span><br><span class="line">$ ls -l temp.tile    检验输出文件长度</span><br><span class="line">-rw-rw-t-- 1 sar 500000 Apr 1 13:03 temp.file</span><br></pre></td></tr></table></figure></p>
<p>但是，若标准输出是终端，则期望write有时返回小于500000的一个数字，有时返回错误。</p>
<h2 id="记录锁"><a href="#记录锁" class="headerlink" title="记录锁"></a>记录锁</h2><p>记录锁(record locking)的功能是：当第一个进程正在读或修改文件的某个部分时，使用记录锁可以阻止其他进程修改同一文件区。对于UNIX系统而言，”记录”这个词是一种误用，因为UNIX系统内核根本没有使用文件记录这种概念。一个更适合的术语可能是字节范围锁(byte-range locking)，因为它锁定的只是文件中的一个区域(也可能是整个文件)。</p>
<h3 id="fcntl记录锁"><a href="#fcntl记录锁" class="headerlink" title="fcntl记录锁"></a>fcntl记录锁</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> cmd, ...<span class="comment">/* struct flock *flockptr */</span>)</span></span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，依赖于cmd(见下)。否则，返回-1</span></span><br></pre></td></tr></table></figure>
<p>对于记录锁，<code>cmd</code>是<code>F_GETLK</code>、<code>F_SETLX</code>或<code>F_SETLKW</code>。第三个参数是一个指向<code>flock</code>结构的指针。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">flock</span> &#123;</span></span><br><span class="line">	<span class="keyword">short</span> l_type;   <span class="comment">/* F_RDLCK, E_WRLCK, or F_UNLCK */</span></span><br><span class="line">	<span class="keyword">short</span> l_whence; <span class="comment">/* SEEK_SET, SEEK_CUR, OF SEEK_END */</span></span><br><span class="line">	<span class="keyword">off_t</span> l_start;  <span class="comment">/* offset in bytes, relative to l_whence */</span></span><br><span class="line">	<span class="keyword">off_t</span> l_len;    <span class="comment">/* length, in bytes; 0 means lock to EOF */</span></span><br><span class="line">	<span class="keyword">pid_t</span> l_pid;    <span class="comment">/* returned with F_GETLK */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>对<code>flock</code>结构说明如下。</p>
<ul>
<li>所希望的锁类型：<code>F_RDLCK</code>(共享读锁)、<code>F_WRLCK</code>(独占性写锁)或<code>F_ONLCK</code>(解锁个区域)</li>
<li>要加锁或解锁区域的起始字节偏移量(<code>l_start</code>和<code>l_whence</code>)</li>
<li>区域的字节长度(<code>l_len</code>)</li>
<li>进程的ID(<code>l_pid</code>)持有的锁能阻塞当前进程(仅由<code>F_GETLK</code>返回)</li>
</ul>
<p>关于加锁或解锁区域的说明还要注意下列几项规则。</p>
<ul>
<li>指定区域起始偏移量的两个元素与<code>lseek</code>函数中最后两个参数类似。<code>l_whence</code>可选用的值是<code>SEEK_SET</code>、<code>SEEK_CUR</code>或<code>SEEK_END</code></li>
<li>锁可以在当前文件尾端处开始或者越过尾端处开始。但是不能在文件起始位置之前开始。</li>
<li>如若<code>l_len</code>为0。则表示锁的范围可以扩展到最大可能偏移量。这意味着不管向该文件中追加写了多少数据，它们都可以处于锁的范围内(不必猜测会有多少字节被追加写到了文件之后)，而且起始位置可以是文件中的任意一个位置</li>
<li>为了对整个文件加锁，我们设置<code>l_start</code>和<code>l_whence</code>指向文件的起始位置，并且指定长度(<code>l_len</code>)为0</li>
</ul>
<p>上面提到了两种类型的锁，共享读锁(<code>l_type</code>为<code>L_RDLCK</code>)和独占性写锁(<code>L_WRLCK</code>)。基本规则是：任意多个进程在一个给定的字节上可以有一把共享的读锁，但是在一个给定字节上只能有一个进程有一把独占写锁。进一步而言，如果在一个给定字节上已经有一把或多把读锁，则不能在该字节上再加写锁；如果在一个字节上已经有一把独占性写锁，则不能再对它加任何读锁<br><img src="/img/1622627160.jpg" alt></p>
<p>上面说明的兼容性规则适用于不同进程提出的锁请求，并不适用于单个进程提出的多个锁请求。如果一个进程对一个文件区间已经有了一把锁，后来该进程又企图在同一文件区间再加一把锁，那么新锁将替换已有镜。加读锁时，该描述符必须是读打开。加写锁时，该描述符必须是写打开。下面说明一下<code>fcntl</code>函数的3种命令。</p>
<ul>
<li><code>F_GETLK</code>判断由<code>flockptr</code>所描述的锁是否会被另外一把锁所排斥(阻塞)。如果存在一把锁，它阻止创建由<code>flockptr</code>所描述的锁，则该现有锁的信息将重写<code>flockptr</code>指向的信息。如果不存在这种情况，则除了将<code>l_type</code>设置为<code>E_UNLCK</code>之外，<code>flockptr</code>所指向结构中的其他信息保持不变</li>
<li><code>F_SETLK</code>设置由<code>flockptr</code>所描述的锁。如果我们试图获得一把读锁(<code>l_type</code>为<code>F_RDLCK</code>)或写锁(<code>l_type</code>为<code>F_WRLCK</code>)，而兼容性规则阻止系统给我们这把锁，那么<code>fcntl</code>会立即出错返回，此时errno设置为EACCES或EAGAIN。此命令也用来清除由<code>flockptr</code>指定的锁(<code>l_type</code>为<code>F_UNLCK</code>)</li>
<li><code>F_SETLKW</code>这个命令是<code>F_SETLK</code>的阻塞版本。如果所请求的读愤或写锁因另一个进程当前已经对所请求区域的某部分进行了加锁而不能被授予，那么调用进程会被置为休眠。如果请求创建的锁已经可用，或者休眠由信号中断，则该进程被唤醒</li>
</ul>
<p>应当了解，用<code>E_GETLK</code>测试能否建立一把锁，然后用<code>F_SETLK</code>或<code>E_SETLKW</code>企图建立那把锁，这两者不是一个原子操作。因此不能保证在这两次<code>fcntl</code>调用之间不会有另一个进程插入并建立一把相同的锁。如果不希望在等待锁变为可用时产生阻塞，就必须处理由<code>F_SETLK</code>返回的可能的出错。</p>
<p>在设置或释放文件上的一把锁时，系统按要求组合或分裂相邻区。例如，若第100~199字节是加锁的区，需解锁第150字节， 则内核将维持两把锁，一把用于第100~149字节，另一把用于第151~199字节。假定我们又对第150字节加锁，那么系统将会再把3个相邻的加锁区合并成一个区(第100~199字节)。</p>
<p>为了避免每次分配<code>flock</code>结构，然后又填入各项信息，可以用函数<code>lock_reg</code>来处理所有这些细节。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">lock_reg(<span class="keyword">int</span> fd, <span class="keyword">int</span> cmd, <span class="keyword">int</span> type, <span class="keyword">off_t</span> offset, <span class="keyword">int</span> whence, <span class="keyword">off_t</span> len)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">flock</span>	<span class="title">lock</span>;</span></span><br><span class="line"></span><br><span class="line">	lock.l_type = type;		<span class="comment">/* F_RDLCK, F_WRLCK, F_UNLCK */</span></span><br><span class="line">	lock.l_start = offset;	<span class="comment">/* byte offset, relative to l_whence */</span></span><br><span class="line">	lock.l_whence = whence;	<span class="comment">/* SEEK_SET, SEEK_CUR, SEEK_END */</span></span><br><span class="line">	lock.l_len = len;		<span class="comment">/* #bytes (0 means to EOF) */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span>(fcntl(fd, cmd, &amp;lock));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因为大多数锁调用是加锁或解锁一个文件区域(命令<code>E_GETLK</code>很少使用)，故通常使用下列5个宏中的一个。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> read_lock(fd, offset, whence, len)\</span></span><br><span class="line">	lock_reg((fd), F_SETLK, F_RDLCK, (offset), (whence), (len))</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> readw_lock (fd, offset, whence, len) \</span></span><br><span class="line">	lock_reg((fd), F_SETLKW, F_RDLCK, (offset), (whence), (len))</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> write_lock(fd, offset, whence, len) \</span></span><br><span class="line">	lock_reg((fd), F_SETLK, F_WRLCK, (offset), (whence), (len))</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> writew_lock (fd, offset, whence, len) \</span></span><br><span class="line">	lock_reg((fd)，F_SETLKW, F_WRLCK, (offset),(whence), (len))</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> un_lock (fd, offset, whence, len) \</span></span><br><span class="line">	lock_reg((fd), F_SETLK, F_UNLCK, (offset), (whence), (len))</span><br></pre></td></tr></table></figure></p>
<p>下边定义了一个函数<code>lock_test</code>，我们将用它测试一把锁。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pid_t</span></span><br><span class="line">lock_test(<span class="keyword">int</span> fd, <span class="keyword">int</span> type, <span class="keyword">off_t</span> offset, <span class="keyword">int</span> whence, <span class="keyword">off_t</span> len)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">flock</span>	<span class="title">lock</span>;</span></span><br><span class="line"></span><br><span class="line">	lock.l_type = type;		<span class="comment">/* F_RDLCK or F_WRLCK */</span></span><br><span class="line">	lock.l_start = offset;	<span class="comment">/* byte offset, relative to l_whence */</span></span><br><span class="line">	lock.l_whence = whence;	<span class="comment">/* SEEK_SET, SEEK_CUR, SEEK_END */</span></span><br><span class="line">	lock.l_len = len;		<span class="comment">/* #bytes (0 means to EOF) */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (fcntl(fd, F_GETLK, &amp;lock) &lt; <span class="number">0</span>)</span><br><span class="line">		err_sys(<span class="string">"fcntl error"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (lock.l_type == F_UNLCK)</span><br><span class="line">		<span class="keyword">return</span>(<span class="number">0</span>);		<span class="comment">/* false, region isn't locked by another proc */</span></span><br><span class="line">	<span class="keyword">return</span>(lock.l_pid);	<span class="comment">/* true, return pid of lock owner */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果存在一把锁，它阻塞由参数指定的锁请求，则此函数返回持有这把现有锁的进程的进程ID，否则此函数返回0。通常用下面两个宏来调用此函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	is_read_lockable(fd, offset, whence, len) \</span></span><br><span class="line">			(lock_test((fd), F_RDLCK, (offset), (whence), (len)) == <span class="number">0</span>)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	is_write_lockable(fd, offset, whence, len) \</span></span><br><span class="line">			(lock_test((fd), F_WRLCK, (offset), (whence), (len)) == <span class="number">0</span>)</span><br></pre></td></tr></table></figure></p>
<p>注意，进程不能使用<code>lock_test</code>函数测试它自己是否在文件的某一部分持有一把锁。<code>F_GETLK</code>命令的定义说明，返回信息指示是否有现有的锁阻止调用进程设置它自己的锁。因为<code>F_SETLK</code>和<code>F_SETLKW</code>命令总是替换调用进程现有的锁，所以调用进程决不会阻塞在自己持有的锁上，于是，<code>F_GETLK</code>命令决不会报告调用进程自己持有的锁。</p>
<p>如果一个进程已经控制了文件中的一个加锁区域。然后它又试图对另一个进程控制的区域加锁，那么它就会休眠，在这种情况下，有发生死锁的可能性。子进程对第0字节加锁，父进程对第1字节加锁。然后，它们中的每一个又试图对对方已经加锁的字节加锁。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">lockabyte(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (writew_lock(fd, offset, SEEK_SET, <span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">		err_sys(<span class="string">"%s: writew_lock error"</span>, name);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s: got the lock, byte %lld\n"</span>, name, (<span class="keyword">long</span> <span class="keyword">long</span>)offset);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span>		fd;</span><br><span class="line">	<span class="keyword">pid_t</span>	pid;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Create a file and write two bytes to it.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> ((fd = creat(<span class="string">"templock"</span>, FILE_MODE)) &lt; <span class="number">0</span>)</span><br><span class="line">		err_sys(<span class="string">"creat error"</span>);</span><br><span class="line">	<span class="keyword">if</span> (write(fd, <span class="string">"ab"</span>, <span class="number">2</span>) != <span class="number">2</span>)</span><br><span class="line">		err_sys(<span class="string">"write error"</span>);</span><br><span class="line"></span><br><span class="line">	TELL_WAIT();</span><br><span class="line">	<span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		err_sys(<span class="string">"fork error"</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;			<span class="comment">/* child */</span></span><br><span class="line">		lockabyte(<span class="string">"child"</span>, fd, <span class="number">0</span>);</span><br><span class="line">		TELL_PARENT(getppid());</span><br><span class="line">		WAIT_PARENT();</span><br><span class="line">		lockabyte(<span class="string">"child"</span>, fd, <span class="number">1</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;						<span class="comment">/* parent */</span></span><br><span class="line">		lockabyte(<span class="string">"parent"</span>, fd, <span class="number">1</span>);</span><br><span class="line">		TELL_CHILD(pid);</span><br><span class="line">		WAIT_CHILD();</span><br><span class="line">		lockabyte(<span class="string">"parent"</span>, fd, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行图14-7中的程序得到：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out</span><br><span class="line">parent: got the lock, byte 1</span><br><span class="line">child: got the lock, byte 0</span><br><span class="line">parent: writem_lock error: Resource deadlock avoided</span><br><span class="line">child: got the lock, byte 1</span><br></pre></td></tr></table></figure></p>
<p>检测到死锁时，内核必须选择一个进程接收出错返回。在本实例中，选择了父进程，但这是一个实现细节。在某些系统上，子进程总是接到出错信息，在另一些系统上，父进程总是接到出错信息。在某些系统上，当试图使用多把锁时，有时是子进程接到出错信息，有时则是父进程接到出错信息。</p>
<h3 id="锁的隐含继承和释放"><a href="#锁的隐含继承和释放" class="headerlink" title="锁的隐含继承和释放"></a>锁的隐含继承和释放</h3><p>关于记录锁的自动继承和释放有3条规则。</p>
<ul>
<li>锁与进程和文件两者相关联。这有两重含义。第一重很明显，当一个进程终止时，它所建立的锁全部释放；第二重则不太明显，无论一个描述符何时关闭，该进程通过这一描述符引用的文件上的任何一把锁都会释放(这些锁都是该进程设置的)。<ul>
<li>这就意味着，如果执行下列4步：<ul>
<li><code>fd1 = open (pathname, ...);</code></li>
<li><code>read_lock(fd1, ...);</code></li>
<li><code>fd2 = dup(fdi);</code></li>
<li><code>close (fd2);</code></li>
</ul>
</li>
<li>则在<code>close(fd2)</code>后，在<code>fd1</code>上设置的锁被释放。如果将<code>dup</code>替换为<code>open</code>，其效果也一样：<ul>
<li><code>fd1 = open (pathname, ...);</code></li>
<li><code>read_lock(fd1, ...);</code></li>
<li><code>fd2 = open(pathname, ...);</code></li>
<li><code>close (fd2);</code></li>
</ul>
</li>
</ul>
</li>
<li>由<code>fork</code>产生的子进程不继承父进程所设置的锁。这意味着，若一个进程得到一把锁，然后调用<code>fork</code>，那么对于父进程获得的锁而言，子进程被视为另一个进程。对于通过<code>fork</code>从父进程处继承过来的描述符，子进程需要调用<code>fcntl</code>才能获得它自己的锁。<ul>
<li>这个约束是有道理的，因为锁的作用是阻止多个进程同时写同一个文件。如果子进程通过<code>fork</code>继承父进程的锁，则父进程和子进程就可以同时写同一个文件。</li>
</ul>
</li>
<li>在执行exec后，新程序可以继承原执行程序的锁。但是注意，如果对一个文件描述符设置了执行时关闭标志，那么当作为<code>exec</code>的一部分关闭该文件描述符时，将释放相应文件的所有锁。</li>
</ul>
<h3 id="FreeBSD实现"><a href="#FreeBSD实现" class="headerlink" title="FreeBSD实现"></a>FreeBSD实现</h3><p>先简要地观察FreeBSD实现中使用的数据结构。这会帮助我们进一步理解记录锁的自动继承和释放的第一条规则：锁与进程和文件两者相关联。考虑一个进程，它执行下列语句(忽略出错返回)。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fd1 = open (pathname, ...);</span><br><span class="line">write_lock(fd1, <span class="number">0</span>, SEEK_SET, <span class="number">1</span>);</span><br><span class="line"><span class="comment">/* parent write locks byte 0 */</span></span><br><span class="line"><span class="keyword">if</span> ((pid = fork()) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="comment">/* parent */</span></span><br><span class="line">	fd2 = dup(fd1);</span><br><span class="line">	fd3 = open (pathname, ...];</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">	read_lock(fd1, <span class="number">1</span>, SEEK_SET, <span class="number">1</span>); <span class="comment">/* child read locks byte 1 */</span></span><br><span class="line">&#125;</span><br><span class="line">pause();</span><br></pre></td></tr></table></figure></p>
<p>图显示了父进程和子进程暂停(执行<code>pause()</code>)后的数据结构情况。<br><img src="/img/1622640114.jpg" alt></p>
<p>前面已经给出了<code>open</code>、<code>fork</code>以及<code>dup</code>调用后的数据结构。有了记录锁后，在原来的这些图上新加了<code>lockf</code>结构，它们由i节点结构开始相互链接起来。每个<code>lockf</code>结构描述了一个给定进程的一个加锁区域(由偏移量和长度定义的)。图中显示了两个<code>lockf</code>结构，一个是由父进程调用<code>write_lock</code>形成的，另一个则是由子进程调用<code>read_lock</code>形成的。每一个结构都包含了相应的进程ID。</p>
<p>在父进程中，关闭<code>fd1</code>、<code>fd2</code>或<code>fd3</code>中的任意一个都将释放由父进程设置的写锁。在关闭这3个描述符中的任意一个时，内核会从该描述符所关联的i节点开始，逐个检查<code>lockf</code>链接表中的各项，并释放由调用进程持有的各把锁。</p>
<p>程序展示了<code>lockfile</code>函数的实现，守护进程可用该函数在文件上加写锁。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">lockfile(<span class="keyword">int</span> fd)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">flock</span> <span class="title">fl</span>;</span></span><br><span class="line"></span><br><span class="line">	fl.l_type = F_WRLCK;</span><br><span class="line">	fl.l_start = <span class="number">0</span>;</span><br><span class="line">	fl.l_whence = SEEK_SET;</span><br><span class="line">	fl.l_len = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span>(fcntl(fd, F_SETLK, &amp;fl));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>另一种方法是用<code>write_lock</code>函数定义<code>lockfile</code>函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lockfile(fd) write_lock((fd)，0, SEEK_SET, 0)</span></span><br></pre></td></tr></table></figure></p>
<h3 id="在文件尾端加锁"><a href="#在文件尾端加锁" class="headerlink" title="在文件尾端加锁"></a>在文件尾端加锁</h3><p>在对相对于文件尾端的字节范围加锁或解锁时需要特别小心。大多数实现按照<code>l_whence</code>的<code>SEEK_CUR</code>或<code>SEEK_END</code>值，用<code>l_start</code>以及文件当前位置或当前长度得到绝对文件偏移量。但是，常常需要相对于文件的当前长度指定一把锁，但又不能调用<code>fstat</code>来得到当前文件长度，因为我们在该文件上没有锁。考虑以下代码序列：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">writew_lock(fd, <span class="number">0</span>, SEEK_END, <span class="number">0</span>);</span><br><span class="line">write(fd, buf, <span class="number">1</span>):</span><br><span class="line">un_lock(fd, <span class="number">0</span>, SEEK_END);</span><br><span class="line">write(fd, buf, <span class="number">1</span>);</span><br></pre></td></tr></table></figure></p>
<p>该代码序列所做的可能并不是你所期望的，它得到一把写锁，该写锁从当前文件尾端起，包括以后可能追加写到该文件的任何数据。假定，该文件偏移量处于文件尾端时，执行第一个write，这个操作将文件延伸了1个字节，而该字节将被加锁。跟随其后的是解锁操作，其作用是对以后追加写到文件上的数据不再加锁。但在其之前刚追加写的一个字节则保留加锁状态。当执行第二个写时，文件尾端又廷伸了1个字节，但该字节并未加锁。</p>
<p>当对文件的一部分加锁时，内核将指定的偏移量变换成绝对文件偏移量。另外，除了指定一个绝对偏移量(<code>SEEK_SET</code>)之外，<code>fcntl</code>还允许我们相对于文件中的某个点指定该偏移量，这个点是指当前偏移量(<code>SEEK_CUR</code>)或文件尾端(<code>SEEK_END</code>)。当前偏移量和文件尾端可能会不断变化，而这种变化又不应影响现有锁的状态，所以内核必须独立于当前文件偏移量或文件尾端而记住锁。如果想解除的锁中包括第一次<code>write</code>所写的1个字节，那么应指定长度为-1。负的长度值表示在指定偏移量之前的字节数。</p>
<h3 id="建议性锁和强制性锁"><a href="#建议性锁和强制性锁" class="headerlink" title="建议性锁和强制性锁"></a>建议性锁和强制性锁</h3><p>强制性锁会让内核检查每一个<code>open</code>、<code>read</code>和<code>write</code>，验证调用进程是否违背了正在访问的文件上的某一把锁。强制性锁有时也称为强迫方式锁(enforcement-mode locking)。</p>
<p>对一个特定文件打开其设置组ID位、关闭其组执行位便开启了对该文件的强制性锁机制。因为当组执行位关闭时，设置组ID位不再有意义。如果一个进程试图读(read)或写(write)一个强制性锁起作用的文件，而欲读、写的部分又由其他进程加上了锁，取决于3方面的因素：操作类型(read或write)、其他进程持有的锁的类型(读锁或写锁)以及read或write的描述符是阻塞还是非阻塞的，下边列出了8种可能性。<br><img src="/img/1622641438.jpg" alt></p>
<p>通常，即使正在打开的文件具有强制性记录锁，该<code>open</code>也会成功。如果欲打开的文件具有强制性记录锁(读锁或写锁)，而且<code>open</code>调用中的标志指定为<code>O_TRUNC</code>或<code>O_CREAT</code>，则不论是否指定<code>O_NONBLOCK</code>，<code>open</code>都立即出错返回，errno设置为EAGAIN。</p>
<h2 id="I-O多路转接"><a href="#I-O多路转接" class="headerlink" title="I/O多路转接"></a>I/O多路转接</h2><p>当从一个描述符读，然后又写到另一个描述符时，可以在下列形式的循环中使用阻塞I/O:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ((n=read(STDIN_FILENO, buf, BUFSIZ)) &gt; <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">if</span> (write(STDOUT_FILENO, buf, n) != n)</span><br><span class="line">		err_sys (<span class="string">"write error"</span>);</span><br></pre></td></tr></table></figure></p>
<p>这种形式的阻塞I/O到处可见。但是如果必须从两个描述符读，我们不能在任一个描述符上进行阻塞读(read)，否则可能会因为被阻塞在一个描述符的读操作上而导致另一个描述符即使有数据也无法处理。所以为了处理这种情况需要另一种不同的技术。将一个进程变成两个进程(用fork)，每个进程处理一条数据通路。图中显示了这种安排。<br><img src="/img/1622642397.jpg" alt></p>
<p>如果使用两个进程，则可使每个进程都执行阻塞<code>read</code>。如果子进程接收到文件结束符，那么该子进程终止。然后父进程接收到<code>SIGCHLD</code>信号。但是，如果父进程终止，那么父进程应通知子进程停止。为此可以使用一个信号(如<code>SIGUSR1</code>)，但这使程序变得更加复杂。</p>
<p>另一个方法是仍旧使用一个进程执行该程序，但使用非阻塞I/O读取数据。其基本思想是：将两个输入描述符都设置为非阻塞的，对第一个描述符发一个<code>read</code>。如果该输入上有数据，则读数据并处理它。如果无数据可读，则该调用立即返回。然后对第二个描述符作同样的处理。在此之后，等待一定的时间(可能是若干秒)，然后再尝试从第一个描述符读。这种形式的循环称为<strong>轮询</strong>。这种方法的不足之处是浪费CPU时间。</p>
<p>还有一种技术称为异步I/O(asynchronous I/O)。进程告诉内核：当描述符准备好可以进行I/O时，用一个信号通知它。这种技术有两个问题。首先，尽管一些系统提供了各自的受限形式的异步I/O，但POSIX采纳了另外一套标准化接口。</p>
<p>这种技术的第二个问题是，这种信号对每个进程而言只有1个(<code>SIGPOLL</code>或<code>SIGIO</code>)。如果使该信号对两个描述符都起作用，那么进程在接到此信号时将无法判别是哪一个描述符准备好了，需将这两个描述符都设置为非阻塞的，并顺序尝试执行I/O。</p>
<p>一种比较好的技术是使用I/O多路转接(I/O multiplexing)。为了使用这种技术，先构造一张我们感兴趣的描述符(通常都不止一个)的列表，然后调用一个函数，直到这些描述符中的一个已准备好进行I/O时，该函数才返回。<code>poll</code>、<code>pselect</code>和<code>select</code>这3个函数使我们能够执行I/O多路转接。在从这些函数返回时，进程会被告知哪些描述符已准备好可以进行I/O。POSIX指定，为了在程序中使用<code>select</code>，必须包括<code>&lt;sys/select.h&gt;</code>。</p>
<h3 id="函数select和pselect"><a href="#函数select和pselect" class="headerlink" title="函数select和pselect"></a>函数select和pselect</h3><p><code>select</code>函数使我们可以执行I/O多路转接。传给<code>select</code>的参数告诉内核：</p>
<ul>
<li>我们所关心的描述符</li>
<li>对于每个描述符我们所关心的条件</li>
<li>愿意等待多长时间</li>
</ul>
<p>从<code>select</code>返回时，内核告诉我们</p>
<ul>
<li>已准备好的描述符的总数量：</li>
<li>对于读、写或异常这3个条件中的每一个，哪些描述符已准备好。</li>
</ul>
<p>使用这种返回信息，就可调用相应的I/O函数(一般是<code>read</code>或<code>write</code>)，并且确知该函数不会阻塞。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> maxfdp1, fd_set *<span class="keyword">restrict</span> readfds, fd_set *<span class="keyword">restrict</span> writefds, fd_set *restriet exceptfds, struct timeval *<span class="keyword">restrict</span> tvptr)</span></span>;</span><br><span class="line"><span class="comment">// 返回值，准备就绪的描述符数目，若超时，返回0，若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>最后一个参数指定愿意等待的时间长度，单位为秒和微秒。有以下3种情况。</p>
<ul>
<li><code>tvptr == NULL</code><ul>
<li>永远等待。如果捕捉到一个信号则中断此无限期等待。当所指定的描述符中的一个已准备好或捕捉到一个信号则返回。如果捕捉到一个信号，则<code>select</code>返回-1，errno设置为EINTR。</li>
</ul>
</li>
<li><code>tvptr-&gt;tv_sec == 0 &amp;&amp; tvptr-&gt;tv_usec == 0</code><ul>
<li>根本不等待。测试所有指定的描述符并立即返回。这是轮询系统找到多个描述符状态而不阻塞<code>select</code>函数的方法。</li>
</ul>
</li>
<li><code>tvptr-&gt;tv_sec != 0 || tvptr-&gt;n_usec != 0</code><ul>
<li>等待指定的秒数和微秒数。当指定的描述符之一已准备好，或当指定的时间值已经超过时立即返回。如果在超时到期时还没有一个描述符准备好，则返回值是0。与第一种情况一样，这种等待可被捕捉到的信号中断。</li>
</ul>
</li>
</ul>
<p>中间3个参数<code>readfds</code>，<code>writefds</code>和<code>exceptfds</code>是指向描述符集的指针。这3个描述符集说明了可读、可写或处于异常条件的描述符集合。每个描述符集存储在一个<code>fd_set</code>数据类型中。这个数据类型是由实现选择的，它可以为每一个可能的描述符保持一位。我们可以认为它只是一个很大的字节数组。<br><img src="/img/1622643609.jpg" alt></p>
<p>对于<code>fd_set</code>数据类型，唯一可以进行的处理是：分配一个这种类型的变量，将这种类型的一个变量值赋给同类型的另一个变量，或对这种类型的变量使用下列4个函数中的一个。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;</span><br><span class="line"><span class="comment">// 返回值：若fd在描述符集中，返回非0值；否则，返回0</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_CLR</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_SET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *fdset)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>这些接口可实现为宏或函数。调用<code>FD_ZERO</code>将一个<code>fd_set</code>变量的所有位设置为0。要开启描述符集中的一位，可以调用<code>FD_SET</code>。调用<code>FD_CLR</code>可以清除一位。最后，可以调用<code>FD_ISSET</code>测试描述符集中的一个指定位是否已打开。</p>
<p>在声明了一个描述符集之后，必须用<code>FD_ZERO</code>将这个描述符集置为0，然后在其中设置我们关心的各个描述符的位。具体操作如下所示：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fd_set rset;</span><br><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line">FD_ZERO(&amp;rset);</span><br><span class="line">FD_SET(fd, &amp;rset);</span><br><span class="line">FD_SET(STDIN_FILENO, &amp;rset);</span><br></pre></td></tr></table></figure></p>
<p>从<code>select</code>返回时，可以用<code>FD_ISSET</code>测试该集中的一个给定位是否仍处于打开状态：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (FD_ISSET(fd, &amp;rset));</span><br></pre></td></tr></table></figure></p>
<p><code>select</code>的中间3个参数(指向描述符集的指针)中的任意一个(或全部)可以是空指针，这表示对相应条件并不关心。如果所有3个指针都是NULL，则<code>select</code>提供了比<code>sleep</code>更精确的定时器。</p>
<p><code>select</code>第一个参数<code>maxfdp1</code>的意思是“最大文件描述符编号值加1”。也可将第一个参数设置为<code>FD_SETSIZE</code>，它指定最大描述符数(经常是1024)。通过指定我们所关注的最大描述符，内核就只需在此范围内寻找打开的位，而不必在了个描述符集中的数百个没有使用的位内搜索。例如，图14-16所示的两个描述符集的情况就好像是执行了下述操作：<br><img src="/img/20210602112207.png" alt></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fd_set readset, writeset;</span><br><span class="line">PO_ZERO(&amp;readset);</span><br><span class="line">PD_ZERO(&amp;writeset);</span><br><span class="line">FD_SET(<span class="number">0</span>, &amp;readset);</span><br><span class="line">FD_SET(<span class="number">3</span>, &amp;readset);</span><br><span class="line">FD_SET(<span class="number">1</span>, &amp;writeset);</span><br><span class="line">FD_SET(<span class="number">2</span>, &amp;writeset);</span><br><span class="line">select(<span class="number">4</span>, &amp;readset, &amp;writeset, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>
<p>因为描述符编号从0开始，所以要在最大描述符编号值上加1。第一个参数实际上是要检查的描述符数(从描述符0开始)。</p>
<p><code>select</code>有3个可能的返回值。</p>
<ol>
<li>返回值-1表示出错。这是可能发生的，例如，在所指定的描述符一个都没准备好时捕捉到一个信号。在此种情况下，一个描述符集都不修改</li>
<li>返回值0表示没有描述符准备好。若指定的描述符一个都没准备好，指定的时间就过了，那么就会发生这种情况。此时，所有描述符集都会置0</li>
<li>一个正返回值说明了已经准备好的描述符数。该值是3个描述符集中已准备好的描述符数之和，所以如果同一描述符已准备好读和写，那么在返回值中会对其计两次数。在这种情况下，3个描述符集中仍旧打开的位对应于已准备好的描述符。</li>
</ol>
<p>对于“准备好”的含义要作一些更具体的说明。</p>
<ul>
<li>若对读集(readfds)中的一个描述符进行的read操作不会阻塞，则认为此描述符是准备好的。</li>
<li>若对写集(writefds)中的一个描述符进行的wrile操作不会阻塞，则认为此描述符是准备好的。</li>
<li>若对异常条件集(exceptfds)中的一个描述符有一个未决异常条件，则认为此播述符是准备好的。</li>
<li>对于读、写和异常条件，普通文件的文件描述符总是返回准备好。</li>
</ul>
<p>一个描述符阻塞与否并不影响<code>select</code>是否阻塞，也就是说，如果希望读一个非阻塞描述符，并且以超时值为5秒调用<code>select</code>，则<code>select</code>最多阻塞5s。相类似，如果指定一个无限的超时值，则在该描述符数据准备好，或捕捉到一个信号之前，<code>select</code>会一直阻塞。</p>
<p>如果在一个描述符上碰到了文件尾端，则<code>select</code>会认为该描述符是可读的。然后调用<code>read</code>，它返回0；这是UNIX系统指示到达文件尾端的方法。POSIX.1也定义了一个<code>select</code>的变体，称为<code>pselect</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ays/seiect.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pselect</span> <span class="params">(<span class="keyword">int</span> maxfdpl, fd_set *<span class="keyword">restrict</span> readfds,</span></span></span><br><span class="line"><span class="function"><span class="params">	fd_set *<span class="keyword">restrict</span> writefds, fd_set *<span class="keyword">restrict</span> exceptfds,</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">const</span> struct timespec *<span class="keyword">restrict</span> tsptr,</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">const</span> <span class="keyword">sigset_t</span> *<span class="keyword">restrict</span> sigmask)</span></span>;</span><br><span class="line"><span class="comment">// 返回值：准备就绪的描述符数目，若超时，返回0。若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>除下列几点外，<code>pselect</code>与<code>select</code>相同。</p>
<ul>
<li><code>select</code>的超时值用<code>timeval</code>结构指定，但<code>pselect</code>使用<code>timespec</code>结构。<code>timespec</code>结构以秒和纳秒表示超时值，而非秒和微秒。</li>
<li><code>pselect</code>的超时值被声明为<code>const</code>，这保证了调用<code>pselect</code>不会改变此值。</li>
<li><code>pselect</code>可使用可选信号屏蔽字。若<code>sigmask</code>为NULL，那么在与信号有关的方面，<code>pselect</code>的运行状况和<code>select</code>相同。否则，<code>sigmask</code>指向一信号屏蔽字，在调用<code>pselect</code>时，以原子操作的方式安装该信号屏蔽字。在返回时，恢复以前的信号屏蔽字。</li>
</ul>
<h3 id="函数poll"><a href="#函数poll" class="headerlink" title="函数poll"></a>函数poll</h3><p><code>poll</code>函数类似于<code>select</code>，但是程序员接口有所不同。<code>poll</code>函数可用于任何类型的文件描述符。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span> <span class="params">(struct pollfd fdarray[], <span class="keyword">nfds_t</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line"><span class="comment">// 返回值：准备就绪的描述行数目，若超时，返回0；若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>与<code>select</code>不同，<code>poll</code>不是为每个条件(可读性、可写性和异常条件)构造一个描述符集，而是构造一个<code>pollfd</code>结构的数组，每个数组元素指定一个描述符编号以及我们对该描述符感兴趣的条件。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> fd;       <span class="comment">/* file deacriptor to check, or &lt;0 to sgnore */</span></span><br><span class="line">	<span class="keyword">short</span> events; <span class="comment">/* events of interest on fd */</span></span><br><span class="line">	<span class="keyword">short</span> revents; <span class="comment">/* events that occurred on fd */</span></span><br></pre></td></tr></table></figure></p>
<p><code>fdarray</code>数组中的元素数由<code>nfds</code>指定。</p>
<p>应将每个数组元素的<code>events</code>成员设置为表中所示值的一个或几个，通过这些值告诉内核我们关心的是每个描述符的哪些事件。返回时，<code>revents</code>成员由内核设置，用于说明每个描述符发生了哪些事件。(注意，<code>poll</code>没有更改<code>events</code>成员。这与<code>select</code>不同，<code>select</code>修改其参数以指示哪一个描述符已准备好了。)</p>
<table>
<thead>
<tr>
<th>标志名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>POLLIN</td>
<td>可以不阻塞读高优先级数据以外的数据(等效于<code>POLLRDNORM</code></td>
<td><code>POLLRDBAND</code>)</td>
</tr>
<tr>
<td>POLLRDNORM</td>
<td>可以不阻塞地读普通数据</td>
</tr>
<tr>
<td>POLLRDBAND</td>
<td>可以不阻塞地读优先级数据</td>
</tr>
<tr>
<td>POLLPRI</td>
<td>可以不阻塞地读高优先级数据</td>
</tr>
<tr>
<td>POLLOUT</td>
<td>可以不阻塞地写普通数据</td>
</tr>
<tr>
<td>POLLMRNORM</td>
<td>与POLLOUT相同</td>
</tr>
<tr>
<td>POLLWRBAND</td>
<td>可以不阻塞地写优先级数据</td>
</tr>
<tr>
<td>POLLERR</td>
<td>已出错</td>
</tr>
<tr>
<td>POLLHUP</td>
<td>已挂断</td>
</tr>
<tr>
<td>POLLNVAL</td>
<td>描述符没有引用一个打开文件</td>
</tr>
</tbody>
</table>
<p>当一个描述符被挂断(<code>POLLHUP</code>)后，就不能再写该描述符，但是有可能仍然可以从该描述符读取到数据。</p>
<p><code>poll</code>的最后一个参数指定的是我们愿意等待多长时间。如同<code>select</code>一样，有3种不同的情形。</p>
<ul>
<li><code>timeout == -1</code><ul>
<li>永远等待。(某些系统在<code>&lt;stropts.h&gt;</code>中定义了常量INFTIM，其值通常是-1。)当所指定的描述符中的一个已准备好，或捕捉到一个信号时返回。如果捕捉到一个信号，则<code>poll</code>返回-1，errno设置为EINTR。</li>
</ul>
</li>
<li><code>timeout == 0</code><ul>
<li>不等待。测试所有描述符并立即返回。这是一种轮询系统的方法，可以找到多个描述符的状态而不阻塞<code>poll</code>函数。</li>
</ul>
</li>
<li><code>timeout &gt; 0</code><ul>
<li>等待timeout毫秒，当指定的描述符之一已准备好，或<code>timeout</code>到期时立即返回。如果<code>timeout</code>到期时还没有一个描述符准备好，则返回值是0。</li>
</ul>
</li>
</ul>
<p>与<code>select</code>一样，一个描述符是否阻塞不会影响<code>poll</code>是否阻塞。</p>
<h2 id="异步I-O"><a href="#异步I-O" class="headerlink" title="异步I/O"></a>异步I/O</h2><p>使用POSIX异步I/O接口，会带来下列麻烦：</p>
<ul>
<li>每个异步操作有了处可能产生错误的地方：一处在操作提交的部分，一处在操作本身的结果，还有一处在用于决定异步操作状态的函数中。</li>
<li>与POSIX异步IO接口的传统方法相比，它们本身涉及大量的额外设置和处理规则。<ul>
<li>事实上，并不能把非异步I/O函数称作“同步”的，因为尽管它们相对于程序流来说是同步的，但相对于I/O来说并非如此。当从<code>write</code>函数的调用返回时，写的数据是持久的，我们称这个写操作为“同步”的。也不能依靠把传统的调用归类为“标准”的I/O调用来区到传统的I/O函数和异步I/O函数，因为这样会使它们和标准I/O库中的函数调用相混淆。</li>
</ul>
</li>
<li>从错误中恢复可能会比较困难。</li>
</ul>
<h3 id="System-V异步I-O"><a href="#System-V异步I-O" class="headerlink" title="System V异步I/O"></a>System V异步I/O</h3><p>在System V中，异步I/O是STREAMS系统的一部分，它只对STREAMS设备和STREAMS管道起作用。SystemV的异步I/O信号是<code>SIGPOLL</code>。</p>
<p>除了调用<code>ioctl</code>指定产生<code>SIGPOLL</code>信号的条件以外，还应为该信号建立信号处理程序。应当在调用<code>ioctl</code>之前建立信号处理程序。</p>
<table>
<thead>
<tr>
<th>常量</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>S_INPUT</td>
<td>可以不阻塞地读取数据(非高优先级数据)</td>
</tr>
<tr>
<td>S_RDNORM</td>
<td>可以不阻塞地读取普通数据</td>
</tr>
<tr>
<td>S_RDBAND</td>
<td>可以不阻塞地读取优先级数据</td>
</tr>
<tr>
<td>S_BANDURG</td>
<td>若此常量和<code>S_RDBAND</code>一起指定，当我们可以不阻塞地读取优先数据时，产生<code>SIGURG</code>信号而非<code>SIGPOLL</code></td>
</tr>
<tr>
<td>S_HIPRI</td>
<td>可以不阻塞地读取高优先级数据</td>
</tr>
<tr>
<td>S_OUTPUT</td>
<td>可以不阻塞地写普通数据</td>
</tr>
<tr>
<td>S_WRNGRM</td>
<td>与<code>S_OUTPUT</code>相同</td>
</tr>
<tr>
<td>S_WRBAND</td>
<td>可以不阻塞地写优先级数据</td>
</tr>
<tr>
<td>S_MSG</td>
<td>包含<code>SIGPOLL</code>信号的消息已经到达流头部</td>
</tr>
<tr>
<td>S_ERROR</td>
<td>流有错误</td>
</tr>
<tr>
<td>S_HANGUP</td>
<td>流已挂起</td>
</tr>
</tbody>
</table>
<h3 id="BSD异步I-O"><a href="#BSD异步I-O" class="headerlink" title="BSD异步I/O"></a>BSD异步I/O</h3><p>在BSD派生的系统中，异步I/O是信号<code>SIGIO</code>和<code>SIGURG</code>的组合。<code>SIGIO</code>是通用异步I/O信号，<code>SIGURG</code>则只用来通知进程网络连接上的带外数据已经到达。为了接收SIGIO信号，需执行以下3步。</p>
<ol>
<li>调用<code>signal</code>或<code>sigaction</code>为<code>SIGIO</code>信号建立信号处理程序。</li>
<li>以命令<code>F_SETOWN</code>调用tentl来设置进程ID或进程组ID，用于接收时对于该描述符的信号。</li>
<li>以命令<code>F_SETPL</code>调用<code>fcnt1</code>设置<code>O_ASYNC</code>文件状态标志，使在该描述符上可以进行异步I/O。</li>
</ol>
<h3 id="POSIX异步I-O"><a href="#POSIX异步I-O" class="headerlink" title="POSIX异步I/O"></a>POSIX异步I/O</h3><p>POSIX异步I/O接口为对不同类型的文件进行异步I/O提供了一套一致的方法。这些异步I/O接口使用AIO控制块来描述I/O操作。<code>aiocb</code>结构定义了AIO控制块。该结构至少包括下面这些字段：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">alocb</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> aio_fildes;                <span class="comment">/* file descriptor */</span></span><br><span class="line">	<span class="keyword">off_t</span> aio_offset;              <span class="comment">/* file offset for I/O */</span></span><br><span class="line">	<span class="keyword">volatile</span> <span class="keyword">void</span> *aio_buf;        <span class="comment">/* buffer for I/O */</span></span><br><span class="line">	<span class="keyword">size_t</span> aio_nbytes;             <span class="comment">/* number of bytes to transfer */</span></span><br><span class="line">	<span class="keyword">int</span> aio_reqprior               <span class="comment">/* priority */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sigevent</span> <span class="title">aio_sigevent</span>;</span>  <span class="comment">/* signal information */</span></span><br><span class="line">	<span class="keyword">int</span> aio_lio_opcode;            <span class="comment">/* operation for list I/O */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>aio_fields</code>字段表示被打开用来读或写的文件损述符。读或写操作从<code>aio_offset</code>指定的偏移量开始。对于读操作，数据会复制到缓冲区中，该缓冲区从<code>aio_buf</code>指定的地址开始。对于写操作，数据会从这个缓冲区中复制出来。<code>aio_ nbytes</code>字段包含了要读或写的字节数。注意，异步I/O操作必须显式地指定偏移量。异步I/O接口并不影响由操作系统维护的文件偏移量。如果使用异步I/O接口向一个以追加模式(使用<code>O_APPEND</code>)打开的文件中写入数据，AIO控制块中的<code>aio_offset</code>字段会被系统忽略。</p>
<p>其他字段和传统I/O函数中的不一致。应用程序使用<code>aio_reqprio</code>字段为异步I/O请求提示顺序。然而，系统对于该顺序只有有限的控制能力，因此不一定能遵循该提示。<code>aio_lio_opcode</code>字段只能用于基于列表的异步I/O，<code>aio_sigevent</code>字段控制，在I/O事件完成后，如何通知应用程序。这个字段通过<code>sigevent</code>结构来描述。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">migevent</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span>   sigev_notitys                           <span class="comment">/* notity type */</span></span><br><span class="line"><span class="keyword">int</span>   sigev_signos                            <span class="comment">/* aignai number */</span></span><br><span class="line"><span class="keyword">union</span> sigval sigev_value;                     <span class="comment">/* notify arqument */</span></span><br><span class="line"><span class="keyword">void</span> (*sigev_notify_funetion) (<span class="keyword">union</span> sigval); <span class="comment">/* notify function */</span></span><br><span class="line"><span class="keyword">pthread_attr_t</span> *sigev_notify_attributes;      <span class="comment">/* notity attrs */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>sigev_notify</code>字段控制通知的类型。取值可能是以下3个中的一个。</p>
<ul>
<li><code>SIGEV_NONE</code>：异步I/O请求完成后，不通知进程。</li>
<li><code>SIGEV_SIGNAL</code>：异步IO请求完成后，产生由<code>sigev_signo</code>字段指定的信号。如果应用程序已选择捕捉信号，且在建立信号处理程序的时候指定了<code>SA_SIGINFO</code>标志，那么该信号将被入队(如果实现支持捶队信号)。信号处理程序会传送给一个<code>siginfo</code>结构，该结构的<code>si_value</code>字段被设置为<code>sigev_value</code>(如果使用了<code>SA_SIGINFO</code>标志)。</li>
<li><code>SIGEV_THREAD</code>：当异步I/O请求完成时，由<code>sigev_notify_function</code>字段指定的函数被调用。<code>sigev_value</code>字段被传入作为它的唯一参数。除非<code>sigev_notify_attributes</code>字段被设定为<code>pthread</code>属性结构的地址，且该结构指定了一个另外的线程属性，否则该函数将在分离状态下的一个单独的线程中执行。</li>
</ul>
<p>在进行异步I/O之前需要先初始化AIO控制块，调用<code>aio_read</code>函数来进行异步读操作，或调用<code>aio_write</code>函数来进行异步写操作。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> caio.h&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">aio_read</span> <span class="params">(struct aiocb *aiocb)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">aio_write</span> <span class="params">(struct aiocb *aiocb)</span></span>;</span><br><span class="line"><span class="comment">// 两个函数的返回值：若成功，返回0；若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>当这些函数返回成功时，异步I/O请求便已经被操作系统放入等待处理的队列中了。这些返回值与实际I/O操作的结果没有任何关系。I/O操作在等待时，必须注意确保AIO控制块和数据库缓冲区保持稳定；它们下面对应的内存必须始终是合法的，除非I/O操作完成，否则不能被复用。要想强制所有等待中的异步操作不等待而写入持久化的存储中，可以设立一个AIO控制块并调用<code>aio_fsync</code>函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;aio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">aio_async</span><span class="params">(<span class="keyword">int</span> op, struct aiocb *aiocb)</span></span>;</span><br><span class="line"><span class="comment">// 返回值，若成功，返回0；若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>AIO控制块中的<code>aio_fildes</code>字段指定了其异步写操作被同步的文件。如果<code>op</code>参数设定为<code>O_DSYNC</code>，那么操作执行起来就会像调用了<code>fdatasync</code>一样。否则，如果<code>op</code>参数设定为<code>O_SYNC</code>，那么操作执行起来就会像调用了<code>fsync</code>一样。</p>
<p>像<code>aio_read</code>和<code>aio_write</code>函数一样，在安排了同步时，<code>aio_fsync</code>操作返回。在异步同步操作完成之前，数据不会被持久化。AIO控制块控制我们如何被通知，就像<code>aio_read</code>和<code>aio_write</code>函数一样，为了获知一个异步读、写或者同步操作的完成状态，需要调用<code>aio_error</code>函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;aio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">aio_error</span> <span class="params">(<span class="keyword">const</span> struct aiocb *aiocb)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>返回值为下面4种情况中的一种</p>
<ul>
<li>0：异步操作成功完成。需要调用<code>aio_return</code>函数获取操作返回值。</li>
<li>-1：对<code>aio_error</code>的调用失败。这种情况下，errno会告诉我们为什么。</li>
<li><code>EINPROGRESS</code>：异步读、写或同步操作仍在等待。</li>
<li>其他情况：其他任何返回值是相关的异步操作失败返回的错误码。</li>
</ul>
<p>如果异步操作成功，可以调用<code>aio_return</code>函数来获取异步操作的返回值。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;aio.h&gt;</span></span></span><br><span class="line"><span class="keyword">size_t</span> aio_return (<span class="keyword">const</span> struct aiocb *aiocb);</span><br></pre></td></tr></table></figure></p>
<p>直到异步操作完成之前，都需要小心不要调用<code>aio_return</code>函数。操作完成之前的结果是来定义的。还需要小心对每个异步操作只调用一次<code>aio_return</code>。一旦调用了该函数，操作系统就可以释放掉包含了I/O操作返回值的记录。如果<code>aio_return</code>函数本身失败，会返回-1，并设置errno。其他情况下，它将返回异步操作的结果，即会返回<code>read</code>、<code>write</code>或者<code>fsync</code>在被成功调用时可能返回的结果。</p>
<p>执行I/O操作时，如果还有其他事务要处理而不想被I/O操作阻塞，就可以使用异步I/O。然如果在完成了所有事务时，还有异步操作未完成时，可以调用<code>aio_suspend</code>函数来阻塞进直到操作完成。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;aio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">aio_suspend</span> <span class="params">(<span class="keyword">const</span> struct aiocb *<span class="keyword">const</span> <span class="built_in">list</span>[], <span class="keyword">int</span> nent, <span class="keyword">const</span> struct timespec *timeout)</span></span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回0；若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p><code>aio_suspend</code>可能会返回三种情况中的一种。</p>
<ul>
<li>如果我们被一个信号中断，它将会返回-1，并将errno设置为EINTR。</li>
<li>如果在没有任何I/O操作完成的情况下，阻塞的时间超过了函数中可选的<code>timeout</code>参数所指定的时间限制，那么<code>aio_suspend</code>将返回-1，并将errno设置为EAGAIN。</li>
<li>如果有任何I/O操作完成，<code>aio_suspend</code>将返回0。</li>
<li>如果在我们调用<code>aio_suspend</code>操作时，所有的异步I/O操作都已完成，那么<code>aio_suspend</code>将在不阻塞的情况下直接返回。</li>
</ul>
<p><code>list</code>参数是一个指向AIO控制块数组的指针，<code>nent</code>参数表明了数组中的条目数。数组中的空指针会被跳过，其他条目都必须指向已用于初始化异步I/O操作的AIO控制块。</p>
<p>当还有我们不想再完成的等待中的异步I/O操作时，可以尝试使用<code>aio_cancel</code>函数来取消它们。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;aio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">aio_cancel</span><span class="params">(<span class="keyword">int</span> fd, struct aiocb *aiocb)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p><code>fd</code>参数指定了那个未完成的异步I/O操作的文件描述符。如果<code>aiocb</code>参数为NULL，系统将会尝试取消所有该文件上未完成的异步I/O操作。其他情况下，系统将尝试取消由AIO控制块描述的单个异步I/O操作。我们之所以说系统“尝试”取消操作，是因为无法保证系统能够取消正在进程中的任何操作。</p>
<p><code>aio_cancel</code>函数可能会返回以下4个值中的一个。</p>
<ul>
<li><code>AIO_ALLDONE</code>：所有操作在尝试取消它们之前已经完成。</li>
<li><code>AIO_CANCELED</code>：所有要求的操作已被取消</li>
<li><code>AIO_NOTCANCELED</code>：至少有一个要求的操作没有被取消.</li>
<li>-1：对<code>aio_cancel</code>的调用失败，错误码将被存储在errno中。</li>
</ul>
<p>如果异步I/O操作被成功取消，对相应的AIO控制块调用<code>aio_error</code>函数将会返回错误ECANCELED。如果操作不能被取消，那么相应的AIO控制块不会因为对<code>aio_cancel</code>的调用而被修改。</p>
<p>还有一个函数也被包含在异步I/O接口当中，尽管它既能以同步的方式来使用，又能以异步的方式来使用，这个函数就是<code>lio_listio</code>。该函数提交一系列由一个AIO控制块列表描述的IO请求。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;aio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lio_lintio</span><span class="params">(<span class="keyword">int</span> mode, struct aiocb *<span class="keyword">restrict</span> <span class="keyword">const</span> <span class="built_in">list</span>[<span class="keyword">restrict</span>],</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">int</span> nent, struct sigevent *<span class="keyword">restrict</span> sigev)</span></span>;</span><br><span class="line"><span class="comment">// 返回值，若成功，返回0；若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p><code>mode</code>参数决定了I/O是否真的是异步的。如果该参数被设定为<code>LIO_WAIT</code>，<code>lio_listio</code>函数将在所有由列表指定的I/O操作完成后返回。在这种情况下，<code>sigev</code>参数将被忽略。如果<code>mode</code>参数被设定为<code>LIO_NOWAIT</code>，<code>lio_listio</code>函数将在I/O请求入队后立即返回。进程将在所有I/O操作完成后，按照<code>sigev</code>参数指定的，被异步地通知。如果不想被通知，可以把<code>sigev</code>设定为NULL。注意，每个AIO控制块本身也可能肩用了在各自操作完成时的异步通知。被<code>sigev</code>参数指定的异步通知是在此之外另加的，并且只会在所有的I/O操作完成后发送。</p>
<p><code>list</code>参数指向AIO控制块列表，该列表指定了要运行的I/O操作的。<code>nent</code>参数指定了数组中的元素个数。AIO控制块列表可以包含NULL指针，这些条目将被忽略。</p>
<p>在每一个AIO控制块中，<code>alo_lio_opcode</code>字段指定了该操作是一个读操作(<code>LIO_READ</code>)、写操作(<code>LIO_WRITE</code>)，还是将被忽略的空操作(<code>LIO_NOP</code>)。 读操作会按照对应的AIO控制块被传给了<code>aio_read</code>函数来处理。类似地，写操作会按照对应的AIO控制块被传给了<code>aio_write</code>函数来处理。</p>
<p>实现会限制我们不想完成的异步I/O操作的数量。这些限制都是运行时不变量。</p>
<p>可以通过调用<code>sysconf</code>函数并把<code>name</code>参数设置为<code>_SC_IO_LISTIO_MAX</code>来设定<code>AIO_LISTIO_MAX</code>的值。类似地，可以通过调用<code>sysconf</code>并把<code>name</code>参数设置为<code>_SC_AIO_MAX</code>来设定<code>AIO_MAX</code>的值，通过调用<code>sysconf</code>并把其参数设置为<code>_SC_AIO_PRIO_DELTA_MAX</code>来设定<code>AIO_PRIO_DELTA_MAX</code>的值。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
<th>可接受的最小值</th>
</tr>
</thead>
<tbody>
<tr>
<td>AIO_LISTIO_MAX</td>
<td>单个列表I/O调用中的最大I/O操作数</td>
<td><code>_POSIX_AIO_LISTIO_MAX(2)</code></td>
</tr>
<tr>
<td>AIO_MAX</td>
<td>未完成的异步I/O操作的最大数目</td>
<td><code>_POSIX_AIO_MAX(1)</code></td>
</tr>
<tr>
<td>AIO_PRIO_DELTA_MAX</td>
<td>进程可以减少的其异步I/O优先级的最大值</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>引入POSIX异步操作IO接口的初衷是为实时应用提供一种方法，避免在执行I/O操作时阻塞进程。</p>
<p>从输入文件中读取一个块，翻译之，然后再把这个块写到输出文件中。重复该步骤直到遇到文件尾端，read返回0。程序展示了如何使用异步I/O函数完成。<br><figure class="highlight plain"><figcaption><span>"apue.h"</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;ctype.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;aio.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line"></span><br><span class="line">#define BSZ 4096</span><br><span class="line">#define NBUF 8</span><br><span class="line"></span><br><span class="line">enum rwop &#123;</span><br><span class="line">	UNUSED = 0,</span><br><span class="line">	READ_PENDING = 1,</span><br><span class="line">	WRITE_PENDING = 2</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct buf &#123;</span><br><span class="line">	enum rwop     op;</span><br><span class="line">	int           last;</span><br><span class="line">	struct aiocb  aiocb;</span><br><span class="line">	unsigned char data[BSZ];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct buf bufs[NBUF];</span><br><span class="line"></span><br><span class="line">unsigned char</span><br><span class="line">translate(unsigned char c)</span><br><span class="line">&#123;</span><br><span class="line">	/* same as before */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int</span><br><span class="line">main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	int					ifd, ofd, i, j, n, err, numop;</span><br><span class="line">	struct stat			sbuf;</span><br><span class="line">	const struct aiocb	*aiolist[NBUF];</span><br><span class="line">	off_t				off = 0;</span><br><span class="line"></span><br><span class="line">	if (argc != 3)</span><br><span class="line">		err_quit(&quot;usage: rot13 infile outfile&quot;);</span><br><span class="line">	if ((ifd = open(argv[1], O_RDONLY)) &lt; 0)</span><br><span class="line">		err_sys(&quot;can&apos;t open %s&quot;, argv[1]);</span><br><span class="line">	if ((ofd = open(argv[2], O_RDWR|O_CREAT|O_TRUNC, FILE_MODE)) &lt; 0)</span><br><span class="line">		err_sys(&quot;can&apos;t create %s&quot;, argv[2]);</span><br><span class="line">	if (fstat(ifd, &amp;sbuf) &lt; 0)</span><br><span class="line">		err_sys(&quot;fstat failed&quot;);</span><br><span class="line"></span><br><span class="line">	/* initialize the buffers */</span><br><span class="line">	for (i = 0; i &lt; NBUF; i++) &#123;</span><br><span class="line">		bufs[i].op = UNUSED;</span><br><span class="line">		bufs[i].aiocb.aio_buf = bufs[i].data;</span><br><span class="line">		bufs[i].aiocb.aio_sigevent.sigev_notify = SIGEV_NONE;</span><br><span class="line">		aiolist[i] = NULL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	numop = 0;</span><br><span class="line">	for (;;) &#123;</span><br><span class="line">		for (i = 0; i &lt; NBUF; i++) &#123;</span><br><span class="line">			switch (bufs[i].op) &#123;</span><br><span class="line">			case UNUSED:</span><br><span class="line">				/*</span><br><span class="line">				 * Read from the input file if more data</span><br><span class="line">				 * remains unread.</span><br><span class="line">				 */</span><br><span class="line">				if (off &lt; sbuf.st_size) &#123;</span><br><span class="line">					bufs[i].op = READ_PENDING;</span><br><span class="line">					bufs[i].aiocb.aio_fildes = ifd;</span><br><span class="line">					bufs[i].aiocb.aio_offset = off;</span><br><span class="line">					off += BSZ;</span><br><span class="line">					if (off &gt;= sbuf.st_size)</span><br><span class="line">						bufs[i].last = 1;</span><br><span class="line">					bufs[i].aiocb.aio_nbytes = BSZ;</span><br><span class="line">					if (aio_read(&amp;bufs[i].aiocb) &lt; 0)</span><br><span class="line">						err_sys(&quot;aio_read failed&quot;);</span><br><span class="line">					aiolist[i] = &amp;bufs[i].aiocb;</span><br><span class="line">					numop++;</span><br><span class="line">				&#125;</span><br><span class="line">				break;</span><br><span class="line"></span><br><span class="line">			case READ_PENDING:</span><br><span class="line">				if ((err = aio_error(&amp;bufs[i].aiocb)) == EINPROGRESS)</span><br><span class="line">					continue;</span><br><span class="line">				if (err != 0) &#123;</span><br><span class="line">					if (err == -1)</span><br><span class="line">						err_sys(&quot;aio_error failed&quot;);</span><br><span class="line">					else</span><br><span class="line">						err_exit(err, &quot;read failed&quot;);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				/*</span><br><span class="line">				 * A read is complete; translate the buffer</span><br><span class="line">				 * and write it.</span><br><span class="line">				 */</span><br><span class="line">				if ((n = aio_return(&amp;bufs[i].aiocb)) &lt; 0)</span><br><span class="line">					err_sys(&quot;aio_return failed&quot;);</span><br><span class="line">				if (n != BSZ &amp;&amp; !bufs[i].last)</span><br><span class="line">					err_quit(&quot;short read (%d/%d)&quot;, n, BSZ);</span><br><span class="line">				for (j = 0; j &lt; n; j++)</span><br><span class="line">					bufs[i].data[j] = translate(bufs[i].data[j]);</span><br><span class="line">				bufs[i].op = WRITE_PENDING;</span><br><span class="line">				bufs[i].aiocb.aio_fildes = ofd;</span><br><span class="line">				bufs[i].aiocb.aio_nbytes = n;</span><br><span class="line">				if (aio_write(&amp;bufs[i].aiocb) &lt; 0)</span><br><span class="line">					err_sys(&quot;aio_write failed&quot;);</span><br><span class="line">				/* retain our spot in aiolist */</span><br><span class="line">				break;</span><br><span class="line"></span><br><span class="line">			case WRITE_PENDING:</span><br><span class="line">				if ((err = aio_error(&amp;bufs[i].aiocb)) == EINPROGRESS)</span><br><span class="line">					continue;</span><br><span class="line">				if (err != 0) &#123;</span><br><span class="line">					if (err == -1)</span><br><span class="line">						err_sys(&quot;aio_error failed&quot;);</span><br><span class="line">					else</span><br><span class="line">						err_exit(err, &quot;write failed&quot;);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				/*</span><br><span class="line">				 * A write is complete; mark the buffer as unused.</span><br><span class="line">				 */</span><br><span class="line">				if ((n = aio_return(&amp;bufs[i].aiocb)) &lt; 0)</span><br><span class="line">					err_sys(&quot;aio_return failed&quot;);</span><br><span class="line">				if (n != bufs[i].aiocb.aio_nbytes)</span><br><span class="line">					err_quit(&quot;short write (%d/%d)&quot;, n, BSZ);</span><br><span class="line">				aiolist[i] = NULL;</span><br><span class="line">				bufs[i].op = UNUSED;</span><br><span class="line">				numop--;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if (numop == 0) &#123;</span><br><span class="line">			if (off &gt;= sbuf.st_size)</span><br><span class="line">				break;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			if (aio_suspend(aiolist, NBUF, NULL) &lt; 0)</span><br><span class="line">				err_sys(&quot;aio_suspend failed&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	bufs[0].aiocb.aio_fildes = ofd;</span><br><span class="line">	if (aio_fsync(O_SYNC, &amp;bufs[0].aiocb) &lt; 0)</span><br><span class="line">		err_sys(&quot;aio_fsync failed&quot;);</span><br><span class="line">	exit(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意，我们使用了8个缓冲区，因此可以有最多8个异步I/O请求处于等待状态。在检查操作的返回值之前，必须确认操作已经完成。当<code>aio_error</code>返回的值既非EINPROGRESS亦非-1时，表明操作完成。除了这些值之外，如果返回值是0以外的任何值，说明操作失败了。一旦检查过这些情况，便可以安全地调用<code>aio_return</code>来获取I/O操作的返回值了。</p>
<p>只要还有事情要做，就可以提交异步I/O操作。当存在未使用的AIO控制块时，可以提交一个异步读操作。读操作完成后，翻译缓冲区中的内容并将它提交给一个异步写请求。当所有AIO控制块都在使用中时，通过调用<code>aio_suspend</code>等待操作完成。</p>
<h2 id="函数readv和writev"><a href="#函数readv和writev" class="headerlink" title="函数readv和writev"></a>函数readv和writev</h2><p><code>readv</code>和<code>writev</code>函数用于在一次函数调用中读、写多个非连续缓冲区。有时也将这两个函数称为散布读(scatter read)和聚集写(gather write)。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ays/uio.h&gt;</span></span></span><br><span class="line"><span class="keyword">ssize_t</span> readv(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct iovec *iov, <span class="keyword">int</span> iovent);</span><br><span class="line"><span class="keyword">ssize_t</span> writev(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct iovec *iov, <span class="keyword">int</span> iovent);</span><br><span class="line"><span class="comment">// 两个函数的返回值，已读或已写的字节数；若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>这两个函数的第二个参数是指向<code>iovec</code>结构数组的一个指针：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> &#123;</span></span><br><span class="line">	<span class="keyword">void</span> *iov_bases <span class="comment">/* starting address of buffer */</span></span><br><span class="line">	<span class="keyword">size_t</span> iov_len; <span class="comment">/* size of buffer */</span></span><br></pre></td></tr></table></figure></p>
<p><code>iov</code>数组中的元素数由<code>iovent</code>指定，其最大值受限于<code>IOV_MAX</code>。图中显示了这两个函数的参数和<code>iovec</code>结构之间的关系。<br><img src="/img/20210604122019.png" alt></p>
<p><code>writev</code>函数从缓冲区中来集输出数据的顺序是：<code>iov[0]</code>、<code>iov[1]</code>直至<code>iov[iovent-1]</code>。<code>writev</code>返回输出的字节总数，通常应等于所有缓冲区长度之和。</p>
<p><code>readv</code>函数则将读入的数据按上述同样顺序散布到缓冲区中。<code>readv</code>总是先填满一个缓冲区，然后再填写下一个。<code>readv</code>返回读到的字节总数。如果遇到文件尾端，己无数据可读，则返回0。</p>
<h2 id="函数readn和writen"><a href="#函数readn和writen" class="headerlink" title="函数readn和writen"></a>函数readn和writen</h2><p>管道、FIFO以及某些设备(特别是终端和网络)有下列两种性质。</p>
<ol>
<li>一次<code>read</code>操作所返回的数据可能少于所要求的数据，即使还没达到文件尾端也可能是这样。这不是一个错误，应当继续读该设备。</li>
<li>一次<code>write</code>操作的返回值也可能少于指定输出的字节数。这可能是由某个因素造成的。</li>
</ol>
<p>在读、写磁盘文件时从未见到过这种情况，除非文件系统用完了空间，或者接近了配额限制，不能将要求写的数据全部写出。</p>
<p>通常，在读、写一个管道、网络设备或终端时，需要考虑这些特性。下面两个函数<code>readn</code>和<code>writen</code>的功能分别是读、写指定的N字节数据，并处理返回值可能小于要求值的情况。这两个函数只是按需多次调用<code>read</code>和<code>write</code>直至读、写了N字节数据。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="keyword">ssize_t</span> readn(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes);</span><br><span class="line"><span class="keyword">ssize_t</span> writen(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbyees);</span><br><span class="line"><span class="comment">// 两个函数的返回值：读、写的字节数，若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>在要将数据写到上面提到的文件类型上时，就可调用<code>writen</code>，但是仅当事先就知道要接收数据的数量时，才调用<code>readn</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span>             <span class="comment">/* Read "n" bytes from a descriptor  */</span></span><br><span class="line">readn(<span class="keyword">int</span> fd, <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">size_t</span>		nleft;</span><br><span class="line">	<span class="keyword">ssize_t</span>		nread;</span><br><span class="line"></span><br><span class="line">	nleft = n;</span><br><span class="line">	<span class="keyword">while</span> (nleft &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((nread = read(fd, ptr, nleft)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (nleft == n)</span><br><span class="line">				<span class="keyword">return</span>(<span class="number">-1</span>); <span class="comment">/* error, return -1 */</span></span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="keyword">break</span>;      <span class="comment">/* error, return amount read so far */</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (nread == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">break</span>;          <span class="comment">/* EOF */</span></span><br><span class="line">		&#125;</span><br><span class="line">		nleft -= nread;</span><br><span class="line">		ptr   += nread;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>(n - nleft);      <span class="comment">/* return &gt;= 0 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意，若在已经读、写了一些数据之后出错，则这两个函数返回的是已传输的数据量，而非错误。与此类似，在读时，如达到文件尾端，而且在此之前已成功地读了一些数据，但尚未满足所要求的量，则<code>readn</code>返回已复制到调用者缓冲区中的字节数。</p>
<h2 id="存储映射I-O"><a href="#存储映射I-O" class="headerlink" title="存储映射I/O"></a>存储映射I/O</h2><p>存储映射I/O(memory-mapped I/O)能将一个磁盘文件映射到存储空间中的一个缓冲区上，于是。当从缓冲区中取数据时，就相当于读文件中的相应字节。与此类似，将数据存入缓冲区时，相应字节就自动写入文件。这样，就可以在不使用<code>read</code>和<code>write</code>的情况下执行I/O。</p>
<p>为了使用这种功能，应首先告诉内核将一个给定的文件映射到一个存储区域中。这是由<code>map</code>函数实现的。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mmap</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> len, <span class="keyword">int</span> prot, <span class="keyword">int</span> flag, <span class="keyword">int</span> fd, <span class="keyword">off_t</span> off)</span></span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回映射区的起始地址；若出错，返回MAP.PAILED</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>addr</code>参数用于指定映射存储区的起始地址。通常将其设置为0。这表示由系统选择该映射区的起始地址。此函数的返回值是该映射区的起始地址。</li>
<li><code>fd</code>参数是指定要被映射文件的描述符。在文件映射到地址空间之前，必须先打开该文件。<code>len</code>参数是映射的字节数，<code>off</code>是要映射字节在文件中的起始偏移量。</li>
<li><code>prot</code>参数指定了映射存储区的保护要求，如下所示。</li>
</ul>
<table>
<thead>
<tr>
<th>prot</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>PROT_READ</td>
<td>映射区可读</td>
</tr>
<tr>
<td>PROT_WRITE</td>
<td>映射区可写</td>
</tr>
<tr>
<td>PROT_EXEC</td>
<td>映射区可执行</td>
</tr>
<tr>
<td>PROT_NONE</td>
<td>映射区不可访问</td>
</tr>
</tbody>
</table>
<p>可将<code>prot</code>参数指定任意组合的按位或。对指定映射存储区的保护要求不能超过文件<code>open</code>模式访问权限。</p>
<p>图中显示了一个存储映射文件。在此图中，“起始地址”是<code>mmap</code>的返回值。映射存储区位于堆和栈之间。<br><img src="/img/20210604124542.png" alt></p>
<p>下面是<code>flag</code>参数影响映射存储区的多种属性</p>
<ul>
<li><code>MAP_FIXED</code>：返回值必须等于<code>addr</code>，因为这不利于可移植性，所以不鼓励使用此标志。如果未指定此标志，而且<code>addr</code>非0，则内核只把<code>addr</code>视为在何处设置映射区的一种建议，但是不保证会使用所要求的地址。将<code>addr</code>指定为0可获得最大可移植性。</li>
<li><code>MAR_SHARED</code>：这一标志描述了本进程对映射区所进行的存储操作的配置。此标志指定存储操作修改映射文件。</li>
<li><code>MAP_PRIVATE</code>：本标志说明，对映射区的存储操作导致创建该映射文件的一个私有副本。所有后来对该映射区的引用都是引用该副本。</li>
</ul>
<p><code>off</code>的值和<code>addr</code>的值(如果指定了<code>MAP_FIXED</code>)通常被要求是系统虚拟存储页长度的倍数。虚拟存储页长可用带参数<code>_SC_PAGESIZE</code>或<code>SC_PAGE_SIZE</code>的<code>sysconf</code>函数得到。因为<code>off</code>和<code>addr</code>常常指定为0，所以这种要求一般并不重要。</p>
<p>既然映射文件的起始偏移量受系统虚拟存储页长度的限制，那么如果映射区的长度不是页长的整数倍时，文件长为12字节， 系统页长为512字节，则系统通常提供512字节的映射区，其中后500字节被设置为0。可以修改后面的这500字节，但任何变动都不会在文件中反映出来。于是，不能用<code>mmap</code>将数据添加到文件中。</p>
<p>与映射区相关的信号有<code>SIGSEGV</code>和<code>SIGBUS</code>。信号<code>SIGSEGV</code>通常用于指示进程试图访问对它不可用的存储区。如果映射存储区被<code>mmap</code>指定成了只读的，那么进程试图将数据存入这个映射存储区的时候，也会产生此信号。如果映射区的某个部分在访问时已不存在，则产生<code>SIGBUS</code>信号。例如，假设用文件长度映射了一个文件，但在引用该映射区之前，另一个进程已将该文件截断。此时，如果进程试图访问对应于该文件已截去部分的映射区，将会接收到<code>SIGBUS</code>信号。</p>
<p>子进程能通过<code>fork</code>继承存储映射区(因为子进程复制父进程地址空间，而存储映射区是该地址空间中的一部分)，但是由于同样的原因，新程序则不能通过<code>exec</code>继承存储映射区。</p>
<p>调用<code>mprotect</code>可以更改一个现有映射的权限。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mprotect</span> <span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> len, <span class="keyword">int</span> prot)</span></span>;</span><br><span class="line"><span class="comment">// 返回值，若成功，返回0；若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p><code>prot</code>的合法值与<code>mmap</code>中<code>prot</code>参数的一样。请注意，地址参数<code>addr</code>的值必须是系统页长的整数倍。</p>
<p>如果修改的页是通过<code>MAP_SHARED</code>标志映射到地址空间的，那么修改并不会立即写回到文件中。相反，何时写回脏页由内核的守护进程决定，决定的依据是系统负载和用来限制在系统失败事件中的数据损失的配置参数。因此，如果只修改了一页中的一个字节，当修改被写回到文件中时，整个页都会被写回。</p>
<p>如果共享映射中的页已修改，那么可以调用<code>msync</code>将该页冲洗到被映射的文件中。<code>msync</code>函数类似于<code>fsync</code>，但作用于存储映射区。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/man.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msync</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回0；若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>如果映射是私有的，那么不修改被映射的文件。与其他存储映射函数一样，地址必须与页边界对齐。</p>
<p><code>flags</code>参数使我们对如何冲洗存储区有某种程度的控制。可以指定<code>MS_ASYNC</code>标志来简单地调试要写的页。如果希望在返回之前等待写操作完成，则可指定<code>MS_SYNC</code>标志。一定要指定<code>MS_ASYNC</code>和<code>MS_SYNC</code>中的一个。</p>
<p><code>MS_INVALIDATE</code>是一个可选标志， 允许我们通知操作系统丢弃那些与底层存储器没有同步的页。若使用了此标志，某些实现将丢弃指定范围中的所有页，但这种行为并不是必需的。</p>
<p>当进程终止时，会自动解除存储映射区的映射，或者直接调用<code>munmap</code>函数也可以解除映射。关闭映射存储区时使用的文件描述符并不解除映射区。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">munmap</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> len)</span></span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回0；若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p><code>munmap</code>并不影响被映射的对象，也就是说，调用<code>munmap</code>并不会使映射区的内容写到磁盘文件上。对于<code>MAR_SHARED</code>区磁盘文件的更新， 会在我们将数据写到存储映射区后的某个时刻，按内核虚拟存储算法自动进行。在存储区解除映射后，对<code>MAP_PRIVATE</code>存储区的修改会被丢弃。</p>
<p>程序用存储映射I/O复制文件。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COPYINCR (1024*1024*1024)	<span class="comment">/* 1 GB */</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span>			fdin, fdout;</span><br><span class="line">	<span class="keyword">void</span>		*src, *dst;</span><br><span class="line">	<span class="keyword">size_t</span>		copysz;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">stat</span>	<span class="title">sbuf</span>;</span></span><br><span class="line">	<span class="keyword">off_t</span>		fsz = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">3</span>)</span><br><span class="line">		err_quit(<span class="string">"usage: %s &lt;fromfile&gt; &lt;tofile&gt;"</span>, argv[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((fdin = open(argv[<span class="number">1</span>], O_RDONLY)) &lt; <span class="number">0</span>)</span><br><span class="line">		err_sys(<span class="string">"can't open %s for reading"</span>, argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((fdout = open(argv[<span class="number">2</span>], O_RDWR | O_CREAT | O_TRUNC,</span><br><span class="line">	  FILE_MODE)) &lt; <span class="number">0</span>)</span><br><span class="line">		err_sys(<span class="string">"can't creat %s for writing"</span>, argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (fstat(fdin, &amp;sbuf) &lt; <span class="number">0</span>)			<span class="comment">/* need size of input file */</span></span><br><span class="line">		err_sys(<span class="string">"fstat error"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ftruncate(fdout, sbuf.st_size) &lt; <span class="number">0</span>)	<span class="comment">/* set output file size */</span></span><br><span class="line">		err_sys(<span class="string">"ftruncate error"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (fsz &lt; sbuf.st_size) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((sbuf.st_size - fsz) &gt; COPYINCR)</span><br><span class="line">			copysz = COPYINCR;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			copysz = sbuf.st_size - fsz;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> ((src = mmap(<span class="number">0</span>, copysz, PROT_READ, MAP_SHARED,</span><br><span class="line">		  fdin, fsz)) == MAP_FAILED)</span><br><span class="line">			err_sys(<span class="string">"mmap error for input"</span>);</span><br><span class="line">		<span class="keyword">if</span> ((dst = mmap(<span class="number">0</span>, copysz, PROT_READ | PROT_WRITE,</span><br><span class="line">		  MAP_SHARED, fdout, fsz)) == MAP_FAILED)</span><br><span class="line">			err_sys(<span class="string">"mmap error for output"</span>);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">memcpy</span>(dst, src, copysz);	<span class="comment">/* does the file copy */</span></span><br><span class="line">		munmap(src, copysz);</span><br><span class="line">		munmap(dst, copysz);</span><br><span class="line">		fsz += copysz;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该程序首先打开两个文件，然后调用<code>fstat</code>得到输入文件的长度。在为输入文件调用<code>map</code>和设置输出文件长度时都需使用输入文件长度。可以调用<code>ftruncate</code>设置输出文件的长度。如果不设置输出文件的长度，则对输出文件调用<code>mmap</code>也可以，但是对相关存储区的第一次引用会产生SIGBUS信号。</p>
<p>然后对每个文件调用<code>mmap</code>，将文件映射到内存，最后调用<code>memcpy</code>将输入缓冲区的内容复制到输出缓冲区。为了限制使用内存的量，我们每次最多复制1GB的数据(如果系统没有足够的内存，可能无法把一个很大的文件中的所有内容都映射到内存中)。在映射文件中的后一部分数据之前，我们需要解除前一部分数据的映射。</p>
<p>在从输入缓冲区(src)取数据字节时，内核自动读输入文件：在将数据存入输出缓冲区(dst)时，内核自动将数据写到输出文件中。</p>
<p>数据被写到文件的确切时间依赖于系统的页管理算法。某些系统设置了守护进程，在系统运行期间，它慢条斯理地将改写过的页写到磁盘上。如果想要确保数据安全地写到文件中，则需在进程终止前以<code>MS_SYNC</code>标志调用<code>msync</code>。</p>
<p>使用<code>mmap</code>和<code>memcpy</code>复制，与使用<code>read</code>和<code>write</code>相比，花费了更多的用户时间，但却减少了系统时间。在Linux中，用<code>read</code>和<code>write</code>消耗的系统时间要比使用<code>mmap</code>和<code>memcpy</code>略好一些。这两种版本的方法是殊途同归的。</p>
<p>二者的主要区别在于，与<code>mmap</code>和<code>memcpy</code>相比，<code>read</code>和<code>write</code>执行了更多的系统调用，并做了更多的复制。<code>read</code>和<code>write</code>将数据从内核缓冲区中复制到应用缓冲区(read)，然后再把数据从应用缓冲区复制到内核缓冲区(write)。而<code>mmap</code>和<code>memcpy</code>则直接把数据从映射到地址空间的一个内核缓冲区复制到另一个内核缓冲区。当引用尚不存在的内存页时，这样的复制过程就会作为处理页错误的结果面出现(每次错页读发生一次错误， 每次错页写发生一次错误)。如果系统调用和额外的复制操作的开销和页错误的开销不同，那么这两种方法中就会有一种比另一种表现更好。</p>
<h1 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>进程间通信(InterProcess Communication, IPC)是各种进程通信方式的统称。</p>
<ul>
<li>半双工管道</li>
<li>FIFO</li>
<li>全双工管道</li>
<li>命名全双工管道</li>
<li>XSI消息队列</li>
<li>XSI信号量</li>
<li>XSI共享存储</li>
<li>消息队列(实时)</li>
<li>信号量</li>
<li>共享存储(实时)</li>
<li>套接字</li>
<li>STREAMS</li>
</ul>
<h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>管道是UNIX系统IPC的最古老形式，所有UNIX系统都提供此种通信机制。管道有以下两种局限性：</p>
<ol>
<li>历史上，它们是半双工的(即数据只能在一个方向上流动)。现在，某些系统提供全双工管道。</li>
<li>管道只能在具有公共祖先的两个进程之间使用。通常，一个管道由一个进程创建，在进程调用<code>fork</code>之后，这个管道就能在父进程和子进程之间使用了。</li>
</ol>
<p>半双工管道仍是最常用的IPC形式。每当在管道中键入一个命令序列，让shell执行时，shell都会为每一条命令单独创建一个进程，然后用管道将前一条命令进程的标<br>准输出与后一条命令的标准输入相连接。</p>
<p>管道是通过调用<code>pipe</code>函数创建的。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> fd[<span class="number">2</span>])</span></span>;</span><br><span class="line"><span class="comment">// 返回值，若成功，返回0；若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>经由参数<code>fd</code>返回两个文件描述符：<code>fd[0]</code>为读而打开，<code>f[1]</code>为写而打开。<code>fd[1]</code>的输出是<code>fd[0]</code>的输入。</p>
<p><code>fstat</code>函数对管道的每一端都返回一个FIFO类型的文件描述符。可以用<code>S_ISFIFO</code>宏来测试管道。POSIX.1规定<code>stat</code>结构的<code>st_size</code>成员对于管道是未定义的。但是当<code>fstat</code>函数应用于管道读端的文件描述符时，很多系统在<code>st_size</code>中存储管道中可用于读的字节数。但是，这是不可移植的。</p>
<p>单个进程中的管道几乎没有任何用处。通常，进程会先调用<code>pipe</code>，接着调用<code>fork</code>，从而创建从父进程到子进程的IPC通道，反之亦然。</p>
<p><code>fork</code>之后做什么取决于我们想要的数据流的方向。对于从父进程到子进程的管道，父进程关闭管道的读端(<code>fd[0]</code>)，子进程关闭写端(<code>fd[1]</code>)。</p>
<p>对于一个从子进程到父进程的管道，父进程关闭<code>fd[1]</code>，子进程关闭<code>fd[0]</code>。</p>
<p>当管道的一端被关闭后，下列两条规则起作用。</p>
<ol>
<li>当读(read)一个写已被关闭的管道时，在所有数据都被读取后，read返回0；表示文件结束。</li>
<li>如果写(write)一个读端已被关闭的管道，则产生信号<code>SIGPIPE</code>。如果忽略该信号或者捕捉该信号并从其处理程序返回，则<code>write</code>返回-1，errno设置为EPIPE.</li>
</ol>
<p>在写管道(或FIFO)时，常量<code>PIPE_BUF</code>规定了内核的管道缓冲区大小。如果对管道调用<code>write</code>，而且要求写的字节数小于等于<code>PIPE_BUF</code>，则此操作不会与其他进程对同一管道(或FIFO)的<code>write</code>操作交叉进行。但是，若有多个进程同时写一个管道(或FIFO)，而且我们要求写的字节数超过<code>PIPE_BUF</code>，那么我们所写的数据可能会与其他进程所写的数据相互交叉。用<code>pathconf</code>或<code>fpathconf</code>函数可以确定<code>PIPE_BUF</code>的值。</p>
<p>程序创建了一个从父进程到子进程的管道，并且父进程经由该管道向子进程传送数据。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span>		n;</span><br><span class="line">	<span class="keyword">int</span>		fd[<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">pid_t</span>	pid;</span><br><span class="line">	<span class="keyword">char</span>	line[MAXLINE];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pipe(fd) &lt; <span class="number">0</span>)</span><br><span class="line">		err_sys(<span class="string">"pipe error"</span>);</span><br><span class="line">	<span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		err_sys(<span class="string">"fork error"</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;		<span class="comment">/* parent */</span></span><br><span class="line">		close(fd[<span class="number">0</span>]);</span><br><span class="line">		write(fd[<span class="number">1</span>], <span class="string">"hello world\n"</span>, <span class="number">12</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;					<span class="comment">/* child */</span></span><br><span class="line">		close(fd[<span class="number">1</span>]);</span><br><span class="line">		n = read(fd[<span class="number">0</span>], line, MAXLINE);</span><br><span class="line">		write(STDOUT_FILENO, line, n);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在上面的例子中，直接对管道描述符调用了<code>read</code>和<code>write</code>。更有趣的是将管道描述符复制到了标准输入或标准输出上。通常，子进程会在此之后执行另一个程序，该程序或者从标准输入(已创建的管道)读数据，或者将数据写至其标准输出(该管道)。</p>
<p>我们希望通过管道将输出直接送到分页程序。为此，先创建一个管道，<code>fork</code>一个子进程，使子进程的标准输入成为管道的读端，然后调用<code>exec</code>，执行用的分页程序。程序显示了如何实现这些操作。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	DEF_PAGER	<span class="meta-string">"/bin/more"</span>		<span class="comment">/* default pager program */</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span>		n;</span><br><span class="line">	<span class="keyword">int</span>		fd[<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">pid_t</span>	pid;</span><br><span class="line">	<span class="keyword">char</span>	*pager, *argv0;</span><br><span class="line">	<span class="keyword">char</span>	line[MAXLINE];</span><br><span class="line">	FILE	*fp;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">		err_quit(<span class="string">"usage: a.out &lt;pathname&gt;"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((fp = fopen(argv[<span class="number">1</span>], <span class="string">"r"</span>)) == <span class="literal">NULL</span>)</span><br><span class="line">		err_sys(<span class="string">"can't open %s"</span>, argv[<span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">if</span> (pipe(fd) &lt; <span class="number">0</span>)</span><br><span class="line">		err_sys(<span class="string">"pipe error"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		err_sys(<span class="string">"fork error"</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;								<span class="comment">/* parent */</span></span><br><span class="line">		close(fd[<span class="number">0</span>]);		<span class="comment">/* close read end */</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/* parent copies argv[1] to pipe */</span></span><br><span class="line">		<span class="keyword">while</span> (fgets(line, MAXLINE, fp) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			n = <span class="built_in">strlen</span>(line);</span><br><span class="line">			<span class="keyword">if</span> (write(fd[<span class="number">1</span>], line, n) != n)</span><br><span class="line">				err_sys(<span class="string">"write error to pipe"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (ferror(fp))</span><br><span class="line">			err_sys(<span class="string">"fgets error"</span>);</span><br><span class="line"></span><br><span class="line">		close(fd[<span class="number">1</span>]);	<span class="comment">/* close write end of pipe for reader */</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (waitpid(pid, <span class="literal">NULL</span>, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">			err_sys(<span class="string">"waitpid error"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;										<span class="comment">/* child */</span></span><br><span class="line">		close(fd[<span class="number">1</span>]);	<span class="comment">/* close write end */</span></span><br><span class="line">		<span class="keyword">if</span> (fd[<span class="number">0</span>] != STDIN_FILENO) &#123;</span><br><span class="line">			<span class="keyword">if</span> (dup2(fd[<span class="number">0</span>], STDIN_FILENO) != STDIN_FILENO)</span><br><span class="line">				err_sys(<span class="string">"dup2 error to stdin"</span>);</span><br><span class="line">			close(fd[<span class="number">0</span>]);	<span class="comment">/* don't need this after dup2 */</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* get arguments for execl() */</span></span><br><span class="line">		<span class="keyword">if</span> ((pager = getenv(<span class="string">"PAGER"</span>)) == <span class="literal">NULL</span>)</span><br><span class="line">			pager = DEF_PAGER;</span><br><span class="line">		<span class="keyword">if</span> ((argv0 = <span class="built_in">strrchr</span>(pager, <span class="string">'/'</span>)) != <span class="literal">NULL</span>)</span><br><span class="line">			argv0++;		<span class="comment">/* step past rightmost slash */</span></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			argv0 = pager;	<span class="comment">/* no slash in pager */</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (execl(pager, argv0, (<span class="keyword">char</span> *)<span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">			err_sys(<span class="string">"execl error for %s"</span>, pager);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在调用<code>fork</code>之前，先创建一个管道。调用<code>fork</code>之后，父进程关闭其读端，子进程关闭其写端。然后子进程调用<code>dup2</code>，使其标准输。入成为管道的读端。当执行分页程序时，其标准输入将是管道的读端。</p>
<p>将一个描述符复制到另一个上(在子进程中，<code>fd[0]</code>复制到标准输入)，在复制之前应当比较该描述符的值是否已经具有所希望的值。如果该描述符已经具有所希望的值，并且调用了<code>dup2</code>和<code>close</code>，那么该描述符的副本将关闭。</p>
<p>在本程序中，如果shell没有打开标准输入，那么程序开始处的<code>fopen</code>应已使用描述符0。也就是最小未使用的描述符，所以<code>fd[0]</code>决不会等于标准输入。尽管如此，无论何时调用<code>dup2</code>和<code>close</code>将一个描述符复制到另一个上，作为一种保护性的编程措施，都要先将两个描述符进行比较。</p>
<h2 id="函数popen和pclose"><a href="#函数popen和pclose" class="headerlink" title="函数popen和pclose"></a>函数popen和pclose</h2><p>常见的操作是创建一个连接到另一个进程的管道，然后读其输出或向其输入端发送数据，为此，标准I/O库提供了两个函数<code>popen</code>和<code>pclose</code>。这两个函数实现的操作是：创建一个管道，<code>fork</code>一个子进程，关闭未使用的管道端，执行一个shell运行命令，然后等待命令终止。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function">FILE *<span class="title">popen</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *cmdstring, <span class="keyword">const</span> <span class="keyword">char</span> *type)</span></span>;</span><br><span class="line"><span class="comment">// 返回值，若成功，返回文件指针；若出错，返回NULL</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pclose</span><span class="params">(FILE *fp)</span></span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回cmdetring的终止状态；若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>函数<code>popen</code>先执行<code>fork</code>，然后调用<code>exec</code>执行<code>cmdstring</code>，并且返回一个标准I/O文件指针。如果type是”r”，则文件指针连接到cmdstring的标准输出。如果ype是”w”，则文件指针连接到cmdstring的标准输入。</p>
<p>有一种方法可以帮助我们记住<code>popen</code>的最后一个参数及其作用，这就是与<code>fopen</code>进行类比。如果type是”r”，则返回的文件指针是可读的，如果type是”w”，则是可写的。</p>
<p><code>pclose</code>函数关闭标准I/O流，等待命令终止，然后返回shell的终止状态。如果shell不能被执行，则<code>pclose</code>返回的终止状态与shell已执行exit(127)一样，<code>cmdstring</code>由Bourne shell以下列方式执行：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh -c cmdstring</span><br></pre></td></tr></table></figure></p>
<p>这表示shell将扩展<code>cmdstring</code>中的任何特殊字符。例如，可以使用：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fp = popen(<span class="string">"ls *.c"</span>, <span class="string">"r"</span>);</span><br></pre></td></tr></table></figure></p>
<p>或者<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fp = popen(<span class="string">"cmd 2&gt;&amp;1"</span>, <span class="string">"r"</span>);</span><br></pre></td></tr></table></figure></p>
<p>程序是我们编写的<code>popen</code>和<code>pclose</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Pointer to array allocated at run-time.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">pid_t</span>	*childpid = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * From our open_max(), &#123;Prog openmax&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span>		maxfd;</span><br><span class="line"></span><br><span class="line">FILE *</span><br><span class="line">popen(<span class="keyword">const</span> <span class="keyword">char</span> *cmdstring, <span class="keyword">const</span> <span class="keyword">char</span> *type)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span>		i;</span><br><span class="line">	<span class="keyword">int</span>		pfd[<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">pid_t</span>	pid;</span><br><span class="line">	FILE	*fp;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* only allow "r" or "w" */</span></span><br><span class="line">	<span class="keyword">if</span> ((type[<span class="number">0</span>] != <span class="string">'r'</span> &amp;&amp; type[<span class="number">0</span>] != <span class="string">'w'</span>) || type[<span class="number">1</span>] != <span class="number">0</span>) &#123;</span><br><span class="line">		errno = EINVAL;</span><br><span class="line">		<span class="keyword">return</span>(<span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (childpid == <span class="literal">NULL</span>) &#123;		<span class="comment">/* first time through */</span></span><br><span class="line">		<span class="comment">/* allocate zeroed out array for child pids */</span></span><br><span class="line">		maxfd = open_max();</span><br><span class="line">		<span class="keyword">if</span> ((childpid = <span class="built_in">calloc</span>(maxfd, <span class="keyword">sizeof</span>(<span class="keyword">pid_t</span>))) == <span class="literal">NULL</span>)</span><br><span class="line">			<span class="keyword">return</span>(<span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pipe(pfd) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span>(<span class="literal">NULL</span>);	<span class="comment">/* errno set by pipe() */</span></span><br><span class="line">	<span class="keyword">if</span> (pfd[<span class="number">0</span>] &gt;= maxfd || pfd[<span class="number">1</span>] &gt;= maxfd) &#123;</span><br><span class="line">		close(pfd[<span class="number">0</span>]);</span><br><span class="line">		close(pfd[<span class="number">1</span>]);</span><br><span class="line">		errno = EMFILE;</span><br><span class="line">		<span class="keyword">return</span>(<span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>(<span class="literal">NULL</span>);	<span class="comment">/* errno set by fork() */</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;							<span class="comment">/* child */</span></span><br><span class="line">		<span class="keyword">if</span> (*type == <span class="string">'r'</span>) &#123;</span><br><span class="line">			close(pfd[<span class="number">0</span>]);</span><br><span class="line">			<span class="keyword">if</span> (pfd[<span class="number">1</span>] != STDOUT_FILENO) &#123;</span><br><span class="line">				dup2(pfd[<span class="number">1</span>], STDOUT_FILENO);</span><br><span class="line">				close(pfd[<span class="number">1</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			close(pfd[<span class="number">1</span>]);</span><br><span class="line">			<span class="keyword">if</span> (pfd[<span class="number">0</span>] != STDIN_FILENO) &#123;</span><br><span class="line">				dup2(pfd[<span class="number">0</span>], STDIN_FILENO);</span><br><span class="line">				close(pfd[<span class="number">0</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* close all descriptors in childpid[] */</span></span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; maxfd; i++)</span><br><span class="line">			<span class="keyword">if</span> (childpid[i] &gt; <span class="number">0</span>)</span><br><span class="line">				close(i);</span><br><span class="line"></span><br><span class="line">		execl(<span class="string">"/bin/sh"</span>, <span class="string">"sh"</span>, <span class="string">"-c"</span>, cmdstring, (<span class="keyword">char</span> *)<span class="number">0</span>);</span><br><span class="line">		_exit(<span class="number">127</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* parent continues... */</span></span><br><span class="line">	<span class="keyword">if</span> (*type == <span class="string">'r'</span>) &#123;</span><br><span class="line">		close(pfd[<span class="number">1</span>]);</span><br><span class="line">		<span class="keyword">if</span> ((fp = fdopen(pfd[<span class="number">0</span>], type)) == <span class="literal">NULL</span>)</span><br><span class="line">			<span class="keyword">return</span>(<span class="literal">NULL</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		close(pfd[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">if</span> ((fp = fdopen(pfd[<span class="number">1</span>], type)) == <span class="literal">NULL</span>)</span><br><span class="line">			<span class="keyword">return</span>(<span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	childpid[fileno(fp)] = pid;	<span class="comment">/* remember child pid for this fd */</span></span><br><span class="line">	<span class="keyword">return</span>(fp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">pclose(FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span>		fd, stat;</span><br><span class="line">	<span class="keyword">pid_t</span>	pid;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (childpid == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		errno = EINVAL;</span><br><span class="line">		<span class="keyword">return</span>(<span class="number">-1</span>);		<span class="comment">/* popen() has never been called */</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fd = fileno(fp);</span><br><span class="line">	<span class="keyword">if</span> (fd &gt;= maxfd) &#123;</span><br><span class="line">		errno = EINVAL;</span><br><span class="line">		<span class="keyword">return</span>(<span class="number">-1</span>);		<span class="comment">/* invalid file descriptor */</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ((pid = childpid[fd]) == <span class="number">0</span>) &#123;</span><br><span class="line">		errno = EINVAL;</span><br><span class="line">		<span class="keyword">return</span>(<span class="number">-1</span>);		<span class="comment">/* fp wasn't opened by popen() */</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	childpid[fd] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (fclose(fp) == EOF)</span><br><span class="line">		<span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (waitpid(pid, &amp;stat, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">if</span> (errno != EINTR)</span><br><span class="line">			<span class="keyword">return</span>(<span class="number">-1</span>);	<span class="comment">/* error other than EINTR from waitpid() */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span>(stat);	<span class="comment">/* return child's termination status */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先，每次调用<code>popen</code>时，应当记住所创建的子进程的进程ID, 以及其文件描述符或<code>FILE</code>指针。我们选择在数组<code>childpid</code>中保存子进程ID，并用文件描述符作为其下标。于是，当以<code>FILE</code>指针作为参数调用<code>pclose</code>时，调用标准I/O函数<code>fileno</code>得到文件描述符，然后取得子进程ID，并用其作为参数调用<code>waitpid</code>。因为一个进程可能调用<code>popen</code>多次，所以在动态分配<code>childpid</code>数组时(第一次调用<code>popen</code>时)，其数组长度应当是最大文件描述符数，于是该数组中可以存放与最大文件描述符数相同的子进程ID数。</p>
<p>POSIX.1要求<code>popen</code>关闭那些以前调用<code>popen</code>打开的、现在仍然在子进程中打开着的I/O流。为此，在子进程中从头逐个检查childpid数组的各个元素，关闭仍旧打开着的描述符。若<code>pclose</code>的调用者已经为信号SIGCHLD设置了一个信号处理程序，则<code>pclose</code>中的<code>waitpid</code>调用将返回一个错误EINTR。因为允许调用者捕捉此信号，所以当<code>waitpid</code>被一个捕捉到的信号中断时，我们只是再次调用<code>waitpid</code>。</p>
<p>注意，如果应用程序调用<code>waitpid</code>，并且获得了<code>popen</code>创建的子进程的退出状态，那么我们会在应用程序调用<code>pclose</code>时调用<code>waitpid</code>，如果发现子进程已不再存在，将返回-1，将errno设置为ECHILD。</p>
<p>注意，<code>popen</code>决不应由设置用户ID或设置组ID程序调用。当它执行命令时，<code>popen</code>等同于：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execl(<span class="string">"/bin/sh"</span>, <span class="string">"sh"</span>, <span class="string">"-c"</span> command, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure></p>
<p>它在从调用者继承的环境中执行shell，并由shell解释执行command。一个恶意用户可以操控这种环境，使得shell能以设置ID文件模式所授予的提升了的权限以及非预期的方式执行命令。</p>
<p><code>popen</code>特别适用于执行简单的过滤器程序，它变换运行命令的输入成输出。当命令希望构造它自己的管道时，就是这种情形。</p>
<h2 id="协同进程"><a href="#协同进程" class="headerlink" title="协同进程"></a>协同进程</h2><p>UNIX系统过滤程序从标准输入读取数据，向标准输出写数据。几个过滤程序通常在shell管道中线性连接。当一个过滤程序既产生某个过滤程序的输入，又读取该过滤程序的输出时，它就变成了<strong>协同进程</strong>(coprocess)。</p>
<p>协同进程通常在shell的后台运行，其标准输入和标准输出通过管道连接到另一个程序。<code>popen</code>只提供连接到另一个进程的标准输入或标准输出的一个单向管道，而协同进程则有连接到另一个进程的两个单向管道：一个接到其标准输入，另一个则来自其标准输出。我们想将数据写到其标准输入，经其处理后，再从其标准输出读取数据。</p>
<h2 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO"></a>FIFO</h2><p>FIFO有时被称为命名管道。未命名的管道只能在两个相关的进程之间使用，而且这两个相关的进程还要有一个共同的创建了它们的祖先进程。但是，通过FIFO，不相关的进程也能交换数据。</p>
<p>通过<code>stat</code>结构的<code>st_mode</code>成员的编码可以知道文件是否是FIFO类型。可以用<code>S_ISFIFO</code>宏对此进行测试。创建FIFO类似于创建文件。确实，FIFO的路径名存在于文件系统中。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkfifo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkfifoat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line"><span class="comment">// 两个函数的返回值，若成功，返回0；若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p><code>mkfifo</code>函数中<code>mode</code>参数的规格说明与<code>open</code>函数中<code>mode</code>的相同。</p>
<p><code>mkfitoat</code>函数和<code>mkfifo</code>函数相似，但是<code>mkfifoat</code>函数可以被用来在<code>fd</code>文件描述符表示的目录相关的位置创建一个FIFO。像其他at函数一样，这里有3种情形：</p>
<ol>
<li>如果path参数指定的是绝对路径名，则后参数会被忽略掉，并且<code>mkfifoat</code>函数的行为和`mkfifo类似</li>
<li>如果path参数指定的是相对路径名，则细参数是一个打开目录的有效文件描述符，路径名和目录有关</li>
<li>如果path参数指定的是相对路径名，并且<code>fd</code>参数有一个特殊值<code>AT_FDCWD</code>，则路径名以当前目录开始，<code>mkfifoat</code>和<code>mkfifo</code>类似。</li>
</ol>
<p>当我们用<code>mkfifo</code>或者<code>mkfifoat</code>创建FIFO时，要用<code>open</code>来打开它。确实，正常的文件I/O函数(如<code>close</code>、<code>read</code>、<code>write</code>和<code>unlink</code>)都需要FIFO。</p>
<p>当open一个FIFO时，非阻塞标志(<code>O_NONBLOCK</code>)会产生下列影响。在一般情况下(没有指定<code>O_NONBLOCK</code>)，只读<code>open</code>要阻塞到某个其他进程为写而打开这个FIFO为止。类似地，只写open要阻塞到某个其他进程为读而打开它为止。如果指定了<code>O_NONBLOCK</code>，则只读open立即返回。但是，如果没有进程为读而打开一个FIFO，那么只写open将返回-1，并将errno设置成ENXIO。</p>
<p>类似于管道，若<code>write</code>一个尚无进程为读而打开的FIFO，则产生信号<code>SIGPIPE</code>。若某个FIFO的最后一个写进程关闭了该FIFO，则将为该FIPO的读进程产生一个文件结束标志。</p>
<p>一个给定的FIFO有多个写进程是常见的。这就意味着，如果不希望多个进程所写的数据交叉，则必须考虑原子写操作。和管道一样，常量PIPB. BUF说明了可被原子地写到FIFO的最大数据量。</p>
<p>FIFO有以下两种用途。</p>
<ol>
<li>shell命令使用FIFO将数据从一条管道传送到另一条时，无需创建中间临时文件。</li>
<li>客户进程-服务器进程应用程序中，FIFO用作汇聚点，在客户进程和服务器进程二者之间传递数据</li>
</ol>
<p>实例：用FIFO复制输出流<br>FIFO可用于复制一系列shell命令中的输出流。这就防止了将数据写向中间磁盘文件(类似于使用管道来避免中间磁盘文件)。但是不同的是管道只能用于两个进程之间的线性连接，而FIFO是有名字的，因此它可用于非线性连接。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkfifo fifo1</span><br><span class="line">prog3 &lt; fifo1 &amp;</span><br><span class="line">prog1 &lt; infile | tee fifo1 | prog2</span><br></pre></td></tr></table></figure></p>
<p>创建FIFO，然后在后台启动prog3，从FIFO读数据。然后启动prog1，用tee将其输出发送到FIFO和prog2。</p>
<p>FIFO的另一个用途是在客户进程和服务器进程之间传送数据。如果有一个服务器进程，它与很多客户进程有关，每个客户进程都可将其请求写到一个该服务器进程创建的众所周知的FIFO中。因为该FIFO有多个写进程，所以客户进程发送给服务器进程的请求的长度要小于<code>PIPE_BUF</code>字节。这样就能避免客户进程的多次写之间的交叉。</p>
<p>每个客户进程都在其请求中包含它的进程ID。然后服务器进程为每个客户进程创建一个FIFO，所使用的路径名是以客户进程的进程ID为基础的。虽然这种安排可以工作，但服务器进程不能判断一个客户进程是否崩溃终止，这就使得客户进程专用FIFO会遗留在文件系统中。另外，服务器进程还必须得捕捉SIGPIPE信号，因为客户进程在发送一个请求后有可能没有读取响应就终止了，于是留下一个只有写进程(服务器进程)而无读进程的客户进程专用FIFO。</p>
<p>如果服务器进程以只读方式打开众所周知的FIFO (因为它只需读该FIFO)，则每当客户进程个数从1变成0时，服务器进程就将在FIFO中读到(read)一个文件结束标志为使服务器进程免于处理这种情况，一种常用的技巧是使服务器进程以读-写方式打开该众所周知的FIFO</p>
<h2 id="XSI-IPC"><a href="#XSI-IPC" class="headerlink" title="XSI IPC"></a>XSI IPC</h2><p>有3种称作XSI IPC的IPC：消息队列、信号量以及共享存储器。它们之间有很多相似之处。</p>
<h3 id="标识符和键"><a href="#标识符和键" class="headerlink" title="标识符和键"></a>标识符和键</h3><p>每个内核中的IPC结构(消息队列、信号量或共享存储段)都用一个非负整数的标识符(idemtifier)加以引用。当一个IPC结构被创建，然后又被删除时，与这种结构相关的标识符连续加1，直至达到一个整型数的最大正值，然后又回转到0。</p>
<p>标识符是IPC对象的内部名。为使多个合作进程能够在同一IPC对象上汇聚，需要提供一个外部命名方案。为此，每个IPC对象都与一个键(key)相关联。将这个键作为该对象的外部名。无论何时创建IPC结构(通过调用<code>msgget</code>、<code>semget</code>或<code>shmget</code>创建)，都应指定一个键。这个键的数据类型是基本系统数据类型<code>key_t</code>，通常在头文件<code>&lt;sys/types.h&gt;</code>中被定义为长整型。这个键由内核变换成标识符。</p>
<p>有多种方法使客户进程和服务器进程在同一IPC结构上汇聚</p>
<ol>
<li>服务器进程可以指定键<code>IPC_PRIVATE</code>创建一个新IPC结构，将返回的标识符存放在某处(如一个文件)以便客户进程取用。键<code>IPC_PRIVATE</code>保证服务器进程创建一个新IPC结构。缺点是需要读写文件。<code>IPC_PRIVATE</code>键也可用于父进程子关系。父进程指定<code>IPC_PRIVATE</code>创建一个新IPC结构，所返回的标识符可供fork后的子进程使用。接着，子进程又可将此标识符作为<code>exec</code>函数的一个参数传给一个新程序。</li>
<li>可以在一个公用头文件中定义一个客户进程和服务器进程都认可的键。然后服务器进程指定此键创建一个新的IPC结构。这种方法的问题是该键可能已与一个IPC结构相结合，在此情况下，<code>get</code>函数(<code>msgget</code>、<code>semget</code>或<code>shmget</code>)出错返回。服务器进程必须处理这一错误，删除已存在的IPC结构，然后试着再创建它。</li>
<li>客户进程和服务器进程认同一个路径名和项目ID，接着，调用函数<code>ftok</code>将这两个值变换为一个键。然后在方法(2)中使用此键。<code>ftok</code>提供的唯一服务就是由一个路径名和项目ID产生一个键。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="keyword">key_t</span> ftok(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">int</span> id);</span><br><span class="line"><span class="comment">// 返回值，若成功，返回键，若出错，返回(key_t)-1</span></span><br></pre></td></tr></table></figure>
<p><code>path</code>参数必须引用一个现有的文件。当产生键时，只使用过参数的低8位。<code>ftok</code>创建的键通常是用下列方式构成的：按给定的路径名取得其<code>stat</code>结构中的部分<code>st_dev</code>和<code>st_ino</code>字段， 然后再将它们与项目ID组合起来。如果两个路径名引用的是两个不同的文件，那么<code>ftok</code>通常会为这两个路径名返回不同的键。但是，因为i节点编号和键通常都存放在长整型中，所以创建健时可能会丢失信息。这意味着，对于不同文件的两个路径名。如果使用同一项目ID，那么可能产生相同的键。</p>
<p>3个get函数(<code>msgget</code>、<code>semget</code>和<code>shmget</code>)都有两个类似的参数：一个<code>key</code>和一个整型<code>flag</code>。在创建新的IPC结构(通常由服务器进程创建)时，如果<code>key</code>是<code>IPC_PRIVATE</code>或者和当前某种类型的IPC结构无关，则需要指明<code>flag</code>的<code>IPC_CREAT</code>标志位。为了引用一个现有队列(通常由客户进程创建)，<code>key</code>必须等于队列创建时指明的<code>key</code>的值，并且<code>IPC_CREAT</code>必须不被指明。注意，决不能指定<code>IPC_PRIVATE</code>作为键来引用一个现有队列，因为这个特殊的健值总是用于创建一个新队列。为了引用一个用<code>IPC_PRIVATE</code>键创建的现有队列，一定要知道这个相关的标识符，然后在其他IPC调用中(如<code>msgsnd</code>、<code>msgrev</code>)使用该标识符，这样可以绕过<code>get</code>函数。</p>
<p>如果希望创建一个新的IPC结构，而且要确保没有引用具有同一标识符的一个现有IPC结构，那么必须在<code>flag</code>中同时指定<code>IPC_CREAT</code>和<code>IPC_EXCL</code>位。这样做了以后，如果IPC结构已经存在就会造成出错，返回EEXIST(这与指定了<code>O_CREAT</code>和<code>O_EXCL</code>标志的<code>open</code>相类似)。</p>
<h3 id="权限结构"><a href="#权限结构" class="headerlink" title="权限结构"></a>权限结构</h3><p>XSI IPC为每一个IPC结构关联了一个<code>ipc_perm</code>结构。该结构规定了权限和所有者，它至少包括下列成员：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> &#123;</span></span><br><span class="line">	<span class="keyword">uid_t</span> uid; <span class="comment">/* owner's effective user id */</span></span><br><span class="line">	<span class="keyword">gid_t</span> gid; <span class="comment">/* owner's effective group id */</span></span><br><span class="line">	<span class="keyword">uid_t</span> cuid; <span class="comment">/* creator's effective user id */</span></span><br><span class="line">	<span class="keyword">gid_t</span> cgid; <span class="comment">/* creator's effective group id */</span></span><br><span class="line">	<span class="keyword">mode_t</span> mode; <span class="comment">/* access modes */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>mode</code>字段对于任何IPC结构都不存在执行权限。另外，消息队列和共享存储使用术语“读”和“写”，而信号量则用术语“读”和“更改”(alter)。</p>
<h3 id="结构限制"><a href="#结构限制" class="headerlink" title="结构限制"></a>结构限制</h3><p>所有3种形式的XSIIPC都有内置限制。大多数限制可以通过重新配置内核来改变。在对这3种形式的IPC中的每一种进行描述时，我们都会指出它的限制。</p>
<h3 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h3><p>XSI IPC的一个基本问题是：IPC结构是在系统范围内起作用的，没有引用计数。例如，如果进程创建了一个消息队列，并且在该队列中放入了几则消息，然后终止，那么该消息队列及其内容不会被删除。它们会一直留在系统中直至发生下列动作为止：由某个进程调用<code>msgrcv</code>或<code>msgctl</code>读消息或删除消息队列：成某个进程执行<code>ipcrm(1)</code>命令删除消息队列：或正在自举的系统删除消息队列。将此与管道相比，当最后一个引用管道的进程终止时，管道就被完全地删除了。对于FIFO面言，在最后一个引用FIFO的进程终止时，虽然FIFO的名字仍保留在系统中，直至被显式地删除，但是留在PIPO中的数据已被删除了。</p>
<p>XSI IPC的另一个问题是：这些IPC结构在文件系统中没有名字。不能用<code>ls</code>命令查看IPC对象，不能用<code>rm</code>命令删除它们，也不能用<code>chmod</code>命令修改它们的访问权限。于是，又增加了两个新命令<code>ipcs(1)</code>和<code>ipcrm(1)</code>。</p>
<p>表中对这些不同形式IPC的某些特征进行了比较。</p>
<table>
<thead>
<tr>
<th>IPC类型</th>
<th>无连接?</th>
<th>可靠的?</th>
<th>流控制?</th>
<th>记录?</th>
<th>消息类型或优先级?</th>
</tr>
</thead>
<tbody>
<tr>
<td>消息队列</td>
<td>否</td>
<td>是</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>STREAMS</td>
<td>否</td>
<td>是</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>UNIX域流套接字</td>
<td>否</td>
<td>是</td>
<td>是</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>UNIX域数据报套接字</td>
<td>是</td>
<td>是</td>
<td>否</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>FIFO(非STREAMS)</td>
<td>否</td>
<td>是</td>
<td>是</td>
<td>否</td>
<td>否</td>
</tr>
</tbody>
</table>
<p>“无连接”指的是无需先调用某种形式的打开函数就能发送消息的能力。如前所述，因为需要有某种技术来获得队列标识符，所以我们并不认为消息队列是无连接的。因为所有这些形式的IPC被限制在一台主机上，所以它们都是可靠的。当消息通过网络传送时，就要考虑丢失消息的可能性。“流控制”的意思是如果系统资源(缓冲区)短缺，或者如果接收进程不能再接收更多消息，则发送进程就要休眠。当流控制条件消失时，发送进程应自动唤醒。</p>
<p>图中没有显示的一个特征是：IPC设施能否自动地为每个客户进程创建一个到服务器进程的唯一连接。</p>
<h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>消息队列是消息的链接表，存储在内核中，由消息队列标识符标识。在本节中，我们把消息队列简称为队列，其标识符简称为队列ID。</p>
<p><code>msgget</code>用于创建一个新队列或打开一个现有队列。<code>msgsnd</code>将新消息添加到队列尾缩。每个消息包含一个正的长整型类型的字段、一个非负的长度以及实际数据字节数(对应于长度)，所有这些都在将消息添加到队列时，传送给<code>msgsnd</code>、<code>msgrev</code>用于从队列中取消息。我们并不一定要以先进先出次序取消息。也可以按消息的类型字段取消息。</p>
<p>每个队列都有一个<code>msqid_ds</code>结构与其相关联：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msqid_ds</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span>  <span class="title">msg_perm</span>;</span>  </span><br><span class="line">	<span class="keyword">msgqnum_t</span>        msg_qnum;    <span class="comment">/* # of nessages on queue */</span></span><br><span class="line">	<span class="keyword">msglen_t</span>         msg_qbytes;  <span class="comment">/* max # of bytes on queue */</span></span><br><span class="line">	<span class="keyword">pid_t</span>            msg_lspid;   <span class="comment">/* pid of last msgsnd() */</span></span><br><span class="line">	<span class="keyword">pid_t</span>            msg_lrpid;   <span class="comment">/* pid of last magrev() */</span></span><br><span class="line">	<span class="keyword">time_t</span>           msg_stime;   <span class="comment">/* last-msgsnd() time */</span></span><br><span class="line">	<span class="keyword">time_t</span>           msg_rtime;   <span class="comment">/* last-msgrev() time */</span></span><br><span class="line">	<span class="keyword">time_t</span>           msg_ctime;   <span class="comment">/* last-change time */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>调用的第一个函数通常是<code>msgget</code>，其功能是打开一个现有队列或创建一个新队列。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">int</span> flag)</span></span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回消息队列ID，若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>在创建新队列时，要初始化<code>msqid-ds</code>结构的下列成员。</p>
<ul>
<li><code>ipc-perm</code>结构中的<code>mode</code>成员按<code>flag</code>中的相应权限位设置。</li>
<li><code>msg_qnum</code>、<code>msg_lspid</code>、<code>msg_lrpid</code>、<code>msg_stime</code>和<code>msg_rtime</code>都设置为0。</li>
<li><code>msg_ctime</code>设置为当前时间。</li>
<li><code>msg_qbytes</code>设置为系统限制值。</li>
</ul>
<p>若执行成功，<code>msgget</code>返回非负队列ID。此后，该值就可被用于其他3个消息队列函数。<code>msgctl</code>函数对队列执行多种操作。它和另外两个与信号量及共享存储有关的函数(<code>semctl</code>和<code>shmctl</code>)都是XSI IPC的类似于<code>ioctl</code>的函数(亦即垃圾桶函数)。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">magctl</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">int</span> cmd, struct msqid_ds *buf)</span></span>;</span><br><span class="line"><span class="comment">// 返回值，若成功，返回0；若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p><code>cmd</code>参数指定对<code>msqid</code>指定的队列要执行的命令。</p>
<ul>
<li><code>IPC_STAT</code>取此队列的<code>msqid_ds</code>结构，并将它存放在buf指向的结构中。</li>
<li><code>IPC_SET</code>将字段<code>msg_perm.uid</code>、<code>msg_perm.gid</code>、<code>msg_perm.mode</code>和<code>msg_qbytes</code>从<code>buf</code>指向的结构复制到与这个队列相关的<code>msqid_ds</code>结构中。此命令只能由下列两种进程执行：<ul>
<li>一种是其有效用户ID等于<code>msg_perm.cuid</code>或<code>msg_perm.uid</code>，</li>
<li>另一种是具有超级用户特权的进程。只有超级用户才能增加<code>msg_qbytes</code>的值。</li>
</ul>
</li>
<li><code>IPC_RMID</code>从系统中删除该消息队列以及仍在该队列中的所有数据。这种删除立即生效。仍在使用这一消息队列的其他进程在它们下一次试图对此队列进行操作时，将得到EIDRM错误。此命令只能由下列两种进程执行：<ul>
<li>一种是其有效用户ID等于<code>msg_perm.cuid</code>或<code>msg_perm.uid</code>；</li>
<li>另一种是具有超级用户特权的进程。</li>
</ul>
</li>
</ul>
<p>调用<code>msgsnd</code>将数据放到消息队列中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgsnd</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">const</span> <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> nbytes, <span class="keyword">int</span> flag)</span></span>;</span><br><span class="line"><span class="comment">// 返回值，若成功，返回0；若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>正如前面提及的，每个消息都由3部分组成：</p>
<ul>
<li>一个正的长整型类型的字段；</li>
<li>一个非负的长度(nbytes)</li>
<li>实际数据字节数(对应于长度)。</li>
</ul>
<p>消息总是放在队列尾端。<code>ptr</code>参数指向一个长整型数，它包含了正的整型消息类型，其后紧接着的是消息数据(若<code>mbytes</code>是0，则无消息数据)。若发送的最长消息是512字节的，则可定义下列结构：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mymesg</span> &#123;</span></span><br><span class="line">	<span class="keyword">long</span> mtype;      <span class="comment">/* positive nessage type */</span></span><br><span class="line">	<span class="keyword">char</span> mtext[<span class="number">512</span>]; <span class="comment">/* nessage data, of length mbytes */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>ptr</code>就是一个指向<code>mymesg</code>结构的指针。接收者可以使用消息类型以非先进先出的次序取消息。</p>
<blockquote>
<p>某些平台既支持32位环境，又支持64位环境。这影响到长整型和指针的大小。64位应用程序的<code>mtype</code>字段的一部分可能会被32位应用程序视为<code>mtext</code>字段的组成部分，而32位应用程序的<code>mtext</code>字段的前4个字节会被64位应用程序解释为<code>mtype</code>字段的组成部分。</p>
</blockquote>
<p>参数<code>flag</code>的值可以指定为<code>IPC_NOWAIT</code>。这类似于文件I/O的非阻塞I/O标志。若消息队列已满(或者是队列中的消息总数等于系统限制值，或队列中的字节总数等于系统限制值)，则指定<code>IPC_NOWAIT</code>使得<code>msgsnd</code>立即出错返回EAGAIN。如果没有指定<code>IPC_NOWAIT</code>，则进程会一直阻塞到；有空间可以容纳要发送的消息；或者从系统中删除了此队列，或者捕捉到一个信号，并从信号处理程序返回。</p>
<p>注意，对删除消息队列的处理不是很完善。因为每个消息队列没有维护引用计数器，所以在队列被删除以后，仍在使用这一队列的进程在下次对队列进行操作时会出错返回。信号量机构也以同样方式处理其删除。相反，删除一个文件时，要等到使用该文件的最后一个进程关闭了它的文件描述符以后，才能删除文件中的内容。</p>
<p>当<code>msgsnd</code>返回成功时，消息队列相关的<code>msqid_ds</code>结构会随之更新，表明调用的进程ID(<code>msg_lspid</code>)、调用的时间(<code>msg_stime</code>)以及队列中新增的消息(<code>msg_qnum</code>)。</p>
<p><code>msgrcv</code>从队列中取用消息。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="keyword">saize_t</span> msgrev(<span class="keyword">int</span> msqid, <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> nbytes, <span class="keyword">long</span> type, <span class="keyword">int</span> flag);</span><br><span class="line"><span class="comment">// 返回值，若成功，返回消息数据部分的长度，若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>和<code>msgsnd</code>一样，<code>ptr</code>参数指向一个长整型数(其中存储的是返回的消息类型)，其后跟随的是存储实际消息数据的缓冲区。<code>nbyes</code>指定数据缓冲区的长度。若返回的清息长度大于<code>nbytes</code>，而且在<code>flag</code>中设置了<code>MSG_NOERROR</code>位，则该消息会被截断。如果没有设置这一标志，而消息又太长，则出错返回E2BIG。</p>
<p>参数<code>type</code>可以指定想要哪一种消息。</p>
<ul>
<li><code>type == 0</code>返回队列中的第一个消息，</li>
<li><code>type &gt; 0</code>返回队列中消息类型为<code>type</code>的第一个消息。</li>
<li><code>type &lt; 0</code>返回队列中消息类型值小于等于<code>type</code>绝对值的消息，如果这种消息有若干个，则取类型值最小的消息。</li>
</ul>
<p><code>type</code>值非0用于以非先进先出次序读消息。例如，若应用程序对消息赋予优先权，那么<code>type</code>就可以是优先权值。如果一个消息队列由多个客户进程和一个服务器进程使用，那么<code>type</code>字段可以用来包含客户进程的进程ID(只要进程ID可以存放在长整型中)。</p>
<p>可以将<code>flag</code>值指定为<code>IPC_NOWAIT</code>，使操作不阻塞，这样，如果没有所指定类型的消息可用，则<code>msgrcv</code>返回-1，error设置为ENOMSG。如果没有指定<code>IPC_NOWAIT</code>，则进程会一直阻塞到有了指定类型的消息可用，或者从系统中删除了此队列(返回-1，error设置为EIDRN)，或者捕捉到一个信号并从信号处理程序返回。</p>
<p><code>msgrev</code>成功执行时，内核会更新与该消息队列相关联的<code>msqid_ds</code>结构，以指示调用者的进程ID(<code>msg_lrpid</code>)和调用时间(<code>msg_rtime</code>), 并指示队列中的消息数减少了1个(<code>msg_qnum</code>)。</p>
<p>如若需要客户进程和服务器进程之间的双向数据流，可以使用消息队列或全双工管道。消息队列原来的实施目的是提供高于一般速度的IPC，但现在与其他形式的IPC相比，在速度方面已经没有什么差别了。</p>
<h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>信号量是一个计数器，用于为多个进程提供对共享数据对象的访问。</p>
<p>为了获得共享资源，进程需要执行下列操作。</p>
<ol>
<li>测试控制该资源的信号量。</li>
<li>若此信号量的值为正，则进程可以使用该资源。在这种情况下，进程会将信号量值减1，表示它使用了一个资源单位</li>
<li>否则，若此信号量的值为0。则进程进入休眼状态，直至信号量值大于0。进程被唤醒后，它返回至步骤(1)</li>
</ol>
<p>当进程不再使用由一个信号量控制的共享资源时，该信号量值增1。如果有进程正在休眠等待此信号量，则唤醒它们。为了正确地实现信号量，信号量值的测试及减1操作应当是原子操作。为此，信号最通常是在内核中实现的。</p>
<p>常用的信号量形式被称为二元信号量(binary semuphore)。它控制单个资源，其初始值为1。但是，一般而言，信号量的初值可以是任意一个正值，该值表明有多少个共享资源单位可供共享应用。遭憾的是，XSI信号量与此相比要复杂得多。以下3种特性造成了这种不必要的复杂性。</p>
<ol>
<li>信号量并非是单个非负值，而必需定义为含有一个或多个信号量值的集合。当创建信号量时，要指定集合中信号量值的数量</li>
<li>信号量的创建(semget)是独立于它的初始化(semct1)的。这是一个致命的缺点，因为不能原子地创建一个信号量集合，并且对该集合中的各个信号量值赋初值。</li>
<li>即使没有进程正在使用各种形式的XSIPC。它们仍然是存在的。有的程序在终止时并没有释放已经分配给它的信号量，所以我们不得不为这种程序担心。后面将要说明的undo功能就是处理这种情况的。</li>
</ol>
<p>内核为每个信号量集合维护着一个<code>semid_ds</code>结构：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> <span class="title">sem_perm</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span> sem_nsems; <span class="comment">/* # of semaphores in set */</span></span><br><span class="line">	<span class="keyword">time_t</span> sem_otimes <span class="comment">/* last-semop() time */</span></span><br><span class="line">	<span class="keyword">time_t</span> sem_ctime; <span class="comment">/* last-change time */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>每个信号量由一个无名结构表示，它至少包含下列成员：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span> semval;    <span class="comment">/* semaphore value, always &gt;= 0 */</span></span><br><span class="line">	<span class="keyword">pid_t</span> sempid;             <span class="comment">/* pid for last operation */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span> semncnt;   <span class="comment">/* # processes awaiting senval&gt;curval */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span> senzcnts   <span class="comment">/* # processes awaiting senval==0 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>当我们想使用XSI信号量时，首先需要通过调用函数<code>semget</code>来获得一个信号量ID。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semget</span> <span class="params">(<span class="keyword">key_t</span> kay, <span class="keyword">int</span> nsems, <span class="keyword">int</span> flag)</span></span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回信号量ID，若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>创建一个新集合时，要对<code>semid_ds</code>结构的下列成员赋初值。</p>
<ul>
<li>初始化<code>ipc_perm</code>结构。该结构中的<code>mode</code>成员被设置为<code>flag</code>中的相应权限位。</li>
<li><code>sem_otime</code>设置为0。</li>
<li><code>sem_ctime</code>设置为当前时间。</li>
<li><code>sem_nsems</code>设置为<code>nsems</code>。</li>
</ul>
<p><code>nsems</code>是该集合中的信号量数。如果是创建新集合，则必须指定<code>nsems</code>。如果是引用现有集合(一个客户进程)，则将<code>nsems</code>指定为0。</p>
<p><code>semctl</code>函数包含了多种信号量操作。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semctl</span><span class="params">(<span class="keyword">int</span> semid, <span class="keyword">int</span> semnum, <span class="keyword">int</span> cmd, ... <span class="comment">/* union semun arg */</span>)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>第4个参数是可选的，是否使用取决于所请求的命令，如果使用该参数，则其类型是<code>semun</code>，它是多个命令特定参数的联合(union):<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> semun &#123;</span><br><span class="line">	<span class="keyword">int</span> val;              <span class="comment">/* for SETVAL */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span> *<span class="title">buf</span>;</span> <span class="comment">/* for IPC_STAT and IPC_SET */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span> *<span class="built_in">array</span>;<span class="comment">/* for GETALL and SETALL */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意，这个选项参数是一个联合，而非指向联合的指针。</p>
<p><code>cmd</code>参数指定下列10种命令中的一种，这些命令是运行在<code>semid</code>指定的信号量集合上的。其中有5种命令是针对一个特定的信号量值的，它们用<code>semnum</code>指定该信号量集合中的一个成员。<code>semnum</code>值在0和nsems-1之间，包括0和nsems-1。</p>
<ul>
<li><code>IPC_STAT</code>对此集合取<code>semid_ds</code>结构，并存储在由<code>arg.buf</code>指向的结构中。</li>
<li><code>IPC_SET</code>按<code>arg.buf</code>指向的结构中的值，设置与此集合相关的结构中的<code>sem_perm.uid</code>、<code>sem_perm.gid</code>和<code>sem_perm.mode</code>字段。此命令只能由两种进程执行：<ul>
<li>一种是其有效用户ID等于<code>sem_perm.cuid</code>或<code>sem_perm.uid</code>的进程，</li>
<li>另一种是具有超级用户特权的进程</li>
</ul>
</li>
<li><code>IPC_RMID</code>从系统中删除该信号量集合。这种删除是立即发生的。删除时仍在使用此信号量集合的其他进程，在它们下次试图对此信号量集合进行操作时，将出错返回EIDRM。此命令只能由两种进程执行：<ul>
<li>一种是其有效用户ID等于<code>sem_perm.cuid</code>或<code>sem_perm.uid</code>的进程；</li>
<li>另一种是具有超级用户特权的进程。</li>
</ul>
</li>
<li><code>GETVAL</code>：返回成员<code>semnum</code>的<code>semval</code>值。</li>
<li><code>SETVAL</code>：设置成员<code>semnum</code>的<code>semval</code>值。该值由<code>arg.val</code>指定。</li>
<li><code>GETPID</code>：返回成员<code>semnum</code>的<code>sempid</code>值。</li>
<li><code>GETNCNT</code>：返回成员<code>semnum</code>的<code>semncnt</code>值。</li>
<li><code>GETZCNT</code>：返回成员<code>semnum</code>的<code>semzcnt</code>值。</li>
<li><code>GETALL</code>：取该集合中所有的信号量值。这些值存储在<code>arg.array</code>指向的数组中。</li>
<li><code>SETALL</code>：将该集合中所有的信号量值设置成<code>arg.array</code>指向的数组中的值。</li>
</ul>
<p>对于除<code>GETALL</code>以外的所有<code>GET</code>命令，<code>semctl</code>函数都返回相应值。对于其他命令，若成功则返回值为0，若出错，则设置errno井返回-1。</p>
<p>函数<code>semop</code>自动执行信号量集合上的操作数组。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semop</span><span class="params">(<span class="keyword">int</span> semid, struct sembuf semoparray[], <span class="keyword">size_t</span> nops)</span></span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回0；若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>参数<code>semoparray</code>是一个指针，它指向一个由<code>sembuf</code>结构表示的信号量操作数组：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span>  sem_num;  <span class="comment">/* menber # in set (0, 1, ..., nsems-1 */</span></span><br><span class="line">	<span class="keyword">short</span> sem_op;  <span class="comment">/* operation(negative, 0, or positive */</span>)</span><br><span class="line">	<span class="keyword">short</span> sem_flg; <span class="comment">/* IPC_NOWAIT, SEM_UNDO */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>参数<code>nops</code>规定该数组中操作的数量(元素数)。对集合中每个成员的操作由相应的<code>sem_op</code>值规定。此值可以是负值、0或正值。</p>
<ol>
<li>最易于处理的情况是<code>sem_op</code>为正值。这对应于进程释放的占用的资源数。<code>sem_op</code>值会加到信号量的值上。如果指定了<code>undo</code>标志，则也从该进程的此信号量调整值中减去<code>sem_op</code>。</li>
<li>若<code>sem_op</code>为负值，则表示要获取由该信号量控制的资源。</li>
</ol>
<p>如若该信号量的值大于等于<code>sem_op</code>的绝对值(具有所需的资源)，则从信号量值中减去<code>sem_op</code>的绝对值。这能保证信号量的结果值大于等于0。如果指定了<code>undo</code>标志，则<code>sem_op</code>的绝对值也加到该进程的此信号量调整值上。</p>
<p>如果信号量值小于<code>sem_op</code>的绝对值(资源不能满足要求)，则适用下列条件。</p>
<ol>
<li>若指定了<code>IPC_NOWAIT</code>，则<code>semop</code>出错返回EAGAIN。</li>
<li>若未指定<code>IPC_NOWAIT</code>，则该信号量的<code>semncnt</code>值加1(因为调用进程将进入休眠状态)，然后调用进程被挂起直至下列事件之一发生：<ol>
<li>此信号量值变成大于等于<code>sem_op</code>的绝对值(即某个进程已释放了某些资源)。此信号量的<code>semncnt</code>值减1(因为已结束等待)，并且从信号量值中减去<code>sem_op</code>的绝对值。如果指定了<code>undo</code>标志，则<code>sem_op</code>的绝对值也加到该进程的此信号量调整值上。</li>
<li>从系统中删除了此信号量。在这种情况下，函数出错返回EIDRM。</li>
<li>进程捕捉到一个信号，并从信号处理程序返同，在这种情况下，此信号量的<code>semncnt</code>值减1(因为调用进程不再等待)，并且函数出错返回EINTR。</li>
</ol>
</li>
<li>若<code>sem_op</code>为0，这表示调用进程希望等待到该信号量值变成0。<ol>
<li>如果信号量值当前是0，则此函数立即返回，</li>
<li>如果信号量值非0，则适用下列条件。<ol>
<li>若指定了<code>IPC_NOWAIT</code>，则出错返回EAGAIN。</li>
<li>若未指定<code>IPC_NOWAIT</code>，则该信号量的<code>semzcnt</code>值加1(因为调用进程将进入休眠状态)，然后调用进程被挂起，直至下列的一个事件发生。<ol>
<li>此信号量值变成0。此信号量的semzcnt值减1 (因为调用进程已结束等待)。</li>
<li>从系统中删除了此信号量。在这种情况下，函数出错返回BIDRM.</li>
<li>进程捕提到一个信号，并从信号处理程序返回，在这种情况下，此信号量的<code>semzcnt</code>值减1(因为调用进程不再等待)，并且函数出错返回BINTR。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<p><code>semop</code>函数具有原子性，它或者执行数组中的所有操作，或者一个也不做。</p>
<h3 id="exit时的信号量调整"><a href="#exit时的信号量调整" class="headerlink" title="exit时的信号量调整"></a>exit时的信号量调整</h3><p>如果在进程终止时，它占用了经由信号量分配的资源，那么就会成为一个问题。无论何时只要为信号量操作指定了<code>SEM_UNDO</code>标志，然后分配资源(sem_op值小于0)，那么内核就会记住对于该特定信号量，分配给调用进程多少资源(<code>sem_op</code>的绝对值)。当该进程终止时，不论自愿或者不自愿，内核都将检验该进程是否还有尚来处理的信号最调整值，如果有，则按调整值对相应信号量值进行处理。</p>
<p>如果用带<code>SETVAL</code>或<code>SETALL</code>命令的<code>semctl</code>设置一个信号量的值，则在所有进程中，该信号量的调整值都将设置为0。</p>
<p>若使用信号量，则先创建一个包含一个成员的信号量集合，然后将该信号量值初始化为1。为了分配资源，以<code>sem_op</code>为-1调用<code>semop</code>。为了释放资源，以<code>sem_op</code>为-1调用<code>semop</code>。对每个操作都指定<code>SEM_UNDO</code>，以处理在未释放资源条件下进程终止的情况。</p>
<p>若使用记录锁，则先创建一个空文件，并且用该文件的第一个字节(无需存在)作为锁字节。为了分配资源，先对该字节获得一个写锁。释放该资源时，则对该字节解锁。记录锁的性质确保了当一个锁的持有者进程终止时，内核会自动释放该锁。</p>
<p>若使用互斥量，需要所有的进程将相同的文件映射到它们的地址空间里，并且使用<code>PTHREAD_PROCESS_SHARED</code>互斥量属性在文件的相同偏移处初始化互斥量。为了分配资源，我们对互斥量加锁。为了释放锁，我们解锁互斥量。如果一个进程没有释放互斥量而终止，恢复将是非常困难的，除<br>非我们使用鲁棒互斥量。</p>
<h2 id="共享存储"><a href="#共享存储" class="headerlink" title="共享存储"></a>共享存储</h2><p>共享存储允许两个或多个进程共享一个给定的存储区。因为数据不需要在客户进程和服务器进程之间复制，所以这是最快的一种IPC。使用共享存储时要掌握的唯一窍门是，在多个进程之间同步访问一个给定的存储区。若服务器进程正在将数据放入共享存储区，则在它做完这一操作之前，客户进程不应当去取这些数据。通常，信号量用于同步共享存储访问。</p>
<p>我们已经看到了共享存储的一种形式，就是在多个进程将同一个文件映射到它们的地址空间的时候。XSI共享存储和内存映射的文件的不同之处在于，前者没有相关的文件。XSI共享存储段是内存的匿名段。</p>
<p>内核为每个共享存储段维护着一个结构，该结构至少要为每个共享存储段包含以下成员：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shmid_ds</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> <span class="title">shm_perm</span>;</span></span><br><span class="line">	<span class="keyword">size_t</span> shm_segsz;   <span class="comment">/* size of segment in bytes */</span></span><br><span class="line">	<span class="keyword">pid_t</span> shm_lpid; <span class="comment">/* pid of last shoop() */</span></span><br><span class="line">	<span class="keyword">pid_t</span> shm_cpid; <span class="comment">/* pid of creator */</span></span><br><span class="line">	<span class="keyword">shmatt_t</span> shm_nattch; <span class="comment">/* number of current attaches */</span></span><br><span class="line">	<span class="keyword">time_t</span> shm_atime; <span class="comment">/* last-attach time */</span></span><br><span class="line">	<span class="keyword">time_t</span> shm_dtime; <span class="comment">/* last-detach time */</span></span><br><span class="line">	<span class="keyword">time_t</span> shm_ctime; <span class="comment">/* last-change time */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>shmatt_t</code>类型定义为无符号整型。</p>
<p>调用的第一个函数通常是<code>shmget</code>，它获得一个共享存储标识符：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">size_t</span> size, <span class="keyword">int</span> flag)</span></span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回共享存储ID，若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>当创建一个新段时，初始化<code>shmid_ds</code>结构的下列成员。</p>
<ul>
<li><code>ipc_perm</code>结构中的<code>mode</code>按<code>flag</code>中的相应权限位设置</li>
<li><code>shm_lpid</code>、<code>shm_nattach</code>、<code>shm_atime</code>和<code>shm_dtime</code>都设置为0</li>
<li><code>shm_ctime</code>设置为当前时间</li>
<li><code>shm_segsz</code>设置为请求的size</li>
</ul>
<p>参数<code>size</code>是该共享存储段的长度，以字节为单位。实现通常将其向上取为系统页长的整倍数。但是，若应用指定的<code>size</code>值并非系统页长的整倍数，那么最后一页的余下部分是不可使用的。如果正在创建一个新段(通常在服务器进程中)，则必须指定其<code>size</code>。如果正在引用一个现存的段(一个客户进程)，则将<code>size</code>指定为0。当创建一个新段时，段内的内容初始化为0。</p>
<p><code>shmctl</code>函数对共享存储段执行多种操作：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmctl</span><span class="params">(<span class="keyword">int</span> shmid, <span class="keyword">int</span> cmd, struct shmid_ds *buf)</span></span>;</span><br><span class="line"><span class="comment">// 返回值，若成功，返回0；若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p><code>cmd</code>参数指定下列5种命令中的一种，使其在<code>shmid</code>指定的段上执行。</p>
<ul>
<li><code>IPC_STAT</code>取此段的<code>shmid_ds</code>结构，并将它存储在由<code>buf</code>指向的结构中。</li>
<li><code>IPC_SET</code>按<code>buf</code>指向的结构中的值设置与此共享存储段相关的<code>shmid_ds</code>结构中的下列3个字段：<code>shm_perm.uid</code>、<code>shm_perm.gid</code>和<code>shm_perm.mode</code>。此命令只能由下列两种进程执行，<ul>
<li>一种是其有效用户ID等于<code>shm_perm.cuid</code>或<code>shm_perm.uid</code>的进程；</li>
<li>另一种是具有超级用户特权的进程。</li>
</ul>
</li>
<li><code>IPC_RMID</code>从系统中剥除该共享存储段。因为每个共享存储段维护着一个连接计数(<code>shmid_ds</code>结构中的<code>shm_nattch</code>字段)，所以除非使用该段的最后一个进程终止或与该段分离，否则不会实际上删除该存储段。不管此段是否仍在使用，该段标识符都会被立即删除，所以不能再用<code>shmat</code>与该段连接。此命令只能由下列两种进程执行，<ul>
<li>一种是其有效用户ID等于<code>shm_perm.cuid</code>或<code>shm_perm.uid</code>的进程；</li>
<li>另一种是具有超级用户特权的进程。</li>
</ul>
</li>
</ul>
<p>Linux提供了另外两种命令。</p>
<ul>
<li><code>SHM_LOCK</code>在内存中对共享存储段加锁。此命令，只能由超级用户执行。</li>
<li><code>SHM_UNLOCK</code>解锁共享存储段。此命令只能由超级用户执行。</li>
</ul>
<p>一旦创建了一个共享存储段，进程就可调用<code>shmat</code>将其连接到它的地址空间中。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">shmat</span><span class="params">(<span class="keyword">int</span> shmid, <span class="keyword">const</span> <span class="keyword">void</span> *addr, <span class="keyword">int</span> flag)</span></span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回指向共享存储段的指针，若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>共享存储段连接到调用进程的哪个地址上与<code>addr</code>参数以及<code>flag</code>中是否指定<code>SRM_RND</code>位有关。</p>
<ul>
<li>如果<code>addr</code>为0，则此段连接到由内核选择的第一个可用地址上。这是推荐的使用方式。</li>
<li>如果<code>addr</code>非0，并且没有指定<code>SHM_RND</code>，则此段连接到<code>addr</code>所指定的地址上。</li>
<li>如果<code>addr</code>非0，并且指定了<code>SHM_RND</code>，则此段连接到(<code>addr - (addr mod SHMLBA)</code>)所表示的地址上。<code>SHM_RND</code>命令的意思是“取整”。<code>SHMLBA</code>的意思是“低边界地址倍数”，它总是2的乘方。该算式是将地址向下取最近1个<code>SHMLBA</code>的倍数。</li>
</ul>
<p>当对共享存储段的操作已经结束时，则调用<code>shmdt</code>与该段分离。注意，这并不从系统中删除其标识符以及其相关的数据结构。该标识符仍然存在，直至某个进程(一般是服务器进程)带<code>IPC_RMID</code>命令的调用<code>shmctl</code>特地删除它为止。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmdt</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *addr)</span></span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回0；若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p><code>addr</code>参数是以前调用<code>shmat</code>时的返回值。如果成功，<code>shmdt</code>将使相关<code>shmid_ds</code>结构中的<code>shm_nattch</code>计数器值减1。</p>
<p>内核将以地址0连接的共享存储段放在什么位置上与系统密切相关。程序打印一些特定系统存放各种类型的数据的位置信息。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	ARRAY_SIZE	40000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	MALLOC_SIZE	100000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	SHM_SIZE	100000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	SHM_MODE	0600	<span class="comment">/* user read/write */</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>	<span class="built_in">array</span>[ARRAY_SIZE];	<span class="comment">/* uninitialized data = bss */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span>		shmid;</span><br><span class="line">	<span class="keyword">char</span>	*ptr, *shmptr;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"array[] from %p to %p\n"</span>, (<span class="keyword">void</span> *)&amp;<span class="built_in">array</span>[<span class="number">0</span>],</span><br><span class="line">	  (<span class="keyword">void</span> *)&amp;<span class="built_in">array</span>[ARRAY_SIZE]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"stack around %p\n"</span>, (<span class="keyword">void</span> *)&amp;shmid);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((ptr = <span class="built_in">malloc</span>(MALLOC_SIZE)) == <span class="literal">NULL</span>)</span><br><span class="line">		err_sys(<span class="string">"malloc error"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"malloced from %p to %p\n"</span>, (<span class="keyword">void</span> *)ptr,</span><br><span class="line">	  (<span class="keyword">void</span> *)ptr+MALLOC_SIZE);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((shmid = shmget(IPC_PRIVATE, SHM_SIZE, SHM_MODE)) &lt; <span class="number">0</span>)</span><br><span class="line">		err_sys(<span class="string">"shmget error"</span>);</span><br><span class="line">	<span class="keyword">if</span> ((shmptr = shmat(shmid, <span class="number">0</span>, <span class="number">0</span>)) == (<span class="keyword">void</span> *)<span class="number">-1</span>)</span><br><span class="line">		err_sys(<span class="string">"shmat error"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"shared memory attached from %p to %p\n"</span>, (<span class="keyword">void</span> *)shmptr,</span><br><span class="line">	  (<span class="keyword">void</span> *)shmptr+SHM_SIZE);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (shmctl(shmid, IPC_RMID, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">		err_sys(<span class="string">"shmctl error"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在一个基于Intel的64位Linux系统上运行此程序，其输出如下：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out</span><br><span class="line">array[] from 0x6020c0 to Ox60bd00</span><br><span class="line">stack around Ox7ffr957b146c</span><br><span class="line">malloced fron 0x9e3010 to 0x9fb6b0</span><br><span class="line">shared nemory attached from 0x7fba578ab000 to 0x7fba578c36a0</span><br></pre></td></tr></table></figure></p>
<p>图显示了这种情况，注意，共享存储段紧靠在栈之下。<br><img src="/img/1622869817.jpg" alt></p>
<p>回忆一下mmap函数，它可将一个文件的若干部分映射至进程地址空间。这在概念上类似于用<code>shmat</code>连接一个共享存储段。两者之间的主要区别是，用<code>mmap</code>映射的存储段是与文件相关联的，而XSI共享存储段则并无这种关联。</p>
<p>在读设备<code>/dev/zero</code>时，该设备是0字节的无限资源。它也接收写向它的任何数据，但又忽略这些数据。我们对此设备作为IPC的兴趣在于，当对其进行存储映射时，它具有一些特殊性质。</p>
<ul>
<li>创建一个未命名的存储区，其长度是<code>mmap</code>的第二个参数，将其向上取整为系统的最近页长。</li>
<li>存储区都初始化为0。</li>
<li>如果多个进程的共同祖先进程对<code>mmap</code>指定了<code>MAP_SHARED</code>标志，则这些进程可共享此存储区。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	NLOOPS		1000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	SIZE		sizeof(long)	<span class="comment">/* size of shared memory area */</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">update(<span class="keyword">long</span> *ptr)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span>((*ptr)++);	<span class="comment">/* return value before increment */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span>		fd, i, counter;</span><br><span class="line">	<span class="keyword">pid_t</span>	pid;</span><br><span class="line">	<span class="keyword">void</span>	*area;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((fd = open(<span class="string">"/dev/zero"</span>, O_RDWR)) &lt; <span class="number">0</span>)</span><br><span class="line">		err_sys(<span class="string">"open error"</span>);</span><br><span class="line">	<span class="keyword">if</span> ((area = mmap(<span class="number">0</span>, SIZE, PROT_READ | PROT_WRITE, MAP_SHARED,</span><br><span class="line">	  fd, <span class="number">0</span>)) == MAP_FAILED)</span><br><span class="line">		err_sys(<span class="string">"mmap error"</span>);</span><br><span class="line">	close(fd);		<span class="comment">/* can close /dev/zero now that it's mapped */</span></span><br><span class="line"></span><br><span class="line">	TELL_WAIT();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		err_sys(<span class="string">"fork error"</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;			<span class="comment">/* parent */</span></span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NLOOPS; i += <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> ((counter = update((<span class="keyword">long</span> *)area)) != i)</span><br><span class="line">				err_quit(<span class="string">"parent: expected %d, got %d"</span>, i, counter);</span><br><span class="line"></span><br><span class="line">			TELL_CHILD(pid);</span><br><span class="line">			WAIT_CHILD();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;						<span class="comment">/* child */</span></span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; NLOOPS + <span class="number">1</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">			WAIT_PARENT();</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> ((counter = update((<span class="keyword">long</span> *)area)) != i)</span><br><span class="line">				err_quit(<span class="string">"child: expected %d, got %d"</span>, i, counter);</span><br><span class="line"></span><br><span class="line">			TELL_PARENT(getppid());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="POSIX信号量"><a href="#POSIX信号量" class="headerlink" title="POSIX信号量"></a>POSIX信号量</h2><p>POSIX信号量接口意在解决XSI信号量接口的儿个缺陷，</p>
<ul>
<li>相比于XSI接口。POSIX信号量接口考虑到了更高性能的实现</li>
<li>POSIX信号量接口使用更简单，没有信号量集，在熟悉的文件系统操作后一些接口被模式化了。尽管没有要求一定要在文件系统中实现，但是一些系统的确是这么实现的。</li>
<li>POSIX信号量在删除时表现更完美。使用POSIX信号量时，操作能继续正常工作直到该信号量的最后一次引用被释放。</li>
</ul>
<p>POSIX信号量有两种形式；命名的和未命名的。它们的差异在于创建和销毁的形式上，但其他工作一样。未命名信号量只存在于内存中，并要求能使用信号量的进程必须可以访问内存。这意味着它们只能应用在同一进程中的线程，或者不同进程中已经映射相同内存内容到它们的地址空间中的线程。相反，命名信号量可以通过名字访问，因此可以被任何已知它们名字的进程中的线程使用。</p>
<p>我们可以调用<code>sem_open</code>函数来创建一个新的命名信号量或者使用一个现有信号量。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="keyword">sem_t</span> *sem_open (<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">int</span> oflag, ...<span class="comment">/* mode_t mode, unsigned int value */</span> );</span><br><span class="line"><span class="comment">// 返回值，若成功，返回指向信号量的指针，若出错，返回SEM_FAILED</span></span><br></pre></td></tr></table></figure></p>
<p>当使用一个现有的命名信号量时，我们仅仅指定两个参数：信号量的名字和<code>oflag</code>参数的0值。当这个<code>oflag</code>参数有<code>O_CREAT</code>标志集时，如果命名信号量不存在，则创建一个新的。如果它已经存在，则会被使用，但是不会有额外的初始化发生。</p>
<p>当我们指定<code>O_CREAT</code>标志时，需要提供两个额外的参数。<code>mode</code>参数指定谁可以访问信号量。<code>mode</code>的取值和打开文件的权限位相同：用户读、用户写、用户执行、组读、组写、组执行、其他读、其他写和其他执行。赋值给信号量的权限可以被调用者的文件创建屏蔽字修改。注意，只有读和写访问要紧，但是当我们打开一个现有信号量时接口不允许指定模式。</p>
<p>在创建信号量时，<code>value</code>参数用来指定信号量的初始值。它的取值是0~<code>SEM_VALUE_MAX</code>。如果我们想确保创建的是信号量，可以设置<code>oflag</code>参数为<code>O_CREATIO_EXCL</code>。如果信号量已经存在，会导致<code>sem_open</code>失败。</p>
<p>为了增加可移植性，在选择信号量命名时必须遵循一定的规则。</p>
<ul>
<li>名字的第一个字符应该为斜杠(<code>/</code>)。</li>
<li>名字不应包含其他斜杠以此避免实现定义的行为。例如，如果文件系统被使用了，那么名字<code>/mysem</code>和<code>//mysem</code>会被认定为是同一个文件名，但是如果实现没有使用文件系统，那么这两种命名可以被认为是不同的</li>
<li>信号量名字的最大长度是实现定义的。名字不应该长于<code>_POSIX_NAME_MAX</code>个字符长度。因为这是使用文件系统的实现能允许的最大名字长度的限制。</li>
</ul>
<p>如果想在信号量上进行操作，<code>sem_open</code>函数会为我们返回一个信号量指针，用于传递到其他信号量函数上。当完成信号最操作时，可以调用<code>sem_close</code>函数来释放任何信号量相关的资源。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_close</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回0；若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>如果进程没有首先调用<code>sem_close</code>而退出，那么内核将自动关闭任何打开的信号量。注意，这不会影响信号量值的状态，如果已经对它进行了增1操作，这并不会仅因为退出而改变。类似地。如果调用<code>sem_close</code>，信号量值也不会受到影响。在XSI信号量中没有类似<code>SEM_UNDO</code>标志的机制。可以使用<code>sem_unlink</code>函数来销毁一个命名信号量。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_unlink</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回0；若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>sem_unlink函数删除信号量的名字。如果没有打开的信号量引用，则该信号量会被销毁。否则，销毁将延迟到最后一个打开的引用关闭。</p>
<p>不像XSI信号量，我们只能通过一个函数调用来调节POSIX信号量的值。计数减1和对一个二进制信号量加锁或者获取计数信号量的相关资源是相类似的。</p>
<p>注意，信号量和POSIX信号量之间是没有差别的。是采用二进制信号量还是用计数信号量取决于如何初始化和使用信号量。如果一个信号量只是有值0或者1，那么它就是二进制信号量。当二进制信号量是1时，它就是“解锁的”，如果它的值是0，那就是“加锁的”。</p>
<p>可以使用<code>sem_wait</code>或者<code>sem_trywait</code>函数来实现信号量的减1操作。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_trywait</span> <span class="params">(<span class="keyword">sem_t</span> *sem)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_wait</span> <span class="params">(<span class="keyword">sem_t</span> *sem)</span></span>;</span><br><span class="line"><span class="comment">// 两个函数的返回值：若成功，返回0；若出错则返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>使用<code>sem_wait</code>函数时，如果信号量计数是0就会发生阻塞。直到成功使信号量减1或者被信号中断时才返回。可以使用<code>sem_trywait</code>函数来避免阻塞。调用<code>sem_trywait</code>时，如果信号量是0，则不会阻塞，而是会返回-1并且将errno置为EAGAIN。</p>
<p>第三个选择是阻塞一段确定的时间。为此，可以使用<code>sem_timewait</code>函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sen_timedwait</span> <span class="params">(<span class="keyword">sem_t</span> *<span class="keyword">restrict</span> sem, <span class="keyword">const</span> struct timespec *<span class="keyword">restrict</span> tsptr)</span></span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回0；若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>想要放弃等待信号量的时候，可以用<code>tsptr</code>参数指定绝对时间。超时是基于<code>CLOCK_REALTIME</code>时钟的。如果信号量可以立即减1，那么超时值就不重要了，尽管指定的可能是过去的某个时间，信号量的减1操作依然会成功。如果超时到期并且信号量计数没能减1，<code>sem_timedwait</code>将返回-1且将errno设置为ETIMEDOUT。</p>
<p>可以调用<code>sem_post</code>函数使信号量值增1。这和解锁一个二进制信号量或者释放一个计数信号量相关的资源的过程是类似的。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_post</span> <span class="params">(<span class="keyword">sem_t</span> *sem)</span></span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回0；若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>调用<code>sem_post</code>时，如果在调用<code>sem_wait</code>(或者<code>sem_timedwait</code>)中发生进程阻塞，那么进程会被唤醒并且被<code>sem_post</code>增1的信号量计数会再次被<code>sem_wait</code>(或者<code>sem_timedwait</code>)减1。</p>
<p>当我们想在单个进程中使用POSIX信号量时，使用未命名信号量更容易。这仅仅改变创建和销毁信号量的方式。可以调用<code>sem_init</code>函数来创建一个未命名的信号量。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;senaphore.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_init</span> <span class="params">(<span class="keyword">sem_t</span> *sem, <span class="keyword">int</span> pshared, <span class="keyword">unsigned</span> <span class="keyword">int</span> value)</span></span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回0；若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p><code>pshared</code>参数表明是否在多个进程中使用信号量。如果是，将其设置成一个非0值。<code>value</code>参数指定了信号量的初始值。</p>
<p>需要声明一个<code>sem_t</code>类型的变量并把它的地址传递给<code>sem_init</code>来实现初始化，而不是像<code>sem_open</code>函数那样返回一个指向信号量的指针。如果要在两个进程之间使用信号量，需要确保<code>sem</code>参数指向两个进程之间共享的内存范围。</p>
<p>对未命名信号量的使用已经完成时，可以调用<code>sem_destroy</code>函数丢弃它。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_destroy</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span>;</span><br><span class="line"><span class="comment">// 返回值，若成功，返回0，若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>调用<code>sem_destroy</code>后，不能再使用任何带有<code>sem</code>的信号量函数，除非通过调用<code>sem_init</code>重新初始化它。</p>
<p><code>sem_getvalue</code>函数可以用来检索信号量值。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_getvalue</span> <span class="params">(<span class="keyword">sem_t</span> *<span class="keyword">restrict</span> sem, <span class="keyword">int</span> *<span class="keyword">restrict</span> valp)</span></span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回0；若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>成功后，<code>valp</code>指向的整数值将包含信号量值，试图要使用刚读出来的值时，信号量的值可能已经变了。除非使用额外的同步机制来避免这种竞争，否则<code>sem_getvalue</code>函数只能用于调试。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"slock.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">slock</span> *</span></span><br><span class="line"><span class="class"><span class="title">s_alloc</span>()</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">slock</span> *<span class="title">sp</span>;</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> cnt;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((sp = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct slock))) == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span>(<span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		<span class="built_in">snprintf</span>(sp-&gt;name, <span class="keyword">sizeof</span>(sp-&gt;name), <span class="string">"/%ld.%d"</span>, (<span class="keyword">long</span>)getpid(),</span><br><span class="line">		  cnt++);</span><br><span class="line">		sp-&gt;semp = sem_open(sp-&gt;name, O_CREAT|O_EXCL, S_IRWXU, <span class="number">1</span>);</span><br><span class="line">	&#125; <span class="keyword">while</span> ((sp-&gt;semp == SEM_FAILED) &amp;&amp; (errno == EEXIST));</span><br><span class="line">	<span class="keyword">if</span> (sp-&gt;semp == SEM_FAILED) &#123;</span><br><span class="line">		<span class="built_in">free</span>(sp);</span><br><span class="line">		<span class="keyword">return</span>(<span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	sem_unlink(sp-&gt;name);</span><br><span class="line">	<span class="keyword">return</span>(sp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">s_free(struct slock *sp)</span><br><span class="line">&#123;</span><br><span class="line">	sem_close(sp-&gt;semp);</span><br><span class="line">	<span class="built_in">free</span>(sp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">s_lock(struct slock *sp)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span>(sem_wait(sp-&gt;semp));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">s_trylock(struct slock *sp)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span>(sem_trywait(sp-&gt;semp));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">s_unlock(struct slock *sp)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span>(sem_post(sp-&gt;semp));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Linux/" rel="tag"># Linux</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/05/29/UNIX高级编程 笔记5/" rel="next" title="UNIX高级编程 笔记5">
                <i class="fa fa-chevron-left"></i> UNIX高级编程 笔记5
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/06/05/UNIX高级编程 笔记7/" rel="prev" title="UNIX高级编程 笔记7">
                UNIX高级编程 笔记7 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/header.jpg" alt="Hao Yu">
            
              <p class="site-author-name" itemprop="name">Hao Yu</p>
              <p class="site-description motion-element" itemprop="description">Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author</p>
          </div>
          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">303</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>
        	<audio controls="controls" loop="loop" preload="auto" src="/resource/xiaomeihao.mp3">
	        </audio>
	

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yuhao0102" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:yuh18@mails.tsinghua.edu.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#守护进程"><span class="nav-number">1.</span> <span class="nav-text">守护进程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#守护进程的特征"><span class="nav-number">1.1.</span> <span class="nav-text">守护进程的特征</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#编程规则"><span class="nav-number">1.2.</span> <span class="nav-text">编程规则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#出错记录"><span class="nav-number">1.3.</span> <span class="nav-text">出错记录</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#单实例守护进程"><span class="nav-number">1.4.</span> <span class="nav-text">单实例守护进程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#守护进程的惯例"><span class="nav-number">1.5.</span> <span class="nav-text">守护进程的惯例</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#高级I-O"><span class="nav-number">2.</span> <span class="nav-text">高级I/O</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#非阻塞I-O"><span class="nav-number">2.1.</span> <span class="nav-text">非阻塞I/O</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#记录锁"><span class="nav-number">2.2.</span> <span class="nav-text">记录锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#fcntl记录锁"><span class="nav-number">2.2.1.</span> <span class="nav-text">fcntl记录锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#锁的隐含继承和释放"><span class="nav-number">2.2.2.</span> <span class="nav-text">锁的隐含继承和释放</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FreeBSD实现"><span class="nav-number">2.2.3.</span> <span class="nav-text">FreeBSD实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在文件尾端加锁"><span class="nav-number">2.2.4.</span> <span class="nav-text">在文件尾端加锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#建议性锁和强制性锁"><span class="nav-number">2.2.5.</span> <span class="nav-text">建议性锁和强制性锁</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#I-O多路转接"><span class="nav-number">2.3.</span> <span class="nav-text">I/O多路转接</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#函数select和pselect"><span class="nav-number">2.3.1.</span> <span class="nav-text">函数select和pselect</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数poll"><span class="nav-number">2.3.2.</span> <span class="nav-text">函数poll</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#异步I-O"><span class="nav-number">2.4.</span> <span class="nav-text">异步I/O</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#System-V异步I-O"><span class="nav-number">2.4.1.</span> <span class="nav-text">System V异步I/O</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BSD异步I-O"><span class="nav-number">2.4.2.</span> <span class="nav-text">BSD异步I/O</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#POSIX异步I-O"><span class="nav-number">2.4.3.</span> <span class="nav-text">POSIX异步I/O</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数readv和writev"><span class="nav-number">2.5.</span> <span class="nav-text">函数readv和writev</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数readn和writen"><span class="nav-number">2.6.</span> <span class="nav-text">函数readn和writen</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#存储映射I-O"><span class="nav-number">2.7.</span> <span class="nav-text">存储映射I/O</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#进程间通信"><span class="nav-number">3.</span> <span class="nav-text">进程间通信</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#引言"><span class="nav-number">3.1.</span> <span class="nav-text">引言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#管道"><span class="nav-number">3.2.</span> <span class="nav-text">管道</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数popen和pclose"><span class="nav-number">3.3.</span> <span class="nav-text">函数popen和pclose</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#协同进程"><span class="nav-number">3.4.</span> <span class="nav-text">协同进程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#FIFO"><span class="nav-number">3.5.</span> <span class="nav-text">FIFO</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#XSI-IPC"><span class="nav-number">3.6.</span> <span class="nav-text">XSI IPC</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#标识符和键"><span class="nav-number">3.6.1.</span> <span class="nav-text">标识符和键</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#权限结构"><span class="nav-number">3.6.2.</span> <span class="nav-text">权限结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#结构限制"><span class="nav-number">3.6.3.</span> <span class="nav-text">结构限制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#优点和缺点"><span class="nav-number">3.6.4.</span> <span class="nav-text">优点和缺点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#消息队列"><span class="nav-number">3.7.</span> <span class="nav-text">消息队列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#信号量"><span class="nav-number">3.8.</span> <span class="nav-text">信号量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#exit时的信号量调整"><span class="nav-number">3.8.1.</span> <span class="nav-text">exit时的信号量调整</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#共享存储"><span class="nav-number">3.9.</span> <span class="nav-text">共享存储</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#POSIX信号量"><span class="nav-number">3.10.</span> <span class="nav-text">POSIX信号量</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>
  <div id="DvelopmentTarget">     
  </div>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart" aria-hidden="false"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>

  
</div>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_uv"> 
  本站访客数<span id="busuanzi_value_site_uv"></span>人次
</span>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  


  <script type="text/javascript" src="/js/src/love.js"></script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
