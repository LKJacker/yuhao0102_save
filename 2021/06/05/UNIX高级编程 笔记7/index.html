<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zn-ch">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-center-simple.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Linux,">










<meta name="description" content="网络IPC：套接字引言将描述套接字网络进程间通信接口，进程用该接口能够和其他进程通信，无论它们是在同一台计算机上还是在不同的计算机上。实际上，这正是套接字接口的设计目标之一：同样的接口既可以用于计算机间通信，也可以用于计算机内通信。 套接字描述符套接字是通信端点的抽象。正如使用文件描述符访问文件，应用程序用套接字描述符访问套接字。套接字描述符在UNIX系统中被当作是一种文件描述符。事实上，许多处理">
<meta name="keywords" content="Linux">
<meta property="og:type" content="article">
<meta property="og:title" content="UNIX高级编程 笔记7">
<meta property="og:url" content="http://yoursite.com/2021/06/05/UNIX高级编程 笔记7/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="网络IPC：套接字引言将描述套接字网络进程间通信接口，进程用该接口能够和其他进程通信，无论它们是在同一台计算机上还是在不同的计算机上。实际上，这正是套接字接口的设计目标之一：同样的接口既可以用于计算机间通信，也可以用于计算机内通信。 套接字描述符套接字是通信端点的抽象。正如使用文件描述符访问文件，应用程序用套接字描述符访问套接字。套接字描述符在UNIX系统中被当作是一种文件描述符。事实上，许多处理">
<meta property="og:locale" content="zn-ch">
<meta property="og:image" content="http://yoursite.com/img/1622943429.jpg">
<meta property="og:image" content="http://yoursite.com/img/1623034862.jpg">
<meta property="og:image" content="http://yoursite.com/img/1623067638.jpg">
<meta property="og:updated_time" content="2021-06-07T12:34:10.217Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="UNIX高级编程 笔记7">
<meta name="twitter:description" content="网络IPC：套接字引言将描述套接字网络进程间通信接口，进程用该接口能够和其他进程通信，无论它们是在同一台计算机上还是在不同的计算机上。实际上，这正是套接字接口的设计目标之一：同样的接口既可以用于计算机间通信，也可以用于计算机内通信。 套接字描述符套接字是通信端点的抽象。正如使用文件描述符访问文件，应用程序用套接字描述符访问套接字。套接字描述符在UNIX系统中被当作是一种文件描述符。事实上，许多处理">
<meta name="twitter:image" content="http://yoursite.com/img/1622943429.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2021/06/05/UNIX高级编程 笔记7/">





  <title>UNIX高级编程 笔记7 | Hao Yu's blog</title>
  








 
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zn-ch">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hao Yu's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">The program monkey was eaten by the siege lion.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/resume.pdf" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-mybetterhalf">
          <a href="/mybetterhalf/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>
            
            mybetterhalf
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/06/05/UNIX高级编程 笔记7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">UNIX高级编程 笔记7</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-06-05T16:20:00+08:00">
                2021-06-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="网络IPC：套接字"><a href="#网络IPC：套接字" class="headerlink" title="网络IPC：套接字"></a>网络IPC：套接字</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>将描述套接字网络进程间通信接口，进程用该接口能够和其他进程通信，无论它们是在同一台计算机上还是在不同的计算机上。实际上，这正是套接字接口的设计目标之一：同样的接口既可以用于计算机间通信，也可以用于计算机内通信。</p>
<h2 id="套接字描述符"><a href="#套接字描述符" class="headerlink" title="套接字描述符"></a>套接字描述符</h2><p>套接字是通信端点的抽象。正如使用文件描述符访问文件，应用程序用套接字描述符访问套接字。套接字描述符在UNIX系统中被当作是一种文件描述符。事实上，许多处理文件描述符的函数(如read和write)可以用于处理套接字描述符。为创建一个套接字，调用<code>socket</code>函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span> <span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br><span class="line"><span class="comment">// 返回值，若成功，返回文件(套接字)描述符。若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>参数<code>domain</code>(域)确定通信的特性，包括地址格式。图中总结了由POSIX.1指定的各个域。各个域都有自己表示地址的格式，而表示各个域的常数都以<code>AF_</code>开头，意指地址族(address family)。</p>
<p>大多数系统还定义了<code>AF_LOCAL</code>域，这是<code>AF_UNIX</code>的别名。<code>AF_UNSPEC</code>域可以代表“任何”域。</p>
<p>|域|描述|<br>|AF_INET|IPv4因特网域|<br>|AF_INET6|IPv6因特网域|<br>|AF_UNIX|UNIX域|<br>|AF_UPSPEC|未指定|</p>
<p>参数<code>type</code>确定套接字的类型，进一步确定通信特征。图中总结了由POSIX.1定义的套接字类型，但在实现中可以自由增加其他类型的支持</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>SOCK_DGRAM</td>
<td>固定长度的、无连接的、不可靠的报文传递</td>
</tr>
<tr>
<td>SOCK_RAW</td>
<td>IP协议的数据报接口</td>
</tr>
<tr>
<td>SOCK_SEQPACKET</td>
<td>固定长度的、有序的、可靠的、面向连接的报文传递</td>
</tr>
<tr>
<td>SOCK_STREAM</td>
<td>有序的、可靠的、双向的、面向连接的字节流</td>
</tr>
</tbody>
</table>
</div>
<p>参数<code>protocol</code>通常是0，表示为给定的域和套接字类型选择默认协议。当对同一域和套接字类型支持多个协议时，可以使用<code>protocol</code>选择一个特定协议。在<code>AF_INET</code>通信域中，套接字类型<code>SOCK_STREAM</code>的默认协议是传输控制协议(Transmission Control Protocol, TCP)。在<code>AF_INET</code>通信域中，套接字类型<code>SOCK_DGRAM</code>的默认协议是UDP。图列出了为因特网域套接字定义的协议。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>协议</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>IPPROTO_IP</td>
<td>IPv4网际协议</td>
</tr>
<tr>
<td>IPPROTO_IPV6</td>
<td>IPv6网际协议</td>
</tr>
<tr>
<td>IPPROTO_ICMP</td>
<td>因特网控制报文协议(Internet Cantrol Message Protacel)</td>
</tr>
<tr>
<td>IPPROTO_RAW</td>
<td>原始护数据包协议</td>
</tr>
<tr>
<td>IPPROTO_TCP</td>
<td>传输控制协议</td>
</tr>
<tr>
<td>IPPROTO_UDP</td>
<td>用户数据报协议(User Datagram Protocol)</td>
</tr>
</tbody>
</table>
</div>
<p>对于数据报(<code>SOCK_DGRAM</code>)接口，两个对等进程之间通信时不需要逻辑连接。只需要向对等进程所使用的套接字送出一个报文。</p>
<p>因此数据报提供了一个无连接的服务。另一方面，字节流(<code>SOCK_STREAM</code>)要求在交换数据之前，在本地套接字和通信的对等进程的套接字之间建立一个逻辑连接。数据报是自包含报文。发送数据报近似于给某人邮寄信件。你能邮寄很多信，但你不能保证传递的次序，并且可能有些信件会丢失在路上。每封信件包含接收者地址， 使这封信件独立于所有其他信件。每封信件可能送达不同的接收者。</p>
<p>相反，使用面向连接的协议通信就像与对方打电话。首先，需要通过电话建立一个连接，连接建立好之后，彼此能双向地通信。每个连接是端到端的通信链路。对话中不包含地址信息，就像呼叫两端存在一个点对点虚拟连接，并且连接本身暗示特定的源和目的地。</p>
<p><code>SOCK_STREAM</code>套接字提供字节流服务，所以应用程序分辨不出报文的界限。这意味着从<code>SOCK_STREAM</code>套接字读数据时，它也许不会返回所有由发送进程所写的字节数。最终可以获得发送过来的所有数据，但也许要通过若干次函数调用才能得到。</p>
<p><code>SOCK_SEQPACKET</code>套接字和<code>SOCK_STREAM</code>套接字很类似，只是从该套接字得到的是基于报文的服务而不是字节流服务。这意味着从<code>SOCK_SEQPACKET</code>套接字接收的数据量与对方所发送的一致。流控制传输协议(Stream Control Transmission Protocol, SCTP)提供了因特网域上的顺序数据包服务。</p>
<p><code>SOCK_RAM</code>套接字提供一个数据报接口，用于直接访问下面的网络层(即因特网域中的IP层)。使用这个接口时，应用程序负责构造自己的协议头部，这是因为传输协议(如TCP和UDP)被绕过了。当创建一个原始套接字时，需要有超级用户特权，这样可以防止恶意应用程序绕过内建安全机制来创建报文。</p>
<p>调用<code>socket</code>与调用<code>open</code>相类似。在两种情况下，均可获得用于I/O的文件描述符。当不再需要该文件描述符时，调用<code>close</code>来关闭对文件或套接字的访问，并且释放该描述符以便重新使用。虽然套接字描述符本质上是一个文件描述符，但不是所有参数为文件描述符的函数都可以接受套接字描述符。</p>
<p><img src="/img/1622943429.jpg" alt><br>未指定和由实现定义的行为通常意味着该函数对套接字描述符无效。例如，<code>lseek</code>不能以套接字横述符为参数，因为套接字不支持文件偏移量的概念。</p>
<p>套接字通信是双向的。可以采用<code>shutdown</code>函数来禁止一个套接字的I/O。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shutdown</span> <span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> how)</span></span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回0；若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>如果<code>how</code>是<code>SHUT_RD</code>(关闭读端)，那么无法从套接字读取数据。如果<code>how</code>是<code>SHUT_WR</code>(关闭写端)，那么无法使用套接字发送数据。如果<code>how</code>是<code>SHUT_RDWR</code>，则既无法读取数据，又无法发送数据。</p>
<p>为何使用shutdown呢?首先，只有最后一个活动引用关闭时，<code>close</code>才释放网络端点。这意味着如果复制一个套接字(如采用<code>dup</code>)，要直到关闭了最后一个引用它的文件描述符才会释放这个套接字。而<code>shutdown</code>允许使一个套接字处于不活动状态，和引用它的文件描述符数目无关。其次，有时可以很方便地关闭套接字双向传输中的一个方向。例如，如果想让所通信的进程能够确定数据传输何时结束，可以关闭该套接<br>字的写端，然而通过该套接字读端仍可以继续接收数据。</p>
<h2 id="寻址"><a href="#寻址" class="headerlink" title="寻址"></a>寻址</h2><h3 id="宇节序"><a href="#宇节序" class="headerlink" title="宇节序"></a>宇节序</h3><p>字节序是一个处理器架构特性，用于指示像整数这样的大数据类型内部的字节如何排序。网络协议指定了字节序，因此异构计算机系统能够交换协议信息而不会被字节序所混淆。TCP/IP协议栈使用大端字节序。应用程序交换格式化数据时，字节序问题就会出现。</p>
<p>对于TCP/IP应用程序，有4个用来在处理器字节序和网络字节序之间实施转换的函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="keyword">uint32_t</span> htonl (<span class="keyword">uint32_t</span> hostint32);</span><br><span class="line"><span class="comment">// 返回值；以网络字节序表示的32位整数</span></span><br><span class="line"><span class="keyword">uint16_t</span> htons(<span class="keyword">uint16_t</span> hostintl6);</span><br><span class="line"><span class="comment">// 返回值：以网络字节序表示的16位整数</span></span><br><span class="line"><span class="keyword">uint32_t</span> ntohl (<span class="keyword">uint32_t</span> netint32);</span><br><span class="line"><span class="comment">// 返回值；以主机字节序表示的32位整数</span></span><br><span class="line"><span class="keyword">uint16_t</span> ntohs(<span class="keyword">uint16_t</span> netint16);</span><br><span class="line"><span class="comment">// 返回值。以主机字节序表示的16位整数</span></span><br></pre></td></tr></table></figure></p>
<p><code>h</code>表示“主机”字节序，<code>n</code>表示“网络”字节序。<code>l</code>表示“长”(即4字节)整数，<code>s</code>表示“短”(即4字节)整数。虽然在使用这些函数时包含的是<code>&lt;arpa/inet.h&gt;</code>头文件，但系统实现经常是在其他头文件中声明这些函数的，只是这些头文件都包含在<code>&lt;arpa/inet.h&gt;</code>中。对于系统来说，把这些函数实现为宏也是很常见的。</p>
<h3 id="地址格式"><a href="#地址格式" class="headerlink" title="地址格式"></a>地址格式</h3><p>一个地址标识一个特定通信域的套接字端点，地址格式与这个特定的通信域相关。为使不同格式地址能够传入到套接字函数，地址会被强制转换成一个通用的地址结构<code>sockaddr</code>：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span> sa_family;  <span class="comment">/*address family */</span></span><br><span class="line">    <span class="keyword">char</span> sa_data[];   <span class="comment">/*variabie-length address */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>套接字实现可以自由地添加额外的成员并且定义<code>sa_data</code>成员的大小。</p>
<p>因特网地址定义在<code>&lt;netinet/in.h&gt;</code>头文件中。在IPv4因特网域(<code>AF_INET</code>)中，套接字地址用结构<code>sockaddr_in</code>表示：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_adds</span> &#123;</span></span><br><span class="line">    <span class="keyword">in_addr_t</span> s_addr;</span><br><span class="line">    <span class="comment">/* IPv4 address */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span> sin_family; <span class="comment">/* address family */</span></span><br><span class="line">    <span class="keyword">in_port_t</span> sin_port;     <span class="comment">/* port number */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span><span class="comment">/* IPv4 address */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>数据类型<code>in_port_t</code>定义成<code>uint16_t</code>。数据类型<code>in_addr_t</code>定义成<code>uint32_t</code>。这些整数类型在<code>&lt;stdint.h&gt;</code>中定义并指定了相应的位数。</p>
<p>与<code>AF_INET</code>域相比较，IPv6因特网域(<code>AF_INET6</code>)套接字地址用结构<code>sockaddr_in6</code>表示：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct_in6_addr &#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> s6_addr[<span class="number">16</span>]; <span class="comment">/* IPv6 address */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in6</span> &#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span> sin6_family;  <span class="comment">/* address family */</span></span><br><span class="line">    <span class="keyword">in_port_t</span> sin6_port;      <span class="comment">/* port number */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> sin6_flowinfo;   <span class="comment">/* trattic class and flow info */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> <span class="title">sin6_addr</span>;</span><span class="comment">/* IPv6 addreas*/</span></span><br><span class="line">    <span class="keyword">uint32_t</span> sin6_scope_id;   <span class="comment">/* set of interfaces for scope */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在Linux中，<code>sockaddr_in</code>定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span> sin_family;   <span class="comment">/* address family */</span></span><br><span class="line">    <span class="keyword">in_port_t</span>   sin_port;     <span class="comment">/* port number */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> <span class="title">sin6_add</span>;</span> <span class="comment">/* IPV4 address */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> sin_zero[<span class="number">8</span>];<span class="comment">/* filler */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>其中成员<code>sin_zero</code>为填充字段，应该全部被置为0。</p>
<p>注意，尽管<code>sockaddr_in</code>与<code>sockaddr_in6</code>结构相差比较大，但它们均被强制转换成<code>sockaddr</code>结构输入到套接字例程中。将会看到UNIX域套接字地址的结构与上述两个因特网域套接字地址格式的不同。</p>
<p>有时，需要打印出能被人理解而不是计算机所理解的地址格式。有两个新函数<code>inet_ntop</code>和<code>inet_pton</code>具有相似的功能，而且同时支持IPv4地址和IPv6地址。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">inet_ntop</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">const</span> <span class="keyword">void</span> *<span class="keyword">restrict</span> addit, <span class="keyword">char</span> *<span class="keyword">restrict</span> str, <span class="keyword">socklen_t</span> size)</span></span>;</span><br><span class="line"><span class="comment">// 返回值，若成功，返回地址字符串指针：若出错，返回NULL</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_pton</span><span class="params">(<span class="keyword">int</span> domain, conat <span class="keyword">char</span> * <span class="keyword">restrict</span> str, <span class="keyword">void</span> *<span class="keyword">restrict</span> addr)</span></span>;</span><br><span class="line"><span class="comment">// 返回值，若成功，返回1；若格式无效，返回0；若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>函数<code>inet_ntop</code>将网络字节序的二进制地址转换成文本字符串格式。<code>inet_pton</code>将文本字符串格式转换成网络字节序的二进制地址。参数<code>domain</code>仅支持两个值：<code>AF_INET</code>和<code>AF_INET6</code>。</p>
<p>对于<code>inet_ntop</code>，参数<code>size</code>指定了保存文本字符串的缓冲区(str)的大小。 两个常数用于简化工作：<code>INET_ADDRSTRLEN</code>定义了足够大的空间来存放一个表示IPv4地址的文本字符串；<code>INET6_ADDRSTRLEN</code>定义了足够大的空间来存放一个表示IPv6地址的文本字符串。对于<code>inet_pton</code>，如果<code>domain</code>是<code>AF_INET</code>，则缓冲区<code>addr</code>需要足够大的空间来存放一个32位地址；如果<code>domain</code>是<code>AF_INET6</code>，则需要足够大的空间来存放一个128位地址。</p>
<h3 id="地址查询"><a href="#地址查询" class="headerlink" title="地址查询"></a>地址查询</h3><p>理想情况下，应用程序不需要了解一个套接字地址的内部结构。如果一个程序简单地传递一个类似于<code>sockaddr</code>结构的套接字地址，并且不依赖于任何协议相关的特性，那么可以与提供相同类型服务的许多不同协议协作。</p>
<p>网络配置信息被存放在许多地方。这个信息可以存放在静态文件(如<code>/etc/hosts</code>和<code>/etc/services</code>)中，也可以由名字服务管理，如域名系统(Domain Name System，DNS)或者网络信息服务(Network Information Service，NIS)。无论这个信息放在何处，都可以用同样的函数访问它。</p>
<p>通过调用<code>gethostent</code>，可以找到给定计算机系统的主机信息。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="function">struct hostent *<span class="title">gethostent</span> <span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回指针，若出错，返回NULL</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sethostent</span><span class="params">(<span class="keyword">int</span> stayopen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">endhostent</span> <span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>如果主机数据库文件没有打开，<code>gethostent</code>会打开它。函数<code>gethostent</code>返回文件中的下一个条目。函数<code>sethostent</code>会打开文件，如果文件已经被打开，那么将其回绕。当<code>stayopen</code>参数设置成非0值时，调用<code>gethostent</code>之后，文件将依然是打开的。函数<code>endhostent</code>可以关闭文件。</p>
<p>当<code>gethostent</code>返回时，会得到一个指向<code>hostent</code>结构的指针，该结构可能包含一个静态的数据缓冲区，每次调用<code>gethostent</code>，缓冲区都会被覆盖。<code>hostent</code>结构至少包含以下成员：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hostent</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> *h_name;      <span class="comment">/* name of host */</span></span><br><span class="line">    <span class="keyword">char</span> **h_aliases;  <span class="comment">/* pointer to alternate host name array +/</span></span><br><span class="line"><span class="comment">    int h_addrtype;    /*address type */</span></span><br><span class="line">    <span class="keyword">int</span> h_length;      <span class="comment">/* length in bytes of address */</span></span><br><span class="line">    <span class="keyword">char</span> **h_addr_list;<span class="comment">/* pointer to array of network addresses */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>返回的地址采用网络字节序。</p>
<p>另外两个函数<code>gethostbyname</code>和<code>gethostbyaddr</code>，原来包含在<code>hostent</code>函数中，现在则被认为是过时的。</p>
<p>能够采用一套相似的接口来获得网络名字和网络编号，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="function">struct netent *<span class="title">getnetbyaddr</span> <span class="params">(<span class="keyword">uint32_t</span> net, <span class="keyword">int</span> type)</span></span>;</span><br><span class="line"><span class="function">struct netent *<span class="title">getnetbyname</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br><span class="line"><span class="function">struct netent *<span class="title">getnetent</span> <span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="comment">// 3个函数的返回值，若成功，返回指针；若出错，返回NULL</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setnetent</span> <span class="params">(<span class="keyword">int</span> stayopen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">endnetent</span> <span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p><code>netent</code>结构至少包含以下字段：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">netent</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span>   *n_name;   <span class="comment">/*network nane */</span></span><br><span class="line">    <span class="keyword">char</span> **n_aliases; <span class="comment">/* alternate network name array pointer */</span></span><br><span class="line">    <span class="keyword">int</span> n_addrtype;   <span class="comment">/*address type */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> n_net,   <span class="comment">/*network nunber */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>网络编号按照网络字节序返回。地址类型是地址族常量之一(如<code>AF_INET</code>)。我们可以用以下函数在协议名字和协议编号之间进行映射。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdib.h&gt;</span></span></span><br><span class="line"><span class="function">struct protoent *<span class="title">getprotobyname</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br><span class="line"><span class="function">struct protoent *<span class="title">getprotobynumber</span> <span class="params">(<span class="keyword">int</span> proto)</span></span>;</span><br><span class="line"><span class="function">struct protoent *<span class="title">getprotoent</span> <span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="comment">// 3个函数的返回值：若成功，返回指针，若出错，返回NULL</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setprotoent</span> <span class="params">(<span class="keyword">int</span> stayopen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">endprotoent</span> <span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>POSIX.1定义的<code>protoent</code>结构至少包含以下成员：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">protoent</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> *p_name;       <span class="comment">/* protocol name */</span></span><br><span class="line">    <span class="keyword">char</span> **p_aliases;   <span class="comment">/* pointer to alternane protocol name array */</span></span><br><span class="line">    <span class="keyword">int</span> p_proto;        <span class="comment">/* protocol number */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>服务是由地址的端口号部分表示的。每个服务由一个唯一的众所周知的端口号来支持。可以使用函数<code>getservbyname</code>将一个服务名映射到一个端口号，使用函数<code>getservbyport</code>将一个端口号映射到一个服务名，使用函数<code>getservent</code>顺序扫描服务数据库。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="function">struct servent *<span class="title">getservbyname</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> <span class="keyword">char</span> *proto)</span></span>;</span><br><span class="line"><span class="function">struct servent *<span class="title">getserbyport</span> <span class="params">(<span class="keyword">int</span> port, <span class="keyword">const</span> <span class="keyword">char</span> *proto)</span></span>;</span><br><span class="line"><span class="function">struct servent *<span class="title">getservent</span> <span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="comment">// 3个函数的返回值，若成功，返回指针，若出错，返图NULL</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setservent</span> <span class="params">(<span class="keyword">int</span> stayopen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">endservent</span> <span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p><code>servent</code>结构至少包含以下成员：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">servent</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> *s_name;      <span class="comment">/* service name */</span></span><br><span class="line">    <span class="keyword">char</span> **s_aliases;  <span class="comment">/* pointer to alternate service name array */</span></span><br><span class="line">    <span class="keyword">int</span> s_port;        <span class="comment">/* port nunber */</span></span><br><span class="line">    <span class="keyword">char</span> *s_proto;     <span class="comment">/* nane of protocol */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>POSIX.1定义了若干新的函数，允许一个应用程序将一个主机名和一个服务名映射到一个地址，或者反之。这些函数代替了较老的函数<code>gethostbyname</code>和<code>gethostbyaddr</code>。</p>
<p><code>getaddrinfo</code>函数允许将一个主机名和一个服务名映射到一个地址。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getaddrinfo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> host, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> service, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> struct addrinfo *<span class="keyword">restrict</span> hint, struct addrinfo **<span class="keyword">restrict</span> res)</span></span>;</span><br><span class="line"><span class="comment">// 返回值，若成功，返回0；若出错，返回非0错误码</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeaddrinfo</span><span class="params">(struct addrinfo *ai)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>需要提供主机名、服务名，或者两者都提供。如果仅仅提供一个名字，另外一个必须是一个空指针。主机名可以是一个节点名或点分格式的主机地址。<code>getaddrinfo</code>函数返回一个链表结构<code>addrinfo</code>。可以用<code>freeaddrinfo</code>来释放一个或多个这种结构，这取决于用<code>ai_next</code>字段链接起来的结构有多少。</p>
<p><code>addrinfo</code>结构的定义至少包含以下成员：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">addrinto</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span>              ai_flags;    <span class="comment">/* custonize behavior */</span></span><br><span class="line">    <span class="keyword">int</span>              ai_family;   <span class="comment">/* address fanily */</span></span><br><span class="line">    <span class="keyword">int</span>              ai_socktype; <span class="comment">/* socket type */</span></span><br><span class="line">    <span class="keyword">int</span>              ai_protocol; <span class="comment">/* protocol */</span></span><br><span class="line">    <span class="keyword">socklen_t</span>        ai_addrlen;  <span class="comment">/* length in bytes of address */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> *<span class="title">ai_addr</span>;</span>     <span class="comment">/* address */</span></span><br><span class="line">    <span class="keyword">char</span>            *ai_canonname;<span class="comment">/* canonical name of host */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> *<span class="title">ai_next</span>;</span>     <span class="comment">/* next in list */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>可以提供一个可选的<code>hint</code>来选择符合特定条件的地址。<code>hint</code>是一个用于过滤地址的模板，包括<code>ai_family</code>、<code>ai_flags</code>、<code>ai_protocol</code>和<code>ai_socktype</code>字段。剩余的整数字段必须设置为0，指针字段必须为空。图总结了<code>ai_flags</code>字段中的标志，可以用这些标志来自定义如何处理地址和名字。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>标志</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>AI_ADDRCONFIG</td>
<td>查询配置的地址类型(Pv4或IPv6)</td>
</tr>
<tr>
<td>AI_ALL</td>
<td>查找IPv4和IPv6地址(仅用于AI_V4MAPPED)</td>
</tr>
<tr>
<td>AI_CANONNAME</td>
<td>需要一个规范的名字(与别名相对)</td>
</tr>
<tr>
<td>AI_NUMERICHOST</td>
<td>以数字格式指定主机地址，不翻译</td>
</tr>
<tr>
<td>AL_NUMERICSERV</td>
<td>将服务指定为数字编口号，不翻译</td>
</tr>
<tr>
<td>AI_PASSIVE</td>
<td>套接字地址用于监听绑定</td>
</tr>
<tr>
<td>AI_V4NAPPED</td>
<td>如没有找到IPv6地址，返回映射到IPV6格式的IPv4地址</td>
</tr>
</tbody>
</table>
</div>
<p>如果<code>getaddrinfo</code>失败，不能使用<code>perror</code>或<code>strerror</code>来生成错误消息，而是要调用<code>gai_strerror</code>将返回的错误码转换成错误消息。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">gai_strerror</span> <span class="params">(<span class="keyword">int</span> emor)</span></span>;</span><br><span class="line"><span class="comment">// 返回值：指向描述错误的字符串的指针</span></span><br></pre></td></tr></table></figure></p>
<p><code>getnameinfo</code>函数将一个地址转换成一个主机名和一个服务名。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getnameinfo</span> <span class="params">(<span class="keyword">const</span> struct sockaddr *<span class="keyword">restrict</span> addr, <span class="keyword">socklen_t</span> alen,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">char</span> *<span class="keyword">restrict</span> host, <span class="keyword">socklen_t</span> hostlen,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">char</span> *reatrict service, <span class="keyword">socklen_t</span> servlen, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回0；若出错，返回非0值</span></span><br></pre></td></tr></table></figure></p>
<p>套接字地址(<code>addr</code>)被翻译成一个主机名和一个服务名。如果<code>host</code>非空，则指向一个长度为<code>hostlen</code>字节的缓冲区用于存放返回的主机名。同样，如果<code>service</code>非空，则指向一个长度为<code>servlen</code>字节的缓冲区用于存放返回的主机名。</p>
<p><code>flags</code>参数提供了一些控制翻译的方式。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>标志</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>NI_DGRAM</td>
<td>服务基于数据报而非基于流</td>
</tr>
<tr>
<td>NI_NAMEREQD</td>
<td>如果找不到主机名，将其作为一个错误</td>
</tr>
<tr>
<td>NI_NOFQDN</td>
<td>对于本地主机，仅返回全限定域名的节点名部分</td>
</tr>
<tr>
<td>NI_NUMERICHOST</td>
<td>返回主机地址的数字形式，非主机名</td>
</tr>
<tr>
<td>NI_NUMERICSCOPE</td>
<td>对于IPv6，返回范围ID的数字形式，而非名字</td>
</tr>
<tr>
<td>NI_NUMERICSERV</td>
<td>返回服务地址的数字形式(即端口号)，而非名字</td>
</tr>
</tbody>
</table>
</div>
<p><code>getaddrinfo</code>函数的使用方法。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(SOLARIS)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(BSD)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">print_family(struct addrinfo *aip)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">" family "</span>);</span><br><span class="line">	<span class="keyword">switch</span> (aip-&gt;ai_family) &#123;</span><br><span class="line">	<span class="keyword">case</span> AF_INET:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"inet"</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> AF_INET6:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"inet6"</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> AF_UNIX:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"unix"</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> AF_UNSPEC:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"unspecified"</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"unknown"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">print_type(struct addrinfo *aip)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">" type "</span>);</span><br><span class="line">	<span class="keyword">switch</span> (aip-&gt;ai_socktype) &#123;</span><br><span class="line">	<span class="keyword">case</span> SOCK_STREAM:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"stream"</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> SOCK_DGRAM:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"datagram"</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> SOCK_SEQPACKET:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"seqpacket"</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> SOCK_RAW:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"raw"</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"unknown (%d)"</span>, aip-&gt;ai_socktype);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">print_protocol(struct addrinfo *aip)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">" protocol "</span>);</span><br><span class="line">	<span class="keyword">switch</span> (aip-&gt;ai_protocol) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"default"</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> IPPROTO_TCP:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"TCP"</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> IPPROTO_UDP:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"UDP"</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> IPPROTO_RAW:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"raw"</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"unknown (%d)"</span>, aip-&gt;ai_protocol);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">print_flags(struct addrinfo *aip)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"flags"</span>);</span><br><span class="line">	<span class="keyword">if</span> (aip-&gt;ai_flags == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">" 0"</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (aip-&gt;ai_flags &amp; AI_PASSIVE)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">" passive"</span>);</span><br><span class="line">		<span class="keyword">if</span> (aip-&gt;ai_flags &amp; AI_CANONNAME)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">" canon"</span>);</span><br><span class="line">		<span class="keyword">if</span> (aip-&gt;ai_flags &amp; AI_NUMERICHOST)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">" numhost"</span>);</span><br><span class="line">		<span class="keyword">if</span> (aip-&gt;ai_flags &amp; AI_NUMERICSERV)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">" numserv"</span>);</span><br><span class="line">		<span class="keyword">if</span> (aip-&gt;ai_flags &amp; AI_V4MAPPED)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">" v4mapped"</span>);</span><br><span class="line">		<span class="keyword">if</span> (aip-&gt;ai_flags &amp; AI_ALL)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">" all"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span>		*<span class="title">ailist</span>, *<span class="title">aip</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span>		<span class="title">hint</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span>	*<span class="title">sinp</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> 			*addr;</span><br><span class="line">	<span class="keyword">int</span> 				err;</span><br><span class="line">	<span class="keyword">char</span> 				abuf[INET_ADDRSTRLEN];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">3</span>)</span><br><span class="line">		err_quit(<span class="string">"usage: %s nodename service"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">	hint.ai_flags = AI_CANONNAME;</span><br><span class="line">	hint.ai_family = <span class="number">0</span>;</span><br><span class="line">	hint.ai_socktype = <span class="number">0</span>;</span><br><span class="line">	hint.ai_protocol = <span class="number">0</span>;</span><br><span class="line">	hint.ai_addrlen = <span class="number">0</span>;</span><br><span class="line">	hint.ai_canonname = <span class="literal">NULL</span>;</span><br><span class="line">	hint.ai_addr = <span class="literal">NULL</span>;</span><br><span class="line">	hint.ai_next = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span> ((err = getaddrinfo(argv[<span class="number">1</span>], argv[<span class="number">2</span>], &amp;hint, &amp;ailist)) != <span class="number">0</span>)</span><br><span class="line">		err_quit(<span class="string">"getaddrinfo error: %s"</span>, gai_strerror(err));</span><br><span class="line">	<span class="keyword">for</span> (aip = ailist; aip != <span class="literal">NULL</span>; aip = aip-&gt;ai_next) &#123;</span><br><span class="line">		print_flags(aip);</span><br><span class="line">		print_family(aip);</span><br><span class="line">		print_type(aip);</span><br><span class="line">		print_protocol(aip);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n\thost %s"</span>, aip-&gt;ai_canonname?aip-&gt;ai_canonname:<span class="string">"-"</span>);</span><br><span class="line">		<span class="keyword">if</span> (aip-&gt;ai_family == AF_INET) &#123;</span><br><span class="line">			sinp = (struct sockaddr_in *)aip-&gt;ai_addr;</span><br><span class="line">			addr = inet_ntop(AF_INET, &amp;sinp-&gt;sin_addr, abuf,</span><br><span class="line">			    INET_ADDRSTRLEN);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">" address %s"</span>, addr?addr:<span class="string">"unknown"</span>);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">" port %d"</span>, ntohs(sinp-&gt;sin_port));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个程序说明了<code>getaddrinfo</code>函数的使用方法。如果有多个协议为指定的主机提供给定的服务，程序会打印出多条信息。如果想将输出限制在<code>AF_INET</code>协议族， 可以在提示中设置<code>ai_family</code>字段。在一个测试系统上运行这个程序时，得到了以下输出：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out harry nfs</span><br><span class="line">flags canon fanily inet <span class="built_in">type</span> stream protocol TCP</span><br><span class="line">hoat harry address 192.168.1.99 port 2049</span><br><span class="line">flags canon fanily inet <span class="built_in">type</span> dataqran protocol UDP</span><br><span class="line">host harry address 192.168.1.99 port 2049</span><br></pre></td></tr></table></figure></p>
<h3 id="将套接字与地址关联"><a href="#将套接字与地址关联" class="headerlink" title="将套接字与地址关联"></a>将套接字与地址关联</h3><p>将一个客户端的套接字关联。上一个地址没有多少新意，可以让系统选一个默认的地址。然而，对于服务器，需要给一个接收客户端请求的服务器套接字关联上一个众所周知的地址。客户端应有一种方法来发现连接服务器所需要的地址，最简单的方法就是服务器保留一个地址并且注册在<code>/etc/services</code>或者某个名字服务中。</p>
<p>使用<code>bind</code>函数来关联地址和套接字。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *addr, <span class="keyword">socklen_t</span> len)</span></span>;</span><br><span class="line"><span class="comment">// 返回值，若成功，返回0；若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>对于使用的地址有以下一些限制。</p>
<ul>
<li>在进程正在运行的计算机上，指定的地址必须有效；不能指定一个其他机器的地址。</li>
<li>地址必须和创建套接字时的地址族所支持的格式相匹配。</li>
<li>地址中的端口号必须不小于1024，除非该进程具有相应的特权(即超级用户)。</li>
<li>一般只能将一个套接字端点绑定到一个给定地址上，尽管有些协议允许多重绑定。</li>
</ul>
<p>对于因特网域，如果指定IP地址为<code>INADDR_ANY</code>(<code>&lt;netinet/in.h&gt;</code>中定义的)，套接字端点可以被绑定到所有的系统网络接口上。这意味着可以接收这个系统所安装的任何一个网卡的数据包。</p>
<p>可以调用<code>getsockname</code>函数来发现绑定到套接字上的地址：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsockname</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *<span class="keyword">restrict</span> addr,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">socklen_t</span> *<span class="keyword">restrict</span> alenp)</span></span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回0；若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>调用<code>getsockname</code>之前，将<code>alenp</code>设置为一个指向整数的指针，该整数指定缓冲区<code>sockaddr</code>的长度。返回时，整数会被设置成返同地址的大小。如果地址和提供的缓冲区长度不匹配，地址会被自动截断而不报错。如果当前没有地址绑定到该套接字，则其结果是未定义的。</p>
<p>如果套接字已经和对等方连接，可以调用<code>getpeername</code>函数来找到对方的地址。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getpeername</span> <span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *<span class="keyword">restrict</span> addr,</span></span></span><br><span class="line"><span class="function"><span class="params">   <span class="keyword">socklen_t</span> *<span class="keyword">restrict</span> alenp)</span></span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回0；若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>除了返回对等方的地址，函数<code>getpeername</code>和<code>getsockname</code>一样。</p>
<h2 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h2><p>如果要处理一个面向连接的网络服务(<code>SOCK_STREAM</code>或<code>SOCK_SEQPACKET</code>)，那么在开始交换数据以前，需要在请求服务的进程套接字(客户端)和提供服务的进程套接字(服务器)之间建立一个连接。使用<code>connect</code>函数来建立连接。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span> <span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *addr, <span class="keyword">socklen_t</span> len)</span></span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回0；若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>在<code>connect</code>中指定的地址是我们想与之通信的服务器地址。如果<code>sockfd</code>没有绑定到一个地址，<code>connect</code>会给调用者绑定一个默认地址。</p>
<p>如果一个服务器运行在一个负载很重的系统上，就很有可能发生错误。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSLEEP 128</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">connect_retry(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *addr, <span class="keyword">socklen_t</span> alen)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> numsec;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Try to connect with exponential backoff.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">for</span> (numsec = <span class="number">1</span>; numsec &lt;= MAXSLEEP; numsec &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (connect(sockfd, addr, alen) == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Connection accepted.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Delay before trying again.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (numsec &lt;= MAXSLEEP/<span class="number">2</span>)</span><br><span class="line">			sleep(numsec);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个函数展示了指数补偿(exponential backoff) 算法。如果调用<code>connect</code>失败，进程会休眠一小段时间，然后进入下次循环再次尝试，每次循环休眠时间会以指数级增加，直到最大延迟为2分钟左右。</p>
<p>如果<code>connect</code>失败，套接字的状态会变成未定义的。因此，如果<code>connect</code>失败，可迁移的应用程序需要关闭套接字。如果想重试，必须打开一个新的套接字。这种更易于迁移的技术如下所示。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSLEEP 128</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">connect_retry(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol,</span><br><span class="line">              <span class="keyword">const</span> struct sockaddr *addr, <span class="keyword">socklen_t</span> alen)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> numsec, fd;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Try to connect with exponential backoff.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">for</span> (numsec = <span class="number">1</span>; numsec &lt;= MAXSLEEP; numsec &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((fd = socket(domain, type, protocol)) &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">if</span> (connect(fd, addr, alen) == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Connection accepted.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">return</span>(fd);</span><br><span class="line">		&#125;</span><br><span class="line">		close(fd);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Delay before trying again.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (numsec &lt;= MAXSLEEP/<span class="number">2</span>)</span><br><span class="line">			sleep(numsec);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>需要注意的是，因为可能要建立一个新的套接字，给<code>connect_retry</code>函数传递一个套接字描述符参数是没有意义。我们现在返回一个已连接的套接字描述符给调用者，而并非返回一个表示调用成功的值</p>
<p>如果套接字描述符处于非阻塞模式，那么在连接不能马上建立时，<code>connect</code>将会返回-1并且将errno设置为特殊的错误码<code>EINPROGRESS</code>。应用程序可以使用<code>poll</code>或者<code>select</code>来判断文件描述符何时可写。如果可写，连接完成。<code>connect</code>函数还可以用于无违接的网络服务(<code>SOCK_DGRAM</code>)。这看起来有点矛盾，实际上却是一个不错的选择。如果用<code>SOCK_DGRAM</code>套接字调用<code>connect</code>，传送的报文的目标地址会设置成<code>connect</code>调用中所指定的地址，这样每次传送报文时就不需要再提供地址。另外，仅能接收来自指定地址的报文。</p>
<p>服务器调用<code>listen</code>函数来宣告它愿意接受连接请求。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回0；若出错，返回一</span></span><br></pre></td></tr></table></figure></p>
<p>参数<code>backlog</code>提供了一个提示，提示系统该进程所要入队的未完成连接请求数量。其实际值由系统决定，但上限由<code>&lt;sys/socket.h&gt;</code>中的<code>SOMAXCONN</code>指定。一旦队列满，系统就会拒绝多余的连接请求，所以<code>backlog</code>的值应该基于服务器期望负载和处理量来选择，其中处理量是指接受连接请求与启动服务的数量。一旦服务器调用了<code>listen</code>，所用的套接字就能接收连接请求。使用<code>accept</code>函数获得连接请求并建立连接。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span> <span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *<span class="keyword">restrict</span> addr,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">socklen_t</span> *<span class="keyword">restrict</span> len)</span></span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回文件(套接字)描述符；若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>函数<code>accept</code>所返回的文件描述符是套接字描述符，该描述符连接到调用<code>connect</code>的客户端。这个新的套接字描述符和原始套接字(<code>sockfd</code>)具有相同的套接字类型和地址族。传给<code>accept</code>的原始套接字没有关联到这个连接，而是继续保持可用状态并接收其他连接请求。</p>
<p>如果不关心客户端标识，可以将参数<code>addr</code>和<code>len</code>设为NULL。否则，在调用<code>accept</code>之前，将<code>addr</code>参数设为足够大的缓冲区来存放地址，并且将<code>len</code>指向的整数设为这个缓冲区的字节大小。返回时，<code>accept</code>会在缓冲区填充客户端的地址，并且更新指向<code>len</code>的整数来反映该地址的大小。</p>
<p>如果没有连接请求在等待，<code>accept</code>会阻塞直到一个请求到来。如果<code>sockfd</code>处于非阻塞模式，<code>accept</code>会返回-1，并将errno设置为EAGAIN或EWOULDBLOCK。</p>
<p>如果服务器调用<code>accept</code>，并且当前没有连接请求，服务器会阻塞直到一个请求到来。另外，服务器可以使用<code>poll</code>或<code>select</code>来等待一个请求的到来。在这种情况下，一个带有等待连接请求的套接字会以可读的方式出现。</p>
<p>函数可以用来分配和初始化套接字供服务器进程使用。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">initserver(<span class="keyword">int</span> type, <span class="keyword">const</span> struct sockaddr *addr, <span class="keyword">socklen_t</span> alen,</span><br><span class="line">  <span class="keyword">int</span> qlen)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> fd;</span><br><span class="line">	<span class="keyword">int</span> err = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((fd = socket(addr-&gt;sa_family, type, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">if</span> (bind(fd, addr, alen) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> errout;</span><br><span class="line">	<span class="keyword">if</span> (type == SOCK_STREAM || type == SOCK_SEQPACKET) &#123;</span><br><span class="line">		<span class="keyword">if</span> (listen(fd, qlen) &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">goto</span> errout;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>(fd);</span><br><span class="line"></span><br><span class="line">errout:</span><br><span class="line">	err = errno;</span><br><span class="line">	close(fd);</span><br><span class="line">	errno = err;</span><br><span class="line">	<span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h2><p>既然一个套接字端点表示为一个文件描述符，那么只要建立连接，就可以使用<code>read</code>和<code>write</code>来通过套接字通信。通过在<code>connect</code>函数里面设置默认对等地址，数据报套接字也可以被“连接”。在套接字描述符上使用<code>read</code>和<code>write</code>是非常有意义的，因为这意味着可以将套接字描述符传递给那些原先为处理本地文件而设计的函数。而且还可以安排将套接字描述符传递给予进程，而该子进程执行的程序并不了解套接字。</p>
<p>如果想指定选项，从多个客户端接收数据包，或者发送带外数据，就需要使用6个为数据传递而设计的套接字函数中的一个。3个函数用来发送数据，3个用于接收数据。首先，考查用于发送数据的函数。最简单的是<code>send</code>，它和<code>write</code>很像，但是可以指定标志来改变处理传输数据的方式。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="keyword">ssize_t</span> send(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes, <span class="keyword">int</span> flags);</span><br><span class="line"><span class="comment">// 返回值：若成功，返回发送的字节数：若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>类似<code>write</code>，使用<code>send</code>时套接字必须已经连接。参数<code>buf</code>和<code>nbytes</code>的含义与<code>write</code>中的一致。</p>
<p>然而，与<code>write</code>不同的是，<code>send</code>支持第4个参数<code>flags</code>。图总结了这些标志。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>标志</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>MSG_CONFIRM</td>
<td>提供链路层反馈以保持地址映射有效</td>
</tr>
<tr>
<td>MSG_DONTROUTE</td>
<td>勿将数据包路由出本地网络</td>
</tr>
<tr>
<td>MSG_DONTWAIT</td>
<td>允许非阻塞操作</td>
</tr>
<tr>
<td>MSG_EOF</td>
<td>发送数据后关闭套接字的发送端</td>
</tr>
<tr>
<td>MSG_EOR</td>
<td>如果协议支持，标记记录结束</td>
</tr>
<tr>
<td>MSG_MORE</td>
<td>延迟发送数据包允许写更多数据</td>
</tr>
<tr>
<td>MSG_NOSIGNAL</td>
<td>在写无连接的套接字时不产生SIGPIPE信号</td>
</tr>
<tr>
<td>MSG_OOB</td>
<td>如果协议支持，发送带外数据</td>
</tr>
</tbody>
</table>
</div>
<p>即使<code>send</code>成功返回，也并不表示连接的另一端的进程就一定接收了数据。我们所能保证的只是当<code>send</code>成功返回时，数据已经被无错误地发送到网络驱动程序上。对于支持报文边界的协议，如果尝试发送的单个报文的长度超过协议所支持的最大长度，那么<code>send</code>会失败，并将errno设为EMSGSIZE。对于字节流协议，<code>send</code>会阻塞直到整个数据传输完成。函数<code>sendto</code>和<code>send</code>很类似。区别在于<code>sendto</code>可以在无连锁的套接字上指定一个目标地址。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="keyword">ssize_t</span> sendto(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes, <span class="keyword">int</span> flags,</span><br><span class="line">    <span class="keyword">const</span> struct sockaddr *destaddr, <span class="keyword">socklen_t</span> destlen);</span><br><span class="line"><span class="comment">// 返回值：若成功，返回发送的字节数；若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>对于面向连接的套接字，目标地址是被忽略的，因为连接中隐含了目标地址。对于无连接的套接字，除非先调用<code>connect</code>设置了目标地址，否则不能使用<code>send</code>。<code>sendto</code>提供了发送报文的另一种方式。</p>
<p>通过套接字发送数据时，还有一个选择。可以调用带有<code>msghdr</code>结构的<code>sendmsg</code>来指定多重缓冲区传输数据，这和<code>writev</code>函数很相似<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="keyword">ssize_t</span> sendmsg(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct msghdr *mig, <span class="keyword">int</span> flags);</span><br><span class="line"><span class="comment">// 返回值：若成功，返回发送的字节数；若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>POSIX.1定义了<code>msghdr</code>结构，它至少有以下成员：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span>         *msg_name;      <span class="comment">/* optional address */</span></span><br><span class="line">    <span class="keyword">socklen_t</span>     msg_namelen;   <span class="comment">/* address oize in bytes */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> *<span class="title">msg_iov</span>;</span>       <span class="comment">/* array of I/O butters */</span></span><br><span class="line">    <span class="keyword">int</span>           msg_iovlen;    <span class="comment">/* number of elements in array */</span></span><br><span class="line">    <span class="keyword">void</span>         *msg_control;   <span class="comment">/* ancillary data */</span></span><br><span class="line">    <span class="keyword">socklen_t</span>     msg_eontrollen;<span class="comment">/* number of ancillary bytes */</span></span><br><span class="line">    <span class="keyword">int</span>           msg_flags;     <span class="comment">/* flags for received nessage */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>函数<code>recv</code>和<code>read</code>相似，但是<code>recv</code>可以指定标志来控制如何接收数据。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="keyword">ssize_t</span> recv(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes, <span class="keyword">int</span> flags);</span><br><span class="line"><span class="comment">// 返回值，返回数据的字节长度；着无可用数据或对等方已经按序结束，返回0；若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>标志</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>MSG_CMSG_CLOEXEC</td>
<td>为UNIX域套接字上接收的文件描述符设置执行时关闭标志</td>
</tr>
<tr>
<td>MSG_DONTWAIT启用非阻塞操作</td>
</tr>
<tr>
<td>MSG_ERRQUEUE</td>
<td>接收错误信息作为辅助数据</td>
</tr>
<tr>
<td>MSG_OOB</td>
<td>如果协议支持，获取带外数据</td>
</tr>
<tr>
<td>MSG_PEEK</td>
<td>返回数据包内容而不真正取走数据包</td>
</tr>
<tr>
<td>MSG_TRUNC</td>
<td>即使数据包被截断，也返回数据包的实际长度</td>
</tr>
<tr>
<td>MSG_WAITALL</td>
<td>等待直到所有的数据可用</td>
</tr>
</tbody>
</table>
</div>
<p>当指定<code>MSG_PEEK</code>标志时，可以查看下一个要读取的数据但不真正取走它。当再次调用<code>read</code>或其中一个<code>recv</code>函数时，会返回刚才查看的数据。对于<code>SOCK_STREAM</code>套接字， 接收的数据可以比预期的少。<code>MSG_WAITALL</code>标志会阻止这种行为，直到所请求的数据全部返回，<code>recv</code>函数才会返回。对于<code>SOCK_DGRAM</code>和<code>SOCK_SEQPACKET</code>套接字，<code>MSG_WAITALL</code>标志没有改变什么行为，因为这些基于报文的套接字类型一次读取就返回整个报文。</p>
<p>如果发送者已经调用<code>shutdown</code>来结束传输，或者网络协议支持按默认的顺序关闭并且发送端已经关闭，那么当所有的数据接收完毕后，<code>recv</code>会返回0。</p>
<p>如果有兴趣定位发送者，可以使用<code>recvfrom</code>来得到数据发送者的源地址。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="keyword">ssize_t</span> recvfrom(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *<span class="keyword">restrict</span> buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags,</span><br><span class="line">    struct sockaddr *<span class="keyword">restrict</span> addr,</span><br><span class="line">    <span class="keyword">socklen_t</span> *<span class="keyword">restrict</span> addrlen);</span><br><span class="line"><span class="comment">// 返回值：返回数据的字节长度，若无可用数据或对等方已经按序结束，返回0；若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>如果<code>addr</code>非空，它将包含数据发送者的套接字端点地址。当调用<code>recvfrom</code>时，需要设置<code>addrlen</code>参数指向一个整数，该整数包含<code>addr</code>所指向的套接字缓冲区的字节长度。返回时，该整数设为该地址的实际字节长度。因为可以获得发送者的地址，<code>recvfrom</code>通常用于无连接的套接字。否则，<code>recvfrom</code>等同于<code>recv</code>。</p>
<p>为了将接收到的数据送入多个缓冲区，类似于<code>readv</code>，或者想接收辅助数据，可以使用<code>recvmsg</code>，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="keyword">ssize_t</span> recvmsg(<span class="keyword">int</span> sockfd, struct msghdr *msg, <span class="keyword">int</span> flags);</span><br><span class="line"><span class="comment">// 返回值，返回数据的字节长度。若无可用数据或对等方已经按序结束，返回0；若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p><code>recvmsg</code>用<code>msghdr</code>结构指定接收数据的输入缓冲区。可以设置参数<code>flags</code>来改变<code>recvmsg</code>的默认行为。返回时，<code>msghdr</code>结构中的<code>msg_flags</code>字段被设为所接收数据的各种特征。<code>recvmsg</code>中返回的各种可能值总结在图中。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>标志</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>MSG_CTRUNC</td>
<td>控制数据被阶段</td>
</tr>
<tr>
<td>MSG_EOR</td>
<td>接收记录结束符</td>
</tr>
<tr>
<td>MSG_ERRQUEUE</td>
<td>接收错误信息作为辅助数据</td>
</tr>
<tr>
<td>MSG_OOB</td>
<td>接收带外数据</td>
</tr>
<tr>
<td>MSG_TRUNC</td>
<td>一般数据被截断</td>
</tr>
</tbody>
</table>
</div>
<p>程序显示了一个与服务器通信的客户端从系统的<code>uptime</code>命令获得输出。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFLEN		128</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">connect_retry</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">const</span> struct sockaddr *,</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">socklen_t</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">print_uptime(<span class="keyword">int</span> sockfd)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span>		n;</span><br><span class="line">	<span class="keyword">char</span>	buf[BUFLEN];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> ((n = recv(sockfd, buf, BUFLEN, <span class="number">0</span>)) &gt; <span class="number">0</span>)</span><br><span class="line">		write(STDOUT_FILENO, buf, n);</span><br><span class="line">	<span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">		err_sys(<span class="string">"recv error"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span>	*<span class="title">ailist</span>, *<span class="title">aip</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span>	<span class="title">hint</span>;</span></span><br><span class="line">	<span class="keyword">int</span>				sockfd, err;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">		err_quit(<span class="string">"usage: ruptime hostname"</span>);</span><br><span class="line">	<span class="built_in">memset</span>(&amp;hint, <span class="number">0</span>, <span class="keyword">sizeof</span>(hint));</span><br><span class="line">	hint.ai_socktype = SOCK_STREAM;</span><br><span class="line">	hint.ai_canonname = <span class="literal">NULL</span>;</span><br><span class="line">	hint.ai_addr = <span class="literal">NULL</span>;</span><br><span class="line">	hint.ai_next = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span> ((err = getaddrinfo(argv[<span class="number">1</span>], <span class="string">"ruptime"</span>, &amp;hint, &amp;ailist)) != <span class="number">0</span>)</span><br><span class="line">		err_quit(<span class="string">"getaddrinfo error: %s"</span>, gai_strerror(err));</span><br><span class="line">	<span class="keyword">for</span> (aip = ailist; aip != <span class="literal">NULL</span>; aip = aip-&gt;ai_next) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((sockfd = connect_retry(aip-&gt;ai_family, SOCK_STREAM, <span class="number">0</span>,</span><br><span class="line">		  aip-&gt;ai_addr, aip-&gt;ai_addrlen)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			err = errno;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			print_uptime(sockfd);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	err_exit(err, <span class="string">"can't connect to %s"</span>, argv[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个程序连接服务器，读取服务器发送过来的字符串并将其打印到标准输出。因为使用的是<code>SOCK_STREAM</code>套接字，所以不能保证调用一次<code>recv</code>就会读取整个字符串，因此需要重复调用直到它返回0。</p>
<p>如果服务器支持多重网络接口或多重网络协议，函数<code>getaddrinfo</code>可能会返回多个候选地址供使用。轮流尝试每个地址，当找到一个允许连接到服务的地址时便可停止。使用<code>connect_retry</code>函数来与服务器建立一个连接。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;syslog.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFLEN	128</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QLEN 10</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HOST_NAME_MAX</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HOST_NAME_MAX 256</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">initserver</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">const</span> struct sockaddr *, <span class="keyword">socklen_t</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">serve(<span class="keyword">int</span> sockfd)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span>		clfd;</span><br><span class="line">	FILE	*fp;</span><br><span class="line">	<span class="keyword">char</span>	buf[BUFLEN];</span><br><span class="line"></span><br><span class="line">	set_cloexec(sockfd);</span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((clfd = accept(sockfd, <span class="literal">NULL</span>, <span class="literal">NULL</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			syslog(LOG_ERR, <span class="string">"ruptimed: accept error: %s"</span>,</span><br><span class="line">			  strerror(errno));</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		set_cloexec(clfd);</span><br><span class="line">		<span class="keyword">if</span> ((fp = popen(<span class="string">"/usr/bin/uptime"</span>, <span class="string">"r"</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="built_in">sprintf</span>(buf, <span class="string">"error: %s\n"</span>, strerror(errno));</span><br><span class="line">			send(clfd, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">while</span> (fgets(buf, BUFLEN, fp) != <span class="literal">NULL</span>)</span><br><span class="line">				send(clfd, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">			pclose(fp);</span><br><span class="line">		&#125;</span><br><span class="line">		close(clfd);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span>	*<span class="title">ailist</span>, *<span class="title">aip</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span>	<span class="title">hint</span>;</span></span><br><span class="line">	<span class="keyword">int</span>				sockfd, err, n;</span><br><span class="line">	<span class="keyword">char</span>			*host;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">1</span>)</span><br><span class="line">		err_quit(<span class="string">"usage: ruptimed"</span>);</span><br><span class="line">	<span class="keyword">if</span> ((n = sysconf(_SC_HOST_NAME_MAX)) &lt; <span class="number">0</span>)</span><br><span class="line">		n = HOST_NAME_MAX;	<span class="comment">/* best guess */</span></span><br><span class="line">	<span class="keyword">if</span> ((host = <span class="built_in">malloc</span>(n)) == <span class="literal">NULL</span>)</span><br><span class="line">		err_sys(<span class="string">"malloc error"</span>);</span><br><span class="line">	<span class="keyword">if</span> (gethostname(host, n) &lt; <span class="number">0</span>)</span><br><span class="line">		err_sys(<span class="string">"gethostname error"</span>);</span><br><span class="line">	daemonize(<span class="string">"ruptimed"</span>);</span><br><span class="line">	<span class="built_in">memset</span>(&amp;hint, <span class="number">0</span>, <span class="keyword">sizeof</span>(hint));</span><br><span class="line">	hint.ai_flags = AI_CANONNAME;</span><br><span class="line">	hint.ai_socktype = SOCK_STREAM;</span><br><span class="line">	hint.ai_canonname = <span class="literal">NULL</span>;</span><br><span class="line">	hint.ai_addr = <span class="literal">NULL</span>;</span><br><span class="line">	hint.ai_next = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span> ((err = getaddrinfo(host, <span class="string">"ruptime"</span>, &amp;hint, &amp;ailist)) != <span class="number">0</span>) &#123;</span><br><span class="line">		syslog(LOG_ERR, <span class="string">"ruptimed: getaddrinfo error: %s"</span>,</span><br><span class="line">		  gai_strerror(err));</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (aip = ailist; aip != <span class="literal">NULL</span>; aip = aip-&gt;ai_next) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((sockfd = initserver(SOCK_STREAM, aip-&gt;ai_addr,</span><br><span class="line">		  aip-&gt;ai_addrlen, QLEN)) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">			serve(sockfd);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了找到它的地址，服务器需要获得其运行时的主机名。如果主机名的最大长度不确定，可以使用<code>HOST_NAME_MAX</code>代替。如果系统没定义<code>HOST_NAME_MAX</code>，可以自己定义。POSIX.1要求主机名的最大长度至少为255字节，不包括终止null字符，因此定义<code>HOST_NAME_MAX</code>为256来包括终止null字符。</p>
<p>对于无连接的套接字，数据包到达时可能已经没有次序，因此如果不能将所有的数据放在一个数据包里，则在应用程序中就必须关心数据包的次序。数据包的最大尺寸是通信协议的特征，另外，对于无连接的套接字，数据包可能会丢失。如果应用程序不能容忍这种丢失，必须使用面向连接的套接字。</p>
<p>容忍数据包丢失意味着两种选择。一种选择是，如果想和对等方可靠通信，就必须对数据包编号，并且在发现数据包丢失时，请求对等应用程序重传，还必须标识重复数据包并丢弃它们，因为数据包可能会延迟或疑似丢失，可能请求重传之后，它们又出现了。</p>
<p>另一种选择是，通过让用户再次尝试那个命令来处理错误。对于简单的应用程序，这可能就足够了，但对于复杂的应用程序，这种选择通常不可行。因此，一般在这种情况下使用面向连接的套接字比较好。</p>
<p>面向连接的套接字的缺陷在于需要更多的时间和工作来建立一个连接，并且每个连接都需要消耗较多的操作系统资源。</p>
<p>程序是采用数据报套接字接口的<code>uptime</code>客户端命令版本。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFLEN		128</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TIMEOUT		20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">sigalrm(<span class="keyword">int</span> signo)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">print_uptime(<span class="keyword">int</span> sockfd, struct addrinfo *aip)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span>		n;</span><br><span class="line">	<span class="keyword">char</span>	buf[BUFLEN];</span><br><span class="line"></span><br><span class="line">	buf[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (sendto(sockfd, buf, <span class="number">1</span>, <span class="number">0</span>, aip-&gt;ai_addr, aip-&gt;ai_addrlen) &lt; <span class="number">0</span>)</span><br><span class="line">		err_sys(<span class="string">"sendto error"</span>);</span><br><span class="line">	alarm(TIMEOUT);</span><br><span class="line">	<span class="keyword">if</span> ((n = recvfrom(sockfd, buf, BUFLEN, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (errno != EINTR)</span><br><span class="line">			alarm(<span class="number">0</span>);</span><br><span class="line">		err_sys(<span class="string">"recv error"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	alarm(<span class="number">0</span>);</span><br><span class="line">	write(STDOUT_FILENO, buf, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span>		*<span class="title">ailist</span>, *<span class="title">aip</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span>		<span class="title">hint</span>;</span></span><br><span class="line">	<span class="keyword">int</span>					sockfd, err;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span>	<span class="title">sa</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">		err_quit(<span class="string">"usage: ruptime hostname"</span>);</span><br><span class="line">	sa.sa_handler = sigalrm;</span><br><span class="line">	sa.sa_flags = <span class="number">0</span>;</span><br><span class="line">	sigemptyset(&amp;sa.sa_mask);</span><br><span class="line">	<span class="keyword">if</span> (sigaction(SIGALRM, &amp;sa, <span class="literal">NULL</span>) &lt; <span class="number">0</span>)</span><br><span class="line">		err_sys(<span class="string">"sigaction error"</span>);</span><br><span class="line">	<span class="built_in">memset</span>(&amp;hint, <span class="number">0</span>, <span class="keyword">sizeof</span>(hint));</span><br><span class="line">	hint.ai_socktype = SOCK_DGRAM;</span><br><span class="line">	hint.ai_canonname = <span class="literal">NULL</span>;</span><br><span class="line">	hint.ai_addr = <span class="literal">NULL</span>;</span><br><span class="line">	hint.ai_next = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span> ((err = getaddrinfo(argv[<span class="number">1</span>], <span class="string">"ruptime"</span>, &amp;hint, &amp;ailist)) != <span class="number">0</span>)</span><br><span class="line">		err_quit(<span class="string">"getaddrinfo error: %s"</span>, gai_strerror(err));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (aip = ailist; aip != <span class="literal">NULL</span>; aip = aip-&gt;ai_next) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((sockfd = socket(aip-&gt;ai_family, SOCK_DGRAM, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			err = errno;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			print_uptime(sockfd, aip);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"can't contact %s: %s\n"</span>, argv[<span class="number">1</span>], strerror(err));</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>除了增加安装一个SIGALRM的信号处理程序以外，基于数据报的客户端中的main函数和面向连接的客户端中的类似。使用<code>alarm</code>函数来避免调用<code>recvfrom</code>时的无限期阻塞。</p>
<p>对于面向连接的协议，需要在交换数据之前连接到服务器。对于服务器来说，到来的连接请求已经足够判断出所需提供给客户端的服务。但是对于基于数据报的协议，需要有一种方法通知服务器来执行服务。本例中，只是简单地向服务器发送了1字节的数据。服务器将接收它，从数据包中得到地址，并使用这个地址来传送它的响应。如果服务器提供多个服务，可以使用这个请求数据来表示需要的服务，但由于服务器只做一件事情，1字节数据的内容是无关紧要的。</p>
<p>如果服务器不在运行状态，客户端调用<code>recvfrom</code>便会无限期阻塞。对于这个面向连接的实例，如果服务器不运行，<code>connect</code>调用会失败。为了避免无限期阻塞，可以在调用<code>recvfrom</code>之前设置警告时钟。</p>
<h2 id="套接字选项"><a href="#套接字选项" class="headerlink" title="套接字选项"></a>套接字选项</h2><p>套接字机制提供了两个套接字选项接口来控制套接字行为。一个接口用来设置选项，另一个接口可以查询选项的状态。可以获取或设置以下3种选项。</p>
<ol>
<li>通用选项，工作在所有套接字类型上。</li>
<li>在套接字层次管理的选项，但是依赖于下层协议的支持。</li>
<li>特定于某协议的选项，每个协议独有的。</li>
</ol>
<p>可以使用<code>setsockopt</code>函数来设置套接字选项。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setsockopt</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> option, <span class="keyword">const</span> <span class="keyword">void</span> *val,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">socklen_t</span> len)</span></span>;</span><br><span class="line"><span class="comment">// 返回值，若成功，返回0；若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>参数<code>level</code>标识了选项应用的协议。如果选项是通用的套接字层次选项，则<code>level</code>设置成<code>SOL_SOCKET</code>。否则，<code>level</code>设置成控制这个选项的协议编号。对于TCP选项，<code>level</code>是<code>IPPROTO_TCP</code>，对于IP，<code>level</code>是<code>IPPROTO_IP</code>。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>选项</th>
<th>参数val的类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>SO_ACCEPTCONN</td>
<td>int</td>
<td>返回信息指示该套接字是否能被监听</td>
</tr>
<tr>
<td>SO_BROADCAST</td>
<td>int</td>
<td>如果<code>*val</code>非0，广播数据报</td>
</tr>
<tr>
<td>SO_DEBUG</td>
<td>int</td>
<td>如果<code>*val</code>非0，启用网络驱动调试功能</td>
</tr>
<tr>
<td>SO_DONTROUTE</td>
<td>int</td>
<td>如果<code>*val</code>非0。绕过通常路由</td>
</tr>
<tr>
<td>SO_ERROR</td>
<td>int</td>
<td>返回挂起的套接字错误并清除</td>
</tr>
<tr>
<td>SO_KEEPALIVE</td>
<td>int</td>
<td>如果<code>*val</code>非0。启用周期性keep-alive报文</td>
</tr>
<tr>
<td>SO_LINGER</td>
<td>struct linger</td>
<td>当还有未发报文雨套接字已关闭时，延迟时间</td>
</tr>
<tr>
<td>SO_OOBINLINE</td>
<td>int</td>
<td>如果<code>*val</code>非0，将带外数据放在普通数据中</td>
</tr>
<tr>
<td>SO_RCVBUF</td>
<td>int</td>
<td>接收缓冲区的字节长度</td>
</tr>
<tr>
<td>SO_RCVLOWAT</td>
<td>int</td>
<td>接收调用中返回的最小数据字节数</td>
</tr>
<tr>
<td>SO_RCVTIMEO</td>
<td>struct timeval</td>
<td>套接字接收调用的超时值</td>
</tr>
<tr>
<td>SO_REUSEADDR</td>
<td>int</td>
<td>如果<code>*val</code>非0，重用bind中的地址</td>
</tr>
<tr>
<td>SO_SNDBUF</td>
<td>int</td>
<td>发送缓冲区的字节长度</td>
</tr>
<tr>
<td>SO_SNDLOWAT</td>
<td>int</td>
<td>发送调用中传送的最小数据字节数</td>
</tr>
<tr>
<td>SO_SNDTIMEO</td>
<td>struct timeval</td>
<td>套接字发送调用的超时值</td>
</tr>
<tr>
<td>SO_TYPE</td>
<td>int</td>
<td>标识套接字类型</td>
</tr>
</tbody>
</table>
</div>
<p>参数<code>val</code>根据选项的不同指向一个数据结构或者一个整数。一些选项是on/off开关。如果整数非0，则启用选项。如果整数为0，则禁止选项。参数len指定了val指向的对象的大小。可以使用<code>getsockopt</code>函数来查看选项的当前值。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsockopt</span> <span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> option, <span class="keyword">void</span> *<span class="keyword">restrict</span> val,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">socklen_t</span> *rentrict lenp)</span></span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回0；若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>多数<code>lenp</code>是一个指向整数的指针。在调用<code>getsockopt</code>之前，设置该整数为复制选项缓冲区的长度。如果选项的实际长度大于此值，则选项会被截断。如果实际长度正好小于此值，那么返回时将此值更新为实际长度。</p>
<h2 id="带外数据"><a href="#带外数据" class="headerlink" title="带外数据"></a>带外数据</h2><p>带外数据(out-of-band data)是一些通信协议所支持的可选功能，与普通数据相比，它允许更高优先级的数据传输。带外数据先行传输，即使传输队列已经有数据。TCP支持带外数据，但是UDP不支持。套接字接口对带外数据的支持很大程度上受TCP带外数据具体实现的影响。</p>
<p>TCP将带外数据称为紧急数据(urgent data)。TCP仅支持一个字节的紧急数据，但是允许紧急数据在普通数据传递机制数据流之外传输。为了产生紧急数据，可以在3个send函数中的任何一个里指定<code>MSG_OOB</code>标志。如果带<code>MSG_OOB</code>标志发送的字节数超过一个时，最后一个字节将被视为紧急数据字节。</p>
<p>如果通过套接字安排了信号的产生，那么紧急数据被接收时，会发送SIGURG信号。可以通过调用以下函数安排进程接收套接字的信号：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fcntl(sockfd, F_SETOWN, pid);</span><br></pre></td></tr></table></figure></p>
<p><code>F_GETOWN</code>命令可以用来获得当前套接字所有权，对于<code>F_SETOWN</code>命令，负值代表进程组ID，正值代表进程ID。因此，调用<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">owner = fcntl (socked, F_GETOWN, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></p>
<p>将返回<code>owner</code>，如果<code>owner</code>为正值， 则等于配置为接收套接字信号的进程的ID。如果<code>owner</code>为负值，其绝对值为接收套接字信号的进程组的ID。</p>
<p>TCP支持紧急标记(urgentmark)的概念， 即在普通数据流中紧急数据所在的位置。如果采用套接字选项<code>SO_OOBINLINE</code>，那么可以在普通数据中接收紧急数据。为帮助判断是否已经到达紧急标记，可以使用函数<code>sockatmark</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sockatmark</span><span class="params">(<span class="keyword">int</span> sockfd)</span></span>;</span><br><span class="line"><span class="comment">// 返回值：若在标记处，返回1；若没在标记处，返回0；若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>当下一个要读取的字节在紧急标志处时，<code>sockatmark</code>返回1。当带外数据出现在套接字读取队列时，<code>select</code>函数会返回一个文件描述符并且有一个待处理的异常条件。可以在普通数据流上接收紧急数据，也可以在其中一个<code>recv</code>函数中采用<code>MSG_OOB</code>标志在其他队列数据之前接收紧急数据。TCP队列仅用一个字节的紧急数据。如果在接收当前的紧急数据字节之前又有新的紧急数据到来，那么已有的字节会被丢弃。</p>
<h2 id="非阻塞和异步I-O"><a href="#非阻塞和异步I-O" class="headerlink" title="非阻塞和异步I/O"></a>非阻塞和异步I/O</h2><p>通常，<code>recv</code>函数没有数据可用时会阻塞等待。同样地，当套接字输出队列没有足够空间来发送消息时，<code>send</code>函数会阻塞。在套接字非阻塞模式下，行为会改变。在这种情况下，这些函数不会阻塞而是会失败，将errno设置为EWOULDBLOCK成者EAGAIN。当这种情况发生时，可以使用<code>poll</code>或<code>select</code>来判断能否接收或者传输数据。</p>
<p>在基于套接字的异步I/O中，当从套接字中读取数据时， 或者当套接字写队列中空间变得可用时，可以安排要发送的信号SIGIO。启用异步I/O是一个两步骤的过程。</p>
<ol>
<li>建立套接字所有权，这样信号可以被传递到合适的进程。</li>
<li>通知套接字当I/O操作不会阻塞时发信号。</li>
</ol>
<p>可以使用3种方式来完成第一个步骤。</p>
<ul>
<li>在<code>fcntl</code>中使用<code>F_SETOWN</code>命令。</li>
<li>在<code>fcctl</code>中使用<code>FIOSETOWN</code>命令。</li>
<li>在<code>fcctl</code>中使用<code>SIOCSPGRP</code>命令。</li>
</ul>
<p>要完成第二个步骤，有两个选择</p>
<ol>
<li>在<code>fcntl</code>中使用<code>F_SETFL</code>命令并且启用文件标志<code>O_ASYNC</code>。</li>
<li>在<code>ioctl</code>中使用<code>FIOASYNC</code>命令。</li>
</ol>
<h1 id="高级进程间通信"><a href="#高级进程间通信" class="headerlink" title="高级进程间通信"></a>高级进程间通信</h1><h2 id="UNIX域套接字"><a href="#UNIX域套接字" class="headerlink" title="UNIX域套接字"></a>UNIX域套接字</h2><p>UNIX域套接字用于在同一台计算机上运行的进程之间的通信。虽然因特网域套接字可用于同一目的，但UNIX域套接字的效率更高。UNIX域套接字仅仅复制数据，它们并不执行协议处理，不需要添加或删除网络报头，无需计算校验和，不要产生顺序号，无需发送确认报文。UNIX域套接字提供流和数据报两种接口，UNIX域数据报服务是可靠的，既不会丢失报文也不会传递出错。UNIX域套接字就像是套接字和管道的混合。可以使用它们面向网络的域套接字接口或者使用<code>socketpair</code>函数来创建一对无命名的、相互连接的UNIX域套接字。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socketpair</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol, <span class="keyword">int</span> sockfd[<span class="number">2</span>])</span></span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回0；若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>虽然接口足够通用，允许<code>socketpair</code>用于其他域，但一般来说操作系统仅对UNIX域提供支持，一对相互连接的UNIX域套接字可以起到全双工管道的作用：两端对读和写开放。我们将其称为fd管道(fd-pipe)，以便与普通的半双工管道区分开来。</p>
<p><code>fd_pipe</code>函数使用<code>socketpair</code>函数来创建一对相互连接的UNIX域流套接字。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fd_pipe</span><span class="params">(<span class="keyword">int</span> fd[<span class="number">2</span>])</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (socketpair (AF_UNIX, SOCK_STREAM, <span class="number">0</span>, fd));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>套接字是和文件描述符相关联的，消息到达时，可以用套接字来通知。对每个消息队列使用一个线程。每个线程都会在<code>msgrcv</code>调用中阻塞。当消息到达时，线程会把它写入一个UNIX域套接字的一端。当poll指示套接字可以读取数据时，应用程序会使用这个套接字的另外一端来接收这个消息。</p>
<p><code>main</code>函数中创建了一些消息队列和UNIX域套接字，并为每个消息队列开启了一个新线程。然后它在一个无限循环中用poll来轮询选择一个套接字端点。当某个套接字可读时，程序可以从套接字中读取数据并把消息打印到标准输出上。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NQ		3		<span class="comment">/* number of queues */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXMSZ	512		<span class="comment">/* maximum message size */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KEY		0x123	<span class="comment">/* key for first message queue */</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">threadinfo</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> qid;</span><br><span class="line">	<span class="keyword">int</span> fd;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mymesg</span> &#123;</span></span><br><span class="line">	<span class="keyword">long</span> mtype;</span><br><span class="line">	<span class="keyword">char</span> mtext[MAXMSZ];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *</span><br><span class="line">helper(<span class="keyword">void</span> *arg)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span>					n;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mymesg</span>		<span class="title">m</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">threadinfo</span>	*<span class="title">tip</span> = <span class="title">arg</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(;;) &#123;</span><br><span class="line">		<span class="built_in">memset</span>(&amp;m, <span class="number">0</span>, <span class="keyword">sizeof</span>(m));</span><br><span class="line">		<span class="keyword">if</span> ((n = msgrcv(tip-&gt;qid, &amp;m, MAXMSZ, <span class="number">0</span>, MSG_NOERROR)) &lt; <span class="number">0</span>)</span><br><span class="line">			err_sys(<span class="string">"msgrcv error"</span>);</span><br><span class="line">		<span class="keyword">if</span> (write(tip-&gt;fd, m.mtext, n) &lt; <span class="number">0</span>)</span><br><span class="line">			err_sys(<span class="string">"write error"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span>					i, n, err;</span><br><span class="line">	<span class="keyword">int</span>					fd[<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">int</span>					qid[NQ];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span>		<span class="title">pfd</span>[<span class="title">NQ</span>];</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">threadinfo</span>	<span class="title">ti</span>[<span class="title">NQ</span>];</span></span><br><span class="line">	<span class="keyword">pthread_t</span>			tid[NQ];</span><br><span class="line">	<span class="keyword">char</span>				buf[MAXMSZ];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NQ; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((qid[i] = msgget((KEY+i), IPC_CREAT|<span class="number">0666</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">			err_sys(<span class="string">"msgget error"</span>);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"queue ID %d is %d\n"</span>, i, qid[i]);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (socketpair(AF_UNIX, SOCK_DGRAM, <span class="number">0</span>, fd) &lt; <span class="number">0</span>)</span><br><span class="line">			err_sys(<span class="string">"socketpair error"</span>);</span><br><span class="line">		pfd[i].fd = fd[<span class="number">0</span>];</span><br><span class="line">		pfd[i].events = POLLIN;</span><br><span class="line">		ti[i].qid = qid[i];</span><br><span class="line">		ti[i].fd = fd[<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">if</span> ((err = pthread_create(&amp;tid[i], <span class="literal">NULL</span>, helper, &amp;ti[i])) != <span class="number">0</span>)</span><br><span class="line">			err_exit(err, <span class="string">"pthread_create error"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="keyword">if</span> (poll(pfd, NQ, <span class="number">-1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">			err_sys(<span class="string">"poll error"</span>);</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NQ; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (pfd[i].revents &amp; POLLIN) &#123;</span><br><span class="line">				<span class="keyword">if</span> ((n = read(pfd[i].fd, buf, <span class="keyword">sizeof</span>(buf))) &lt; <span class="number">0</span>)</span><br><span class="line">					err_sys(<span class="string">"read error"</span>);</span><br><span class="line">				buf[n] = <span class="number">0</span>;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"queue id %d, message %s\n"</span>, qid[i], buf);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意，我们使用的是数据报(<code>SOCK_DGRAM</code>)套接字而不是流套接字。这样做可以保持消息边界，以保证从套接字里一次只读取一条消息。</p>
<p>这种技术可以(非直接地)在消息队列中运用<code>poll</code>或者<code>select</code>。只要为每个队列分配一个线程的开销以及每个消息额外复制两次(一次写入套接字，另一次从套接字里读取出来)的开销是可接受的，这种技术就会使XSI消息队列的使用更加容易。</p>
<p>使用上述的程序发送消息。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXMSZ 512</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mymesg</span> &#123;</span></span><br><span class="line">	<span class="keyword">long</span> mtype;</span><br><span class="line">	<span class="keyword">char</span> mtext[MAXMSZ];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">key_t</span> key;</span><br><span class="line">	<span class="keyword">long</span> qid;</span><br><span class="line">	<span class="keyword">size_t</span> nbytes;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mymesg</span> <span class="title">m</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"usage: sendmsg KEY message\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	key = strtol(argv[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> ((qid = msgget(key, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">		err_sys(<span class="string">"can't open queue key %s"</span>, argv[<span class="number">1</span>]);</span><br><span class="line">	<span class="built_in">memset</span>(&amp;m, <span class="number">0</span>, <span class="keyword">sizeof</span>(m));</span><br><span class="line">	<span class="built_in">strncpy</span>(m.mtext, argv[<span class="number">2</span>], MAXMSZ<span class="number">-1</span>);</span><br><span class="line">	nbytes = <span class="built_in">strlen</span>(m.mtext);</span><br><span class="line">	m.mtype = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (msgsnd(qid, &amp;m, nbytes, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">		err_sys(<span class="string">"can't send message"</span>);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个程序需要两个参数：消息队列关联的键值以及一个包含消息主体的字符串。发送消息到服务器端时，它会打印如下信息：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ ./pollmag &amp;      在后台运行服务器</span><br><span class="line">[1]12814</span><br><span class="line">$ queue ID 0 is 196608</span><br><span class="line">queue ID 1 18 196609</span><br><span class="line">queue ID 2 18 196610</span><br><span class="line"></span><br><span class="line">$ ./sendmsg 0x123 <span class="string">"hello, world"</span>     给第一个队列发送一条消息</span><br><span class="line">queue id 196608, message hello, world</span><br><span class="line">$ ./sendmsg 0x124 <span class="string">"just a test"</span>      给第二个队列发送一条消息</span><br><span class="line">queue id 196609, nessage just a <span class="built_in">test</span> </span><br><span class="line">$ ./ sendmsg 0x125 <span class="string">"bye"</span>             给第三个队列发送一条消息</span><br><span class="line">queue id 196610, nessage <span class="built_in">bye</span></span><br></pre></td></tr></table></figure></p>
<h3 id="命名UNIX域套接字"><a href="#命名UNIX域套接字" class="headerlink" title="命名UNIX域套接字"></a>命名UNIX域套接字</h3><p>虽然<code>socketpair</code>函数能创建一对相互连接的套接字，但是每一个套接字都没有名字。这意味着无关进程不能使用它们。</p>
<p>可以命名UNIX域套接字，并可将其用于告示服务。但是要注意，UNIX域套接字使用的地址格式不同于因特网域套接字。套接字地址格式会随实现而变。UNIX域套接字的地址由<code>sockaddr_un</code>结构表示。<code>sockaddr_un</code>结构在头文件<code>&lt;sys/un.h&gt;</code>中的定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> &#123;</span></span><br><span class="line">	<span class="keyword">sa_family_t</span> sun_tamily;   <span class="comment">/* AF_UNIX */</span></span><br><span class="line">	<span class="keyword">char</span> sun_path[<span class="number">108</span>];       <span class="comment">/* pathnome */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>sockaddr_un</code>结构的<code>sun_path</code>成员包含一个路径名。当我们将一个地址绑定到一个UNIX域套接字时，系统会用该路径名创建一个<code>S_IFSOCK</code>类型的文件。该文件仅用于向客户进程告示套接字名字。该文件无法打开，也不能由应用程序用于通信。如果我们试图绑定同一地址时，该文件已经存在，那么bind请求会失败。当关闭套接字时，并不自动删除该文件，所以必须确保在应用程序退出前，对该文件执行解除链接操作。</p>
<p>所示的程序是一个将地址绑定到UNIX域套接字的例子。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> fd, size;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">un</span>;</span></span><br><span class="line"></span><br><span class="line">	un.sun_family = AF_UNIX;</span><br><span class="line">	<span class="built_in">strcpy</span>(un.sun_path, <span class="string">"foo.socket"</span>);</span><br><span class="line">	<span class="keyword">if</span> ((fd = socket(AF_UNIX, SOCK_STREAM, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">		err_sys(<span class="string">"socket failed"</span>);</span><br><span class="line">	size = offsetof(struct sockaddr_un, sun_path) + <span class="built_in">strlen</span>(un.sun_path);</span><br><span class="line">	<span class="keyword">if</span> (bind(fd, (struct sockaddr *)&amp;un, size) &lt; <span class="number">0</span>)</span><br><span class="line">		err_sys(<span class="string">"bind failed"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"UNIX domain socket bound\n"</span>);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>确定绑定地址长度的方法是，先计算<code>sun_path</code>成员在<code>sockaddr_un</code>结构中的偏移量，然后将结果与路径名长度(不包括终止null字符)相加。因为<code>sockaddr_un</code>结构中<code>sun_path</code>之前的成员与实现相关，所以我们使用<code>&lt;stddef.h&gt;</code>头文件(包括在<code>apue.h</code>中)中的<code>offsetof</code>宏计算<code>sun_path</code>成员从结构开始处的偏移量。如果查看<code>&lt;stddef.h&gt;</code>，则可见到类似于下列形式的定义：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> offsetof (TYPE, MEMBER) ((int)&amp;((TYPE *)0)-&gt;MEMBER)</span></span><br></pre></td></tr></table></figure></p>
<p>假定该结构从地址0开始，此表达式求得成员起始地址的整型值。</p>
<h2 id="唯一连接"><a href="#唯一连接" class="headerlink" title="唯一连接"></a>唯一连接</h2><p>服务器进程可以使用标准<code>bind</code>、<code>listen</code>和<code>accept</code>函数，为客户进程安排一个唯一UNIX域连接。客户进程使用<code>connect</code>与服务器进程联系。在服务器进程接受了<code>connect</code>请求后，在服务器进程和客户进程之间就存在了唯一连接。</p>
<p>图17-6展示了客户进程和服务器进程存在连接之前二者的情形。服务器端把它的套接字绑定到<code>sockaddr_un</code>的地址并监听新的连接请求。图17-7展示了在服务器端接受客户端连接请求后，客户端和服务器端之间建立的唯一的连接。<br><img src="/img/1623034862.jpg" alt></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">serv_listen</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回要监听的文件描述符；若出错，返回负值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">serv_accept</span> <span class="params">(<span class="keyword">int</span> listenfd, <span class="keyword">uid_t</span> *uidptr)</span></span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回新文件描述符；若出错，返回负值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cli_conn</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回文件描述符；若出错，返回负值</span></span><br></pre></td></tr></table></figure>
<p>服务器进程可以调用<code>serv_listen</code>函数声明它要在一个众所周知的名字上监听客户进程的连接请求。当客户进程想要连接至服务器进程时，它们将使用该名字。<code>serv_listen</code>函数的返回值是用于接收客户进程连接请求的服务器UNIX域套接字。服务器进程可以使用<code>serv_accept</code>函数等待客户进程连接请求的到达。当一个请求到达时，系统自动创建一个新的UNIX域套接字，并将它与客户端套接字连接，最后将这个新套接字返回给服务器。此外，客户进程的有效用户ID存放在<code>uidptr</code>指向的存储区中。客户进程调用<code>cli_conn</code>函数连接至服务器进程。客户进程指定的<code>name</code>参数必须与服务器进程调用<code>serv_listen</code>函数时所用的名字相同。函数返回时，客户进程得到接连至服务器进程的文件描述符。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QLEN    10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Create a server endpoint of a connection.</span></span><br><span class="line"><span class="comment"> * Returns fd if all OK, &lt;0 on error.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">serv_listen(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span>                 fd, len, err, rval;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span>  <span class="title">un</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strlen</span>(name) &gt;= <span class="keyword">sizeof</span>(un.sun_path)) &#123;</span><br><span class="line">        errno = ENAMETOOLONG;</span><br><span class="line">        <span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* create a UNIX domain stream socket */</span></span><br><span class="line">    <span class="keyword">if</span> ((fd = socket(AF_UNIX, SOCK_STREAM, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>(<span class="number">-2</span>);</span><br><span class="line"></span><br><span class="line">    unlink(name);   <span class="comment">/* in case it already exists */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* fill in socket address structure */</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;un, <span class="number">0</span>, <span class="keyword">sizeof</span>(un));</span><br><span class="line">    un.sun_family = AF_UNIX;</span><br><span class="line">    <span class="built_in">strcpy</span>(un.sun_path, name);</span><br><span class="line">    len = offsetof(struct sockaddr_un, sun_path) + <span class="built_in">strlen</span>(name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* bind the name to the descriptor */</span></span><br><span class="line">    <span class="keyword">if</span> (bind(fd, (struct sockaddr *)&amp;un, len) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        rval = <span class="number">-3</span>;</span><br><span class="line">        <span class="keyword">goto</span> errout;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (listen(fd, QLEN) &lt; <span class="number">0</span>) &#123; <span class="comment">/* tell kernel we're a server */</span></span><br><span class="line">        rval = <span class="number">-4</span>;</span><br><span class="line">        <span class="keyword">goto</span> errout;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>(fd);</span><br><span class="line"></span><br><span class="line">errout:</span><br><span class="line">    err = errno;</span><br><span class="line">    close(fd);</span><br><span class="line">    errno = err;</span><br><span class="line">    <span class="keyword">return</span>(rval);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，调用<code>socket</code>创建一个UNIX域套接字。然后将欲赋给套接字的众所周知的路径名填入<code>sockaddr_un</code>结构。该结构是调用<code>bind</code>的参数。注意，不需要设置某些平台提供的<code>sun_len</code>字段，因为操作系统会用传送给bind函数的地址长度设置该字段。最后，调用<code>listen</code>函数来通知内核该进程将作为服务器进程等待客户进程的连接请求。当收到一个客户进程的连接请求后，服务器进程调用<code>serv_accept</code>函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	STALE	30	<span class="comment">/* client's name can't be older than this (sec) */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Wait for a client connection to arrive, and accept it.</span></span><br><span class="line"><span class="comment"> * We also obtain the client's user ID from the pathname</span></span><br><span class="line"><span class="comment"> * that it must bind before calling us.</span></span><br><span class="line"><span class="comment"> * Returns new fd if all OK, &lt;0 on error</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">serv_accept(<span class="keyword">int</span> listenfd, <span class="keyword">uid_t</span> *uidptr)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span>					clifd, err, rval;</span><br><span class="line">	<span class="keyword">socklen_t</span>			len;</span><br><span class="line">	<span class="keyword">time_t</span>				staletime;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span>	<span class="title">un</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">stat</span>			<span class="title">statbuf</span>;</span></span><br><span class="line">	<span class="keyword">char</span>				*name;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* allocate enough space for longest name plus terminating null */</span></span><br><span class="line">	<span class="keyword">if</span> ((name = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(un.sun_path + <span class="number">1</span>))) == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line">	len = <span class="keyword">sizeof</span>(un);</span><br><span class="line">	<span class="keyword">if</span> ((clifd = accept(listenfd, (struct sockaddr *)&amp;un, &amp;len)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">free</span>(name);</span><br><span class="line">		<span class="keyword">return</span>(<span class="number">-2</span>);		<span class="comment">/* often errno=EINTR, if signal caught */</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* obtain the client's uid from its calling address */</span></span><br><span class="line">	len -= offsetof(struct sockaddr_un, sun_path); <span class="comment">/* len of pathname */</span></span><br><span class="line">	<span class="built_in">memcpy</span>(name, un.sun_path, len);</span><br><span class="line">	name[len] = <span class="number">0</span>;			<span class="comment">/* null terminate */</span></span><br><span class="line">	<span class="keyword">if</span> (stat(name, &amp;statbuf) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		rval = <span class="number">-3</span>;</span><br><span class="line">		<span class="keyword">goto</span> errout;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span>	S_ISSOCK	<span class="comment">/* not defined for SVR4 */</span></span></span><br><span class="line">	<span class="keyword">if</span> (S_ISSOCK(statbuf.st_mode) == <span class="number">0</span>) &#123;</span><br><span class="line">		rval = <span class="number">-4</span>;		<span class="comment">/* not a socket */</span></span><br><span class="line">		<span class="keyword">goto</span> errout;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((statbuf.st_mode &amp; (S_IRWXG | S_IRWXO)) ||</span><br><span class="line">		(statbuf.st_mode &amp; S_IRWXU) != S_IRWXU) &#123;</span><br><span class="line">		  rval = <span class="number">-5</span>;	<span class="comment">/* is not rwx------ */</span></span><br><span class="line">		  <span class="keyword">goto</span> errout;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	staletime = time(<span class="literal">NULL</span>) - STALE;</span><br><span class="line">	<span class="keyword">if</span> (statbuf.st_atime &lt; staletime ||</span><br><span class="line">		statbuf.st_ctime &lt; staletime ||</span><br><span class="line">		statbuf.st_mtime &lt; staletime) &#123;</span><br><span class="line">		  rval = <span class="number">-6</span>;	<span class="comment">/* i-node is too old */</span></span><br><span class="line">		  <span class="keyword">goto</span> errout;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (uidptr != <span class="literal">NULL</span>)</span><br><span class="line">		*uidptr = statbuf.st_uid;	<span class="comment">/* return uid of caller */</span></span><br><span class="line">	unlink(name);		<span class="comment">/* we're done with pathname now */</span></span><br><span class="line">	<span class="built_in">free</span>(name);</span><br><span class="line">	<span class="keyword">return</span>(clifd);</span><br><span class="line"></span><br><span class="line">errout:</span><br><span class="line">	err = errno;</span><br><span class="line">	close(clifd);</span><br><span class="line">	<span class="built_in">free</span>(name);</span><br><span class="line">	errno = err;</span><br><span class="line">	<span class="keyword">return</span>(rval);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>服务器进程在调用<code>serv_accept</code>中阻塞，等待一个客户进程调用<code>cli_conn</code>。从<code>accept</code>返回时，返回值是连接到客户进程的崭新的描述符。另外，<code>accept</code>函数也经由其第二个参数(指向<code>sockaddr_un</code>结构的指针)返回客户进程赋给其套接字的路径名(包含客户进程ID的名字)。接着，程序复制这个路径名，并确保它是以null终止的(如果路径名占用了<code>sockaddr_un</code>结构里的<code>sun_path</code>成员所有的可用空间，那就没有空间存放终止null字符)。然后，调用<code>stat</code>函数验证：该路径名确实是一个套接字；其权限仅允许用户读、用户写以及用户执行。还要验证与套接字相关联的3个时间参数不比当前时间早30秒。</p>
<p>如若通过了所有这些检验，则可认为客户进程的身份(其有效用户ID)是该套接字的所有者。虽然这种检验并不完善，但这是对当前系统所能做到的最佳方案。</p>
<p>客户进程调用<code>cli_conn</code>函数对连到服务器进程的连接进行初始化。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	CLI_PATH	<span class="meta-string">"/var/tmp/"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	CLI_PERM	S_IRWXU			<span class="comment">/* rwx for user only */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Create a client endpoint and connect to a server.</span></span><br><span class="line"><span class="comment"> * Returns fd if all OK, &lt;0 on error.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">cli_conn(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span>					fd, len, err, rval;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span>	<span class="title">un</span>, <span class="title">sun</span>;</span></span><br><span class="line">	<span class="keyword">int</span>					do_unlink = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strlen</span>(name) &gt;= <span class="keyword">sizeof</span>(un.sun_path)) &#123;</span><br><span class="line">		errno = ENAMETOOLONG;</span><br><span class="line">		<span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* create a UNIX domain stream socket */</span></span><br><span class="line">	<span class="keyword">if</span> ((fd = socket(AF_UNIX, SOCK_STREAM, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* fill socket address structure with our address */</span></span><br><span class="line">	<span class="built_in">memset</span>(&amp;un, <span class="number">0</span>, <span class="keyword">sizeof</span>(un));</span><br><span class="line">	un.sun_family = AF_UNIX;</span><br><span class="line">	<span class="built_in">sprintf</span>(un.sun_path, <span class="string">"%s%05ld"</span>, CLI_PATH, (<span class="keyword">long</span>)getpid());</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"file is %s\n"</span>, un.sun_path);</span><br><span class="line">	len = offsetof(struct sockaddr_un, sun_path) + <span class="built_in">strlen</span>(un.sun_path);</span><br><span class="line"></span><br><span class="line">	unlink(un.sun_path);		<span class="comment">/* in case it already exists */</span></span><br><span class="line">	<span class="keyword">if</span> (bind(fd, (struct sockaddr *)&amp;un, len) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		rval = <span class="number">-2</span>;</span><br><span class="line">		<span class="keyword">goto</span> errout;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (chmod(un.sun_path, CLI_PERM) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		rval = <span class="number">-3</span>;</span><br><span class="line">		do_unlink = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">goto</span> errout;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* fill socket address structure with server's address */</span></span><br><span class="line">	<span class="built_in">memset</span>(&amp;sun, <span class="number">0</span>, <span class="keyword">sizeof</span>(sun));</span><br><span class="line">	sun.sun_family = AF_UNIX;</span><br><span class="line">	<span class="built_in">strcpy</span>(sun.sun_path, name);</span><br><span class="line">	len = offsetof(struct sockaddr_un, sun_path) + <span class="built_in">strlen</span>(name);</span><br><span class="line">	<span class="keyword">if</span> (connect(fd, (struct sockaddr *)&amp;sun, len) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		rval = <span class="number">-4</span>;</span><br><span class="line">		do_unlink = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">goto</span> errout;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>(fd);</span><br><span class="line"></span><br><span class="line">errout:</span><br><span class="line">	err = errno;</span><br><span class="line">	close(fd);</span><br><span class="line">	<span class="keyword">if</span> (do_unlink)</span><br><span class="line">		unlink(un.sun_path);</span><br><span class="line">	errno = err;</span><br><span class="line">	<span class="keyword">return</span>(rval);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>调用<code>socket</code>函数创建UNIX域套接字的客户进程端，然后用客户进程专有的名字填入<code>sockaddr_un</code>结构。</p>
<p>绑定的路径名的最后5个字符来自客户进程ID。仅在该路径名已存在时调用<code>unlink</code>。然后，调用<code>bind</code>将名字赋给客户进程套接字。这在文件系统中创建了一个套接字文件，所用的名字与被绑定的路径名一样。接着，调用<code>chmod</code>关闭除用户读、用户写以及用户执行以外的其他权限。</p>
<p>在<code>serv_accept</code>中，服务器进程检验这些权限以及套接字用户ID以验证客户进程的身份。然后，必须填充另一个<code>sockaddr_un</code>结构，这次用的是服务进程众所周知的路径名。最后，调用<code>connect</code>函数初始化与服务进程的连接。</p>
<h2 id="传送文件描述符"><a href="#传送文件描述符" class="headerlink" title="传送文件描述符"></a>传送文件描述符</h2><p>在两个进程之间传送打开文件描述符的技术是非常有用的。它使一个进程(通常是服务器进程)能够处理打开一个文件所要做的一切操作(包括将网络名翻译为网络地址、拨号调制解调器、协商文件锁等)以及向调用进程送回一个描述符，该描述符可被用于以后的所有I/O函数。涉及打开文件或设备的所有细节对客户进程而言都是透明的。</p>
<p>当一个进程向另一个进程传送一个打开文件描述符时，我们想让发送进程和接收进程共享同一文件表项。图中显示了所期望的安排。<br><img src="/img/1623067638.jpg" alt></p>
<p>在技术上，我们是将指向一个打开文件表项的指针从一个进程发送到另外一个进程。该指针被分配存放在接收进程的第一个可用描述符项中。两个进程共享同一个打开文件表，这与fork之后的父进程和子进程共享打开文件表的情况完全相同)。</p>
<p>当发送进程将描述符传送给接收进程后，通常会关闭该描述符。发送进程关闭该描述符并不会真的关闭该文件或设备，其原因是该描述符仍被视为由接收进程打开(即使接收进程尚未接收到该描述符)。下面定义本章用以发送和接收文件报述符的3个函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">send_fd</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> fd_no_send)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">send_err</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> status, <span class="keyword">const</span> <span class="keyword">char</span> *errmsg)</span></span>;</span><br><span class="line"><span class="comment">// 两个函数的返回值，若成功，返回0；若出错，返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">recv_fd</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">ssize_t</span> (*userfunc) (<span class="keyword">int</span>, <span class="keyword">const</span> <span class="keyword">void</span> *, <span class="keyword">size_t</span>))</span></span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回文件描述符：若出错，返回负值</span></span><br></pre></td></tr></table></figure></p>
<p>当一个进程(通常是服务器进程)想将一个描述符传送给另一个进程时，可以调用<code>send_fd</code>或<code>send_err</code>。等待接收描述符的进程(客户进程)调用<code>recv_fd</code>。<code>send_fd</code>使用<code>fd</code>代表的UNIX域套接字发送描述符<code>fd_to_send</code>。<code>send_err</code>使用<code>fd</code>发送<code>errmsg</code>以及后随的<code>stahus</code>字节。<code>status</code>的值应在-1~—255。</p>
<p>客户进程调用<code>recv_fd</code>接收描述符。如果一切正常(发送者调用了<code>send_fd</code>)，则函数返回值为非负描述符。否则，返回值是由<code>send_err</code>发送的<code>status</code>(-1~—255的一个负值)。另外，如果服务器进程发送了一条出错消息，则客户进程调用它自己的<code>userfunc</code>函数处理该消息。<code>userfunc</code>的第一个参数是常量<code>STDERR_FILENO</code>，然后是指向出错消息的指针及其长度。<code>userfunc</code>函数的返回值是已写的字节数或负的出错编号值。客户进程常将普通的<code>write</code>函数指定为<code>userfunc</code>。</p>
<p>为发送一个描述符，<code>send_fd</code>先发送2字节0，然后是实际描述符。为了发送一条出错消息，<code>send_err</code>发送<code>errmsg</code>，然后是1字节0，最后是<code>status</code>字节的绝对值(1~255)。<code>recv_fd</code>函数读取套接字中所有字节直至遇到null字符。null字符之前的所有字符都传送给调用者的<code>userfunc</code>。<code>recv_fd</code>读取的下一个字节是状态(<code>status</code>)字节。若状态字节为0，则表示一个描述符已传送过来，否则表示没有描述符可接收。<code>send_err</code>函数在将出错消息写到套接字后，即调用<code>send_fd</code>函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Used when we had planned to send an fd using send_fd(),</span></span><br><span class="line"><span class="comment"> * but encountered an error instead.  We send the error back</span></span><br><span class="line"><span class="comment"> * using the send_fd()/recv_fd() protocol.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">send_err(<span class="keyword">int</span> fd, <span class="keyword">int</span> errcode, <span class="keyword">const</span> <span class="keyword">char</span> *msg)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span>		n;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((n = <span class="built_in">strlen</span>(msg)) &gt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">if</span> (writen(fd, msg, n) != n)	<span class="comment">/* send the error message */</span></span><br><span class="line">			<span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (errcode &gt;= <span class="number">0</span>)</span><br><span class="line">		errcode = <span class="number">-1</span>;	<span class="comment">/* must be negative */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (send_fd(fd, errcode) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为了用UNIX域套接字交换文件描述符，调用<code>sendmsg(2)</code>和<code>recvmsg(2)</code>函数。这两个函数的参数中都有一个指向<code>msghdr</code>结构的指针，该结构包含了所有关于要发送或要接收的消息的信息。该结构的定义大致如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> &#123;</span></span><br><span class="line">	<span class="keyword">void</span> *msg_name;        <span class="comment">/* optional address */</span></span><br><span class="line">	<span class="keyword">socklen_t</span> msg_namelen; <span class="comment">/* address size in bytes */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> *<span class="title">msg_iov</span>;</span> <span class="comment">/* array of I/O butters */</span></span><br><span class="line">	<span class="keyword">int</span> msg_iovlens        <span class="comment">/* number of elements in array */</span></span><br><span class="line">	<span class="keyword">void</span> *msg_control;     <span class="comment">/* ancillary data */</span></span><br><span class="line">	<span class="keyword">socklen_t</span> msg_controllen; <span class="comment">/* number of ancillery bytes */</span></span><br><span class="line">	<span class="keyword">int</span> msg_flags;            <span class="comment">/* flags for received message */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>前两个元素通常用于在网络连接上发送数据报，其中目的地址可以由每个数据报指定。接下来的两个元素使我们可以指定一个由多个缓冲区构成的数组(散布读和聚集写)，这与对<code>readv</code>和<code>writev</code>函数的说明一样。<code>msg_flags</code>字段包含了描述接收到的消息的标志，总结了这些标志。</p>
<p>两个元素处理控制信息的传送和接收。<code>msg_control</code>字段指向<code>cmsghdr</code>(整制信息头)结构，<code>msg_controllen</code>字段包含控制信息的字节数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmsghdr</span> &#123;</span></span><br><span class="line">	<span class="keyword">socklen_t</span> cmsg_len;  <span class="comment">/* data byte count, including header */</span></span><br><span class="line">	<span class="keyword">int</span> cmsg_level;      <span class="comment">/* originating protocol */</span></span><br><span class="line">	<span class="keyword">int</span> cmsg_type;       <span class="comment">/* protocol-specirie type */</span></span><br><span class="line">	<span class="comment">/* followed by the actual control message data */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在此定义3个宏，用于访问控制数据，一个宏用于帮助计算cmsg_len所使用的值。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">CMSG_DATA</span><span class="params">(struct cmsghdr* cp)</span></span>;</span><br><span class="line"><span class="comment">// 返回值：返回一个指针，指向与cmsghdr结构相关联的数据</span></span><br><span class="line"><span class="function">struct cmsghdr *<span class="title">CMSG_FIRSTHDR</span><span class="params">(struct msghdr* mp)</span></span>;</span><br><span class="line"><span class="comment">// 返回值，返回一个指针，指向与msghdr结构相关联的第一个cmsghdr结构，若无这样的结构，返回null</span></span><br><span class="line"><span class="function">struct cmsghdr *<span class="title">CMSG_NXTHDR</span><span class="params">(struct maghdr *mp, struct cmsghdr *cp)</span></span>;</span><br><span class="line"><span class="comment">// 返回值：返回一个指针，指向与msghdr结构相关联的下一个cmsghdr结构，该msghdr结构给出了当前的cmsghdr结构；若当前cmsghdr结构已是最后一个，返回NULL</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">CMSG_LEN</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> nbytes)</span></span>;</span><br><span class="line"><span class="comment">// 返回值。返回为nbytes长的数据对象分配的长度</span></span><br></pre></td></tr></table></figure></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Linux/" rel="tag"># Linux</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/06/02/UNIX高级编程 笔记6/" rel="next" title="UNIX高级编程 笔记6">
                <i class="fa fa-chevron-left"></i> UNIX高级编程 笔记6
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/06/19/北京地铁规划/" rel="prev" title="北京地铁2025年规划">
                北京地铁2025年规划 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/header.jpg" alt="Hao Yu">
            
              <p class="site-author-name" itemprop="name">Hao Yu</p>
              <p class="site-description motion-element" itemprop="description">Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author</p>
          </div>
          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">292</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>
        	<audio controls="controls" loop="loop" preload="auto" src="/resource/xiaomeihao.mp3">
	        </audio>
	

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yuhao0102" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:yuh18@mails.tsinghua.edu.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#网络IPC：套接字"><span class="nav-number">1.</span> <span class="nav-text">网络IPC：套接字</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#引言"><span class="nav-number">1.1.</span> <span class="nav-text">引言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#套接字描述符"><span class="nav-number">1.2.</span> <span class="nav-text">套接字描述符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#寻址"><span class="nav-number">1.3.</span> <span class="nav-text">寻址</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#宇节序"><span class="nav-number">1.3.1.</span> <span class="nav-text">宇节序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#地址格式"><span class="nav-number">1.3.2.</span> <span class="nav-text">地址格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#地址查询"><span class="nav-number">1.3.3.</span> <span class="nav-text">地址查询</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#将套接字与地址关联"><span class="nav-number">1.3.4.</span> <span class="nav-text">将套接字与地址关联</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#建立连接"><span class="nav-number">1.4.</span> <span class="nav-text">建立连接</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据传输"><span class="nav-number">1.5.</span> <span class="nav-text">数据传输</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#套接字选项"><span class="nav-number">1.6.</span> <span class="nav-text">套接字选项</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#带外数据"><span class="nav-number">1.7.</span> <span class="nav-text">带外数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#非阻塞和异步I-O"><span class="nav-number">1.8.</span> <span class="nav-text">非阻塞和异步I/O</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#高级进程间通信"><span class="nav-number">2.</span> <span class="nav-text">高级进程间通信</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#UNIX域套接字"><span class="nav-number">2.1.</span> <span class="nav-text">UNIX域套接字</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#命名UNIX域套接字"><span class="nav-number">2.1.1.</span> <span class="nav-text">命名UNIX域套接字</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#唯一连接"><span class="nav-number">2.2.</span> <span class="nav-text">唯一连接</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#传送文件描述符"><span class="nav-number">2.3.</span> <span class="nav-text">传送文件描述符</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>
  <div id="DvelopmentTarget">     
  </div>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart" aria-hidden="false"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>

  
</div>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_uv"> 
  本站访客数<span id="busuanzi_value_site_uv"></span>人次
</span>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  


  

  


  <script type="text/javascript" src="/js/src/love.js"></script>

</body>
</html>
