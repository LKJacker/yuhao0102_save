<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zn-ch">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-center-simple.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="C++,">










<meta name="description" content="新标准的诞生C++11语言变化的领域C++11相对于C++98/03有哪些显著的增强呢?事实上，这包括以下几点：  通过内存模型、线程、原子操作等来支持本地并行编程( Native Concurrency )。 通过统一.初始化表达式、auto、declytype、移动语义等来统一对泛型编程的支持。 通过constexpr、POD (概念)等更好地支持系统编程。 通过内联命名空间、继承构造函数和右">
<meta name="keywords" content="C++">
<meta property="og:type" content="article">
<meta property="og:title" content="深入理解C++11：C++11新特性解析与应用 笔记1">
<meta property="og:url" content="http://yoursite.com/2021/08/06/深入理解cpp11 笔记1/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="新标准的诞生C++11语言变化的领域C++11相对于C++98/03有哪些显著的增强呢?事实上，这包括以下几点：  通过内存模型、线程、原子操作等来支持本地并行编程( Native Concurrency )。 通过统一.初始化表达式、auto、declytype、移动语义等来统一对泛型编程的支持。 通过constexpr、POD (概念)等更好地支持系统编程。 通过内联命名空间、继承构造函数和右">
<meta property="og:locale" content="zn-ch">
<meta property="og:image" content="http://yoursite.com/img/1628403398.jpg">
<meta property="og:image" content="http://yoursite.com/img/1628403417.jpg">
<meta property="og:image" content="http://yoursite.com/img/1628477156.jpg">
<meta property="og:image" content="http://yoursite.com/img/1628492956.jpg">
<meta property="og:image" content="http://yoursite.com/img/1628501072.jpg">
<meta property="og:updated_time" content="2021-08-18T07:53:25.300Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="深入理解C++11：C++11新特性解析与应用 笔记1">
<meta name="twitter:description" content="新标准的诞生C++11语言变化的领域C++11相对于C++98/03有哪些显著的增强呢?事实上，这包括以下几点：  通过内存模型、线程、原子操作等来支持本地并行编程( Native Concurrency )。 通过统一.初始化表达式、auto、declytype、移动语义等来统一对泛型编程的支持。 通过constexpr、POD (概念)等更好地支持系统编程。 通过内联命名空间、继承构造函数和右">
<meta name="twitter:image" content="http://yoursite.com/img/1628403398.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2021/08/06/深入理解cpp11 笔记1/">





  <title>深入理解C++11：C++11新特性解析与应用 笔记1 | Hao Yu's blog</title>
  








 
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zn-ch">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hao Yu's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">The program monkey was eaten by the siege lion.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/resume.pdf" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-mybetterhalf">
          <a href="/mybetterhalf/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>
            
            mybetterhalf
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/08/06/深入理解cpp11 笔记1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">深入理解C++11：C++11新特性解析与应用 笔记1</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-08-06T14:14:00+08:00">
                2021-08-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="新标准的诞生"><a href="#新标准的诞生" class="headerlink" title="新标准的诞生"></a>新标准的诞生</h1><h2 id="C-11语言变化的领域"><a href="#C-11语言变化的领域" class="headerlink" title="C++11语言变化的领域"></a>C++11语言变化的领域</h2><p>C++11相对于C++98/03有哪些显著的增强呢?事实上，这包括以下几点：</p>
<ul>
<li>通过内存模型、线程、原子操作等来支持本地并行编程( Native Concurrency )。</li>
<li>通过统一.初始化表达式、auto、declytype、移动语义等来统一对泛型编程的支持。</li>
<li>通过constexpr、POD (概念)等更好地支持系统编程。</li>
<li>通过内联命名空间、继承构造函数和右值引用等，以更好地支持库的构建。</li>
</ul>
<p>表列出了C++11批准通过的，且本书将要涉及的语言特性。<br><img src="/img/1628403398.jpg" alt><br><img src="/img/1628403417.jpg" alt></p>
<h2 id="与硬件紧密合作"><a href="#与硬件紧密合作" class="headerlink" title="与硬件紧密合作"></a>与硬件紧密合作</h2><p>在C++11中，常量表达式以及原子操作都是可以用于支持嵌人式编程的重要特性。这些特性对于提高性能、降低存储空间都大有好处，比如ROM。C++98/03中也具备const类型，不过它对只读内存(ROM)支持得不够好。这是因为在C++中const类型只在初始化后才意味着它的值应该是常量表达式，从而在运行时不能被改变。不过由于初始化依旧是动态的，这对ROM设备来说并不适用。这就要求在动态初始化前就将常量计算出来。为此标准增加了constexpr，它让函数和变量可以被编译时的常量取代。</p>
<p>C++11 通过引入内存模型，为开发者和系统建立了一个高效的同步机制。作为开发者，通常需要保证线程程序能够正确同步，在程序中不会产生竞争。而相对地，系统(可能是编译器、内存系统，或是缓存一致性机制)则会保证程序员编写的程序(使用原子类型)不会引入数据竞争。而且为了同步，系统会自行禁止某些优化，又保证其他的一些优化有效。除非编写非常底层的并行程序，否则系统的优化对程序员来讲，基本上是透明的。这可能是C++11中最大、最华丽的进步。</p>
<p>就算程序员不乐意使用原子类型，而要使用线程，那么使用标准的互斥变量mutex来进行临界区的加锁和开锁也就够了。而如果读者还想要疯狂地挖掘并行的速度，或试图完全操控底层，或想找点麻烦，那么无锁( lock-free)的原子类型也可以满足你的各种“野心”。内存模型的机制会保证你不会犯错。只有在使用与系统内存单位不同的位域的时候，内存模型才无法成功地保证同步。比如说下面这个位域的例子，这样的位域常常会引发竞争(跨了一个内存单元)，因为这破坏了内存模型的假定，编译器不能保证这是没有竞争的。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span><span class="keyword">int</span> a:<span class="number">9</span>; <span class="keyword">int</span> b:<span class="number">7</span>;&#125;</span><br></pre></td></tr></table></figure></p>
<p>不过如果使用下面的字符位域则不会引发竞争，因为字符位域可以被视为是独立内存位置。而在C++98/03 中，多线程程序中该写法却通常会引发竞争。这是因为编译器可能将a和b连续存放，那么对b进行赋值(互斥地)的时候就有可能在a没有被上锁的情况下一起写掉了。原因是在单线程情况下常被视为普通的安全的优化，却没有考虑到多线程情况下的复杂性。C++11 则在这方面做出了较好的修正。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span><span class="keyword">char</span> a; <span class="keyword">char</span> b;&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="融入编程现实"><a href="#融入编程现实" class="headerlink" title="融入编程现实"></a>融入编程现实</h2><p>如今GNU的属性( attribute)几乎无所不在，所有的编译器都在尝试支持它，以用于修饰类型、变量和函数等。不过<code>__attribute__((attribute-name))</code>这样的写法，除了不怎么好看外，每一个编译器可能还都有它自己的变体，比如微软的属性就是以<code>__declspec</code>打头的。因此在C++11中，我们看到了通用属性的出现。</p>
<p>不过C++11引入通用属性更大的原因在于，属性可以在不引入额外的关键字的情况下，为编译提供额外的信息。因此，一些可以实现为关键字的特性，也可以用属性来实现。C++11标准最终选择创建很少的几个通用属性，<code>noreturn</code>和<code>carrier_dependency</code>(其实final、override也一度是热门“人选” )。</p>
<h1 id="保证稳定性和兼容性"><a href="#保证稳定性和兼容性" class="headerlink" title="保证稳定性和兼容性"></a>保证稳定性和兼容性</h1><p>作为C语言的嫡亲，C++有一个众所周知的特性——对C语言的高度兼容。</p>
<h2 id="保持与C99兼容"><a href="#保持与C99兼容" class="headerlink" title="保持与C99兼容"></a>保持与C99兼容</h2><p>虽然C语言发展中的大多数改进都被引入了C++语言标准中，但还是存在着一些属于C99标准的“漏网之鱼”。所以C++11将对以下C99特性的支持也都纳入了新标准中：</p>
<ul>
<li>C99中的预定义宏</li>
<li><code>__func__</code>预定义标识符</li>
<li><code>_Pragma</code>操作符</li>
<li>不定参数宏定义以及<code>__VA_ARGS__</code></li>
<li>宽窄字符串连接</li>
</ul>
<h3 id="预定义宏"><a href="#预定义宏" class="headerlink" title="预定义宏"></a>预定义宏</h3><p>相较于C89标准，C99语言标准增加一些预定义宏。C++11 同样增加了对这些宏的支持。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>宏名称</th>
<th>功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>__STDC_HOSTED__</code></td>
<td>如果编译器的目标系统环境中包含完整的标准C库，那么这个宏就定义为1，否则宏的值为0</td>
</tr>
<tr>
<td><code>__STDC__</code></td>
<td>C编译器通常用这个宏的值来表示编译器的实现是否和C标准一致。 C++11标准中这个宏是否定义以及定成什么值由编译器来决定</td>
</tr>
<tr>
<td><code>__STDC_VERSION__</code></td>
<td>C编译器通常用这个宏来表示所支持的C标准的版本，比如1999mmL。C++11 标准中这个宏是否定义以及定成什么值将由编译器来决定</td>
</tr>
<tr>
<td><code>__STDC_ISO_10646__</code></td>
<td>这个宏通常定义为一个yyymmL格式的整数常量，例如199712L，用来表示C++编译环境符合某个版本的ISO/IEC 10646标准</td>
</tr>
</tbody>
</table>
</div>
<p>使用这些宏，我们可以查验机器环境对C标准和C库的支持状况，如代码所示。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Standard Clib:"</span> &lt;&lt; __STDC_HOSTED__&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// Standard Clib: 1</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"ISO/IEC"</span> &lt;&lt; __STDC_ISO_10646__&lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">    <span class="comment">// ISO/IEC 200009</span></span><br><span class="line">    <span class="comment">//编译选项：g++ -std=c++11 2-1-1.cpp</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>预定义宏对于多目标平台代码的编写通常具有重大意义。通过以上的宏，程序员通过使用<code>#ifdef/#endif</code>等预处理指令，就可使得平台相关代码只在适合于当前平台的代码上编译，从而在同一套代码中完成对多平台的支持。从这个意义上讲，平台信息相关的宏越丰富，代码的多平台支持越准确。不过值得注意的是，与所有预定义宏相同的，如果用户重定义(<code>#define</code>)或<code>#undef</code>了预定义的宏，那么后果是“未定义”的。因此在代码编写中，程序员应该注意避免自定义宏与预定义宏同名的情况。</p>
<h3 id="func预定义标识符"><a href="#func预定义标识符" class="headerlink" title="func预定义标识符"></a><strong>func</strong>预定义标识符</h3><p>很多现实的编译器都支持C99标准中的<code>__func__</code>预定义标识符功能，其基本功能就是返回所在函数的名字。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">hello</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> __func__; &#125;</span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">world</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> __func__; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; hello() &lt;&lt; <span class="string">", "</span> &lt;&lt; world() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// hello, world</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编译选项：g++ -std=c++11 2-1-2.ccpp</span></span><br></pre></td></tr></table></figure></p>
<p>按照标准定义，编译器会隐式地在函数的定义之后定义<code>__func__</code>标识符。比如上述例子中的hello函数，其实际的定义等同于如下代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span>* __func__= <span class="string">"hello"</span>;</span><br><span class="line">    <span class="keyword">return</span> __func__;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>__func__</code>预定义标识符对于轻量级的调试代码具有十分重要的作用。而在C++11中，标准甚至允许其使用在类或者结构体中。我们可以看看下面这个例子。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TestStruct</span> &#123;</span></span><br><span class="line">    TestStruct () : name(__func__) &#123;&#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Teststruct ts;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ts.name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// TestStruct</span></span><br><span class="line"><span class="comment">//编译选项：g++ -std=c++11 2-1-3.ccpp</span></span><br></pre></td></tr></table></figure></p>
<p>在结构体的构造函数中，初始化成员列表使用<code>__func__</code>预定义标识符是可行的，其效果跟在函数中使用一样。不过将<code>__fun__</code>标识符作为函数参数的默认值，如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FuncFail</span><span class="params">(<span class="built_in">string</span> func_name = __func__)</span> </span>&#123; &#125;; <span class="comment">// 无法通过编译</span></span><br></pre></td></tr></table></figure></p>
<h3 id="Pragma-操作符"><a href="#Pragma-操作符" class="headerlink" title="_Pragma 操作符"></a>_Pragma 操作符</h3><p>在C/C++标准中，<code>#pragma</code>是预处理的指令(preprocessor directive)。简单地说，#pragma是用来向编译器传达语言标准以外的一些信息。举个简单的例子，如果我们在代码的头文件中定义了以下语句：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br></pre></td></tr></table></figure></p>
<p>那么该指令会指示编译器(如果编译器支持)，该头文件应该只被编译一次。这与使用如下代码来定义头文件所达到的效果是一样的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> THIS_HEADER</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THIS_HEADER</span></span><br><span class="line"><span class="comment">//一些头文件的定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>在C++11中，标准定义了与预处理指令<code>#pragma</code>功能相同的操作符<code>_Pragma</code>。<code>_Pragma</code>操作符的格式如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_Pragma ( 字符串字面量)</span><br></pre></td></tr></table></figure></p>
<p>其使用方法跟sizeof等操作符一样，将字符串字面量作为参数写在括号内即可。那么要达到与上例<code>#pragma</code>类似的效果，则只需要如下代码即可。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_Pragma (<span class="string">"once"</span>);</span><br></pre></td></tr></table></figure></p>
<p>而相比预处理指令<code>#pragma</code>，由于<code>_Pragma</code>是一个操作符，因此可以用在一些宏中。我们可以看看下面这个例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONCAT(x) PRAGMA (concat on #x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRAGMA(x) _Pragma (#x)</span></span><br><span class="line">CONCAT( ..\concat.dir )</span><br></pre></td></tr></table></figure></p>
<p>这里，<code>CONCAT( ..\concat.dir )</code>最终会产生<code>_Pragma(concat on &quot;..\concat.dir&quot;)</code>这样的效果(这里只是显示语法效果，应该没有编译器支持这样的<code>_Pragma</code>语法)。而<code>#pragma</code>则不能在宏中展开，因此从灵活性上来讲，C++11的<code>_Pragma</code>具有更大的灵活性。</p>
<h3 id="变长参数的宏定义以及-VA-ARGS"><a href="#变长参数的宏定义以及-VA-ARGS" class="headerlink" title="变长参数的宏定义以及 VA_ARGS"></a>变长参数的宏定义以及 <strong>VA_ARGS</strong></h3><p>在C99标准中，程序员可以使用变长参数的宏定义。变长参数的宏定义是指在宏定义中参数列表的最后一个参数为省略号，而预定义宏<code>__VA_ARGS__</code>则可以在宏定义的实现部分替换省略号代表的字符串。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PR(...) printf(__VA_ARGS__)</span></span><br></pre></td></tr></table></figure></p>
<p>就可以定义一个printf的别名PR。事实上，变长参数宏与printf是好搭档：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG(...) &#123;\</span></span><br><span class="line">    <span class="built_in">fprintf</span> (<span class="built_in">stderr</span>, <span class="string">"%s: Line %d:\t"</span>，__FILE__, __LINE__); \</span><br><span class="line">    <span class="built_in">fprintf</span> (<span class="built_in">stderr</span>, __VA_ARGS__); \</span><br><span class="line">    <span class="built_in">fprintf</span> (<span class="built_in">stderr</span>, <span class="string">"\n"</span>); \</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">3</span>;</span><br><span class="line">    <span class="comment">//一些代码</span></span><br><span class="line">    LOG(<span class="string">"x = &amp;d"</span>, x); <span class="comment">// 2-1-5.cpp: Line 12:    X=3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编译选项：g++ -std=c++11 2-1-5.cpp</span></span><br></pre></td></tr></table></figure></p>
<p>定义LOG宏用于记录代码位置中一些信息。程序员可以根据stderr产生的日志追溯到代码中产生这些记录的位置。这样的特性对于轻量级调试，简单的错误输出都是具有积极意义的。</p>
<h2 id="long-long整型"><a href="#long-long整型" class="headerlink" title="long long整型"></a>long long整型</h2><p>相比于C++98标准，C++11整型的最大改变就是多了long long。long long整型有两种：long long和unsigned long long。在C++11中，标准要求long long整型可以在不同平台上有不同的长度，但至少有64位。我们在写常数字面量时，可以使用LL后缀(或是ll)标识一个long long类型的字面量，而ULL (或ull、Ull、uLL)表示一个unsigned long long类型的字面量。比如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> lli = <span class="number">-9000000000000000000L</span>L;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> ulli = - <span class="number">900000000000000000U</span>LL;</span><br></pre></td></tr></table></figure></p>
<p>就定义了一个有符号的long long变量<code>lli</code>和无符号的unsigned long long变量<code>ulli</code>。事实上，在C++11中，还有很多与long long等价的类型。比如对于有符号的，下面的类型是等价的：<code>long long</code>、<code>signed long long</code>、<code>long long int</code>、<code>signed long long int</code>；而<code>unsigned long long</code>和<code>unsigned long long int</code>也是等价的。</p>
<p>同其他的整型一样，要了解平台上<code>long long</code>大小的方法就是查看<code>&lt;climits&gt;</code> (或<code>&lt;limits.h&gt;</code>中的宏)。与<code>long long</code>整型相关的一共有3个：<code>LLONG_MIN</code>、<code>LLONG_MAX</code>和<code>ULLONG_MIN</code>，它们分别代表了平台上最小的long long值、最大的long long值，以及最大的unsigned long long值。</p>
<h2 id="扩展的整型"><a href="#扩展的整型" class="headerlink" title="扩展的整型"></a>扩展的整型</h2><p>程序员常会在代码中发现一些整型的名字，比如<code>UINT</code>、<code>__int16</code>、<code>u64</code>、<code>int64_t</code>等等。这些类型有的源自编译器的自行扩展，有的则是来自某些编程环境(比如工作在Linux内核代码中)，不一而足。而事实上，在C++11中一共只定义了以下5种标准的有符号整型：</p>
<ul>
<li><code>signed char</code></li>
<li><code>short int</code></li>
<li><code>int</code></li>
<li><code>long int</code></li>
<li><code>long long int</code></li>
</ul>
<p>标准同时规定，每一种有符号整型都有一种对应的无符号整数版本，且有符号整型与其对应的无符号整型具有相同的存储空间大小。比如与signed int对应的无符号版本的整型是unsigned int。</p>
<p>在实际的编程中，由于这5种基本的整型适用性有限，所以有时编译器出于需要，也会自行扩展一些整型。在C++11中，标准对这样的扩展做出了一些规定。具体地讲，除了标准整型( standard integer type)之外，C++11 标准允许编译器扩展自有的所谓扩展整型(extended integer type)。这些扩展整型的长度(占用内存的位数)可以比最长的标准整型(long long int，通常是一个64位长度的数据)还长，也可以介于两个标准整数的位数之间。比如在128位的架构上，编译器可以定义一个扩展整型来对应128位的的整数。</p>
<p>简单地说，C++11 规定，扩展的整型必须和标准类型一样，有符号类型和无符号类型占用同样大小的内存空间。而由于C/C++是一种弱类型语言，当运算、传参等类型不匹配的时候，整型间会发生隐式的转换，这种过程通常被称为整型的提升( Integral promotion)。 比如如下表达式：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">int</span>) a + (<span class="keyword">long</span> <span class="keyword">long</span>)b</span><br></pre></td></tr></table></figure></p>
<p>通常就会导致变量<code>(int)a</code>被提升为<code>long long</code>类型后才与<code>(long long)b</code>进行运算。而无论是扩展的整型还是标准的整型，其转化的规则会由它们的“等级”(rank)决定。而通常情况，我们认为有如下原则：</p>
<ul>
<li>长度越大的整型等级越高，比如long long int的等级会高于int。</li>
<li>长度相同的情况下，标准整型的等级高于扩展类型，比如long long int 和int64如果都是64位长度，则long long int类型的等级更高。</li>
<li>相同大小的有符号类型和无符号类型的等级相同，long long int和unsigned longlong int的等级就相同。</li>
</ul>
<p>而在进行隐式的整型转换的时候，一般是按照低等级整型转换为高等级整型，有符号的转换为无符号。这种规则其实跟C++98的整型转换规则是一致的。</p>
<p>在一个128位的构架上，编译器可以定义<code>__int128_t</code>为128位的有符号整型(对应的无符号类型为<code>_uint128_t</code>)。于是程序员可以使用<code>_int128_t</code>类型保存形如+92233720368547758070的超长整数(长于64位的自然数)。而不用查看编译器文档我们也会知道，一旦遇到整型提升，按照上面的规则，比如<code>_int128_t a</code>，与任何短于它的类型的数据b进行运算(比如加法)时，都会导致b被隐式地转换为<code>_int128_t</code>的整型，因为扩展的整型必须遵守C++11的规范。</p>
<h2 id="宏-cplusplus"><a href="#宏-cplusplus" class="headerlink" title="宏__cplusplus"></a>宏__cplusplus</h2><p>在C与C++混合编写的代码中，我们常常会在头文件里看到如下的声明：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">//一些代码</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>这种类型的头文件可以被<code>#include</code>到C文件中进行编译，也可以被<code>#include</code>到C++文件中进行编译。由于<code>extern &quot;C&quot;</code>可以抑制C++对函数名、变量名等符号( symbol)进行名称重整( name mangling)，因此编译出的C目标文件和C++目标文件中的变量、函数名称等符号都是相同的(否则不相同)，链接器可以可靠地对两种类型的目标文件进行链接。这样该做法成为了C与C++混用头文件的典型做法。</p>
<p>鉴于以上的做法，程序员可能认为<code>__cplusplus</code>这个宏只有“被定义了”和“未定义”两种状态。事实上却并非如此，<code>__cplusplus</code>这个宏通常被定义为一个整型值。而且随着标准变化，<code>_cplusplus</code>宏会是一个比以往标准中更大的值。比如在C++03标准中，<code>__cplusplus</code>的值被预定为199711L，而在C++11标准中，宏<code>__cplusplus</code>被预定义为201103L。这点变化可以为代码所用。比如程序员在想确定代码是使用支持C++11编译器进行编译时，那么可以按下面的方法进行检测：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __cplusplus &lt; 201103L</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">error</span> <span class="meta-string">"should use C++11 implementat ion”</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">#endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>这里，使用了预处理指令<code>#error</code>，这使得不支持C++11的代码编译立即报错并终止编译。读者可以使用C++98编译器和C++11的编译器分别实验一下其效果。</p>
<h2 id="静态断言"><a href="#静态断言" class="headerlink" title="静态断言"></a>静态断言</h2><h3 id="断言：运行时与预处理时"><a href="#断言：运行时与预处理时" class="headerlink" title="断言：运行时与预处理时"></a>断言：运行时与预处理时</h3><p>断言(assertion)是一种编程中常用的手段。在通常情况下，断言就是将一个返回值总是需要为真的判别式放在语句中，用于排除在设计的逻辑上不应该产生的情况。比如一个函数总需要输入在一定的范围内的参数，那么程序员就可以对该参数使用断言，以迫使在该参数发生异常的时候程序退出，从而避免程序陷入逻辑的混乱。</p>
<p>从一些意义.上讲，断言并不是正常程序所必需的，不过对于程序调试来说，通常断言能够帮助程序开发者快速定位那些违反了某些前提条件的程序错误。在C++中，标准在<code>&lt;cassert&gt;</code>或<code>&lt;assert.h&gt;</code>头文件中为程序员提供了assert宏，用于在运行时进行断言。我们可以看看下面这个例子。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//一个简单的堆内存数组分配函数</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">ArrayAlloc</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    assert(n &gt; <span class="number">0</span>); <span class="comment">// 断言，n必须大于0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">char</span> [n] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* a = ArrayAlloc(<span class="number">0</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编译选项：g++ 2-5-1. cpp</span></span><br></pre></td></tr></table></figure></p>
<p>在代码中，我们定义了一个<code>ArrayAlloc</code>函数，该函数的唯一功能就是在堆上分配字节长度为n的数组并返回。为了避免意外发生，函数ArrayAlloc对参数n进行了断言，要求其大于0。而<code>main</code>函数中对<code>ArrayAlloc</code>的使用却没有满足这个条件，那么在运行时，我们可以看到如下结果：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a.out: 2-5-1.cpp:6: char* ArrayAlloc(int): Assertion : <span class="string">'n &gt; 0'</span> failed.</span><br><span class="line">Aborted</span><br></pre></td></tr></table></figure></p>
<p>在C++中，程序员也可以定义宏NDEBUG来禁用assert宏。这对发布程序来说还是必要的。因为程序用户对程序退出总是敏感的，而且部分的程序错误也未必会导致程序全部功能失效。那么通过定义NDEBUG宏发布程序就可以尽量避免程序退出的状况。而当程序有问题时，通过没有定义宏NDEBUG的版本，程序员则可以比较容易地找到出问题的位置。</p>
<p>事实上，<code>assert</code>宏在<code>&lt;cassert&gt;</code>中的实现方式类似于下列形式：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> NDEBUG</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> assert (expr) (static_cast<span class="meta-string">&lt;void&gt; (0))</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>可以看到，一旦定义了NDBUG宏，<code>assert</code>宏将被展开为一条无意义的C语句(通常会被编译器优化掉)。</p>
<h3 id="静态断言与static-assert"><a href="#静态断言与static-assert" class="headerlink" title="静态断言与static_assert"></a>静态断言与static_assert</h3><p>断言<code>assert</code>宏只有在程序运行时才能起作用。而<code>#error</code>只在编译器预处理时才能起作用。有的时候，我们希望在编译时能做一些断言。 比如下面这个例子。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//枚举编译器对各种特性的支持，每个枚举值占一位</span></span><br><span class="line"><span class="keyword">enum</span> FeatureSupports &#123;</span><br><span class="line">    C99      = <span class="number">0x0001</span>,</span><br><span class="line">    ExtInt   = <span class="number">0x0002</span>,</span><br><span class="line">    SAssert  = <span class="number">0x0004</span>,</span><br><span class="line">    NoExcept = <span class="number">0x0008</span>,</span><br><span class="line">    SMAX     = <span class="number">0x0010</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一个编译器类型，包括名称、特性支持等</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Compiler</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * name ; </span><br><span class="line">    <span class="keyword">int</span> spp;  <span class="comment">// 使用FeatureSupports枚举</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//检查枚举值是否完备</span></span><br><span class="line">    assert( (SMAX - <span class="number">1</span>) == (C99| ExtInt| SAssert| NoExcept)) ;</span><br><span class="line">    Compiler a = &#123;<span class="string">"abc"</span>, (C99| SAssert) &#125;;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (a.spp &amp; C99) &#123;</span><br><span class="line">        <span class="comment">//一些代码...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编译选项：g++ 2-5-2. cpp .</span></span><br></pre></td></tr></table></figure></p>
<p>在该例中，我们编写了一个枚举类型<code>FeatureSupports</code>，用于列举编译器对各种特性的支持。而结构体Compiler则包含了一个int类型成员spp。由于各种特性都具有“支持”和“不支持”两种状态，所以为了节省存储空间，我们让每个<code>FeatureSupports</code>的枚举值占据一个特定的比特位置，并在使用时通过“或”运算压缩地存储在Compiler的spp成员中( 即<code>bitset</code>的概念)。在使用时，则可以通过检查spp的某位来判断编译器对特性是否支持。</p>
<p>有的时候这样的枚举值会非常多，而且还会在代码维护中不断增加。那么代码编写者必须想出办法来对这些枚举进行校验，比如查验一下 是否有重位等。在本例中程序员的做法是使用一个“最大枚举”<code>SMAX</code>，并通过比较<code>SMAX - 1</code>与所有其他枚举的或运算值来验证是否有枚举值重位。可以想象，如果<code>SAssert</code>被误定义为<code>0x0001</code>，表达式<code>(SMAX- 1) == (C99 | ExtInt | SAssert | NoExcept)</code>将不再成立。</p>
<p>在本例中我们使用了断言assert。但assert是一个运行时的断言，这意味着不运行程序我们将无法得知是否有枚举重位。在一些情况下，这是不可接受的，因为可能单次运行代码并不会调用到assert相关的代码路径。因此这样的校验最好是在编译时期就能完成。在一些C++的模板的编写中，我们可能也会遇到相同的情况，比如下面这个例子。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T，<span class="keyword">typename</span> U&gt; <span class="function"><span class="keyword">int</span> <span class="title">bit_copy</span><span class="params">(T&amp; a, U&amp; b)</span> </span>&#123;</span><br><span class="line">    assert (<span class="keyword">sizeof</span>(b) == <span class="keyword">sizeof</span>(a));</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;a, &amp;b, <span class="keyword">sizeof</span> (b));</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0x2468</span>;</span><br><span class="line">    <span class="keyword">double</span> b</span><br><span class="line">    bit_copy(a, b) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编译选项：g++ 2-5-3. cpp</span></span><br></pre></td></tr></table></figure></p>
<p>代码中的assert是要保证a和b两种类型的长度一致，这样<code>bit_copy</code>才能够保证复制操作不会遇到越界等问题。这里我们还是使用assert的这样的运行时断言，但如果<code>bit_copy</code>不被调用，我们将无法触发该断言。实际上，正确产生断言的时机应该在模板实例化时，即编译时期。</p>
<p>利用语言规则实现静态断言的讨论非常多，比较典型的实现是开源库Boost内置的<code>BOOST_STATIC_ASSERT</code>断言机制( 利用sizeof操作符)。我们可以利用“除0”会导致编译器报错这个特性来实现静态断言。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> assert_static(e) \</span></span><br><span class="line"><span class="keyword">do</span> &#123; \</span><br><span class="line">    <span class="keyword">enum</span> &#123; assert_static__= <span class="number">1</span>/(e) &#125;; \</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure></p>
<p>在理解这段代码时，读者可以忽略do while循环以及enum这些语法上的技巧。真正起作用的只是<code>1/(e)</code>这个表达式。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T，<span class="keyword">typename</span> U&gt; <span class="function"><span class="keyword">int</span> <span class="title">bit_copy</span><span class="params">(T&amp; a, U&amp; b)</span></span>&#123;</span><br><span class="line">    assert_static(<span class="keyword">sizeof</span>(b) == <span class="keyword">sizeof</span>(a)) ;</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;a, &amp;b, <span class="keyword">sizeof</span>(b)) ;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0x2468</span>;</span><br><span class="line">    <span class="keyword">double</span> b;</span><br><span class="line">    bit_copy(a, b) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编译选项：g++ -std=c++11 2-5-4. cpp</span></span><br></pre></td></tr></table></figure></p>
<p>结果如我们预期的，在模板实例化时我们会得到编译器的错误报告，读者可以实验一下在自己本机运行的结果。在我们的实验机上会输出比较长的错误信息，主要信息是除零错误。当然，读者也可以尝试一下Boost库内置的<code>BOOST_STATIC_ASSERT</code>，输出的主要信息是<code>sizeof</code>错误。但无论是哪种方式的静态断言，其缺陷都是很明显的：诊断信息不够充分，不熟悉该静态断言实现的程序员可能一时无法将错误对应到断言错误上，从而难以准确定位错误的根源。</p>
<p>在C++11标准中，引入了<code>static_assert</code>断言来解决这个问题。<code>static_assert</code>使用起来非常简单，它接收两个参数，一个是断言表达式，这个表达式通常需要返回一个bool值；一个则<br>是警告信息，它通常也就是一段字符串。我们可以用<code>static_assert</code>替换一下代码中<code>bit_copy</code>的声明。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> t, <span class="keyword">typename</span> u&gt; <span class="function"><span class="keyword">int</span> <span class="title">bit_copy</span><span class="params">(t&amp; a, u&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static_assert</span> (<span class="keyword">sizeof</span>(b) == <span class="keyword">sizeof</span> (a) , <span class="string">"the parameters of bit_copy must have same width."</span>) ;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>那么再次编译代码清单2-9的时候，我们就会得到如下信息：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: static assertion failed: <span class="string">"the parameters of bit_copy should have same width. "</span></span><br></pre></td></tr></table></figure></p>
<p>这样的错误信息就非常清楚，也非常有利于程序员排错。而由于<code>static_assert</code>是编译时期的断言，其使用范围不像assert一样受到限制。在通常情况下，<code>static_assert</code>可以用于任何名字空间，如代码所示。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static_assert</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) == <span class="number">8</span>，<span class="string">"This 64-bit machine should follow this!"</span>) ;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line"><span class="comment">//编译选项：g++ -std=C++11 2-5-5.ccpp</span></span><br></pre></td></tr></table></figure></p>
<p>而在C++中，函数则不可能像代码中的<code>static_assert</code>这样独立于任何调用之外运行。因此将<code>static_assert</code>写在函数体外通常是较好的选择，这让代码阅读者可以较容易发现<code>static_assert</code>为断言而非用户定义的函数。而反过来讲，必须注意的是，<code>static_assert</code>的断言表达式的结果必须是在编译时期可以计算的表达式，即必须是常量表达式。如果读者使用<br>了变量，则会导致错误，如代码所示。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">positive</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static_assert</span>(n &gt; <span class="number">0</span>，<span class="string">"value must &gt;0"</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编译选项：g++ -std=C++11 -c 2-5-6. ccpp</span></span><br></pre></td></tr></table></figure></p>
<p>代码使用了参数变量<code>n</code>(虽然是个const参数)，因而<code>static_assert</code>无法通过编译。对于此例，如果程序员需要的只是运行时的检查，那么还是应该使用assert宏。</p>
<h2 id="noexcept修饰符与noexcept操作符"><a href="#noexcept修饰符与noexcept操作符" class="headerlink" title="noexcept修饰符与noexcept操作符"></a>noexcept修饰符与noexcept操作符</h2><p>相比于断言适用于排除逻辑上不可能存在的状态，异常通常是用于逻辑上可能发生的错误。在C++98中，我们看到了一套完整的不同于C的异常处理系统。通过这套异常处理系统，C++拥有了远比C强大的异常处理功能。</p>
<p>在异常处理的代码中，程序员有可能看到过如下的异常声明表达形式：.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">excpt_func</span><span class="params">()</span> <span class="title">throw</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">double</span>)</span></span>&#123; ... &#125;</span><br></pre></td></tr></table></figure></p>
<p>在<code>excpt_func</code>函数声明之后，我们定义了一个动态异常声明<code>throw(int, double)</code>，该声明指出了<code>excpt_func</code>可能抛出的异常的类型。事实上，该特性很少被使用，因此在C++11中被弃用了，而表示函数不会抛出异常的动态异常声明<code>throw()</code>也被新的<code>noexcept</code>异常声明所取代。</p>
<p><code>noexcept</code>表示其修饰的函数不会抛出异常。不过与<code>throw()</code>动态异常声明不同的是，在C++11中如果<code>noexcept</code>修饰的函数抛出了异常，编译器可以选择直接调用<code>std:terminate()</code>函数来终止程序的运行，这比基于异常机制的<code>throw()</code>在效率上会高一些。</p>
<p>从语法上讲，<code>noexcept</code>修饰符有两种形式，一种就是简单地在函数声明后加上<code>noexcept</code>关键字。比如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">excpt_func</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>; .</span><br></pre></td></tr></table></figure></p>
<p>另外一种则可以接受一个常量表达式作为参数，如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">excpt_func</span><span class="params">()</span> <span class="title">noexcept</span> <span class="params">( 常量表达式)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>常量表达式的结果会被转换成一个bool类型的值。该值为true，表示函数不会抛出异常，反之，则有可能抛出异常。这里，不带常量表达式的<code>noexcept</code>相当于声明了<code>noexcept(true)</code>，即不会抛出异常。</p>
<p>在通常情况下，在C++11中使用<code>noexcept</code>可以有效地阻止异常的传播与扩散。我们可以看看下面这个例子。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Throw</span><span class="params">()</span> </span>&#123; <span class="keyword">throw</span> <span class="number">1</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NoBlockThrow</span><span class="params">()</span> </span>&#123; Throw(); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BlockThrow</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; Throw() ;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Throw() ;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(...) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Found throw."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">// Found throw.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        NoBlockThrow() ;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(...) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Throw is not blocked."</span> &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">        <span class="comment">// Throw is not blocked .</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        BlockThrow(); <span class="comment">// terminate called after throwing an instance of ' int '</span></span><br><span class="line">    &#125; <span class="keyword">catch</span>(...) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Found throw 1."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译选项：g++ -std=c++11 2-6-1. ccpp .</span></span><br></pre></td></tr></table></figure></p>
<p>在代码中，我们定义了<code>Throw</code>函数，该函数的唯一作用是抛出一个异常。而<code>NoBlockThrow</code>是一个调用<code>Throw</code>的普通函数，<code>BlockThrow</code>则是一个<code>noexcept</code>修饰的函数。从main的运行中我们可以看到，<code>NoBlockThrow</code>会让<code>Throw</code>函数抛出的异常继续抛出，直到main中的catch语句将其捕捉。而<code>BlockThrow</code>则会直接调用<code>std::terminate</code>中断程序的执行，从而阻止了异常的继续传播。从使用效果上看，这与C++98中的<code>throw()</code>是一样的。</p>
<p>而<code>noexcept</code>作为一个操作符时，通常可以用于模板。比如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">fun</span>() <span class="title">noexcept</span> (<span class="title">noexcept</span> (<span class="title">T</span>())) &#123;</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里，<code>fun</code>函数是否是一个<code>noexcept</code>的函数，将由<code>T()</code>表达式是否会抛出异常所决定。这里的第二个<code>noexcept</code>就是一个<code>noexcept</code>操作符。当其参数是一个有可能抛出异常的表达式的时候，其返回值为false，反之为true。这样一来，我们就可以使模板函数根据条件实现<code>noexcept</code>修饰的版本或无<code>noexcept</code>修饰的版本。从泛型编程的角度看来，这样的设计保证了关于“ 函数是否抛出异常”这样的问题可以通过表达式进行推导。因此这也可以视作C++11为了更好地支持泛型编程而引入的特性。</p>
<p>虽然<code>noexcept</code>修饰的函数通过<code>std::terminate</code>的调用来结束程序的执行的方式可能会带来很多问题，比如无法保证对象的析构函数的正常调用，无法保证栈的自动释放等，但很多时候，“暴力”地终止整个程序确实是很简单有效的做法。比如在C++98中，存在着使用<code>throw()</code>来声明不抛出异常的函数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">constexpr</span> T <span class="title">min</span><span class="params">()</span> <span class="title">throw</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> T() ; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">constexpr</span> T <span class="title">max</span><span class="params">()</span> <span class="title">throw</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> T() ;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">constexpr</span> T <span class="title">lowest</span><span class="params">()</span> <span class="title">throw</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> T() ;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>而在C++11中，则使用<code>noexcept</code>来替换<code>throw()</code>。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">constexpr</span> T <span class="title">min</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> T() ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">constexpr</span> T <span class="title">max</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> T() ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">constexpr</span> T <span class="title">lowest</span><span class="params">()</span> <span class="keyword">noexcept</span></span>&#123; <span class="keyword">return</span> T(); &#125;</span><br></pre></td></tr></table></figure></p>
<p>又比如，在C++98中，<code>new</code>可能会包含一些抛出的<code>std::bad_alloc</code> 异常。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span>)</span> <span class="title">throw</span><span class="params">(<span class="built_in">std</span>::bad_alloc)</span> </span>;</span><br><span class="line"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[] (<span class="built_in">std</span>::<span class="keyword">size_t</span>) <span class="keyword">throw</span>(<span class="built_in">std</span>::bad_alloc) ;</span><br></pre></td></tr></table></figure></p>
<p>而在C++11中，则使用<code>noexcept(false)</code>来进行替代。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span>)</span> <span class="title">noexcept</span> <span class="params">(<span class="literal">false</span>)</span> </span>;</span><br><span class="line"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[] (<span class="built_in">std</span>::<span class="keyword">size_t</span>) <span class="keyword">noexcept</span> (<span class="literal">false</span>) ;</span><br></pre></td></tr></table></figure></p>
<p>当然，<code>noexcept</code>更大的作用是保证应用程序的安全。比如一个类析构函数不应该抛出异常，那么对于常被析构函数调用的<code>delete</code>函数来说，C++11默认将<code>delete</code>函数设置成<code>noexcept</code>，就可以提高应用程序的安全性。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span> <span class="params">(<span class="keyword">void</span>*)</span> <span class="keyword">noexcept</span> </span>; </span><br><span class="line"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[] (<span class="keyword">void</span>*) <span class="keyword">noexcept</span>;</span><br></pre></td></tr></table></figure></p>
<p>而同样出于安全考虑，C++11 标准中让类的析构函数默认也是<code>noexcept(true)</code>的。当然，如果程序员显式地为析构函数指定了<code>noexcept</code>，或者类的基类或成员有<code>noexcept(false)</code>的析构函数，析构函数就不会再保持默认值。我们可以看看下面的例子。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    ~A() &#123; <span class="keyword">throw</span> <span class="number">1</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> &#123;</span></span><br><span class="line">    ~B() <span class="keyword">noexcept</span> (<span class="literal">false</span>) &#123; <span class="keyword">throw</span> <span class="number">2</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">C</span> &#123;</span></span><br><span class="line">    B b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">funA</span><span class="params">()</span> </span>&#123; A a; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">funB</span><span class="params">()</span> </span>&#123; B b; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">funC</span><span class="params">()</span> </span>&#123; C c; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        funB() ;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(...)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"caught funB."</span> &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// caught funB .</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        funC() ;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(...)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"caught funC."</span> &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// caught funC.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        funA(); <span class="comment">// terminate called after throwing an instance of 'int'</span></span><br><span class="line">    &#125; <span class="keyword">catch</span>(...)&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"caught funA."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编译选项：g++ -std=c++11 2-6-2.cpp</span></span><br></pre></td></tr></table></figure></p>
<p>在代码中，无论是析构函数声明为<code>noexcept(false)</code>的类B，还是包含了B类型成员的类C，其析构函数都是可以抛出异常的。只有什么都没有声明的类A，其析构函数被默认为<code>noexcept(true)</code>，从而阻止了异常的扩散。这在实际的使用中，应该引起程序员的注意。</p>
<h2 id="快速初始化成员变量"><a href="#快速初始化成员变量" class="headerlink" title="快速初始化成员变量"></a>快速初始化成员变量</h2><p>在C++98中，支持了在类声明中使用等号“=”加初始值的方式，来初始化类中静态成员常量。这种声明方式我们也称之为“就地”声明。就地声明在代码编写时非常便利，不过C++98对类中就地声明的要求却非常高。如果静态成员不满足常量性，则不可以就地声明，而且即使常量的静态成员也只能是整型或者枚举型才能就地初始化。而非静态成员变量的初始化则必须在构造函数中进行。我们来看看下面的例子。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Init</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Init(): a(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">    Init(<span class="keyword">int</span> d): a(d) &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 成员，无法通过编译</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> d = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 成员，无法通过编译</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">double</span> e = <span class="number">1.3</span>;</span><br><span class="line">    <span class="comment">// 非整型或者枚举，无法通过编译</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> f = <span class="string">"e"</span>; <span class="comment">// 非整型或者枚举，无法通过编译</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//编译选项：g++ -c 2-7-1.ccpp</span></span><br></pre></td></tr></table></figure></p>
<p>在代码中，成员c、静态成员d、静态常量成员e以及静态常量指针f的就地初始化都无法通过编译。在C++11中，标准允许非静态成员变量的初始化有多种形式。具体而言，除了初始化列表外，在C++11中，标准还允许使用等号<code>=</code>或者花括号<code>{}</code>进行就地的非静态成员变量初始化。比如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">init</span>&#123;</span> <span class="keyword">int</span> a = <span class="number">1</span>; <span class="keyword">double</span> b &#123;<span class="number">1.2</span>&#125;; &#125;;</span><br></pre></td></tr></table></figure></p>
<p>在这个名叫<code>init</code>的结构体中，我们给了非静态成员a和b分别赋予初值1和1.2。这在C++11中是一个合法的结构体声明。花括号式的集合(列表)初始化已经成为C++11中初始化声明的一种通用形式。不过在C++11中，对于非静态成员进行就地初始化，两者却并非等价的，如代码所示。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">C</span> &#123;</span></span><br><span class="line">    C(<span class="keyword">int</span> i):c(i)&#123;&#125;;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">init</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">b</span><span class="params">(<span class="string">"he1lo"</span>)</span></span>; <span class="comment">// 无法通过编译</span></span><br><span class="line">    <span class="function">C <span class="title">c</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="comment">//无法通过编译</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//编译选项：g++ -std=c++11 -c 2-7-2. cpp</span></span><br></pre></td></tr></table></figure></p>
<p>从代码中可以看到，就地圆括号式的表达式列表初始化非静态成员b和c都会导致编译出错。在C++11标准支持了就地初始化非静态成员的同时，初始化列表这个手段也被保留下来了。如果两者都使用，是否会发生冲突呢?我们来看下面这个例子，如代码所示。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Mem</span> &#123;</span></span><br><span class="line">    Mem() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Mem default, num: "</span> &lt;&lt; num &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    Mem(<span class="keyword">int</span> i): num(i) &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Mem, num: "</span> &lt;&lt; num &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">2</span>; <span class="comment">// 使用=初始化非静态成员</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Group</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Group() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Group default. val:"</span> &lt;&lt; val &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    Group(<span class="keyword">int</span> i): val(<span class="string">'G'</span>), a(i) &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Group. val: "</span> &lt;&lt; val &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">NumOfA</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"number of A:"</span> &lt;&lt; a.num &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">NumOfB</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"number of B:"</span> &lt;&lt; b.num &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> val&#123;<span class="string">'g'</span>&#125;; <span class="comment">// 使用&#123;&#125;初始化非静态成员</span></span><br><span class="line">    Mem a;</span><br><span class="line">    Mem b&#123;<span class="number">19</span>&#125;;</span><br><span class="line">    <span class="comment">//使用&#123;&#125;初始化非静态成员</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Mem member;</span><br><span class="line">    <span class="comment">// Mem default, num: 2</span></span><br><span class="line">    Group group;</span><br><span class="line">    <span class="comment">// Mem default, num: 2</span></span><br><span class="line">    <span class="comment">// Mem， num: 1</span></span><br><span class="line">    <span class="comment">// Group default. val: g</span></span><br><span class="line">    group.NumOfA() ;</span><br><span class="line">    <span class="comment">// number of A: 2</span></span><br><span class="line">    group.NumOfB() ;</span><br><span class="line">    <span class="comment">// number of B: 19</span></span><br><span class="line">    <span class="function">Group <span class="title">group2</span><span class="params">(<span class="number">7</span>)</span> </span>;</span><br><span class="line">    <span class="comment">// Mem， num: 7</span></span><br><span class="line">    <span class="comment">// Mem, num: 1</span></span><br><span class="line">    <span class="comment">// Group. val: G</span></span><br><span class="line">    group2.NumOfA() ;</span><br><span class="line">    <span class="comment">// number of A: 7</span></span><br><span class="line">    group2.NumOfB() ;</span><br><span class="line">    <span class="comment">// number of B: 19</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编译选项：g++ 2-7-3.ccpp -std=C++11 .</span></span><br></pre></td></tr></table></figure>
<p>在代码中，我们定义了有两个初始化函数的类Mem，此外还定义了包含两个Mem对象的Group类。类Mem中的成员变量num，以及classGroup中的成员变量a、b、val,采用了与C++98完全不同的初始化方式。</p>
<p>相对于传统的初始化列表，在类声明中对非静态成员变量进行就地列表初始化可以降低程序员的工作量。当然，我们只在有多个构造函数，且有多个成员变量的时候可以看到新方式带来的便利。</p>
<h2 id="非静态成员的sizeof"><a href="#非静态成员的sizeof" class="headerlink" title="非静态成员的sizeof"></a>非静态成员的sizeof</h2><p>在C++引入类(class) 类型之后， sizeof 的定义也随之进行了拓展。不过在C++98标准中，对非静态成员变量使用sizeof是不能够通过编译的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">People</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> hand;</span><br><span class="line">    <span class="keyword">static</span> People *all;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    People P;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span> (p.hand) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// C++98 中通过，C++11 中通过</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span> (People::all) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// C++98中通过，C++11 中通过</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span> (People: :hand) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// C++98 中错误，C++11中通过</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编译选项：g++ 2-8-1. ccpp</span></span><br></pre></td></tr></table></figure></p>
<p>注意最后一个<code>sizeof</code>操作。在C++11中，对非静态成员变量使用<code>sizeof</code>操作是合法的。而在C++98中，只有静态成员，或者对象的实例才能对其成员进行<code>sizeof</code>操作。因此如果读者只有一个支持C++98标准的编译器，在没有定义类实例的时候，要获得类成员的大小，我们通常会采用以下的代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sizeof</span> (( (People*)<span class="number">0</span>) -&gt;hand) ;</span><br></pre></td></tr></table></figure></p>
<p>这里我们强制转换0为一个<code>People</code>类的指针，继而通过指针的解引用获得其成员变量，并用<code>sizeof</code>求得该成员变量的大小。而在C++11中，我们无需这样的技巧，因为<code>sizeof</code>可以作用的表达式包括了类成员表达式。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sizeof</span> (People::hand) ;</span><br></pre></td></tr></table></figure></p>
<h2 id="扩展的friend语法"><a href="#扩展的friend语法" class="headerlink" title="扩展的friend语法"></a>扩展的friend语法</h2><p>friend 关键字用于声明类的友元，友元可以无视类中成员的属性。C++11对friend关键字进行了一些改进。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Poly</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> Poly P;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LiLei</span> &#123;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Poly</span>;</span> <span class="comment">// C++98 通过，C++11 通过</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Jim</span></span></span><br><span class="line"><span class="class">    <span class="title">friend</span> <span class="title">Poly</span>;</span></span><br><span class="line"><span class="comment">// C++98 失败，C++11 通过</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HanMeiMei</span> &#123;</span></span><br><span class="line">    <span class="keyword">friend</span> P;</span><br><span class="line"><span class="comment">// C++98失败，C++11 通过</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//编译选项：g++ -std=C++11 2-9-1.cpp</span></span><br></pre></td></tr></table></figure></p>
<p>在代码中，我们声明了3个类型：LiLei、 Jim和HanMeiMei，它们都有一个友元类型Poly。从编译通过与否的状况中我们可以看出，在C++11中，声明一个类为另外一个类的友元时，不再需要使用class关键字。</p>
<p>我们使用Poly的别名P来声明友元，程序员借此可以为类模板声明友元。比如下面这个例子。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">P</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">People</span> &#123;</span></span><br><span class="line">    <span class="keyword">friend</span> T;</span><br><span class="line">&#125;;</span><br><span class="line">People&lt;P&gt; PP;</span><br><span class="line"><span class="comment">//类型P在这里是People类型的友元</span></span><br><span class="line">People&lt;<span class="keyword">int</span>&gt; Pi; <span class="comment">//对于int类型模板参数，友元声明被忽略</span></span><br><span class="line"><span class="comment">//编译选项：g++ -std=c++11 2-9-2.cpp</span></span><br></pre></td></tr></table></figure></p>
<p>从代码中我们看到，对于People这个模板类，在使用类P为模板参数时，P是<code>People&lt;P&gt;</code>的一个friend 类。而在使用内置类型int作为模板参数的时候，<code>People&lt;int&gt;</code>会被实例化为一个普通的没有友元定义的类型。这样一来，我们就可以在模板实例化时才确定一个模板类是否有友元，以及谁是这个模板类的友元。</p>
<h2 id="final-override-控制"><a href="#final-override-控制" class="headerlink" title="final/override 控制"></a>final/override 控制</h2><p>在通常情况下，一旦在基类A中的成员函数fun被声明为virtual 的，那么对于其派生类B而言，fun总是能够被重载的(除非被重写了)。有的时候我们并不想fun在B类型派生类中被重载，那么，C++98没有方法对此进行限制。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mathobject</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">Arith</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Printable</span> :</span> <span class="keyword">public</span> Mathobject &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">Arith</span><span class="params">()</span> </span>= <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123;<span class="comment">//在C++98中我们无法阻止该接口被重写</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Output is: "</span> &lt;&lt; Arith() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Add2</span> :</span> <span class="keyword">public</span> Printable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Add2 (<span class="keyword">double</span> a, <span class="keyword">double</span> b): x(a)， y(b) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">Arith</span><span class="params">()</span> </span>&#123; returnx + y; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> x，y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mu13</span> :</span> <span class="keyword">public</span> Printable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Mul3 (<span class="keyword">double</span> a, <span class="keyword">double</span> b, <span class="keyword">double</span> c): x(a), y(b), z(c) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">Arith</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> x*y*z; &#125;</span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    <span class="keyword">double</span> x，y, z;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//编译选项：g++ 2-10-1. cpp</span></span><br></pre></td></tr></table></figure></p>
<p>我们的基础类<code>MathObject</code>定义了两个接口：<code>Arith</code>和<code>Print</code>。类<code>Printable</code>则继承于<code>MathObject</code>并实现了<code>Print</code>接口。接下来，<code>Add2</code>和<code>Mul3</code>为了使用<code>MathObject</code>的接口和<code>Printable</code>的<code>Print</code>的实现，于是都继承了<code>Printable</code>。</p>
<p>final关键字的作用是使派生类不可覆盖它所修饰的虚函数。C++11 也采用了类似的做法。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">object</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base</span> :</span> <span class="keyword">public</span> object &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> final</span>; <span class="comment">// 声明为final</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//无法通过编译</span></span><br><span class="line">&#125;;.</span><br><span class="line"><span class="comment">//编译选项：g++ -c -std=c++11 2-10-2. cpp</span></span><br></pre></td></tr></table></figure></p>
<p>派生于<code>Object</code>的<code>Base</code>类重载了<code>Object</code>的<code>fun</code>接口，并将本类中的<code>fun</code>函数声明为final的。那么派生于<code>Base</code>的<code>Derived</code>类对接口<code>fun</code>的重载则会导致编译时的错误。</p>
<p>基类中的虚函数可以使用final关键字，不过这样将使用该虚函数无法被重载，也就失去了虚函数的意义。如果不想成员函数被重载，程序员可以直接将该成员函数定义为非虚的。而final通常只在继承关系的“中途”终止派生类的重载中有意义。</p>
<p>在C++中重载还有一个特点，就是对于基类声明为virtual的函数，之后的重载版本都不需要再声明该重载函数为virtual。即使在派生类中声明了virtual，该关键字也是编译器可以忽略的。</p>
<p>在C++11中为了帮助程序员写继承结构复杂的类型，引入了虚函数描述符override,如<br>果派生类在虚函数声明时使用了override描述符，那么该函数必须重载其基类中的同名函数，否则代码将无法通过编译。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Turing</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">VNeumann</span><span class="params">(<span class="keyword">int</span> g)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">DKnuth</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span> </span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DerivedMid</span>:</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line">    <span class="comment">// void VNeumann (double g) ;</span></span><br><span class="line">    <span class="comment">//接口被隔离了，曾想多一个版本的VNeumann函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DerivedTop</span> :</span> <span class="keyword">public</span> DerivedMid &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Turing</span><span class="params">()</span> override </span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Dikjstral</span><span class="params">()</span> override</span>;</span><br><span class="line">    <span class="comment">//无法通过编译，拼写错误，并非重载</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">VNeumann</span> <span class="params">(<span class="keyword">double</span> g)</span> override</span>;</span><br><span class="line">    <span class="comment">//无法通过编译，参数不一致，并非重载</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DKnuth</span><span class="params">()</span> override </span>;</span><br><span class="line">    <span class="comment">//无法通过编译，常量性不一致，并非重载</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span> override</span>;</span><br><span class="line">    <span class="comment">//无法通过编译，非虚函数重载</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编译选项：g++ -c -std=C++11 2-10-3. cpp</span></span><br></pre></td></tr></table></figure></p>
<p>我们在基类<code>Base</code>中定义了一些virtual的函数(接口)以及一个非virtual的函数Print。其派生类DerivedMid中，基类的Base的接口都没有重载，<code>DerivedTop</code>的作者在重载所有Base类的接口的时候，犯下了3种不同的错误：</p>
<ul>
<li>函数名拼写错，Djjkstra 误写作了Dikjstra。</li>
<li>函数原型不匹配，VNeumann 函数的参数类型误做了double类型，而DKnuth的常量性在派生类中被取消了。</li>
<li>重写了非虛函数Print。</li>
</ul>
<h2 id="模板函数的默认模板参数"><a href="#模板函数的默认模板参数" class="headerlink" title="模板函数的默认模板参数"></a>模板函数的默认模板参数</h2><p>在C++11中模板和函数一样，可以有默认的参数。这就带来了一定的复杂性。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//定义一个函数模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">TempFun</span><span class="params">(T a)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    TempFun(<span class="number">1</span>) ;</span><br><span class="line">    <span class="comment">// 1，(实例化为TempFun&lt;const int&gt;(1))</span></span><br><span class="line">    TempFun(<span class="string">"1"</span>) ;</span><br><span class="line">    <span class="comment">// 1，(实例化为TempFun&lt;const char *&gt;("1"))</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编译选项：g++ 2-11-1. cpp</span></span><br></pre></td></tr></table></figure></p>
<p>在代码清单2-26中，当编译器解析到函数调用<code>fun(1)</code>的时候，发现<code>fun</code>是一个函数模板。这时候编译器就会根据实参1的类型const int推导实例化出模板函数<code>void TempFun&lt;const int&gt;(int)</code>，再进行调用。相应的，对于<code>fun(&quot;1&quot;)</code>来说也是类似的，不过编译器实例化出的模板函数的参数的类型将是<code>const char *</code>。</p>
<p>函数模板在C++98中与类模板一起被引入，不过在模板类声明的时候，标准允许其有默认模板参数。默认的模板参数的作用好比函数的默认形参。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DefParm</span><span class="params">(<span class="keyword">int</span> m = <span class="number">3</span>)</span> </span>&#123;&#125; <span class="comment">// C++98 编译通过，C++11编译通过</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T = <span class="keyword">int</span>&gt;</span><br><span class="line">class DefClass &#123;&#125;;</span><br><span class="line"><span class="comment">// C++98 编译通过，C++11 编译通过</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T = <span class="keyword">int</span>&gt;</span><br><span class="line"><span class="keyword">void</span> DefTemcpparm() &#123;&#125;; <span class="comment">// C++98 编译失败，C++11编译通过</span></span><br><span class="line"><span class="comment">//编译选项：g++ -c -std=c++11 2-11-1. ccpp</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到，<code>DefTemcpparm</code>函数模板拥有一个默认参数。使用仅支持C++98的编译器<br>编译，<code>DefTemcpparm</code>的编译会失败，而支持C++11的编译器则毫无问题。不过在语法上，与类模板有些不同的是，在为多个默认模板参数声明指定默认值的时候，程序员必须遵照“从右往左”的规则进行指定。</p>
<p>而这个条件对函数模板来说并不是必须的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2 = <span class="keyword">int</span>&gt; class DefClass1 ;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1 = <span class="keyword">int</span>, <span class="keyword">typename</span> T2&gt; class DefClass2; <span class="comment">//无法通过编译</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T，<span class="keyword">int</span> i = <span class="number">0</span>&gt; class DefClass3;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> i = <span class="number">0</span>，<span class="keyword">typename</span> T&gt; class DefClass4; <span class="comment">//无法通过编译</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1 = <span class="keyword">int</span>, <span class="keyword">typename</span> T2&gt; <span class="keyword">void</span> DefFunc1(T1 a，T2 b) ;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> i = <span class="number">0</span>，<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> DefFunc2(T a) ;</span><br><span class="line"><span class="comment">//编译选项：g++ -c -std=c++11 2-11-2. cpp</span></span><br></pre></td></tr></table></figure></p>
<p>从代码清单2-28中可以看到，不按照从右往左定义默认类模板参数的模板类<code>DefClass2</code>和<code>DefClass4</code>都无法通过编译。而对于函数模板来说，默认模板参数的位置则比较随意。可以看到<code>DefFunc1</code>和<code>DefFunc2</code>都为第一个模板参数定义了默认参数，而第二个模板参数的默认值并没有定义，C++11 编译器却认为没有问题。</p>
<p>函数模板的参数推导规则也并不复杂。简单地讲，如果能够从函数实参中推导出类型的话，那么默认模板参数就不会被使用，反之，默认模板参数则可能会被使用。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">U</span> = <span class="title">double</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">voidf</span>(<span class="title">T</span> <span class="title">t</span> = 0, <span class="title">U</span> <span class="title">u</span> = 0);</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    f(<span class="number">1</span>, <span class="string">'c'</span>);      <span class="comment">// f&lt;int, char&gt;(1, 'c') </span></span><br><span class="line">    f(<span class="number">1</span>);           <span class="comment">// f&lt;int, double&gt;(1,0),使用了默认模板参数double</span></span><br><span class="line">    f();            <span class="comment">// 错误：T无法被推导出来</span></span><br><span class="line">    f&lt;<span class="keyword">int</span>&gt;();       <span class="comment">// f&lt;int , double&gt;(0,0)，使用了默认模板参数double</span></span><br><span class="line">    f&lt;<span class="keyword">int</span>, <span class="keyword">char</span>&gt;(); <span class="comment">// f&lt;int,char&gt;(0,0)</span></span><br><span class="line"><span class="comment">//编译选项：g++ -std=c++11 2-11-3. cpp</span></span><br></pre></td></tr></table></figure></p>
<p>我们定义了一个函数模板f，f同时使用了默认模板参数和默认函数参数。可以看到，由于函数的模板参数可以由函数的实参推导而出，所以在<code>f(1)</code>这个函数调用中，我们实例化出了模板函数的调用应该为<code>f&lt;int,double&gt;(1,0)</code>，其中，第二个类型参数U使用了默认的模板类型参数double，而函数实参则为默认值0。类似地，<code>f&lt;int&gt;()</code>实例化出的模板函数第二参数类型为double，值为0。而表达式<code>f()</code>由于第一类型参数T的无法推导，从而导致了编译的失败。而通过这个例子我们也可以看到，默认模板参数通常是需要跟默认函数参数一起使用的。</p>
<h2 id="外部模板"><a href="#外部模板" class="headerlink" title="外部模板"></a>外部模板</h2><h3 id="为什么需要外部模板"><a href="#为什么需要外部模板" class="headerlink" title="为什么需要外部模板"></a>为什么需要外部模板</h3><p>通常情况下，我们在一个文件中a.c中定义了一个变量<code>int i</code>，而在另外一个文件b.c中想使用它，这个时候我们就会在没有定义变量i的b.c文件中做一个外部变量的声明。比如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> i;</span><br></pre></td></tr></table></figure></p>
<p>这样做的好处是，在分别编译了a.c 和b.c之后，其生成的目标文件a.o和b.o中只有i<br>这个符号的一份定义。如果b.c中我们声明<code>int i</code>的时候不加上<code>extern</code>的话，那么i就会实实在在地既存在于a.o的数据区中，也存在于b.o的数据区中。那么链接器在链接a.o和b.o的时候，就会报告错误，因为无法决定相同的符号是否需要合并。</p>
<p>而对于函数模板来说，现在我们遇到的几乎是一模一样的问题。我们在一个test.h的文件中声明了如下一个模板函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(T)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>在第一个test1.cpp文件中，我们定义了以下代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"test .h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123; fun(<span class="number">3</span>); &#125;</span><br></pre></td></tr></table></figure></p>
<p>而在另一个test2.cpp文件中，我们定义了以下代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"test. h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123; fun(<span class="number">4</span>); &#125;</span><br></pre></td></tr></table></figure></p>
<p>由于两个源代码使用的模板函数的参数类型一致，所以在编译test1.cpp的时候，编译器实例化出了函数<code>fun&lt;int&gt;(int)</code>，而当编译test2.cpp的时候，编译器又再一次实例化出了函数<code>fun&lt;int&gt;(int)</code>。那么可以想象，在test1.o目标文件和test2.o目标文件中，会有两份一模一样的函数<code>fun&lt;int&gt;(int)</code>代码。</p>
<p>在链接的时候，链接器通过一些编译器辅助的手段将重复的模板函数代码<code>fun&lt;int&gt;(int)</code>删除掉，只保留了单个副本。由于编译器会产生大量冗余代码，会极大地增加编译器的编译时间和链接时间。解决这个问题的方法基本跟变量共享的思路是一样的，就是使用“外部的”模板。</p>
<h3 id="显式的实例化与外部模板的声明"><a href="#显式的实例化与外部模板的声明" class="headerlink" title="显式的实例化与外部模板的声明"></a>显式的实例化与外部模板的声明</h3><p>外部模板的使用实际依赖于C++98中一个已有的特性，即显式实例化(Explicit Instantiation)。显式实例化的语法很简单，比如对于以下模板：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(T)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们只需要声明：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> <span class="keyword">void</span> fun&lt;<span class="keyword">int</span>&gt; (<span class="keyword">int</span>) ;</span><br></pre></td></tr></table></figure></p>
<p>这就可以使编译器在本编译单元中实例化出<code>fun&lt;int&gt;(int)</code>版本的函数。而在C++11标准中，又加入了外部模板( Exterm Template)的声明。语法上，外部模板的声明跟显式的实例化差不多，只是多了一个关键字<code>extern</code>。对于上面的例子，我们可以通过：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="keyword">void</span> fun&lt;<span class="keyword">int</span>&gt; (<span class="keyword">int</span>) ;</span><br></pre></td></tr></table></figure></p>
<p>这样的语法完成一个外部模板的声明。</p>
<p>那么回到一开始我们的例子，来修改一下我们的代码。首先，在test1.cpp做显式地实<br>例化：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"test.h"</span></span></span><br><span class="line"><span class="keyword">template</span> <span class="keyword">void</span> fun&lt;<span class="keyword">int</span>&gt;(<span class="keyword">int</span>); <span class="comment">// 显示地实例化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123; fun(<span class="number">3</span>); &#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来，在test2.cpp中做外部模板的声明：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"test.h"</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="keyword">void</span> fun&lt;<span class="keyword">int</span>&gt; (<span class="keyword">int</span>); <span class="comment">//外部模板的声明</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123; fun(<span class="number">3</span>) ;&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样一来，在test2.o中不会再生成<code>fun&lt;int&gt;(int)</code>的实例代码，编译器也不用每次都产生一份<code>fun&lt;int&gt;(int)</code>的代码，所以可以减少编译时间。这里也可以把外部模板声明放在头文件中，这样所有包含test.h的头文件就可以共享这个外部模板声明了。</p>
<p>在使用外部模板的时候，我们还需要注意以下问题：如果外部模板声明出现于某个编译<br>单元中，那么与之对应的显示实例化必须出现于另一个编译单元中或者同一个编译单元的后续代码中；外部模板声明不能用于一个静态函数(即文件域函数)，但可以用于类静态成员函数。</p>
<h1 id="通用为本，专用为末"><a href="#通用为本，专用为末" class="headerlink" title="通用为本，专用为末"></a>通用为本，专用为末</h1><h2 id="继承构造函数"><a href="#继承构造函数" class="headerlink" title="继承构造函数"></a>继承构造函数</h2><p>如果派生类要使用基类的构造函数，通常需要在构造函数中显式声明。比如下面的例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span> A(<span class="keyword">int</span> i) &#123;&#125; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> :</span> A &#123; B(inti) : A(i) &#123;&#125; &#125;;</span><br></pre></td></tr></table></figure></p>
<p>B派生于A，B又在构造函数中调用A的构造函数，从而完成构造函数的“传递”。这在C++代码中非常常见。当然，这样的设计有一定的好处，尤其是B中有成员的时候。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span> A(<span class="keyword">int</span> i) &#123;&#125; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> :</span> A &#123; </span><br><span class="line">    B(<span class="keyword">int</span> i) : A(i), d(i) &#123;&#125;</span><br><span class="line">    <span class="keyword">int</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//编译选项：g++ -c 3-1-1. ccpp</span></span><br></pre></td></tr></table></figure></p>
<p>倘若基类中有大量的构造函数，而派生类却只有一些成员函数时，那么对于派生类而言，其构造就等同于构造基类。这时候问题就来了，在派生类中我们写的构造函数完完全全就是为了构造基类。那么为了遵从于语法规则，我们还需要写很多的“透传”的构造函数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    A(<span class="keyword">int</span> i) &#123;&#125;</span><br><span class="line">    A(<span class="keyword">double</span> d, <span class="keyword">int</span> i) &#123;&#125;</span><br><span class="line">    A(<span class="keyword">float</span> f, <span class="keyword">int</span> i, <span class="keyword">const</span> <span class="keyword">char</span>* c) &#123;&#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> :</span> A&#123;</span><br><span class="line">    B(<span class="keyword">int</span> i): A(i) &#123;&#125;</span><br><span class="line">    B(<span class="keyword">double</span> d, <span class="keyword">int</span> i): A(d, i) &#123;&#125;</span><br><span class="line">    B(<span class="keyword">float</span> f, <span class="keyword">int</span> i, <span class="keyword">const</span> <span class="keyword">char</span>* c): A(f, i, c)&#123;&#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Extrainterface</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们的基类A有很多的构造函数的版本，而继承于A的派生类B实际上只是添加了一个接口<code>Extralnterface</code>。那么如果我们在构造B的时候想要拥有A这样多的构造方法的话，就必须一一“透传”各个接口。这无疑是相当不方便的。事实上，在C++中已经有了一个好用的规则，就是如果派生类要使用基类的成员函数的，可以通过using声明( using-declaration)来完成。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">include &lt;iostream&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span> <span class="params">(<span class="keyword">double</span> i)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base:"</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived</span> :</span> Base &#123;</span><br><span class="line">    <span class="keyword">using</span> Base::f;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Derived:"</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    Base b;</span><br><span class="line">    b.f(<span class="number">4.5</span>);    <span class="comment">// Base: 4.5</span></span><br><span class="line"></span><br><span class="line">    Derived d;</span><br><span class="line">    d.f(<span class="number">4.5</span>);    <span class="comment">// Base: 4.5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>派生类中的<code>f</code>函数接受int类型为参数，而基类中接受double类型的参数。这里我们使用了<code>using</code>声明，声明派生类<code>Derived</code>也使用基类版本的函数<code>f</code>。这样一来，派生类中实际就拥有了两个f函数的版本。可以看到，我们在main函数中分别定义了Base变量b和 Derived变量d，并传入浮点字面常量4.5，结果都会调用到基类的接受double为参数的版本。</p>
<p>在C++11中，这个想法被扩展到了构造函数上。子类可以通过使用 using声明来声明继承基类的构造函数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    A(<span class="keyword">int</span> i) &#123;&#125;</span><br><span class="line">    A(<span class="keyword">double</span> d, <span class="keyword">int</span> i) &#123;&#125;</span><br><span class="line">    A(<span class="keyword">float</span> f, <span class="keyword">int</span> i, coust <span class="keyword">char</span>* c) &#123;&#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> :</span> A &#123;</span><br><span class="line">    <span class="keyword">using</span> A::A;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">ExtraInterface</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这里我们通过<code>using A::A</code>的声明，把基类中的构造函数悉数继承到派生类B中。C++11标准继承构造函数被设计为跟派生类中的各种类默认函数(默认构造、析构、拷贝构造等样，是隐式声明的。这意味着如果一个继承构造函数不被相关代码使用，编译器不会为其产生真正的函数代码。这无疑比“透传”方案总是生成派生类的各种构造函数更加节省目标代码空间。</p>
<p>有的时候，基类构造函数的参数会有默认值。对于继承构造函数来讲，参数的默认值是不会被继承的。事实上，默认值会导致基类产生多个构造函数的版本，这些函数版本都会被派生类继承。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    A (<span class="keyword">int</span> a = <span class="number">3</span>, <span class="keyword">double</span> d = <span class="number">2.4</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> :</span> A &#123;</span><br><span class="line">    <span class="keyword">using</span> A::A;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>我们的基类的构造函数<code>A(int a=3, double=2.4)</code>有一个接受两个参数的构造函数，且两个参数均有默认值。那么A到底有多少个可能的构造函数的版本呢?事实上，B可能从A中继承来的候选继承构造函数有如下一些：</p>
<ul>
<li><code>A(int=3, double =2.4);</code>这是使用两个参数的情况。</li>
<li><code>A(int=3);</code>这是减掉一个参数的情况。</li>
<li><code>A(const A&amp;);</code>这是默认的复制构造函数</li>
<li><code>A()</code>这是不使用参数的情况。</li>
</ul>
<p>相应地，B中的构造函数将会包括以下一些：</p>
<ul>
<li><code>B(int, double);</code>这是一个继承构造函数</li>
<li><code>B(int);</code>这是减少掉一个参数的继承构造函数。</li>
<li><code>B(const B&amp;);</code>这是复制构造函数，这不是继承来的。</li>
<li><code>B();</code>这是不包含参数的默认构造函数。</li>
</ul>
<p>有的时候，我们还会遇到继承构造函数“冲突”的情况。这通常发生在派生类拥有多个基类的时候。多个基类中的部分构造函数可能导致派生类中的继承构造函数的函数名、参数(有的时候，我们也称其为函数签名)都相同，那么继承类中的冲突的继承构造函数将导致不合法的派生类代码。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span> A(<span class="keyword">int</span>) &#123;&#125; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> &#123;</span> B(<span class="keyword">int</span>) &#123;&#125; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">C</span>:</span> A, B &#123;</span><br><span class="line">    <span class="keyword">using</span> A::A;</span><br><span class="line">    <span class="keyword">using</span> B::B;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>A和B的构造函数会导致C中重复定义相同类型的继承构造函数这种情况下，可以通过显式定义继承类的冲突的构造函数，阻止隐式生成相应的继承构造函数来解决冲突。比如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">C</span>:</span> A, B&#123;</span><br><span class="line">    <span class="keyword">using</span> A::A;</span><br><span class="line">    <span class="keyword">using</span> B::B;</span><br><span class="line">    C(<span class="keyword">int</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>其中的构造函数<code>C(int)</code>就很好地解决了继承构造函数的冲突问题。</p>
<p>另外我们还需要了解的一些规则是，如果基类的构造函数被声明为私有成员函数，或者派生类是从基类中虚继承的，那么就不能够在派生类中声明继承构造函数。此外，如果一旦使用了继承构造函数，编译器就不会再为派生类生成默认构造函数了</p>
<h2 id="委派构造函数"><a href="#委派构造函数" class="headerlink" title="委派构造函数"></a>委派构造函数</h2><p>通过委派其他构造函数，多构造函数的类编写将更加容易。我们能够将一个构造函数设定为“基准版本”，而其他构造函数可以通过委派“基准版本”来进行初始化。按照这个想法，我们可能会如下编写构造函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Info() &#123; Initrest(); &#125;</span><br><span class="line">Info(<span class="keyword">int</span> i) &#123; <span class="keyword">this</span>-&gt;Info(); type = i; &#125;</span><br><span class="line">Info(<span class="keyword">char</span> e) &#123; <span class="keyword">this</span>-&gt;Info(); name = e;&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里我们通过<code>this</code>指针调用我们的“基准版本”的构造函数。不过可惜的是，一般的编译器都会阻止<code>this-&gt;Info()</code>的编译。原则上，编译器不允许在构造函数中调用构造函数，即使参数看起来并不相同。</p>
<p>在C+11中，我们可以使用委派构造函数来达到期望的效果。更具体的，C++11中的委派构造函数是在构造函数的初始化列表位置进行构造的、委派的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Info</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Info() &#123; Initrest(); &#125;</span><br><span class="line">    Info(<span class="keyword">int</span> i) : Info() &#123; type = i; &#125;</span><br><span class="line">    Info(<span class="keyword">char</span> e) : Info() &#123; name = e;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Initrest</span><span class="params">()</span> </span>&#123;<span class="comment">/* 其他初始化 */</span> &#125;</span><br><span class="line">    <span class="keyword">int</span> type &#123;<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> name &#123;<span class="string">'a'</span>&#125;;</span><br></pre></td></tr></table></figure></p>
<p>我们在<code>Info(int)</code>和<code>Info(char)</code>的初始化列表的位置，调用了“基准版本”的构造函数<code>Info()</code>。这里我们为了区分被调用者和调用者，称在初始化列表中调用“基准版本”的构造函数为委派构造函数(delegating constructor)，而被调用的“基准版本”则为目标构造函数( target constructor)。</p>
<p>在C++11中，所谓委派构造，就是指委派函数将构造的任务委派给了目标构造函数来完成这样一种类构造的方式。当然，委派构造函数只能在函数体中为ype、name等成员赋初值。这是由于委派构造函数不能有初始化列表造成的。</p>
<p>在C++中，构造函数不能同时“委派”和使用初始化列表，所以如果委派构造函数要给变量赋初值，初始化代码必须放在函数体中。比如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rule1</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    Rule1(<span class="keyword">int</span> a); i(a) &#123;&#125;</span><br><span class="line">    Rule1(): Rule1(<span class="number">40</span>), i(<span class="number">1</span>) &#123;&#125; <span class="comment">//无法通过编译</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>Rule1</code>的委派构造函数<code>Rule1()</code>的写法就是非法的。我们不能在初始化列表中既初始化成员，又委托其他构造函数完成构造。</p>
<p>事实上，在使用委派构造函数的时候，我们也建议程序员抽象出最为“通用”的行为做目标构造函数。这样做一来代码清晰，二来行为也更加正确。在构造函数比较多的时候，我们可能会拥有不止一个委派构造函数，而一些目标构造函数很可能也是委派构造函数，这样一来，我们就可能在委派构造函数中形成链状的委派构造关系。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Info</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Info() : Info(<span class="number">1</span>) &#123; &#125; <span class="comment">//委派构造函数</span></span><br><span class="line">    Info(<span class="keyword">int</span> i) : Info(i,<span class="string">'a'</span>) &#123; &#125; <span class="comment">//既是目标构造函数，也是委派构造函数</span></span><br><span class="line">    Info(<span class="keyword">char</span> e): Info(<span class="number">1</span>, e) &#123; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Info(<span class="keyword">int</span> i, <span class="keyword">char</span> e) : type(i), name(e)&#123;<span class="comment">/* 其他初始化 */</span> &#125;<span class="comment">//目标构造函数</span></span><br><span class="line">    <span class="keyword">int</span> type;</span><br><span class="line">    <span class="keyword">char</span> name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里我们使<code>Info()</code>委托<code>Info(int)</code>进行构造，而<code>Info(int)</code>又委托<code>Info(int, char)</code>进行构造。在委托构造的链状关系中，有一点程序员必须注意，就是不能形成委托环( delegation cycle)。比如<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rule2</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> i, c;</span><br><span class="line">    Rule2(): Rule2(<span class="number">2</span>) &#123;&#125;</span><br><span class="line">    Rule2(<span class="keyword">int</span> i): Rule2(<span class="string">'c'</span>) &#123; &#125;</span><br><span class="line">    Rule2(<span class="keyword">char</span> c): Rule2(<span class="number">2</span>) &#123; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>Rule2</code>定义中，<code>Rule2()</code>、<code>Rule2(int)</code>和<code>Rule2(char)</code>都依赖于别的构造函数，形成环委托构造关系。这样的代码通常会导致编译错误。</p>
<h2 id="右值引用：移动语义和完美转发"><a href="#右值引用：移动语义和完美转发" class="headerlink" title="右值引用：移动语义和完美转发"></a>右值引用：移动语义和完美转发</h2><h3 id="指针成员与拷贝构造"><a href="#指针成员与拷贝构造" class="headerlink" title="指针成员与拷贝构造"></a>指针成员与拷贝构造</h3><p>在类中包含了一个指针成员特别小心拷贝构造函数的编写，因为一不小心，就会出现内存泄露。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasPtrMem</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        HasPtrMem(): d(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">0</span>))&#123;&#125;</span><br><span class="line">        ~HasPtrMem() &#123;</span><br><span class="line">            <span class="keyword">delete</span> d;</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">int</span> *d; <span class="comment">//指针成员d</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    HasPtrMem a;</span><br><span class="line">    <span class="function">HasPtrMem <span class="title">b</span><span class="params">(a)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;*a.d&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//0</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;*b.d&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们定义了一个<code>HasptrMem</code>的类。这个类包含一个指针成员，该成员在构造时接受一个new操作分配堆内存返回的指针，而在析构的时候则会被delete操作用于释放之前分配的堆内存。在main函数中，我们声明了<code>HasPtrMem</code>类型的变量a，又使用a初始化了变量b。按照C++的语法，这会调用<code>HasptrMem</code>的拷贝构造函数。<code>a.d</code>和<code>b.d</code>都指向了同一块堆内存。在main作用域结束的时候，a和b的析构函数纷纷被调用，当其中之一完成析构之后(比如b)，那么<code>a.d</code>就成了一个“悬挂指针”(dangling pointer)，因为其不再指向有效的内存了。</p>
<p>这样的拷贝构造方式，在C++中也常被称为“浅拷贝”(shallow copy)。而在未声明构造函数的情况下，C++也会为类生成一个浅拷贝的构造函数。通常最佳的解决方案是用户自定义拷贝构造函数来实现“深拷贝”(deep copy)。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasptrMem</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    HasptrMem(): d(<span class="keyword">new</span> <span class="keyword">int</span> (<span class="number">0</span>)) &#123; &#125;</span><br><span class="line">    HasptrMem(HasptrMem &amp; h) : d(<span class="keyword">new</span> <span class="keyword">int</span>(*h.d)) &#123; &#125; <span class="comment">//拷贝构造函数，从堆中分配内存，并用*h.d初始化</span></span><br><span class="line">    ~HasptrMem() &#123; <span class="keyword">delete</span> d; &#125;</span><br><span class="line">    <span class="keyword">int</span> * d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    HasptrMem a;</span><br><span class="line">    <span class="function">HasptrMem <span class="title">b</span><span class="params">(a)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *a.d &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *b.d &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们为<code>HasptrMem</code>添加了一个拷贝构造函数。拷贝构造函数从堆中分配新内存，将该分配来的内存的指针交还给d，又使用<code>*(h.d)</code>对d进行了初始化。通过这样的方法，就避免了悬挂指针的困扰。</p>
<h3 id="移动语义"><a href="#移动语义" class="headerlink" title="移动语义"></a>移动语义</h3><p>拷贝构造函数中为指针成员分配新的内存再进行内容拷贝的做法在C++编程中几乎被视为是不可违背的。不过在一些时候，我们确实不需要这样的拷贝构造语义。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasPtrMem</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        HasPtrMem(): d(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">0</span>))&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"Construct:"</span> &lt;&lt; ++n_cstr&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        HasPtrMem(<span class="keyword">const</span> HasPtrMem&amp;h): d(<span class="keyword">new</span> <span class="keyword">int</span>(*h.d))&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"Copy construct:"</span>&lt;&lt; ++n_cptr&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125; <span class="comment">//拷贝构造函数，从堆中分配内存，并用*h.d初始化</span></span><br><span class="line">        ~HasPtrMem() &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"Destruct:"</span>&lt;&lt;++n_dstr&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> *d; </span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> n_cstr;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> n_dstr;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> n_cptr;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> HasPtrMem::n_cstr=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> HasPtrMem::n_dstr=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> HasPtrMem::n_cptr=<span class="number">0</span>;</span><br><span class="line"><span class="function">HasPtrMem <span class="title">GetTemp</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> HasPtrMem();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    HasPtrMem a=GetTemp();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们声明了一个返回一个<code>HasptrMem</code>变量的函数。为了记录构造函数、拷贝构造函数，以及析构函数调用的次数，我们使用了一些静态变量。在main函数中，我们简单地声明了一个<code>HasptrMem</code>的变量a，要求它使用<code>Gettemp</code>的返回值进行初始化。编译运行该程序，我们可以看到下面的输出<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Construct: <span class="number">1</span></span><br><span class="line">Copy construct: <span class="number">1</span></span><br><span class="line">Destruct: <span class="number">1</span></span><br><span class="line">Copy construct: <span class="number">2</span></span><br><span class="line">Destruct: <span class="number">2</span></span><br></pre></td></tr></table></figure></p>
<p>这里构造函数被调用了一次，这是在<code>GetTemp</code>函数中<code>HasptrMem()</code>表达式显式地调用了构造函数而打印出来的。而拷贝构造函数则被调用了两次。这两次一次是从<code>GetTemp</code>函数中<code>HasPtrmeme()</code>生成的变量上拷贝构造出一个临时值，以用作<code>GetTemp</code>的返回值，而另外一次则是由临时值构造出<code>main</code>中变量a调用的。对应地，析构函数也就调用了3次。</p>
<p>如果<code>HasptrMem</code>的指针指向非常大的堆内存数据的话，那么拷贝构造的过程就会非常昂贵。按照C++的语义，临时对象将在语句结束后被析构，会释放它所包含的堆内存资源。而a在拷贝构造的时候，又会被分配堆内存。一种“新”方法是在构造时使得<code>a.d</code>指向临时对象的堆内存资。同时我们保证临时对象不释放所指向的堆内存，那么在构造完成后临时对象被析构，a就从中“偷”到了临时对象所拥有的堆内存资源。<br><img src="/img/1628477156.jpg" alt></p>
<p>C++11中，这样的“偷走”临时变量中资源的构造函数，就被称为“移动构造函数”而这样的“偷”的行为，则称之为“移动语义”( move semantics)。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasPtrMem</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        HasPtrMem(): d(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">3</span>))&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"Construct:"</span> &lt;&lt; ++n_cstr&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        HasPtrMem(<span class="keyword">const</span> HasPtrMem&amp;h): d(<span class="keyword">new</span> <span class="keyword">int</span>(*h.d))&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"Copy construct:"</span>&lt;&lt; ++n_cptr&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125; <span class="comment">//拷贝构造函数，从堆中分配内存，并用*h.d初始化</span></span><br><span class="line">        HasPtrMem(HasPtrMem &amp;&amp;h):d(h.d)&#123;</span><br><span class="line">            h.d=<span class="literal">nullptr</span>;<span class="comment">//将临时值得指针成员置空。</span></span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"Move construct:"</span>&lt;&lt;++n_mvtr&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        ~HasPtrMem() &#123;</span><br><span class="line">            <span class="keyword">delete</span> d;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"Destruct:"</span>&lt;&lt;++n_dstr&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> *d; </span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> n_cstr;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> n_dstr;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> n_cptr;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> n_mvtr;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> HasPtrMem::n_cstr=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> HasPtrMem::n_dstr=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> HasPtrMem::n_cptr=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> HasPtrMem::n_mvtr=<span class="number">0</span>;</span><br><span class="line"><span class="function">HasPtrMem <span class="title">GetTemp</span><span class="params">()</span></span>&#123;</span><br><span class="line">    HasPtrMem h;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Resource from"</span>&lt;&lt;__func__&lt;&lt;<span class="string">":"</span>&lt;&lt;hex&lt;&lt;h.d&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> h; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//HasPtrMem b;</span></span><br><span class="line">    HasPtrMem a=GetTemp();</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Resource from"</span>&lt;&lt;__func__&lt;&lt;<span class="string">":"</span>&lt;&lt;hex&lt;&lt;a.d&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>HasptrMem</code>类多了一个构造函数<code>HasPtrmem(HasptrMem&amp;&amp;)</code>，这个就是我们所谓的移动构造函数。移动构造函数接受一个所谓的“右值引用”的参数。可以看到，移动构造函数使用了参数<code>h</code>的成员<code>d</code>初始化了本对象的成员<code>d</code>，而<code>h</code>的成员<code>d</code>随后被置为指针空值<code>nullptr</code>。这就完成了移动构造的全过程。</p>
<p>这里所谓的“偷”堆内存，就是指将本对象<code>d</code>指向<code>h.d</code>所指的内存这一条语句，相应地，我们还将<code>h</code>的成员<code>d</code>置为指针空值。这其实也是我们“偷”内存时必须做的。这是因为在移动构造完成之后，临时对象会立即被析构。如果不改变<code>h.d</code>(临时对象的指针成员)的话，则临时对象会析构掉本是我们“偷”来的堆内存。这样一来，本对象中的<code>d</code>指针也就成了个悬挂指针，如果我们对指针进行解引用，就会发生严重的运行时错误。</p>
<p>将指针置为nullptr只是让这个指针不再指向任何对象，并没有释放原来这个指针指向的对象的内存。结果：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//理论上的结果：</span></span><br><span class="line">Construct:<span class="number">1</span></span><br><span class="line">Resource from GetTemp:<span class="number">0x603010</span></span><br><span class="line">Move construct:<span class="number">1</span></span><br><span class="line">Destruct:<span class="number">1</span></span><br><span class="line">Move construct:<span class="number">2</span></span><br><span class="line">Destruct:<span class="number">2</span></span><br><span class="line">Resource from main:<span class="number">0x603010</span></span><br><span class="line">Destruct:<span class="number">3</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到，这里没有调用拷贝构造函数，而是调用了两次移动构造函数，移动构造的结果是，<code>GetTemp</code>中的<code>h</code>的指针成员<code>h.d</code>和<code>main</code>函数中的<code>a</code>的指针成员<code>a.d</code>的值是相同的，即<code>h.d</code>和<code>a.d</code>都指向了相同的堆地址内存。该堆内存在函数返回的过程中，成功地逃避了被析构的“厄运”，取而代之地，成为了赋值表达式中的变量<code>a</code>的资源。</p>
<p>事实上，移动语义并不是什么新的概念，在C++98/03的语言和库中，它已经存在了，比如：</p>
<ul>
<li>在某些情况下拷贝构遗函数的省略</li>
<li>智能指针的拷贝</li>
<li>链表拼接</li>
<li>容器内的置换</li>
</ul>
<p>以上这些操作都包含了从一个对象向另外一个对象的资源转移的过程，唯一欠缺的是统一的语法和语义的支持，来使我们可以使用通用的代码移动任意的对象。如果能够任意地使用对象的移动而不是拷贝，那么标准库中的很多地方的性能都会大大提高。</p>
<h3 id="左值、右值与右值引用"><a href="#左值、右值与右值引用" class="headerlink" title="左值、右值与右值引用"></a>左值、右值与右值引用</h3><p>在赋值表达式中，出现在等号左边的就是“左值”，而在等号右边的，则称为“右值”。C++中还有一个被广泛认同的说法，那就是可以取地址的有名字的就是左值，反之，不能取地址的、没有名字的就是右值。</p>
<p>更为细致地，在C++11中，右值是由两个概念构成的个是将亡值( xvalue, expiring Value),另一个则是纯右值( rvalue, Pure Rvalue)。其中纯右值就是C++98标准中右值的概念，讲的是用于辨识临时变量和一些不跟对象关联的值。比如非引用返回的函数返回的临时变量值就是一个纯右值。一些运算表达式，比如1+3产生的临时变量值，也是纯右值。而不跟对象关联的字面量值，比如：2、’c’、true，也是纯右值。此外，类型转换函数的返回值、 lambda表达式等，也都是右值。</p>
<p>而将亡值则是C++11新增的跟右值引用相关的表达式，这样表达式通常是将要被移动的对象，比如返回右值引用<code>T&amp;&amp;</code>的函数返回值、<code>std:move</code>的返回值，或者转换为<code>T&amp;&amp;</code>的类型转换函数的返回值。而剩余的，可以标识函数、对象的值都属于左值。在C++11的程序中，所有的值必属于左值、将亡值、纯右值三者之一。</p>
<p>通常情况下，我们只能是从右值表达式获得其引用。比如<code>T &amp;&amp; a = Returnrvalue();</code>，这个表达式中，假设<code>Returnrvalue</code>返回一个右值，我们就声明了一个名为<code>a</code>的右值引用，其值等于<code>Returnrvalue</code>函数返回的临时变量的值。</p>
<p>为了区别于C++98中的引用类型，我们称C++98中的引用为“左值引用”。右值引用和左值引用都是属于引用类型。无论是声明一个左值引用还是右值引用，都必须立即进行初始化。而其原因可以理解为是引用类型本身自己并不拥有所绑定对象的内存，只是该对象的一个别名。左值引用是具名变量值的别名，而右值引用则是不具名(匿名)变量的别名。</p>
<p>在上面的例子中，<code>Returnrvalue</code>函数返回的右值在表达式语句结束后，其生命也就终结了(通常我们也称其具有表达式生命期)，而通过右值引用的声明，该右值又“重获新生”其生命期将与右值引用类型变量a的生命期一样。所以相比于以下语句的声明方式：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T b = Returnrvalue()</span><br></pre></td></tr></table></figure></p>
<p>我们刚才的右值引用变量声明，就会少一次对象的析构及一次对象的构造。因为<code>a</code>是右值引用，直接绑定了<code>Returnrvalue()</code>返回的临时量，而<code>b</code>只是由临时值构造而成的，而临时量在表达式结東后会析构因应就会多一次析构和构造的开销。</p>
<p>能够声明右值引用<code>a</code>的前提是<code>Returnrvalue</code>返回的是一个右值。通常情况下，右值引用是不能够绑定到任何的左值的。比如下面的表达式就是无法通过编译的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> c;</span><br><span class="line"><span class="keyword">int</span> &amp;&amp;d = c;</span><br></pre></td></tr></table></figure></p>
<p>这样的语句是否能够通过编译呢?<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">T &amp;e = ReturnRvalue();</span><br><span class="line"><span class="keyword">const</span> T &amp; f = ReturnRvalue();</span><br></pre></td></tr></table></figure></p>
<p>这里的答案是：<code>e</code>的初始化会导致编译时错误，而<code>f</code>则不会。</p>
<p>在常量左值引用在C++98标准中可以接受非常量左值、常量左值、右值对其进行初始化。而且在使用右值对其初始化的时候，常量左值引用还可以像右值引用一样将右值的生命期延长。不过相比于右值引用所引用的右值，常量左值所引用的右值在它的“余生”中只能是只读的。相对地，非常量左值只能接受非常量左值对其进行初始化。</p>
<p>即使在C++98中，我们也常可以使用常量左值引用来减少临时对象的开销<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Copyable</span> &#123;</span></span><br><span class="line">    Copyable() &#123;&#125;</span><br><span class="line">    Copyable(<span class="keyword">const</span> Copyable &amp;o) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Copied"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Copyable <span class="title">ReturnRvalue</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Copyable(); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AcceptVal</span><span class="params">(Copyable)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AcceptRef</span><span class="params">(<span class="keyword">const</span> Copyable &amp; )</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Pass by value: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    AcceptVal(ReturnRvalue()); <span class="comment">// 临时值被拷贝传入</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Pass by reference: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    AcceptRef(ReturnRvalue()); <span class="comment">// 临时值被作为引用传递</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们声明了结构体<code>Copyable</code>，该结构体唯一作用是在被拷贝构造的时候打印一句话：Copied。两个函数，<code>AcceptVal</code>使用了值传递参数，<code>AcceptRef</code>使用了引用传递。在以<code>ReturnRvalue</code>返回的右值为参数的时候，<code>AcceptRef</code>就可以直接使用产生的临时值，而<code>AcceptVal</code>则不能直接使用临时对象。</p>
<p>编译运行代码，可以得到以下结果：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Pass by value:</span><br><span class="line">Copied</span><br><span class="line">Copied</span><br><span class="line">Pass by reference:</span><br><span class="line">Copied</span><br></pre></td></tr></table></figure></p>
<p>可以看到，由于使用了左值引用，临时对象被直接作为函数的参数，而不需要从中拷贝。在C++11中，以右值引用为参数声明如下函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AcceptRvalueRef</span><span class="params">(Copyable &amp;&amp;)</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure></p>
<p>也同样可以减少临时变量拷贝的开销。进一步地，还可以在<code>AcceptRvalueRef</code>中修改该临时值。</p>
<p>如果我们这样实现函数<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AcceptRvalueRef</span><span class="params">(Copyable &amp;&amp; s)</span> </span>&#123;</span><br><span class="line">    Copyable news = <span class="built_in">std</span>::move(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>std::move(s)</code>的作用是强制一个左值成为右值。该函数就是使用右值来初始化 <code>Copyable</code>变量<code>news</code>。使用移动语义的前提是<code>Copyable</code>还需要添加一个以右值引用为参数的移动构造函数，比如<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Copyable(Copyable &amp;&amp;o) &#123; <span class="comment">/*实现移动语义*/</span> &#125;</span><br></pre></td></tr></table></figure></p>
<p>这样一来，如果<code>Copyable</code>类的临时对象中包含一些大块内存的指针，<code>news</code>就可以将临时值中的内存“窃”为己用，从而从这个以右值引用参数的<code>AcceptRvalueRef</code>函数中获得最大的收益。</p>
<p>如果<code>Copyable</code>没有移动构造函数，下列语句<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Copyable news = <span class="built_in">std</span>::move(s);</span><br></pre></td></tr></table></figure></p>
<p>将调用以常量左值引用为参数的拷贝构造函数。这是一种非常安全的设计，移动不成，至少还可以执行拷贝。</p>
<p>为了语义的完整，C++11中还存在着常量右值引用，比如我们通过以下代码声明一个常量右值引用。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> T &amp;&amp; crvalueref = ReturnRvalue();</span><br></pre></td></tr></table></figure></p>
<p>我们列出了在C++11中各种引用类型可以引用的值的类型。值得注意的是只要能够绑定右值的引用类型，都能够延长右值的生命期。<br><img src="/img/1628492956.jpg" alt></p>
<p>有的时候，我们可能不知道一个类型是否是引用类型，以及是左值引用还是右值引用。标准库在<code>&lt;type_traits&gt;</code>头文件中提供了3个模板类：<code>is_rvalue_reference</code>、<code>is_lvalue_reference</code>、<code>is_reference</code>，可供我们进行判断。比如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; is_rvalue_reference&lt;<span class="built_in">string</span> &amp;&amp;&gt;::value;</span><br></pre></td></tr></table></figure></p>
<h3 id="std-move：强制转化为右值"><a href="#std-move：强制转化为右值" class="headerlink" title="std::move：强制转化为右值"></a>std::move：强制转化为右值</h3><p>在C++11中，标准库在<code>utility</code>中提供了一个有用的函数<code>std::move</code>，这个函数的功能是将一个左值强制转化为右值引用，继而我们可以通过右值引用使用该值，以用于移动语义。从实现上讲<code>std::move</code>基本等同于一个类型转换：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static_cast</span>&lt;T&amp;&amp;&gt;(lvalue);</span><br></pre></td></tr></table></figure></p>
<p>值得一提的是，被转化的左值，其生命期并没有随着左右值的转化而改变。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Moveable</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Moveable():i(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">3</span>)) &#123;&#125;</span><br><span class="line">    ~Moveable() &#123; <span class="keyword">delete</span> i; &#125;</span><br><span class="line">    Moveable(<span class="keyword">const</span> Moveable &amp; m): i(<span class="keyword">new</span> <span class="keyword">int</span>(*m.i)) &#123; &#125;</span><br><span class="line">    Moveable(Moveable &amp;&amp; m):i(m.i) &#123;</span><br><span class="line">        m.i = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>* i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Moveable a;</span><br><span class="line"></span><br><span class="line">    <span class="function">Moveable <span class="title">c</span><span class="params">(move(a))</span></span>;    <span class="comment">// 会调用移动构造函数</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *a.i &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">// 运行时错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们为类型<code>Moveable</code>定义了移动构造函数。这个函数定义本身没有什么问题，但调用的时候，使用了<code>Moveable c(move(a));</code>这样的语句。这里的<code>a</code>本来是个左值变量，通过<code>std::move</code>将其转换为右值。这样一来，<code>a.i</code>就被<code>c</code>的移动构造函数设置为指针空值。由于<code>a</code>的生命期实际要到<code>main</code>函数结束才结東，那么随后对表达式<code>*a.i</code>进行计算的时候，就会发生严重的运行时错误。这是个典型误用<code>std::move</code>的例子。</p>
<p>我们来看看正确例子<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HugeMem</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    HugeMem(<span class="keyword">int</span> size): sz(size &gt; <span class="number">0</span> ? size : <span class="number">1</span>) &#123;</span><br><span class="line">        c = <span class="keyword">new</span> <span class="keyword">int</span>[sz];</span><br><span class="line">    &#125;</span><br><span class="line">    ~HugeMem() &#123; <span class="keyword">delete</span> [] c; &#125;</span><br><span class="line">    HugeMem(HugeMem &amp;&amp; hm): sz(hm.sz), c(hm.c) &#123;</span><br><span class="line">        hm.c = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> * c;</span><br><span class="line">    <span class="keyword">int</span> sz;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Moveable</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Moveable():i(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">3</span>)), h(<span class="number">1024</span>) &#123;&#125;</span><br><span class="line">    ~Moveable() &#123; <span class="keyword">delete</span> i; &#125;</span><br><span class="line">    Moveable(Moveable &amp;&amp; m):</span><br><span class="line">        i(m.i), h(move(m.h)) &#123;      <span class="comment">// 强制转为右值，以调用移动构造函数</span></span><br><span class="line">        m.i = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>* i;</span><br><span class="line">    HugeMem h;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Moveable <span class="title">GetTemp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Moveable tmp = Moveable();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; hex &lt;&lt; <span class="string">"Huge Mem from "</span> &lt;&lt; __func__</span><br><span class="line">        &lt;&lt; <span class="string">" @"</span> &lt;&lt; tmp.h.c &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// Huge Mem from GetTemp @0x603030</span></span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Moveable <span class="title">a</span><span class="params">(GetTemp())</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; hex &lt;&lt; <span class="string">"Huge Mem from "</span> &lt;&lt; __func__</span><br><span class="line">        &lt;&lt; <span class="string">" @"</span> &lt;&lt; a.h.c &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">// Huge Mem from main @0x603030</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们定义了两个类型：<code>Hugemem</code>和<code>Moveable</code>，其中<code>Moveable</code>包含了一个<code>HugeMem</code>的对象。在<code>Moveable</code>的移动构造函数中，我们就看到了<code>std::move</code>函数的使用。该函数将<code>m.h</code>强制转化为右值，以迫使<code>Moveable</code>中的<code>h</code>能够实现移动构造。这里可以使用<code>std::move</code>，是因为<code>m.h</code>是<code>m</code>的成员，既然<code>m</code>将在表达式结束后被析构，其成员也自然会被析构，因此不存在生存期不对的问题。</p>
<p>另外一个问题可能是<code>std::move</code>使用的必要性。可以接受右值的右值引用本身却是个左值。这里的<code>m.h</code>引用了一个确定的对象，而且<code>m.h</code>也有名字，可以使用<code>&amp;m.h</code>取到地址，因此是个不折不扣的左值。不过这个左值确确实实会很快“灰飞烟灭”，因为拷贝构造函数在<code>Moveable</code>对象<code>a</code>的构造完成后也就结束了。那么这里使用<code>std::move</code>强制其为右值就不会有问题了。</p>
<p>事实上，为了保证移动语义的传递，程序员在编写移动构造函数的时候，应该总是记得使用<code>std::move</code>转换拥有形如堆内存、文件句柄等资源的成员为右值，这样一来，如果成员支持移动构造的话，就可以实现其移动语义。而即使成员没有移动构造函数，那么接受常量左值的构造函数版本也会轻松地实现拷贝构造，因此也不会引起大的问题。</p>
<h3 id="移动语义的一些其他问题"><a href="#移动语义的一些其他问题" class="headerlink" title="移动语义的一些其他问题"></a>移动语义的一些其他问题</h3><p>移动语义一定是要修改临时变量的值。程序员在实现移动语义一定要注意排除不必要的const关键字。</p>
<p>在C++11中，拷贝/移动构造函数实际上有以下3个版本：</p>
<ul>
<li><code>T object(T &amp;)</code></li>
<li><code>T Object(const T &amp;)</code></li>
<li><code>T object(T &amp;&amp;)</code></li>
</ul>
<p>其中常量左值引用的版本是一个拷贝构造版本，而右值引用版本是一个移动构造版本。默认情况下，编译器会为程序员隐式地生成一个移动构造函数。不过如果程序员声明了自定义的拷贝构造函数、拷贝赋值函数、移动赋值函数、析构函数中的一个或者多个，编译器都不会再为程序员生成默认版本。默认的移动构造函数实际上跟默认的拷贝构造函数一样，只能做一些按位拷贝的工作。这对实现移动语义来说是不够的。</p>
<p>声明了移动构造函数、移动赋值函数、拷贝赋值函数和析构函数中的一个或者多个，编译器也不会再为程序员生成默认的拷贝构造函数。所以在C++11中，拷贝构造/赋值和移动构造/赋值函数必须同时提供，或者同时不提供，程序员才能保证类同时具有拷贝和移动语义。只声明其中一种的话，类都仅能实现一种语义。</p>
<p>只有移动语义构造的类型往往都是“资源型”的类型，比如说智能指针，文件流等，都可以视为“资源型”的类型。一些编译器现在也把<code>ifstream</code>这样的类型实现为仅可移动的。</p>
<p>在标准库的头文件<code>&lt;type_traits&gt;</code>里，我们还可以通过一些辅助的模板类来判断一个类型是否是可以移动的。比如<code>is_move_constructible</code>、<code>is_trivially_move_constructible</code>、<code>is_nothrow_move_constructible</code>，使用方法仍然是使用其成员<code>value</code>。比如<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; is_move_constructible&lt;UnknownType&gt;::value;</span><br></pre></td></tr></table></figure></p>
<p>就可以打印出<code>UnknowType</code>是否可以移动，这在一些情况下还是非常有用的。</p>
<p>而有了移动语义，还有一个比较典型的应用是可以实现高性能的置换(swap)函数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">swap</span>(<span class="title">T</span>&amp; <span class="title">a</span>, <span class="title">T</span>&amp; <span class="title">b</span>) &#123;</span></span><br><span class="line">    <span class="function">T <span class="title">tmp</span><span class="params">(move(a))</span></span>;</span><br><span class="line">    a = move(b);</span><br><span class="line">    b = move(tmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果T是可以移动的，那么移动构造和移动赋值将会被用于这个置换。整个过程，代码都只会按照移动语义进行指针交换，不会有资源的释放与申请。而如果T不可移动却是可拷贝的，那么拷贝语义会被用来进行置换。这就跟普通的置换语句是相同的了。</p>
<p>另外一个关于移动构造的话题是异常。程序员应该尽量编写不抛出异常的移动构造函数，通过为其添加一个<code>noexcept</code>关键字，可以保证移动构造函数中抛出来的异常会直接调用<code>terminate</code>程序终止运行，而不是造成指针悬挂的状态。而标准库中，我们还可以用一个<code>std::move_if_noexcept</code>的模板函数替代<code>move</code>函数。该函数在类的移动构造函数没有<code>noexcept</code>关键字修饰时返回一个左值引用从而使变量可以使用拷贝语义，而在类的移动构造函数有<code>noexcept</code>关键字时，返回一个右值引用，从而使变量可以使用移动语义。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Maythrow</span> &#123;</span></span><br><span class="line">    Maythrow() &#123;&#125;</span><br><span class="line">    Maythrow(<span class="keyword">const</span> Maythrow&amp;) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Maythorow copy constructor."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Maythrow(Maythrow&amp;&amp;) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Maythorow move constructor."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Nothrow</span> &#123;</span></span><br><span class="line">    Nothrow() &#123;&#125;</span><br><span class="line">    Nothrow(Nothrow&amp;&amp;) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Nothorow move constructor."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Nothrow(<span class="keyword">const</span> Nothrow&amp;) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Nothorow move constructor."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Maythrow m;</span><br><span class="line">    Nothrow n;</span><br><span class="line"></span><br><span class="line">    Maythrow mt = move_if_noexcept(m);  <span class="comment">// Maythorow copy constructor.</span></span><br><span class="line">    Nothrow nt = move_if_noexcept(n);   <span class="comment">// Nothorow move constructor.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以清楚地看到<code>move_if_noexcept</code>的效果。事实上，<code>move_if_noexcept</code>是以牺牲性能保证安全的一种做法，而且要求类的开发者对移动构造函数使用<code>noexcept</code>进行描述，否则就会损失更多的性能。</p>
<p>还有一个与移动语义看似无关，但偏偏有些关联的话题是，编译器中被称为RVO/NRVO的优化(RVO, 返回值优化)。事实上，在本节中大量的代码都使用了<code>-fno-elide-constructors</code>选项在g++/clang++中关闭这个优化，这样可以使读者在代码中较为容易地利用函数返回的临时量右值。</p>
<p>但若在编译的时候不使用该选项的话，读者会发现很多构造和移动都被省略了。对于下面这样的代码，一旦打开g++/clang++的RVO/NRVO，从<code>ReturnValue</code>函数中a变量拷贝/移动构造临时变量，以及从临时变量拷贝/移动构造b的二重奏就通通没有了。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">A <span class="title">ReturnRvalue</span><span class="params">()</span> </span>&#123; <span class="function">A <span class="title">a</span><span class="params">()</span></span>; <span class="keyword">return</span> a; &#125;</span><br><span class="line">A b = ReturnRvalue();</span><br></pre></td></tr></table></figure></p>
<p><code>b</code>变量实际就使用了<code>ReturnRvalue</code>函数中<code>a</code>的地址，任何的拷贝和移动都没有了。通俗地说，就是b变量直接“霸占”了a变量。这是编译器中一个效果非常好的一个优化。不过RVO/NRVO并不是对任何情况都有效。比如有些情况下，一些构造是无法省略的。还有一些情况，即使 RVO/NRVO完成了，也不能达到最好的效果</p>
<h3 id="完美转发"><a href="#完美转发" class="headerlink" title="完美转发"></a>完美转发</h3><p>所谓完美转发(perfect forwarding)，是指在函数模板中，完全依照模板的参数的类型，将参数传递给函数模板中调用的另外一个函数。比如<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IamForwording</span><span class="params">(T t)</span> </span>&#123; IruncodeActually(t); &#125;</span><br></pre></td></tr></table></figure></p>
<p>这个简单的例子中，<code>IamForwording</code>是一个转发函数模板。而函数<code>IruncodeActually</code>则是真正执行代码的目标函数。对于目标函数<code>IruncodeActually</code>而言，它总是希望转发函数将参数按照传入<code>Iamforwarding</code>时的类型传递，而不产生额外的开销，就好像转发者不存在一样。通常程序员需要的是一个引用类型，引用类型不会有拷贝的开销。其次，则需要考虑转发函数对类型的接受能力。因为目标函数可能需要能够既接受左值引用，又接受右值引用。</p>
<p>以常量左值为参数的转发函数却会遇到一些尷尬，比如<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IrunCodeActually</span><span class="params">(<span class="keyword">int</span> t)</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IamForwording</span><span class="params">(<span class="keyword">const</span> T&amp; t)</span> </span>&#123; IrunCodeActually(t); &#125;</span><br></pre></td></tr></table></figure></p>
<p>这里，由于目标函数的参数类型是非常量左值引用类型，因此无法接受常量左值引用作为参数，这样一来，虽然转发函数的接受能力很高，但在目标函数的接受上却出了问题。那么我们可能就需要通过一些常量和非常量的重载来解决目标函数的接受问题。C++11通过引入一条所谓“引用折叠”(reference collapsing)的新语言规则，并结合新的模板推导规则来完成完美转发。</p>
<p>在C++11以前，形如下列语句：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">const</span> <span class="keyword">int</span> T;</span><br><span class="line"><span class="keyword">typedef</span> T&amp; TR;</span><br><span class="line">TR&amp; v = <span class="number">1</span>;</span><br></pre></td></tr></table></figure></p>
<p>其中<code>TR&amp; v = 1</code>这样的表达式会被编译器认为是不合法的表达式，而在C++11中，一旦出现了这样的表达式，就会发生引用折叠，即将复杂的未知表达式折叠为已知的简单表达式，具体如表。<br><img src="/img/1628501072.jpg" alt></p>
<p>这个规则并不难记忆，因为一旦定义中出现了左值引用，引用折叠总是优先将其折叠为值引用。而模板对类型的推导规则就比较简单，当转发函数的实参是类型X的一个左值引用，那么模板参数被推导为<code>X&amp;</code>类型，而转发函数的实参是类型<code>X</code>的一个右值引用的话，那么模板的参数被推导为<code>X&amp;&amp;</code>类型。结合以上的引用折叠规则，就能确定出参数的实际类型进一步，我们可以把转发函数写成如下形式：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IamForwording</span> <span class="params">(T &amp;&amp; t)</span> </span>&#123;</span><br><span class="line">    IrunCodeActually(<span class="keyword">static_cast</span>&lt;T &amp;&amp;&gt;(t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们不仅在参数部分使用了<code>T&amp;&amp;</code>这样的标识，在目标函数传参的强制类型转换中也使用了这样的形式。比如我们调用转发函数时传入了一个<code>X</code>类型的左值引用，可以想象，转发函数将被实例化为如下形式：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IamForwording</span><span class="params">(X&amp; &amp;&amp; t)</span> </span>&#123;</span><br><span class="line">    IrunCodeActually(<span class="keyword">static_cast</span>&lt;X&amp;&amp;&amp;&gt;(t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>应用上引用折叠规则，就是：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IamForwording</span><span class="params">(X&amp; t)</span> </span>&#123;</span><br><span class="line">    IrunCodeActually(<span class="keyword">static_cast</span>&lt;X&amp;&gt;(t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样一来，我们的左值传递就毫无问题了。实际使用的时候，<code>IrunCodeActually</code>如果接受左值引用的话，就可以直接调用转发函数。不过读者可能发现，这里调用前的 <code>static_cast</code>没有什么作用。事实上，这里的<code>static_cast</code>是留给传递右值用的。</p>
<p>而如果我们调用转发函数时传入了一个<code>X</code>类型的右值引用的话，我们的转发函数将被实例化为<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IamForwording</span><span class="params">(X&amp;&amp; &amp;&amp; t)</span> </span>&#123;</span><br><span class="line">    IrunCodeActually(<span class="keyword">static_cast</span>&lt;X&amp;&amp;&amp;&amp;&gt;(t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>应用上引用折叠规则，就是：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IamForwording</span><span class="params">(X&amp;&amp; t)</span> </span>&#123;</span><br><span class="line">    IrunCodeActually(<span class="keyword">static_cast</span>&lt;X&amp;&amp;&gt;(t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里我们就看到了<code>static_cast</code>的重要性。对于一个右值而言，当它使用右值引用表达式引用的时候，该右值引用却是个不折不扣的左值，那么我们想在函数调用中继续传递右值，就需要使用<code>std::move</code>来进行左右值的转换。而<code>std::move</code>通常就是一个<code>static_cast</code>。不过在C++11中，用于完美转发的函数却不再叫作<code>move</code>，而是另外一个名字：<code>forward</code>。所以我们可以把转发函数写成这样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="function"><span class="keyword">void</span> <span class="title">IamForwording</span><span class="params">(T &amp;&amp; t)</span> </span>&#123;</span><br><span class="line">    IrunCodeActually(forward(t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们来看一个完美转发的例子。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RunCode</span><span class="params">(<span class="keyword">int</span> &amp;&amp; m)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"rvalue ref"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RunCode</span><span class="params">(<span class="keyword">int</span> &amp; m)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"lvalue ref"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RunCode</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;&amp; m)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"const rvalue ref"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RunCode</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp; m)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"const lvalue ref"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PerfectForward</span><span class="params">(T &amp;&amp;t)</span> </span>&#123;</span><br><span class="line">    RunCode(forward&lt;T&gt;(t));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> c = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> d = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    PerfectForward(a);      <span class="comment">// lvalue ref</span></span><br><span class="line">    PerfectForward(move(b));      <span class="comment">// rvalue ref</span></span><br><span class="line">    PerfectForward(c);      <span class="comment">// const lvalue ref</span></span><br><span class="line">    PerfectForward(move(d));      <span class="comment">// const rvalue ref</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们使用了表3-1中的所有4种类型的值对完美转发进行测试，可以看到，所有的转发都被正确地送到了目的地。</p>
<p>完美转发的一个作用就是做包装函数，这是一个很方便的功能。可以用很少的代码记录单参数函数的参数传递状况。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PerfectForward</span><span class="params">(T &amp;&amp;t, U&amp; Func)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; t &lt;&lt; <span class="string">"\tforwarded."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    Func(forward&lt;T&gt;(t));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RunCode</span><span class="params">(<span class="keyword">double</span> &amp;&amp; m)</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RunHome</span><span class="params">(<span class="keyword">double</span> &amp;&amp; )</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RunComp</span><span class="params">(<span class="keyword">double</span> &amp;&amp; m)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    PerfectForward(<span class="number">1.5</span>, RunComp);</span><br><span class="line">    PerfectForward(<span class="number">8</span>,   RunCode);</span><br><span class="line">    PerfectForward(<span class="number">1.5</span>, RunHome);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>C++11标准库中我们可以看到大量完美转发的实际应用，一些很小巧好用的函数，比如<code>make_pair</code>、<code>make_unique</code>等都通过完美转发实现了。</p>
<h2 id="显式转换操作符"><a href="#显式转换操作符" class="headerlink" title="显式转换操作符"></a>显式转换操作符</h2><p>我们确实应该阻止会产生歧义的隐式转换。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ptr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Ptr(T* p) : _p(p) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* _p;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    Ptr&lt;<span class="keyword">int</span>&gt; p(&amp;a); <span class="comment">//自动转换为bool型，没有问题</span></span><br><span class="line">    <span class="keyword">if</span> (p)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"valid pointer. "</span> &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// valid pointer</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"invalid pointer. "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        </span><br><span class="line">    Ptr&lt;<span class="keyword">double</span>&gt; pd(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p + pd &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 1， 相加没有意义</span></span><br></pre></td></tr></table></figure></p>
<p>我们定义了一个指针模板类型<code>Ptr</code>。我们为指针编写了自定义类型转换到bool类型的函数，这样的转换使得<code>Ptr&lt;int&gt;</code>和<code>Ptr&lt;double&gt;</code>两个指针的加法运算获得了语法上的允许。</p>
<p>在C++11中，标准将<code>explicit</code>的使用范围扩展到了自定义的类型转换操作符上，以支持所谓的“显式类型转换”。<code>explicit</code>关键字作用于类型转换操作符上，意味着只有在直接构造目标类型或显式类型转换的时候可以使用该类型。所谓显式类型转换并没完全禁止从源类型到目标类型的转换，不过由于此时拷贝构造和非显式类型转换不被允许，那么我们通常就不能通过赋值表达式或者函数参数的方式来产生这样一个目标类型。</p>
<h2 id="列表初始化"><a href="#列表初始化" class="headerlink" title="列表初始化"></a>列表初始化</h2><h3 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h3><p>如标准程序库中的vector这样的容器，总是需要声明对象-循环初始化这样的重复动作，这对于使用模板的泛型编程无疑是非常不利的。在C++11中，集合(列表)的初始化已经成为C++语言的一个基本功能，在C++11中，这种初始化的方法被称为“初始化列表”。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>&#125;; <span class="comment">//C++98通过，C++11通过</span></span><br><span class="line"><span class="keyword">int</span> b[] &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>&#125;; <span class="comment">//C++98失败，C++11通过</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; c&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>&#125;; <span class="comment">//C++98失败，C++11通过</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">float</span>&gt; d = &#123;&#123;<span class="number">1</span>, <span class="number">1.0f</span>&#125;, &#123;<span class="number">2</span>, <span class="number">2.0f</span>&#125;, &#123;<span class="number">5</span>, <span class="number">3.2f</span>&#125;&#125;; <span class="comment">//C++98失败，C+11通过</span></span><br></pre></td></tr></table></figure></p>
<p>我们看到了变量b、c、d在C++98的情况下均无法通过编译，在C++11中，却由于列表初始化的存在而可以通过编译。这里，列表初始化可以在“{}”花括号之前使用等号，其效果与不带使用等号的初始化相同。</p>
<p>这样一来，自动变量和全局变量的初始化在C++11中被丰富了。程序员可以使用以下几种形式完成初始化的工作</p>
<ul>
<li>等号“=”加上赋值表达式，比如<code>int a = 3+4</code></li>
<li>等号“=”加上花括号式的初始化列表，比如<code>int a = {3+4}</code></li>
<li>圆括号式的表达式列表，比如<code>int a (3+4)</code></li>
<li>花括号式的初始化列表，比如<code>int a {3+4}</code></li>
</ul>
<p>而后两种形式也可以用于获取堆内存new操作符中，比如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">double</span> *d = <span class="keyword">new</span> <span class="keyword">double</span>&#123;<span class="number">1.2f</span>&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在C++11中，标准总是倾向于使用更为通用的方式来支持新的特性。标准模板库中容器对初始化列表的支持源自<code>&lt;initializer_list&gt;</code>这个头文件中<code>initialize_list</code>类模板的支持。程序员只要include了<code>&lt;initializer_list&gt;</code>头文件，井且声明一个以<code>initialize_list&lt;T&gt;</code>模板类为参数的构造函数，同样可以使得自定义的类使用列表初始化。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Gender &#123;boy, girl&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    People(<span class="built_in">initializer_list</span>&lt;pair&lt;<span class="built_in">string</span>, Gender&gt;&gt; l) &#123;</span><br><span class="line">        <span class="keyword">auto</span> i = l.begin();</span><br><span class="line">        <span class="keyword">for</span> (; i != l.end(); i ++)</span><br><span class="line">            data.push_back(*i);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;pair&lt;<span class="built_in">string</span>, Gender&gt;&gt; data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">People ship2 = &#123;&#123;<span class="string">"Garfield"</span>, boy&#125;, &#123;<span class="string">"Hellokitty"</span>, girl&#125;&#125;;</span><br></pre></td></tr></table></figure>
<p>类和结构体的成员函数也可以使用初始化列表，包括一些操作符的重载函数。而在代码所示的这个例子中，我们利用了初始化列表重载了<code>operator[]</code>，并且重载了<code>operator=</code>以及使用辅助的数组。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mydata</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Mydata &amp; <span class="keyword">operator</span>[] (<span class="built_in">initializer_list</span>&lt;<span class="keyword">int</span>&gt; input) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = input.begin(); i != input.end(); ++i)</span><br><span class="line">            idx.push_back(*i);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Mydata &amp; <span class="keyword">operator</span> = (<span class="keyword">int</span> v) &#123;</span><br><span class="line">        <span class="keyword">if</span> (idx.empty() != <span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> i = idx.begin(); i != idx.end(); ++i) &#123;</span><br><span class="line">                d.resize((*i &gt; d.size()) ? *i : d.size());</span><br><span class="line">                d[*i - <span class="number">1</span>] = v;</span><br><span class="line">            &#125;</span><br><span class="line">            idx.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = d.begin(); i != d.end(); ++i)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; *i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; idx;<span class="comment">//辅助数组，用于记录index</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line">&#125;;</span><br><span class="line">Mydata mydata;	</span><br><span class="line">mydata[&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;] = <span class="number">7</span>;	</span><br><span class="line">mydata[&#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>&#125;] = <span class="number">4</span>;	</span><br><span class="line">mydata.print();</span><br></pre></td></tr></table></figure></p>
<p>此外，初始化列表还可以用于函数返回的情况。返回一个初始化列表，通常会导致构造个临时变量，比如<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; Func() &#123; <span class="keyword">return</span> &#123;<span class="number">1</span>, <span class="number">3</span>&#125;; &#125;</span><br></pre></td></tr></table></figure></p>
<p>当然，跟声明时采用列表初始化一样，列表初始化构造成什么类型是依据返回类型的比如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; Func2() &#123; <span class="keyword">return</span> &#123;<span class="number">3</span>, <span class="number">5</span>&#125;; &#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的返回值就是以<code>deque&lt;int&gt;</code>列表初始化构造函数而构造的。而跟普通的字面量相同，如果返回值是一个引用类型的话，则会返回一个临时变量的引用。比如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; Func1() &#123; <span class="keyword">return</span> &#123;<span class="number">3</span>, <span class="number">5</span>&#125;; &#125;</span><br></pre></td></tr></table></figure></p>
<p>这里注意，必须要加const限制符。该规则与返回一个字面常量是一样的。</p>
<h3 id="防止类型收窄"><a href="#防止类型收窄" class="headerlink" title="防止类型收窄"></a>防止类型收窄</h3><p>类型收窄一般是指一些可以使得数据变化或者精度丢失的隐式类型转换。可能导致类型收窄的典型情况如下：</p>
<ul>
<li>从浮点数隐式地转化为整型数。</li>
<li>从高精度的浮点数转为低精度的浮点数</li>
<li>从整型转化为浮点型</li>
<li>从整型转化为较低长度的整型</li>
</ul>
<p>在C++11中，使用初始化列表进行初始化的数据，编译器是会检查其是否发生类型收窄的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> x = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> y = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> a = x;                  <span class="comment">// 收窄，但可以通过编译</span></span><br><span class="line"><span class="keyword">char</span>* b = <span class="keyword">new</span> <span class="keyword">char</span>(<span class="number">1024</span>);    <span class="comment">// 收窄，但可以通过编译</span></span><br><span class="line"><span class="keyword">char</span> c = &#123;x&#125;;                <span class="comment">// 收窄，无法通过编译</span></span><br><span class="line"><span class="keyword">char</span> d = &#123;y&#125;;                <span class="comment">// 可以通过编译</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> e &#123;<span class="number">-1</span>&#125;;        <span class="comment">// 收窄，无法通过编译</span></span><br><span class="line"><span class="keyword">float</span> f &#123;<span class="number">7</span>&#125;                  <span class="comment">// 可以通过编译</span></span><br><span class="line"><span class="keyword">int</span> g &#123; <span class="number">2.0f</span> &#125;;              <span class="comment">// 收窄，无法通过编译</span></span><br><span class="line"><span class="keyword">float</span> *h = <span class="keyword">new</span> <span class="keyword">float</span> &#123;<span class="number">1e48</span>&#125;; <span class="comment">// 收窄，无法通过编译</span></span><br><span class="line"><span class="keyword">float</span> i = <span class="number">1.2l</span>;              <span class="comment">// 可以通过编译</span></span><br></pre></td></tr></table></figure></p>
<p>在C++11中，列表初始化是唯一一种可以防止类型收窄的初始化方式。这也是列表初始化区别于其他初始化方式的地方。事实上，现有编译器大多数会在发生类型收窄的时候提示用户，因为类型收窄通常是代码可能出现问题的征兆。C++11将列表初始化设定为可以防范收窄，也就是为了加强类型使用的安全性。</p>
<h2 id="POD类型"><a href="#POD类型" class="headerlink" title="POD类型"></a>POD类型</h2><p>POD是英文中 Plain Old Data的缩写。C++11将POD划分为两个基本概念的合集，即：平凡的(trivial)和标准布局的(standard layout)。</p>
<p>通常情况下，一个平凡的类或结构体应该符合以下定义：</p>
<ol>
<li>拥有平凡的默认构造函数(trivial constructor)和析构函数(trivial destructor)。平凡的默认构造函数就是说构造函数“什么都不干””。通常情况下，不定义类的构造函数，编译器就会为我们生成一个平凡的默认构造函数。而一旦定义了构造函数，即使构造函数不包含参数，函数体里也没有任何的代码，那么该构造函数也不再是“平凡”的。</li>
<li>拥有平凡的拷贝构造函数(trivial copy constructor)和移动构造函数(trivial move constructor)。平凡的拷贝构造函数基本上等同于使用<code>memcpy</code>进行类型的构造。同平凡的默认构造函数一样，不声明拷贝构造函数的话，编译器会帮程序员自动地生成。同样地，可以显式地使用<code>= default</code>声明默认拷贝构造函数。</li>
<li>拥有平凡的拷贝赋值运算符(trivial assignment operator)和移动赋值运算符(trivial move operator)。这基本上与平凡的拷贝构造函数和平凡的移动构造运算符类似。</li>
<li>不能包含虚函数以及虚基类。</li>
</ol>
<p>C++11中，我们可以通过一些辅助的类模板来帮我们进行以上属性的判断<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">struct</span> <span class="title">std</span>:</span>:is_trivial;</span><br></pre></td></tr></table></figure></p>
<p>类模板<code>is_trivial</code>的成员<code>value</code>可以用于判断<code>T</code>的类型是否是一个平凡的类型。除了类和结构体外，<code>is_trivial</code>还可以对内置的标量类型数据及数组类型进行判断。</p>
<p>POD包含的另外一个概念是标准布局。标准布局的类或结构体应该符合以下定义：</p>
<ul>
<li>所有非静态成员有相同的访问权限(public，prvate，protected)</li>
<li>在类或者结构体继承时，满足以下两种情况之一<ul>
<li>派生类中有非静态成员，且只有一个仅包含静态成员的基类</li>
<li>基类有非静态成员，而派生类没有非静态成员</li>
<li>这样的类或者结构体，也是标准布局的。比如：<ul>
<li><code>struct B1 { static int a; };</code></li>
<li><code>struct D1 : B1 { int d; };</code></li>
<li><code>struct B2 { int a; };</code></li>
<li><code>struct D2 : B2 { static int d; }</code></li>
<li><code>struct D3 : B2, B1 { static int d; };</code></li>
<li><code>struct D4 : B2 { int d; };</code></li>
<li><code>struct D5 : B2, D1 { }</code></li>
</ul>
</li>
<li>D1、D2和D3都是标准布局的，而D4和D5则不属于标准布局的。这实际上使得非静态成员只要同时出现在派生类和基类间，其即不属于标准布局的。而多重继承也会导致类型布局的一些变化，所以一且非静态成员出现在多个基类中，派生类也不属于标准布局的</li>
</ul>
</li>
<li>类中第一个非静态成员的类型与其基类不同。<ul>
<li>用于形如<code>struct A : B { B b; };</code>这样的情况。这里A类型不是一个标准布局的类型，因为第一个非静态成员变量b的类型跟A所继承的类型B相同。</li>
<li>形如<code>struct C: B { int a; B b; }</code>则是一个标准布局的类型。</li>
<li>该规则实际上是基于C++中允许优化不包含成员的基类而产生的。</li>
</ul>
</li>
<li>没有虚函数和虚基类</li>
<li>所有非静态数据成员均符合标准布局类型，其基类也符合标准布局。</li>
</ul>
<p>在C++标准中，如果基类没有成员，标准允许派生类的第一个成员与基类共享地址，基类并没有占据任何实际的空间，但此时若该派生类的第一个成员类型仍然是基类，编译器仍会为基类分配1字节的空间，这是因为C++标准要求类型相同的对象必须地址不同，所以C++11标准强制要求POD类型的派生类的第一个非静态成员的类型必须不同于基类。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A1</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A2</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B1</span>:</span><span class="keyword">public</span> A1 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A1 a1;</span><br><span class="line">    <span class="keyword">int</span> b1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B2</span>:</span><span class="keyword">public</span> A1 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A2 a2;</span><br><span class="line">    <span class="keyword">int</span> b2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B3</span>:</span><span class="keyword">public</span> A1 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> b3;</span><br><span class="line">    A1 a1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    B1 b1;b1.b1=<span class="number">0xb1</span>;</span><br><span class="line">    B2 b2;b2.b2=<span class="number">0xb2</span>;</span><br><span class="line">    B3 b3;b3.b3=<span class="number">0xb3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"sizeof(b1)="</span>&lt;&lt;<span class="keyword">sizeof</span>(b1)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"&amp;b1   ="</span>&lt;&lt;&amp;b1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"&amp;b1.a1="</span>&lt;&lt;&amp;b1.a1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"&amp;b1.b1="</span>&lt;&lt;&amp;b1.b1&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"sizeof(b2)="</span>&lt;&lt;<span class="keyword">sizeof</span>(b2)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"&amp;b2   ="</span>&lt;&lt;&amp;b2&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"&amp;b2.a2="</span>&lt;&lt;&amp;b2.a2&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"&amp;b2.b2="</span>&lt;&lt;&amp;b2.b2&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"sizeof(b3)="</span>&lt;&lt;<span class="keyword">sizeof</span>(b3)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"&amp;b3   ="</span>&lt;&lt;&amp;b3&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"&amp;b3.b3="</span>&lt;&lt;&amp;b3.b3&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"&amp;b3.a1="</span>&lt;&lt;&amp;b3.a1&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;boolalpha&lt;&lt;is_standard_layout&lt;B1&gt;::value&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;boolalpha&lt;&lt;is_standard_layout&lt;B2&gt;::value&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;boolalpha&lt;&lt;is_standard_layout&lt;B3&gt;::value&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">sizeof(b1)=8</span><br><span class="line">&amp;b1   =0x28ff28</span><br><span class="line">&amp;b1.a1=0x28ff29</span><br><span class="line">&amp;b1.b1=0x28ff2c</span><br><span class="line"></span><br><span class="line">sizeof(b2)=8</span><br><span class="line">&amp;b2   =0x28ff20</span><br><span class="line">&amp;b2.a2=0x28ff20</span><br><span class="line">&amp;b2.b2=0x28ff24</span><br><span class="line"></span><br><span class="line">sizeof(b3)=8</span><br><span class="line">&amp;b3   =0x28ff18</span><br><span class="line">&amp;b3.b3=0x28ff18</span><br><span class="line">&amp;b3.a1=0x28ff1c</span><br><span class="line"></span><br><span class="line">false</span><br><span class="line">true</span><br><span class="line">true</span><br></pre></td></tr></table></figure></p>
<p>在C++11中，我们可以使用模板类来帮助判断类型是否是一个标准布局的类型。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">struct</span> <span class="title">std</span>:</span>:is_standard_layout;</span><br></pre></td></tr></table></figure></p>
<p>对于POD而言，在C++11中的定义就是平凡的和标准布局的两个方面。同样地，要判定某一类型是否是POD，标准库中的<code>&lt;type_traits&gt;</code>头文件也为程序员提供了如下模板类：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">struct</span> <span class="title">std</span>:</span>:is_pod;</span><br></pre></td></tr></table></figure></p>
<p>POD最为复杂的地方还是在类或者结构体的判断。使用POD有什么好处呢?</p>
<ul>
<li>字节赋值，代码中我们可以安全地使用<code>memset</code>和<code>memcpy</code>对POD类型进行初始化和拷贝等操作。</li>
<li>提供对C内存布局兼容。C++程序可以与C函数进行相互操作，因为POD类型的数据在C与C++间的操作总是安全的</li>
<li>保证了静态初始化的安全有效。静态初始化在很多时候能够提高程序的性能，而POD类型的对象初始化往往更加简单</li>
</ul>
<h2 id="非受限联合体"><a href="#非受限联合体" class="headerlink" title="非受限联合体"></a>非受限联合体</h2><p>联合体(union)是一种构造类型的数据结构。在一个联合体内，我们可以定义多种不同的数据类型，这些数据将会共享相同内存空间，这在一些需要复用内存的情况下，可以达到节省空间的目的。</p>
<p>除了非POD类型之外，C++98标准也不允许联合体拥有静态或引用类型的成员。这样虽然可能在一定程度上保证了和C的兼容性，不过也为联合体的使用带来了很大的限制。而且通过长期的实践应用证明，C++98标准对于联合体的限制是完全没有必要的。在新的C++11标准中，取消了联合体对于数据成员类型的限制。标准规定，任何非引用类型都可以成为联合体的数据成员，这样的联合体即所谓的非受限联合体(Unrestricted Union)。</p>
<h2 id="用户自定义字面量"><a href="#用户自定义字面量" class="headerlink" title="用户自定义字面量"></a>用户自定义字面量</h2><p>在C/C++程序中，程序员常常会使用结构体或者类来创造新的类型，以满足实际的需求。C++11标准可以通过确定一个后缀标识的操作符，将声明了该后缀标识的字面量转化为需要的类型。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> uint8;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RGBA</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    uint8 r;</span><br><span class="line">    uint8 g;</span><br><span class="line">    uint8 b;</span><br><span class="line">    uint8 a;</span><br><span class="line">    RGBA(uint8 R, uint8 G, uint8 B, uint8 A = <span class="number">0</span>)</span><br><span class="line">        : r(R), g(G), b(B), a(A)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">RGBA <span class="keyword">operator</span> <span class="string">""</span> _C(<span class="keyword">const</span> <span class="keyword">char</span>* col, <span class="keyword">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* p = col;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* end = col + n;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* r, *g, *b, *a;</span><br><span class="line">    r = g = b = a = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">for</span> (; p != end; ++p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (*p == <span class="string">'r'</span>) r = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (*p == <span class="string">'g'</span>) g = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (*p == <span class="string">'b'</span>) b = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (*p == <span class="string">'a'</span>) a = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="literal">nullptr</span> == r) || (<span class="literal">nullptr</span> == g) || (<span class="literal">nullptr</span> == b))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="literal">nullptr</span> == a)</span><br><span class="line">        <span class="keyword">return</span> RGBA(atoi(r + <span class="number">1</span>), atoi(g + <span class="number">1</span>), atoi(b + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> RGBA(atoi(r + <span class="number">1</span>), atoi(g + <span class="number">1</span>), atoi(b + <span class="number">1</span>), atoi(a + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, RGBA&amp; col)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> out &lt;&lt; <span class="string">"r: "</span> &lt;&lt; (<span class="keyword">int</span>)col.r</span><br><span class="line">        &lt;&lt; <span class="string">", g: "</span> &lt;&lt; (<span class="keyword">int</span>)col.g</span><br><span class="line">        &lt;&lt; <span class="string">", b: "</span> &lt;&lt; (<span class="keyword">int</span>)col.b</span><br><span class="line">        &lt;&lt; <span class="string">", a: "</span> &lt;&lt; (<span class="keyword">int</span>)col.a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">blend</span><span class="params">(RGBA &amp;&amp; col1, RGBA &amp;&amp; col2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"blend "</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; col1 &lt;&lt; col2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    blend(<span class="string">"r255 g240 b155"</span>_C, <span class="string">"r15 g255 b10 a7"</span>_C);</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*运行结果</span></span><br><span class="line"><span class="comment">blend</span></span><br><span class="line"><span class="comment">r: 255, g: 240, b: 155, a: 0</span></span><br><span class="line"><span class="comment">r: 15, g: 255, b: 10, a: 7</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p>
<p>这里，我们声明了一个字面量操作符(literal operator)函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RGBA <span class="keyword">operator</span> <span class="string">""</span>_C(<span class="keyword">const</span> <span class="keyword">char</span> *col, <span class="keyword">size_t</span> n)</span><br></pre></td></tr></table></figure></p>
<p>函数。这个函数会解析以<code>_C</code>为后缀的字符串，并返回一个RGBA的临时变量。有了这样一个用户字面常量的定义，<code>main</code>函数中我们不再需要通过声明RGBA类型的声明变量-传值运算的方式来传递实际意义上的常量。通过声明一个字符串以及一个<code>_C</code>后缀，<code>operator &quot;&quot; _C</code>函数会产生临时变量。<code>blend</code>函数就可以通过右值引用获得这些临时值并进行计算了。这样一来，用户就完成了定义自定义类型的字面常量，<code>main</code>函数中的代码书写显得更加清晰。</p>
<p>在C++11中，标准要求声明字面量操作符有一定的规则该规则跟字面量的“类型”密切相关。C++11中具体规则如下：</p>
<ul>
<li>如果字面量为整型数，那么字面量操作符函数只可接受unsigned long long或者 <code>const char*</code>为其参数。当unsigned long long无法容纳该字面量的时候，编译器会自动将该字面量转化为以0为结束符的字符串，并调用以<code>const char*</code>为参数的版本进行处理。</li>
<li>如果字面量为浮点型数，则字面量操作符函数只可接受long double或者<code>const char*</code>为参数。<code>const char*</code>版本的调用规则同整型的一样。</li>
<li>如果字面量为字符串，则字面量操作符函数函数只可接受<code>const char*</code>、<code>size_t</code>为参数。</li>
<li>如果字面量为字符，则字面量操作符函数只可接受一个char为参数。</li>
</ul>
<p>应该注意以下几点:</p>
<ul>
<li>在字面量操作符函数的声明中，<code>operator&quot;&quot;</code>与用户自定义后缀之间必须有空格。</li>
<li>后缀建议以下划线开始。不宜使用非下划线后级的用户自定义字符串常量，否则会被编译器警告。</li>
</ul>
<h2 id="内联名字空间"><a href="#内联名字空间" class="headerlink" title="内联名字空间"></a>内联名字空间</h2><p>C++11中，标准引入了一个新特性，叫做“内联的名字空间”。通过关键字<code>inline namespace</code>就可以声明一个内联的名字空间。内联的名字空间允许程序员在父名字空间定义或特化子名字空间的模板。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">namespace</span> Jim &#123;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">namespace</span> Basic &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Knife</span> &#123;</span> Knife() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">" Knife in Basic."</span> &lt;&lt; <span class="built_in">endl</span>; &#125; &#125;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Corkscrew</span> &#123;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">namespace</span> Toolkit &#123;</span><br><span class="line">        <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">SwissArmyknife</span> &#123;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">namespace</span> Other &#123;</span><br><span class="line">        Knife b;<span class="comment">// Knife in Basic </span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Knife</span> &#123;</span> Knife() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Knife in other"</span> &lt;&lt; <span class="built_in">endl</span>; &#125; &#125;;</span><br><span class="line">        Knife c; <span class="comment">// Knife in other</span></span><br><span class="line">        Basic::Knife k; <span class="comment">// Knife in Basic</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Jim &#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;&gt; <span class="class"><span class="keyword">class</span> <span class="title">SwissArmyKnife</span>&lt;Knife&gt;&#123;</span>&#125;; <span class="comment">//编译通过</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Jim;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SwissArmyKnife&lt;Knife&gt; sknife;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们将名字空间 Basic和 Toolkit都声明为 inline的。此时，Lilei对库中模板的偏特化(<code>SwissArmyKnife&lt;Knife&gt;</code>)则可以通过编译。不过这里我们需要再次注意一下 <code>Other</code>这个名字空间中的状况。可以看到，变量<code>b</code>的声明语句是可以通过编译的，而且其被声明为一个<code>Basic::Knife</code>的类型。</p>
<h2 id="模板的别名"><a href="#模板的别名" class="headerlink" title="模板的别名"></a>模板的别名</h2><p>当遇到一些比较长的名字，尤其是在使用模板和域的时候，使用别名的优势会更加明显。比如：<code>typedef std::vector&lt;std::string&gt; strvec;</code>。这里使用<code>strvec</code>作为<code>std::vector&lt;std::string&gt;</code>的别名。在C++11中，定义别名已经不再是<code>typedef</code>的专属能力，使用<code>using</code>同样也可以定义类型的别名，而且从语言能力上看，<code>using</code>丝毫不比<code>typedef</code>逊色。</p>
<p>在使用模板程的时候，<code>using</code>的语法甚至比<code>typedef</code>更加灵活。比如下面这个例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">using</span> Mapstring = <span class="built_in">std</span>::<span class="built_in">map</span>&lt;T, <span class="keyword">char</span>*&gt;;</span><br><span class="line">Mapstring&lt;<span class="keyword">int</span>&gt; numberedstring;</span><br></pre></td></tr></table></figure></p>
<p>在这里，我们“模板式”地使用了<code>using</code>关键字，将<code>std::map&lt;T, char*&gt;</code>定义为了一个<code>Mapstring</code>类型，之后我们还可以使用类型参数对<code>Mapstring</code>进行类型的实例化，而使用<code>typedef</code>将无法达到这样的效果。</p>
<h2 id="一般化的SFINEA规则"><a href="#一般化的SFINEA规则" class="headerlink" title="一般化的SFINEA规则"></a>一般化的SFINEA规则</h2><p>SFINEA- Substitution failure is not an error，即“匹配失败不是错误”。更为确切地说，这条规则表示的是对重载的模板的参数进行展开的时候，如果展开导致了一些类型不匹配，编译器并不会报错。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">int</span> foo;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">typename</span> T::foo)</span> </span>&#123;&#125; <span class="comment">//第一个模板定义</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T)</span> </span>&#123;&#125;   <span class="comment">// 第二个模板定义</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    f&lt;Test&gt;(<span class="number">10</span>);</span><br><span class="line">    f&lt;<span class="keyword">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里通过typename知道<code>T</code>是一个类，第二个模板定义则接受一个<code>T</code>类型的参数。在<code>main</code>函数中，分别使用<code>f&lt;Test&gt;</code>和<code>f&lt;int&gt;</code>对模板进行实例化的时候会发现，对于<code>f&lt;int&gt;</code>来讲，虽然不存在<code>int::foo</code>这样的类型，编译器依然不会报错，相反地编译器会找到第二个模板定义并对其进行实例化。这样一来，就保证了编译的正确性。</p>
<p>基本上，这是一个使得C++模板推导规则符合程序员想象的规则。通过SFINAE我们能够使得模板匹配更为“精确”，即使得一些模板函数、模板类在实例化时使用特殊的模板版本，而另外一些则使用通用的版本，这样就大大增加了模板设计使用上的灵活性。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/C/" rel="tag"># C++</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/07/19/Linux检测工具/" rel="next" title="Linux检测工具">
                <i class="fa fa-chevron-left"></i> Linux检测工具
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/08/09/深入理解cpp11 笔记2/" rel="prev" title="深入理解C++11：C++11新特性解析与应用 笔记2">
                深入理解C++11：C++11新特性解析与应用 笔记2 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/header.jpg" alt="Hao Yu">
            
              <p class="site-author-name" itemprop="name">Hao Yu</p>
              <p class="site-description motion-element" itemprop="description">Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author</p>
          </div>
          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">353</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>
        	<audio controls="controls" loop="loop" preload="auto" src="/resource/xiaomeihao.mp3">
	        </audio>
	

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yuhao0102" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:yuh18@mails.tsinghua.edu.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#新标准的诞生"><span class="nav-number">1.</span> <span class="nav-text">新标准的诞生</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#C-11语言变化的领域"><span class="nav-number">1.1.</span> <span class="nav-text">C++11语言变化的领域</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#与硬件紧密合作"><span class="nav-number">1.2.</span> <span class="nav-text">与硬件紧密合作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#融入编程现实"><span class="nav-number">1.3.</span> <span class="nav-text">融入编程现实</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#保证稳定性和兼容性"><span class="nav-number">2.</span> <span class="nav-text">保证稳定性和兼容性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#保持与C99兼容"><span class="nav-number">2.1.</span> <span class="nav-text">保持与C99兼容</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#预定义宏"><span class="nav-number">2.1.1.</span> <span class="nav-text">预定义宏</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#func预定义标识符"><span class="nav-number">2.1.2.</span> <span class="nav-text">func预定义标识符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Pragma-操作符"><span class="nav-number">2.1.3.</span> <span class="nav-text">_Pragma 操作符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#变长参数的宏定义以及-VA-ARGS"><span class="nav-number">2.1.4.</span> <span class="nav-text">变长参数的宏定义以及 VA_ARGS</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#long-long整型"><span class="nav-number">2.2.</span> <span class="nav-text">long long整型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#扩展的整型"><span class="nav-number">2.3.</span> <span class="nav-text">扩展的整型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#宏-cplusplus"><span class="nav-number">2.4.</span> <span class="nav-text">宏__cplusplus</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#静态断言"><span class="nav-number">2.5.</span> <span class="nav-text">静态断言</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#断言：运行时与预处理时"><span class="nav-number">2.5.1.</span> <span class="nav-text">断言：运行时与预处理时</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#静态断言与static-assert"><span class="nav-number">2.5.2.</span> <span class="nav-text">静态断言与static_assert</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#noexcept修饰符与noexcept操作符"><span class="nav-number">2.6.</span> <span class="nav-text">noexcept修饰符与noexcept操作符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#快速初始化成员变量"><span class="nav-number">2.7.</span> <span class="nav-text">快速初始化成员变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#非静态成员的sizeof"><span class="nav-number">2.8.</span> <span class="nav-text">非静态成员的sizeof</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#扩展的friend语法"><span class="nav-number">2.9.</span> <span class="nav-text">扩展的friend语法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#final-override-控制"><span class="nav-number">2.10.</span> <span class="nav-text">final/override 控制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#模板函数的默认模板参数"><span class="nav-number">2.11.</span> <span class="nav-text">模板函数的默认模板参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#外部模板"><span class="nav-number">2.12.</span> <span class="nav-text">外部模板</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么需要外部模板"><span class="nav-number">2.12.1.</span> <span class="nav-text">为什么需要外部模板</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#显式的实例化与外部模板的声明"><span class="nav-number">2.12.2.</span> <span class="nav-text">显式的实例化与外部模板的声明</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#通用为本，专用为末"><span class="nav-number">3.</span> <span class="nav-text">通用为本，专用为末</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#继承构造函数"><span class="nav-number">3.1.</span> <span class="nav-text">继承构造函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#委派构造函数"><span class="nav-number">3.2.</span> <span class="nav-text">委派构造函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#右值引用：移动语义和完美转发"><span class="nav-number">3.3.</span> <span class="nav-text">右值引用：移动语义和完美转发</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#指针成员与拷贝构造"><span class="nav-number">3.3.1.</span> <span class="nav-text">指针成员与拷贝构造</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#移动语义"><span class="nav-number">3.3.2.</span> <span class="nav-text">移动语义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#左值、右值与右值引用"><span class="nav-number">3.3.3.</span> <span class="nav-text">左值、右值与右值引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#std-move：强制转化为右值"><span class="nav-number">3.3.4.</span> <span class="nav-text">std::move：强制转化为右值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#移动语义的一些其他问题"><span class="nav-number">3.3.5.</span> <span class="nav-text">移动语义的一些其他问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#完美转发"><span class="nav-number">3.3.6.</span> <span class="nav-text">完美转发</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#显式转换操作符"><span class="nav-number">3.4.</span> <span class="nav-text">显式转换操作符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#列表初始化"><span class="nav-number">3.5.</span> <span class="nav-text">列表初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#初始化列表"><span class="nav-number">3.5.1.</span> <span class="nav-text">初始化列表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#防止类型收窄"><span class="nav-number">3.5.2.</span> <span class="nav-text">防止类型收窄</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#POD类型"><span class="nav-number">3.6.</span> <span class="nav-text">POD类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#非受限联合体"><span class="nav-number">3.7.</span> <span class="nav-text">非受限联合体</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#用户自定义字面量"><span class="nav-number">3.8.</span> <span class="nav-text">用户自定义字面量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内联名字空间"><span class="nav-number">3.9.</span> <span class="nav-text">内联名字空间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#模板的别名"><span class="nav-number">3.10.</span> <span class="nav-text">模板的别名</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#一般化的SFINEA规则"><span class="nav-number">3.11.</span> <span class="nav-text">一般化的SFINEA规则</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>
  <div id="DvelopmentTarget">     
  </div>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart" aria-hidden="false"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>

  
</div>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_uv"> 
  本站访客数<span id="busuanzi_value_site_uv"></span>人次
</span>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  


  

  


  <script type="text/javascript" src="/js/src/love.js"></script>

</body>
</html>
