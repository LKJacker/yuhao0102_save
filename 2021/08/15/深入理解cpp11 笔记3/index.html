<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zn-ch">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-center-simple.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="C++,">










<meta name="description" content="为改变思考方式而改变指针空值nullptr指针空值：从0到NULL，再到nullptr一般情况下，NULL是一个宏定义。123456#undef NULL#if defined(__cpluspuls)#define NULL 0#else#define NULL ((void*)0)#endif NULL可能被定义为字面常量0，或者是定义为无类型指针void*常量。编译器总是会优先把NULL看作">
<meta name="keywords" content="C++">
<meta property="og:type" content="article">
<meta property="og:title" content="深入理解C++11：C++11新特性解析与应用 笔记3">
<meta property="og:url" content="http://yoursite.com/2021/08/15/深入理解cpp11 笔记3/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="为改变思考方式而改变指针空值nullptr指针空值：从0到NULL，再到nullptr一般情况下，NULL是一个宏定义。123456#undef NULL#if defined(__cpluspuls)#define NULL 0#else#define NULL ((void*)0)#endif NULL可能被定义为字面常量0，或者是定义为无类型指针void*常量。编译器总是会优先把NULL看作">
<meta property="og:locale" content="zn-ch">
<meta property="og:updated_time" content="2021-08-18T07:53:25.055Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="深入理解C++11：C++11新特性解析与应用 笔记3">
<meta name="twitter:description" content="为改变思考方式而改变指针空值nullptr指针空值：从0到NULL，再到nullptr一般情况下，NULL是一个宏定义。123456#undef NULL#if defined(__cpluspuls)#define NULL 0#else#define NULL ((void*)0)#endif NULL可能被定义为字面常量0，或者是定义为无类型指针void*常量。编译器总是会优先把NULL看作">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2021/08/15/深入理解cpp11 笔记3/">





  <title>深入理解C++11：C++11新特性解析与应用 笔记3 | Hao Yu's blog</title>
  








 
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zn-ch">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hao Yu's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">The program monkey was eaten by the siege lion.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/resume.pdf" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-mybetterhalf">
          <a href="/mybetterhalf/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>
            
            mybetterhalf
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/08/15/深入理解cpp11 笔记3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">深入理解C++11：C++11新特性解析与应用 笔记3</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-08-15T14:14:00+08:00">
                2021-08-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="为改变思考方式而改变"><a href="#为改变思考方式而改变" class="headerlink" title="为改变思考方式而改变"></a>为改变思考方式而改变</h1><h2 id="指针空值nullptr"><a href="#指针空值nullptr" class="headerlink" title="指针空值nullptr"></a>指针空值nullptr</h2><h3 id="指针空值：从0到NULL，再到nullptr"><a href="#指针空值：从0到NULL，再到nullptr" class="headerlink" title="指针空值：从0到NULL，再到nullptr"></a>指针空值：从0到NULL，再到nullptr</h3><p>一般情况下，NULL是一个宏定义。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> NULL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__cpluspuls)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NULL 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NULL ((void*)0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>NULL可能被定义为字面常量0，或者是定义为无类型指针<code>void*</code>常量。编译器总是会优先把NULL看作是一个整型常量，这会引起一些二义性，比如<code>int</code>和<code>char*</code>的重载。在C++11新标准中，为二义性给出了新的答案，就是<code>nullptr</code>，<code>nullptr</code>是一个所谓“指针空值类型”的常量。指针空值类型被命名为<code>nullptr_t</code>，事实上，我们可以在支持<code>nullptr_t</code>的头文件中找出如下定义<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(<span class="literal">nullptr</span>)</span> nullptr_t</span>;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，<code>nullptr_t</code>的定义方式非常有趣，使用<code>nullptr_t</code>的时候必须<code>include&lt;cstddef&gt;</code>，而<code>nullptr</code>则不用。这大概就是由于<code>nullptr</code>是关键字，而<code>nullptr_t</code>是通过推导而来的缘故。</p>
<p>而相比于gcc等编译器将NULL预处理为编译器内部标识<code>nul</code>，<code>nullptr</code>拥有更大的优势。简单而言，由于<code>nullptr</code>是有类型的，且仅可以被隐式转化为指针类型</p>
<h3 id="nullptr和nullptr-t"><a href="#nullptr和nullptr-t" class="headerlink" title="nullptr和nullptr_t"></a>nullptr和nullptr_t</h3><p>C++11标准不仅定义了指针空值常量<code>nullptr</code>，也定义了其指针空值类型<code>nullptr_t</code>，也就表示了指针空值类型并非仅有<code>nullptr</code>一个实例。通常情况下，也可以通过<code>nullptr_t</code>来声明个指针空值类型的变量(即使看起来用途不大)。除去<code>nullptr</code>及<code>nullptr_t</code>以外，C++中还存在各种内置类型。C++11标准严格规定了数据间的关系。大体上常见的规则简单地列在了下面：</p>
<ul>
<li>所有定义为<code>nullptr_t</code>类型的数据都是等价的，行为也是完全一致。</li>
<li><code>nullptr_t</code>类型数据可以隐式转换成任意一个指针类型</li>
<li><code>nullptr_t</code>类型数据不能转换为非指针类型，即使使用<code>reinterpret_cast&lt;nullptr_t&gt;()</code>的方式也是不可以的。</li>
<li><code>nullptr_t</code>类型数据不适用于算术运算表达式。</li>
<li><code>nullptr_t</code>类型数据可以用于关系运算表达式，但仅能与<code>nullptr_t</code>类型数据或者指针类型数据进行比较，当且仅当关系运算符为=、&lt;=、&gt;=等时返回true</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//nullptr可以隐式转换为 char*</span></span><br><span class="line">    <span class="keyword">char</span> *cp = <span class="literal">nullptr</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 不可转换为整型，而任何类型也不能转换为 nullptr_t</span></span><br><span class="line">    <span class="comment">// 以下代码不能通过编译</span></span><br><span class="line">    <span class="comment">// int n1 = nullptr;</span></span><br><span class="line">    <span class="comment">// int n2 = reinterpret_cast&lt;int&gt;(nullptr)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//nul1ptr与nullptr_t类型变量可以作比较</span></span><br><span class="line">    <span class="comment">//当使用=、&lt;=、&gt;=符号比较时返回true</span></span><br><span class="line">    <span class="keyword">nullptr_t</span> nptr;</span><br><span class="line">    <span class="keyword">if</span> (nptr == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"nullptr_t nptr == nullptr"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"nullptr_t nptr != nullptr"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> (nptr &lt; <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"nullptr_t nptr &lt; nullptr"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"nullptr_t nptr !&lt; nullptr"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不能转换为整型或bool类型，以下代码不能通过编译</span></span><br><span class="line">    <span class="comment">// if (0 == nullptr);</span></span><br><span class="line">    <span class="comment">// if (nullptr)</span></span><br><span class="line">    <span class="comment">// 不可以进行算术运算，以下代码不能通过编译</span></span><br><span class="line">    <span class="comment">// nullptr += 1;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//以下操作均可以正常进行</span></span><br><span class="line">    <span class="keyword">sizeof</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">typeid</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">throw</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="一些关于nullptr规则的讨论"><a href="#一些关于nullptr规则的讨论" class="headerlink" title="一些关于nullptr规则的讨论"></a>一些关于nullptr规则的讨论</h3><p>在C++11标准中，<code>nullptr</code>类型数据所占用的内存空间大小跟<code>void*</code>相同的，即<code>sizeof(nullptr_t)==sizeof(void*)</code>。两者在语法层面有着不同的内涵。<code>nullptr</code>是一个编译时期的常量，它的名字是一个编译时期的关键字，能够为编译器所识别。而<code>(void*)0</code>只是一个强制转换表达式，其返回的也是一个<code>void*</code>指针类型。而且最为重要的是，在C++语言中，<code>nullptr</code>到任何指针的转换是隐式的，而<code>(void*)0</code>则必须经过类型转换后才能使用。</p>
<h2 id="默认函数的控制"><a href="#默认函数的控制" class="headerlink" title="默认函数的控制"></a>默认函数的控制</h2><h3 id="类与默认函数"><a href="#类与默认函数" class="headerlink" title="类与默认函数"></a>类与默认函数</h3><p>在C++中声明自定义的类，编译器会默认帮助程序员生成一些他们未自定义的成员函数。这样的函数版本被称为“默认函数”。这包括了以下一些自定义类型的成员函数</p>
<ul>
<li>构造函数</li>
<li>拷贝构造函数</li>
<li>拷贝赋值函数</li>
<li>移动构造函数</li>
<li>移动拷贝函数</li>
<li>析构函数</li>
</ul>
<p>此外，C++编译器还会为以下这些自定义类型提供全局默认操作符函数：</p>
<ul>
<li><code>operator&amp;</code></li>
<li><code>operator&amp;&amp;</code></li>
<li><code>operator*</code></li>
<li><code>operator-&gt;</code></li>
<li><code>operator-&gt;*</code></li>
<li><code>operator new</code></li>
<li><code>operator delete</code></li>
</ul>
<p>在C++语言规则中，一旦程序员实现了这些函数的自定义版本，则编译器不会再为该类自动生成默认版本。有时这样的规则会被程序员忘记，最常见的是声明了带参数的构造版本，则必须声明不带参数的版本以完成无参的变量初始化。不过通过编译器的提示，这样的问题通常会得到更正。但更为严重的问题是，一旦声明了自定义版本的构造函数，则有可能导致我们定义的类型不再是POD的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_trait&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Twocstor</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 提供了带参数版本的构造函数，则必须自行提供</span></span><br><span class="line">    <span class="comment">// 不带参数版本，且Twocstor不再是POD类型</span></span><br><span class="line">    Twocstor() &#123;&#125;;</span><br><span class="line">    Twocstor(<span class="keyword">int</span> i): data(i) &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; is_pod&lt;Twocstor&gt;::value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然提供了<code>Twocstor()</code>构造函数，它与默认的构造函数接口和使用方式也完全一致，不过该构造函数却不是平凡的，因此<code>Twocstor</code>也就不再是POD的了。使用<code>is_pod</code>模板类查看<code>Twocstor</code>，也会发现程序输出为0。</p>
<p>在C++11中，标准提供default关键字，程序员可以在默认函数定义或者声明时加上<code>=default</code>，从而显式地指示编译器生成该函数的默认版本。而如果指定产生默认版本后，程序员不再也不应该实现一份同名的函数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> &lt;iostream》</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Twocstor</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 提供了带参数版本的构造函数，再指示编译器</span></span><br><span class="line">    <span class="comment">// 提供默认版本，则本自定义类型依然是POD类型</span></span><br><span class="line">    Twocstor() = <span class="keyword">default</span>;</span><br><span class="line">    Twocstor(<span class="keyword">int</span> i): data(i) &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>另一方面，程序员在一些情况下则希望能够限制一些默认函数的生成。最典型地，类的编写者有时需要禁止使用者使用拷贝构造函数，在C++98标准中，我们的做法是将拷贝构造函数声明为<code>private</code>的成员，并且不提供函数实现。这样一来，一且有人试图(或者无意识)使用拷贝构造函数，编译器就会报错。</p>
<p>在C++11中，标准则给出了更为简单的方法，即在函数的定义或者声明加上<code>=delete</code>会指示编译器不生成函数的缺省版本。</p>
<h3 id="“-default”与”-deleted”"><a href="#“-default”与”-deleted”" class="headerlink" title="“= default”与”= deleted”"></a>“= default”与”= deleted”</h3><p>C++11标准称<code>= default</code>修饰的函数为显式缺省(explicit defaulted)函数，而称<code>= delete</code>修饰的函数为删除(deleted)函数。C++11引入显式缺省和显式删除是为了增强对类默认函数的控制，让程序员能够更加精细地控制默认版本的函数。不过这并不是它们的唯一功能，而且使用上，也不仅仅局限在类的定义内。事实上，显式缺省不仅可以用于在类的定义中修饰成员函数，也可以在类定义之外修饰成员函数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Defaultedoptr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//使用“= default”来产生缺省版本</span></span><br><span class="line">    Defaultdoptr() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里没使用“default”</span></span><br><span class="line">    Defaultedoptr &amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> Defaultedoptr &amp;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 在类定义外用“= default”来指明使用缺省版本</span></span><br><span class="line"><span class="keyword">inline</span> Defaultedoptr &amp; Defaultedoptr::<span class="keyword">operator</span> =(<span class="keyword">const</span> Defaultedoptr &amp;) = <span class="keyword">default</span>;</span><br></pre></td></tr></table></figure></p>
<p>类<code>Defaultedoptr</code>的操作符<code>operator=</code>被声明在了类的定义外，并且被设定为缺省版本。这在C++11规则中也是被允许的。在类定义外显式指定缺省版本所带来的好处是，程序员可以对一个 class定义提供多个实现版本。</p>
<p>对一些普通的函数仍然可以通过显式删除来禁止类型转换。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Func</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Func</span><span class="params">(<span class="keyword">char</span> c)</span> </span>= <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Func(<span class="number">3</span>);</span><br><span class="line">    Func(<span class="string">'c'</span>);   <span class="comment">// 显式删除char版本</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>显式删除还有一些有趣的使用方式。比如使用显式删除来删除自定义类型的<code>operator new</code>操作符的话，皆可以做到避免在堆上分配该class的对象：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NoHeapAlloc</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> * <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span>)</span> </span>= <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    NoHeapAlloc n;</span><br><span class="line">    NoHeapAlloc * a = <span class="keyword">new</span> NoHeapAlloc(); <span class="comment">// 失败</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="lambda函数"><a href="#lambda函数" class="headerlink" title="lambda函数"></a>lambda函数</h2><h3 id="C-11中的lambda函数"><a href="#C-11中的lambda函数" class="headerlink" title="C++11中的lambda函数"></a>C++11中的lambda函数</h3><p>我们可以通过一个例子先来观察一下，如代码<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> girls = <span class="number">3</span>, boys = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">auto</span> totalChild = [] &#123;<span class="keyword">int</span> x, <span class="keyword">int</span> y&#125; -&gt;<span class="keyword">int</span>( <span class="keyword">return</span> x + y; &#125;</span><br><span class="line">    <span class="keyword">return</span> totalChild(girls, boys);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们定义了一个lambda函数。该函数接受两个参数<code>(int x, int y)</code>，并且返回其和。直观地看， lambda函数跟普通函数相比不需要定义函数名，取而代之的多了一对方括号<code>[]</code>。此外， lambda函数还采用了追踪返回类型的方式声明其返回值。其余方面看起来则跟普通函数定义一样。</p>
<p>而通常情况下， lambda函数的语法定义如下<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[capture] (parameters) <span class="keyword">mutable</span> -&gt; <span class="keyword">return</span>-type&#123;statement&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中：</p>
<ul>
<li><code>[capture]</code>：捕捉列表。捕捉列表总是出现在 lambda函数的开始处。事实上，<code>[]</code>是lambda引出符。编译器根据该引出符判断接下来的代码是否是lambda函数。捕捉列表能够捕捉上下文中的变量以供 lambda函数使用。具体的方法在下文中会再描述。</li>
<li><code>(parameters)</code>：参数列表。与普通函数的参数列表一致。如果不需要参数传递，则可以连同括号一起省略。</li>
<li><code>mutable</code>：<code>mutable</code>修饰符。默认情况下，lambda函数总是一个const函数，<code>mutable</code>可以取消其常量性。在使用该修饰符时，参数列表不可省略(即使参数为空)。</li>
<li><code>return-type</code>：返回类型。用追踪返回类型形式声明函数的返回类型。出于方便，不需要返回值的时候也可以连同符号<code>-&gt;</code>一起省略。此外，在返回类型明确的情况下也可以省略该部分，让编译器对返回类型进行推导。</li>
<li><code>{statement}</code>：函数体。内容与普通函数一样，不过除了可以使用参数之外，还可以使用所有捕获的变量。</li>
</ul>
<p>在lambda函数的定义中，参数列表和返还类型都是可选的部分，而捕捉列表和函数体都可能为空。那么在极端情况下，C++11中最为简略的alambda函数只需要声明为<code>[]{}</code>就可以了。不过该lambda函数不能做任何事情。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    []&#123;&#125;; <span class="comment">// 最简单的lambda函数</span></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">4</span>;</span><br><span class="line">    [=] &#123; <span class="keyword">return</span> a + b; &#125;   <span class="comment">// 省略了参数列表与返回类型，返回类型由编译器推断为int</span></span><br><span class="line">    <span class="keyword">auto</span> fun1 = [&amp;](<span class="keyword">int</span> c) &#123; b = a + c; &#125; <span class="comment">//省略了返回类型，无返回值</span></span><br><span class="line">    <span class="keyword">auto</span> fun2 = [=, &amp;b](<span class="keyword">int</span> c) -&gt; <span class="keyword">int</span> &#123; <span class="keyword">return</span> b = a + c; &#125;;<span class="comment">//各部分都很完整的lambda函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直观地讲， lambda函数与普通函数可见的最大区别之一，就是lambda函数可以通过捕捉列表访问一些上下文中的数据。具体地，捕捉列表描述了上下文中哪些的数据可以被lambda使用，以及使用方式(以值传递的方式或引用传递的方式)。</p>
<p>lambda函数的运算是基于初始状态进行的运算。这与函数简单基于参数的运算是有所不同的。语法上，捕捉列表由多个捕捉项组成，并以逗号分割。捕提列表有如下几种形式：</p>
<ul>
<li><code>[var]</code>表示值传递方式捕捉变量<code>var</code></li>
<li><code>[=]</code>表示值传递方式捕捉所有父作用域的变量(包括this)</li>
<li><code>[&amp;var]</code>表示引用传递捕捉变量<code>var</code></li>
<li><code>[&amp;]</code>表示引用传递捕捉所有父作用域的变量(包括this)</li>
<li><code>[this]</code>表示值传递方式捕提当前的this指针。</li>
</ul>
<p>通过一些组合，捕捉列表可以表示更复杂的意思。比如</p>
<ul>
<li><code>[=, &amp;a, &amp;b]</code>表示以引用传递的方式捕捉变量<code>a</code>和<code>b</code>，值传递方式捕提其他所有变量。</li>
<li><code>[&amp;, a, this]</code>表示以值传递的方式捕捉变量<code>a</code>和<code>this</code>，引用传递方式捕捉其他所有变量。</li>
</ul>
<p>不过值得注意的是，捕捉列表不允许变量重复传递。下面一些例子就是典型的重复，会导致编译时期的错误。</p>
<ul>
<li><code>[=, a]</code>这里<code>=</code>已经以值传递方式捕捉了所有变量，捕捉<code>a</code>重复</li>
<li><code>[&amp;, &amp;this]</code>这里<code>&amp;</code>已经以引用传递方式捕捉了所有变量，再捕捉this也是一种重复。</li>
</ul>
<h3 id="lambda与仿函数"><a href="#lambda与仿函数" class="headerlink" title="lambda与仿函数"></a>lambda与仿函数</h3><p>仿函数简单地说，就是重定义了成员函数<code>operator ()</code>的一种自定义类型对象。这样的对象有个特点，就是其使用在代码层面感觉跟函数的使用并无二样，但究其本质却并非函数。我们可以看一个仿函数的例子。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> _<span class="title">functor</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> x + y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> girls = <span class="number">3</span>, boys = <span class="number">4</span>;</span><br><span class="line">    _functor totalChild;</span><br><span class="line">    <span class="keyword">return</span> totalChild(<span class="number">5</span>, <span class="number">6</span>);</span><br></pre></td></tr></table></figure></p>
<p><code>class _functor</code>的<code>operator()</code>被重载，因此，在调用该函数的时候，我们看到跟函数调用一样的形式，只不过这里的<code>totalChild</code>不是函数名称，而是对象名称。</p>
<p>注意相比于函数，仿函数可以拥有初始状态，一般通过class定义私有成员，并在声明对象的时候对其进行初始化。私有成员的状态就成了仿函数的初始状态。而由于声明一个仿函数对象可以拥有多个不同初始状态的实例，因此可以借由仿函数产生多个功能类似却不同的仿函数实例。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tax</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">float</span> rate;</span><br><span class="line">    <span class="keyword">int</span> base;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Tax(<span class="keyword">float</span> r, <span class="keyword">int</span> b): rate(r), base(b) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">float</span> money)</span> </span>&#123; <span class="keyword">return</span> (money - base) * rate; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Tax <span class="title">high</span><span class="params">(<span class="number">0.4</span>, <span class="number">3000</span>)</span></span>;</span><br><span class="line">    <span class="function">Tax <span class="title">middle</span><span class="params">(<span class="number">0.25</span>, <span class="number">20000</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里通过带状态的仿函数，可以设定两种不同的税率的计算。而仔细观察的话，除去自定义类型<code>_functor</code>的声明及其对象的定义，除去在语法层面上的不同， lambda和仿函数有着相同的内涵，都可以捕捉一些变量作为初始状态并接受参数进行运算。</p>
<h3 id="lambda的基础使用"><a href="#lambda的基础使用" class="headerlink" title="lambda的基础使用"></a>lambda的基础使用</h3><p>最为简单的应用下，我们会利用 lambda函数来封装一些代码逻辑，使其不仅具有函数的包装性，也具有就地可见的自说明性。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> z;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">float</span> c;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Calc</span><span class="params">(<span class="keyword">int</span>&amp;, <span class="keyword">int</span>, <span class="keyword">float</span> &amp;, <span class="keyword">float</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Testcalc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x, y = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> success = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> validate = [&amp;]() -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ((x == y+z) &amp;&amp; (a == b+c))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    Calc (x, y, a, b);</span><br><span class="line">    success += validate();</span><br><span class="line">    y = <span class="number">1024</span>;</span><br><span class="line">    b = <span class="number">1e13</span>;</span><br><span class="line">    </span><br><span class="line">    Calc (x, y, a, b);</span><br><span class="line">    success += validate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里使用了一个<code>auto</code>关键字推导出了<code>validate</code>变量的类型为匿名 lambda函数。可以看到，我们使用lambda函数直接访问了<code>Testcal</code>中的局部的变量来完成这个工作。在没有 lambda函数之前，通常需要在<code>Testcalc</code>外声明同样一个函数，并且把 <code>Testcalc</code>中的变量当作参数进行传递。出于函数作用域及运行效率考虑，这样声明的函数通常还需要加上关键字 static和 inline。相比于一个传统意义上的函数定义， lambda函数在这里更加直观。</p>
<h3 id="关于lambda的一些问题及有趣的实验"><a href="#关于lambda的一些问题及有趣的实验" class="headerlink" title="关于lambda的一些问题及有趣的实验"></a>关于lambda的一些问题及有趣的实验</h3><p>使用 lambda函数的时候，捕捉列表不同会导致不同的结果。具体地讲，按值方式传递捕提列表和按引用方式传递捕捉列表效果是不一样的。对于按值方式传递的捕捉列表，其传递的值在 lambda函数定义的时候就已经决定了。而按引用传递的捕捉列表变量，其传递的值则等于 lambda函数调用时的值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">12</span>;</span><br><span class="line">    <span class="keyword">auto</span> by_val_lambda = [=] &#123; <span class="keyword">return</span> j + <span class="number">1</span>; &#125;;</span><br><span class="line">    <span class="keyword">auto</span> by_ref_lambda = [&amp;] &#123; <span class="keyword">return</span> j + <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"by val lambda: "</span> &lt;&lt; by_val_lambda() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"by ref lambda: "</span> &lt;&lt; by_ref_lambda() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    j ++;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"by val lambda: "</span> &lt;&lt; by_val_lambda() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"by ref lambda: "</span> &lt;&lt; by_ref_lambda() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">by val lambda: 13</span><br><span class="line">by ref lambda: 13</span><br><span class="line">by val lambda: 13</span><br><span class="line">by ref lambda: 13</span><br></pre></td></tr></table></figure></p>
<p>这个结果的原因是由于在<code>by_val_lambda</code>中，<code>j</code>被视为了一个常量，一旦初始化后不会再改变(可以认为之后只是一个跟父作用域中<code>j</code>同名的常量)而在<code>by_ref_lambda</code>中，<code>j</code>仍在使用父作用域中的值。</p>
<p>因此简单地总结的话，在使用 lambda函数的时候，如果需要捕捉的值成为 lambda函数的常量，我们通常会使用按值传递的方式捕捉；反之，需要捕捉的值成为 lambda函数运行时的变量(类似于参数的效果)，则应该采用按引用方式进行捕捉。</p>
<p>从C++11标准的定义上可以发现， lambda的类型被定义为“闭包”(closure)的类，而每个 lambda表达式则会产生一个闭包类型的临时对象(右值)。因此，严格地讲， lambda函数并非函数指针。不过C++11标准却允许 lambda表达是向函数指针的转换，但前提是lambda函数没有捕捉任何变量，且函数指针所示的函数原型，必须跟 lambda函数有着相同的调用方式。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> girls = <span class="number">3</span>, boys = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">auto</span> totalchild = [](<span class="keyword">int</span> x, <span class="keyword">int</span> y) -&gt; <span class="keyword">int</span> &#123; <span class="keyword">return</span> x + y; &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*allchild)</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*oneChild)</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line">    allchild p;</span><br><span class="line">    p = totalchild;</span><br><span class="line"></span><br><span class="line">    onechild q;</span><br><span class="line">    q = totalchild;    <span class="comment">// 编译失败</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">decltype</span>(totalchild) allpeople = totalchild; <span class="comment">// 需通过decltype获得lambda类型</span></span><br><span class="line">    <span class="keyword">decltype</span>(totalchild) totalpeople = p;        <span class="comment">// 编译失败，指针无法转成lambda</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们可以把没有捕捉列表的<code>totalchild</code>转化为接受参数类型相同的<code>allchild</code>类型的函数指针。不过，转化为参数类型不一致的<code>onechild</code>类型则会失败。此外，将函数指针转化为lambda也是不成功的。值得注意的是，程序员也可以通过<code>decltype</code>的方式来获得 lambda函数的类型。</p>
<p>除此之外，还有一个问题是关于 lambda函数的常量性及 mutable关键字的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">auto</span> const_val_lambda = [=]() &#123; val = <span class="number">3</span>; &#125;; <span class="comment">//编译失败，在const的lambda中修改常量</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//非const的lambda，可以修改常量数据</span></span><br><span class="line">    <span class="keyword">auto</span> mutable_val_lambda = [=]() <span class="keyword">mutable</span> &#123; val = <span class="number">3</span>; &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//依然是 const的lambda，不过没有改动引用本身</span></span><br><span class="line">    <span class="keyword">auto</span> const_ref_lambda = [&amp;] &#123; val = <span class="number">3</span>; &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//依然是 const的lambda，通过参数传递val</span></span><br><span class="line">    <span class="keyword">auto</span> const_param_lambda = [&amp;](<span class="keyword">int</span> v) &#123; v = <span class="number">3</span>; &#125;;</span><br><span class="line">    const_param_lambda(val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们定义了4种不同的 lambda函数，这4种 lambda 函数本身的行为都是一致的，即修改父作用域中传递而来的val参数的值。不过对于<code>const_val_lambda</code>函数而言，编译器认为这是一个错误。而对于声明了 mutable属性的函数<code>mutable_val_lambda</code>，以及通过引用传递变量<code>val</code>的<code>const_ref_lambda</code>函数，甚至是通过参数来传递变量<code>val</code>的<code>const_param_lambda</code>，编译器均不会报错。如我们之前的定义中提到一样，C++11中，默认情况下 lambda函数是一个 const函数。按照规则，一个 const的成员函数是不能在函数体中改变非静态成员变量的值的。但这里明显编译器对不同传参或捕捉列表的 lambda函数执行了不同的规则有着不同的见解。</p>
<p>这跟 lambda函数的特别的常量性相关。lambda函数的函数体部分被转化为仿函数之后会成为一个 class 的常量成员函数。整个<code>const_val_lambda</code>看起来会是代码清单所示的样子。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">const_val_lambda</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    const_val_lambda(<span class="keyword">int</span> v): val(v)&#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; val = <span class="number">3</span>; &#125; <span class="comment">/*注意：常量成员函数*/</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>对于常量成员函数，其常量的规则跟普通的常量函数是不同的。具体而言，对于常量成员函数，不能在函数体内改变 class 中任何成员变量。</p>
<p>lambda的捕捉列表中的变量都会成为等价仿函数的成员变量，而常量成员函数(如<code>operator()</code>)中改变其值是不允许的，因而按值捕捉的变量在没有声明为 mutable的 lambda函数中，其值一旦被修改就会导致编译器报错。</p>
<p>而使用引用的方式传递的变量在常量成员函数中值被更改则不会导致错误。简单地说，由于函数<code>const_ref_lambda</code>不会变引用本身，而只会改变引用的值，因此编译器将编译通过。至于按传参数的<code>const_param_lambd</code>就更加不会引起编译器的“抱怨”了。准确地讲，现有C+11标准中的 lambda等价的是有常量<code>operator()</code>的仿函数。因此在使用捕捉列表的时候必须注意，按值传递方式捕捉的变量是 lambda函数中不可更改的常量。</p>
<p>此外， lambda函数的<code>mutable</code>修饰符可以消除其常量性，不过这实际上只是提供了一种语法上的可能性。大多数时侯，我们使用默认版本的(非<code>mutable</code>)的lambda函数也就足够了。</p>
<h3 id="lambda与STL"><a href="#lambda与STL" class="headerlink" title="lambda与STL"></a>lambda与STL</h3><p>首先我们来看一个最为常见的STL算法<code>for_each</code>。简单地说，<code>for_each</code>算法的原型如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">UnaryProc <span class="title">for_each</span><span class="params">(InputIterator beg, InputIterator end, UnaryProc op)</span></span></span><br></pre></td></tr></table></figure></p>
<p><code>for_each</code>算法需要一个标记开始的<code>Iterator</code>，一个标记结束的<code>Iterator</code>，以及一个接受单个参数的“函数”(即一个函数指针、仿函数或者lambda函数)。<code>for_each</code>的一个示意实现如下<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for_each(Iterator begin, Iterator end, Function fn) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Iterator i = begin; i ! end; ++i)</span><br><span class="line">        fn(*i);</span><br></pre></td></tr></table></figure></p>
<p>通过<code>for_each</code>，我们可以完成各种循环操作。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; largenums;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ubound = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Largenumsfunc</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; ubound)</span><br><span class="line">        largenums.push_back (i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Above</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//传统的for循环</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> itr = nums.begin(); itr != nums.end(): ++itr)</span><br><span class="line">        <span class="keyword">if</span> (*itr &gt;= ubound)</span><br><span class="line">            largenums.push_back(*itr);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使用函数指针</span></span><br><span class="line">    for_each (nums.begin(), nums.end(), Largenumsfunc);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使用lambda函数和算法for_each</span></span><br><span class="line">    for_each(nums.begin(), nums.end(), [-](<span class="keyword">int</span> i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; ubound)</span><br><span class="line">            largenums.push_back(i);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们分别用了3种方式来遍历一个<code>vector nums</code>，找出其中大于<code>ubound</code>的值，并将其写入另外一个<code>vector largenums</code>中。第一种是传统的for循环；第二种，则更泛型地使用了<code>for_each</code>算法以及函数指针；第三种同样使用了<code>for_each</code>，但是第三个参数传入的是 lambda函数。首先必须指出的是使用<code>for_each</code>的好处，使用<code>for_each</code>算法不用关心<code>Iterator</code>，或者说循环的细节，只需要设定边界，作用于每个元素的操作，就可以在近似“一条语句”内完成循环，正如函数指针版本和 lambda版本完成的那样。</p>
<p>函数指针的方式看似简洁，不过却有很大的缺陷。第一点是函数定义在别的地方，比如很多行以前(后)或者别的文件中这样的代码阅读起来并不方便。第二点则是出于效率考虑，使用函数指针很可能导致编译器不对其进行 inline优化，在循环次数较多的时候，内联的 lambda和没有能够内联的函数指针可能存在着巨大的性能差别。因此，相比于函数指针，lambda拥有无可替代的优势。</p>
<h1 id="融入实际应用"><a href="#融入实际应用" class="headerlink" title="融入实际应用"></a>融入实际应用</h1><h2 id="对齐支持"><a href="#对齐支持" class="headerlink" title="对齐支持"></a>对齐支持</h2><h3 id="数据对齐"><a href="#数据对齐" class="headerlink" title="数据对齐"></a>数据对齐</h3><p>在了解为什么数据需要对齐之前，我们可以回顾一下打印结构体的大小<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HowManyBytes</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span>     a;</span><br><span class="line">    <span class="keyword">int</span>      b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"sizeof(char): "</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">char</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"sizeof(int): "</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">int</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"sizeof(HowManyBytes): "</span> &lt;&lt; <span class="keyword">sizeof</span>(HowManyBytes) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"offset of char a: "</span> &lt;&lt; offsetof(HowManyBytes, a) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"offset of int b: "</span> &lt;&lt; offsetof(HowManyBytes, b) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>结构体<code>HowManyBytes</code>由一个char类型成员<code>a</code>及一个int类型成员<code>b</code>组成。编译运行得到如下结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sizeof(char): 1</span><br><span class="line">sizeof (int): 4</span><br><span class="line">sizeof (Howmanybytes): 8</span><br><span class="line"></span><br><span class="line">offset of char a: 0</span><br><span class="line">offset of int b:  4</span><br></pre></td></tr></table></figure></p>
<p>这个现象主要是由于数据对齐要求导致的。通常情况下，C/C++结构体中的数据会有一定的对齐要求。在这个例子中，可以通过<code>offsetof</code>查看成员的偏移的方式来检验数据的对齐方式。这里<code>b</code>并非紧邻着<code>a</code>排列。C/C++的int类型数据要求对齐到4字节，即要求int类型数据必须放在一个能够整除4的地址上；而char要求对齐到1字节。这就造成了成员a之后的3字节空间被空出，通常我们也称因为对齐而造成的内存留空为填充数据( padding data)。</p>
<p>对齐方式通常是一个整数，它表示的是一个类型的对象存放的内存地址应满足的条件。对齐的数据在读写上会有性能上的优势。比如频繁使用的数据如果与处理器的高速缓存器大小对齐，有可能提高缓存性能。而数据不对齐可能造成一些不良的后果，比较严重的当属导致应用程序退出。典型的，如在有的平台上，硬件将无法读取不按字对齐的某些类型数据，这个时候硬件会抛出异常来终止程序。而更为普遍的，在一些平台上，不按照字对齐的数据会造成数据读取效率低下</p>
<p>我们利用C++11新提供的修饰符<code>alignas</code>来重新设定<code>Colorvector</code>的对齐方式。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct <span class="title">alignas</span><span class="params">(<span class="number">32</span>)</span> Colorvector </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> r;</span><br><span class="line">    <span class="keyword">double</span> g;</span><br><span class="line">    <span class="keyword">double</span> b;</span><br><span class="line">    <span class="keyword">double</span> a;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="C-11的alignof和alignas"><a href="#C-11的alignof和alignas" class="headerlink" title="C++11的alignof和alignas"></a>C++11的alignof和alignas</h3><p><code>alignof</code>的操作数表示一个定义完整的自定义类型或者内置类型或者变量，返回的值是一个<code>std::size_t</code>类型的整型常量。如同<code>sizeof</code>操作符一样，<code>alignof</code>获得的也是一个与平台相关的值。</p>
<p><code>alignas</code>既可以接受常量表达式，也可以接受类型作为参数，比如<code>aligns(double) char c</code>也是合法的描述符。其使用效果跟<code>alignas(alignof(double)) char c</code>是一样的。</p>
<blockquote>
<p>在C++11标准之前，我们也可以使用一些编译器的扩展来描述对齐方式，比如GNU格式的<code>__attribute__((__aligned__(8))</code>就是一个广泛被接受的版本。</p>
</blockquote>
<p>我们在使用常量表达式作为<code>alignas</code>的操作符的时候，其结果必须是以2的自然数幂次作为对齐值。对齐值越大，我们称其对齐要求越高；而对齐值越小，其对齐要求也越低。</p>
<p>在C++11标准中规定了一个“基本对齐值”(fundamental alignment)。一般情况下其值通常等于平台上支持的最大标量类型数据的对齐值(常常是<code>long double</code>)。我们可以通过<code>alignof(std::max_align_t)</code>来查询其值。</p>
<p>对齐描述符可以作用于各种数据。具体来说，可以修饰变量、类的数据成员等，而位域(bit field)以及用<code>register</code>声明的变量则不可以。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">alignas(<span class="keyword">double</span>) <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>; <span class="comment">//错误：alignas不能修饰函数</span></span><br><span class="line">alignas(<span class="keyword">double</span>) <span class="keyword">unsigned</span> <span class="keyword">char</span> c[<span class="keyword">sizeof</span>(<span class="keyword">double</span>)); <span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> c [<span class="keyword">sizeof</span>(<span class="keyword">double</span>)];</span><br><span class="line">alignas(<span class="keyword">float</span>)</span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> c[<span class="keyword">sizeof</span>(<span class="keyword">double</span>)); <span class="comment">// 错误：不同对齐方式的变量定义</span></span><br></pre></td></tr></table></figure>
<p>我们再来看一个例子，这个例子中我们采用了模板的方式来实现一个固定容量但是大小随着所用的数据类型变化的容器类型。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function">struct <span class="title">aligns</span><span class="params">(<span class="keyword">alignof</span>(<span class="keyword">double</span>)*<span class="number">4</span>)</span> Colorvector </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> r;</span><br><span class="line">    <span class="keyword">double</span> g;</span><br><span class="line">    <span class="keyword">double</span> b;</span><br><span class="line">    <span class="keyword">double</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//固定容量的模板数组</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fixedcapacityarray</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(T t)</span> </span>&#123;<span class="comment">/*在data中加入t变量*/</span> &#125;</span><br><span class="line">    char alignas(T) data[1024] = &#123;0&#125;;</span><br><span class="line">    <span class="comment">// int length = 1024 / sizeof(T);</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Fixedcapacityarray&lt;<span class="keyword">char</span>&gt; arrch;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"alignof(char):"</span> &lt;&lt; <span class="keyword">alignof</span>(<span class="keyword">char</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"alignof(arch. data): "</span> &lt;&lt; <span class="keyword">alignof</span>(arch.data) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    Fixedcapacityarray&lt;colorvector&gt; arrcv;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"alignof(Colorvector):"</span> &lt;&lt; <span class="keyword">alignof</span>(colorvector) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"alignof(arrcv.data):"</span> &lt;&lt; <span class="keyword">alignof</span> (arrcv.data) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在本例中，<code>Fixedcapacityarray</code>固定使用1024字节的空间，但由于模板的存在，可以实例化为各种版本。这样一来，我们可以在相同的内存使用量的前提下，做出多种类型(内置或者自定义)版本的数组。</p>
<p>如我们之前提到的一样，为了有效地访问数据，必须使得数据按照其固有特性进行对齐。对于<code>arrch</code>，由于数组中的元素都是char类型，所以对齐到1就行了，而对于我们定义的<code>arrcv</code>，必须使其符合<code>Colorvector</code>的扩展对齐，即对齐到8字节的内存边界上。在这个例子中，起到关键作用的代码是下面这一句<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char alignas(T) data[1024]=&#123;0&#125;;</span><br></pre></td></tr></table></figure></p>
<p>该句指示<code>data[1024]</code>这个char类型数组必须按照模板参数T的对齐方式进行对齐。编译运行该例子后，可以在实验机上得到如下结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alignof (char): 1</span><br><span class="line">alignof (arrch.data): 1</span><br><span class="line">alignof (Colorvector): 32</span><br><span class="line">alignof (arrcv.data): 32</span><br></pre></td></tr></table></figure></p>
<p>如果我们去掉<code>alignas(T)</code>这个修饰符，代码的运行结果会完全不同，具体如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alignof (char): 1</span><br><span class="line">alignof (arch.data): 1</span><br><span class="line">alignof (Colorvector): 32</span><br><span class="line">alignof (arrcv.data): 1</span><br></pre></td></tr></table></figure></p>
<p>可以看到，由于char数组默认对齐值为1，会导致<code>data[1024]</code>数组也对齐到1。这肯定不是程序员愿意见到的。事实上，在C++11标准引入<code>alignas</code>修饰符之前，这样的固定容量的泛型数组有时可能遇到因为对齐不佳而导致的性能损失(甚至程序错误)，这给库的编写者带来了很大的困扰。而引入<code>alignas</code>能够解决这些移植性的困难</p>
<p>在STL库中，还内建了<code>std::align</code>函数来动态地根据指定的对齐方式调整数据块的位置。该函数的原型如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">align</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> alignment, <span class="built_in">std</span>::<span class="keyword">size_t</span> size, <span class="keyword">void</span>*&amp; ptr, <span class="built_in">std</span>::<span class="keyword">size_t</span>&amp; space)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>该函数在<code>ptr</code>指向的大小为<code>space</code>的内存中进行对齐方式的调整，将<code>ptr</code>开始的<code>size</code>大小的数据调整为按<code>alignment</code>对齐。</p>
<h2 id="通用属性"><a href="#通用属性" class="headerlink" title="通用属性"></a>通用属性</h2><h3 id="语言扩展到通用属性"><a href="#语言扩展到通用属性" class="headerlink" title="语言扩展到通用属性"></a>语言扩展到通用属性</h3><p>扩展语法中比较常见的就是“属性”( attribute)。属性是对语言中的实体对象(比如函数、变量、类型等)附加一些的额外注解信息，其用来实现一些语言及非语言层面的功能，或是实现优化代码等的一种手段。不同编译器有不同的属性语法。比如对于g++，属性是通过GNU的关键字<code>__attribute__</code>来声明的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">area</span><span class="params">(<span class="keyword">int</span> n)</span> __<span class="title">attribute__</span><span class="params">((<span class="keyword">const</span>))</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> areas = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++) &#123;</span><br><span class="line">        areas += area(<span class="number">3</span>) * i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>const</code>属性告诉编译器，本函数返回值只依赖于输入，不会改变任何函数外的值，因此没有副作用，编译器可以对函数进行优化，从而大大提高了程序的执行性能。</p>
<h3 id="C-11的通用属性"><a href="#C-11的通用属性" class="headerlink" title="C++11的通用属性"></a>C++11的通用属性</h3><p>C++11语言中的通用属性使用了左右双中括号的形式<code>[[attribute-list]]</code>，这样设计的好处是：既不会消除语言添加或者重载关键字的能力，又不会占用用户而的关键字的名字空间。语法上，C+11的通用属性可以作用于类型、变量、名称、代码块等。对于作用声的通用属性，既可以写在声明的起始处，也可以写在声明的标识符之后。而对于作用于整个语句的通用属性，则应该写在语句起始处。</p>
<p>而出现在以上两种规则描述的位置之外的通用属性，作用于哪个实体跟编译器具体的实现有关。我们可以看几个例子。第一个是关于通用属性应用于函数的，具体如下<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[attr1]] <span class="keyword">void</span> func [[attr2]] ();</span><br></pre></td></tr></table></figure></p>
<p>这里，<code>[[attr1]]</code>出现在函数定义之前，而<code>[[attr2]]</code>则位于函数名称之后，根据定义，<code>[[attr1]]</code>和<code>[[attr2]]</code>均可以作用于函数<code>func</code>。</p>
<p>现有C++11标准中，只预定义了两个通用属性，分别是<code>[[noreturn]]</code>和<code>[[carries_dependency]]</code>。</p>
<h3 id="预定义的通用属性"><a href="#预定义的通用属性" class="headerlink" title="预定义的通用属性"></a>预定义的通用属性</h3><p><code>[[noreturn]]</code>是用于标识不会返回的函数的。这里必须注意，不会返回和没有返回值的(void)函数的区别。没有返回值的void函数在调用完成后，调用者会接着执行函数后的代码；而不会返回的函数在被调用完成后，后续代码不会再被执行。主要用于标识那些不会将控制流返回给原调用函数的函数，典型的例子有有终止应用程序语句的函数、有无限循环语句的函数、有异常抛出的函数等。通过这个属性，开发人员可以告知编译器某些函数不会将控制流返回给调用函数，这能帮助编译器产生更好的警告信息，同时编译器也可以做更多的诸如死代码消除、免除为函数调用者保存一些特定寄存器等代码优化工作。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dosomething1</span> <span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dosomething2</span> <span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">[[noreturn]] <span class="function"><span class="keyword">void</span> <span class="title">Throwaway</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">"expection"</span>;</span><br><span class="line">&#125; <span class="comment">//控制流跳转到异常处理</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Dosomething1();</span><br><span class="line">    Throwaway();</span><br><span class="line">    Dosomething2();<span class="comment">//该函数不可到达</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由于<code>Throwaway</code>抛出了异常，<code>Dosomething2</code>水远不会被执行，这个时候将<code>Throwaway</code>标记为<code>[[noreturn]]</code>的话，编译器会不再为<code>Throwaway</code>之后生成调用<code>Dosomething2</code>的代码。当然，编译器也可以选择为<code>func</code>函数中的<code>Dosomething2</code>做出一些警告以提示程序员这里有不可到达的代码。不返回的函数除了是有异常抛出的函数外，还有可能是有终止应用程序语句的函数，或是有无限循环语句的函数等。</p>
<p>另外一个通用属性<code>[[carries_dependency]]</code>则跟并行情况下的编译器优化有关。事实上<code>[[carries_dependency]]</code>主要是为了解决弱内存模型平台上使用<code>memory_order_consume</code>内存顺序枚举问题。</p>
<p><code>memory_order_consume</code>的主要作用是保证对当前原子类型数据的读取操作先于所有之后关于该原子变量的操作完成，但它不影响其他原子操作的顺序。要保证这样的“先于发生”的关系，编译器往往需要根据memory_model枚举值在原子操作间构建一系列的依赖关系，以减少在弱一致性模型的平台上产生内存栅栏。不过这样的关系则往往会由于函数的存在而被破坏。比如下面的代码<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">atomic&lt;<span class="keyword">int</span>*&gt; a;</span><br><span class="line"><span class="keyword">int</span>* p = (<span class="keyword">int</span>*)a.load(memory_order_consume);</span><br><span class="line">func(p);</span><br></pre></td></tr></table></figure></p>
<p>上面的代码中，编译器在编译时可能并不知道<code>func</code>函数的具体实现，因此，如果要保证<code>load</code>先于任何关于<code>a</code>(或是<code>p</code>)的操作发生，编译器往往会在<code>func</code>函数之前加入一条内存栅栏。然而，如果<code>func</code>的实现是<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func(<span class="keyword">int</span> * p) &#123;</span><br><span class="line">    <span class="comment">// 假设p2是一个 atomic&lt;int*&gt;的变量</span></span><br><span class="line">    p2.store(p, memory_order_release);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>那么对于<code>func</code>函数来说，由于<code>p2.store</code>使用了<code>memory_order_release</code>的内存顺序，因此，<code>p2.store</code>对<code>p</code>的使用会被保证在任何关于<code>p</code>的使用之后完成。这样一来，编译器在<code>func</code>函数之前加入的内存栅栏就变得毫无意义，且影响了性能。</p>
<p>而解决的方法正是使用<code>[[carries_dependency]]</code>。该通用属性既可以标识函数参数，又可以标识函数的返回值。当标识函数的参数时，它表示数据依赖随着参数传递进入函数，即不需要产生内存栅栏。而当标识函数的返回值时，它表示数据依赖随着返回值传递出函数，不需要产生内存栅栏。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/C/" rel="tag"># C++</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/08/09/深入理解cpp11 笔记2/" rel="next" title="深入理解C++11：C++11新特性解析与应用 笔记2">
                <i class="fa fa-chevron-left"></i> 深入理解C++11：C++11新特性解析与应用 笔记2
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/09/24/深入分析LINUX内核源码 笔记1/" rel="prev" title="深入分析Linux内核源码笔记1">
                深入分析Linux内核源码笔记1 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/header.jpg" alt="Hao Yu">
            
              <p class="site-author-name" itemprop="name">Hao Yu</p>
              <p class="site-description motion-element" itemprop="description">Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author</p>
          </div>
          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">323</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>
        	<audio controls="controls" loop="loop" preload="auto" src="/resource/xiaomeihao.mp3">
	        </audio>
	

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yuhao0102" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:yuh18@mails.tsinghua.edu.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#为改变思考方式而改变"><span class="nav-number">1.</span> <span class="nav-text">为改变思考方式而改变</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#指针空值nullptr"><span class="nav-number">1.1.</span> <span class="nav-text">指针空值nullptr</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#指针空值：从0到NULL，再到nullptr"><span class="nav-number">1.1.1.</span> <span class="nav-text">指针空值：从0到NULL，再到nullptr</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#nullptr和nullptr-t"><span class="nav-number">1.1.2.</span> <span class="nav-text">nullptr和nullptr_t</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#一些关于nullptr规则的讨论"><span class="nav-number">1.1.3.</span> <span class="nav-text">一些关于nullptr规则的讨论</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#默认函数的控制"><span class="nav-number">1.2.</span> <span class="nav-text">默认函数的控制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#类与默认函数"><span class="nav-number">1.2.1.</span> <span class="nav-text">类与默认函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#“-default”与”-deleted”"><span class="nav-number">1.2.2.</span> <span class="nav-text">“= default”与”= deleted”</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lambda函数"><span class="nav-number">1.3.</span> <span class="nav-text">lambda函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#C-11中的lambda函数"><span class="nav-number">1.3.1.</span> <span class="nav-text">C++11中的lambda函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lambda与仿函数"><span class="nav-number">1.3.2.</span> <span class="nav-text">lambda与仿函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lambda的基础使用"><span class="nav-number">1.3.3.</span> <span class="nav-text">lambda的基础使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关于lambda的一些问题及有趣的实验"><span class="nav-number">1.3.4.</span> <span class="nav-text">关于lambda的一些问题及有趣的实验</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lambda与STL"><span class="nav-number">1.3.5.</span> <span class="nav-text">lambda与STL</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#融入实际应用"><span class="nav-number">2.</span> <span class="nav-text">融入实际应用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#对齐支持"><span class="nav-number">2.1.</span> <span class="nav-text">对齐支持</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数据对齐"><span class="nav-number">2.1.1.</span> <span class="nav-text">数据对齐</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-11的alignof和alignas"><span class="nav-number">2.1.2.</span> <span class="nav-text">C++11的alignof和alignas</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#通用属性"><span class="nav-number">2.2.</span> <span class="nav-text">通用属性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#语言扩展到通用属性"><span class="nav-number">2.2.1.</span> <span class="nav-text">语言扩展到通用属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-11的通用属性"><span class="nav-number">2.2.2.</span> <span class="nav-text">C++11的通用属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#预定义的通用属性"><span class="nav-number">2.2.3.</span> <span class="nav-text">预定义的通用属性</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>
  <div id="DvelopmentTarget">     
  </div>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart" aria-hidden="false"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>

  
</div>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_uv"> 
  本站访客数<span id="busuanzi_value_site_uv"></span>人次
</span>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  


  <script type="text/javascript" src="/js/src/love.js"></script>

</body>
</html>
