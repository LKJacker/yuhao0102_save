<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zn-ch">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-center-simple.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="C++,">










<meta name="description" content="新手易学，老兵易用右尖括号&amp;gt;的改进在C++98中，有一条需要程序员规避的规则：如果在实例化模板的时候出现了连续的两个右尖括号&amp;gt;，那么它们之间需要一个空格来进行分隔，以避免发生编译时的错误。我们定义了两个模板类型X和Y，并且使用模板定义分别声明了以X&amp;lt;1&amp;gt;为参数的Y&amp;lt;X&amp;lt;1&amp;gt;&amp;gt;类型变量x1，以及以X&amp;lt;2&amp;gt;为参数的Y&amp;lt;X&amp;lt;2&amp;gt">
<meta name="keywords" content="C++">
<meta property="og:type" content="article">
<meta property="og:title" content="深入理解C++11：C++11新特性解析与应用 笔记2">
<meta property="og:url" content="http://yoursite.com/2021/08/09/深入理解cpp11 笔记2/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="新手易学，老兵易用右尖括号&amp;gt;的改进在C++98中，有一条需要程序员规避的规则：如果在实例化模板的时候出现了连续的两个右尖括号&amp;gt;，那么它们之间需要一个空格来进行分隔，以避免发生编译时的错误。我们定义了两个模板类型X和Y，并且使用模板定义分别声明了以X&amp;lt;1&amp;gt;为参数的Y&amp;lt;X&amp;lt;1&amp;gt;&amp;gt;类型变量x1，以及以X&amp;lt;2&amp;gt;为参数的Y&amp;lt;X&amp;lt;2&amp;gt">
<meta property="og:locale" content="zn-ch">
<meta property="og:image" content="http://yoursite.com/img/1628912842.jpg">
<meta property="og:updated_time" content="2021-08-18T07:53:25.079Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="深入理解C++11：C++11新特性解析与应用 笔记2">
<meta name="twitter:description" content="新手易学，老兵易用右尖括号&amp;gt;的改进在C++98中，有一条需要程序员规避的规则：如果在实例化模板的时候出现了连续的两个右尖括号&amp;gt;，那么它们之间需要一个空格来进行分隔，以避免发生编译时的错误。我们定义了两个模板类型X和Y，并且使用模板定义分别声明了以X&amp;lt;1&amp;gt;为参数的Y&amp;lt;X&amp;lt;1&amp;gt;&amp;gt;类型变量x1，以及以X&amp;lt;2&amp;gt;为参数的Y&amp;lt;X&amp;lt;2&amp;gt">
<meta name="twitter:image" content="http://yoursite.com/img/1628912842.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2021/08/09/深入理解cpp11 笔记2/">





  <title>深入理解C++11：C++11新特性解析与应用 笔记2 | Hao Yu's blog</title>
  








 
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zn-ch">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hao Yu's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">The program monkey was eaten by the siege lion.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/resume.pdf" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-mybetterhalf">
          <a href="/mybetterhalf/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>
            
            mybetterhalf
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/08/09/深入理解cpp11 笔记2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">深入理解C++11：C++11新特性解析与应用 笔记2</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-08-09T14:14:00+08:00">
                2021-08-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="新手易学，老兵易用"><a href="#新手易学，老兵易用" class="headerlink" title="新手易学，老兵易用"></a>新手易学，老兵易用</h1><h2 id="右尖括号-gt-的改进"><a href="#右尖括号-gt-的改进" class="headerlink" title="右尖括号&gt;的改进"></a>右尖括号&gt;的改进</h2><p>在C++98中，有一条需要程序员规避的规则：如果在实例化模板的时候出现了连续的两个右尖括号<code>&gt;</code>，那么它们之间需要一个空格来进行分隔，以避免发生编译时的错误。我们定义了两个模板类型<code>X</code>和<code>Y</code>，并且使用模板定义分别声明了以<code>X&lt;1&gt;</code>为参数的<code>Y&lt;X&lt;1&gt;&gt;</code>类型变量<code>x1</code>，以及以<code>X&lt;2&gt;</code>为参数的<code>Y&lt;X&lt;2&gt;&gt;</code>类型变量<code>x2</code>。不过<code>x2</code>的定义编译器却不能正确解析。在<code>x2</code>的定义中，编译器会把<code>&gt;</code>优先解析为右移符号。</p>
<p>除去嵌套的模板标识，在使用形如<code>static_cast</code>、<code>dynamic cast</code>、<code>reinterpret_cast</code>或者<code>const_cast</code>表达式进行转换的时候，我们也常会遇到相同的情况。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = <span class="keyword">static_cast</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(v);</span><br></pre></td></tr></table></figure></p>
<h2 id="auto类型推导"><a href="#auto类型推导" class="headerlink" title="auto类型推导"></a>auto类型推导</h2><h3 id="静态类型、动态类型与类型推导"><a href="#静态类型、动态类型与类型推导" class="headerlink" title="静态类型、动态类型与类型推导"></a>静态类型、动态类型与类型推导</h3><p>每个变量使用前必须定义被视为编程语言中的“静态类型”的体现。而变量不需要声明，“拿来就用”则被视为“动态类型”的体现。</p>
<p>不过从技术上严格地讲，静态类型和动态类型的主要区别在于对变量进行类型检査的时间点。静态类型类型检査主要发生在编译阶段；动态类型类型检查主要发生在运行阶段。变量“拿来就用”的特性归功于类型推导。</p>
<p><code>auto</code>关键字在早期的C/C++标准中有着完全不同的含义。声明时使用<code>auto</code>修饰的变量，按照早期C/C++标准的解释，是具有自动存储期的局部变量。不过现实情况是该关键字几儿乎无人使用，因为一般函数内没有声明为<code>static</code>的变量总是具有自动存储期的局部变量。因此在C++11中，标准委员会决定赋予<code>auto</code>全新的含义，即<code>auto</code>不再是一个存储类型指示符，而是作为一个新的类型指示符来指示编译器，<code>auto</code>声明变量的类型必须由编译器在编译时期推导而得。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> x = <span class="number">1</span>;      <span class="comment">// x的类型为int</span></span><br><span class="line">    <span class="keyword">auto</span> y = foo();  <span class="comment">// y的类型为double</span></span><br><span class="line">    <span class="keyword">auto</span> z;          <span class="comment">// 无法推导，无法通过编译</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>变量x被初始化为1，因为字面常量1的类型为<code>const int</code>，所以编译器推导出<code>x</code>的类型应该为int。同理在变量<code>y</code>的定义中，<code>auto</code>类型的<code>y</code>被推导为<code>double</code>类型；使用<code>auto</code>关键字来“声明”<code>z</code>，但不立即对其进行定义则会报错。<code>auto</code>声明的变量必须被初始化，以使编译器能够从其初始化表达式中推导出其类型。从这个意义上来讲，auto并非一种“类型”声明，而是一个类型声明时的“占位符”，编译器在编译时期会将auto替代为变量实际的类型。</p>
<h3 id="auto的优势"><a href="#auto的优势" class="headerlink" title="auto的优势"></a>auto的优势</h3><p>直观地，auto推导的一个最大优势就是在拥有初始化表达式的复杂类型变量声明时简化代码。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loopover</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; &amp; vs)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;::iterator i = vs.begin();<span class="comment">//想要使用iterator，往往需要大量代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当我们想定义一个迭代器<code>i</code>的时侯我们必须写出<code>std::vector&lt;std::string&gt;::iterator</code>这样长的类型声明。这么长的类型声明只需要一个<code>auto</code>即可。</p>
<p><code>auto</code>的第二个优势则在于可以免除程序员在一些类型声明时的麻烦，或者避免一些在类型声明时的错误。对于不同的平台上的代码维护，<code>auto</code>也会带来一些“泛型”的好处。这里我们以<code>strlen</code>函数为例，在32位的编译环境下，<code>strlen</code>返回的为一个4字节的整型，而在64位的编译环境下，<code>strlen</code>会返回一个8字节的整型。虽然系统库<code>&lt;cstring&gt;</code>为其提供了<code>size_t</code>类型来支持多平台间的代码共享支持，但是使用<code>auto</code>关键字我们同样可以达到代码跨平台的效果：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> var = <span class="built_in">strlen</span>(<span class="string">"hello world"</span>);</span><br></pre></td></tr></table></figure></p>
<p>由于<code>size_t</code>的适用范围往往局限于<code>&lt;cstring&gt;</code>中定义的函数，<code>auto</code>的适用范围明显更为广泛。</p>
<h3 id="auto的使用细则"><a href="#auto的使用细则" class="headerlink" title="auto的使用细则"></a>auto的使用细则</h3><p>在C++11中，auto可以与指针和引用结合起来使用，使用的效果基本上会符合C/C++程序员的想象。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x; </span><br><span class="line"><span class="keyword">int</span> * y = &amp;x; </span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">foo</span><span class="params">()</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> &amp; <span class="title">bar</span><span class="params">()</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> * a = &amp;x; <span class="comment">// int* </span></span><br><span class="line"><span class="keyword">auto</span> &amp; b = x; <span class="comment">// int&amp; </span></span><br><span class="line"><span class="keyword">auto</span> c = y; <span class="comment">// int* </span></span><br><span class="line"><span class="keyword">auto</span> * d = y; <span class="comment">// int* </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> * e = &amp;foo(); <span class="comment">// 编译失败，指针不能指向一个临时变量</span></span><br><span class="line"><span class="keyword">auto</span> &amp; f = foo(); <span class="comment">// 编译失败，nonconst的左值引用不能和一个临时变量绑定</span></span><br><span class="line"><span class="keyword">auto</span> g = bar(); <span class="comment">// int</span></span><br><span class="line"><span class="keyword">auto</span> &amp; h = bar(); <span class="comment">// int&amp;</span></span><br></pre></td></tr></table></figure></p>
<p>本例中，变量a、c、d的类型都是指针类型，且都指向变量x。实际上对于a、c、d变量而言，声明其为<code>auto*</code>或<code>auto</code>并没有区别。而如果要使得<code>auto</code>声明的变量是另一个变量的引用，则必须使用<code>auto&amp;</code>，如同本例中的变量b和h一样。</p>
<p>其次，<code>auto</code>与<code>volatile</code>和<code>const</code>之间也存在着一些相互的联系。<code>volatile</code>和<code>const</code>代表了变量的两种不同的属性：易失的和常量的。在C++标准中，它们常常被一起叫作cv限制符(cv-qualifier)。鉴于cv限制符的特殊性，C+1标准规定<code>auto</code>可以与cv限制符一起使用。不过声明为<code>auto</code>的变量并不能从其初始化表达式中“带走”cv限制符。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">foo</span><span class="params">()</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">float</span> * <span class="title">bar</span><span class="params">()</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> a = foo(); <span class="comment">// a: const double </span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> &amp; b = foo(); <span class="comment">// b: const double&amp; </span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">auto</span> * c = bar(); <span class="comment">// c: volatile float* </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> d = a; <span class="comment">// d: double </span></span><br><span class="line"><span class="keyword">auto</span> &amp; e = a; <span class="comment">// e: const double &amp; </span></span><br><span class="line"><span class="keyword">auto</span> f = c; <span class="comment">// f: float * </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">auto</span> &amp; g = c; <span class="comment">// g: volatile float * &amp;</span></span><br></pre></td></tr></table></figure></p>
<p>我们可以通过非cv限制的类型初始化一个cv限制的类型，如变量a、b、c所示。不过通过auto声明的变量d、f却无法带走a和f的常量性或者易失性。这里的例外还是引用，可以看出，声明为引用的变量e、g都保持了其引用的对象相同的属性。此外，跟其他的变量指示符一样，同一个赋值语句中，auto可以用来声明多个变量的类型，不过这些变量的类型必须相同。如果这些变量的类型不相同，编译器则会报错。事实上，用auto来声明多个变量类型时，只有第一个变量用于auto的类型推导，然后推导出来的数据类型被作用于其他的变量。所以不允许这些变量的类型不相同。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> x = <span class="number">1</span>, y = <span class="number">2</span>; <span class="comment">// x和y的类型均为int </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// m是一个指向const int类型变量的指针，n是一个int类型的变量 </span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span>* m = &amp;x, n = <span class="number">1</span>; </span><br><span class="line"><span class="keyword">auto</span> i = <span class="number">1</span>, j = <span class="number">3.</span> <span class="number">14f</span>; <span class="comment">// 编译失败</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> o = <span class="number">1</span>, &amp;p = o, *q = &amp;p; <span class="comment">// 从左向右推导</span></span><br></pre></td></tr></table></figure></p>
<p>我们使用auto声明了两个类型相同变量x和y，并用逗号进行分隔，这可以通过编译。而在声明变量i和j的时候，按照我们所说的第一变量用于推导类型的规则，那么由于x所推导出的类型是int，那么对于变量j而言，其声明就变成了<code>int j = 3.14f</code>，这无疑会导致精度的损失。而对于变量m和n，就变得非常有趣，这里似乎是auto被替换成了int，所以m是一个<code>int*</code>指针类型，而n只是一个<code>int</code>类型。同样的情况也发生在变量o、p、q上，这里o是一个类型为<code>int</code>的变量，p是o的引用，而q是p的指针。<code>auto</code>的类型推导按照从左往右，且类似于字面替换的方式进行。事实上，标准里称auto是一个将要推导出的类型的“占位符”(placeholder)。这样的规则无疑是直观而让人略感意外的。</p>
<p>受制于语法的二义性，或者是实现的困难性，auo往往也会有使用上的限制。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt; vector&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">( <span class="keyword">auto</span> x = <span class="number">1</span>)</span></span>&#123;&#125; <span class="comment">// 1: auto函数参数，无法通过编译 </span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">str</span>&#123;</span> </span><br><span class="line">    <span class="keyword">auto</span> var = <span class="number">10</span>; <span class="comment">// 2: auto非静态成员变量，无法通过编译</span></span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">char</span> x[ <span class="number">3</span>]; </span><br><span class="line">    <span class="keyword">auto</span> y = x; </span><br><span class="line">    <span class="keyword">auto</span> z[ <span class="number">3</span>] = x; <span class="comment">// 3: auto数组，无法通过编译</span></span><br><span class="line">    <span class="comment">// 4: auto模板参数（实例化时），无法通过编译</span></span><br><span class="line">    <span class="built_in">vector</span>&lt; <span class="keyword">auto</span>&gt; v = &#123;<span class="number">1</span>&#125;; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>对于函数<code>fun</code>来说，auto不能是其形参类型。<code>auto</code>是不能做形参的类型的。如果程序员需要泛型的参数，还是需要求助于模板。</li>
<li>对于结构体来说，非静态成员变量的类型不能是<code>auto</code>的。同样的，由于<code>var</code>定义了初始值，读者可能认为<code>auto</code>可以推导<code>str</code>成员<code>var</code>的类型为<code>int</code>的。但编译器阻止<code>auto</code>对结构体中的非静态成员进行推导，即使成员拥有初始值。</li>
<li>声明<code>auto</code>数组。我们可以看到，<code>main</code>中的<code>x</code>是一个数组，<code>y</code>的类型是可以推导的。而声明<code>auto z[3]</code>这样的数组同样会被编译器禁止</li>
<li>在实例化模板的时候使用<code>auto</code>作为模板参数，如<code>main</code>中我们声明的<code>vector&lt;auto&gt;</code>虽然读者可能认为这里一眼而知是int类型，但编译器却阻止了编译。</li>
</ol>
<h2 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h2><h3 id="typeid与decltype"><a href="#typeid与decltype" class="headerlink" title="typeid与decltype"></a>typeid与decltype</h3><p>C++98对动态类型支持就是C++中的运行时类型识别(RTTI)。RTTI的机制是为每个类型产生一个type info类型的数据，程序员可以在程序中使用<code>typeid</code>随时查询一个变量的类型，<code>typeid</code>就会返回变量相应的<code>type_info</code>数据。而<code>type_info</code>的<code>name</code>成员函数可以返回类型的名字。而在C++11中，又增加了<code>hash_code</code>，这个成员函数返回该类型唯一的哈希值，以供程序员对变量的类型随时进行比较。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">White</span>&#123;</span>&#125;; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Black</span>&#123;</span>&#125;; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    White a; </span><br><span class="line">    Black b; </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">typeid</span>(a).name() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 5White </span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">typeid</span>(b).name() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 5Black </span></span><br><span class="line">    White c; </span><br><span class="line">    <span class="keyword">bool</span> a_b_sametype = (<span class="keyword">typeid</span>(a).hash_code() == <span class="keyword">typeid</span>(b).hash_code()); </span><br><span class="line">    <span class="keyword">bool</span> a_c_sametype = (<span class="keyword">typeid</span>(a).hash_code() == <span class="keyword">typeid</span>(c).hash_code()); </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Same type? "</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"A and B? "</span> &lt;&lt; (<span class="keyword">int</span>) a_b_sametype &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 0 </span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"A and C? "</span> &lt;&lt; (<span class="keyword">int</span>) a_c_sametype &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 1 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在RTTI的支持下，程序员可以在一定程度上了解程序中类型的信息。除了<code>typeid</code>外，RTTI还包括了C++中的<code>dynamic_cast</code>等特性。不过不得不提的是，由于RTTI会带来一些运行时的开销，所以一些编译器会让用户选择性地关闭该特性(比如XLCC++编译器的- qnortti，GCC的选项-fno-rttion，或者微软编译器选项/GR-)。</p>
<p>在decltype产生之前，很多编译器的厂商都开发了自己的C++语言扩展用于类型推导。比如GCC的<code>typeof</code>操作符就是其中的一种。C++11则将这些类型推导手段标准化为<code>auto</code>以及<code>decltype</code>。与<code>auto</code>类似地，<code>decltype</code>也能进行类型推导，不过两者的使用方式却有一定的区别。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> i; </span><br><span class="line">    <span class="keyword">decltype</span>(i) j = <span class="number">0</span>; </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">typeid</span>(j).name() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 打印出" i", g++ 表示 int </span></span><br><span class="line">    <span class="keyword">float</span> a; </span><br><span class="line">    <span class="keyword">double</span> b; </span><br><span class="line">    <span class="keyword">decltype</span>(a + b) c; </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">typeid</span>(c).name() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 打印出" d", g++ 表示 double </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们看到变量j的类型由<code>decltype(i)</code>进行声明，表示j的类型跟i相同。而c的类型则跟<code>(a+b)</code>这个表达式返回的类型相同。而由于<code>a+b</code>加法表达式返回的类型为double，所以<code>c</code>的类型被 <code>decltype</code>推导为double。</p>
<p>从这个例子中可以看到，<code>decltype</code>的类型推导并不是像<code>auto</code>一样是从变量声明的初始化表达式获得变量的类型，<code>decltype</code>总是以一个普通的表达式为参数，返回该表达式的类型。而与<code>auto</code>相同的是，作为一个类型指示符，<code>decltype</code>可以将获得的类型来定义另外一个变量。与<code>auto</code>相同，<code>decltype</code>类型推导也是在编译时进行的。</p>
<h3 id="decltype的应用"><a href="#decltype的应用" class="headerlink" title="decltype的应用"></a>decltype的应用</h3><p>在C+11中，使用<code>decltype</code>推导类型是非常常见的事情。比较典型的就是<code>decltype</code>与<code>typedef/using</code>的合用。在C++11的头文件中，我们常能看以下这样的代码<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> size_ t = <span class="keyword">decltype</span>(<span class="keyword">sizeof</span>(<span class="number">0</span>)); </span><br><span class="line"><span class="keyword">using</span> ptrdiff_ t = <span class="keyword">decltype</span>((<span class="keyword">int</span>*) <span class="number">0</span> - (<span class="keyword">int</span>*) <span class="number">0</span>); </span><br><span class="line"><span class="keyword">using</span> nullptr_ t = <span class="keyword">decltype</span>(<span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure></p>
<p>这里<code>size_t</code>以及<code>ptrdiff_t</code>还有<code>nullptr_t</code>都是由<code>decltype</code>推导出的类型。这种定义方式非常有意思。在一些常量、基本类型、运算符、操作符等都已经被定义好的情况下，类型可以按照规则被推导出。而使用<code>using</code>，就可以为这些类型取名。这就颠覆了之前类型拓展需要将扩展类型“映射”到基本类型的常规做法。</p>
<p>除此之外，<code>decltype</code>在某些场景下，可以极大地增加代码的可读性。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(vec.begin())</span> vectype</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (vectype i = vec.begin(); i &lt; vec.end(); i ++) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">decltype</span>(vec)::iterator i = vec.begin(); i &lt; vec.end(); i ++) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们定义了vector的iterator的类型。这个类型还可以在<code>main</code>函数中重用。当我们遇到一些具有复杂类型的变量或表达式时，就可以利用<code>decltype</code>和<code>typedef using</code>的组合来将其转化为一个简单的表达式，这样在以后的代码写作中可以提高可读性和可维护性。此外我们可以看到<code>decltype(vec)::iterator</code>这样的灵活用法，这看起来跟<code>auto</code>非常类似，也类似于是一种“占位符”式的替代。</p>
<p>拥有了<code>decltype</code>这个利器之后，重用匿名类型也并非难事。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> &#123;</span>K1, K2, K3&#125; anon_e; <span class="comment">//匿名的强类型枚举</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> &#123;</span><br><span class="line">    <span class="keyword">decltype</span> (anon_e) key;</span><br><span class="line">    <span class="keyword">char</span>* name;</span><br><span class="line">&#125; anon_u;<span class="comment">//匿名的 union联合体</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> d;</span><br><span class="line">    <span class="keyword">decltype</span>(anon_u) id; </span><br><span class="line">&#125; anon_s[<span class="number">100</span>]; <span class="comment">// 匿名的struct数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">decltype</span>&lt;anon_s) as;</span><br><span class="line">    as[<span class="number">0</span>].id.key = <span class="keyword">decltype</span>(anon_e)::K1; <span class="comment">//引用匿名强类型枚举中的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们使用了3种不同的匿名类型：匿名的强类型枚举<code>anon_e</code>、匿名的联合体<code>anon_u</code>，以及匿名的结构体数组<code>anon_s</code>。可以看到，只要通过匿名类型的变量名<code>anon_e</code>、<code>anon_u</code>，以及<code>anon_s</code>,<code>decltype</code>可以推导其类型并且进行重用。</p>
<p>有了<code>decltype</code>，我们可以适当扩大模板泛型的能力。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Sum</span><span class="params">(T1 &amp; t1, T2 &amp; t2, <span class="keyword">decltype</span>(t1+t2) &amp; s)</span> </span>&#123;</span><br><span class="line">    s = t1 + t2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样一来，<code>Sum</code>的适用范围增加，因为其返回的类型不再是单一的类型，而是根据<code>t1+2</code>推导而来的类型。不过这里还是有一定的限制，我们可以看到返回值的类型必须一开始就被指定，程序员必须清楚<code>Sum</code>运算的结果使用什么样的类型来存储是合适的，这在一些泛型编程中依然不能满足要求。解决的方法是结合<code>decltype</code>与<code>auto</code>关键字，使用追踪返回类型的函数定义来使得编译器对函数返回值进行推导。</p>
<p>我们在实例化一些模板的时候，<code>decltype</code>也可以起到一些作用。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">char</span>*)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">char</span>*, <span class="keyword">decltype</span>(hash)&gt; dict_key; <span class="comment">// 无法通过编译</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">char</span>*, <span class="keyword">decltype</span>(hash(<span class="literal">nullptr</span>))&gt; dict_key1;</span><br></pre></td></tr></table></figure></p>
<p>我们实例化了标准库中的<code>map</code>模板。因为该<code>map</code>是为了存储字符串以及与其对应哈希值的，因此我们可以通过<code>decltype(hash(nullptr)</code>来确定哈希值的类型。这样的定义非常直观，但是程序员必须要注意的是，<code>decltype</code>只能接受表达式做参数，像函数名做参数的表达式<code>decltype(hash)</code>是无法通过编译的。</p>
<p>一些标准库的实现也会依赖于类型推导。一个典型的例子是基于<code>decltype</code>的模板类<code>result_of</code>，其作用是推导函数的返回类型。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">double</span> <span class="params">(*func)</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    result_of&lt;func()&gt;::type f;</span><br><span class="line">    <span class="comment">//由func()推导其结果类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里f的类型最终被推导为double，而<code>result_of</code>并没有真正调用<code>func()</code>这个函数，这切都是因为底层的实现使用了<code>decltype</code>。<code>result_of</code>的一个可能的实现方式如下<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">result_of</span>;</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">F</span>, <span class="title">class</span>.. <span class="title">ArgTypes</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">result_of</span>&lt;F(ArgTypes.. )&gt; &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="built_in">std</span>::declval&lt;F&gt;()(<span class="built_in">std</span>::declval&lt;ArgTypes&gt;()...)</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span> type</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里标准库将<code>decltype</code>作用于函数调用上，并将函数调用表达式返回的类型<code>typedef</code>为一个名为<code>type</code>的类型。这样一来，<code>result_of&lt;func()&gt;::type</code>就会被<code>decltype</code>推导为<code>double</code>。</p>
<h3 id="decltype推导四规则"><a href="#decltype推导四规则" class="headerlink" title="decltype推导四规则"></a>decltype推导四规则</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">decltype</span>(i) a;</span><br><span class="line"><span class="keyword">decltype</span>((i)) b;  <span class="comment">// b int&amp;: 必须初始化引用</span></span><br></pre></td></tr></table></figure>
<p><code>decltype((i))b</code>这样的语句编译不过。编译器会提示<code>b</code>是一个引用，但没有被赋初值。而<code>decltypet(i) a</code>这一句却能通过编译，因为其类型被如预期地推导为<code>int</code>。这种问题显得非常诡异，单单多了一对圆括号，<code>decltype</code>所推导出的类型居然发生了变化。事实上，C++11中<code>decltype</code>推导返回类型的规则比我们想象的复杂。具体地，当程序员用<code>decltype(e)</code>来获取类型时，编译器将依序判断以下四规则：</p>
<ol>
<li>如果<code>e</code>是一个没有带括号的标记符表达式或者类成员访问表达式，那么<code>decltype(e)</code>就是<code>e</code>所命名的实体的类型。此外，如果<code>e</code>是一个被重载的函数，则会导致编译时错误。</li>
<li>否则，假设<code>e</code>的类型是<code>T</code>，如果<code>e</code>是一个将亡值，那么<code>decltype(e)</code>为<code>T&amp;&amp;</code>。</li>
<li>否则，假设<code>e</code>的类型是<code>T</code>，如果<code>e</code>是一个左值，则<code>decltype(e)</code>为<code>T&amp;</code>。</li>
<li>否则，假设<code>e</code>的类型是<code>T</code>，则<code>decltype(e)</code>为<code>T</code>。</li>
</ol>
<p>基本上，所有除去关键字、字面量等编译器需要使用的标记之外的程序员自定义的标记都可以是标记符。而单个标记符对应的表达式就是标记符表达式。比如程序员定义了<code>int arr[4]</code>，那么<code>arr</code>是一个标记符表达式，而<code>arr[3]+0</code>，<code>arr[3]</code>等，则都不是标记符表达式。</p>
<p><code>decltype(i) a</code>使用了推导规则1，因为<code>i</code>是一个标记符表达式，所以类型被推导为<code>int</code>；而<code>decltype((i))b</code>中，由于<code>(i)</code>不是一个标记符表达式，但却是一个左值表达式(可以有具名的地址)，因此，按照 <code>decltype</code>推导规则3，其类型应该是一个int的引用。上面的规则看起来非常复杂，但事实上，在实际应用中，<code>decltype</code>类型推导规则中最容易引起迷惑的只有规则1和规则3。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *ptr = arr;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span> <span class="keyword">double</span> d; &#125; s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Overloaded</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Overloaded</span><span class="params">(<span class="keyword">char</span>)</span></span>; <span class="comment">//重载的函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> &amp;&amp; <span class="title">RvalRef</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">bool</span> <span class="title">Func</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 规则1:单个标记符表达式以及访问类成员，推导为本类型</span></span><br><span class="line"><span class="keyword">decltype</span>(arr) var1;        <span class="comment">// int[5]，标记符表达式</span></span><br><span class="line"><span class="keyword">decltype</span>(ptr) var2;        <span class="comment">// int*，标记符表达式</span></span><br><span class="line"><span class="keyword">decltype</span>(s.d) var4;        <span class="comment">// doub1e，成员访问表达式</span></span><br><span class="line"><span class="keyword">decltype</span>(Overloaded) var5; <span class="comment">// 无法通过编译，是个重载的函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//规则2:将亡值，推导为类型的右值引用</span></span><br><span class="line"><span class="keyword">decltype</span>(RvalRef()) var6 = <span class="number">1</span>; <span class="comment">//int&amp;&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 规则3:左值，推导为类型的引用</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="literal">true</span> ? i : i) var7 = i;       <span class="comment">// int&amp;，三元运算符，这里返回一个i的左值</span></span><br><span class="line"><span class="keyword">decltype</span>((i)) var8 = i;                <span class="comment">// int&amp;，带圆括号的左值</span></span><br><span class="line"><span class="keyword">decltype</span>(++i) var9 = i;                <span class="comment">// int&amp;，++i返回i的左值</span></span><br><span class="line"><span class="keyword">decltype</span>(arr[<span class="number">3</span>]) var10 = i             <span class="comment">// int[]操作返回左值</span></span><br><span class="line"><span class="keyword">decltype</span>(*ptr) var11 = i;              <span class="comment">// int&amp; *操作返回左值</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="string">"lval"</span>) var12 = <span class="string">"lval"</span>;       <span class="comment">// const char(&amp;)[9]，字符串字面常量为左值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//规则4:以上都不是，推导为本类型</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="number">1</span>) var13;                     <span class="comment">// int，除字符串外字面常量为右值</span></span><br><span class="line"><span class="keyword">decltype</span>(i++)var14;                    <span class="comment">// int，i++返回右值</span></span><br><span class="line"><span class="keyword">decltype</span>((Func(<span class="number">1</span>))) var15;             <span class="comment">// const bool，圆括号可以忽略</span></span><br></pre></td></tr></table></figure></p>
<p>另外一些时候，C++11标准库中添加的模板类<code>is_lvalue_reference</code>，可以帮助程序员进行一些推导结果的识别。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::is_lvalue_reference&lt;<span class="keyword">decltype</span>(++i)&gt;::value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p>
<p>结果1表示为左值，结果为0为非右值。同样的，也有<code>is_rvalue_reference</code>这样的模板类来判断decltype推断结果是否为右值。</p>
<h3 id="cv限制符的继承与冗余的符号"><a href="#cv限制符的继承与冗余的符号" class="headerlink" title="cv限制符的继承与冗余的符号"></a>cv限制符的继承与冗余的符号</h3><p>与auto类型推导时不能“带走”cv限制符不同， decltype是能够“带走”表达式的cv限制符的。不过，如果对象的定义中有 const 或 volatile 限制符，使用 decltype进行推导时其成员不会继承 const或 volatile限制符。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> ic = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> iv;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">S</span>&#123;</span> <span class="keyword">int</span> i; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> S a = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">volatile</span> S b;</span><br><span class="line">    <span class="keyword">volatile</span> S*p = &amp;b;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::is_const&lt;<span class="keyword">decltype</span>(ic)&gt;::value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;       <span class="comment">//1 推导类型为:const int</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::is_volatile&lt;<span class="keyword">decltype</span>(iv)&gt;::value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;    <span class="comment">//1 推导类型为:volatile int</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::is_const&lt;<span class="keyword">decltype</span>(a)&gt;::value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;        <span class="comment">//1 推导类型为:const S</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::is_volatile&lt;<span class="keyword">decltype</span>(b)&gt;::value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;     <span class="comment">//1 推导类型为:volatile S</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::is_const&lt;<span class="keyword">decltype</span>(a.i)&gt;::value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;      <span class="comment">//0 推导类型a为const,但是成员不继承const类型</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::is_volatile&lt;<span class="keyword">decltype</span>(p-&gt;i)&gt;::value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  <span class="comment">//0 推导类型p为volatile,但是成员不继承volatile类型</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，结构体变量a、b和结构体指针p的cv限制符并没有出现在其成员的 decltype类型推导结果中。而与auto相同的， decltype从表达式推导出类型后，进行类型定义时，也会允许一些冗余的符号。比如cv限制符以及引用符号<code>&amp;</code>，通常情况下，如果推导出的类型已经有了这些属性，冗余的符号则会被忽略。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span>&amp; j = i;</span><br><span class="line">    <span class="keyword">int</span> *p = &amp;i;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">decltype</span>(i)&amp; var1 = i;</span><br><span class="line">    <span class="keyword">decltype</span>(j)&amp; var2 = i;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::is_lvalue_reference&lt;<span class="keyword">decltype</span>(var1)&gt;::value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;    <span class="comment">//1,是左值引用</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::is_rvalue_reference&lt;<span class="keyword">decltype</span>(var2)&gt;::value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;    <span class="comment">//0,不是右值引用</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::is_lvalue_reference&lt;<span class="keyword">decltype</span>(var2)&gt;::value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;    <span class="comment">//1，是左值引用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//decltype(p)* var3 = &amp;i;   //编译错误</span></span><br><span class="line">    <span class="keyword">decltype</span>(p)* var4 = &amp;p;     <span class="comment">//var4的类型为int **</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span>* v3 = p;               <span class="comment">//v3的类型为int *</span></span><br><span class="line">    v3 = &amp; i;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="title">decltype</span><span class="params">(k)</span> var5 </span>= <span class="number">1</span>; <span class="comment">//冗余的const,被忽略</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们定义了类型为<code>decltype(i)&amp;</code>的变量<code>var1</code>，以及类型为<code>decltype(j)&amp;</code>的变量<code>var2</code>。由于<code>i</code>的类型为int，所以这里的引用符号保证<code>var1</code>成为一个<code>int&amp;</code>引用类型。而由于<code>j</code>本来就是一个<code>int&amp;</code>的引用类型，所以<code>decltype</code>之后的<code>&amp;</code>成为了冗余符号，会被编译器忽略，因此<code>j</code>的类型依然是<code>int&amp;</code>。这里特别要注意的是<code>decltype(p)*</code>的情况。可以看到，在定义<code>var3</code>变量的时候，由于<code>p</code>的类型是<code>int*</code>，因此<code>var3</code>被定义为了<code>int**</code>类型。这跟<code>auto</code>声明中，<code>*</code>也可以是冗余的不同。在<code>decltype</code>后的<code>*</code>号，并不会被编译器忽略。</p>
<p>此外我们也可以看到，<code>var4</code>中const可以被冗余的声明，但会被编译器忽略，同样的情况也会发生在<code>volatile</code>限制符上。总的说来，<code>decltype</code>算得上是C++11中类型推导使用方式上最灵活的一种。虽然看起来它的推导规则比较复杂，有的时候跟auto推导结果还略有不同，但大多数时候，我们发现使用<code>decltype</code>还是自然而亲切的。</p>
<h2 id="追踪返回类型"><a href="#追踪返回类型" class="headerlink" title="追踪返回类型"></a>追踪返回类型</h2><h3 id="追踪返回类型的引入"><a href="#追踪返回类型的引入" class="headerlink" title="追踪返回类型的引入"></a>追踪返回类型的引入</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="keyword">decltype</span>(t1+t2) Sum(T1&amp; t1, T2&amp; t2) &#123;</span><br><span class="line">    <span class="keyword">return</span> t1 + t2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译器在推导<code>decltype(t1+t2)</code>时，表达式中的<code>t1</code>和<code>t2</code>都未声明，为了解决这个问题C++11引入新语法——追踪返回类型，来声明和定义这样的函数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line">auto Sum(T1 &amp;t1, T2 &amp;t2) -&gt; decltype(t1 + t2) &#123;</span><br><span class="line">    <span class="keyword">return</span> t1 + t2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们把函数的返回值移至参数声明之后，复合符号<code>decltype(t1 + t2)</code>被称为追踪返回类型。而原本函数返回值的位置由<code>auto</code>关键字占据。这样，我们就可以让编译器来推导<code>Sum</code>函数模板的返回类型了。而<code>auto</code>占位符和<code>-&gt; ereturn type</code>也就是构成追踪返回类型函数的两个基本元素</p>
<h3 id="使用追踪返回类型的函数"><a href="#使用追踪返回类型的函数" class="headerlink" title="使用追踪返回类型的函数"></a>使用追踪返回类型的函数</h3><p>追踪返回类型的函数和普通函数的声明最大的区别在于返回类型的后置。在一般情况下，普通函数的声明方式会明显简单于最终返回类型。比如<code>int func (char a, int b)</code>这样的书写会比下面<code>auto func(char*a, int b)-&gt; int</code>少上不少。</p>
<p>如我们刚才提到的，返回类型后置，使模板中的一些类型推导就成为了可能。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line">auto Sum(const T1 &amp; t1, const T2 &amp; t2) -&gt; decltype(t1 + t2) &#123;</span><br><span class="line">    <span class="keyword">return</span> t1 + t2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line">auto Mul(const T1 &amp; t1, const T2 &amp; t2) -&gt; decltype(t1 * t2) &#123;</span><br><span class="line">    <span class="keyword">return</span> t1 * t2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> a = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">auto</span> b = <span class="number">4L</span>;</span><br><span class="line">    <span class="keyword">auto</span> pi = <span class="number">3.14</span>;</span><br><span class="line">    <span class="keyword">auto</span> c = Mul(Sum(a, b), pi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们定义了两个模板函数<code>Sum</code>和<code>Mul</code>，它们的参数的类型和返回值都在实例化时决定。而由于<code>main</code>函数中还使用了auto，整个例子中没有看到一个具体的类型声明。</p>
<p>追踪返回类型的另一个优势是简化函数的定义，提高代码的可读性。这种情况常见于函数指针中。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> (*(*pf())())() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// auto (*)() -&gt; int(*)() 一个返回函数指针的函数(假设为a函数)</span></span><br><span class="line"><span class="comment">// auto pf1() -&gt; auto (*)() -&gt; int(*)() 一个返回a函数的指针的函数</span></span><br><span class="line">auto pf1() -&gt; auto(*)()-&gt; int (*)() &#123;</span><br><span class="line">    eturn <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; is_same&lt;<span class="keyword">decltype</span>(pf), <span class="keyword">decltype</span>(pf1)&gt;::value &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p>
<p>定义了两个类型完全一样的函数<code>pf</code>和<code>pf1</code>其返回的都是一个函数指针。而该函数指针又指向一个返回函数指针的函数。这一点通过<code>is_same</code>的成员value已经能够确定了。而仔细看一看函数类型的声明，可以发现老式的声明法可读性非常差。而追踪返回类型只需要依照从右向左的方式，就可以将嵌套的声明解析出来。这大大提高了嵌套函数这类代码的可读性。</p>
<p>除此之外，追踪返回类型也被广泛地应用在转发函数中<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">double</span>)a + <span class="number">0.1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">double</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">auto</span> <span class="title">Forward</span>(<span class="title">T</span> <span class="title">t</span>) -&gt; <span class="title">decltype</span>(<span class="title">foo</span>(<span class="title">t</span>)) &#123;</span></span><br><span class="line">    <span class="keyword">return</span> foo(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; Forward(<span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; Forward(<span class="number">0.5</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p>
<p>由于使用了追踪返回类型，可以实现参数和返回类型不同时的转发。</p>
<p>追踪返回类型还可以用在函数指针中，其声明方式与追踪返回类型的函数比起来，并没有太大的区别。比如<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span>(*fp)() -&gt; <span class="keyword">int</span></span><br></pre></td></tr></table></figure></p>
<p>和<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> (*fp) ();</span><br></pre></td></tr></table></figure></p>
<p>的函数指针声明是等价的。同样的情况也适用于函数引用，比如：<code>auto (&amp;fr)() -&gt; int</code>和<code>int (&amp;fr)();</code>的声明也是等价的。</p>
<p>P 168</p>
<h2 id="基于范围的for循环"><a href="#基于范围的for循环" class="headerlink" title="基于范围的for循环"></a>基于范围的for循环</h2><p>C++的标准模板库中，我们可以找到形如<code>for_each</code>的模板函数。如果我们使用<code>for_each</code>，代码看起来会是<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">action1</span><span class="params">(<span class="keyword">int</span> &amp;e)</span> </span>&#123; e *= <span class="number">2</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">action2</span><span class="params">(<span class="keyword">int</span> &amp;e)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; e &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    for_each(arr, arr+<span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(arr[<span class="number">0</span>]), action1);</span><br><span class="line">    for_each(arr, arr+<span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(arr[<span class="number">0</span>]), action2);</span><br></pre></td></tr></table></figure></p>
<p>上述代码要告诉循环体其界限的范围，即<code>arr</code>到<code>arr+sizeof(arr)/sizeof(arr[0])</code>之间，才能按元素执行操作。</p>
<p>C++11也引入了基于范围的for循环，就可以很好地解决了这个问题<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> &amp;e: arr)</span><br><span class="line">        e *= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> &amp;e: arr)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; e &lt;&lt; &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这是一个基于范围的for循环的实例。for循环后的括号由冒号<code>:</code>分为两部分，第一部分是范围内用于迭代的变量，第二部分则表示将被送代的范围。基于范围的for循环跟普通循环是一样的，可以用continue语句来跳过循环的本次迭代，而用break语句来跳出整个循环。</p>
<p>值得指出的是，是否能够使用基于范围的for循环，必须依赖于一些条件。首先，就是for循环迭代的范围是可确定的。对于类来说，如果该类有<code>begin</code>和<code>end</code>函数，那么<code>begin</code>和<code>end</code>之间就是for循环迭代的范围。对于数组而言，就是数组的第一个和最后一个元素间的范围。其次，基于范围的for循环还要求迭代的对象实现<code>++</code>和<code>==</code>等操作符。对于标准库中的容器，如string、aray、 vector、 deque、list、 queue、map、set等，不会有问题，因为标准库总是保证其容器定义了相关的操作。普通的已知长度的数组也不会有问题。而用户自己写的类，则需要自行提供相关操作。</p>
<h1 id="提高类型安全"><a href="#提高类型安全" class="headerlink" title="提高类型安全"></a>提高类型安全</h1><h2 id="强类型枚举"><a href="#强类型枚举" class="headerlink" title="强类型枚举"></a>强类型枚举</h2><h3 id="强类型枚举-1"><a href="#强类型枚举-1" class="headerlink" title="强类型枚举"></a>强类型枚举</h3><p>非强类型作用域，允许隐式转换为整型，占用存储空间及符号性不确定，都是枚举类的缺点。针对这些缺点，新标准C++11引入了一种新的枚举类型，即“枚举类”，又称“强类型枚举”。声明强类型枚举非常简单，只需要在<code>enum</code>后加上关键字<code>class</code>。比如<code>enum class Type { General, Light, Medium, Heavy};</code>就声明了一个强类型的枚举<code>Type</code>。</p>
<p>强类型枚举具有以下几点优势</p>
<ul>
<li>强作用域，强类型枚举成员的名称不会被输出到其父作用域空间。</li>
<li>转换限制，强类型枚举成员的值不可以与整型隐式地相互转换。</li>
<li>可以指定底层类型。强类型枚举默认的底层类型为int，但也可以显式地指定底层类型具体方法为在枚举名称后面加上“:type”，其中<code>type</code>可以是除<code>wchar_t</code>以外的任何整型。比如<code>enum class Type: char { General, Light, Medium, Heavy};</code>就指定了<code>Type</code>是基于<code>char</code>类型的强类型枚举。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Type</span> &#123;</span> General, Light, Medium, Heavy &#125;;</span><br><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Category</span> &#123;</span> General = <span class="number">1</span>, Pistol, Machinegun, Cannon&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Type t = Type::Light;</span><br><span class="line">    t = General;                <span class="comment">//编译失败，必须使用强类型名称</span></span><br><span class="line">    <span class="keyword">if</span> (t == Category::General) <span class="comment">//编译失败，必须使用Type中的 General</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"General Weapon"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">if</span> (t &gt; Type::General)      <span class="comment">//通过编译</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Not General Weapon"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">if</span> (t &gt; <span class="number">0</span>)                  <span class="comment">//编译失败，无法转换为int类型</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Not General Weapon"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">int</span>)t &gt; <span class="number">0</span>)             <span class="comment">//通过编译</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Not General Weapon"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; is_pod&lt;Type&gt;::value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; is_pod&lt;Category&gt;::value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在代码清单5-5中，我们定义了两个强类型枚举<code>Type</code>和<code>Category</code>，它们都包含一个称为<code>General</code>的成员。由于强类型枚举成员的名字不会输出到父作用域，因此不会有编译问题。也由于不输出成员名字，所以我们在使用该类型成员的时候必须加上其所属的枚举类型的名字。此外，可以看到，枚举成员间仍然可以进行数值式的比较，但不能够隐式地转为int型。事实上，如果要将强类型枚举转化为其他类型，必须进行显式转换。事实上，强类型制止enum成员和int之间的转换，使得枚举更加符合“枚举”的本来意义，即对同类进行列举的一个集合，而定义其与数值间的关联则使之能够默认拥有种对成员排列的机制。而制止成员名字输出则进一步避免了名字空间冲突的问题。我们可以看到，<code>Type</code>和<code>Category</code>都是POD类型，不会像 class 封装版本一样被编译器视为结构体。</p>
<h2 id="堆内存管理"><a href="#堆内存管理" class="headerlink" title="堆内存管理"></a>堆内存管理</h2><h3 id="显式内存管理"><a href="#显式内存管理" class="headerlink" title="显式内存管理"></a>显式内存管理</h3><p>从语言层面来讲，我们可以将不正确处理堆内存的分配与释放归纳为以下一些问题。</p>
<ul>
<li>野指针：一些内存单元已被释放，之前指向它的指针却还在被使用。这些内存有可能被运行时系统重新分配给程序使用，从而导致了无法预测的错误</li>
<li>重复释放：程序试图去释放已经被释放过的内存单元，或者释放已经被重新分配过的内存单元，就会导致重复释放错误。通常重复释放内存会导致C++运行时系统打印出大量错误及诊断信息。</li>
<li>内存泄漏：不再需要使用的内存单元如果没有被释放就会导致内存泄漏。如果程序不断地重复进行这类操作，将会导致内存占用剧增。</li>
</ul>
<h3 id="C-11的智能指针"><a href="#C-11的智能指针" class="headerlink" title="C++11的智能指针"></a>C++11的智能指针</h3><p>在C++98中，智能指针通过一个模板类型<code>auto_ptr</code>来实现。<code>auto_ptr</code>以对象的方式管理堆分配的内存，并在适当的时间(比如析构)，释放所获得的堆内存。这种堆内存管理的方式只需要程序员将new操作返回的指针作为<code>auto_ptr</code>的初始值即可，程序员不用再显式地调用delete。不过<code>auto_ptr</code>有一些缺点(拷贝时返回一个左值，不能调用delete等)，所以在C++11标准中被废弃了。C++11标准中改用<code>unique_ptr</code>、<code>shared_ptr</code>及<code>weak_ptr</code>等智能指针来自动回收堆分配的对象。</p>
<p>这里我们可以看一个C++11中使用新的智能指针的简单例子<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; up1(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">11</span>)); <span class="comment">// 无法复制的 unique_ptr</span></span><br><span class="line">    <span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; up2 = up1;        <span class="comment">// 不能通过编译</span></span><br><span class="line">    <span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; up3 = move(up1);  <span class="comment">// 现在p3是数据唯一的 unique_ptr智能指针</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *up3 &lt;&lt; <span class="built_in">endl</span>;             <span class="comment">// 11</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *up1 &lt;&lt; <span class="built_in">endl</span>;             <span class="comment">// 运行时错误</span></span><br><span class="line">    up3.reset();                      <span class="comment">// 显式释放内存</span></span><br><span class="line">    up1.reset();                      <span class="comment">// 不会导致运行时错误</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *up3 &lt;&lt; <span class="built_in">endl</span>;             <span class="comment">// 运行时错误</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sp1(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">22</span>));</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sp2 = sp1;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *sp1 &lt;&lt; <span class="built_in">endl</span>;             <span class="comment">// 22</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *sp2 &lt;&lt; <span class="built_in">endl</span>;             <span class="comment">// 22</span></span><br><span class="line"></span><br><span class="line">    sp1.reset();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *sp2 &lt;&lt; <span class="built_in">endl</span>;             <span class="comment">// 22</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure></p>
<p>在代码中使用了两种不同的智能指针<code>unique_ptr</code>及<code>shared_ptr</code>来自动地释放堆对象的内存。由于每个智能指针都重载了<code>*</code>运算符，用户可以使用<code>up1</code>这样的方式来访问所分配的雄内存。而在该指针析构或者调用<code>reset</code>成员的时候，智能指针都可能释放其拥有的堆内存。从作用上来讲，<code>unique_ptr</code>和<code>shared_ptr</code>还是和以前的<code>auto_ptr</code>保持了一致。</p>
<p>不过从代码中还是可以看到，<code>unique_ptr</code>和<code>shared_ptr</code>在对所占内存的共享上还是有一定区别的。直观地看来，<code>unique_ptr</code>与所指对象的内存绑定紧密，不能与其他<code>unique_ptr</code>类型的指针对象共享所指对象的内存。比如，本例中的<code>unique_ptr&lt;int&gt; up2 = up1</code>不能通过编译，是因为每个<code>unique_ptr</code>都是唯一地“拥有”所指向的对象内存，由于<code>up1</code>唯一地占有了new分配的堆内存，所以<code>up2</code>无法共享其“所有权”。事实上，这种“所有权”仅能够通过标准库的<code>move</code>函数来转移。</p>
<p>我们可以看到代码中<code>up3</code>的定义，<code>unique_ptr&lt;int&gt; up3 = move(up1)</code>，一旦“所有权”转移成功了，原来的<code>unique_ptr</code>指针就失去了对象内存的所有权。此时再使用已经“失势”的<code>unique_ptr</code>，就会导致运行时的错误。</p>
<p>从实现上讲，<code>unique_ptr</code>则是一个删除了拷贝构造函数、保留了移动构造函数的指针封装类型。程序员仅可以使用右值对<code>unique_ptr</code>对象进行构造，而且一旦构造成功，右值对象中的指针即被“窃取”，因此该右值对象即刻失去了对指针的“所有权”。而<code>shared_ptr</code>同样形如其名，允许多个该智能指针共享地“拥有”同一堆分能对象的内存。与<code>unique_ptr</code>不同的是，由手在实现上采用了引用计数，所以一旦一个<code>shared_ptr</code>指针放弃了“所有权”(失效)，其他的<code>shared_ptr</code>对象内存的引用并不会受到影响。虽然<code>sp1</code>调用了<code>reset</code>成员函数，但由于<code>sp1</code>和<code>sp2</code>共享了new分配的堆内存，所以<code>sp1</code>调用<code>reset</code>成员函数只会导致引用计数的降低，而不会导致堆内存的释放。只有在引用计数归零的时候，<code>shared_ptr</code>才会真正释放所占有的堆内存的空间。</p>
<p>在C++11标准中，除了<code>unique_ptr</code>和<code>shared_ptr</code>，智能指针还包括了<code>weak_ptr</code>这个类模板。<code>weak_ptr</code>的使用更为复杂一点，它可以指向<code>shared_ptr</code>指针指向的对象内存，却并不拥有该内存。而使用<code>weak_ptr</code>成员<code>lock</code>，则可返回其指向内存的一个<code>shared_ptr</code>对象，且在所指对象内存已经无效时，返回指针空值(<code>nullptr</code>)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Check</span><span class="params">(weak_ptr&lt;<span class="keyword">int</span>&gt;&amp; wp)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; ap = wp.lock();   <span class="comment">//转换为shared_ptr&lt;int&gt;</span></span><br><span class="line">    <span class="keyword">if</span> (sp != <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"still "</span> &lt;&lt; *sp &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"pointer is invalid"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sp1 (<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">22</span>));</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sp2 = sp1;</span><br><span class="line">    weak_ptr&lt;<span class="keyword">int</span>&gt; wp = sp1;    <span class="comment">//指向shared_ptr&lt;int&gt;所指对象</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &gt;&gt; *sp1 &lt;&lt; <span class="built_in">endl</span>;             <span class="comment">// 22 </span></span><br><span class="line">    <span class="built_in">cout</span> &gt;&gt; *sp2 &lt;&lt; <span class="built_in">endl</span>;             <span class="comment">// 22 </span></span><br><span class="line">    Check(wp)                         <span class="comment">// still 22</span></span><br><span class="line">    </span><br><span class="line">    sp1.reset()</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *sp2 &lt;&lt; <span class="built_in">endl</span>;             <span class="comment">// 22</span></span><br><span class="line">    Check(wp);                        <span class="comment">// still 22</span></span><br><span class="line">    sp2.reset();</span><br><span class="line">    Check(wp)                         <span class="comment">// pointer is invalid</span></span><br></pre></td></tr></table></figure>
<p>在<code>sp1</code>和<code>sp2</code>都有效的时候，调用<code>wp</code>的<code>lock</code>函数，将返回一个有效的<code>shared_ptr</code>对象供使用，此后我们分别调用了<code>sp1</code>及<code>sp2</code>的<code>reset</code>函数，这会导致对唯一的堆内存对象的引用计数降至0。而一旦引用计数归0，<code>shared_ptr&lt;int&gt;</code>就会释放堆内存空间，使之失效。此时我们再调用<code>weak_ptr</code>的<code>lock</code>函数时，则返回一个指针空值<code>nullptr</code>。</p>
<h3 id="垃圾回收的分类"><a href="#垃圾回收的分类" class="headerlink" title="垃圾回收的分类"></a>垃圾回收的分类</h3><p>垃圾回收的方式虽然很多，但主要可以分为两大类</p>
<ul>
<li>基于引用计数的垃圾回收器<ul>
<li>引用计数主要是使用系统记录对象被引用(引用、指针)的次数。当对象被引用的次数变为0时，该对象即可被视作“垃圾”而回收。</li>
<li>使用引用计数做垃圾回收的算法的一个优点是实现很简单，与其他垃圾回收算法相比，该方法不会造成程序暂停，因为计数的增减与对象的使用是紧密结合的。</li>
<li>此外，引用计数也不会对系统的缓存或者交换空间造成冲击，因此被认为“副作用”较小。</li>
<li>但是这种方法比较难处理“环形引用”问题，此外由于计数带来的额外开销也并不小，所以在实用上也有一定的限制。</li>
</ul>
</li>
<li>基于跟踪处理的垃圾回收器<ul>
<li>跟踪处理的垃圾回收机制基本方法是产生跟踪对象的关系图，然后进行垃圾回收。</li>
<li>使用跟踪方式的垃圾回收算法主要有以下几种：<ul>
<li>标记-清除(Mark-Swep)<ul>
<li>首先该算法将程序中正在使用的对象视为“根对象”，从根对象开始查找它们所引用的堆空间，并在这些堆空间上做标记。当标记结束后所有被标记的对象就是可达对象( Reachable Object)或活对象( Live Object)，而没有被标记的对象就被认为是垃圾</li>
<li>在第二步的清扫(Swep)阶段会被回收掉。</li>
<li>这种方法的特点是活的对象不会被移动，但是其存在会出现大量的内存碎片的问题。</li>
</ul>
</li>
<li>标记-整理(Mark-Compact)<ul>
<li>标记完之后，不再遍历所有对象清扫垃圾，而是将活的对象向“左”靠齐，这就解决了内存碎片的问题。</li>
<li>标记-整理的方法有个特点就是移动活的对象，因此相应的，程序中所有对堆内存的引用都必须更新</li>
</ul>
</li>
<li>标记-拷贝(Mark-Copy)<ul>
<li>这种算法将堆空间分为两个部分：From和To。</li>
<li>刚开始系统只从From的堆空间里面分配内存，当From分配满的时候系统就开始垃圾回收：从From堆空间找出所有活的对象，拷贝到To的堆空间里。这样一来，From的堆空间里面就全剩下垃圾了。而对象被拷贝到T0里之后，在To里是紧湊排列的。</li>
<li>接下来是需要将From和To交换一下角色，接着从新的From里面开始分配。</li>
<li>标记-拷贝算法的一个问题是堆的利用率只有一半，而且也需要移动活的对象。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="提高性能及操作硬件的能力"><a href="#提高性能及操作硬件的能力" class="headerlink" title="提高性能及操作硬件的能力"></a>提高性能及操作硬件的能力</h1><h2 id="常量表达式"><a href="#常量表达式" class="headerlink" title="常量表达式"></a>常量表达式</h2><h3 id="运行时常量性与编译时常量性"><a href="#运行时常量性与编译时常量性" class="headerlink" title="运行时常量性与编译时常量性"></a>运行时常量性与编译时常量性</h3><p>常量通常是通过 const关键字来修饰的。比如<code>const int i = 3</code>。</p>
<p>上述代码就声明了一个名字为i的常量。const还可以修饰函数参数、函数返回值、函数本身、类等。在不同的使用条件下， const有不同的意义，不过大多数情况下， const描述的都是一些“运行时常量性”的概念，即具有运行时数据的不可更改性。不过有的时候，我们需要的却是编译时期的常量性，这是 const关键字无法保证的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span> <span class="title">Getconst</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Constless</span><span class="params">(<span class="keyword">int</span> cond)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[Getconst()] = &#123;<span class="number">0</span>&#125;;   <span class="comment">//无法通过编译</span></span><br><span class="line">    <span class="keyword">enum</span>&#123; e1 = Getconst(), e2 &#125;; <span class="comment">//无法通过编译</span></span><br><span class="line">    <span class="keyword">switch</span> (cond) &#123;</span><br><span class="line">        case Getconst():</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们定义了一个返回常数1的函数<code>Getconst()</code>。我们使用了const关键字修饰了返回类型。不过编译后我们发现，无论将<code>Getconst</code>的结果用于需要初始化数组<code>arr</code>的声明中，还是用于匿名枚举中，或用于switch-case的case表达式中，编译器都会报告错误。这些语句都需要的是编译时期的常量值。而<code>const</code>修饰的函数返回值，只保证了在运行时期内其值是不可以被更改的。这是两个完全不同的概念。</p>
<p>C++11中对象时期常量的回答是<code>constexpr</code>，即常量表达式(constant expression)。可以用下面的声明方法<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">Getconst</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="number">1</span>;&#125;</span><br></pre></td></tr></table></figure></p>
<p>即在函数表达式前加上<code>constexpr</code>关键字即可。有了常量表达式这样的声明，编译器就可以在编译时期对<code>Getconst</code>表达式进行值计算(evaluation)，从而将其视为一个绵译时期的常量。常量表达式实际上可以作用的实体不仅限于函数，还可以作用于数据声明，以及类的构造函数等。</p>
<h3 id="常量表达式函数"><a href="#常量表达式函数" class="headerlink" title="常量表达式函数"></a>常量表达式函数</h3><p>通常我们可以在函数返回类型前加入关键字<code>constexpr</code>来使其成为常量表达式函数。不过并非所有的函数都有资格成为常量表达式函数。事实上，常量表达式函数的要求非常严格。总结起来，大概有以下几点：</p>
<ul>
<li>函数体只有单一的return返回语句。<ul>
<li>函数体中只有一条语句，且该条语句必须是 return语句。</li>
<li>这就意味着形如<code>int i = 1; return i;</code>这样的多条语句的写法是无法通过编译的。</li>
<li>不过一些不会产生实际代码的语句不会导致编译器的“抱怨”。</li>
</ul>
</li>
<li>函数必须返回值(不能是void函数)。<ul>
<li>形如<code>constexpr void f() {}</code>这样的不返回值的函数就不能是常量表达式。</li>
<li>因为无法获得常量的常量表达式是不被认可的。</li>
</ul>
</li>
<li>在使用前必须已有定义。<br>  - </li>
<li>return返回语句表达式中不能使用非常量表达式的函数、全局数据，且必须是一个常量表达式。<ul>
<li>形如<code>constexpr int g() { return e();}</code>或者形如<code>constexpr int h() { return g;}</code>的常量表达式定义是不能通过编译的。</li>
<li>如果我们要使得<code>g()</code>是个编译时的常量，那么其return表达式语句就不能包含运行时才能确定返回值的函数。</li>
</ul>
</li>
</ul>
<h3 id="常量表达式值"><a href="#常量表达式值" class="headerlink" title="常量表达式值"></a>常量表达式值</h3><p>通常情况下，常量表达式值必须被常量表达式赋值，而跟常量表达式函数一样，常量表达式值在使用前必须被初始化。而使用<code>constexpr</code>声明的数据最常被问起的问题是，下列两条语句：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> j = <span class="number">1</span>;</span><br></pre></td></tr></table></figure></p>
<p>在大多数情况下是没有区别的。如果<code>i</code>在全局名字空间中，编译器一定会为<code>i</code>产生数据。而对于<code>j</code>，如果不是有代码显式地使用了它的地址，编译器可以选择不为它生成数据，而仅将其当做编译时期的值。</p>
<p>有的时候，我们在常量表达式中会看到浮点数。通常情况下，编译器对浮点数做编译时期常量这件事情很敏感。因为编译时环境和运行时环境可能有所不同，那么编译时的浮点常量和实际运行时的浮点数常量可能在精度上存在差别。而对于自定义类型的数据，要使其成为常量表达式值的话，则不像内置类型这么简单。C++标准中，<code>constexpr</code>关键字是不能用于修饰自定义类型的定义的。比如下面这样的类型定义和使用<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="class"><span class="keyword">struct</span> <span class="title">Mytype</span> &#123;</span> <span class="keyword">int</span> i; &#125;</span><br><span class="line"><span class="keyword">constexpr</span> Mytype mt = &#123; <span class="number">0</span> &#125;;</span><br></pre></td></tr></table></figure></p>
<p>在C++11中，就是无法通过编译的。正确地做法是，定义自定义常量构造函数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Mytype</span> &#123;</span></span><br><span class="line">    constexpr Mytype(int x): i(x) &#123;&#125;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> Mytype mt = &#123; <span class="number">0</span> &#125;;</span><br></pre></td></tr></table></figure></p>
<p>我们对<code>Mytype</code>的构造函数进行了定义。不过在定义前，我们加上了<code>constexpr</code>关键字。通过这样的定义，<code>Mytype</code>类型的<code>constexpr</code>的变量<code>mt</code>的定义就可以通过编译了。</p>
<p>常量表达式的构造函数也有使用上的约束，主要的有以下两点</p>
<ul>
<li>函数体必须为空。</li>
<li>初始化列表只能由常量表达式来赋值。</li>
</ul>
<p>形如下面的常量表达式构造函数都是无法通过编译的<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">struct Mytype &#123; int i; constexpr Mytype(): i(f()) &#123;&#125; &#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="常量表达式的其他应用"><a href="#常量表达式的其他应用" class="headerlink" title="常量表达式的其他应用"></a>常量表达式的其他应用</h3><p>常量表达式是可以用于模板函数的。不过由于模板中类型的不确定性，所以模板函数是否会被实例化为一个能够满足编译时常量性的版本通常也是未知的。针对这种情况，C++11标准规定，当声明为常量表达式的模板函数后，而某个该模板函数的实例化结果不满足常量表达式的需求的话，<code>constexpr</code>会被自动忽略。该实例化后的函数将成为一个普通函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Notliteral</span> &#123;</span></span><br><span class="line">    Notliteral() &#123; i = <span class="number">5</span>; &#125;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line">Notliteral nl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">contexpr T <span class="title">Constexp</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Nothiteral nl;</span><br><span class="line">    Notliteral nl1 = Constexp(nl);</span><br><span class="line">    <span class="keyword">constexpr</span> Notliteral nl2 = Constexp(nl); <span class="comment">//无法通过编译</span></span><br><span class="line">    <span class="keyword">int</span> a = Constexp(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>结构体<code>Notliteral</code>不是一个定义了常量表达式构造函数的类型，因此是不能够声明为常量表达式值的。而模板函数<code>Constexp</code>一旦以<code>Notliteral</code>为参数的话，那么其<code>constexpr</code>关键字将被忽略，如<code>nl1</code>变量所示。实例化为<code>Constexp&lt;Notliteral&gt;</code>的函数将不是一个常量表达式函数，因此，我们也看到<code>nl2</code>是无法通过编译的。而在可以实例化为常量表达式函数的时候，<code>Constexp</code>则可以用于常量表达式值的初始化。比如本例中的<code>a</code>，就是由实例化为<code>Constexp&lt;int&gt;</code>的常量表达式函数所初始化的。</p>
<p>对于常量表达式的应用，还有一个有趣的问题就是函数递归问题。在标准中说明，符合C++11标准的编译器对常量表达式函数应该至少支持512层的递归。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (n == <span class="number">1</span>) ? <span class="number">1</span> : ((n == <span class="number">2</span>) ? <span class="number">1</span> : Fibonacci(n<span class="number">-1</span>) + Fibonacci(n<span class="number">-2</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fib[] = &#123;</span><br><span class="line">        Fibonacci(<span class="number">11</span>), Fibonacci(<span class="number">12</span>),</span><br><span class="line">        Fibonacci(<span class="number">13</span>), Fibonacci(<span class="number">14</span>),</span><br><span class="line">        Fibonacci(<span class="number">15</span>),Fibonacci (<span class="number">16</span>)</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure></p>
<p>早在C++模板刚出现的时候，就出现了基于模板的编译时期运算的编程方式，这种编程通常被称为模板元编程(template meta-programming)。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">long</span> num&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fibonacci</span> &#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">long</span> val = Fibonacci&lt;num<span class="number">-1</span>&gt;::val + Fibonacci&lt;num<span class="number">-2</span>&gt;::val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="class"><span class="keyword">struct</span> <span class="title">Fibonacci</span>&lt;2&gt;&#123;</span> <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">long</span> val = <span class="number">1</span>; &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="class"><span class="keyword">struct</span> <span class="title">Fibonacci</span>&lt;1&gt;&#123;</span> <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">long</span> val = <span class="number">1</span>; &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="class"><span class="keyword">struct</span> <span class="title">Fibonacci</span>&lt;0&gt;&#123;</span> <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">long</span> val = <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    fib[] = &#123;</span><br><span class="line">        Fibonacci&lt;<span class="number">11</span>&gt;::val, Fibonacci&lt;<span class="number">12</span>&gt;::val,</span><br><span class="line">        Fibonacci&lt;<span class="number">13</span>&gt;::val, Fibonacci&lt;<span class="number">14</span>&gt;::val,</span><br><span class="line">        Fibonacci&lt;<span class="number">15</span>&gt;::val, Fibonacci&lt;<span class="number">16</span>&gt;::val</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>定义了一个非类型参数的模板<code>Fibonacci</code>。该模板类定义了一个静态变量<code>val</code>，而<code>val</code>的定义方式是递归的。因此模板将会递归地进行推导。此外，我们还通过偏特化定义了模板推导的边界条件，即斐波那契的初始值。那么模板在推导到边界条件的时候就会终止推导。通过这样的方法，我们同样可以在编译时进行值计算，从而生成数组的值。通过<code>constexpr</code>进行的运行时值计算，跟模板元编程非常类似。因此有的程序员自然地称利用constexpr进行编译时期运算的编程方式为constexpr元编程。</p>
<h2 id="变长模板"><a href="#变长模板" class="headerlink" title="变长模板"></a>变长模板</h2><h3 id="变长函数和变长的模板参数"><a href="#变长函数和变长的模板参数" class="headerlink" title="变长函数和变长的模板参数"></a>变长函数和变长的模板参数</h3><p>通过使用变长函数(variadic funciton)，<code>printf</code>的实现能够接受任何长度的参数列表。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarh.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Sumoffloat</span><span class="params">(<span class="keyword">int</span> count, ...)</span> </span>&#123;</span><br><span class="line">    va_list ap;</span><br><span class="line">    <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">    va_start(ap, count);     <span class="comment">//获得变长列表的句柄ap</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i ++)</span><br><span class="line">        sum += va_arg(ap, <span class="keyword">double</span>);    <span class="comment">//每次获得一个参数</span></span><br><span class="line">    va_end(ap);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在被调用者中，需要通过一个类型为<code>va_list</code>的数据结构<code>ap</code>来辅助地获得参数。可以看到，这里代码首先使用<code>va_start</code>函数对<code>ap</code>进行初始化，使得<code>ap</code>成为被传递的变长参数的一个句柄。而后代码再使用<code>va_arg</code>函数从<code>ap</code>中将参数一一取出用于运算。由于这里是计算浮点数的和，所以每次总是给<code>va_arg</code>传递一个<code>double</code>类型作为参数。图显示了一种变长函数的可能的实现方式，即以句柄<code>ap</code>为指向各个变长参数的指针，而<code>va_arg</code>则通过改变指针的方式来返回下一个指针所指向的对象。<br><img src="/img/1628912842.jpg" alt></p>
<h3 id="変长模板：模板参数包和函数参数包"><a href="#変长模板：模板参数包和函数参数包" class="headerlink" title="変长模板：模板参数包和函数参数包"></a>変长模板：模板参数包和函数参数包</h3><p>以<code>tuple</code>为例，我们需要以下代码来声明<code>tuple</code>是一个变长类模板<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Elements&gt; <span class="class"><span class="keyword">class</span> <span class="title">tuple</span>;</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到，我们在标示符<code>Elements</code>之前的使用了省略号来表示该参数是变长的。在C++11中，<code>Elements</code>被称作是一个“模板参数包”。这是一种新的模板参数类型。有了这样的参数包，类模板<code>tuple</code>就可以接受任意多个参数作为模板参数。对于以下实例化的<code>tuple</code>模板类：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tuple&lt;<span class="keyword">int</span>, <span class="keyword">char</span>, <span class="keyword">double</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>编译器则可以将多个模板参数打包成为“单个的”模板参数包<code>Elements</code>，即<code>Element</code>在进行模板推导的时候，就是一个包含int、char和 double三种类型类型集合。</p>
<p>与普通的模板参数类似，模板参数包也可以是非类型的，比如<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span>... A&gt; <span class="class"><span class="keyword">class</span> <span class="title">Nontypevariadictemplate</span>&#123;</span>&#125;;</span><br><span class="line">Nontypevariadictemplate&lt;<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>&gt; ntvt;</span><br></pre></td></tr></table></figure></p>
<p>就定义了接受非类型参数的变长模板<code>Nontypevariadictemplate</code>。这里，我们实例化参数<code>(1,0,2)</code>的模板实例该声明方式相当于<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="class"><span class="keyword">class</span> <span class="title">Nontypevariadictemplate</span>&#123;</span>&#125;;</span><br><span class="line">Nontypevariadictemplate&lt;<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>&gt; ntvt;</span><br></pre></td></tr></table></figure></p>
<p>这样的类模板定义和实例化。除了类型的模板参数包和非类型的模板参数包，模板参数包实际上还是模板类型的。</p>
<p>一个模板参数包在模板推导时会被认为是模板的单个参数(虽然实际上它将会打包任意数量的实参)。为了使用模板参数包，我们总是需要将其解包(unpack)。在C++11中，这通常是通过一个名为包扩展(pack expansion)的表达式来完成。比如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... A&gt; <span class="class"><span class="keyword">class</span> <span class="title">Template</span>:</span> <span class="keyword">private</span> B&lt;A...&gt;&#123;&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这里的表达式<code>A...</code>就是一个包扩展。直观地看，参数包会在包扩展的位置展开为多个参数。比如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt; <span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span>&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>...A&gt; <span class="class"><span class="keyword">class</span> <span class="title">Template</span>:</span> <span class="keyword">private</span> B&lt;A...&gt;&#123;&#125;;</span><br><span class="line">Template&lt;X, Y&gt; xy;</span><br></pre></td></tr></table></figure></p>
<p>这里我们为类模板声明了一个参数包<code>A</code>，而使用参数包<code>A</code>则是在<code>Template</code>的私有基类<code>B&lt;A...&gt;</code>中，那么最后一个表达式就声明了一个基类为<code>B&lt;X,Y&gt;</code>的模板类<code>Template&lt;X,Y&gt;</code>的对象<code>xy</code>。其中<code>X</code>、<code>Y</code>两个模板参数先是被打包为参数包<code>A</code>，而后又在包扩展表达式<code>A...</code>中被还原。</p>
<p>通过定义递归的模板偏特化定义，我们可以使得模板参数包在实例化时能够层层展开，直到参数包中的参数逐渐耗尽或到达某个数量的边界为止。下面的例子是一个用变长模板实现<code>tuple</code>的代码。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Elements&gt; <span class="class"><span class="keyword">class</span> <span class="title">tuple</span>;</span> <span class="comment">//变长模板的声明</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Head, <span class="keyword">typename</span>... Tail&gt;   <span class="comment">//递归的偏特化定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">tuple</span>&lt;Head, Tail...&gt; :</span> <span class="keyword">private</span> tuple&lt;Tail...&gt; &#123;</span><br><span class="line">    Head head;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="class"><span class="keyword">class</span> <span class="title">tuple</span>&lt;&gt; &#123;</span>&#125;;                <span class="comment">//边界条件</span></span><br></pre></td></tr></table></figure></p>
<p>我们声明了变长模板类<code>tuple</code>，其只包含一个模板参数，即<code>Elements</code>模板参数包。此外，我们又偏特化地定义了一个双参数的<code>tuple</code>的版本。该偏特化版本的<code>tuple</code>包含了两个参数，一个是类型模板参数<code>Head</code>，另一个则是模板参数包<code>Tail</code>。<code>Head</code>型的数据作为<code>tuple&lt;Head,Tail...&gt;</code>的第一个成员，而将使用了包扩展表达式的模板类<code>tuple&lt;Tail...&gt;</code>作为<code>tuple&lt;Head,Tail...&gt;</code>的私有基类。这样来，当程序员实例化一个形如<code>tuple &lt;double, int, char, float&gt;</code>的类型时，则会引起基类的递归构造，这样的递归在<code>tuple</code>的参数包为0个的时候会结束。</p>
<p>我们再来看一个使用非类型模板的一个例子。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">long</span>... nums&gt; <span class="class"><span class="keyword">struct</span> <span class="title">Multiply</span>;</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">long</span> first, <span class="keyword">long</span>... last&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Multiply</span>&lt;first, last...&gt; &#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">long</span> val = first * Multiply&lt;last...&gt;::val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Multiply</span>&lt;&gt; &#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">long</span> val = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; Multiply&lt;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&gt;::val &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; Multip1y&lt;<span class="number">22</span>,<span class="number">44</span>,<span class="number">66</span>,<span class="number">88</span>,<span class="number">9</span>&gt;::val &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="变长模板：进阶"><a href="#变长模板：进阶" class="headerlink" title="变长模板：进阶"></a>变长模板：进阶</h3><p>标准定义了以下7种参数包可以展开的位置</p>
<ul>
<li>表达式</li>
<li>初始化列表</li>
<li>基类描述列表</li>
<li>类成员初始化列表</li>
<li>模板参数列表</li>
<li>通用属性列表</li>
<li>lambda函数的捕捉列表</li>
</ul>
<p>语言的其他“地方”则无法展开参数包。而对于包扩展而言，其解包也与其声明的形式息息相关。事实上，我们还可以声明一些有趣的包扩展表达式。比如声明了<code>Arg</code>为参数包，那么我们可以使用<code>Arg&amp;&amp;...</code>这样的包扩展表达式，其解包后等价于<code>Arg1&amp;&amp;, ..., Argn&amp;&amp;</code>。</p>
<p>一个更为有趣的包扩展表达式如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>...A&gt; <span class="class"><span class="keyword">class</span> <span class="title">T</span>:</span> <span class="keyword">private</span> B&lt;A&gt;...&#123;&#125;'</span><br></pre></td></tr></table></figure></p>
<p>注意这个包扩展跟下面的类模板声明<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>...A&gt; <span class="class"><span class="keyword">class</span> <span class="title">T</span>:</span> <span class="keyword">private</span> B&lt;A...&gt;&#123;&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在解包后是不同的，对于同样的实例化<code>T&lt;X,Y&gt;</code>，前者会解包为：<code>class T&lt;X, Y&gt;: private B&lt;X&gt;, private B&lt;Y&gt;{};</code>即多重继承的派生类，而后者则会解包为<code>class T&lt;X, Y&gt;: private B&lt;X, Y&gt;{};</code>即派生于多参数的模板类的派生类，这点存在着本质的不同。</p>
<p>在C++11中，标准还引入了新操作符<code>sizeof...</code>，其作用是计算参数包中的参数个数。通过这个操作符，我们能够实现参数包更多的用法。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span>...<span class="title">A</span>&gt; <span class="title">void</span> <span class="title">Print</span>(<span class="title">A</span>...<span class="title">arg</span>) &#123;</span></span><br><span class="line">    assert(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//特化6参数的版本</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(<span class="keyword">int</span> a1, <span class="keyword">int</span> a2, <span class="keyword">int</span> a3, <span class="keyword">int</span> a4, <span class="keyword">int</span> a5, <span class="keyword">int</span> a6)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a1 &lt;&lt; a2 &lt;&lt; a3 &lt;&lt; a4 &lt;&lt; a5 &lt;&lt; a6 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span>...<span class="title">A</span>&gt; <span class="title">int</span> <span class="title">Vaargs</span>(<span class="title">A</span> ...<span class="title">args</span>) &#123;</span></span><br><span class="line">    <span class="keyword">int</span> size = <span class="keyword">sizeof</span>...(A);      <span class="comment">//计算变长包的长度</span></span><br><span class="line">    <span class="keyword">switch</span>(size) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: Print(<span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: Print(<span class="number">99</span>, <span class="number">99</span>, args..., <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: Print(<span class="number">99</span>, <span class="number">99</span>, args..., <span class="number">99</span>, <span class="number">99</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>: Print(args..., <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>: Print(<span class="number">99</span>, args..., <span class="number">99</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>: Print(<span class="number">99</span>, args...);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>: Print(args...);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>: Print(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="原子类型与原子操作"><a href="#原子类型与原子操作" class="headerlink" title="原子类型与原子操作"></a>原子类型与原子操作</h2><h3 id="原子操作与C-11原子类型"><a href="#原子操作与C-11原子类型" class="headerlink" title="原子操作与C++11原子类型"></a>原子操作与C++11原子类型</h3><p>所谓原子操作，就是多线程程序中“最小的且不可并行化的”的操作。通常对一个共享资源的操作是原子操作的话，意味着多个线程访问该资源时，有且仅有唯一一个线程在对这个资源进行操作。那么从线程(处理器)的角度看来，其他线程就不能够在本线程对资源访问期间对该资源进行操作，因此原子操作对于多个线程而言，就不会发生有别于单线程程序的意外状况。通常情况下，原子操作都是通过“互斥”( mutual exclusive)的访问来保证的。实现互斥通常需要平台相关的特殊指令，这在C++11标准之前，这常常意味着需要在C/C++代码中嵌入内联汇编代码。</p>
<p>在C++11的并行程序中，使用原子类型是非常容易的。事实上，由于C++11与C11标准都支持原子类型，因此我们可以简单地通过<code>#include&lt;cstdatomic&gt;</code>头文件中来使用对应于内置类型的原子类型定义。<code>&lt;cstdatomic&gt;</code>中包含的原子类型定义如表所示。</p>
<table>
<thead>
<tr>
<th>原子类型名称</th>
<th>对应的内置类型名称</th>
</tr>
</thead>
<tbody>
<tr>
<td>atomic_bool</td>
<td>bool</td>
</tr>
<tr>
<td>atomic_char</td>
<td>char</td>
</tr>
<tr>
<td>atomic_schar</td>
<td>signed char</td>
</tr>
<tr>
<td>atomic_uchar</td>
<td>unsigned char</td>
</tr>
<tr>
<td>atomic_int</td>
<td>int</td>
</tr>
<tr>
<td>atomic_uint</td>
<td>unsigned int</td>
</tr>
<tr>
<td>atomic_short</td>
<td>short</td>
</tr>
<tr>
<td>atomic_ushort</td>
<td>unsigned short</td>
</tr>
<tr>
<td>atomic_long</td>
<td>long</td>
</tr>
<tr>
<td>atomic_ulong</td>
<td>unsigned long</td>
</tr>
<tr>
<td>atomic_llong</td>
<td>long long</td>
</tr>
<tr>
<td>atomic_ullong</td>
<td>unsigned long long</td>
</tr>
<tr>
<td>atomic_char16_t</td>
<td>char16_t</td>
</tr>
<tr>
<td>atomic_char32_t</td>
<td>char32_t</td>
</tr>
<tr>
<td>atomic_wchar_t</td>
<td>wchar_t</td>
</tr>
</tbody>
</table>
<p>程序员可以使用<code>atomic</code>类模板任意定义出需要的原子类型。比如下列语句：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::atomic&lt;T&gt; t;</span><br></pre></td></tr></table></figure></p>
<p>就声明了一个类型为<code>T</code>的原子类型変量<code>t</code>。编译器会保证产生并行情况下行为良好的代码，以避免线程间对数据<code>t</code>的竞争。</p>
<p>对于线程而言，原子类型通常属于“资源型”的数据，这意味着多个线程通常只能访问单个原子类型的拷贝。因此在C++11中，原子类型只能从其模板参数类型中进行构造，标准不允许原子类型进行拷贝构造、移动构造，以及使用<code>operator=</code>等，以防止发生意外。比如<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">atomic&lt;<span class="keyword">float</span>&gt; af &#123;<span class="number">1.2f</span>&#125;; </span><br><span class="line">atomic&lt;<span class="keyword">float</span>&gt; af1 &#123;af&#125;;<span class="comment">//无法通过编译</span></span><br></pre></td></tr></table></figure></p>
<p>其中，<code>af1{af}</code>的构造方式在C++11中是不允许的。不过从<code>atomic&lt;T&gt;</code>类型的变量来构造其模板参数类型T的变量则是可以的。比如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">atomic&lt;<span class="keyword">float</span>&gt; af &#123;<span class="number">1.2f</span>&#125;;</span><br><span class="line"><span class="keyword">float</span> f = af;</span><br><span class="line"><span class="keyword">float</span> f1 &#123;af&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这是由于<code>atomic</code>类模板总是定义了从<code>atomic&lt;T&gt;</code>到<code>T</code>的类型转换函数的缘故。在需要时，编译器会隐式地完成原子类型到其对应的类型的转换。</p>
<h3 id="内存模型，顺序一致性与memory-order"><a href="#内存模型，顺序一致性与memory-order" class="headerlink" title="内存模型，顺序一致性与memory order"></a>内存模型，顺序一致性与memory order</h3><p>要了解顺序一致性以及内存模型，我们不妨看看代码。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">atomic&lt;<span class="keyword">int</span>&gt; a &#123;<span class="number">0</span>&#125;;</span><br><span class="line">atomic&lt;<span class="keyword">int</span>&gt; b &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">valueset</span> <span class="params">(<span class="keyword">int</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">1</span>;</span><br><span class="line">    a = t;</span><br><span class="line">    b = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Observer</span><span class="params">(<span class="keyword">int</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125; <span class="comment">//可能有多种输出</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(valueset, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(observer, <span class="number">0</span>)</span></span>;</span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们创建了两个线程1和2，分别执行<code>valueset</code>和<code>observer</code>。在<code>valueset</code>中，为<code>a</code>和<code>b</code>分别赋值1和2。而在<code>observer</code>中，只是打印出<code>a</code>和<code>b</code>的值。可以想象，由于<code>observer</code>打印<code>a</code>和<code>b</code>的时间与<code>valueset</code>设置<code>a</code>和<code>b</code>的时间可能有多种组合方式。</p>
<p>默认情况下，在C++11中的原子类型的变量在线程中总是保持着顺序执行的特性。我们称这样的特性为“顺序一致”的，即代码在线程中运行的顺序与程序员看到的代码顺序一致。</p>
<p>对于C++11中的内存模型而言，要保证代码的顺序一致性，就必须同时做到以下几点</p>
<ul>
<li>编译器保证原子操作的指令间顺序不变，即保证产生的读写原子类型的变量的机器指令与代码编写者看到的是一致的。</li>
<li>处理器对原子操作的汇编指令的执行顺序不变。这对于x86这样的强顺序的体系结构而言，并没有任何的问题。</li>
</ul>
<p>如前文所述，在C++11中，原子类型的成员函数(原子操作)总是保证了顺序一致性。这对于x86这样的平台来说，禁止了编译器对原子类型变量间的重排序优化。在C++11中，设计者给出的解决方式是让程序员为原子操作指定所谓的内存顺序。代码中可以采用一种松散的内存模型来放松对原子操作的执行顺序的要求。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">atomic&lt;<span class="keyword">int</span>&gt; a &#123;<span class="number">0</span>&#125;;</span><br><span class="line">atomic&lt;<span class="keyword">int</span>&gt; b &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Valueset</span><span class="params">(<span class="keyword">int</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">1</span>;</span><br><span class="line">    a.store(t, memory_order_relaxed);</span><br><span class="line">    b.store(<span class="number">2</span>, memory_order_relaxed);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Observer</span><span class="params">(<span class="keyword">int</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//可能有多种输出</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(valueset, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(observer, <span class="number">0</span>)</span></span>;</span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对<code>Valueset</code>函数进行了改造。之前的对<code>a</code>、<code>b</code>进行赋值的语句我们改用了<code>atomic</code>类模板的<code>store</code>成员。<code>store</code>能够接受两个参数，一个是需要写入的值，一个是名为<code>memory_order</code>的枚举值。这里我们使用的值是<code>memory_order_relaxed</code>，表示使用松散的内存模型，该指令可以任由编译器重排序或者由处理器乱序执行。这样一来，<code>a</code>、<code>b</code>赋值语句的“先于发生”顺序得到了解除，我们也就可能得到最佳的运行性能。</p>
<p>大多数<code>atomic</code>原子操作都可以使用<code>memory_order</code>作为一个参数，在C++11中，标准一共定义了7种<code>memory_order</code>的枚举值。</p>
<table>
<thead>
<tr>
<th>枚举值</th>
<th>定义规则</th>
</tr>
</thead>
<tbody>
<tr>
<td>memory_order_relaxed</td>
<td>不对执行顺序做任何保证</td>
</tr>
<tr>
<td>memory_order_acquire</td>
<td>本线程中，所有后续的读操作必须在本条原子操作完成后执行</td>
</tr>
<tr>
<td>memory_orfer_release</td>
<td>本线程中，所有之前的写操作完成后才能执行本条原子操作</td>
</tr>
<tr>
<td>memory_order_acq_rel</td>
<td>同时包含memory_order_acquire和memory_order_release标记</td>
</tr>
<tr>
<td>memory_order_consume</td>
<td>本线程中，所有后续的有关本原子类型的操作，必须在本条原子操作完成之后执行</td>
</tr>
<tr>
<td>memory_order_seq_cst</td>
<td>全部存取都按顺序执行</td>
</tr>
</tbody>
</table>
<p><code>memory_order_seq_cst</code>表示该原子操作必须是顺序一致的，这是C++11中所有<code>atomic</code>原子操作的默认值，不带<code>memory_order</code>参数的原子操作就是使用该值。而<code>memory_order_relaxed</code>则表示该原子操作是松散的，可以被任意重排序的。值得注意的是，并非每种<code>memory_order</code>都可以被<code>atomic</code>的成员使用。通常情况下，我们可以把<code>atomic</code>成员函数可使用的<code>memory_order</code>值分为以下3组</p>
<ul>
<li>原子存储操作(store)可以使用<code>memorey_order_relaxed</code>、<code>memory_order_release</code>、<code>memory_order_seq_cst</code></li>
<li>原子读取操作(load)可以使用<code>memorey_order_relaxed</code>、<code>memory_order_consume</code>、<code>memory_order_acquire</code>、<code>memory_order_seq_cst</code></li>
<li>RMW操作，一些需要同时读写的操作，比如之前提过的<code>atomic_flag</code>类型的<code>test_and_set()</code>操作。又比如<code>atomic</code>类模板的<code>atomic_compare_exchange()</code>操作等都是需要同时读写的。RMW操作可以使用<code>memorey_order_relaxed</code>、<code>memory_order_consume</code>、<code>memory_order_acquire</code>、<code>memory_order_release</code>、<code>memory_order_acq_rel</code>、<code>memory_order_seq_cst</code></li>
</ul>
<p>形如<code>operator=</code>、<code>operator+=</code>的函数，事实上都是<code>memory_order_seq_cst</code>作为memory order参数的原子操作的简单封装。也即是说，之前小节中的代码都是采用顺序致性的内存模型。如之前提到的，<code>memory_order_seq_cst</code>这种memory order对于<code>atomic</code>类型数据的内存顺序要求过高，容易阻碍系统发挥线程应有的性能。而<code>memorey_order_relaxed</code>对内存顺序毫无要求。</p>
<p>但在另外一些情况下，则还是可能无法满足真正的需求<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">atomic&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line">atomic&lt;<span class="keyword">int</span>&gt; b;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Thread1</span><span class="params">(<span class="keyword">int</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">1</span>;</span><br><span class="line">    a.store(t, memory_order_relaxed);</span><br><span class="line">    b.store(<span class="number">2</span>, memory_order_relaxed);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Thread2</span><span class="params">(<span class="keyword">int</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(b.load(memory_order_relaxed) != <span class="number">2</span>); <span class="comment">//自旋等待</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a.load(memory_order_relaxed) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(Thread1, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(Thread2, <span class="number">0</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    t2.join();</span><br><span class="line">    t2.join();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里我们并不希望完全禁用关于原子类型的优化，而采用了<code>memory_order_relaxed</code>作为memory order参数。在一些弱内存模型的机器上，这两条a、b赋值语句将有可能任意一条被先执行。那么对于<code>Thread2</code>函数而言，它先是自旋等待<code>b</code>的值被赋为2，随后将<code>a</code>的值输出。按照松散的内存顺序，我们输出的<code>a</code>的值则有可能为0，也有可能为1。</p>
<p>如果读者仔细地分析的话，我们所需要的只是<code>a.store</code>先于<code>b.store</code>发生，<code>b.load</code>先于<code>a.load</code>发生的顺序。这要这两个“先于发生”关系得到了遵守，对于整个程序而言来说，就不会发生线程间的错误。建立这种“先于发生”关系，即原子操作间的顺序则需要利用其他的memory order枚举值。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">atomic&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line">atomic&lt;<span class="keyword">int</span>&gt; b;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Thread1</span><span class="params">(<span class="keyword">int</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">1</span>;</span><br><span class="line">    a.store(t, memory_order_relaxed);</span><br><span class="line">    b.store(<span class="number">2</span>, memory_order_release); <span class="comment">//本原子操作前所有的写原子操作必须完成</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Thread2</span><span class="params">(<span class="keyword">int</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(b.load(memory_order_acquire)!=<span class="number">2</span>); <span class="comment">//本原子操作必須完成才能执行之后所有的读原子操作</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a.load(memory_order_relaxed) &lt;&lt; <span class="built_in">endl</span>: <span class="comment">//1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(Thread1, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(Thread2, <span class="number">0</span>)</span></span>;</span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一是<code>b.store</code>采用了<code>memory_order_release</code>内存顺序，这保证了本原子操作前所有的写原子操作必完成，也即<code>a.store</code>作必发生于<code>b.store</code>之前。二是<code>b.load</code>采用了<code>memory_order_acquire</code>作为内存顺序，这保证了本原子操作必须完成才能执行之后所有的读原子操作。即<code>b.load</code>必须发生在<code>a.load</code>操作之前。这样一来，通过确立“先于发生”关系的，我们就完全保证了代码运行的正确性，即当<code>b</code>的值为2的时候，<code>a</code>的值也确定地为1。而打印语句也不会在自旋等待之前打印<code>a</code>的值。</p>
<p>通常情况下，“先于发生”关系总是传递的，比如原子操作A发生于原子操作B之前而原子操作B又发生于原子操作C之前的话，则A一定发生于C之前。有了这样的顺序就可以指导编译器在重排序指令的时候在不破坏依赖规则(相当于多给了一些依赖关系)的情况下，仅在适当的位置插入内存栅栏，以保证执行指令时数据执行正确的同时获得最佳的运行性能。</p>
<p>形如其名，<code>memory_order_release</code>和<code>memory_order_consume</code>的配合会建立关于原子类程的“生产者消费者”的同步顺序。同样的，我们可以称之为 release- consume内存顺序。顺序一致、松散、release-acquire和release-consume通常是最为典型的4种内存顺序。其他的如<code>memory_order_acq_rel</code>，则是常用于实现一种叫做CAS( compare and swap)的基本同步元语，对应到<code>atomic</code>的原子操作<code>compare_exchange_strong</code>成员函数上。我们也称之为acquire-release内存顺序。</p>
<h2 id="线程局部存储"><a href="#线程局部存储" class="headerlink" title="线程局部存储"></a>线程局部存储</h2><p>线程局部存储(TLS, thread local storage)是一个已有的概念。简单地说，所谓线程局部存储变量，就是拥有线程生命期及线程可见性的变量。</p>
<p>线程局部存储实际上是由单线程程序中的全局/静态变量被应用到多线程程序中被线程共享而来。通常情况下，线程会拥有自己的栈空间，但是堆空间、静态数据区(如果从可执行文件的角度来看，静态数据区对应的是可执行文件的daa、bss段的数据，而从CC++语言层面而言，则对应的是全局/静态量)则是共享的。这样一来，全局、静态变量在这种多线程模型下就总是在线程间共享的。多全局、静态变量的共享虽然会带来一些好处，尤其对一些资源性的变量(比如文件句柄)来说也是应该的，不过并不是所有的全局、静态变量都适合在多线程的情况下共享。</p>
<p>各个编译器公司都有自己的TLS标准。我们在g++/clang++/xlc++中可以看到如下的语法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__thread <span class="keyword">int</span> errCode;</span><br></pre></td></tr></table></figure></p>
<p>在全局或者静态变量的声明中加上关键字<code>__thread</code>，即可将变量声明为TLS变量。每个线程将拥有独立的<code>errcode</code>的拷贝，一个线程中对<code>errcode</code>的读写并不会影响另外一个线程中的<code>errcode</code>的数据。C++11对TLS标准做出了一些统一的规定。与<code>__thread</code>修饰符类似，声明一个TLS变量的语法很简单，即通过<code>thread_local</code>修饰符声明变量即可：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="keyword">thread_local</span> errCode;</span><br></pre></td></tr></table></figure></p>
<p>一旦声明一个变量为<code>thread_local</code>，其值将在线程开始时被初始化，而在线程结束时，该值也将不再有效。对于<code>thread_local</code>变量地址取值(&amp;)，也只可以获得当前线程中的TLS变量的地址值。</p>
<h2 id="快速退出：quick-exit与at-quick-exit"><a href="#快速退出：quick-exit与at-quick-exit" class="headerlink" title="快速退出：quick_exit与at_quick_exit"></a>快速退出：quick_exit与at_quick_exit</h2><p>首先我们可以看看<code>terminate</code>函数，没有被捕捉的异常就会导致<code>terminate</code>函数的调用。<code>terminate</code>函数在默认情况下，是去调用<code>abort</code>，不过用户可以通过<code>set_terminate</code>函数来改変要认的行为。</p>
<p>源自于C中的<code>abort</code>则更加低层。<code>abort</code>函数不会调用任何的析构函数，默认情况下，它会向合乎POSIX标准的系统抛出一个信号(signal)：<code>SIGABRT</code>。相比而言，<code>exit</code>这样的属于“正常退出”范畴的程序终止，则不太可能有以上的问题。<code>exit</code>函数会正常调用自动变量的析构函数，并且还会调用<code>atexit</code>注册的函数。</p>
<p>在C++11中，标准引入了<code>quick_exit</code>函数，该函数并不执行析构函数而只是使程序终止。与 abort不同的是，abor的结果通常是异常退出(可能系统还会进行 coredump等以辅助程序员进行问题分析)，而<code>quick_exit</code>与<code>exit</code>同属于正常退出。此外，使用<code>at_quick_exit</code>注册的函数也可以在<code>quick_exit</code>的时候被调用。这样一来，我们同样可以像<code>exit</code>一样做一些清理的工作。在C++11标准中， <code>at_quick_exit</code>和<code>at_exit</code>一样，标准要求编译器至少支持32个注册函数的调用。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span> ~A() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Destruct A."</span> &lt;&lt; <span class="built_in">endl</span>; &#125; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">closedevice</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"device is closed. "</span>&lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    at_quick_exit(closedevice);</span><br><span class="line">    quick_exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/C/" rel="tag"># C++</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/08/06/深入理解cpp11 笔记1/" rel="next" title="深入理解C++11：C++11新特性解析与应用 笔记1">
                <i class="fa fa-chevron-left"></i> 深入理解C++11：C++11新特性解析与应用 笔记1
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/08/15/深入理解cpp11 笔记3/" rel="prev" title="深入理解C++11：C++11新特性解析与应用 笔记3">
                深入理解C++11：C++11新特性解析与应用 笔记3 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/header.jpg" alt="Hao Yu">
            
              <p class="site-author-name" itemprop="name">Hao Yu</p>
              <p class="site-description motion-element" itemprop="description">Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author</p>
          </div>
          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">340</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>
        	<audio controls="controls" loop="loop" preload="auto" src="/resource/xiaomeihao.mp3">
	        </audio>
	

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yuhao0102" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:yuh18@mails.tsinghua.edu.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#新手易学，老兵易用"><span class="nav-number">1.</span> <span class="nav-text">新手易学，老兵易用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#右尖括号-gt-的改进"><span class="nav-number">1.1.</span> <span class="nav-text">右尖括号&gt;的改进</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#auto类型推导"><span class="nav-number">1.2.</span> <span class="nav-text">auto类型推导</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#静态类型、动态类型与类型推导"><span class="nav-number">1.2.1.</span> <span class="nav-text">静态类型、动态类型与类型推导</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#auto的优势"><span class="nav-number">1.2.2.</span> <span class="nav-text">auto的优势</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#auto的使用细则"><span class="nav-number">1.2.3.</span> <span class="nav-text">auto的使用细则</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#decltype"><span class="nav-number">1.3.</span> <span class="nav-text">decltype</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#typeid与decltype"><span class="nav-number">1.3.1.</span> <span class="nav-text">typeid与decltype</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#decltype的应用"><span class="nav-number">1.3.2.</span> <span class="nav-text">decltype的应用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#decltype推导四规则"><span class="nav-number">1.3.3.</span> <span class="nav-text">decltype推导四规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cv限制符的继承与冗余的符号"><span class="nav-number">1.3.4.</span> <span class="nav-text">cv限制符的继承与冗余的符号</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#追踪返回类型"><span class="nav-number">1.4.</span> <span class="nav-text">追踪返回类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#追踪返回类型的引入"><span class="nav-number">1.4.1.</span> <span class="nav-text">追踪返回类型的引入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用追踪返回类型的函数"><span class="nav-number">1.4.2.</span> <span class="nav-text">使用追踪返回类型的函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基于范围的for循环"><span class="nav-number">1.5.</span> <span class="nav-text">基于范围的for循环</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#提高类型安全"><span class="nav-number">2.</span> <span class="nav-text">提高类型安全</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#强类型枚举"><span class="nav-number">2.1.</span> <span class="nav-text">强类型枚举</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#强类型枚举-1"><span class="nav-number">2.1.1.</span> <span class="nav-text">强类型枚举</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#堆内存管理"><span class="nav-number">2.2.</span> <span class="nav-text">堆内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#显式内存管理"><span class="nav-number">2.2.1.</span> <span class="nav-text">显式内存管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-11的智能指针"><span class="nav-number">2.2.2.</span> <span class="nav-text">C++11的智能指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#垃圾回收的分类"><span class="nav-number">2.2.3.</span> <span class="nav-text">垃圾回收的分类</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#提高性能及操作硬件的能力"><span class="nav-number">3.</span> <span class="nav-text">提高性能及操作硬件的能力</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#常量表达式"><span class="nav-number">3.1.</span> <span class="nav-text">常量表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#运行时常量性与编译时常量性"><span class="nav-number">3.1.1.</span> <span class="nav-text">运行时常量性与编译时常量性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常量表达式函数"><span class="nav-number">3.1.2.</span> <span class="nav-text">常量表达式函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常量表达式值"><span class="nav-number">3.1.3.</span> <span class="nav-text">常量表达式值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常量表达式的其他应用"><span class="nav-number">3.1.4.</span> <span class="nav-text">常量表达式的其他应用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#变长模板"><span class="nav-number">3.2.</span> <span class="nav-text">变长模板</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#变长函数和变长的模板参数"><span class="nav-number">3.2.1.</span> <span class="nav-text">变长函数和变长的模板参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#変长模板：模板参数包和函数参数包"><span class="nav-number">3.2.2.</span> <span class="nav-text">変长模板：模板参数包和函数参数包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#变长模板：进阶"><span class="nav-number">3.2.3.</span> <span class="nav-text">变长模板：进阶</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#原子类型与原子操作"><span class="nav-number">3.3.</span> <span class="nav-text">原子类型与原子操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#原子操作与C-11原子类型"><span class="nav-number">3.3.1.</span> <span class="nav-text">原子操作与C++11原子类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内存模型，顺序一致性与memory-order"><span class="nav-number">3.3.2.</span> <span class="nav-text">内存模型，顺序一致性与memory order</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程局部存储"><span class="nav-number">3.4.</span> <span class="nav-text">线程局部存储</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#快速退出：quick-exit与at-quick-exit"><span class="nav-number">3.5.</span> <span class="nav-text">快速退出：quick_exit与at_quick_exit</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>
  <div id="DvelopmentTarget">     
  </div>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart" aria-hidden="false"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>

  
</div>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_uv"> 
  本站访客数<span id="busuanzi_value_site_uv"></span>人次
</span>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  


  <script type="text/javascript" src="/js/src/love.js"></script>

</body>
</html>
