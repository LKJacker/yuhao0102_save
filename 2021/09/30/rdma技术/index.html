<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zn-ch">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-center-simple.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="积累,">










<meta name="description" content="DMA和RDMA概念DMADMA(直接内存访问)是一种能力，允许在计算机主板上的设备直接把数据发送到内存中去，数据搬运不需要CPU的参与。 传统内存访问需要通过CPU进行数据copy来移动数据，通过CPU将内存中的Buffer1移动到Buffer2中。DMA模式：可以同DMA Engine之间通过硬件将数据从Buffer1移动到Buffer2,而不需要操作系统CPU的参与，大大降低了CPU Cop">
<meta name="keywords" content="积累">
<meta property="og:type" content="article">
<meta property="og:title" content="RDMA技术详解">
<meta property="og:url" content="http://yoursite.com/2021/09/30/rdma技术/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="DMA和RDMA概念DMADMA(直接内存访问)是一种能力，允许在计算机主板上的设备直接把数据发送到内存中去，数据搬运不需要CPU的参与。 传统内存访问需要通过CPU进行数据copy来移动数据，通过CPU将内存中的Buffer1移动到Buffer2中。DMA模式：可以同DMA Engine之间通过硬件将数据从Buffer1移动到Buffer2,而不需要操作系统CPU的参与，大大降低了CPU Cop">
<meta property="og:locale" content="zn-ch">
<meta property="og:image" content="http://yoursite.com/img/v2-d359453c9269146cd93de5eed43993c8_720w.jpg">
<meta property="og:image" content="http://yoursite.com/img/v2-f081e8fce13d8b00e5a786399d20ca06_720w.jpg">
<meta property="og:image" content="http://yoursite.com/img/v2-2ec811510b13787ec81a3490e4233f60_720w.jpg">
<meta property="og:image" content="http://yoursite.com/img/v2-e854577d2b1fb56889c95d76999d6583_720w.jpg">
<meta property="og:image" content="http://yoursite.com/img/v2-ea7615096a651042d6ff0758d85ad698_720w.jpg">
<meta property="og:image" content="http://yoursite.com/img/v2-f434f07e79221b59cd82e731cd62285d_720w.jpg">
<meta property="og:image" content="http://yoursite.com/img/v2-55fa92d979172cd69a027a1401f535c2_720w.jpg">
<meta property="og:image" content="http://yoursite.com/img/v2-1282960e29ec7042ffec89dcc4f5577e_720w.jpg">
<meta property="og:image" content="http://yoursite.com/img/v2-9dcb687ffaee99730313270214b327e6_720w.jpg">
<meta property="og:image" content="http://yoursite.com/img/v2-397f08428eaee59f9908dcb0ea2b1b56_720w.jpg">
<meta property="og:image" content="http://yoursite.com/img/v2-a45f31b55c22ca8aad8a139be0eb8d99_720w.jpg">
<meta property="og:image" content="http://yoursite.com/img/v2-4e72a802e022d5742de169921c185cd8_720w.jpg">
<meta property="og:image" content="http://yoursite.com/img/v2-dec6f454affdc07019b8729c6c13fc96_720w.jpg">
<meta property="og:updated_time" content="2021-10-04T07:23:48.883Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="RDMA技术详解">
<meta name="twitter:description" content="DMA和RDMA概念DMADMA(直接内存访问)是一种能力，允许在计算机主板上的设备直接把数据发送到内存中去，数据搬运不需要CPU的参与。 传统内存访问需要通过CPU进行数据copy来移动数据，通过CPU将内存中的Buffer1移动到Buffer2中。DMA模式：可以同DMA Engine之间通过硬件将数据从Buffer1移动到Buffer2,而不需要操作系统CPU的参与，大大降低了CPU Cop">
<meta name="twitter:image" content="http://yoursite.com/img/v2-d359453c9269146cd93de5eed43993c8_720w.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2021/09/30/rdma技术/">





  <title>RDMA技术详解 | Hao Yu's blog</title>
  








 
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zn-ch">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hao Yu's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">The program monkey was eaten by the siege lion.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/resume.pdf" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-mybetterhalf">
          <a href="/mybetterhalf/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>
            
            mybetterhalf
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/09/30/rdma技术/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">RDMA技术详解</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-09-30T09:38:00+08:00">
                2021-09-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="DMA和RDMA概念"><a href="#DMA和RDMA概念" class="headerlink" title="DMA和RDMA概念"></a>DMA和RDMA概念</h1><h2 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h2><p>DMA(直接内存访问)是一种能力，允许在计算机主板上的设备直接把数据发送到内存中去，数据搬运不需要CPU的参与。</p>
<p>传统内存访问需要通过CPU进行数据copy来移动数据，通过CPU将内存中的Buffer1移动到Buffer2中。DMA模式：可以同DMA Engine之间通过硬件将数据从Buffer1移动到Buffer2,而不需要操作系统CPU的参与，大大降低了CPU Copy的开销。</p>
<p><img src="/img/v2-d359453c9269146cd93de5eed43993c8_720w.jpg" alt></p>
<h2 id="RDMA"><a href="#RDMA" class="headerlink" title="RDMA"></a>RDMA</h2><p>RDMA是一种概念，在两个或者多个计算机进行通讯的时候使用DMA， 从一个主机的内存直接访问另一个主机的内存。</p>
<p><img src="/img/v2-f081e8fce13d8b00e5a786399d20ca06_720w.jpg" alt></p>
<p>RDMA是一种host-offload, host-bypass技术，允许应用程序(包括存储)在它们的内存空间之间直接做数据传输。具有RDMA引擎的以太网卡(RNIC)—而不是host—负责管理源和目标之间的可靠连接。使用RNIC的应用程序之间使用专注的QP和CQ进行通讯：</p>
<ul>
<li>每一个应用程序可以有很多QP和CQ</li>
<li>每一个QP包括一个SQ和RQ</li>
<li>每一个CQ可以跟多个SQ或者RQ相关联</li>
</ul>
<p><img src="/img/v2-2ec811510b13787ec81a3490e4233f60_720w.jpg" alt></p>
<h2 id="RDMA的优势"><a href="#RDMA的优势" class="headerlink" title="RDMA的优势"></a>RDMA的优势</h2><p>传统的TCP/IP技术在数据包处理过程中，要经过操作系统及其他软件层，需要占用大量的服务器资源和内存总线带宽，数据在系统内存、处理器缓存和网络控制器缓存之间来回进行复制移动，给服务器的CPU和内存造成了沉重负担。尤其是网络带宽、处理器速度与内存带宽三者的严重”不匹配性”，更加剧了网络延迟效应。</p>
<p>RDMA是一种新的直接内存访问技术，RDMA让计算机可以直接存取其他计算机的内存，而不需要经过处理器的处理。RDMA将数据从一个系统快速移动到远程系统的内存中，而不对操作系统造成任何影响。</p>
<p>在实现上，RDMA实际上是一种智能网卡与软件架构充分优化的远端内存直接高速访问技术，通过将RDMA协议固化于硬件(即网卡)上，以及支持Zero-copy和Kernel bypass这两种途径来达到其高性能的远程直接数据存取的目标。 使用RDMA的优势如下：</p>
<ul>
<li>零拷贝(Zero-copy) - 应用程序能够直接执行数据传输，在不涉及到网络软件栈的情况下。数据能够被直接发送到缓冲区或者能够直接从缓冲区里接收，而不需要被复制到网络层。</li>
<li>内核旁路(Kernel bypass) - 应用程序可以直接在用户态执行数据传输，不需要在内核态与用户态之间做上下文切换。</li>
<li>不需要CPU干预(No CPU involvement) - 应用程序可以访问远程主机内存而不消耗远程主机中的任何CPU。远程主机内存能够被读取而不需要远程主机上的进程（或CPU)参与。远程主机的CPU的缓存(cache)不会被访问的内存内容所填充。</li>
<li>消息基于事务(Message based transactions) - 数据被处理为离散消息而不是流，消除了应用程序将流切割为不同消息/事务的需求。</li>
<li>支持分散/聚合条目(Scatter/gather entries support) - RDMA原生态支持分散/聚合。也就是说，读取多个内存缓冲区然后作为一个流发出去或者接收一个流然后写入到多个内存缓冲区里去。</li>
</ul>
<p>在具体的远程内存读写中，RDMA操作用于读写操作的远程虚拟内存地址包含在RDMA消息中传送，远程应用程序要做的只是在其本地网卡中注册相应的内存缓冲区。远程节点的CPU除在连接建立、注册调用等之外，在整个RDMA数据传输过程中并不提供服务，因此没有带来任何负载。</p>
<h2 id="RDMA-三种不同的硬件实现"><a href="#RDMA-三种不同的硬件实现" class="headerlink" title="RDMA 三种不同的硬件实现"></a>RDMA 三种不同的硬件实现</h2><p>RDMA作为一种host-offload, host-bypass技术，使低延迟、高带宽的直接的内存到内存的数据通信成为了可能。目前支持RDMA的网络协议有：</p>
<ol>
<li>InfiniBand(IB): 从一开始就支持RDMA的新一代网络协议。由于这是一种新的网络技术，因此需要支持该技术的网卡和交换机。</li>
<li>RDMA过融合以太网(RoCE): 即RDMA over Ethernet, 允许通过以太网执行RDMA的网络协议。这允许在标准以太网基础架构(交换机)上使用RDMA，只不过网卡必须是支持RoCE的特殊的NIC。</li>
<li>互联网广域RDMA协议(iWARP): 即RDMA over TCP, 允许通过TCP执行RDMA的网络协议。这允许在标准以太网基础架构(交换机)上使用RDMA，只不过网卡要求是支持iWARP(如果使用CPU offload的话)的NIC。否则，所有iWARP栈都可以在软件中实现，但是失去了大部分的RDMA性能优势。</li>
</ol>
<p><img src="/img/v2-e854577d2b1fb56889c95d76999d6583_720w.jpg" alt></p>
<p>在三种主流的RDMA技术中，可以划分为两大阵营。一个是IB技术, 另一个是支持RDMA的以太网技术(RoCE和iWARP)。其中, IBTA力挺的技术自然是IB和RoCE, Mellanox公司（一个以色列人搞的小公司）是这方面的急先锋。而iWARP则是IEEE/IETF力挺的技术，主要是Chelsio公司在推进。RoCE和iWARP的争论，请参考Mellanox和Chelsio这两家公司发布的白皮书。</p>
<p>在存储领域，支持RDMA的技术早就存在，比如SRP(SCSI RDMA Protocol)和iSER(iSCSI Extensions for RDMA)。 如今兴起的NVMe over Fabrics如果使用的不是FC网络的话，本质上就是NVMe over RDMA。 换句话说，NVMe over InfiniBand, NVMe over RoCE和NVMe over iWARP都是NVMe over RDMA。</p>
<h2 id="RDMA基本术语"><a href="#RDMA基本术语" class="headerlink" title="RDMA基本术语"></a>RDMA基本术语</h2><h3 id="Fabric"><a href="#Fabric" class="headerlink" title="Fabric"></a>Fabric</h3><p>A local-area RDMA network is usually referred to as a fabric.所谓Fabric，就是支持RDMA的局域网(LAN)。</p>
<h3 id="CA-Channel-Adapter"><a href="#CA-Channel-Adapter" class="headerlink" title="CA(Channel Adapter)"></a>CA(Channel Adapter)</h3><p>A channel adapter is the hardware component that connects a system to the fabric.</p>
<p>CA是Channel Adapter(通道适配器)的缩写。那么，CA就是将系统连接到Fabric的硬件组件。 在IBTA中，一个CA就是IB子网中的一个终端结点(End Node)。分为两种类型，一种是HCA, 另一种叫做TCA, 它们合称为xCA。其中， HCA(Host Channel Adapter)是支持”verbs”接口的CA, TCA(Target Channel Adapter)可以理解为”weak CA”, 不需要像HCA一样支持很多功能。 而在IEEE/IETF中，CA的概念被实体化为RNIC（RDMA Network Interface Card）, iWARP就把一个CA称之为一个RNIC。</p>
<p>简言之，在IBTA阵营中，CA即HCA或TCA； 而在iWARP阵营中，CA就是RNIC。 总之，无论是HCA、 TCA还是RNIC，它们都是CA, 它们的基本功能本质上都是生产或消费数据包(packet)</p>
<h3 id="Verbs"><a href="#Verbs" class="headerlink" title="Verbs"></a>Verbs</h3><p>在RDMA的持续演进中，有一个组织叫做OpenFabric Alliance所做的贡献可谓功不可没。 Verbs这个词不好翻译，大致可以理解为访问RDMA硬件的“一组标准动作”。 每一个Verb可以理解为一个Function。</p>
<h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><h3 id="Memory-Registration-MR-内存注册"><a href="#Memory-Registration-MR-内存注册" class="headerlink" title="Memory Registration(MR) | 内存注册"></a>Memory Registration(MR) | 内存注册</h3><p>RDMA 就是用来对内存进行数据传输。那么怎样才能对内存进行传输，很简单，注册。 因为RDMA硬件对用来做数据传输的内存是有特殊要求的。</p>
<ul>
<li>在数据传输过程中，应用程序不能修改数据所在的内存。</li>
<li>操作系统不能对数据所在的内存进行page out操作 — 物理地址和虚拟地址的映射必须是固定不变的。</li>
</ul>
<p>注意无论是DMA或者RDMA都要求物理地址连续，这是由DMA引擎所决定的。 那么怎么进行内存注册呢？</p>
<ul>
<li>创建两个key (local和remote)指向需要操作的内存区域</li>
<li>注册的keys是数据传输请求的一部分</li>
</ul>
<p>注册一个Memory Region之后，这个时候这个Memory Region也就有了它自己的属性：</p>
<ul>
<li>context : RDMA操作上下文</li>
<li>addr : MR被注册的Buffer地址</li>
<li>length : MR被注册的Buffer长度</li>
<li>lkey：MR被注册的本地key</li>
<li>rkey：MR被注册的远程key</li>
</ul>
<p>对Memrory Registration：Memory Registration只是RDMA中对内存保护的一种措施，只有将要操作的内存注册到RDMA Memory Region中，这快操作的内存就交给RDMA 保护域来操作了。这个时候我们就可以对这快内存进行操作，至于操作的起始地址、操作Buffer的长度，可以根据程序的具体需求进行操作。我们只要保证接受方的Buffer 接受的长度大于等于发送的Buffer长度。</p>
<h3 id="Queues-队列"><a href="#Queues-队列" class="headerlink" title="Queues | 队列"></a>Queues | 队列</h3><p>RDMA一共支持三种队列，发送队列(SQ)和接收队列(RQ)，完成队列(CQ)。其中，SQ和RQ通常成对创建，被称为Queue Pairs(QP)。</p>
<p>RDMA是基于消息的传输协议，数据传输都是异步操作。 RDMA操作其实很简单，可以理解为：</p>
<ul>
<li>Host提交工作请求(WR)到工作队列(WQ): 工作队列包括发送队列(SQ)和接收队列(RQ)。工作队列的每一个元素叫做WQE, 也就是WR。</li>
<li>Host从完成队列(CQ）中获取工作完成(WC): 完成队列里的每一个叫做CQE, 也就是WC。</li>
<li>具有RDMA引擎的硬件(hardware)就是一个队列元素处理器。 RDMA硬件不断地从工作队列(WQ)中去取工作请求(WR)来执行，执行完了就给完成队列(CQ)中放置工作完成(WC)。从生产者-消费者的角度理解就是：</li>
<li>Host生产WR, 把WR放到WQ中去</li>
<li>RDMA硬件消费WR</li>
<li>RDMA硬件生产WC, 把WC放到CQ中去</li>
<li>Host消费WC</li>
</ul>
<p><img src="/img/v2-ea7615096a651042d6ff0758d85ad698_720w.jpg" alt></p>
<h2 id="RDMA数据传输"><a href="#RDMA数据传输" class="headerlink" title="RDMA数据传输"></a>RDMA数据传输</h2><h3 id="RDMA-Send-RDMA发送-接收-操作-（Send-Recv）"><a href="#RDMA-Send-RDMA发送-接收-操作-（Send-Recv）" class="headerlink" title="RDMA Send | RDMA发送(/接收)操作 （Send/Recv）"></a>RDMA Send | RDMA发送(/接收)操作 （Send/Recv）</h3><p>跟TCP/IP的send/recv是类似的，不同的是RDMA是基于消息的数据传输协议（而不是基于字节流的传输协议），所有数据包的组装都在RDMA硬件上完成的，也就是说OSI模型中的下面4层(传输层，网络层，数据链路层，物理层)都在RDMA硬件上完成。</p>
<h3 id="RDMA-Read-RDMA读操作-Pull"><a href="#RDMA-Read-RDMA读操作-Pull" class="headerlink" title="RDMA Read | RDMA读操作 (Pull)"></a>RDMA Read | RDMA读操作 (Pull)</h3><p>RDMA读操作本质上就是Pull操作, 把远程系统内存里的数据拉回到本地系统的内存里。</p>
<h3 id="RDMA-Write-RDMA写操作-Push"><a href="#RDMA-Write-RDMA写操作-Push" class="headerlink" title="RDMA Write | RDMA写操作 (Push)"></a>RDMA Write | RDMA写操作 (Push)</h3><p>RDMA写操作本质上就是Push操作，把本地系统内存里的数据推送到远程系统的内存里。</p>
<h3 id="RDMA-Write-with-Immediate-Data-支持立即数的RDMA写操作"><a href="#RDMA-Write-with-Immediate-Data-支持立即数的RDMA写操作" class="headerlink" title="RDMA Write with Immediate Data | 支持立即数的RDMA写操作"></a>RDMA Write with Immediate Data | 支持立即数的RDMA写操作</h3><p>支持立即数的RDMA写操作本质上就是给远程系统Push(推送)带外(OOB)数据, 这跟TCP里的带外数据是类似的。</p>
<p>可选地，immediate 4字节值可以与数据缓冲器一起发送。 该值作为接收通知的一部分呈现给接收者，并且不包含在数据缓冲器中。</p>
<h1 id="RDMA-Send-Receive操作"><a href="#RDMA-Send-Receive操作" class="headerlink" title="RDMA Send Receive操作"></a>RDMA Send Receive操作</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>RDMA指的是远程直接内存访问，这是一种通过网络在两个应用程序之间搬运缓冲区里的数据的方法。RDMA与传统的网络接口不同，因为它绕过了操作系统。这允许实现了RDMA的程序具有如下特点：</p>
<ul>
<li>绝对的最低时延</li>
<li>最高的吞吐量</li>
<li>最小的CPU足迹 （也就是说，需要CPU参与的地方被最小化）</li>
</ul>
<h2 id="RDMA-Verbs操作"><a href="#RDMA-Verbs操作" class="headerlink" title="RDMA Verbs操作"></a>RDMA Verbs操作</h2><p>使用RDMA, 我们需要有一张实现了RDMA引擎的网卡。我们把这种卡称之为HCA(主机通道适配器)。 适配器创建一个贯穿PCIe总线的从RDMA引擎到应用程序内存的通道。一个好的HCA将在导线上执行的RDMA协议所需要的全部逻辑都在硬件上予以实现。这包括分组，重组以及流量控制和可靠性保证。因此，从应用程序的角度看，只负责处理所有缓冲区即可。</p>
<p><img src="/img/v2-f434f07e79221b59cd82e731cd62285d_720w.jpg" alt></p>
<p>在RDMA中我们使用内核态驱动建立一个数据通道。我们称之为命令通道（Command Channel）。使用命令通道，我们能够建立一个数据通道（Data Channel），该通道允许我们在搬运数据的时候完全绕过内核。一旦建立了这种数据通道，我们就能直接读写数据缓冲区。</p>
<p>建立数据通道的API是一种称之为”verbs”的API。”verbs” API是由一个叫做OFED的Linux开源项目维护的。在站点<a href="http://www.openfabrics.org上，为Windows" target="_blank" rel="noopener">http://www.openfabrics.org上，为Windows</a> WinOF提供了一个等价的项目。”verbs” API跟你用过的socket编程API是不一样的。但是，一旦你掌握了一些概念后，就会变得非常容易，而且在设计你的程序的时候更简单。</p>
<h2 id="Queue-Pairs"><a href="#Queue-Pairs" class="headerlink" title="Queue Pairs"></a>Queue Pairs</h2><p>RDMA操作开始于“搞”内存。当你在对内存进行操作的时候，就是告诉内核这段内存名花有主了，主人就是你的应用程序。于是，你告诉HCA，就在这段内存上寻址，赶紧准备开辟一条从HCA卡到这段内存的通道。我们将这一动作称之为注册一个内存区域(MR)。一旦MR注册完毕，我们就可以使用这段内存来做任何RDMA操作。在下面的图中，我们可以看到注册的内存区域(MR)和被通信队列所使用的位于内存区域之内的缓冲区(buffer)。</p>
<p>RDMA Memory Registration<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ibv_mr</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ibv_context</span>     *<span class="title">context</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ibv_pd</span>          *<span class="title">pd</span>;</span></span><br><span class="line">    <span class="keyword">void</span>                   *addr;</span><br><span class="line">    <span class="keyword">size_t</span>                  length;</span><br><span class="line">    <span class="keyword">uint32_t</span>                handle;</span><br><span class="line">    <span class="keyword">uint32_t</span>                lkey;</span><br><span class="line">    <span class="keyword">uint32_t</span>                rkey;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/v2-55fa92d979172cd69a027a1401f535c2_720w.jpg" alt></p>
<p>RDMA硬件不断地从工作队列(WQ)中去取工作请求(WR)来执行，执行完了就给完成队列(CQ)中放置工作完成通知(WC)。这个WC意思就是Work Completion。表示这个WR RDMA请求已经被处理完成，可以从这个Completion Queue从取出来，表示这个RDMA请求已经被处理完毕。</p>
<p>RDMA通信基于三条队列(SQ, RQ和CQ)组成的集合。 其中， 发送队列(SQ)和接收队列(RQ)负责调度工作，他们总是成对被创建，称之为队列对(QP)。当放置在工作队列上的指令被完成的时候，完成队列(CQ)用来发送通知。</p>
<p>当用户把指令放置到工作队列的时候，就意味着告诉HCA那些缓冲区需要被发送或者用来接受数据。这些指令是一些小的结构体，称之为工作请求(WR)或者工作队列元素(WQE)。 WQE的发音为”WOOKIE”，就像星球大战里的猛兽。一个WQE主要包含一个指向某个缓冲区的指针。一个放置在发送队列（SQ）里的WQE中包含一个指向待发送的消息的指针。一个放置在接受队列里的WQE里的指针指向一段缓冲区，该缓冲区用来存放待接受的消息。</p>
<p>下面我们来看一下RDMA中的Work Request（SendWR和ReceWR）</p>
<p>RDMA Send Work Request请求<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ibv_send_wr</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span>                wr_id;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ibv_send_wr</span>     *<span class="title">next</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ibv_sge</span>         *<span class="title">sg_list</span>;</span></span><br><span class="line">    <span class="keyword">int</span>                     num_sge;</span><br><span class="line">    <span class="keyword">enum</span> ibv_wr_opcode      opcode;</span><br><span class="line">    <span class="keyword">int</span>                     send_flags;</span><br><span class="line">    <span class="keyword">uint32_t</span>                imm_data;       <span class="comment">/* in network byte order */</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">                    <span class="keyword">uint64_t</span>        remote_addr;</span><br><span class="line">                    <span class="keyword">uint32_t</span>        rkey;</span><br><span class="line">            &#125; rdma;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">                    <span class="keyword">uint64_t</span>        remote_addr;</span><br><span class="line">                    <span class="keyword">uint64_t</span>        compare_add;</span><br><span class="line">                    <span class="keyword">uint64_t</span>        swap;</span><br><span class="line">                    <span class="keyword">uint32_t</span>        rkey;</span><br><span class="line">            &#125; atomic;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">                    <span class="class"><span class="keyword">struct</span> <span class="title">ibv_ah</span>  *<span class="title">ah</span>;</span></span><br><span class="line">                    <span class="keyword">uint32_t</span>        remote_qpn;</span><br><span class="line">                    <span class="keyword">uint32_t</span>        remote_qkey;</span><br><span class="line">            &#125; ud;</span><br><span class="line">    &#125; wr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>RDMA Receive Work Request请求<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ibv_recv_wr</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span>                wr_id;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ibv_recv_wr</span>     *<span class="title">next</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ibv_sge</span>         *<span class="title">sg_list</span>;</span></span><br><span class="line">    <span class="keyword">int</span>                     num_sge;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>RDMA是一种异步传输机制。因此我们可以一次性在工作队列里放置好多个发送或接收WQE。HCA将尽可能快地按顺序处理这些WQE。当一个WQE被处理了，那么数据就被搬运了。 一旦传输完成，HCA就创建一个完成队列元素(CQE)并放置到完成队列(CQ)中去。 相应地，CQE的发音为”COOKIE”。</p>
<p>RDMA Complete Queue Element<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ibv_wc</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> wr_id; </span><br><span class="line">    <span class="keyword">enum</span> ibv_wc_status status; </span><br><span class="line">    <span class="keyword">enum</span> ibv_wc_opcode opcode; </span><br><span class="line">    <span class="keyword">uint32_t</span> vendor_err; </span><br><span class="line">    <span class="keyword">uint32_t</span> byte_len; </span><br><span class="line">    <span class="keyword">uint32_t</span> imm_data; <span class="comment">/* in network byte order */</span> </span><br><span class="line">    <span class="keyword">uint32_t</span> qp_num; </span><br><span class="line">    <span class="keyword">uint32_t</span> src_qp; </span><br><span class="line">    <span class="keyword">int</span> wc_flags; </span><br><span class="line">    <span class="keyword">uint16_t</span> pkey_index; </span><br><span class="line">    <span class="keyword">uint16_t</span> slid; </span><br><span class="line">    <span class="keyword">uint8_t</span> sl; </span><br><span class="line">    <span class="keyword">uint8_t</span> dlid_path_bits; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="RDMA-Send-Receive"><a href="#RDMA-Send-Receive" class="headerlink" title="RDMA Send/Receive"></a>RDMA Send/Receive</h2><p>让我们看个简单的例子。在这个例子中，我们将把一个缓冲区里的数据从系统A的内存中搬到系统B的内存中去。这就是我们所说的消息传递语义学。接下来我们要讲的一种操作为SEND，是RDMA中最基础的操作类型。</p>
<h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><p>第1步：系统A和B都创建了他们各自的QP的完成队列(CQ), 并为即将进行的RDMA传输注册了相应的内存区域(MR)。 系统A识别了一段缓冲区，该缓冲区的数据将被搬运到系统B上。系统B分配了一段空的缓冲区，用来存放来自系统A发送的数据。<br><img src="/img/v2-1282960e29ec7042ffec89dcc4f5577e_720w.jpg" alt></p>
<h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h3><p>第二步：系统B创建一个WQE并放置到它的接收队列(RQ)中。这个WQE包含了一个指针，该指针指向的内存缓冲区用来存放接收到的数据。系统A也创建一个WQE并放置到它的发送队列(SQ)中去，该WQE中的指针执行一段内存缓冲区，该缓冲区的数据将要被传送。<br><img src="/img/v2-9dcb687ffaee99730313270214b327e6_720w.jpg" alt></p>
<h3 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h3><p>第三步：系统A上的HCA总是在硬件上干活，看看发送队列里有没有WQE。HCA将消费掉来自系统A的WQE, 然后将内存区域里的数据变成数据流发送给系统B。当数据流开始到达系统B的时候，系统B上的HCA就消费来自系统B的WQE，然后将数据放到该放的缓冲区上去。在高速通道上传输的数据流完全绕过了操作系统内核。<br><img src="/img/v2-397f08428eaee59f9908dcb0ea2b1b56_720w.jpg" alt></p>
<h3 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h3><p>第四步：当数据搬运完成的时候，HCA会创建一个CQE。 这个CQE被放置到完成队列(CQ)中，表明数据传输已经完成。HCA每消费掉一个WQE, 都会生成一个CQE。因此，在系统A的完成队列中放置一个CQE,意味着对应的WQE的发送操作已经完成。同理，在系统B的完成队列中也会放置一个CQE，表明对应的WQE的接收操作已经完成。如果发生错误，HCA依然会创建一个CQE。在CQE中，包含了一个用来记录传输状态的字段。</p>
<p>我们刚刚举例说明的是一个RDMA Send操作。在IB或RoCE中，传送一个小缓冲区里的数据耗费的总时间大约在1.3µs。通过同时创建很多WQE, 就能在1秒内传输存放在数百万个缓冲区里的数据。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在这博客中，我们学习了如何使用RDMA verbs API。同时也介绍了队列的概念，而队列概念是RDMA编程的基础。最后，我们演示了RDMA send操作，展现了缓冲区的数据是如何在从一个系统搬运到另一个系统上去的。</p>
<h1 id="理解RDMA-SGL"><a href="#理解RDMA-SGL" class="headerlink" title="理解RDMA SGL"></a>理解RDMA SGL</h1><h2 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h2><p>在使用RDMA操作之前，我们需要了解一些RDMA API中的一些需要的值。其中在ibv_send_wr我们需要一个sg_list的数组，sg_list是用来存放ibv_sge元素，那么什么是SGL以及什么是sge呢？对于一个使用RDMA进行开发的程序员来说，我们需要了解这一系列细节。</p>
<h2 id="SGE简介"><a href="#SGE简介" class="headerlink" title="SGE简介"></a>SGE简介</h2><p>在NVMe over PCIe中，I/O命令支持SGL(Scatter Gather List 分散聚合表)和PRP(Physical Region Page 物理(内存)区域页), 而管理命令只支持PRP;而在NVMe over Fabrics中，无论是管理命令还是I/O命令都只支持SGL。</p>
<p>RDMA编程中，SGL(Scatter/Gather List)是最基本的数据组织形式。 SGL是一个数组，该数组中的元素被称之为SGE(Scatter/Gather Element)，每一个SGE就是一个Data Segment(数据段)。RDMA支持Scatter/Gather操作，具体来讲就是RDMA可以支持一个连续的Buffer空间，进行Scatter分散到多个目的主机的不连续的Buffer空间。Gather指的就是多个不连续的Buffer空间，可以Gather到目的主机的一段连续的Buffer空间。</p>
<p>下面我们就来看一下ibv_sge的定义：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ibv_sge</span> &#123;</span></span><br><span class="line">        <span class="keyword">uint64_t</span>        addr;</span><br><span class="line">        <span class="keyword">uint32_t</span>        length;</span><br><span class="line">        <span class="keyword">uint32_t</span>        lkey;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>addr: 数据段所在的虚拟内存的起始地址 (Virtual Address of the Data Segment (i.e. Buffer))</li>
<li>length: 数据段长度(Length of the Data Segment)</li>
<li>lkey: 该数据段对应的L_Key (Key of the local Memory Region)</li>
</ul>
<h2 id="ivc-post-send接口"><a href="#ivc-post-send接口" class="headerlink" title="ivc_post_send接口"></a>ivc_post_send接口</h2><p>而在数据传输中，发送/接收使用的Verbs API为：</p>
<p>ibv_post_send() - post a list of work requests (WRs) to a send queue 将一个WR列表放置到发送队列中 ibv_post_recv() - post a list of work requests (WRs) to a receive queue 将一个WR列表放置到接收队列中<br>下面以ibv_post_send()为例，说明SGL是如何被放置到RDMA硬件的线缆(Wire)上的。</p>
<p><code>ibv_post_send()</code>的函数原型<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;infiniband/verbs.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ibv_post_send</span><span class="params">(struct ibv_qp *qp, </span></span></span><br><span class="line"><span class="function"><span class="params">                  struct ibv_send_wr *wr,</span></span></span><br><span class="line"><span class="function"><span class="params">                  struct ibv_send_wr **bad_wr)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p><code>ibv_post_send()</code>将以send_wr开头的工作请求（WR）的列表发布到Queue Pair的Send Queue。 它会在第一次失败时停止处理此列表中的WR（可以在发布请求时立即检测到），并通过bad_wr返回此失败的WR。</p>
<p>参数wr是一个ibv_send_wr结构，如中所定义。</p>
<h2 id="ibv-send-wr结构"><a href="#ibv-send-wr结构" class="headerlink" title="ibv_send_wr结构"></a>ibv_send_wr结构</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ibv_send_wr</span> &#123;</span></span><br><span class="line">        <span class="keyword">uint64_t</span>                wr_id;                  <span class="comment">/* User defined WR ID */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ibv_send_wr</span>     *<span class="title">next</span>;</span>                   <span class="comment">/* Pointer to next WR in list, NULL if last WR */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ibv_sge</span>         *<span class="title">sg_list</span>;</span>                <span class="comment">/* Pointer to the s/g array */</span></span><br><span class="line">        <span class="keyword">int</span>                     num_sge;                <span class="comment">/* Size of the s/g array */</span></span><br><span class="line">        <span class="keyword">enum</span> ibv_wr_opcode      opcode;                 <span class="comment">/* Operation type */</span></span><br><span class="line">        <span class="keyword">int</span>                     send_flags;             <span class="comment">/* Flags of the WR properties */</span></span><br><span class="line">        <span class="keyword">uint32_t</span>                imm_data;               <span class="comment">/* Immediate data (in network byte order) */</span></span><br><span class="line">        <span class="keyword">union</span> &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">                        <span class="keyword">uint64_t</span>        remote_addr;    <span class="comment">/* Start address of remote memory buffer */</span></span><br><span class="line">                        <span class="keyword">uint32_t</span>        rkey;           <span class="comment">/* Key of the remote Memory Region */</span></span><br><span class="line">                &#125; rdma;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">                        <span class="keyword">uint64_t</span>        remote_addr;    <span class="comment">/* Start address of remote memory buffer */</span></span><br><span class="line">                        <span class="keyword">uint64_t</span>        compare_add;    <span class="comment">/* Compare operand */</span></span><br><span class="line">                        <span class="keyword">uint64_t</span>        swap;           <span class="comment">/* Swap operand */</span></span><br><span class="line">                        <span class="keyword">uint32_t</span>        rkey;           <span class="comment">/* Key of the remote Memory Region */</span></span><br><span class="line">                &#125; atomic;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">                        <span class="class"><span class="keyword">struct</span> <span class="title">ibv_ah</span>  *<span class="title">ah</span>;</span>             <span class="comment">/* Address handle (AH) for the remote node address */</span></span><br><span class="line">                        <span class="keyword">uint32_t</span>        remote_qpn;     <span class="comment">/* QP number of the destination QP */</span></span><br><span class="line">                        <span class="keyword">uint32_t</span>        remote_qkey;    <span class="comment">/* Q_Key number of the destination QP */</span></span><br><span class="line">                &#125; ud;</span><br><span class="line">        &#125; wr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在调用<code>ibv_post_send()</code>之前，必须填充好数据结构wr。 wr是一个链表，每一个结点包含了一个sg_list(i.e. SGL: 由一个或多个SGE构成的数组), sg_list的长度为num_sge。</p>
<h2 id="RDMA-提交WR流程"><a href="#RDMA-提交WR流程" class="headerlink" title="RDMA 提交WR流程"></a>RDMA 提交WR流程</h2><p>下面图解一下SGL和WR链表的对应关系，并说明一个SGL (struct ibv_sge *sg_list)里包含的多个数据段是如何被RDMA硬件聚合成一个连续的数据段的。</p>
<h3 id="第一步：创建SGL"><a href="#第一步：创建SGL" class="headerlink" title="第一步：创建SGL"></a>第一步：创建SGL</h3><p><img src="/img/v2-a45f31b55c22ca8aad8a139be0eb8d99_720w.jpg" alt></p>
<p>从上图中，我们可以看到wr链表中的每一个结点都包含了一个SGL，SGL是一个数组，包含一个或多个SGE。通过ibv_post_send提交一个RDMA SEND 请求。这个WR请求中，包括一个sg_list的元素。它是一个SGE链表，SGE指向具体需要发送数据的Buffer。</p>
<h3 id="第二步：使用PD进行内存保护"><a href="#第二步：使用PD进行内存保护" class="headerlink" title="第二步：使用PD进行内存保护"></a>第二步：使用PD进行内存保护</h3><p><img src="/img/v2-4e72a802e022d5742de169921c185cd8_720w.jpg" alt></p>
<p>我们在发送一段内存地址的时候，我们需要将这段内存地址通过Memory Registration注册到RDMA中。也就是说注册到PD内存保护域当中。一个SGL至少被一个MR保护, 多个MR存在同一个PD中。如图所示一段内存MR可以保护多个SGE元素。</p>
<h3 id="调用ibv-post-send-将SGL发送到wire上去"><a href="#调用ibv-post-send-将SGL发送到wire上去" class="headerlink" title="调用ibv_post_send()将SGL发送到wire上去"></a>调用ibv_post_send()将SGL发送到wire上去</h3><p><img src="/img/v2-dec6f454affdc07019b8729c6c13fc96_720w.jpg" alt></p>
<p>在上图中，一个SGL数组包含了3个SGE, 长度分别为N1, N2, N3字节。我们可以看到，这3个buffer并不连续，它们Scatter(分散)在内存中的各个地方。RDMA硬件读取到SGL后，进行Gather(聚合)操作，于是在RDMA硬件的Wire上看到的就是N3+N2+N1个连续的字节。换句话说，通过使用SGL, 我们可以把分散(Scatter)在内存中的多个数据段(不连续)交给RDMA硬件去聚合(Gather)成连续的数据段。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/积累/" rel="tag"># 积累</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/09/26/msvc_unique_ptr源码/" rel="next" title="MSVC C++ STL 源码解析系列">
                <i class="fa fa-chevron-left"></i> MSVC C++ STL 源码解析系列
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/10/04/OpenMP参考文档/" rel="prev" title="OpenMP参考文档">
                OpenMP参考文档 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/header.jpg" alt="Hao Yu">
            
              <p class="site-author-name" itemprop="name">Hao Yu</p>
              <p class="site-description motion-element" itemprop="description">Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author</p>
          </div>
          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">353</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>
        	<audio controls="controls" loop="loop" preload="auto" src="/resource/xiaomeihao.mp3">
	        </audio>
	

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yuhao0102" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:yuh18@mails.tsinghua.edu.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#DMA和RDMA概念"><span class="nav-number">1.</span> <span class="nav-text">DMA和RDMA概念</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#DMA"><span class="nav-number">1.1.</span> <span class="nav-text">DMA</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RDMA"><span class="nav-number">1.2.</span> <span class="nav-text">RDMA</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RDMA的优势"><span class="nav-number">1.3.</span> <span class="nav-text">RDMA的优势</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RDMA-三种不同的硬件实现"><span class="nav-number">1.4.</span> <span class="nav-text">RDMA 三种不同的硬件实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RDMA基本术语"><span class="nav-number">1.5.</span> <span class="nav-text">RDMA基本术语</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Fabric"><span class="nav-number">1.5.1.</span> <span class="nav-text">Fabric</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CA-Channel-Adapter"><span class="nav-number">1.5.2.</span> <span class="nav-text">CA(Channel Adapter)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Verbs"><span class="nav-number">1.5.3.</span> <span class="nav-text">Verbs</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#核心概念"><span class="nav-number">1.6.</span> <span class="nav-text">核心概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Memory-Registration-MR-内存注册"><span class="nav-number">1.6.1.</span> <span class="nav-text">Memory Registration(MR) | 内存注册</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Queues-队列"><span class="nav-number">1.6.2.</span> <span class="nav-text">Queues | 队列</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RDMA数据传输"><span class="nav-number">1.7.</span> <span class="nav-text">RDMA数据传输</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#RDMA-Send-RDMA发送-接收-操作-（Send-Recv）"><span class="nav-number">1.7.1.</span> <span class="nav-text">RDMA Send | RDMA发送(/接收)操作 （Send/Recv）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RDMA-Read-RDMA读操作-Pull"><span class="nav-number">1.7.2.</span> <span class="nav-text">RDMA Read | RDMA读操作 (Pull)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RDMA-Write-RDMA写操作-Push"><span class="nav-number">1.7.3.</span> <span class="nav-text">RDMA Write | RDMA写操作 (Push)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RDMA-Write-with-Immediate-Data-支持立即数的RDMA写操作"><span class="nav-number">1.7.4.</span> <span class="nav-text">RDMA Write with Immediate Data | 支持立即数的RDMA写操作</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#RDMA-Send-Receive操作"><span class="nav-number">2.</span> <span class="nav-text">RDMA Send Receive操作</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#前言"><span class="nav-number">2.1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RDMA-Verbs操作"><span class="nav-number">2.2.</span> <span class="nav-text">RDMA Verbs操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Queue-Pairs"><span class="nav-number">2.3.</span> <span class="nav-text">Queue Pairs</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RDMA-Send-Receive"><span class="nav-number">2.4.</span> <span class="nav-text">RDMA Send/Receive</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#第一步"><span class="nav-number">2.4.1.</span> <span class="nav-text">第一步</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第二步"><span class="nav-number">2.4.2.</span> <span class="nav-text">第二步</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第三步"><span class="nav-number">2.4.3.</span> <span class="nav-text">第三步</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第四步"><span class="nav-number">2.4.4.</span> <span class="nav-text">第四步</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">2.5.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#理解RDMA-SGL"><span class="nav-number">3.</span> <span class="nav-text">理解RDMA SGL</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#前言-1"><span class="nav-number">3.1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SGE简介"><span class="nav-number">3.2.</span> <span class="nav-text">SGE简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ivc-post-send接口"><span class="nav-number">3.3.</span> <span class="nav-text">ivc_post_send接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ibv-send-wr结构"><span class="nav-number">3.4.</span> <span class="nav-text">ibv_send_wr结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RDMA-提交WR流程"><span class="nav-number">3.5.</span> <span class="nav-text">RDMA 提交WR流程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#第一步：创建SGL"><span class="nav-number">3.5.1.</span> <span class="nav-text">第一步：创建SGL</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第二步：使用PD进行内存保护"><span class="nav-number">3.5.2.</span> <span class="nav-text">第二步：使用PD进行内存保护</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#调用ibv-post-send-将SGL发送到wire上去"><span class="nav-number">3.5.3.</span> <span class="nav-text">调用ibv_post_send()将SGL发送到wire上去</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>
  <div id="DvelopmentTarget">     
  </div>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart" aria-hidden="false"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>

  
</div>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_uv"> 
  本站访客数<span id="busuanzi_value_site_uv"></span>人次
</span>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  


  

  


  <script type="text/javascript" src="/js/src/love.js"></script>

</body>
</html>
