<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zn-ch">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-center-simple.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="积累,">










<meta name="description" content="DMA和RDMA概念DMADMA(直接内存访问)是一种能力，允许在计算机主板上的设备直接把数据发送到内存中去，数据搬运不需要CPU的参与。 传统内存访问需要通过CPU进行数据copy来移动数据，通过CPU将内存中的Buffer1移动到Buffer2中。DMA模式：可以同DMA Engine之间通过硬件将数据从Buffer1移动到Buffer2,而不需要操作系统CPU的参与，大大降低了CPU Cop">
<meta name="keywords" content="积累">
<meta property="og:type" content="article">
<meta property="og:title" content="RDMA技术详解">
<meta property="og:url" content="http://yoursite.com/2021/09/30/rdma技术/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="DMA和RDMA概念DMADMA(直接内存访问)是一种能力，允许在计算机主板上的设备直接把数据发送到内存中去，数据搬运不需要CPU的参与。 传统内存访问需要通过CPU进行数据copy来移动数据，通过CPU将内存中的Buffer1移动到Buffer2中。DMA模式：可以同DMA Engine之间通过硬件将数据从Buffer1移动到Buffer2,而不需要操作系统CPU的参与，大大降低了CPU Cop">
<meta property="og:locale" content="zn-ch">
<meta property="og:image" content="http://yoursite.com/img/v2-d359453c9269146cd93de5eed43993c8_720w.jpg">
<meta property="og:image" content="http://yoursite.com/img/v2-f081e8fce13d8b00e5a786399d20ca06_720w.jpg">
<meta property="og:image" content="http://yoursite.com/img/v2-2ec811510b13787ec81a3490e4233f60_720w.jpg">
<meta property="og:image" content="http://yoursite.com/img/v2-e854577d2b1fb56889c95d76999d6583_720w.jpg">
<meta property="og:image" content="http://yoursite.com/img/v2-ea7615096a651042d6ff0758d85ad698_720w.jpg">
<meta property="og:image" content="http://yoursite.com/img/v2-f434f07e79221b59cd82e731cd62285d_720w.jpg">
<meta property="og:image" content="http://yoursite.com/img/v2-55fa92d979172cd69a027a1401f535c2_720w.jpg">
<meta property="og:image" content="http://yoursite.com/img/v2-1282960e29ec7042ffec89dcc4f5577e_720w.jpg">
<meta property="og:image" content="http://yoursite.com/img/v2-9dcb687ffaee99730313270214b327e6_720w.jpg">
<meta property="og:image" content="http://yoursite.com/img/v2-397f08428eaee59f9908dcb0ea2b1b56_720w.jpg">
<meta property="og:image" content="http://yoursite.com/img/v2-a45f31b55c22ca8aad8a139be0eb8d99_720w.jpg">
<meta property="og:image" content="http://yoursite.com/img/v2-4e72a802e022d5742de169921c185cd8_720w.jpg">
<meta property="og:image" content="http://yoursite.com/img/v2-dec6f454affdc07019b8729c6c13fc96_720w.jpg">
<meta property="og:updated_time" content="2022-02-23T02:52:58.176Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="RDMA技术详解">
<meta name="twitter:description" content="DMA和RDMA概念DMADMA(直接内存访问)是一种能力，允许在计算机主板上的设备直接把数据发送到内存中去，数据搬运不需要CPU的参与。 传统内存访问需要通过CPU进行数据copy来移动数据，通过CPU将内存中的Buffer1移动到Buffer2中。DMA模式：可以同DMA Engine之间通过硬件将数据从Buffer1移动到Buffer2,而不需要操作系统CPU的参与，大大降低了CPU Cop">
<meta name="twitter:image" content="http://yoursite.com/img/v2-d359453c9269146cd93de5eed43993c8_720w.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2021/09/30/rdma技术/">





  <title>RDMA技术详解 | Hao Yu's blog</title>
  








 
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zn-ch">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hao Yu's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">The program monkey was eaten by the siege lion.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/resume.pdf" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-mybetterhalf">
          <a href="/mybetterhalf/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>
            
            mybetterhalf
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/09/30/rdma技术/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">RDMA技术详解</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-09-30T09:38:00+08:00">
                2021-09-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="DMA和RDMA概念"><a href="#DMA和RDMA概念" class="headerlink" title="DMA和RDMA概念"></a>DMA和RDMA概念</h1><h2 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h2><p>DMA(直接内存访问)是一种能力，允许在计算机主板上的设备直接把数据发送到内存中去，数据搬运不需要CPU的参与。</p>
<p>传统内存访问需要通过CPU进行数据copy来移动数据，通过CPU将内存中的Buffer1移动到Buffer2中。DMA模式：可以同DMA Engine之间通过硬件将数据从Buffer1移动到Buffer2,而不需要操作系统CPU的参与，大大降低了CPU Copy的开销。</p>
<p><img src="/img/v2-d359453c9269146cd93de5eed43993c8_720w.jpg" alt></p>
<h2 id="RDMA"><a href="#RDMA" class="headerlink" title="RDMA"></a>RDMA</h2><p>RDMA是一种概念，在两个或者多个计算机进行通讯的时候使用DMA， 从一个主机的内存直接访问另一个主机的内存。</p>
<p><img src="/img/v2-f081e8fce13d8b00e5a786399d20ca06_720w.jpg" alt></p>
<p>RDMA是一种host-offload, host-bypass技术，允许应用程序(包括存储)在它们的内存空间之间直接做数据传输。具有RDMA引擎的以太网卡(RNIC)—而不是host—负责管理源和目标之间的可靠连接。使用RNIC的应用程序之间使用专注的QP和CQ进行通讯：</p>
<ul>
<li>每一个应用程序可以有很多QP和CQ</li>
<li>每一个QP包括一个SQ和RQ</li>
<li>每一个CQ可以跟多个SQ或者RQ相关联</li>
</ul>
<p><img src="/img/v2-2ec811510b13787ec81a3490e4233f60_720w.jpg" alt></p>
<h2 id="RDMA的优势"><a href="#RDMA的优势" class="headerlink" title="RDMA的优势"></a>RDMA的优势</h2><p>传统的TCP/IP技术在数据包处理过程中，要经过操作系统及其他软件层，需要占用大量的服务器资源和内存总线带宽，数据在系统内存、处理器缓存和网络控制器缓存之间来回进行复制移动，给服务器的CPU和内存造成了沉重负担。尤其是网络带宽、处理器速度与内存带宽三者的严重”不匹配性”，更加剧了网络延迟效应。</p>
<p>RDMA是一种新的直接内存访问技术，RDMA让计算机可以直接存取其他计算机的内存，而不需要经过处理器的处理。RDMA将数据从一个系统快速移动到远程系统的内存中，而不对操作系统造成任何影响。</p>
<p>在实现上，RDMA实际上是一种智能网卡与软件架构充分优化的远端内存直接高速访问技术，通过将RDMA协议固化于硬件(即网卡)上，以及支持Zero-copy和Kernel bypass这两种途径来达到其高性能的远程直接数据存取的目标。 使用RDMA的优势如下：</p>
<ul>
<li>零拷贝(Zero-copy) - 应用程序能够直接执行数据传输，在不涉及到网络软件栈的情况下。数据能够被直接发送到缓冲区或者能够直接从缓冲区里接收，而不需要被复制到网络层。</li>
<li>内核旁路(Kernel bypass) - 应用程序可以直接在用户态执行数据传输，不需要在内核态与用户态之间做上下文切换。</li>
<li>不需要CPU干预(No CPU involvement) - 应用程序可以访问远程主机内存而不消耗远程主机中的任何CPU。远程主机内存能够被读取而不需要远程主机上的进程（或CPU)参与。远程主机的CPU的缓存(cache)不会被访问的内存内容所填充。</li>
<li>消息基于事务(Message based transactions) - 数据被处理为离散消息而不是流，消除了应用程序将流切割为不同消息/事务的需求。</li>
<li>支持分散/聚合条目(Scatter/gather entries support) - RDMA原生态支持分散/聚合。也就是说，读取多个内存缓冲区然后作为一个流发出去或者接收一个流然后写入到多个内存缓冲区里去。</li>
</ul>
<p>在具体的远程内存读写中，RDMA操作用于读写操作的远程虚拟内存地址包含在RDMA消息中传送，远程应用程序要做的只是在其本地网卡中注册相应的内存缓冲区。远程节点的CPU除在连接建立、注册调用等之外，在整个RDMA数据传输过程中并不提供服务，因此没有带来任何负载。</p>
<h2 id="RDMA-三种不同的硬件实现"><a href="#RDMA-三种不同的硬件实现" class="headerlink" title="RDMA 三种不同的硬件实现"></a>RDMA 三种不同的硬件实现</h2><p>RDMA作为一种host-offload, host-bypass技术，使低延迟、高带宽的直接的内存到内存的数据通信成为了可能。目前支持RDMA的网络协议有：</p>
<ol>
<li>InfiniBand(IB): 从一开始就支持RDMA的新一代网络协议。由于这是一种新的网络技术，因此需要支持该技术的网卡和交换机。</li>
<li>RDMA过融合以太网(RoCE): 即RDMA over Ethernet, 允许通过以太网执行RDMA的网络协议。这允许在标准以太网基础架构(交换机)上使用RDMA，只不过网卡必须是支持RoCE的特殊的NIC。</li>
<li>互联网广域RDMA协议(iWARP): 即RDMA over TCP, 允许通过TCP执行RDMA的网络协议。这允许在标准以太网基础架构(交换机)上使用RDMA，只不过网卡要求是支持iWARP(如果使用CPU offload的话)的NIC。否则，所有iWARP栈都可以在软件中实现，但是失去了大部分的RDMA性能优势。</li>
</ol>
<p><img src="/img/v2-e854577d2b1fb56889c95d76999d6583_720w.jpg" alt></p>
<p>在三种主流的RDMA技术中，可以划分为两大阵营。一个是IB技术, 另一个是支持RDMA的以太网技术(RoCE和iWARP)。其中, IBTA力挺的技术自然是IB和RoCE, Mellanox公司（一个以色列人搞的小公司）是这方面的急先锋。而iWARP则是IEEE/IETF力挺的技术，主要是Chelsio公司在推进。RoCE和iWARP的争论，请参考Mellanox和Chelsio这两家公司发布的白皮书。</p>
<p>在存储领域，支持RDMA的技术早就存在，比如SRP(SCSI RDMA Protocol)和iSER(iSCSI Extensions for RDMA)。 如今兴起的NVMe over Fabrics如果使用的不是FC网络的话，本质上就是NVMe over RDMA。 换句话说，NVMe over InfiniBand, NVMe over RoCE和NVMe over iWARP都是NVMe over RDMA。</p>
<h2 id="RDMA基本术语"><a href="#RDMA基本术语" class="headerlink" title="RDMA基本术语"></a>RDMA基本术语</h2><h3 id="Fabric"><a href="#Fabric" class="headerlink" title="Fabric"></a>Fabric</h3><p>A local-area RDMA network is usually referred to as a fabric.所谓Fabric，就是支持RDMA的局域网(LAN)。</p>
<h3 id="CA-Channel-Adapter"><a href="#CA-Channel-Adapter" class="headerlink" title="CA(Channel Adapter)"></a>CA(Channel Adapter)</h3><p>A channel adapter is the hardware component that connects a system to the fabric.</p>
<p>CA是Channel Adapter(通道适配器)的缩写。那么，CA就是将系统连接到Fabric的硬件组件。 在IBTA中，一个CA就是IB子网中的一个终端结点(End Node)。分为两种类型，一种是HCA, 另一种叫做TCA, 它们合称为xCA。其中， HCA(Host Channel Adapter)是支持”verbs”接口的CA, TCA(Target Channel Adapter)可以理解为”weak CA”, 不需要像HCA一样支持很多功能。 而在IEEE/IETF中，CA的概念被实体化为RNIC（RDMA Network Interface Card）, iWARP就把一个CA称之为一个RNIC。</p>
<p>简言之，在IBTA阵营中，CA即HCA或TCA； 而在iWARP阵营中，CA就是RNIC。 总之，无论是HCA、 TCA还是RNIC，它们都是CA, 它们的基本功能本质上都是生产或消费数据包(packet)</p>
<h3 id="Verbs"><a href="#Verbs" class="headerlink" title="Verbs"></a>Verbs</h3><p>在RDMA的持续演进中，有一个组织叫做OpenFabric Alliance所做的贡献可谓功不可没。 Verbs这个词不好翻译，大致可以理解为访问RDMA硬件的“一组标准动作”。 每一个Verb可以理解为一个Function。</p>
<h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><h3 id="Memory-Registration-MR-内存注册"><a href="#Memory-Registration-MR-内存注册" class="headerlink" title="Memory Registration(MR) | 内存注册"></a>Memory Registration(MR) | 内存注册</h3><p>RDMA 就是用来对内存进行数据传输。那么怎样才能对内存进行传输，很简单，注册。 因为RDMA硬件对用来做数据传输的内存是有特殊要求的。</p>
<ul>
<li>在数据传输过程中，应用程序不能修改数据所在的内存。</li>
<li>操作系统不能对数据所在的内存进行page out操作 — 物理地址和虚拟地址的映射必须是固定不变的。</li>
</ul>
<p>注意无论是DMA或者RDMA都要求物理地址连续，这是由DMA引擎所决定的。 那么怎么进行内存注册呢？</p>
<ul>
<li>创建两个key (local和remote)指向需要操作的内存区域</li>
<li>注册的keys是数据传输请求的一部分</li>
</ul>
<p>注册一个Memory Region之后，这个时候这个Memory Region也就有了它自己的属性：</p>
<ul>
<li>context : RDMA操作上下文</li>
<li>addr : MR被注册的Buffer地址</li>
<li>length : MR被注册的Buffer长度</li>
<li>lkey：MR被注册的本地key</li>
<li>rkey：MR被注册的远程key</li>
</ul>
<p>对Memrory Registration：Memory Registration只是RDMA中对内存保护的一种措施，只有将要操作的内存注册到RDMA Memory Region中，这快操作的内存就交给RDMA 保护域来操作了。这个时候我们就可以对这快内存进行操作，至于操作的起始地址、操作Buffer的长度，可以根据程序的具体需求进行操作。我们只要保证接受方的Buffer 接受的长度大于等于发送的Buffer长度。</p>
<h3 id="Queues-队列"><a href="#Queues-队列" class="headerlink" title="Queues | 队列"></a>Queues | 队列</h3><p>RDMA一共支持三种队列，发送队列(SQ)和接收队列(RQ)，完成队列(CQ)。其中，SQ和RQ通常成对创建，被称为Queue Pairs(QP)。</p>
<p>RDMA是基于消息的传输协议，数据传输都是异步操作。 RDMA操作其实很简单，可以理解为：</p>
<ul>
<li>Host提交工作请求(WR)到工作队列(WQ): 工作队列包括发送队列(SQ)和接收队列(RQ)。工作队列的每一个元素叫做WQE, 也就是WR。</li>
<li>Host从完成队列(CQ）中获取工作完成(WC): 完成队列里的每一个叫做CQE, 也就是WC。</li>
<li>具有RDMA引擎的硬件(hardware)就是一个队列元素处理器。 RDMA硬件不断地从工作队列(WQ)中去取工作请求(WR)来执行，执行完了就给完成队列(CQ)中放置工作完成(WC)。从生产者-消费者的角度理解就是：</li>
<li>Host生产WR, 把WR放到WQ中去</li>
<li>RDMA硬件消费WR</li>
<li>RDMA硬件生产WC, 把WC放到CQ中去</li>
<li>Host消费WC</li>
</ul>
<p><img src="/img/v2-ea7615096a651042d6ff0758d85ad698_720w.jpg" alt></p>
<h2 id="RDMA数据传输"><a href="#RDMA数据传输" class="headerlink" title="RDMA数据传输"></a>RDMA数据传输</h2><h3 id="RDMA-Send-RDMA发送-接收-操作-（Send-Recv）"><a href="#RDMA-Send-RDMA发送-接收-操作-（Send-Recv）" class="headerlink" title="RDMA Send | RDMA发送(/接收)操作 （Send/Recv）"></a>RDMA Send | RDMA发送(/接收)操作 （Send/Recv）</h3><p>跟TCP/IP的send/recv是类似的，不同的是RDMA是基于消息的数据传输协议（而不是基于字节流的传输协议），所有数据包的组装都在RDMA硬件上完成的，也就是说OSI模型中的下面4层(传输层，网络层，数据链路层，物理层)都在RDMA硬件上完成。</p>
<h3 id="RDMA-Read-RDMA读操作-Pull"><a href="#RDMA-Read-RDMA读操作-Pull" class="headerlink" title="RDMA Read | RDMA读操作 (Pull)"></a>RDMA Read | RDMA读操作 (Pull)</h3><p>RDMA读操作本质上就是Pull操作, 把远程系统内存里的数据拉回到本地系统的内存里。</p>
<h3 id="RDMA-Write-RDMA写操作-Push"><a href="#RDMA-Write-RDMA写操作-Push" class="headerlink" title="RDMA Write | RDMA写操作 (Push)"></a>RDMA Write | RDMA写操作 (Push)</h3><p>RDMA写操作本质上就是Push操作，把本地系统内存里的数据推送到远程系统的内存里。</p>
<h3 id="RDMA-Write-with-Immediate-Data-支持立即数的RDMA写操作"><a href="#RDMA-Write-with-Immediate-Data-支持立即数的RDMA写操作" class="headerlink" title="RDMA Write with Immediate Data | 支持立即数的RDMA写操作"></a>RDMA Write with Immediate Data | 支持立即数的RDMA写操作</h3><p>支持立即数的RDMA写操作本质上就是给远程系统Push(推送)带外(OOB)数据, 这跟TCP里的带外数据是类似的。</p>
<p>可选地，immediate 4字节值可以与数据缓冲器一起发送。 该值作为接收通知的一部分呈现给接收者，并且不包含在数据缓冲器中。</p>
<h1 id="RDMA-Send-Receive操作"><a href="#RDMA-Send-Receive操作" class="headerlink" title="RDMA Send Receive操作"></a>RDMA Send Receive操作</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>RDMA指的是远程直接内存访问，这是一种通过网络在两个应用程序之间搬运缓冲区里的数据的方法。RDMA与传统的网络接口不同，因为它绕过了操作系统。这允许实现了RDMA的程序具有如下特点：</p>
<ul>
<li>绝对的最低时延</li>
<li>最高的吞吐量</li>
<li>最小的CPU足迹 （也就是说，需要CPU参与的地方被最小化）</li>
</ul>
<h2 id="RDMA-Verbs操作"><a href="#RDMA-Verbs操作" class="headerlink" title="RDMA Verbs操作"></a>RDMA Verbs操作</h2><p>使用RDMA, 我们需要有一张实现了RDMA引擎的网卡。我们把这种卡称之为HCA(主机通道适配器)。 适配器创建一个贯穿PCIe总线的从RDMA引擎到应用程序内存的通道。一个好的HCA将在导线上执行的RDMA协议所需要的全部逻辑都在硬件上予以实现。这包括分组，重组以及流量控制和可靠性保证。因此，从应用程序的角度看，只负责处理所有缓冲区即可。</p>
<p><img src="/img/v2-f434f07e79221b59cd82e731cd62285d_720w.jpg" alt></p>
<p>在RDMA中我们使用内核态驱动建立一个数据通道。我们称之为命令通道（Command Channel）。使用命令通道，我们能够建立一个数据通道（Data Channel），该通道允许我们在搬运数据的时候完全绕过内核。一旦建立了这种数据通道，我们就能直接读写数据缓冲区。</p>
<p>建立数据通道的API是一种称之为”verbs”的API。”verbs” API是由一个叫做OFED的Linux开源项目维护的。在站点<a href="http://www.openfabrics.org上，为Windows" target="_blank" rel="noopener">http://www.openfabrics.org上，为Windows</a> WinOF提供了一个等价的项目。”verbs” API跟你用过的socket编程API是不一样的。但是，一旦你掌握了一些概念后，就会变得非常容易，而且在设计你的程序的时候更简单。</p>
<h2 id="Queue-Pairs"><a href="#Queue-Pairs" class="headerlink" title="Queue Pairs"></a>Queue Pairs</h2><p>RDMA操作开始于“搞”内存。当你在对内存进行操作的时候，就是告诉内核这段内存名花有主了，主人就是你的应用程序。于是，你告诉HCA，就在这段内存上寻址，赶紧准备开辟一条从HCA卡到这段内存的通道。我们将这一动作称之为注册一个内存区域(MR)。一旦MR注册完毕，我们就可以使用这段内存来做任何RDMA操作。在下面的图中，我们可以看到注册的内存区域(MR)和被通信队列所使用的位于内存区域之内的缓冲区(buffer)。</p>
<p>RDMA Memory Registration<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ibv_mr</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ibv_context</span>     *<span class="title">context</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ibv_pd</span>      *<span class="title">pd</span>;</span></span><br><span class="line">    <span class="keyword">void</span>       *addr;</span><br><span class="line">    <span class="keyword">size_t</span>      length;</span><br><span class="line">    <span class="keyword">uint32_t</span>    handle;</span><br><span class="line">    <span class="keyword">uint32_t</span>    lkey;</span><br><span class="line">    <span class="keyword">uint32_t</span>    rkey;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/v2-55fa92d979172cd69a027a1401f535c2_720w.jpg" alt></p>
<p>RDMA硬件不断地从工作队列(WQ)中去取工作请求(WR)来执行，执行完了就给完成队列(CQ)中放置工作完成通知(WC)。这个WC意思就是Work Completion。表示这个WR RDMA请求已经被处理完成，可以从这个Completion Queue从取出来，表示这个RDMA请求已经被处理完毕。</p>
<p>RDMA通信基于三条队列(SQ, RQ和CQ)组成的集合。 其中， 发送队列(SQ)和接收队列(RQ)负责调度工作，他们总是成对被创建，称之为队列对(QP)。当放置在工作队列上的指令被完成的时候，完成队列(CQ)用来发送通知。</p>
<p>当用户把指令放置到工作队列的时候，就意味着告诉HCA那些缓冲区需要被发送或者用来接受数据。这些指令是一些小的结构体，称之为工作请求(WR)或者工作队列元素(WQE)。 WQE的发音为”WOOKIE”，就像星球大战里的猛兽。一个WQE主要包含一个指向某个缓冲区的指针。一个放置在发送队列（SQ）里的WQE中包含一个指向待发送的消息的指针。一个放置在接受队列里的WQE里的指针指向一段缓冲区，该缓冲区用来存放待接受的消息。</p>
<p>下面我们来看一下RDMA中的Work Request（SendWR和ReceWR）</p>
<p>RDMA Send Work Request请求<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ibv_send_wr</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span>    wr_id;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ibv_send_wr</span>     *<span class="title">next</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ibv_sge</span>     *<span class="title">sg_list</span>;</span></span><br><span class="line">    <span class="keyword">int</span>     num_sge;</span><br><span class="line">    <span class="keyword">enum</span> ibv_wr_opcode      opcode;</span><br><span class="line">    <span class="keyword">int</span>     send_flags;</span><br><span class="line">    <span class="keyword">uint32_t</span>    imm_data;       <span class="comment">/* in network byte order */</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			<span class="keyword">uint64_t</span>    remote_addr;</span><br><span class="line">			<span class="keyword">uint32_t</span>    rkey;</span><br><span class="line">		&#125; rdma;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			<span class="keyword">uint64_t</span>    remote_addr;</span><br><span class="line">			<span class="keyword">uint64_t</span>    compare_add;</span><br><span class="line">			<span class="keyword">uint64_t</span>    swap;</span><br><span class="line">			<span class="keyword">uint32_t</span>    rkey;</span><br><span class="line">		&#125; atomic;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">ibv_ah</span>  *<span class="title">ah</span>;</span></span><br><span class="line">			<span class="keyword">uint32_t</span>    remote_qpn;</span><br><span class="line">			<span class="keyword">uint32_t</span>    remote_qkey;</span><br><span class="line">		&#125; ud;</span><br><span class="line">    &#125; wr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>RDMA Receive Work Request请求<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ibv_recv_wr</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span>        wr_id;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ibv_recv_wr</span>     *<span class="title">next</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ibv_sge</span>     *<span class="title">sg_list</span>;</span></span><br><span class="line">    <span class="keyword">int</span>         num_sge;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>RDMA是一种异步传输机制。因此我们可以一次性在工作队列里放置好多个发送或接收WQE。HCA将尽可能快地按顺序处理这些WQE。当一个WQE被处理了，那么数据就被搬运了。 一旦传输完成，HCA就创建一个完成队列元素(CQE)并放置到完成队列(CQ)中去。 相应地，CQE的发音为”COOKIE”。</p>
<p>RDMA Complete Queue Element<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ibv_wc</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> wr_id; </span><br><span class="line">    <span class="keyword">enum</span> ibv_wc_status status; </span><br><span class="line">    <span class="keyword">enum</span> ibv_wc_opcode opcode; </span><br><span class="line">    <span class="keyword">uint32_t</span> vendor_err; </span><br><span class="line">    <span class="keyword">uint32_t</span> byte_len; </span><br><span class="line">    <span class="keyword">uint32_t</span> imm_data; <span class="comment">/* in network byte order */</span> </span><br><span class="line">    <span class="keyword">uint32_t</span> qp_num; </span><br><span class="line">    <span class="keyword">uint32_t</span> src_qp; </span><br><span class="line">    <span class="keyword">int</span> wc_flags; </span><br><span class="line">    <span class="keyword">uint16_t</span> pkey_index; </span><br><span class="line">    <span class="keyword">uint16_t</span> slid; </span><br><span class="line">    <span class="keyword">uint8_t</span> sl; </span><br><span class="line">    <span class="keyword">uint8_t</span> dlid_path_bits; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="RDMA-Send-Receive"><a href="#RDMA-Send-Receive" class="headerlink" title="RDMA Send/Receive"></a>RDMA Send/Receive</h2><p>让我们看个简单的例子。在这个例子中，我们将把一个缓冲区里的数据从系统A的内存中搬到系统B的内存中去。这就是我们所说的消息传递语义学。接下来我们要讲的一种操作为SEND，是RDMA中最基础的操作类型。</p>
<h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><p>第1步：系统A和B都创建了他们各自的QP的完成队列(CQ), 并为即将进行的RDMA传输注册了相应的内存区域(MR)。 系统A识别了一段缓冲区，该缓冲区的数据将被搬运到系统B上。系统B分配了一段空的缓冲区，用来存放来自系统A发送的数据。<br><img src="/img/v2-1282960e29ec7042ffec89dcc4f5577e_720w.jpg" alt></p>
<h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h3><p>第二步：系统B创建一个WQE并放置到它的接收队列(RQ)中。这个WQE包含了一个指针，该指针指向的内存缓冲区用来存放接收到的数据。系统A也创建一个WQE并放置到它的发送队列(SQ)中去，该WQE中的指针执行一段内存缓冲区，该缓冲区的数据将要被传送。<br><img src="/img/v2-9dcb687ffaee99730313270214b327e6_720w.jpg" alt></p>
<h3 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h3><p>第三步：系统A上的HCA总是在硬件上干活，看看发送队列里有没有WQE。HCA将消费掉来自系统A的WQE, 然后将内存区域里的数据变成数据流发送给系统B。当数据流开始到达系统B的时候，系统B上的HCA就消费来自系统B的WQE，然后将数据放到该放的缓冲区上去。在高速通道上传输的数据流完全绕过了操作系统内核。<br><img src="/img/v2-397f08428eaee59f9908dcb0ea2b1b56_720w.jpg" alt></p>
<h3 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h3><p>第四步：当数据搬运完成的时候，HCA会创建一个CQE。 这个CQE被放置到完成队列(CQ)中，表明数据传输已经完成。HCA每消费掉一个WQE, 都会生成一个CQE。因此，在系统A的完成队列中放置一个CQE,意味着对应的WQE的发送操作已经完成。同理，在系统B的完成队列中也会放置一个CQE，表明对应的WQE的接收操作已经完成。如果发生错误，HCA依然会创建一个CQE。在CQE中，包含了一个用来记录传输状态的字段。</p>
<p>我们刚刚举例说明的是一个RDMA Send操作。在IB或RoCE中，传送一个小缓冲区里的数据耗费的总时间大约在1.3µs。通过同时创建很多WQE, 就能在1秒内传输存放在数百万个缓冲区里的数据。</p>
<h2 id="RDMA单边通信"><a href="#RDMA单边通信" class="headerlink" title="RDMA单边通信"></a>RDMA单边通信</h2><p>在 RDMA 传输中，SEND/RECEIVE 是双边操作，即需要通信双方的参与，并且 RECEIVE 要先于 SEND 执行，这样对方才能发送数据，当然如果对方不需要发送数据，可以不执行 RECEIVE 操作，因此该过程和传统通信相似，区别在于 RDMA 的零拷贝网络技术和内核旁路，延迟低，多用于传输短的控制消息。</p>
<p>WRITE/READ 是单边操作，顾名思义，读/写操作是一方在执行，在实际的通信过程中，WRITE/READ 操作是由客户端来执行的，而服务器端不需要执行任何操作。RDMA WRITE 操作中，由客户端把数据从本地 buffer 中直接 push 到远程 QP 的虚拟空间的连续内存块中（物理内存不一定连续），因此需要知道目的地址（remote addr）和访问权限（remote key）。RDMA READ 操作中，是客户端直接到远程的 QP 的虚拟空间的连续内存块中获取数据 pull 到本地目的 buffer 中，因此需要远程 QP 的内存地址和访问权限。单边操作多用于批量数据传输。</p>
<p>可以看出，在单边操作过程中，客户端需要知道远程 QP 的 remote addr 和 remote key，而这两个信息是可以通过 SEND/REVEIVE 操作来交换的。</p>
<h3 id="RDMA-单边操作（RDMA-READ）"><a href="#RDMA-单边操作（RDMA-READ）" class="headerlink" title="RDMA 单边操作（RDMA READ）"></a>RDMA 单边操作（RDMA READ）</h3><p>READ 和 WRITE 是单边操作，只需要本端明确信息的源和目的地址，远端应用不必感知此次通信，数据的读或写都通过 RDMA 在网卡与应用 Buffer 之间完成，再由远端网卡封装成消息返回到本端。</p>
<p>对于单边操作，以存储网络环境下的存储为例，数据的流程如下：</p>
<ol>
<li>首先 A、B 建立连接，QP 已经创建并且初始化。</li>
<li>数据被存档在 B 的 buffer 地址 VB，注意 VB 应该提前注册到 B 的网卡（并且它是一个 memory region），并拿到返回的 remote key，相当于 RDMA 操作这块 buffer 的权限。</li>
<li>B 把数据地址 VB，key 封装到专用的报文传送到 A，这相当于 B 把数据 buffer 的操作权交给了 A。同时 B 在它的 WQ 中注册进一个 WR，以用于接收数据传输的 A 返回的状态。</li>
<li>A 在收到 B 的送过来的数据 VB 和 remote key 后，网卡会把它们连同自身存储地址 VA 到封装 RDMA READ 请求，将这个消息请求发送给 B，这个过程 A、B 两端不需要任何软件参与，就可以将 B 的数据存储到 A 的 VA 虚拟地址。</li>
<li>A 在存储完成后，会向 B 返回整个数据传输的状态信息。</li>
</ol>
<p>单边操作传输方式是 RDMA 与传统网络传输的最大不同，只需提供直接访问远程的虚拟地址，无须远程应用参与其中，这种方式适用于批量数据传输。</p>
<h3 id="RDMA-单边操作（RDMA-WRITE）"><a href="#RDMA-单边操作（RDMA-WRITE）" class="headerlink" title="RDMA 单边操作（RDMA WRITE）"></a>RDMA 单边操作（RDMA WRITE）</h3><p>对于单边操作，以存储网络环境下的存储为例，数据的流程如下：</p>
<ol>
<li>首先 A、B 建立连接，QP 已经创建并且初始化。</li>
<li>数据 remote 目标存储 buffer 地址 VB，注意 VB 应该提前注册到 B 的网卡（并且它是一个 memory region），并拿到返回的 remote key，相当于 RDMA 操作这块 buffer 的权限。</li>
<li>B 把数据地址 VB，key 封装到专用的报文传送到 A，这相当于 B 把数据 buffer 的操作权交给了 A。同时 B 在它的 WQ 中注册进一个 WR，以用于接收数据传输的 A 返回的状态。</li>
<li>A 在收到 B 的送过来的数据 VB 和 remote key 后，网卡会把它们连同自身发送地址 VA 到封装 RDMA WRITE 请求，这个过程 A、B 两端不需要任何软件参与，就可以将 A 的数据发送到 B 的 VB 虚拟地址。</li>
<li>A 在发送数据完成后，会向 B 返回整个数据传输的状态信息。</li>
</ol>
<p>单边操作传输方式是 RDMA 与传统网络传输的最大不同，只需提供直接访问远程的虚拟地址，无须远程应用的参与其中，这种方式适用于批量数据传输。</p>
<h3 id="RDMA-双边操作（RDMA-SEND-RECEIVE）"><a href="#RDMA-双边操作（RDMA-SEND-RECEIVE）" class="headerlink" title="RDMA 双边操作（RDMA SEND/RECEIVE）"></a>RDMA 双边操作（RDMA SEND/RECEIVE）</h3><p>RDMA 中 SEND/RECEIVE 是双边操作，即必须要远端的应用感知参与才能完成收发。在实际中，SEND/RECEIVE 多用于连接控制类报文，而数据报文多是通过 READ/WRITE 来完成的。</p>
<p>对于双边操作为例，主机 A 向主机 B（下面简称 A、B）发送数据的流程如下：</p>
<ol>
<li>首先，A 和 B 都要创建并初始化好各自的 QP，CQ。</li>
<li>A 和 B 分别向自己的 WQ 中注册 WQE，对于 A，WQ = SQ，WQE 描述指向一个等到被发送的数据；对于 B，WQ = RQ，WQE 描述指向一块用于存储数据的 Buffer。</li>
<li>A 的网卡异步调度轮到 A 的 WQE，解析到这是一个 SEND 消息，从 buffer 中直接向 B 发出数据。数据流到达 B 的网卡后，B 的 WQE 被消耗，并把数据直接存储到 WQE 指向的存储位置。</li>
<li>AB 通信完成后，A 的 CQ 中会产生一个完成消息 CQE 表示发送完成。与此同时，B 的 CQ 中也会产生一个完成消息表示接收完成。每个 WQ 中 WQE 的处理完成都会产生一个 CQE。</li>
</ol>
<p>双边操作与传统网络的底层 Buffer Pool 类似，收发双方的参与过程并无差别，区别在零拷贝、kernel bypass，实际上对于 RDMA，这是一种复杂的消息传输模式，多用于传输短的控制消息。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在这博客中，我们学习了如何使用RDMA verbs API。同时也介绍了队列的概念，而队列概念是RDMA编程的基础。最后，我们演示了RDMA send操作，展现了缓冲区的数据是如何在从一个系统搬运到另一个系统上去的。</p>
<h1 id="理解RDMA-SGL"><a href="#理解RDMA-SGL" class="headerlink" title="理解RDMA SGL"></a>理解RDMA SGL</h1><h2 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h2><p>在使用RDMA操作之前，我们需要了解一些RDMA API中的一些需要的值。其中在ibv_send_wr我们需要一个sg_list的数组，sg_list是用来存放ibv_sge元素，那么什么是SGL以及什么是sge呢？对于一个使用RDMA进行开发的程序员来说，我们需要了解这一系列细节。</p>
<h2 id="SGE简介"><a href="#SGE简介" class="headerlink" title="SGE简介"></a>SGE简介</h2><p>在NVMe over PCIe中，I/O命令支持SGL(Scatter Gather List 分散聚合表)和PRP(Physical Region Page 物理(内存)区域页), 而管理命令只支持PRP;而在NVMe over Fabrics中，无论是管理命令还是I/O命令都只支持SGL。</p>
<p>RDMA编程中，SGL(Scatter/Gather List)是最基本的数据组织形式。 SGL是一个数组，该数组中的元素被称之为SGE(Scatter/Gather Element)，每一个SGE就是一个Data Segment(数据段)。RDMA支持Scatter/Gather操作，具体来讲就是RDMA可以支持一个连续的Buffer空间，进行Scatter分散到多个目的主机的不连续的Buffer空间。Gather指的就是多个不连续的Buffer空间，可以Gather到目的主机的一段连续的Buffer空间。</p>
<p>下面我们就来看一下ibv_sge的定义：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ibv_sge</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span>    addr;</span><br><span class="line">    <span class="keyword">uint32_t</span>    length;</span><br><span class="line">    <span class="keyword">uint32_t</span>    lkey;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>addr: 数据段所在的虚拟内存的起始地址 (Virtual Address of the Data Segment (i.e. Buffer))</li>
<li>length: 数据段长度(Length of the Data Segment)</li>
<li>lkey: 该数据段对应的L_Key (Key of the local Memory Region)</li>
</ul>
<h2 id="ivc-post-send接口"><a href="#ivc-post-send接口" class="headerlink" title="ivc_post_send接口"></a>ivc_post_send接口</h2><p>而在数据传输中，发送/接收使用的Verbs API为：</p>
<p>ibv_post_send() - post a list of work requests (WRs) to a send queue 将一个WR列表放置到发送队列中 ibv_post_recv() - post a list of work requests (WRs) to a receive queue 将一个WR列表放置到接收队列中<br>下面以ibv_post_send()为例，说明SGL是如何被放置到RDMA硬件的线缆(Wire)上的。</p>
<p><code>ibv_post_send()</code>的函数原型<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;infiniband/verbs.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ibv_post_send</span><span class="params">(struct ibv_qp *qp, </span></span></span><br><span class="line"><span class="function"><span class="params">    struct ibv_send_wr *wr,</span></span></span><br><span class="line"><span class="function"><span class="params">    struct ibv_send_wr **bad_wr)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p><code>ibv_post_send()</code>将以send_wr开头的工作请求（WR）的列表发布到Queue Pair的Send Queue。 它会在第一次失败时停止处理此列表中的WR（可以在发布请求时立即检测到），并通过bad_wr返回此失败的WR。</p>
<p>参数wr是一个ibv_send_wr结构，如中所定义。</p>
<h2 id="ibv-send-wr结构"><a href="#ibv-send-wr结构" class="headerlink" title="ibv_send_wr结构"></a>ibv_send_wr结构</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ibv_send_wr</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span>    wr_id;      <span class="comment">/* User defined WR ID */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ibv_send_wr</span>     *<span class="title">next</span>;</span>       <span class="comment">/* Pointer to next WR in list, NULL if last WR */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ibv_sge</span>     *<span class="title">sg_list</span>;</span>    <span class="comment">/* Pointer to the s/g array */</span></span><br><span class="line">    <span class="keyword">int</span>     num_sge;    <span class="comment">/* Size of the s/g array */</span></span><br><span class="line">    <span class="keyword">enum</span> ibv_wr_opcode      opcode;     <span class="comment">/* Operation type */</span></span><br><span class="line">    <span class="keyword">int</span>     send_flags;     <span class="comment">/* Flags of the WR properties */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    imm_data;       <span class="comment">/* Immediate data (in network byte order) */</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="keyword">uint64_t</span>    remote_addr;    <span class="comment">/* Start address of remote memory buffer */</span></span><br><span class="line">        <span class="keyword">uint32_t</span>    rkey;       <span class="comment">/* Key of the remote Memory Region */</span></span><br><span class="line">    &#125; rdma;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="keyword">uint64_t</span>    remote_addr;    <span class="comment">/* Start address of remote memory buffer */</span></span><br><span class="line">        <span class="keyword">uint64_t</span>    compare_add;    <span class="comment">/* Compare operand */</span></span><br><span class="line">        <span class="keyword">uint64_t</span>    swap;       <span class="comment">/* Swap operand */</span></span><br><span class="line">            <span class="keyword">uint32_t</span>    rkey;       <span class="comment">/* Key of the remote Memory Region */</span></span><br><span class="line">        &#125; atomic;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">ibv_ah</span>  *<span class="title">ah</span>;</span>     <span class="comment">/* Address handle (AH) for the remote node address */</span></span><br><span class="line">            <span class="keyword">uint32_t</span>    remote_qpn;     <span class="comment">/* QP number of the destination QP */</span></span><br><span class="line">            <span class="keyword">uint32_t</span>    remote_qkey;    <span class="comment">/* Q_Key number of the destination QP */</span></span><br><span class="line">        &#125; ud;</span><br><span class="line">    &#125; wr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在调用<code>ibv_post_send()</code>之前，必须填充好数据结构wr。 wr是一个链表，每一个结点包含了一个sg_list(i.e. SGL: 由一个或多个SGE构成的数组), sg_list的长度为num_sge。</p>
<h2 id="RDMA-提交WR流程"><a href="#RDMA-提交WR流程" class="headerlink" title="RDMA 提交WR流程"></a>RDMA 提交WR流程</h2><p>下面图解一下SGL和WR链表的对应关系，并说明一个SGL (struct ibv_sge *sg_list)里包含的多个数据段是如何被RDMA硬件聚合成一个连续的数据段的。</p>
<h3 id="第一步：创建SGL"><a href="#第一步：创建SGL" class="headerlink" title="第一步：创建SGL"></a>第一步：创建SGL</h3><p><img src="/img/v2-a45f31b55c22ca8aad8a139be0eb8d99_720w.jpg" alt></p>
<p>从上图中，我们可以看到wr链表中的每一个结点都包含了一个SGL，SGL是一个数组，包含一个或多个SGE。通过ibv_post_send提交一个RDMA SEND 请求。这个WR请求中，包括一个sg_list的元素。它是一个SGE链表，SGE指向具体需要发送数据的Buffer。</p>
<h3 id="第二步：使用PD进行内存保护"><a href="#第二步：使用PD进行内存保护" class="headerlink" title="第二步：使用PD进行内存保护"></a>第二步：使用PD进行内存保护</h3><p><img src="/img/v2-4e72a802e022d5742de169921c185cd8_720w.jpg" alt></p>
<p>我们在发送一段内存地址的时候，我们需要将这段内存地址通过Memory Registration注册到RDMA中。也就是说注册到PD内存保护域当中。一个SGL至少被一个MR保护, 多个MR存在同一个PD中。如图所示一段内存MR可以保护多个SGE元素。</p>
<h3 id="调用ibv-post-send-将SGL发送到wire上去"><a href="#调用ibv-post-send-将SGL发送到wire上去" class="headerlink" title="调用ibv_post_send()将SGL发送到wire上去"></a>调用ibv_post_send()将SGL发送到wire上去</h3><p><img src="/img/v2-dec6f454affdc07019b8729c6c13fc96_720w.jpg" alt></p>
<p>在上图中，一个SGL数组包含了3个SGE, 长度分别为N1, N2, N3字节。我们可以看到，这3个buffer并不连续，它们Scatter(分散)在内存中的各个地方。RDMA硬件读取到SGL后，进行Gather(聚合)操作，于是在RDMA硬件的Wire上看到的就是N3+N2+N1个连续的字节。换句话说，通过使用SGL, 我们可以把分散(Scatter)在内存中的多个数据段(不连续)交给RDMA硬件去聚合(Gather)成连续的数据段。</p>
<h1 id="RDMA服务器的代码流程"><a href="#RDMA服务器的代码流程" class="headerlink" title="RDMA服务器的代码流程"></a>RDMA服务器的代码流程</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="number">1.</span> rdma_create_event_channel</span><br><span class="line">	<span class="comment">// 这一步是创建一个event channel，event channel是RDMA设备在操作完成后，或者有连接请求等事件发生时，用来通知应用程序的通道。其内部就是一个file descriptor, 因此可以进行poll等操作。</span></span><br><span class="line"></span><br><span class="line">	<span class="number">2.</span> rdma_create_id(channel, **id，……)</span><br><span class="line">	<span class="comment">// 这一步创建一个rdma_cm_id, 概念上等价与socket编程时的listen socket。</span></span><br><span class="line"></span><br><span class="line">	<span class="number">3.</span> rdma_bind_addr(id,addr)</span><br><span class="line">	<span class="comment">// 和socket编程一样，也要先绑定一个本地的地址和端口，以进行listen操作。</span></span><br><span class="line"></span><br><span class="line">	<span class="number">4.</span> rdma_listen(id,block)</span><br><span class="line">	<span class="comment">// 开始侦听客户端的连接请求</span></span><br><span class="line"></span><br><span class="line">	<span class="number">5.</span> rdma_get_cm_event</span><br><span class="line">	<span class="comment">// 这个调用就是作用在第一步创建的event channel上面，要从event channel中获取一个事件。这是个阻塞调用，只有有事件时才会返回。在一切正常的情况下，函数返回时会得到一个 RDMA_CM_EVENT_CONNECT_REQUEST事件，也就是说，有客户端发起连接了。</span></span><br><span class="line">	<span class="comment">//在事件的参数里面，会有一个新的rdma_cm_id传入。这点和socket是不同的，socket只有在accept后才有新的socket fd创建。</span></span><br><span class="line"></span><br><span class="line">on_event()</span><br><span class="line">&#123;</span><br><span class="line">    on_connect_request()<span class="comment">//RDMA_CM_EVENT_CONNECT_REQUEST</span></span><br><span class="line">	&#123;</span><br><span class="line">		build_context()</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="number">6.</span>ibv_alloc_pd</span><br><span class="line">			<span class="comment">// 创建一个protection domain。protection domain可以看作是一个内存保护单位，在内存区域和队列直接建立一个关联关系，防止未授权的访问。</span></span><br><span class="line"></span><br><span class="line">			<span class="number">7.</span>ibv_create_comp_channel</span><br><span class="line">			<span class="comment">// 和之前创建的event channel类似，这也是一个event channel，但只用来报告完成队列里面的事件。当完成队列里有新的任务完成时，就通过这个channel向应用程序报告。</span></span><br><span class="line"></span><br><span class="line">			<span class="number">8.</span>ibv_create_cq</span><br><span class="line">			<span class="comment">// 创建完成队列，创建时就指定使用第6步的channel。</span></span><br><span class="line"></span><br><span class="line">		&#125;<span class="comment">//--end build_context()</span></span><br><span class="line"></span><br><span class="line">		<span class="number">9.</span>rdma_create_qp</span><br><span class="line">		<span class="comment">// 创建一个queue pair, 一个queue pair包括一个发送queue和一个接收queue. 指定使用前面创建的cq作为完成队列。该qp创建时就指定关联到第6步创建的pd上。</span></span><br><span class="line"></span><br><span class="line">		<span class="number">10.</span>ibv_reg_mr</span><br><span class="line">		<span class="comment">// 注册内存区域。RDMA使用的内存，必须事先进行注册。这个是可以理解的，DMA的内存在边界对齐，能否被swap等方面，都有要求。</span></span><br><span class="line"></span><br><span class="line">		<span class="number">11.</span>rdma_accept</span><br><span class="line">		<span class="comment">// 至此，做好了全部的准备工作，可以调用accept接受客户端的这个请求了。</span></span><br><span class="line">	&#125; <span class="comment">//--end on_connect_request()</span></span><br><span class="line"></span><br><span class="line">	<span class="number">12.</span>rdma_ack_cm_event</span><br><span class="line">	<span class="comment">// 对于每个从event channel得到的事件，都要调用ack函数，否则会产生内存泄漏。这一步的ack是对应第5步的get。每一次get调用，都要有对应的ack调用。</span></span><br><span class="line"></span><br><span class="line">	<span class="number">13.</span>rdma_get_cm_event</span><br><span class="line">	<span class="comment">// 继续调用rdma_get_cm_event, 一切正常的话我们此时应该得到 RDMA_CM_EVENT_ESTABLISHED 事件，表示连接已经建立起来。不需要做额外的处理，直接rdma_ack_cm_event就行了</span></span><br><span class="line">&#125;<span class="comment">//--end on_event()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当rdma_get_cm_event返回RDMA_CM_EVENT_DISCONNECTED事件时，表示客户端断开了连接，server端要进行对应的清理。此时可以调用rdma_ack_cm_event释放事件资源。然后依次调用下面的函数，释放连接资源，内存资源，队列资源。</span></span><br><span class="line"></span><br><span class="line">rdma_disconnect</span><br><span class="line"></span><br><span class="line">rdma_destroy_qp</span><br><span class="line"></span><br><span class="line">ibv_dereg_mr</span><br><span class="line"></span><br><span class="line">rdma_destroy_id</span><br><span class="line"><span class="comment">//释放同客户端连接的rdma_cm_id</span></span><br><span class="line"></span><br><span class="line">rdma_destroy_id</span><br><span class="line"><span class="comment">// 释放用于侦听的rdma_cm_id</span></span><br><span class="line"></span><br><span class="line">rdma_destroy_event_channel</span><br><span class="line"><span class="comment">// 释放 event channel</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// end main</span></span><br></pre></td></tr></table></figure>
<p>服务端server.c<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;rdma/rdma_cma.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEST_NZ(x) do &#123; <span class="meta-keyword">if</span> ( (x)) die(<span class="meta-string">"error: "</span> #x <span class="meta-string">" failed (returned non-zero)."</span> ); &#125; while (0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEST_Z(x)  do &#123; <span class="meta-keyword">if</span> (!(x)) die(<span class="meta-string">"error: "</span> #x <span class="meta-string">" failed (returned zero/null)."</span>); &#125; while (0)</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> BUFFER_SIZE = <span class="number">1024</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">context</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ibv_context</span> *<span class="title">ctx</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ibv_pd</span> *<span class="title">pd</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ibv_cq</span> *<span class="title">cq</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ibv_comp_channel</span> *<span class="title">comp_channel</span>;</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">pthread_t</span> cq_poller_thread;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">connection</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ibv_qp</span> *<span class="title">qp</span>;</span></span><br><span class="line"> </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ibv_mr</span> *<span class="title">recv_mr</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ibv_mr</span> *<span class="title">send_mr</span>;</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">char</span> *recv_region;</span><br><span class="line">  <span class="keyword">char</span> *send_region;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">die</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *reason)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">build_context</span><span class="params">(struct ibv_context *verbs)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">build_qp_attr</span><span class="params">(struct ibv_qp_init_attr *qp_attr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> * <span class="title">poll_cq</span><span class="params">(<span class="keyword">void</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">post_receives</span><span class="params">(struct connection *conn)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">register_memory</span><span class="params">(struct connection *conn)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">on_completion</span><span class="params">(struct ibv_wc *wc)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">on_connect_request</span><span class="params">(struct rdma_cm_id *id)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">on_connection</span><span class="params">(<span class="keyword">void</span> *context)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">on_disconnect</span><span class="params">(struct rdma_cm_id *id)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">on_event</span><span class="params">(struct rdma_cm_event *event)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">context</span> *<span class="title">s_ctx</span> = <span class="title">NULL</span>;</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> _USE_IPV6</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in6</span> <span class="title">addr</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rdma_cm_event</span> *<span class="title">event</span> = <span class="title">NULL</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rdma_cm_id</span> *<span class="title">listener</span> = <span class="title">NULL</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rdma_event_channel</span> *<span class="title">ec</span> = <span class="title">NULL</span>;</span></span><br><span class="line">  <span class="keyword">uint16_t</span> port = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">memset</span>(&amp;addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(addr));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> _USE_IPV6</span></span><br><span class="line">  addr.sin6_family = AF_INET6;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  addr.sin_family = AF_INET;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line">  TEST_Z(ec = rdma_create_event_channel());</span><br><span class="line">  TEST_NZ(rdma_create_id(ec, &amp;listener, <span class="literal">NULL</span>, RDMA_PS_TCP));</span><br><span class="line">  TEST_NZ(rdma_bind_addr(listener, (struct sockaddr *)&amp;addr));</span><br><span class="line">  TEST_NZ(rdma_listen(listener, <span class="number">10</span>)); <span class="comment">/* backlog=10 is arbitrary */</span></span><br><span class="line"> </span><br><span class="line">  port = ntohs(rdma_get_src_port(listener)); <span class="comment">//rdma_get_src_port 返回listener对应的tcp 端口</span></span><br><span class="line"> </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"listening on port %d.\n"</span>, port);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">while</span> (rdma_get_cm_event(ec, &amp;event) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rdma_cm_event</span> <span class="title">event_copy</span>;</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;event_copy, event, <span class="keyword">sizeof</span>(*event));</span><br><span class="line">    rdma_ack_cm_event(event);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (on_event(&amp;event_copy))</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  rdma_destroy_id(listener);</span><br><span class="line">  rdma_destroy_event_channel(ec);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">die</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *reason)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s\n"</span>, reason);</span><br><span class="line">  <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_context</span><span class="params">(struct ibv_context *verbs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (s_ctx) &#123;</span><br><span class="line">    <span class="keyword">if</span> (s_ctx-&gt;ctx != verbs)</span><br><span class="line">      die(<span class="string">"cannot handle events in more than one context."</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  s_ctx = (struct context *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct context));</span><br><span class="line"> </span><br><span class="line">  s_ctx-&gt;ctx = verbs;</span><br><span class="line"> </span><br><span class="line">  TEST_Z(s_ctx-&gt;pd = ibv_alloc_pd(s_ctx-&gt;ctx));</span><br><span class="line">  TEST_Z(s_ctx-&gt;comp_channel = ibv_create_comp_channel(s_ctx-&gt;ctx));</span><br><span class="line">  TEST_Z(s_ctx-&gt;cq = ibv_create_cq(s_ctx-&gt;ctx, <span class="number">10</span>, <span class="literal">NULL</span>, s_ctx-&gt;comp_channel, <span class="number">0</span>)); <span class="comment">/* cqe=10 is arbitrary */</span></span><br><span class="line">  TEST_NZ(ibv_req_notify_cq(s_ctx-&gt;cq, <span class="number">0</span>)); #完成完成队列与完成通道的关联</span><br><span class="line"> </span><br><span class="line">  TEST_NZ(pthread_create(&amp;s_ctx-&gt;cq_poller_thread, <span class="literal">NULL</span>, poll_cq, <span class="literal">NULL</span>));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_qp_attr</span><span class="params">(struct ibv_qp_init_attr *qp_attr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(qp_attr, <span class="number">0</span>, <span class="keyword">sizeof</span>(*qp_attr));</span><br><span class="line"> </span><br><span class="line">  qp_attr-&gt;send_cq = s_ctx-&gt;cq;</span><br><span class="line">  qp_attr-&gt;recv_cq = s_ctx-&gt;cq;</span><br><span class="line">  qp_attr-&gt;qp_type = IBV_QPT_RC;</span><br><span class="line"> </span><br><span class="line">  qp_attr-&gt;cap.max_send_wr = <span class="number">10</span>;</span><br><span class="line">  qp_attr-&gt;cap.max_recv_wr = <span class="number">10</span>;</span><br><span class="line">  qp_attr-&gt;cap.max_send_sge = <span class="number">1</span>;</span><br><span class="line">  qp_attr-&gt;cap.max_recv_sge = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">poll_cq</span><span class="params">(<span class="keyword">void</span> *ctx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ibv_cq</span> *<span class="title">cq</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ibv_wc</span> <span class="title">wc</span>;</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    TEST_NZ(ibv_get_cq_event(s_ctx-&gt;comp_channel, &amp;cq, &amp;ctx));</span><br><span class="line">    ibv_ack_cq_events(cq, <span class="number">1</span>);</span><br><span class="line">    TEST_NZ(ibv_req_notify_cq(cq, <span class="number">0</span>));</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (ibv_poll_cq(cq, <span class="number">1</span>, &amp;wc))</span><br><span class="line">      on_completion(&amp;wc);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">post_receives</span><span class="params">(struct connection *conn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ibv_recv_wr</span> <span class="title">wr</span>, *<span class="title">bad_wr</span> = <span class="title">NULL</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ibv_sge</span> <span class="title">sge</span>;</span></span><br><span class="line"> </span><br><span class="line">  wr.wr_id = (<span class="keyword">uintptr_t</span>)conn;</span><br><span class="line">  wr.next = <span class="literal">NULL</span>;</span><br><span class="line">  wr.sg_list = &amp;sge;</span><br><span class="line">  wr.num_sge = <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">  sge.addr = (<span class="keyword">uintptr_t</span>)conn-&gt;recv_region;</span><br><span class="line">  sge.length = BUFFER_SIZE;</span><br><span class="line">  sge.lkey = conn-&gt;recv_mr-&gt;lkey;</span><br><span class="line"> </span><br><span class="line">  TEST_NZ(ibv_post_recv(conn-&gt;qp, &amp;wr, &amp;bad_wr));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">register_memory</span><span class="params">(struct connection *conn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  conn-&gt;send_region = <span class="built_in">malloc</span>(BUFFER_SIZE);</span><br><span class="line">  conn-&gt;recv_region = <span class="built_in">malloc</span>(BUFFER_SIZE);</span><br><span class="line"> </span><br><span class="line">  TEST_Z(conn-&gt;send_mr = ibv_reg_mr(</span><br><span class="line">    s_ctx-&gt;pd,</span><br><span class="line">    conn-&gt;send_region,</span><br><span class="line">    BUFFER_SIZE,</span><br><span class="line">    <span class="number">0</span>));</span><br><span class="line"> </span><br><span class="line">  TEST_Z(conn-&gt;recv_mr = ibv_reg_mr(</span><br><span class="line">    s_ctx-&gt;pd,</span><br><span class="line">    conn-&gt;recv_region,</span><br><span class="line">    BUFFER_SIZE,</span><br><span class="line">    IBV_ACCESS_LOCAL_WRITE));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">on_completion</span><span class="params">(struct ibv_wc *wc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (wc-&gt;status != IBV_WC_SUCCESS)</span><br><span class="line">    die(<span class="string">"on_completion: status is not IBV_WC_SUCCESS."</span>);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (wc-&gt;opcode &amp; IBV_WC_RECV) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">connection</span> *<span class="title">conn</span> = (<span class="title">struct</span> <span class="title">connection</span> *)(<span class="title">uintptr_t</span>)<span class="title">wc</span>-&gt;<span class="title">wr_id</span>;</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"received message: %s\n"</span>, conn-&gt;recv_region);</span><br><span class="line"> </span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (wc-&gt;opcode == IBV_WC_SEND) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"send completed successfully.\n"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">on_connect_request</span><span class="params">(struct rdma_cm_id *id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ibv_qp_init_attr</span> <span class="title">qp_attr</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rdma_conn_param</span> <span class="title">cm_params</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">connection</span> *<span class="title">conn</span>;</span></span><br><span class="line"> </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"received connection request.\n"</span>);</span><br><span class="line"> </span><br><span class="line">  build_context(id-&gt;verbs);</span><br><span class="line">  build_qp_attr(&amp;qp_attr);</span><br><span class="line"> </span><br><span class="line">  TEST_NZ(rdma_create_qp(id, s_ctx-&gt;pd, &amp;qp_attr));</span><br><span class="line"> </span><br><span class="line">  id-&gt;context = conn = (struct connection *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct connection));</span><br><span class="line">  conn-&gt;qp = id-&gt;qp;</span><br><span class="line"> </span><br><span class="line">  register_memory(conn);</span><br><span class="line">  post_receives(conn);</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">memset</span>(&amp;cm_params, <span class="number">0</span>, <span class="keyword">sizeof</span>(cm_params));</span><br><span class="line">  TEST_NZ(rdma_accept(id, &amp;cm_params));</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">on_connection</span><span class="params">(<span class="keyword">void</span> *context)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">connection</span> *<span class="title">conn</span> = (<span class="title">struct</span> <span class="title">connection</span> *)<span class="title">context</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ibv_send_wr</span> <span class="title">wr</span>, *<span class="title">bad_wr</span> = <span class="title">NULL</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ibv_sge</span> <span class="title">sge</span>;</span></span><br><span class="line"> </span><br><span class="line">  <span class="built_in">snprintf</span>(conn-&gt;send_region, BUFFER_SIZE, <span class="string">"message from passive/server side with pid %d"</span>, getpid());</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"connected. posting send...\n"</span>);</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">memset</span>(&amp;wr, <span class="number">0</span>, <span class="keyword">sizeof</span>(wr));</span><br><span class="line"> </span><br><span class="line">  wr.opcode = IBV_WR_SEND;</span><br><span class="line">  wr.sg_list = &amp;sge;</span><br><span class="line">  wr.num_sge = <span class="number">1</span>;</span><br><span class="line">  wr.send_flags = IBV_SEND_SIGNALED;</span><br><span class="line"> </span><br><span class="line">  sge.addr = (<span class="keyword">uintptr_t</span>)conn-&gt;send_region;</span><br><span class="line">  sge.length = BUFFER_SIZE;</span><br><span class="line">  sge.lkey = conn-&gt;send_mr-&gt;lkey;</span><br><span class="line"> </span><br><span class="line">  TEST_NZ(ibv_post_send(conn-&gt;qp, &amp;wr, &amp;bad_wr));</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">on_disconnect</span><span class="params">(struct rdma_cm_id *id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">connection</span> *<span class="title">conn</span> = (<span class="title">struct</span> <span class="title">connection</span> *)<span class="title">id</span>-&gt;<span class="title">context</span>;</span></span><br><span class="line"> </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"peer disconnected.\n"</span>);</span><br><span class="line"> </span><br><span class="line">  rdma_destroy_qp(id);</span><br><span class="line"> </span><br><span class="line">  ibv_dereg_mr(conn-&gt;send_mr);</span><br><span class="line">  ibv_dereg_mr(conn-&gt;recv_mr);</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">free</span>(conn-&gt;send_region);</span><br><span class="line">  <span class="built_in">free</span>(conn-&gt;recv_region);</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">free</span>(conn);</span><br><span class="line"> </span><br><span class="line">  rdma_destroy_id(id);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">on_event</span><span class="params">(struct rdma_cm_event *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (event-&gt;event == RDMA_CM_EVENT_CONNECT_REQUEST)</span><br><span class="line">    r = on_connect_request(event-&gt;id);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (event-&gt;event == RDMA_CM_EVENT_ESTABLISHED)</span><br><span class="line">    r = on_connection(event-&gt;id-&gt;context);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (event-&gt;event == RDMA_CM_EVENT_DISCONNECTED)</span><br><span class="line">    r = on_disconnect(event-&gt;id);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    die(<span class="string">"on_event: unknown event."</span>);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>客户端client.c<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;rdma/rdma_cma.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEST_NZ(x) do &#123; <span class="meta-keyword">if</span> ( (x)) die(<span class="meta-string">"error: "</span> #x <span class="meta-string">" failed (returned non-zero)."</span> ); &#125; while (0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEST_Z(x)  do &#123; <span class="meta-keyword">if</span> (!(x)) die(<span class="meta-string">"error: "</span> #x <span class="meta-string">" failed (returned zero/null)."</span>); &#125; while (0)</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> BUFFER_SIZE = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> TIMEOUT_IN_MS = <span class="number">500</span>; <span class="comment">/* ms */</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">context</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ibv_context</span> *<span class="title">ctx</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ibv_pd</span> *<span class="title">pd</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ibv_cq</span> *<span class="title">cq</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ibv_comp_channel</span> *<span class="title">comp_channel</span>;</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">pthread_t</span> cq_poller_thread;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">connection</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rdma_cm_id</span> *<span class="title">id</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ibv_qp</span> *<span class="title">qp</span>;</span></span><br><span class="line"> </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ibv_mr</span> *<span class="title">recv_mr</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ibv_mr</span> *<span class="title">send_mr</span>;</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">char</span> *recv_region;</span><br><span class="line">  <span class="keyword">char</span> *send_region;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">int</span> num_completions;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">die</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *reason)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">build_context</span><span class="params">(struct ibv_context *verbs)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">build_qp_attr</span><span class="params">(struct ibv_qp_init_attr *qp_attr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> * <span class="title">poll_cq</span><span class="params">(<span class="keyword">void</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">post_receives</span><span class="params">(struct connection *conn)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">register_memory</span><span class="params">(struct connection *conn)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">on_addr_resolved</span><span class="params">(struct rdma_cm_id *id)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">on_completion</span><span class="params">(struct ibv_wc *wc)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">on_connection</span><span class="params">(<span class="keyword">void</span> *context)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">on_disconnect</span><span class="params">(struct rdma_cm_id *id)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">on_event</span><span class="params">(struct rdma_cm_event *event)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">on_route_resolved</span><span class="params">(struct rdma_cm_id *id)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">context</span> *<span class="title">s_ctx</span> = <span class="title">NULL</span>;</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> *<span class="title">addr</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rdma_cm_event</span> *<span class="title">event</span> = <span class="title">NULL</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rdma_cm_id</span> *<span class="title">conn</span>= <span class="title">NULL</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rdma_event_channel</span> *<span class="title">ec</span> = <span class="title">NULL</span>;</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (argc != <span class="number">3</span>)</span><br><span class="line">    die(<span class="string">"usage: client &lt;server-address&gt; &lt;server-port&gt;"</span>);</span><br><span class="line"> </span><br><span class="line">  TEST_NZ(getaddrinfo(argv[<span class="number">1</span>], argv[<span class="number">2</span>], <span class="literal">NULL</span>, &amp;addr));</span><br><span class="line"> </span><br><span class="line">  TEST_Z(ec = rdma_create_event_channel());</span><br><span class="line">  TEST_NZ(rdma_create_id(ec, &amp;conn, <span class="literal">NULL</span>, RDMA_PS_TCP));</span><br><span class="line">  TEST_NZ(rdma_resolve_addr(conn, <span class="literal">NULL</span>, addr-&gt;ai_addr, TIMEOUT_IN_MS));</span><br><span class="line"> </span><br><span class="line">  freeaddrinfo(addr);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">while</span> (rdma_get_cm_event(ec, &amp;event) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rdma_cm_event</span> <span class="title">event_copy</span>;</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;event_copy, event, <span class="keyword">sizeof</span>(*event));</span><br><span class="line">    rdma_ack_cm_event(event);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (on_event(&amp;event_copy))</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  rdma_destroy_event_channel(ec);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">die</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *reason)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s\n"</span>, reason);</span><br><span class="line">  <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_context</span><span class="params">(struct ibv_context *verbs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (s_ctx) &#123;</span><br><span class="line">    <span class="keyword">if</span> (s_ctx-&gt;ctx != verbs)</span><br><span class="line">      die(<span class="string">"cannot handle events in more than one context."</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  s_ctx = (struct context *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct context));</span><br><span class="line"> </span><br><span class="line">  s_ctx-&gt;ctx = verbs;</span><br><span class="line"> </span><br><span class="line">  TEST_Z(s_ctx-&gt;pd = ibv_alloc_pd(s_ctx-&gt;ctx));</span><br><span class="line">  TEST_Z(s_ctx-&gt;comp_channel = ibv_create_comp_channel(s_ctx-&gt;ctx));</span><br><span class="line">  TEST_Z(s_ctx-&gt;cq = ibv_create_cq(s_ctx-&gt;ctx, <span class="number">10</span>, <span class="literal">NULL</span>, s_ctx-&gt;comp_channel, <span class="number">0</span>)); <span class="comment">/* cqe=10 is arbitrary */</span></span><br><span class="line">  TEST_NZ(ibv_req_notify_cq(s_ctx-&gt;cq, <span class="number">0</span>));</span><br><span class="line"> </span><br><span class="line">  TEST_NZ(pthread_create(&amp;s_ctx-&gt;cq_poller_thread, <span class="literal">NULL</span>, poll_cq, <span class="literal">NULL</span>));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_qp_attr</span><span class="params">(struct ibv_qp_init_attr *qp_attr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(qp_attr, <span class="number">0</span>, <span class="keyword">sizeof</span>(*qp_attr));</span><br><span class="line"> </span><br><span class="line">  qp_attr-&gt;send_cq = s_ctx-&gt;cq;</span><br><span class="line">  qp_attr-&gt;recv_cq = s_ctx-&gt;cq;</span><br><span class="line">  qp_attr-&gt;qp_type = IBV_QPT_RC;</span><br><span class="line"> </span><br><span class="line">  qp_attr-&gt;cap.max_send_wr = <span class="number">10</span>;</span><br><span class="line">  qp_attr-&gt;cap.max_recv_wr = <span class="number">10</span>;</span><br><span class="line">  qp_attr-&gt;cap.max_send_sge = <span class="number">1</span>;</span><br><span class="line">  qp_attr-&gt;cap.max_recv_sge = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">poll_cq</span><span class="params">(<span class="keyword">void</span> *ctx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ibv_cq</span> *<span class="title">cq</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ibv_wc</span> <span class="title">wc</span>;</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    TEST_NZ(ibv_get_cq_event(s_ctx-&gt;comp_channel, &amp;cq, &amp;ctx));</span><br><span class="line">    ibv_ack_cq_events(cq, <span class="number">1</span>);</span><br><span class="line">    TEST_NZ(ibv_req_notify_cq(cq, <span class="number">0</span>));</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (ibv_poll_cq(cq, <span class="number">1</span>, &amp;wc))</span><br><span class="line">      on_completion(&amp;wc);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">post_receives</span><span class="params">(struct connection *conn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ibv_recv_wr</span> <span class="title">wr</span>, *<span class="title">bad_wr</span> = <span class="title">NULL</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ibv_sge</span> <span class="title">sge</span>;</span></span><br><span class="line"> </span><br><span class="line">  wr.wr_id = (<span class="keyword">uintptr_t</span>)conn;</span><br><span class="line">  wr.next = <span class="literal">NULL</span>;</span><br><span class="line">  wr.sg_list = &amp;sge;</span><br><span class="line">  wr.num_sge = <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">  sge.addr = (<span class="keyword">uintptr_t</span>)conn-&gt;recv_region;</span><br><span class="line">  sge.length = BUFFER_SIZE;</span><br><span class="line">  sge.lkey = conn-&gt;recv_mr-&gt;lkey;</span><br><span class="line"> </span><br><span class="line">  TEST_NZ(ibv_post_recv(conn-&gt;qp, &amp;wr, &amp;bad_wr));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">register_memory</span><span class="params">(struct connection *conn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  conn-&gt;send_region = <span class="built_in">malloc</span>(BUFFER_SIZE);</span><br><span class="line">  conn-&gt;recv_region = <span class="built_in">malloc</span>(BUFFER_SIZE);</span><br><span class="line"> </span><br><span class="line">  TEST_Z(conn-&gt;send_mr = ibv_reg_mr(</span><br><span class="line">    s_ctx-&gt;pd, </span><br><span class="line">    conn-&gt;send_region, </span><br><span class="line">    BUFFER_SIZE, </span><br><span class="line">    <span class="number">0</span>));</span><br><span class="line"> </span><br><span class="line">  TEST_Z(conn-&gt;recv_mr = ibv_reg_mr(</span><br><span class="line">    s_ctx-&gt;pd, </span><br><span class="line">    conn-&gt;recv_region, </span><br><span class="line">    BUFFER_SIZE, </span><br><span class="line">    IBV_ACCESS_LOCAL_WRITE));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">on_addr_resolved</span><span class="params">(struct rdma_cm_id *id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ibv_qp_init_attr</span> <span class="title">qp_attr</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">connection</span> *<span class="title">conn</span>;</span></span><br><span class="line"> </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"address resolved.\n"</span>);</span><br><span class="line"> </span><br><span class="line">  build_context(id-&gt;verbs);</span><br><span class="line">  build_qp_attr(&amp;qp_attr);</span><br><span class="line"> </span><br><span class="line">  TEST_NZ(rdma_create_qp(id, s_ctx-&gt;pd, &amp;qp_attr));</span><br><span class="line"> </span><br><span class="line">  id-&gt;context = conn = (struct connection *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct connection));</span><br><span class="line"> </span><br><span class="line">  conn-&gt;id = id;</span><br><span class="line">  conn-&gt;qp = id-&gt;qp;</span><br><span class="line">  conn-&gt;num_completions = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">  register_memory(conn);</span><br><span class="line">  post_receives(conn);</span><br><span class="line"> </span><br><span class="line">  TEST_NZ(rdma_resolve_route(id, TIMEOUT_IN_MS));</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">on_completion</span><span class="params">(struct ibv_wc *wc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">connection</span> *<span class="title">conn</span> = (<span class="title">struct</span> <span class="title">connection</span> *)(<span class="title">uintptr_t</span>)<span class="title">wc</span>-&gt;<span class="title">wr_id</span>;</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (wc-&gt;status != IBV_WC_SUCCESS)</span><br><span class="line">    die(<span class="string">"on_completion: status is not IBV_WC_SUCCESS."</span>);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (wc-&gt;opcode &amp; IBV_WC_RECV)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"received message: %s\n"</span>, conn-&gt;recv_region);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (wc-&gt;opcode == IBV_WC_SEND)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"send completed successfully.\n"</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    die(<span class="string">"on_completion: completion isn't a send or a receive."</span>);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (++conn-&gt;num_completions == <span class="number">2</span>)</span><br><span class="line">    rdma_disconnect(conn-&gt;id);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">on_connection</span><span class="params">(<span class="keyword">void</span> *context)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">connection</span> *<span class="title">conn</span> = (<span class="title">struct</span> <span class="title">connection</span> *)<span class="title">context</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ibv_send_wr</span> <span class="title">wr</span>, *<span class="title">bad_wr</span> = <span class="title">NULL</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ibv_sge</span> <span class="title">sge</span>;</span></span><br><span class="line"> </span><br><span class="line">  <span class="built_in">snprintf</span>(conn-&gt;send_region, BUFFER_SIZE, <span class="string">"message from active/client side with pid %d"</span>, getpid());</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"connected. posting send...\n"</span>);</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">memset</span>(&amp;wr, <span class="number">0</span>, <span class="keyword">sizeof</span>(wr));</span><br><span class="line"> </span><br><span class="line">  wr.wr_id = (<span class="keyword">uintptr_t</span>)conn;</span><br><span class="line">  wr.opcode = IBV_WR_SEND;</span><br><span class="line">  wr.sg_list = &amp;sge;</span><br><span class="line">  wr.num_sge = <span class="number">1</span>;</span><br><span class="line">  wr.send_flags = IBV_SEND_SIGNALED;</span><br><span class="line"> </span><br><span class="line">  sge.addr = (<span class="keyword">uintptr_t</span>)conn-&gt;send_region;</span><br><span class="line">  sge.length = BUFFER_SIZE;</span><br><span class="line">  sge.lkey = conn-&gt;send_mr-&gt;lkey;</span><br><span class="line"> </span><br><span class="line">  TEST_NZ(ibv_post_send(conn-&gt;qp, &amp;wr, &amp;bad_wr));</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">on_disconnect</span><span class="params">(struct rdma_cm_id *id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">connection</span> *<span class="title">conn</span> = (<span class="title">struct</span> <span class="title">connection</span> *)<span class="title">id</span>-&gt;<span class="title">context</span>;</span></span><br><span class="line"> </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"disconnected.\n"</span>);</span><br><span class="line"> </span><br><span class="line">  rdma_destroy_qp(id);</span><br><span class="line"> </span><br><span class="line">  ibv_dereg_mr(conn-&gt;send_mr);</span><br><span class="line">  ibv_dereg_mr(conn-&gt;recv_mr);</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">free</span>(conn-&gt;send_region);</span><br><span class="line">  <span class="built_in">free</span>(conn-&gt;recv_region);</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">free</span>(conn);</span><br><span class="line"> </span><br><span class="line">  rdma_destroy_id(id);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">/* exit event loop */</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">on_event</span><span class="params">(struct rdma_cm_event *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (event-&gt;event == RDMA_CM_EVENT_ADDR_RESOLVED)</span><br><span class="line">    r = on_addr_resolved(event-&gt;id);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (event-&gt;event == RDMA_CM_EVENT_ROUTE_RESOLVED)</span><br><span class="line">    r = on_route_resolved(event-&gt;id);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (event-&gt;event == RDMA_CM_EVENT_ESTABLISHED)</span><br><span class="line">    r = on_connection(event-&gt;id-&gt;context);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (event-&gt;event == RDMA_CM_EVENT_DISCONNECTED)</span><br><span class="line">    r = on_disconnect(event-&gt;id);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    die(<span class="string">"on_event: unknown event."</span>);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">on_route_resolved</span><span class="params">(struct rdma_cm_id *id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rdma_conn_param</span> <span class="title">cm_params</span>;</span></span><br><span class="line"> </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"route resolved.\n"</span>);</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">memset</span>(&amp;cm_params, <span class="number">0</span>, <span class="keyword">sizeof</span>(cm_params));</span><br><span class="line">  TEST_NZ(rdma_connect(id, &amp;cm_params));</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/积累/" rel="tag"># 积累</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/09/26/msvc_unique_ptr源码/" rel="next" title="MSVC C++ STL 源码解析系列">
                <i class="fa fa-chevron-left"></i> MSVC C++ STL 源码解析系列
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/10/04/OpenMP参考文档/" rel="prev" title="OpenMP参考文档">
                OpenMP参考文档 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/header.jpg" alt="Hao Yu">
            
              <p class="site-author-name" itemprop="name">Hao Yu</p>
              <p class="site-description motion-element" itemprop="description">Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author</p>
          </div>
          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">281</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>
        	<audio controls="controls" loop="loop" preload="auto" src="/resource/xiaomeihao.mp3">
	        </audio>
	

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yuhao0102" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:yuh18@mails.tsinghua.edu.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#DMA和RDMA概念"><span class="nav-number">1.</span> <span class="nav-text">DMA和RDMA概念</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#DMA"><span class="nav-number">1.1.</span> <span class="nav-text">DMA</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RDMA"><span class="nav-number">1.2.</span> <span class="nav-text">RDMA</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RDMA的优势"><span class="nav-number">1.3.</span> <span class="nav-text">RDMA的优势</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RDMA-三种不同的硬件实现"><span class="nav-number">1.4.</span> <span class="nav-text">RDMA 三种不同的硬件实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RDMA基本术语"><span class="nav-number">1.5.</span> <span class="nav-text">RDMA基本术语</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Fabric"><span class="nav-number">1.5.1.</span> <span class="nav-text">Fabric</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CA-Channel-Adapter"><span class="nav-number">1.5.2.</span> <span class="nav-text">CA(Channel Adapter)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Verbs"><span class="nav-number">1.5.3.</span> <span class="nav-text">Verbs</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#核心概念"><span class="nav-number">1.6.</span> <span class="nav-text">核心概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Memory-Registration-MR-内存注册"><span class="nav-number">1.6.1.</span> <span class="nav-text">Memory Registration(MR) | 内存注册</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Queues-队列"><span class="nav-number">1.6.2.</span> <span class="nav-text">Queues | 队列</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RDMA数据传输"><span class="nav-number">1.7.</span> <span class="nav-text">RDMA数据传输</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#RDMA-Send-RDMA发送-接收-操作-（Send-Recv）"><span class="nav-number">1.7.1.</span> <span class="nav-text">RDMA Send | RDMA发送(/接收)操作 （Send/Recv）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RDMA-Read-RDMA读操作-Pull"><span class="nav-number">1.7.2.</span> <span class="nav-text">RDMA Read | RDMA读操作 (Pull)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RDMA-Write-RDMA写操作-Push"><span class="nav-number">1.7.3.</span> <span class="nav-text">RDMA Write | RDMA写操作 (Push)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RDMA-Write-with-Immediate-Data-支持立即数的RDMA写操作"><span class="nav-number">1.7.4.</span> <span class="nav-text">RDMA Write with Immediate Data | 支持立即数的RDMA写操作</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#RDMA-Send-Receive操作"><span class="nav-number">2.</span> <span class="nav-text">RDMA Send Receive操作</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#前言"><span class="nav-number">2.1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RDMA-Verbs操作"><span class="nav-number">2.2.</span> <span class="nav-text">RDMA Verbs操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Queue-Pairs"><span class="nav-number">2.3.</span> <span class="nav-text">Queue Pairs</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RDMA-Send-Receive"><span class="nav-number">2.4.</span> <span class="nav-text">RDMA Send/Receive</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#第一步"><span class="nav-number">2.4.1.</span> <span class="nav-text">第一步</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第二步"><span class="nav-number">2.4.2.</span> <span class="nav-text">第二步</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第三步"><span class="nav-number">2.4.3.</span> <span class="nav-text">第三步</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第四步"><span class="nav-number">2.4.4.</span> <span class="nav-text">第四步</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RDMA单边通信"><span class="nav-number">2.5.</span> <span class="nav-text">RDMA单边通信</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#RDMA-单边操作（RDMA-READ）"><span class="nav-number">2.5.1.</span> <span class="nav-text">RDMA 单边操作（RDMA READ）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RDMA-单边操作（RDMA-WRITE）"><span class="nav-number">2.5.2.</span> <span class="nav-text">RDMA 单边操作（RDMA WRITE）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RDMA-双边操作（RDMA-SEND-RECEIVE）"><span class="nav-number">2.5.3.</span> <span class="nav-text">RDMA 双边操作（RDMA SEND/RECEIVE）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">2.6.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#理解RDMA-SGL"><span class="nav-number">3.</span> <span class="nav-text">理解RDMA SGL</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#前言-1"><span class="nav-number">3.1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SGE简介"><span class="nav-number">3.2.</span> <span class="nav-text">SGE简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ivc-post-send接口"><span class="nav-number">3.3.</span> <span class="nav-text">ivc_post_send接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ibv-send-wr结构"><span class="nav-number">3.4.</span> <span class="nav-text">ibv_send_wr结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RDMA-提交WR流程"><span class="nav-number">3.5.</span> <span class="nav-text">RDMA 提交WR流程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#第一步：创建SGL"><span class="nav-number">3.5.1.</span> <span class="nav-text">第一步：创建SGL</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第二步：使用PD进行内存保护"><span class="nav-number">3.5.2.</span> <span class="nav-text">第二步：使用PD进行内存保护</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#调用ibv-post-send-将SGL发送到wire上去"><span class="nav-number">3.5.3.</span> <span class="nav-text">调用ibv_post_send()将SGL发送到wire上去</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#RDMA服务器的代码流程"><span class="nav-number">4.</span> <span class="nav-text">RDMA服务器的代码流程</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>
  <div id="DvelopmentTarget">     
  </div>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart" aria-hidden="false"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>

  
</div>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_uv"> 
  本站访客数<span id="busuanzi_value_site_uv"></span>人次
</span>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  


  

  


  <script type="text/javascript" src="/js/src/love.js"></script>

</body>
</html>
