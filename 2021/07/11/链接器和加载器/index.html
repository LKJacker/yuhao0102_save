<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zn-ch">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-center-simple.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="积累,">










<meta name="description" content="链接和加载链接器和加载器做什么？任何一个链接器和加载器的基本工作都非常简单：将更抽象的名字与更底层的名字绑定起来，好让程序员使用更抽象的名字编写代码。也就是说，它可以将程序员写的一个诸如getline 的名字绑定到“iosys模块内可执行代码的 612 字节处”或者可以采用诸如“这个模块的静态数据开始的第 450 个字节处”这样更抽象的数字地址然后将其绑定到数字地址上。 地址绑定：从历史的角度随着">
<meta name="keywords" content="积累">
<meta property="og:type" content="article">
<meta property="og:title" content="链接器和加载器">
<meta property="og:url" content="http://yoursite.com/2021/07/11/链接器和加载器/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="链接和加载链接器和加载器做什么？任何一个链接器和加载器的基本工作都非常简单：将更抽象的名字与更底层的名字绑定起来，好让程序员使用更抽象的名字编写代码。也就是说，它可以将程序员写的一个诸如getline 的名字绑定到“iosys模块内可执行代码的 612 字节处”或者可以采用诸如“这个模块的静态数据开始的第 450 个字节处”这样更抽象的数字地址然后将其绑定到数字地址上。 地址绑定：从历史的角度随着">
<meta property="og:locale" content="zn-ch">
<meta property="og:updated_time" content="2021-08-18T07:53:25.342Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="链接器和加载器">
<meta name="twitter:description" content="链接和加载链接器和加载器做什么？任何一个链接器和加载器的基本工作都非常简单：将更抽象的名字与更底层的名字绑定起来，好让程序员使用更抽象的名字编写代码。也就是说，它可以将程序员写的一个诸如getline 的名字绑定到“iosys模块内可执行代码的 612 字节处”或者可以采用诸如“这个模块的静态数据开始的第 450 个字节处”这样更抽象的数字地址然后将其绑定到数字地址上。 地址绑定：从历史的角度随着">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2021/07/11/链接器和加载器/">





  <title>链接器和加载器 | Hao Yu's blog</title>
  








 
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zn-ch">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hao Yu's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">The program monkey was eaten by the siege lion.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/resume.pdf" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-mybetterhalf">
          <a href="/mybetterhalf/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>
            
            mybetterhalf
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/07/11/链接器和加载器/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">链接器和加载器</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-07-11T19:00:00+08:00">
                2021-07-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="链接和加载"><a href="#链接和加载" class="headerlink" title="链接和加载"></a>链接和加载</h1><h2 id="链接器和加载器做什么？"><a href="#链接器和加载器做什么？" class="headerlink" title="链接器和加载器做什么？"></a>链接器和加载器做什么？</h2><p>任何一个链接器和加载器的基本工作都非常简单：将更抽象的名字与更底层的名字绑定起来，好让程序员使用更抽象的名字编写代码。也就是说，它可以将程序员写的一个诸如getline 的名字绑定到“iosys模块内可执行代码的 612 字节处”或者可以采用诸如“这个模块的静态数据开始的第 450 个字节处”这样更抽象的数字地址然后将其绑定到数字地址上。</p>
<h2 id="地址绑定：从历史的角度"><a href="#地址绑定：从历史的角度" class="headerlink" title="地址绑定：从历史的角度"></a>地址绑定：从历史的角度</h2><p>随着操作系统的出现，有必要将可重定位的加载器从链接器和库中分离出来。在操作系统将程序加载到内存之前是无法确定程序运行的确切地址的，并将最终的地址绑定从链接时推延到了加载时。现在链接器和加载器已经将这个工作划分开了，链接器对每一个程序的部分地址进行绑定并分配相对地址，加载器完成最后的重定位步骤并赋予的实际地址。</p>
<p>随着计算机系统变得越来愈复杂，链接器被用来做了更多、更复杂的名字管理和地址绑定的工作。Fortran 程序使用了多个子程序和公共块（被多个子程序共享的数据区域），而它是由链接器来为这些子程序和公共数据块进行存储布局和地址分配的。逐渐地链接器还需要处理目标代码库。包括用 Fortran 或其它语言编写的应用程序库，并且编译器也支持那些可以从被编译好的处理 I/O 或其它高级操作的代码中隐含调用的库。</p>
<p>由于程序很快就变得比可用的内存大了，因此链接器提供了覆盖技术，它可以让程序员安排程序的不同部分来分享相同的内存，当程序的某一部分被其它部分调用时可以按需加载。</p>
<p>随着硬件重定位和虚拟内存的出现，每一个程序可以再次拥有整个地址空间，因此链接器和加载器变得不那么复杂了。由于硬件（而不是软件）重定位可以对任何加载时重定位进行处理，程序可以按照被加载到固定地址的方式来链接。编译器和汇编器可以被修改为在多个段内创建目标代码，为只读代码分配一个段，为别的可写数据分配其它段。链接器必须能够将相同类型的所有段都合并在一起，以使得被链接程序的所有代码都放置在一个地方，而所有的数据放在另一个地方。由于地址仍然是在链接时被分配的，因此和之前相比并不能延迟地址绑定的时机，但更多的工作被延迟到了链接器为所有段分配地址的时候。</p>
<p>在较简单的静态共享库中，每个库在创建时会被绑定到特定的地址，链接器在链接时将程序中引用的库例程绑定到这些特定的地址。由于当静态库中的任何部分变化时程序都需要被重新链接，而且创建静态链接库的细节也是非常冗长乏味的，因此静态链接库实际上很麻烦死板。故又出现了动态链接库，使用动态链接库的程序在开始运行之前不会将所用库中的段和符号绑定到确切的地址上。有时这种绑定还会更为延迟：在完全的动态链接中，被调用例程的地址在第一次调用前都不会被绑定。此外在程序运行过程中也可以加载库并进行绑定。这提供了一种强大且高性能的扩展程序功能的方法。</p>
<h2 id="链接与加载"><a href="#链接与加载" class="headerlink" title="链接与加载"></a>链接与加载</h2><p>链接器和加载器完成几个相关但概念上不同的动作。</p>
<ul>
<li>程序加载：将程序从辅助存储设备拷贝到主内存中准备运行。在某些情况下，加载仅仅是将数据从磁盘拷入内存；在其他情况下，还包括分配存储空间，设置保护位或通过虚拟内存将虚拟地址映射到磁盘内存页上。</li>
<li>重定位：编译器和汇编器通常为每个文件创建程序地址从 0 开始的目标代码，但是几乎没有计算机会允许从地址 0 加载你的程序。如果一个程序是由多个子程序组成的，那么所有的子程序必须被加载到互不重叠的地址上。重定位就是为程序不同部分分配加载地址，调整程序中的数据和代码以反映所分配地址的过程。在很多系统中，重定位不止进行一次。</li>
<li>符号解析：当通过多个子程序来构建一个程序时，子程序间的相互引用是通过符号进行的；主程序可能会调用一个名为 sqrt 的计算平方根例程，并且数学库中定义了sqrt 例程。链接器通过标明分配给 sqrt 的地址在库中来解析这个符号，并通过修改目标代码使得 call 指令引用该地址。</li>
</ul>
<p>尽管有相当一部分功能在链接器和加载器之间重叠，定义一个仅完成程序加载的程序为加载器，一个仅完成符号解析的程序为链接器是合理的。他们任何一个都可以进行重定位，而且曾经也出现过集三种功能为一体的链接加载器。</p>
<p>重定位和符号解析的划分界线是模糊的。由于链接器已经可以解析符号的引用，一种处理代码重定位的方法就是为程序的每一部分分配一个指向基址的符号，然后将重定位地址认为是对该基址符号的引用。</p>
<p>链接器和加载器共有的一个重要特性就是他们都会修改目标代码，他们也许是唯一比调试程序在这方面应用更为广泛的程序。这是一个独特而强大的特性，而且细节非常依赖于机器的规格，如果做错的话就会引发令人困惑的 bug。</p>
<h2 id="两遍链接"><a href="#两遍链接" class="headerlink" title="两遍链接"></a>两遍链接</h2><p>链接基本上也是一个两遍的过程。链接器将一系列的目标文件、库、及可能的命令文件作为它的输入，然后将输出的目标文件作为产品结果，此外也可能有诸如加载映射信息或调试器符号文件的副产品。</p>
<p>每个输入文件都包含一系列的段（segments），即会被连续存放在输出文件中的代码或数据块。每一个输入文件至少还包含一个符号表（symbol table）。有一些符号会作为导出符号，他们在当前文件中定义并在其他文件中使用，通常都是可以在其它地方被调用的当前文件内例程的名字。其它符号会作为导入符号，在当前文件中使用但不在当前文件中定义，通常都是在该文件中调用但不存在于该文件中的例程的名字。</p>
<p>当链接器运行时，会首先对输入文件进行扫描，得到各个段的大小，并收集对所有符号的定义和引用。它会创建一个列出输入文件中定义的所有段的段表，和包含所有导出、导入符号的符号表。</p>
<p>利用第一遍扫描得到的数据，链接器可以为符号分配数字地址，决定各个段在输出地址空间中的大小和位置，并确定每一部分在输出文件中的布局。</p>
<p>第二遍扫描会利用第一遍扫描中收集的信息来控制实际的链接过程。它会读取并重定位目标代码，为符号引用替换数字地址，调整代码和数据的内存地址以反映重定位的段地址，并将重定位后的代码写入到输出文件中。通常还会再向输出文件中写入文件头部信息，重定位的段和符号表信息。如果程序使用了动态链接，那么符号表中还要包含运行时链接器解析动态符号时所需的信息。在很多情况下，链接器自己将会在输出文件中生成少量代码或数据，例如用来调用覆盖中或动态链接库中的例程的“胶水代码”，或在程序启动时需要被调用的指向各初始化例程的函数指针数组。</p>
<p>有些目标代码的格式是可以重链接的，也就是一次链接器运行的输出文件可以作为下次链接器运行的输入。这要求输出文件要包含一个像输入文件中那样的符号表，以及其它会出现在输入文件中的辅助信息。</p>
<p>几乎所有的目标代码格式都预备有调试符号，这样当程序在调试器控制下运行时，调试器可以使用这些符号让程序员通过源代码中的行号或名字来控制程序。</p>
<h2 id="目标代码库"><a href="#目标代码库" class="headerlink" title="目标代码库"></a>目标代码库</h2><p>所有的链接器都会以这样或那样的形式来支持目标代码库，同时它们中的大多数还会支持各种各样的共享库。目标代码库的基本原则是很非常简单的。一个库不比一些目标代码文件的集合复杂多少。当链接器处理完所有规则的输入文件后，如果还存在未解析的导入名称（imported name），它就会查找一个或多个库，然后将输出这些未解析名字的库中的任何文件链接进来。</p>
<p>由于链接器将部分工作从链接时推迟到了加载时，使这项任务稍微复杂了一些。在链接器运行时，链接器会识别出解析未定义符号所需的共享库，但是链接器会在输出文件中标明用来解析这些符号的库名称，而不是在链接时将他们链入程序，这样可以在程序被加载时进行共享库绑定。</p>
<h2 id="重定位和代码修改"><a href="#重定位和代码修改" class="headerlink" title="重定位和代码修改"></a>重定位和代码修改</h2><p>链接器和加载器的核心动作是<strong>重定位</strong>和<strong>代码修改</strong>。当编译器或汇编器产生一个目标代码文件时，它使用文件中定义的未重定位代码地址和数据地址来生成代码，对于其它地方定义的数据或代码通常就是 0。作为链接过程的一部分，链接器会修改目标代码以反映实际分配的地址。例如，考虑如下这段将变量 a 中的内容通过寄存器 eax 移动到变量 b 的 x86 代码片段。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov a，%eax</span><br><span class="line">mov %eax，b</span><br></pre></td></tr></table></figure></p>
<p>如果 a 定义在同一文件的位置 0x1234，而 b 是从其它地方导入的，那么生成的代码将会是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A1 34 12 00 00 mov a，%eax</span><br><span class="line">A3 00 00 00 00 mov %eax，b</span><br></pre></td></tr></table></figure></p>
<p>每条指令包含了一个字节的操作码和其后 4 个字节的地址。第一个指令有对地址 1234的引用（由于 x86 使用从右向左的字节序，因此这里是序），而第二个指令由于 b 的位置是未知的因此引用位置为 0。</p>
<p>现在想象链接器将这段代码进行链接，a 所属段被重定位到了 0x10000，b 最终位于地址 0x9A12。则链接器会将代码修改为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A1 34 12 01 00 mov a，%eax</span><br><span class="line">A3 12 9A 00 00 mov %eax，b</span><br></pre></td></tr></table></figure></p>
<p>也就是说，链接器将第一条指令中的地址加上 0x10000，现在它所标识的 a 的重定位地址就是 0x11234，并且也补上了 b 的地址。虽然这些调整影响的是指令，但是目标文件中数据部分任何相关的指针也必须修改。</p>
<p>有些系统需要无论加载到什么位置都可以正常工作的位置无关代码。链接器需要提供额外的技巧来支持位置无关代码，与程序中无法做到位置无关的部分隔离开来，并设法使这两部分可以互相通讯。</p>
<h2 id="编译器驱动"><a href="#编译器驱动" class="headerlink" title="编译器驱动"></a>编译器驱动</h2><p>很多情况下，链接器所进行的操作对程序员是几乎或完全不可见的，因为它会做为编译过程的一部分自动进行。多数编译系统都有一个可以按需自动执行编译器各个阶段的编译器驱动。例如，若一个程序员有两个 C 源程序文件（简称 A，B），那么在 UNIX 系统上编译器驱动将会运行如下一系列的程序：</p>
<ul>
<li>C 语言预处理器处理 A，生成预处理的 A</li>
<li>C 语言编译预处理的 A，生成汇编文件 A</li>
<li>汇编器处理汇编文件 A，生成目标文件 A</li>
<li>C 语言预处理器处理 B，生成预处理的 B</li>
<li>C 语言编译预处理的 B，生成汇编文件 B</li>
<li>汇编器处理汇编文件 B，生成目标文件 B</li>
<li>链接器将目标文件 A、B 和系统 C 库链接在一起</li>
</ul>
<p>也就是说，编译器驱动首先会将每个源文件编译为汇编语言，然后转换为目标代码，接着链接器会将目标代码链接器一起，并包含任何需要的系统 C 库例程。</p>
<p>编译器驱动通常要比这聪明的多，他们会比较源文件和目标代码文件的时间，仅编译那些被修改过的源文件（UNIX make 程序就是典型的例子）。</p>
<h2 id="链接器命令语言"><a href="#链接器命令语言" class="headerlink" title="链接器命令语言"></a>链接器命令语言</h2><p>每个链接器都有某种形式的命令语言来控制链接过程。最起码链接器需要记录所链接的目标代码和库的列表。通常都会有一大长串可能的选项：在哪里放置调试符号，在哪里使用共享或非共享库，使用哪些可能的输出格式等。多数链接器都允许某些方法来指定被链接代码将要绑定的地址，这在链接一个系统内核或其它没有操作系统控制的程序时就会用到。在支持多个代码和数据段的链接器中，链接器命令语言可以对链接各个段的顺序、需要特殊处理的段和某些应用程序相关的选项进行指定。</p>
<p>有四种常见技术向链接器传送指令：</p>
<ul>
<li>命令行：多数系统都会有命令行（或相似功能的其它程序），通过它可以输入各种文件名和开关选项。这对于 UNIX 和 Windows 链接器是很常用的方法。</li>
<li>与目标文件混在一起：有些链接器从一个单个输入文件中接受替换的目标文件及链接器命令。</li>
<li>嵌入在目标文件中：有一些目标代码格式，允许将链接器命令嵌入到目标文件中。这就允许编译器将链接一个目标文件时所需要的任何选项通过文件自身来传递。例如 C 编译器将搜索标准 C 库的命令嵌入到文件中（来传递给链接过程）。</li>
<li>单独的配置语言：极少有链接器拥有完备的配置语言来控制链接过程。可以处理众多目标文件类型、机器体系架构和地址空间规定的 GNU 链接器，拥有可以让程序员指定段链接顺序、合并相近段规则、段地址和大量其它选项的一套复杂的控制语言。</li>
</ul>
<h2 id="链接：一个真实的例子"><a href="#链接：一个真实的例子" class="headerlink" title="链接：一个真实的例子"></a>链接：一个真实的例子</h2><p>我们通过一个简小的链接实例来结束对链接过程的介绍。图 3 所示为一对 C 语言源代码文件，m.c 中的主程序调用了一个名为 a 的例程，而调用了库例程 strlen 和 write 的 a 例程在 a.c 中。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">(<span class="keyword">char</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> ac， <span class="keyword">char</span> **av)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">char</span> <span class="built_in">string</span>[] = <span class="string">"Hello， world!\n"</span>;</span><br><span class="line">	a(<span class="built_in">string</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>源程序 a.c<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">a</span><span class="params">(<span class="keyword">char</span> *s)</span> </span>&#123;</span><br><span class="line">	write(<span class="number">1</span>, s, <span class="built_in">strlen</span>(s));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>主程序 m.c 用 gcc 编译成一个典型 a.out 目标代码格式长度为 165 字节的目标文件。该目标文件包含一个固定长度的头部，16 个字节的“文本”段，包含只读的程序代码，16 个字节的数据段，包含字符串。其后是两个重定位项，其中一个标明 pushl 指令将字符串 string 的地址放置在栈上为调用例程 a 作准备，另一个标明 call 指令将控制转移到例程 a。符号表分别导出和导入了 _main 与_a 的定义，以及调试器需要的其它一系列符号。注意由于和字符串 string 在同一个文件中，pushl 指令引用了 string 的临时地址 0x10，而由于_a 的地址是未知的所以 call 指令引用的地址为 0x0。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Sections:</span><br><span class="line">Idx Name  Size     VMA      LMA      File off Algn</span><br><span class="line">0   .text 00000010 00000000 00000000 00000020 2**3</span><br><span class="line">1   .data 00000010 00000010 00000010 00000030 2**3</span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">00000000 &lt;_main&gt;:</span><br><span class="line">0：55             pushl %ebp</span><br><span class="line">1：89 e5          movl %esp，%ebp</span><br><span class="line">3：68 10 00 00 00 pushl $0x10</span><br><span class="line">4：32             .data</span><br><span class="line">8：e8 f3 ff ff ff call 0</span><br><span class="line">9：DISP32 _a</span><br><span class="line">d：c9 leave</span><br><span class="line">e：c3 ret</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>子程序文件 a.c 编译成一个长度为 160 字节的目标文件，包括头部， 28字节的文本段，无数据段。两个重定位项标记了对 strlen 和 write 的 call 指令，符号表中导出_a 并导入了_strlen 和_write。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Sections:</span><br><span class="line">Idx Name  Size     VMA      LMA      File off Algn</span><br><span class="line">0   .text 0000001c 00000000 00000000 00000020 2**2</span><br><span class="line">          CONTENTS， ALLOC， LOAD， RELOC， CODE</span><br><span class="line">1   .data 00000000 0000001c 0000001c 0000003c 2**2</span><br><span class="line">          CONTENTS， ALLOC， LOAD， DATA</span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">00000000 &lt;_a&gt;:</span><br><span class="line">0：55              pushl %ebp</span><br><span class="line">1：89 e5           movl %esp，%ebp</span><br><span class="line">3：53              pushl %ebx</span><br><span class="line">4：8b 5d 08        movl 0x8(%ebp)，%ebx</span><br><span class="line">7：53              pushl %ebx</span><br><span class="line">8：e8 f3 ff ff ff  call 0</span><br><span class="line">9：DISP32 _strlen</span><br><span class="line">d：50              pushl %eax</span><br><span class="line">e：53              pushl %ebx</span><br><span class="line">f：6a 01           pushl $0x1</span><br><span class="line">11：e8 ea ff ff ff call 0</span><br><span class="line">12：DISP32 _write</span><br><span class="line">16：8d 65 fc       leal -4(%ebp)，%esp</span><br><span class="line">19：5b             popl %ebx</span><br><span class="line">1a：c9             leave</span><br><span class="line">1b：c3             ret</span><br></pre></td></tr></table></figure></p>
<p>为了产生一个可执行程序，链接器将这两个目标文件，以及一个标准的 C 程序启动初始化例程，和必要的 C 库例程整合到一起，产生一个部分如下所示的可执行文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">Sections:</span><br><span class="line">Idx Name Size     VMA      LMA      File off Algn</span><br><span class="line">0  .text 00000fe0 00001020 00001020 00000020 2**3</span><br><span class="line">1  .data 00001000 00002000 00002000 00001000 2**3</span><br><span class="line">2  .bss  00000000 00003000 00003000 00000000 2**3</span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">00001020 &lt;start-c&gt;:</span><br><span class="line">...</span><br><span class="line">1092：e8 0d 00 00 00 call 10a4 &lt;_main&gt;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">000010a4 &lt;_main&gt;:</span><br><span class="line">10a4：55             pushl %ebp</span><br><span class="line">10a5：89 e5          movl %esp，%ebp</span><br><span class="line">10a7：68 24 20 00 00 pushl $0x2024</span><br><span class="line">10ac：e8 03 00 00 00 call 10b4 &lt;_a&gt;</span><br><span class="line">10b1：c9             leave</span><br><span class="line">10b2：c3             ret</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">000010b4 &lt;_a&gt;:</span><br><span class="line">10b4：55             pushl %ebp</span><br><span class="line">10b5：89 e5          movl %esp，%ebp</span><br><span class="line">10b7：53             pushl %ebx</span><br><span class="line">10b8：8b 5d 08       movl 0x8(%ebp)，%ebx</span><br><span class="line">10bb：53             pushl %ebx</span><br><span class="line">10bc：e8 37 00 00 00 call 10f8 &lt;_strlen&gt;</span><br><span class="line">10c1：50             pushl %eax</span><br><span class="line">10c2：53             pushl %ebx</span><br><span class="line">10c3：6a 01          pushl $0x1</span><br><span class="line">10c5：e8 a2 00 00 00 call 116c &lt;_write&gt;</span><br><span class="line">10ca：8d 65 fc       leal -4(%ebp)，%esp</span><br><span class="line">10cd：5b             popl %ebx</span><br><span class="line">10ce：c9             leave</span><br><span class="line">10cf：c3             ret</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">000010f8 &lt;_strlen&gt;:</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">0000116c &lt;_write&gt;:</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>链接器将每个输入文件中相应的段合并在一起，故只存在一个合并后的文本段，一个合并后的数据段和一个 bss 段。由于每个段都会被填充为 4K 对齐以满足 x86 的页尺寸，因此文本段为 4K（减去文件中 20 字节长度的 a.out 头部，逻辑上它并不属于该段），数据段和 bss 段每个同样也是 4K 字节。</p>
<p>合并后的文本段包含名为 start-c 的库启动代码，由 m.o 重定位到 0x10a4 的代码，重定位到 0x10b4 的 a.o，以及被重定位到文本段更高地址从 C 库中链接来的例程。数据段，没有显示在这里，按照和文本段相同的顺序包含了合并后的数据段。由于_main 的代码被重定位到地址 0x10a4，所以这个代码要被修改到 start-c 代码的 call 指令中。在 main 例程内部，对字符串 string 的引用被重定位到 0x2024，这是 string 在数据段最终的位置，并且 call指令中地址修改为 0x10b4，这是_a 最终确定的地址。在_a 内部，对_strlen 和_write 的 call 指令也要修改为这两个例程的最终地址。</p>
<p>可执行程序中仍然有很多其它的 C 库例程，没有显示在这里，它们由启动代码和_write直接或间接的调用。由于可执行程序的文件格式不是可以重链接的，且操作系统从已知的固定位置加载它，因此它不包含重定位数据。它带有一个有助于调试器（debugger）工作的符号表，尽管这个程序没有使用这个符号表并且可以将其删除以节省空间。</p>
<h1 id="体系结构的问题"><a href="#体系结构的问题" class="headerlink" title="体系结构的问题"></a>体系结构的问题</h1><p>硬件体系结构的两个方面影响到链接器：程序寻址和指令格式。链接器需要做的事情之一就是对数据和指令中的地址及偏移量都要进行修改。两种情况下链接器都必须确保所做的修改符合计算机使用的寻址方式；当修改指令时还需要进一步确保修改结果不能是无效指令。</p>
<h2 id="应用程序二进制接口"><a href="#应用程序二进制接口" class="headerlink" title="应用程序二进制接口"></a>应用程序二进制接口</h2><p>每个操作系统都会为运行在该系统下的应用程序提供应用程序二进制接口（Application Binary Interface）。ABI 包含了应用程序在这个系统下运行时必须遵守的编程约定。ABI总是包含一系列的系统调用和使用这些系统调用的方法，以及关于程序可以使用的内存地址和使用机器寄存器的规定。从一个应用程序的角度看，ABI 既是系统架构的一部分也是硬件体系结构的重点，因此只要违反二者之一的条件约束就会导致程序出现严重错误。</p>
<h2 id="内存地址"><a href="#内存地址" class="headerlink" title="内存地址"></a>内存地址</h2><p>计算机系统都有主存储器。主存总是表现为一块连续的存储空间，每一个存储位置都有一个数字地址。这个地址从 0 开始，并逐渐增长为某个较大的数字（由地址中的位数决定）。</p>
<h3 id="字节顺序和对齐"><a href="#字节顺序和对齐" class="headerlink" title="字节顺序和对齐"></a>字节顺序和对齐</h3><p>由于计算机处理的大多数数据，尤其是程序地址，都是大于 8 位的，所以通过将相邻的字节合为一组，计算机同样可以很好的处理 16 位、32 位、64 位或 128 位的数据。在某些计算机上，尤其是 IBM 和 Motorola，多字节数据的第一个字节（数字地址最低）是高位字节（most significant byte），在其它诸如 DEC 和 Intel 的机器上，第一个字节是低位字节（least significant byte）。</p>
<p>多字节数据通常会被对齐到一些“天生”的边界上。就是说，4 字节的数据必须对齐到4 字节的边界上，2 字节要对齐到 2 字节的边界上，并以此类推。另一种想法就是任何 N 字节数据的地址至少要有 log2(N)个低位为 0。即使在那些引用未对齐数据不会导致故障的系统上，性能的损失也是非常大的，以至于值得我们花费精力来尽可能保持地址的对齐。</p>
<p>很多处理器同样要求程序指令的对齐。多数 RISC 芯片要求指令必须对齐在 4 字节的边界上。</p>
<p>每种体系结构都定义了一系列的寄存器，这是可以由程序指令直接引用的数量很少的固定长度高速存储区域。各种体系结构的寄存器数量是变化的，从 x86 架构的 8 个到某些 RISC 设计的 32 个，寄存器的容量几乎都是和程序地址的大小相同，就是说在一个 32 位地址的系统中寄存器是 32 位的，而在具有 64 位地址的系统上，寄存器就是 64 位的了。</p>
<h2 id="地址构成"><a href="#地址构成" class="headerlink" title="地址构成"></a>地址构成</h2><p>当计算机程序执行时，会根据程序中的指令来读写内存。程序的指令本身也存储在内存中，但通常和程序的数据位于内存中不同的部分。</p>
<p>指令在逻辑上是按照存储的顺序被执行的，但通过指定程序中新的地址来执行的跳转指令是例外。每个指令中引用的数据内存地址，每个跳转指令引用的地址，要被加载或存储的数据的地址，或指令要跳转到的地址等，计算机们具有一系列的指令格式和地址构成需要链接器在重定位指令中的地址时予以处理。</p>
<h2 id="指令格式"><a href="#指令格式" class="headerlink" title="指令格式"></a>指令格式</h2><p>每条指令都包含一个操作码，它决定了指令做什么，此外还有一个操作数。操作数可以被编码到指令本身（立即操作数），或者放置在内存中。内存中每个操作数的地址总要经过一些计算。有时地址包含在指令中（直接寻址）。更经常的是地址存储在某一个寄存器中（寄存器间接寻址），或通过将指令中的一个常量加上寄存器中的内容计算得来。如果寄存器中的值是一个存储区域的地址，而指令中的常量是存储区域中想要访问的数据的偏移量，这种策略称为基址寻址。如果二者调换过来，并且寄存器中保存的是偏移量，那这种策略就是索引寻址。基址寻址与索引寻址之间的区别不那么好定义，而且很多体系结构都将他们混在一起了。</p>
<p>还有其它更为复杂的地址计算方法也仍在使用中，但是由于它们不包含链接器需要调整的域，因此链接器的多数组成部分都不需为此担心。一些体系结构使用固定长度的指令，而另一些使用变长指令。所有的 SPARC 指令都是 4字节长，并对齐到 4 字节边界。IBM 370 的指令可以是 2、4 或 6 个字节长，指令的头一个字节的头 2 位确定了指令的长度和格式。Intel x86 的指令格式随时都可以是 1 到 14 个字节长。</p>
<h2 id="过程调用和可寻址性"><a href="#过程调用和可寻址性" class="headerlink" title="过程调用和可寻址性"></a>过程调用和可寻址性</h2><p>计算机的架构师们在地址引用指令中部分或彻底的放弃了直接寻址，使用索引和基址寄存器来提供寻址所需的大部分或全部地址位。这可以让指令短一些，但与之而来的代价是编程更复杂了。</p>
<p>在没有采用直接寻址的体系结构中，程序在进行数据寻址时存在一个“自举”的问题：一个例程要使用寄存器中的基地址来计算数据地址，但是将基址从内存中加载到寄存器中的标准方法是从存有另一个基址的寄存器中寻址。自举问题就是如何在程序开始时将第一个基地址载入到寄存器中，随后再确保每一个例程都拥有它需要的基地址来寻址它要使用的数据。</p>
<h2 id="过程调用"><a href="#过程调用" class="headerlink" title="过程调用"></a>过程调用</h2><p>每种 ABI 都通过将硬件定义的调用指令与内存、寄存器的使用约定组合起来定义了一个标准的过程调用序列。硬件的调用指令保存了返回地址（调用执行后的指令地址）并跳转到目标过程。在诸如 x86 这样具有硬件栈的体系结构中返回地址被压入栈中，而在其它体系结构中它会被保存在一个寄存器里，如果必要软件要负责将寄存器中的值保存在内存中。具有栈的体系结构通常都会有一个硬件的返回指令将返回地址推出栈并跳转到该地址，而其它体系结构则使用一个“跳转到寄存器中地址”的指令来返回。</p>
<p>在一个过程的内部，数据寻址可分为 4 类：</p>
<ul>
<li>调用者可以向过程传递参数。</li>
<li>本地变量在过程中分配，并在过程返回前释放。</li>
<li>本地静态数据保存在内存的固定位置中，并为该过程私有。</li>
<li>全局静态数据保存在内存的固定位置中，并可被很多不同过程引用。</li>
</ul>
<p>为每个过程调用分配的一块栈内存称为“栈框架（stack frame）”。</p>
<p>参数和本地变量通常在栈中分配空间，某一个寄存器可以作为栈指针，它可以基址寄存器来使用。SPARC 和 x86 中使用了该策略的一种比较普遍的变体，在一个过程开始的时候，会从栈指针中加载专门的框架指针或基址指针寄存器。这样就可以在栈中压入可变大小的对象，将栈指针寄存器中的值改变为难以预定的值。如果假定栈是从高地址向低地址生长的，而框架指针指向返回地址保存在内存中的位置，那么参数就位于框架指针较小的正偏移量处，本地变量在负偏移量处。由于操作系统通常会在程序启动前为其初始化栈指针，所以程序只需要在将输入压栈或推栈时更新寄存器即可。</p>
<p>对于局部和全局静态数据，编译器可以为一个例程引用的所有静态变量创建一个指针表。如果某个寄存器存有指向这个表的指针，那么例程可以通过使用表指针寄存器将对象在表中的指针读取出来，加载到另一个使用表指针寄存器作为基址的寄存器中，并将第二个寄存器做为基址寄存器来寻址任何想要访问的静态目标。因此，关键技巧是表的地址存入到第一个寄存器中。一个解决方法是将提取表指针的工作交给例程的调用者，因为调用者已经加载了自己的表指针，并可以从自己的表中获取被调用例程的表的指针。</p>
<p>很多情况下，在一个模块中的所有例程会共享一个指针表，这时模块内的调用不需要改变表指针。SPARC 的约定是整个模块共享一个由链接器创建的表，这样表指针寄存器可以在模块内调用时保持不变。同一模块内的调用可以通过一个将被调用例程的偏移量编码到指令中的调用指令实现，这就不需要再将被调用例程的地址加载到寄存器中了。在所有这些优化中，同一模块中对某个例程的调用序列缩减为一个单独的调用指令。又回到地址自举的问题了，这个表指针的链最初是怎么开始的呢？主例程的表可能存储在一个固定的位置，或初始指针值被标注在可执行文件中这样操作系统可以在程序开始前加载它。无论使用的是什么技术，都是需要链接器的帮助的。</p>
<h2 id="分页和虚拟内存"><a href="#分页和虚拟内存" class="headerlink" title="分页和虚拟内存"></a>分页和虚拟内存</h2><p>在多数现代计算机系统中，每个程序都可以寻址数量巨大的内存，在一个典型的 32 位系统中这通常是 4GB。很少有机器有那么大的内存，即使有它也需要将其在多个程序之间共享。分页硬件将一个程序的地址空间划分为大小固定的页，典型的大小是 2K 或 4K，同时将计算机的物理内存划分为同样大小的页框。硬件包含了由地址空间中各个页对应的页表项组成的多个页表。</p>
<p>一个页表项可以包含针对某个页的实际内存页框，或通过标志位标注该页“不存在”。当应用程序尝试使用一个不存在的页时，硬件会产生一个由操作系统处理的“页失效”错误。操作系统可以将页的内容从磁盘上复制到一个空闲的内存页框中，并让应用程序继续运行。通过按需将页在内存和磁盘之间移动，操作系统可以提供“虚拟内存”的功能，这样从应用程序看来使用的是比实际大的多的内存。</p>
<p>如果页可以被标注为只读，那么也会提升性能。由于只读页可以重新加载因此它们不需要调出页的操作。如果某个页逻辑上出现在多个地址空间中，一个单独的物理页就可以满足所有的地址空间。</p>
<p>对于 32 位寻址和使用 4K 页的 x86，需要一个具有 2^20个项的页表来覆盖整个地址空间。由于每个页表项通常为 4 字节，这会使页表的大小变成不切实际的 4MB。因此，可分页的架构会通过将高层次页表指向那些最终映射到虚拟地址所对应的物理页框的低层次页表来实现对页表的再次分页。在 370 上，高层次页表（被称为段表）的每一项映射 1MB 的地址空间，这样段表在 31 位地址模式时可以包含 2048 项。如果整个段都不存在的话，那么段表中的每一项都可以是空，否则就会指向将页映射到那个段上的低层次页表。每一个低层次页表共有256 个页表项，每一个对应段中 4K 的内存块。虽然对齐的边界略有差别，但 x86 使用类似的方式划分它的页表。每一个高层次页表（称为页目录）映射 4MB 的地址空间，这样高层次页表共有 1024 项。每一个低层次的页表同样包含 1024 项去映射和该页表对应的 4MB 地址空间中的 1024 个 4K 页。</p>
<h2 id="程序地址空间"><a href="#程序地址空间" class="headerlink" title="程序地址空间"></a>程序地址空间</h2><p>每个程序都运行在一个由计算机硬件和操作系统共同定义的地址空间中。链接器和加载器需要生成与这个地址空间匹配的可运行程序。</p>
<p>最简单的地址空间是由 PDP-11 版本的 UNIX 提供的。该地址空间为从 0 开始的 64K 字节。程序的只读代码从位置 0 加载，可读写的数据跟在代码的后面。PDP-11 具有 8K 的页，所以数据从代码后 8K 对齐的地方开始。栈向下生长，从 64K-1 的地方开始，随着栈和数据的增长，对应的区域会变大：当它们相遇时程序就没有可用的地址空间了。</p>
<p>接着 PDP-11 出现的 VAX 版本的 UNIX，使用了相似的策略。每一个 VAX 的 UNIX 程序的头两个字节都是 0（这是一个表明不保存任何东西的寄存器保存掩码）。因此，一个全 0 的空指针总是有效的，并且如果一个 C 程序将空值作为一个字串指针，那么位置 0 的零字节将会当作空字串对待。由于这个原因，上世纪 80 年代的 UNIX 由于空指针的原因包含有很多难以发现的 bug。</p>
<p>Unix 系统将每个程序都放置在单独的地址空间中，而操作系统运行在与应用程序在逻辑上隔离的地址空间中。那些将多个程序放在相同地址空间的操作系统，由于程序的实际加载地址只有在程序运行时才能确定，因此就使得链接器和加载器（尤其是加载器）的工作更为复杂。x86 上的 MS-DOS 系统不使用硬件保护，所以系统和应用程序共享同一个地址空间。当系统运行一个程序的时，它会查找最大的空闲内存块（可能会位于地址空间的任何位置），将程序加载到其中，然后运行它。</p>
<p>MS Windows 采用了一种特殊的加载策略。每个程序按照被加载到一个标准开始地址的方式来链接，但是在可执行程序中带有重定位信息。当 Windows 加载这个程序时，如果可能的话它就将程序放置在这个起始地址处，但如果这个地不可用那就会将它加载到其它地方。</p>
<h2 id="映射文件"><a href="#映射文件" class="headerlink" title="映射文件"></a>映射文件</h2><p>虚拟内存系统在真实内存和硬盘之间来回移动数据，当数据无法保存在内存中时就会将它交换到磁盘上。最初，交换出来的页面都是保存在独立于文件系统名字空间的单独匿名磁盘空间上的。换页发明之后不久，设计者们发现通过让换页系统读写命名的磁盘文件可以将换页系统和文件系统统一起来。当一个应用程序将一个文件映射到程序的部分地址空间时，操作系统将那部分地址空间对应的页设置为“不存在”，然后将该文件像这部分地址空间对应的页交换磁盘那样来使用。</p>
<p>处理对映射文件的写操作有三种不同的方法。最简单的办法是将文件以只读方式（RO）映射，任何对映射文件存储数据的操作都会失败，这通常会导致程序终止。第二种方法是将文件以可读写方式（RW）映射，这样对映射文件在内存中副本的修改会在取消映射的时候写回磁盘上。第三种方法是将文件以写时复制方式（COW）映射。这种情况下操作系统会对该页面做一个副本，这个副本会被当作没有映射的私有页来对待。在应用程序看来，由于本程序所做的修改仅对自己可见而对其它程序不可见，因此以 COW 的方式映射文件与分配一块匿名的新内存并将文件内容读入其中很类似。</p>
<h2 id="共享库和程序"><a href="#共享库和程序" class="headerlink" title="共享库和程序"></a>共享库和程序</h2><p>在几乎所有能够同时运行多个程序的系统中，每个程序都有一套独立的页面，使各自都有一个逻辑上独立的地址空间。如果单一的程序或单一的程序库在多于一个的地址空间中被使用，若能够在多个地址空间中共享这个程序或程序库的单一副本，那将节省大量的内存。对于操作系统实现这个功能是相当简捷的——只需要将可执行程序文件映射到每一个程序的地址空间即可。不可重定位的代码和只读的数据以 RO 方式映射，可写的数据以 COW 方式映射。操作系统还可以让所有映射到该文件的进程之间共享 RO 和尚未被写的 COW 数据对应的物理页框。</p>
<p>要完成这种共享工作需要链接器予以相当多的支持。在可执行程序中，链接器需要将所有的可执行代码聚集起来形成文件中可以被映射为 RO 的部分，而数据是可以被映射为 COW 的另一部分。每一个段的开始地址都需要以页边界对齐，这既针对逻辑上的地址空间也包括实际的被映射文件。当多个不同程序使用一个共享库时，链接器需要做标记，好让程序启动时共享库可以被映射到它们各自的地址空间中。</p>
<h2 id="位置无关代码"><a href="#位置无关代码" class="headerlink" title="位置无关代码"></a>位置无关代码</h2><p>当一个程序在多个不同的地址空间运行时，操作系统通常可以将程序加载到各地址空间的相同位置。这样可以让链接器将程序中所有的地址绑定到固定的位置且在程序加载时不需要进行重定位，因此链接器的工作简单了很多。</p>
<p>共享库使用了位置无关代码（PIC：Position Independnet Code），这是无论被加载到内存中的任何位置都可以正常工作的代码。共享库中的代码通常都是位置无关代码，这样代码可以以 RO 方式映射。数据页仍然带有需要被重定位的指针，但由于数据页将以 COW 方式映射，因此这里对共享不会有什么损失。</p>
<h2 id="嵌入式体系结构"><a href="#嵌入式体系结构" class="headerlink" title="嵌入式体系结构"></a>嵌入式体系结构</h2><p>嵌入式系统中的链接会遇到多种在其它环境中很少遇到的问题。在尽可能小的内存容量下让程序跑的尽可能快是非常重要的。</p>
<h3 id="怪异的地址空间"><a href="#怪异的地址空间" class="headerlink" title="怪异的地址空间"></a>怪异的地址空间</h3><p>嵌入式系统具有很小且分布怪异的地址空间。一个 64K 的地址空间可能会包括高速的片内 ROM 和 RAM，低速的片外 ROM 和 RAM，片内外围设备，或片外外围设备。也可能会存在多个不连续的 ROM 或 RAM 区域。嵌入式系统的链接器需要有办法来指明被链接程序在内存布局上的大量细节，分配特定类型的代码和数据，甚至将例程和变量分开放入特定的地址。</p>
<h3 id="非一致性内存"><a href="#非一致性内存" class="headerlink" title="非一致性内存"></a>非一致性内存</h3><p>对片上内存的引用要比片外内存快很多，因此在同时具有两类内存的系统中，对时间要求最严格的程序需要放在快的内存中。有时候，在链接时将程序的所有对时间敏感的代码放入快速内存是可能的。但此外将数据或代码从慢速内存复制到快速内存也是很有用的，这样多个例程可以在不同时间中共享快速内存。对于这种技巧，如果能够告诉链接器“将这段代码放在位置 XXXX 但将它像在位置 YYYY 那样链接”那将是非常有用的，这样就可以在将代码从低速内存的 XXXX 位置复制到高速内存的 YYYY 位置后程序不会出错了。</p>
<h3 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h3><p>DSP 对某些的数据结构有非常严格的内存对齐要求。</p>
<h1 id="目标文件"><a href="#目标文件" class="headerlink" title="目标文件"></a>目标文件</h1><h2 id="目标文件中都有什么"><a href="#目标文件中都有什么" class="headerlink" title="目标文件中都有什么?"></a>目标文件中都有什么?</h2><p>一个目标文件包含五类信息。</p>
<ul>
<li>头信息：关于文件的整体信息，诸如代码大小，翻译成该目标文件的源文件名称，和创建日期等。</li>
<li>目标代码：由编译器或汇编器产生的二进制指令和数据。</li>
<li>重定位信息：目标代码中的一个位置列表，链接器在修改目标代码的地址时会对它进行调整。</li>
<li>符号：该模块中定义的全局符号，以及从其它模块导入的或者由链接器定义的符号。</li>
<li>调试信息：目标代码中与链接无关但会被调试器使用到的其它信息。包括源代码文件和行号信息，本地符号，被目标代码使用的数据结构描述信息。</li>
</ul>
<h2 id="设计一个目标文件格式"><a href="#设计一个目标文件格式" class="headerlink" title="设计一个目标文件格式"></a>设计一个目标文件格式</h2><p>一个可链接文件包含链接器处理目标代码时所需的扩展符号和重定位信息。目标代码经常被划分为多个会被链接器区别对待的小逻辑段。一个可执行程序中会包含目标代码，但是可以不需要任何符号以及重定位信息。目标代码可以是一个单独的大段，或反映了硬件执行环境的一组小段。根据系统运行时环境细节的不同，一个可加载文件可以仅包含目标代码，或为了进行运行时链接还包含了完整的符号和重定位信息。</p>
<h3 id="代码区段：Unix-a-out-文件"><a href="#代码区段：Unix-a-out-文件" class="headerlink" title="代码区段：Unix a.out 文件"></a>代码区段：Unix a.out 文件</h3><p>具有硬件内存重定位部件的计算机系统（今天几乎所有的计算机都有）通常都会为新运行的程序创建一个具有空地址空间的新进程，这种情况下程序就可以按照从某个固定地址开始的方式被链接，而不需要加载时的重定位。UNIX 的 a.out 目标文件格式就是针对这种情况的。</p>
<p>最简单的情况下，一个 a.out 文件包含一个小文件头，后面接着是可执行代码，然后是静态数据的初始值。后续型号为代码（称为指令空间 I）和数据（称为数据空间 D）提供了独立的地址空间，这样一个程序可以拥有 64K 的代码空间和 64K 的数据空间。为了支持这个特性，编译器、汇编器、链接器都被修改为可以创建两个段的目标文件（代码放入第一个段中，数据放入第二个段中，程序加载时先将第一个段载入进程的 I 空间，再将第二个段载入进程的 D 空间）。</p>
<p>独立的 I 和 D 空间还有另一个性能上的优势：由于一个程序不能修改自己的 I 空间，因此一个程序的多个实体可以共享一份程序代码的副本。在诸如 UNIX 这样的分时系统上，shell（命令解释器）和网络服务进程具有多个副本是很普遍的，共享程序代码可以节省相当可观的内存空间。</p>
<h3 id="a-out-头部"><a href="#a-out-头部" class="headerlink" title="a.out 头部"></a>a.out 头部</h3><p>a.out 的头部根据 UNIX 版本的不同而略有变化。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a_magic; <span class="comment">// 幻数</span></span><br><span class="line"><span class="keyword">int</span> a_text; <span class="comment">// 文本段大小</span></span><br><span class="line"><span class="keyword">int</span> a_data; <span class="comment">// 初始化的数据段大小</span></span><br><span class="line"><span class="keyword">int</span> a_bss; <span class="comment">// 未初始化的数据段大小</span></span><br><span class="line"><span class="keyword">int</span> a_syms; <span class="comment">// 符号表大小</span></span><br><span class="line"><span class="keyword">int</span> a_entry; <span class="comment">// 入口点</span></span><br><span class="line"><span class="keyword">int</span> a_trsize; <span class="comment">// 文本重定位段大小</span></span><br><span class="line"><span class="keyword">int</span> a_drsize; <span class="comment">// 数据重定位段大小</span></span><br></pre></td></tr></table></figure>
<p>幻数 a_magic 说明了当前可执行文件的类型。不同的幻数告诉操作系统的程序加载器以不同的方式将文件加载到内存中；我们将在下面讨论这些区别。文本和数据段大小 a_text 和 a_data 以字节为单位标识了头部后面的只读代码段和可读写数据段的大小。由于 UNIX 会自动将新分配的内存清零，因此初值无关紧要或者为 0 的数据不必在 a.out 文件中存储。未初始化数据大小 a_bss 说明了在 a.out 文件中的可读写数据段后面逻辑上存在多少未初始化的数据（实际上是被初始化为 0）。</p>
<p>a_entry 域指明了程序的起始地址，同时 a_syms，a_trsize 和 a_drsize 说明了在文件数据段后的符号表与重定位信息的大小。已经被链接好可以运行的程序中既不需要符号表也不需要重定位信息，所以除非链接器为了调试器加入符号信息，否则在可运行文件中这些域都是0。</p>
<h3 id="与虚拟内存的交互"><a href="#与虚拟内存的交互" class="headerlink" title="与虚拟内存的交互"></a>与虚拟内存的交互</h3><p>操作系统加载和启动一个简单的双段文件的过程非常简单</p>
<ul>
<li>读取 a.out 的头部获取段的大小。</li>
<li>检查是否已存在该文件的可共享代码段。如果是的话，将那个段映射到该进程的地址空间。如果不是，创建一个并将它映射到地址空间中，然后从文件中读取文本段放入这个新的内存区域。</li>
<li>创建一个足够容纳数据段和 BSS 的私有数据段，将它映射到进程的地址空间中，然后从文件中读取数据段放入内存中的数据段并将 BSS 段对应的内存空间清零。</li>
<li>创建一个栈的段并将其映射到进程的地址空间（由于数据堆和栈的增长方向不同，因此栈段通常是独立于数据段的）。将命令行或者调用程序传递的参数放入栈中。</li>
<li>适当的设置各种寄存器并跳转到起始地址。</li>
</ul>
<p>这种策略相当有效。当 UNIX 系统采用虚拟内存后，对这种简单策略的些许改进还进一步加速了程序加载的速度并节省了相当可观的内存。</p>
<p>在一个分页系统中，上述的简单机制会为每一个文本段和数据段分配新的虚拟内存。由于 a.out 文件已经存储在磁盘中了，所以目标文件本身可以被映射到进程的地址空间中。虚拟内存只需要为程序写入的那些页分配新的磁盘空间，这样可以节省磁盘空间。并且由于虚拟内存系统只需要将程序确实需要的那些页从磁盘加载到内存中（而不是整个文件），这样也加快了程序启动的速度。</p>
<p>对 a.out 文件格式进行少许修改就可以做到这一点，这就够成了被称为 ZMAGIC 的格式。这些变化将目标文件中的段对齐到页的边界。在页大小为 4K 的系统上，a.out 头部扩展为 4K，文本段的大小也要对齐到下一个 4K 的边界。由于 BSS 段逻辑上跟在数据段的后面并在程序加载时被清零，所以没有必要对数据段进行页边界对齐的填充。</p>
<p>ZMAGIC 格式的文件减少了不必要的换页，对应付出的代价是浪费了大量的磁盘空间。a.out 的头部仅有 32 字节长，但是仍需要分配 4K 磁盘空间给它。文本和数据段之间的空隙平均浪费了 2K 空间，即半个 4K 的页。上述这些问题都在被称为 ZMAGIC 的压缩可分页格式中被修正了。</p>
<p>由于并没有什么特别的原因要求文本段的代码必须从地址 0 处开始运行，因此压缩可分页文件将 a.out 头部当成是文本段的一部分（实际上由于未初始化的指针变量经常为 0，位置 0 绝对不是一个程序入口的好地方）。代码紧跟在头部的后面，并将整个页映射为进程的第二个页，而不映射进程地址空间的第一个页，这样对位置 0 的指针引用就会失败。它也产生了一个无害的副作用就是将头部映射到进程的地址空间中了。</p>
<p>QMAGIC 格式的可执行文件中文本和数据段都各自扩充到一个整页，这样系统就可以很容易的将文件中的页映射到地址空间中的页。数据段的最后一页由值为零的 BSS 数据填充补齐；如果 BSS 数据大于可以填充补齐的空间，那么 a.out 的头部中会保存剩余需要分配的 BSS 空间大小。尽管 BSD UNIX 将程序加载到位置 0（或 QMAGIC 格式的 0x1000）处，其它版本的 UNIX 会将程序加载到不同的位置。例如 Motorola 68K 系列上的系统 5（System V）会将程序加载到0x80000000 处，在 386 上会加载到 0x8048000 处。只要地址是页对齐的，并且能够与链接器和加载器达成一致，加载到哪里都没有关系。</p>
<h2 id="重定位：MS-DOS-EXE-文件"><a href="#重定位：MS-DOS-EXE-文件" class="headerlink" title="重定位：MS-DOS EXE 文件"></a>重定位：MS-DOS EXE 文件</h2><p>有一些系统会将所有的程序加载到相同的地址空间。还有一些系统虽然会为程序分配自己的地址空间，但是并不总是将程序加载到相同的地址。在这些情况下，可执行程序会包含多个（通常被称为 fixups 的）重定位项，它们指明了程序中需要在被加载时进行修改的地址位置。具有 fixups 的最简单的格式之一就是 MS-DOS EXE 格式。</p>
<p>DOS 将程序载入到一块连续的可用实模式内存中。如果一个 64K 的段无法容纳整个程序，就需要使用明确的段基址对程序和数据进行寻址，并在程序加载时必须调整程序中的段基址以匹配程序实际加载的位置。文件中的段基址是按照程序将被加载到位置 0 来存储的，所以修正的动作就是将程序实际被加载到的段基地址与存储的段基址相加。就是说，如果程序实际被加载到位置 0x5000，即段基址为 0x500，那么文件中对段基址 0x12 的引用将会重定位为 0x512。由于程序是作为一个整体被重定位的，段内偏移量不会改变，所以加载器不需要修正除段基址之外的其它内容。</p>
<p>每个.EXE 文件都是以所示的头部结构开始的。跟在头部后面的是变量长度相关的额外信息和一个 segment:offset 格式的 32 位修正地址列表。修正地址是程序基地址的相对地址，所以这些修正地址本身也需要被重定位以寻找那些程序中需要被修改的地址。在修正地址列表后的是程序代码。在代码的后面，也许还有会被程序加载器忽略的额外信息。（在下面的例子中，far 类型指针为 32 位，其中 16 位段基址和 16 位段内偏移量）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">char signature[2] = &quot;MZ&quot;;//幻数</span><br><span class="line">short lastsize; //最后一个块使用的字节数</span><br><span class="line">short nblocks; //512 字节块的个数</span><br><span class="line">short nreloc; //重定位项个数</span><br><span class="line">short hdrsize; //以 16 字节段为单位的文件头部尺寸</span><br><span class="line">short minalloc; //需额外分配的最小内存量</span><br><span class="line">short maxalloc; //需额外分配的最大内存量</span><br><span class="line">void far *sp; //初始栈指针</span><br><span class="line">short checksum; //文件校验和</span><br><span class="line">void far *ip; //初始指令指针short relocpos; //重定位修正表位置</span><br><span class="line">short noverlay; //重叠的个数，程序为 0</span><br><span class="line">char extra[]; //重叠所需的额外信息等</span><br><span class="line">void far *relocs[]; //重定位项，从 relocpos 开始</span><br></pre></td></tr></table></figure>
<p>加载.EXE 文件只比加载.COM 文件复杂一点点。</p>
<ul>
<li>读入文件头部，验证幻数是否有效。</li>
<li>找一块大小合适的内存区域。minalloc 和 maxalloc 域说明了在被加载程序末尾后需额外分配的内存块的最大和最小尺寸（链接器总是缺省的将最小尺寸设置为程序中类似 BSS 的未初始化数据的大小，将最大尺寸设置为 0xFFFF）。</li>
<li>创建一个程序段前缀（Program Segment Prefix），即位于程序开头的控制区域。</li>
<li>在 PSP 之后读入程序的代码。nblocks 和 lastsize 域定义了代码的长度。</li>
<li>从 relocpos 处开始读取 nreloc 个修正地址项。对每一个修正地址，将其中的基地址与程序代码加载的基地址相加，然后将这个重定位后的修正地址作为指针，将程序代码的实际基地址与这个指针指向的程序代码中的地址相加。</li>
<li>将栈指针设置为重定位后的 sp，然后跳转到重定位后的 ip 处开始执行程序。</li>
</ul>
<p>在少数情况下，程序的不同片段可以用不同的方式重定位。在 286 保护模式下（EXE 文件不支持），虽然可执行文件中的代码和数据段被加载到系统中各自独立的段，但是由于体系结构的原因段基址是不连续的。每一个保护模式的可执行程序在靠近文件开头的位置有一个表列出来程序需要的所有段。系统会创建一个表将可执行程序中的每个段与系统中实际的段址对应起来。在进行地址调整时，系统会在这个表中查找逻辑段址，并将其替换为实际的段址，相比于重定位这更类似一个符号绑定的过程。</p>
<h2 id="符号和重定位"><a href="#符号和重定位" class="headerlink" title="符号和重定位"></a>符号和重定位</h2><p>多数目标文件并不是可加载的，但相当一部分是由编译器或汇编器生成传递给链接器或库管理器的中间文件。这些可链接文件比起那些可运行文件来说，要复杂的多。原则上，一个支持链接的加载器可以在程序被加载时完成所有链接器必须完成的功能，但由于效率原因加载器通常都尽可能的简单，以提高程序启动的速度。</p>
<h3 id="可重定位的-a-out-格式"><a href="#可重定位的-a-out-格式" class="headerlink" title="可重定位的 a.out 格式"></a>可重定位的 a.out 格式</h3><p>UNIX 系统对于可运行文件和可链接文件都使用相同的一种目标文件格式，其中可运行文件省略掉了那些仅用于链接器的段。文本和数据段的重定位表的大小保存在<code>a_trsize</code>和<code>a_drsize</code>中，符号表的尺寸保存在<code>a_syms</code>中。这三个段跟在文本和数据段后。</p>
<p>重定位项有两个功能。当一个代码段被重定位到另一个不同的段基址时，重定位项标注出代码中需要被修改的地方。在一个可链接文件中，同样也有用来标注对未定义符号引用的重定位项，这样链接器就知道在最终解析符号时应当向何处补写符号的值。每一个重定位项包含了在文本或数据段中需被重定位的地址，以及定义了要做什么的信息。该地址是一个需要进行重定位的项目到文本段或数据段起始位置的偏移量。长度域说明了该重定位项目的长度。pcrel 标志表示这是一个“PC（程序计数器，即指令寄存器）相对的”重定位项目，如果是的话，它会在指令中被作为相对地址使用。</p>
<p>外部标志域控制对 index 域的解释，确定该重定位项目是对某个段或符号的引用。如果外部标志为 off，那这是一个简单的重定位项目，index 就指明了该项目是基于哪个段（文本、数据或 BSS）寻址的。如果外部标志为 on，那么这是一个对外部符号的引用，则 index 是该文件符号表中的符号序号。</p>
<p>UNIX 编译器允许任意长度的标识符，所以名字字串全部都在符号表后面的字串表中。符号表项的第一个域是该符号以空字符结尾的名字字串在字串表中的偏移量。在类型字节中，若低位被置位则该符号是全局符号。非外部符号对于链接是没有必要的，但是会被调试器用到。其余的位是符号类型。最重要的类型包括：</p>
<ul>
<li>文本、数据或 BSS：模块内定义的符号。外部标志位可能设置或没有设置。值为与该符号对应的模块内可重定位地址。</li>
<li>abs：绝对非可重定位符号。很少在调试信息以外的地方使用。外部标志位可能设置或没有设置。值为该符号的绝对地址。</li>
<li>undefined：在该模块中未定义的符号。外部标志位必须被设置。值通常为 0。</li>
</ul>
<p>作为一种特例，编译器可以使用一个未定义的符号来要求链接器为该符号的名字预留一块存储空间。如果一个外部符号的值不为零，则该值是提示链接器程序希望该符号寻址存储空间的大小。在链接时，若该符号的定义不存在，则链接器根据其名字在 BSS 中创建一块存储空间，大小为所有被链接模块中该符号提示尺寸中的最大值。如果该符号在某个模块中被定义了，则链接器使用该定义而忽略提示的空间大小。</p>
<h3 id="Unix-ELF-格式"><a href="#Unix-ELF-格式" class="headerlink" title="Unix ELF 格式"></a>Unix ELF 格式</h3><p>ELF 格式即可执行和链接格式（Executable and Linking Format）。ELF 格式有三个略有不同的类型：可重定位的，可执行的，和共享目标（shared objects）。可重定位文件由编译器和汇编器创建，但在运行前需要被链接器处理。可执行文件完成了所有的重定位工作和符号解析（除了那些可能需要在运行时被解析的共享库符号），共享目标就是共享库，即包括链接器所需的符号信息，也包括运行时可以直接执行的代码。<br>ELF 格式具有不寻常的双重特性。编译器、汇编器和链接器将这个文件看作是被区段（section）头部表描述的一系列逻辑区段的集合，而系统加载器将文件看成是由程序头部表描述的一系列段（segment）的集合。一个段（segment）通常会由多个区段（section）组成。可重定位文件具有区段表，可执行程序具有程序头部表，而共享目标文件两者都有。区段（section）是用于链接器后续处理的，而段（segment）会被映射到内存中。</p>
<p>ELF 文件都是以 ELF 头部起始的。头部被设计为即使在那些字节顺序与文件的目标架构不同的机器上也可以被正确的解码。头 4 个字节是用来标识 ELF 文件的幻数，接下来的 3 个字节描述了头部其余部分的格式。当程序读取了 class 和 byteorder 标志后，它就知道了文件的字节序和字宽度，就可以进行相应的字节顺序和数据宽度的转换。其它的域描述了区段头部或程序头部的大小和位置（如果它们存在的话）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> magic[<span class="number">4</span>] = <span class="string">"\177ELF"</span>; <span class="comment">//幻数</span></span><br><span class="line"><span class="keyword">char</span> <span class="class"><span class="keyword">class</span>;</span> <span class="comment">//地址宽度， 1 = 32 位， 2 = 64 位</span></span><br><span class="line"><span class="keyword">char</span> byteorder; <span class="comment">//字节序， 1 = little-endian，2 = big-endian</span></span><br><span class="line"><span class="keyword">char</span> hversion; <span class="comment">//头部版本，总是 1</span></span><br><span class="line"><span class="keyword">char</span> pad[<span class="number">9</span>]; <span class="comment">//填充字节</span></span><br><span class="line"><span class="keyword">short</span> filetype; <span class="comment">//文件类型：1 = 可重定位，2 = 可执行，3 = 共享目标，4 = 转储镜像（core image）</span></span><br><span class="line"><span class="keyword">short</span> archtype; <span class="comment">//架构类型，2 = SPARC，3 = x86，4 = 68K，等等.</span></span><br><span class="line"><span class="keyword">int</span> fversion; <span class="comment">//文件版本，总是 1</span></span><br><span class="line"><span class="keyword">int</span> entry; <span class="comment">//入口地址（若为可执行文件）</span></span><br><span class="line"><span class="keyword">int</span> phdrpos; <span class="comment">//程序头部在文件中的位置（不存在则为 0）int shdrpos; //区段头部在文件中的位置（不存在则为 0）</span></span><br><span class="line"><span class="keyword">int</span> flags; <span class="comment">//体系结构相关的标志，总是 0</span></span><br><span class="line"><span class="keyword">short</span> hdrsize; <span class="comment">//该 ELF 头部的大小</span></span><br><span class="line"><span class="keyword">short</span> phdrent; <span class="comment">//程序头部表项的大小</span></span><br><span class="line"><span class="keyword">short</span> phdrcnt; <span class="comment">//程序头部表项个数（不存在则为 0）</span></span><br><span class="line"><span class="keyword">short</span> shdrent; <span class="comment">//区段头部表项的大小</span></span><br><span class="line"><span class="keyword">short</span> phdrcnt; <span class="comment">//区段头部表项的个数（不存在则为 0）</span></span><br><span class="line"><span class="keyword">short</span> strsec; <span class="comment">//保存有区段名称字串的区段的序号</span></span><br></pre></td></tr></table></figure>
<h3 id="可重定位文件"><a href="#可重定位文件" class="headerlink" title="可重定位文件"></a>可重定位文件</h3><p>一个可重定位或共享目标文件可以看成是一系列在区段头部表中被定义的区段的集合。每个区段只包含一种类型的信息，可以是程序代码、只读数据或可读写数据，重定位项，或符号。在模块中定义的符号都是以段的相对地址定义的，因此一个过程（procedure）的入口点也是由包含该过程代码的程序代码区段的相对地址来定义的。此外还存在两个伪段，SHN_ABS（数字 0xfff1）逻辑上包含了绝对不可重定位符号（absolute non-relocatable symbols），SHN_COMMON（数字 0xfff2）包含未初始化的数据块。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sh_name; <span class="comment">//名称，可在字串表中索引到</span></span><br><span class="line"><span class="keyword">int</span> sh_type; <span class="comment">//区段类型</span></span><br><span class="line"><span class="keyword">int</span> sh_flags; <span class="comment">//标志位，见下</span></span><br><span class="line"><span class="keyword">int</span> sh_addr; <span class="comment">//若可加载则为内存基址，否则为 0</span></span><br><span class="line"><span class="keyword">int</span> sh_offset; <span class="comment">//区段起始点在文件中的位置</span></span><br><span class="line"><span class="keyword">int</span> sh_size; <span class="comment">//区段大小（字节为单位）</span></span><br><span class="line"><span class="keyword">int</span> sh_link; <span class="comment">//相关信息对应的区段号，若没有则为 0</span></span><br><span class="line"><span class="keyword">int</span> sh_info; <span class="comment">//区段相关的更多信息</span></span><br><span class="line"><span class="keyword">int</span> sh_align; <span class="comment">//移动区段时的对齐粒度</span></span><br><span class="line"><span class="keyword">int</span> sh_entsize;<span class="comment">//若该区段为一个表时其中表项的大小</span></span><br></pre></td></tr></table></figure>
<p>区段类型包括：</p>
<ul>
<li>PROGBITS：程序内容，包括代码，数据和调试器信息。</li>
<li>NOBITS：类似于 PROGBITS，但在文件本身中并没有分配空间。用于 BSS 数据，在程序加载时分配空间。</li>
<li>SYMTAB 和 DYNSYM：符号表，后面会有更加详细的描述。SYMTAB 包含所有的符号并用于普通的链接器，DYNSYM 包含那些用于动态链接的符号（后一个表需要在运行时被加载到内存中，因此要让它尽可能的小）。</li>
<li>STRTAB：字串表，与 a.out 文件中的字串表类似。与 a.out 文件不同的是，ELF 文件能够而且经常为不同的用途创建不同的字串表，例如全段名称、普通符号名称和动态链接符号名称。</li>
<li>REL 和 RELA：重定位信息。REL 项将其中的重定位值加到存储在代码和数据中的基地址值，而 RELA 将重定位需要的基地址也保存在重定位项自身中。</li>
<li>DYNAMIC 和 HASH：动态链接信息和运行时符号 hash 表。这里用到了 3 个标志位：ALLOC，意味着在程序加载时该区段要占用内存空间；WRITE 意味着该区段被加载后是可写的；EXECINSTR 即表示该区段包含可执行的机器代码。</li>
</ul>
<p>一个典型的可重定位可执行程序会有十多个区段。很多区段的名称对于链接器在根据它所支持的区段类型来进行特定的处理（同时根据标志位将不支持的区段忽略或原封不动的传递下去）时，都是有意义的。区段的类型包括：</p>
<ul>
<li>.text 是具有 ALLOC 和 EXECINSTR 属性的 PROGBITS 类型区段。相当于 a.out 的文本段。</li>
<li>.data 是具有 ALLOC 和 WRITE 属性的 PROGBITS 类型区段。对应于 a.out 的数据段。</li>
<li>.rodata 是具有 ALLOC 属性的 PROGBITS 类型区段。由于是只读数据，因此没有 WRITE 属性。</li>
<li>.bss 是具有 ALLOC 和 WRITE 属性的 NOBITS 类型区段。BSS 区段在文件中没有分配空间，因此是 NOBITS 类型，但由于会在运行时分配空间，所以具有 ALLOC 属性。</li>
<li>.rel.txt，.rel.data 和.rel.rodata 每个都是 REL 或 RELA 类型区段。是对应文本或数据区段的重定位信息。</li>
<li>.init 和.fini，都是具有 ALLOC 和 EXECINSTR 属性的 PROGBITS 类型区段。与.text区段相似，但分别为程序启动和终结时执行的代码。</li>
<li>.symtab 和.dynsym 分别是 STMTAB 和 DNYSYM 类型的区段，对应为普通的和动态链接器的符号表。动态链接器符号表具有 ALLOC 属性，因为它需要在运行时被加载。</li>
<li>.strtab 和.dynstr 都是 STRTAB 类型的区段，这是名称字串的表，要么是符号表，要么是段表的段名称字串。.synstr 区段保存动态链接器符号表字串，由于需要在运行时被加载所以具有 ALLOC 属性。</li>
<li>此外还有一些特殊的区段诸如.got 和.plt，分别是全局偏移量表（Global Offset Table）和动态链接时使用的过程链接表（Procedure Linkage Table）。</li>
<li>.debug 区段包含调试器所需的符号，.line 区段也是用于调试器的，它保存了从源代码的行号到目标代码位置的映射关系。</li>
<li>.comment 区段包含着文档字串，通常是版本控制中的版本序号。</li>
</ul>
<p>还有一个特殊的区段类型.interp，它包含解释器程序的名字。如果这个区段存在，系统不会直接运行这个程序，而是会运行对应的解释器程序并将该 ELF 文件作为参数传递给解释器。例如 UNIX 上多年以来都有可以解释型的自运行文本文件，只需要在文件的第一行加上：<code>#!/path/to/interpreter</code>。</p>
<p>ELF 符号表与 a.out 符号表相似，包含一个由表项组成的数组。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> name; <span class="comment">//名称字串在字串表中的位置</span></span><br><span class="line"><span class="keyword">int</span> value; <span class="comment">//符号值，在可重定位文件中是段相对地址，</span></span><br><span class="line"><span class="comment">//在可执行文件中是绝对地址</span></span><br><span class="line"><span class="keyword">int</span> size; <span class="comment">//目标或函数的大小</span></span><br><span class="line"><span class="keyword">char</span> type:<span class="number">4</span>; <span class="comment">//符号类型：数据目标，函数，区段，或特殊文件</span></span><br><span class="line"><span class="keyword">char</span> bind:<span class="number">4</span>; <span class="comment">//符号绑定类型：局部，全局，或弱符号</span></span><br><span class="line"><span class="keyword">char</span> other; <span class="comment">//空闲</span></span><br><span class="line"><span class="keyword">short</span> sect; <span class="comment">//段基址，ABS，COMMON 或 UNDEF</span></span><br></pre></td></tr></table></figure>
<p>ELF 符号表增加了少许新的域。size 域指明了数据目标（尤其是未定义的 BSS，又使用了公共块技巧）的大小，一个符号的绑定可以是局部的（仅模块内可见），全局的（所有地方均可见），或者弱符号。</p>
<p>弱符号是半个全局符号：如果存在一个对未定义的弱符号的有效定义，则链接器采用该值，否则符号值缺省为 0。</p>
<p>符号的类型通常是数据或者函数。对每一个区段都会有一个区段符号，通常都是使用该区段本身的名字，这对重定位项是有用的（ELF 重定位项的符号都是相对地址，因此就需要一个段符号来指明某一个重定位项目是相对于文件中的哪一个区段）。文件入口点是一个包含源代码文件名称的伪符号。</p>
<p>区段号（即段基址）是相对于该符号的定义所在的那个段的，例如函数入口点都是相对于.text 段定义的。这里还可以看到三个特殊的伪区段，UNDEF 用于未定义符号，ABS 用于不可重定位绝对符号，COMMON 用于尚未分配的公共块（COMMON 符号中的 value 域提供了所需的对齐粒度，size 域提供了尺寸最小值。一旦被链接器分配空间后，COMMON 符号就会被转移到.bss 区段中）。</p>
<p>下面是一个典型的完整的 ELF 文件，包含代码、数据、重定位信息、链接器符号、和调试器符号等若干区段。如果该文件是一个 C++程序，那可能还包含.init、.fini、.rel.init 和.rel.fini 等区段。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ELF 文件头部</span><br><span class="line">.text</span><br><span class="line">.data</span><br><span class="line">.rodata</span><br><span class="line">.bss.sym</span><br><span class="line">.rel.text</span><br><span class="line">.rel.data</span><br><span class="line">.rel.rodata</span><br><span class="line">.line</span><br><span class="line">.debug</span><br><span class="line">.strtab</span><br><span class="line">(区段表，但不将其作为一个区段来考虑)</span><br></pre></td></tr></table></figure>
<h3 id="ELF-可执行文件"><a href="#ELF-可执行文件" class="headerlink" title="ELF 可执行文件"></a>ELF 可执行文件</h3><p>一个 ELF 可执行文件具有与可重定位 ELF 文件相同的通用格式，但对数据部分进行了调整以使得文件可以被映射到内存中并运行。文件中会在 ELF 头部后面存在程序头部。程序头部定义了要被映射的段。所示为程序头部，是一个由段描述符组成的数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int type; //类型：可加载代码或数据，动态链接信息，等</span><br><span class="line">int offset; //段在文件中的偏移量</span><br><span class="line">int virtaddr; //映射段的虚拟地址</span><br><span class="line">int physaddr; //物理地址，未使用</span><br><span class="line">int filesize; //文件中的段大小</span><br><span class="line">int memsize; //内存中的段大小（如果包含 BSS 的话会更大些）</span><br><span class="line">int flags; //读，写，执行标志位</span><br><span class="line">int align; //对齐要求，根据硬件页尺大小不同有变动</span><br></pre></td></tr></table></figure>
<p>一个可执行程序通常只有少数几种段，如代码和数据的只读段，可读写数据的可读写段。所有的可加载区段都归并到适当类型的段中以便系统可以通过少数的一两个操作就可以完成文件映射。</p>
<p>ELF 格式文件进一步扩展了 QMAGIC 格式的 a.out 文件中使用的“头部放入地址空间”的技巧，以使得可执行文件尽可能的紧凑，相应付出的代价就是地址空间显得凌乱了些。一个段可以开始和结束于文件中的任何偏移量处，但是段的虚拟起始必须和文件中起始偏移量具有低位地址模对齐的关系，例如，必须起始于一页的相同偏移量处。系统必须将段起始所在页到段结束所在页之间整个的范围都映射进来，哪怕在逻辑上该段只占用了被映射的第一页和最后一页的一部分。</p>
<p>被映射的文本段包括 ELF 头部，程序头部，和只读文本，这样 ELF 头部和程序头部都会在文本段开头的同一页中。文件中仅有的可读写数据段紧跟在文本段的后面。文件中的这一页会同时被映射为内存中文本段的最后一页和数据段的第一页（以 copy-on-write 的方式）。如果计算机具有 4K 的页，并在可执行文件中文本段结束于 0x80045ff，然后数据段起始于 0x8005600。文件中的这一页（即同时存有文本和数据段的页）在内存 0x8004000 处被映射为文本段的最后一页（头 0x600 个字节包含文本段中 0x8004000 到 0x80045ff 之间的内容），并在 0x8005000 处被映射为数据段（0x600 以后的部分包含数据段从 0x8005600 到 0x80056ff<br>的内容）。</p>
<p>BSS 段也是在逻辑上也是跟在数据段的可读写区段后，在本例中长度为 0x1300 字节，即文件中尺寸与内存中尺寸的差值。数据段的最后一页会从文件中映射进来，但是在随后操作系统将 BSS 段清零时，copy-on-write 系统会该段做一个私有的副本。如果文件中包含.init 或.fini 区段，这些区段会成为只读文本段的一部分，并且链接器会在程序入口点处插入代码，使得在调用主程序之前会调用.init 段的代码，并在主程序返回后调用.fini 区段的代码。</p>
<p>ELF 共享目标包含了可重定位和可执行文件的所有东西。它在文件的开头具有程序头部表，随后是可加载段的各区段，包括动态链接信息。在构成可加载段的各区段之后的，是重定位符号表和链接器在根据共享目标创建可执行程序时需要的其它信息，最后是区段表。</p>
<h3 id="ELF-格式小结"><a href="#ELF-格式小结" class="headerlink" title="ELF 格式小结"></a>ELF 格式小结</h3><p>ELF 是一种较为复杂的格式，但它的表项和预期的一样好。它既是一个足够灵活的格式，又是一种高效的可执行格式，同时也可以很方便的将可执行程序的页直接映射到程序的地址空间。它还允许从一个平台到另一个平台的交叉编译和交叉链接，并在 ELF 文件内包含了足以识别目标体系结构和字节序的信息。</p>
<h1 id="存储空间分配"><a href="#存储空间分配" class="headerlink" title="存储空间分配"></a>存储空间分配</h1><p>链接器或加载器的首要任务是存储分配。一旦分配了存储空间后，链接器就可以继续进行符号绑定和代码调整。在一个可链接目标文件中定义的多数符号都是相对于文件内的存储区域定义的，所以只有存储区域确定了才能够进行符号解析。与链接的其它方面情况相似，存储分配的基本问题是很简单的，但处理计算机体系结构和编程语言语义特性的细节让问题复杂起来。存储分配的大多数工作都可以通过优雅和相对架构无关的方法来处理，但总有一些细节需要特定机器的专门技巧来解决。</p>
<h2 id="段和地址"><a href="#段和地址" class="headerlink" title="段和地址"></a>段和地址</h2><p>每个目标或可执行文件都会采用目标地址空间的某种模式。通常这里的目标是目标计算机的应用程序地址空间，但某些情况下（例如共享库）也会是其它东西。在一个重定位链接器或加载器中的基本问题是要确保程序中的所有段都被定义并具有地址，并且这些地址不能发生重叠（除非有意这样）。</p>
<p>每一个链接器输入文件都包含一系列各种类型的段。不同类型的段以不同的方式来处理。通常，所有相同类型的段，诸如可执行代码段，会在输出文件中被合并为一个段。有时候段是在其它段的基础上合并得到的（如 Fortran 的公共块），以及在越来越多的情况下，链接器本身会创建一些段并将其放置在输出中。存储布局是一个“两遍”的过程，这是因为每个段的地址在所有其它段的大小未确定前是无法分配的。</p>
<h3 id="简单的存储布局"><a href="#简单的存储布局" class="headerlink" title="简单的存储布局"></a>简单的存储布局</h3><p>在一种简单而不现实的情形下，链接器的输入文件包含一系列的模块，将它们称为 M1,M2, … Mn，每一个模块都包含一个单独的段，从位置 0 开始长度依次为 L1, L2, … Ln，并且目标地址空间也是从 0 开始。</p>
<p>链接器或加载器依次检查各个模块，按顺序分配存储空间。模块 Mi的起始地址为从 L1到 Li-1相加的总和，链接得到的程序长度为从 L1到 Ln相加的总和。多数体系结构要求数据必须对齐于字边界，或至少在对齐时运行速度会更快些。因此链接器通常会将 Li扩充到目标体系结构最严格的对齐边界（通常是 4 或 8 个字节）的倍数。</p>
<h3 id="多种段类型"><a href="#多种段类型" class="headerlink" title="多种段类型"></a>多种段类型</h3><p>除最简单格式外所有的目标格式，都具有多种段的类型，链接器需要将所有输入模块中相应的段组合在一起。在具有文本和数据段的 UNIX 系统上，被链接的文件需要将所有的文本段都集中在一起，然后跟着的是所有的数据，在后面是逻辑上的 BSS（即使 BSS 在输出文件中不占空间，它仍然需要分配空间来解析 BSS 符号，并指明当输出文件被加载时要分配的 BSS 空间尺寸）。这就需要两级存储分配策略。</p>
<p>在读入每个输入模块时，链接器为每个 Ti，Di，Bi按照（就像是）每个段都各自从位置0 处开始的方式分配空间。在读入了所有的输入文件后，链接器就可以知道这三种段各自总的大小 Ttot，Dtot和 Btot。由于数据段跟在文本段之后，链接器将 Ttot加到每一个数据段所分配的地址上，接着，由于 BSS 跟在文本和数据段之后，所以链接器会将 Ttot、Dtot的和加到每一个 BSS 段分配的地址上。同样，链接器通常会将分配的大小按照对齐要求扩充补齐。</p>
<h3 id="段与页面的对齐"><a href="#段与页面的对齐" class="headerlink" title="段与页面的对齐"></a>段与页面的对齐</h3><p>如果文本和数据被加载到独立的内存页中，这也是通常的情况，文本段的大小必须扩充为一个整页，相应的数据和 BSS 段的位置也要进行调整。很多 UNIX 系统都使用一种技巧来节省文件空间，即在目标文件中数据紧跟在文本的后面，并将那个（文本和数据共存的）页在虚拟内存中映射两次，一次是只读的文本段，一次是写时复制（copy-on-write）的数据段。这种情况下，数据段在逻辑上起始于文本段末尾紧接着的下一页，这样就不需扩充文本段，数据段也可对齐于紧接着文本段后的 4K（或者其它的页尺寸）页边界。</p>
<h3 id="公共块和其它特殊段"><a href="#公共块和其它特殊段" class="headerlink" title="公共块和其它特殊段"></a>公共块和其它特殊段</h3><h4 id="公共块"><a href="#公共块" class="headerlink" title="公共块"></a>公共块</h4><p>在最初的 Fortran 系统中，每一个子程序（主程序、函数或者子例程）都有各自局部声明和分配的标量和数组变量。同时还有一个各例程都可以使用的存储标量和数组的公共区域。公共块存储被证明是非常有用的，并且在后续 Fortran 中单一的公共块已经普及为多个可命名的公共块，每一个子程序都可以声明它们所用的公共块。在最初的 40 年中，Fortran 不支持动态存储分配，公共块是 Fortran 程序用来绕开这个限制的首要工具。标准 Fortran 允许在不同例程中声明不同大小的空白公共块，其中最大的尺寸最终生效。Fortran 系统们无一例外的都将它扩展为允许以不同的大小来声明所有类型的公共块，同样还是最大的尺寸最终生效。</p>
<p>在处理公共块时，链接器会将输入文件中声明的每个公共块当作一个段来处理，但并不会将这些段串联起来，而是将相同名称的公共块重叠在一起。这里会将声明的最大的尺寸作为段的大小，除非在某一个输入文件中存在该段的已初始化的版本。在某些系统上，已初始化的公共块是一个单独的段类型，而在另一些系统上它可能只是数据段的一部分。UNIX 链接器总是一贯支持公共块，甚至从最早版本的 UNIX 都具有一个 Fortran 子集的编译器，并且 UNIX 版本的 C 语言传统上会将未初始化的全局变量作为公共块对待。但在 ELF之前的 UNIX 目标文件只有文本、数据和 BSS 段，没有办法直接声明一个公共块。作为一个特殊技巧，链接器将未定义但具有非零初值的符号当作是公共块，而该值就是公共块的尺寸。</p>
<h4 id="C-重复代码消除"><a href="#C-重复代码消除" class="headerlink" title="C++重复代码消除"></a>C++重复代码消除</h4><p>在某些编译系统中，C++编译器会由于虚函数表、模板和外部 inline 函数而产生大量的重复代码。这些特性的设计是隐含的期望那种程序所有部分都可以被运行的环境。一个虚函数表（通常简称为 vtbl）包含一个类的所有虚函数（可以被子类覆盖的例程）的地址。每个带有任何虚函数的类都需要一个 vtbl。模板本质上就是以数据类型为参数的宏，并能够根据特定的类型参数集可以扩展为特定的例程。确保是否存在一个对普通例程的引用可供调用是程序员的责任，就是说对如 hash(int)和 hash(char *)每一类 hash 函数都有确定的定义，hash(T)模板可以根据程序中使用 hash 函数时不同的参数数据类型创建对应的 hash 函数。</p>
<p>在每个源代码文件都被单独编译的环境中，最简单的方法就是将所有的 vtbl 都放入到每一个目标文件中，扩展所有该文件用到的模板例程和外部 inline 函数，这样做的结果就是产生大量的冗余代码。</p>
<p>在那些使用简单链接器的系统上，某些 C++系统使用了一种迭代链接的方法，并采用独立的数据库来管理将哪些函数扩展到哪些地方，或者添加 progma（向编译器提供信息的程序源代码）向编译器反馈足够的信息以仅仅产生必须的代码。链接器的方法是让编译器在每个目标文件中生成所有可能的重复代码，然后让链接器来识别和消除重复的代码。</p>
<p>GNU 链接器是通过定义一个“link once”类型的区段（与公共块很相似）来解决这个模板的问题的。如果链接器看到诸如.gnu.linkonce.name 之类的区段名称，它会将第一个明确命名的此类区段保留下来并忽略其它冗余区段。同样编译器会将模板扩展到一个采用简化模板名称的.gnu.linkonce 区段中。</p>
<p>这种策略工作的相当不错，但它并不是万能的。例如，它不能保护功能上并不完全相同的 vtbl 和扩展模板。一些链接器尝试去检查被忽略的和保留的区段是否是每个字节都相同。这种方法是很保守的，但是如果两个文件采用了不同的优化选项，或编译器的版本不同，就会产生报错信息。另外，它也不能尽可能多的忽略冗余代码。在多数 C++系统中，所有的指针都具有相同的内部表示，这意味着一个模板的具有指向 int 类型指针参数的实例和指向float 类型指针参数的实例会产生相同的代码（即使它们的 C++数据类型不同）。某些链接器也尝试忽略那些和其它区段每个字节都相同的 link-once 区段，哪怕它们的名字并不是完全的相同，但这个问题仍然没有得到满意的解决。</p>
<h1 id="符号管理"><a href="#符号管理" class="headerlink" title="符号管理"></a>符号管理</h1><p>符号管理是链接器的关键功能。如果没有某种方法来进行模块之间的引用，那么链接器的其它功能也就没有什么太大的用处了。</p>
<h2 id="绑定和名字解析"><a href="#绑定和名字解析" class="headerlink" title="绑定和名字解析"></a>绑定和名字解析</h2><p>链接器要处理各种类型的符号。所有的链接器都要处理各模块之间符号化的引用。每个输入模块都有一个符号表。其中的符号包括：</p>
<ul>
<li>当前模块中被定义（和可能被引用）全局符号。</li>
<li>在被模块中被引用但未被定义的全局符号（通常成为外部符号）。</li>
<li>段名称，通常被当作定义在段起始位置的全局符号。</li>
<li>非全局符号，调试器或崩溃转储（crash dump）分析通常会用到它们。这些符号几乎不会被链接过程用到，但有时候它们经常会和全局符号混在一起，所以链接器至少要能够跳过它们。在另一些情况中它们会在文件中一个单独的表中，或在一个单独的调试信息文件中。</li>
</ul>
<p>链接器读入输入文件中所有的符号表，并提取出有用的信息，有时就是输入的信息，通常都是关于需要链接哪些东西的。然后它会建立链接时符号表并使用该表来指导链接过程。根据输出文件格式的不同，链接器会将部分或全部的符号信息放置在输出文件中。某些格式会在一个文件中存在多个符号表。例如 ELF 共享库会有一个动态链接所需信息的符号表，和一个单独的更大的用来调试和重链接的符号表。这个设计不见得糟糕。动态链接器所需的表比全部的表通常要小得多，将它独立出来可以加快动态链接的速度，毕竟调试或重链接一个库的机会（相比运行这个库）还是很少的。</p>
<h2 id="符号表格式"><a href="#符号表格式" class="headerlink" title="符号表格式"></a>符号表格式</h2><p>链接器中的符号表与编译器中的相近，由于链接器中用到的符号一般没有编译器中的那么复杂，所以符号表通常也更简单一些。在链接器内，有一个列出输入文件和库模块的符号表，保留了每一个文件的信息。第二个符号表处理全局符号，即链接器需要在输入文件中进行解析的符号。第三个表可以处理模块内调试符号，尽管少数情况下链接器也会为调试符号建立完整的符号表，但通常都只需将输入的调试符号传递到输出文件。</p>
<p>在链接器本身内部，符号表通常以表项组成的数组形式来保存，并通过一个 hash 函数来定位表项，或者是由指针组成的数组，并通过 hash 函数来索引，相同 hash 的表项以链表的形式来组织。当需要在表中定位一个符号时，链接器根据符号名计算 hash 值，将该值用桶的个数来取模，以定位某一个 hash 桶，然后遍历其中的符号链表来查找符号。</p>
<h3 id="模块表"><a href="#模块表" class="headerlink" title="模块表"></a>模块表</h3><p>链接器需要跟踪整个链接过程中出现的每一个输入模块，即包括明确链接的模块，也包括从库中提取出来的模块。图 2 所示可以产生 a.out 目标文件的 GNU 链接器的简化版模块表结构。由于每个 a.out 文件的关键信息大部分都在文件头部中，该表仅仅是将文件头部复制过来。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 该文件名称 */</span></span><br><span class="line"><span class="keyword">char</span> *filename;</span><br><span class="line"><span class="comment">/* 符号名字串起始地址 */</span></span><br><span class="line"><span class="keyword">char</span> *local_sym_name;<span class="comment">/* 描述文件内容的布局 */</span></span><br><span class="line"><span class="comment">/* 文件的 a.out 头部 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">exec</span> <span class="title">header</span>;</span></span><br><span class="line"><span class="comment">/* 调试符号段在文件内的偏移量，如果没有则为 0 */</span></span><br><span class="line"><span class="keyword">int</span> symseg_offset;</span><br><span class="line"><span class="comment">/* 描述从文件中加载到内核的数据 */</span></span><br><span class="line"><span class="comment">/* 文件的符号表 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nlist</span> *<span class="title">symbols</span>;</span></span><br><span class="line"><span class="comment">/* 字串表大小，以字节为单位 */</span></span><br><span class="line"><span class="keyword">int</span> string_size;</span><br><span class="line"><span class="comment">/* 指向字串表的指针 */</span></span><br><span class="line"><span class="keyword">char</span> *strings;</span><br><span class="line"><span class="comment">/* 下面两个只在 relocatable_output 为真，或输出未定义引用的行号时使用 */</span></span><br><span class="line"><span class="comment">/* 文本和数据的重定位信息 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">relocation_info</span> *<span class="title">textrel</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">relocation_info</span> *<span class="title">datarel</span>;</span></span><br><span class="line"><span class="comment">/* 该文件的段与输出文件的关系 */</span></span><br><span class="line"><span class="comment">/* 该文件中文本段在输出文件核心镜像中的起始地址 */</span></span><br><span class="line"><span class="keyword">int</span> text_start_address;</span><br><span class="line"><span class="comment">/* 该文件中数据段在输出文件核心镜像中的起始地址 */</span></span><br><span class="line"><span class="keyword">int</span> data_start_address;</span><br><span class="line"><span class="comment">/* 该文件中 BSS 段在输出文件核心镜像中的起始地址 */</span></span><br><span class="line"><span class="keyword">int</span> bss_start_address;</span><br><span class="line"><span class="comment">/* 该文件中第一个本地符号在输出文件中符号表中的偏移量，以字节为单位 */</span></span><br><span class="line"><span class="keyword">int</span> local_syms_offset;</span><br></pre></td></tr></table></figure></p>
<p>该表中还包含了指向符号表、字串表（在一个 a.out 文件中，符号名称字串是在符号表外另一个单独的表中）和重定位表在内存中副本的指针，同时还有计算好的文本、数据和 BSS 段在输出中的偏移量。如果该文件是一个库，每一个被链接的库成员还有它自己的模块表表项。</p>
<p>第一遍扫描中，链接器从每一个输入文件中读入符号表，通常是将它们一字不差的复制到内存中。在将符号名放入单独的字串表的符号格式中，链接器还要将符号表读入，并且为了后续处理更容易一些，还要遍历符号表将每一个的名称字串偏移量转换为指向内存中名称字串的指针。</p>
<h3 id="全局符号表"><a href="#全局符号表" class="headerlink" title="全局符号表"></a>全局符号表</h3><p>链接器会保存一个全局符号表，在任何输入文件中被引用或者定义的符号都会有一个表项，如图 3 所示。每次链接器读入一个输入文件，它会将该文件中所有的全局符号加入到这个符号表中，并将定义或引用每个符号的位置用链表组织起来。当第一遍扫描完成后，每一个全局符号应当仅有一个定义，0 或多个引用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 摘自 GNU ld a.out */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">glosym</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">/* 指向该符号所在 hash 桶中下一个符号的指针 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">glosym</span> *<span class="title">link</span>;</span></span><br><span class="line"><span class="comment">/* 该符号的名称 */</span></span><br><span class="line"><span class="keyword">char</span> *name;</span><br><span class="line"><span class="comment">/* 作为全局符号的符号值 */</span></span><br><span class="line"><span class="keyword">long</span> value;</span><br><span class="line"><span class="comment">/* 该符号在文件中的外部 nlist 链表，包括定义和引用 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nlist</span> *<span class="title">refs</span>;</span></span><br><span class="line"><span class="comment">/* 非零值则意味该符号被定义为公共块，该数值即各公共块中的最大尺寸 */</span></span><br><span class="line"><span class="keyword">int</span> max_common_size;</span><br><span class="line"><span class="comment">/* 非零意味着该全局符号是存在的。库程序不能根据该数值加载 */</span></span><br><span class="line"><span class="keyword">char</span> defined;</span><br><span class="line"><span class="comment">/* 非零则意味着一个确信被加载的文件中引用了该全局符号。大于 1 的数值是该</span></span><br><span class="line"><span class="comment">符号定义的 n_type 编码</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">char</span> referenced;</span><br><span class="line"><span class="comment">/* 1 表示该符号具有多个定义</span></span><br><span class="line"><span class="comment">2 表示该符号具有多个定义，其中一些是集合元素，并且有一个已经被打印出</span></span><br><span class="line"><span class="comment">来了</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> multiply_defined;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于每个输入文件中的全局符号都被加入到全局符号表中，链接器会将文件中每一个项链接到它们在全局符号表中对应的表项中。重定位项一般通过索引模块自己的符号表来指向符号，因此对于每一个外部引用，链接器必须要对此很清楚，例如模块 A 中的符号 15 名为 fruit，模块 B 中的符号 12 同样名为 fruit，也就是说，它们是同一个符号。每一个模块都有自己的索引集，相应也要用自己的指针向量。</p>
<h3 id="符号解析"><a href="#符号解析" class="headerlink" title="符号解析"></a>符号解析</h3><p>在链接的第二遍扫描过程中，链接器在创建输出文件时会解析符号引用。解析的细节与重定位是有相互影响的，这是因为在多数目标格式中，重定位项标识了程序中对符号的引用。在最简单的情况下，即链接器使用绝对地址来创建输出文件（如 UNIX 链接器中的数据引用），解析仅仅是用符号地址来替换符号的引用。如果符号被解析到地址 20486 处，则链接器会将相应的引用替换为 20486。</p>
<p>实际情况要复杂得多。诸如，引用一个符号就有很多种方法，通过数据指针，嵌入到指令中，甚至通过多条指令组合而成。此外，链接器生成的输出文件本身经常还是可以再次链接的。这就是说，如果一个符号被解析为数据区段中的偏移量 426，那么在输出中引用该符号的地方要被替换为可重定位引用的<code>[数据段基址+426]</code>。输出文件通常也拥有自己的符号表，因此链接器还要新创建一个在输出文件中符号的索引向量，然后将输出重定位项中的符号编号映射到这些新的索引中。</p>
<h3 id="特殊符号"><a href="#特殊符号" class="headerlink" title="特殊符号"></a>特殊符号</h3><p>很多系统还会使用少量链接器自己定义的特殊符号。所有的 UNIX 系统都要求链接器定义 etext、edata 和 end 符号依次作为文本、数据和 BSS 段的结尾。系统调用<code>sbrk()</code>将 end 的地址作为运行时内存堆的起始地址，所以堆可以连续的分配在已经存在的数据和 BSS 的后面。对于具有构造和析构例程的程序，很多链接器会为每一个输入文件创建指向这些例程的指针表，并通过链接器创建的诸如<code>__CTOR_LIST__</code>这样的符号让该语言的启动代码可以找到这个表并依次调用其中所有的例程。</p>
<h2 id="名称修改"><a href="#名称修改" class="headerlink" title="名称修改"></a>名称修改</h2><p>在目标文件符号表和链接中使用的名称，与编译目标文件的源代码程序中使用的名称往往是有差别的。主要原因有 3：避免名称冲突，名称超载，和类型检查。将源代码中的名称转换为目标文件中的名称的过程称为名称修改（name mangling）。</p>
<h3 id="简单的-C-和-Fortran-名称修改"><a href="#简单的-C-和-Fortran-名称修改" class="headerlink" title="简单的 C 和 Fortran 名称修改"></a>简单的 C 和 Fortran 名称修改</h3><p>预留名称的问题一直存在。在混合语言的程序中，情况甚至更糟，因为所有语言的代码都要避免使用任何其它语言运行时库中已经用到的名称。解决预留名称问题的方法之一是用其它东西（而不是过程调用）来调用运行时库。UNIX 系统采取的办法是修改 C 和 Fortran 过程的名称这样就不会因为疏忽而与库和其它例程中的名称冲突了。C 过程的名称通过在前面增加下划线来修饰，所以 main 就变成了_main。Fortran 的名称进一步被修改首尾各有一个下划线，所以 calc 就成了<em>calc</em>（这种独特的方法使得从 Fortran 中可以调用 C 中名字末尾带有下划线的例程，这样就可以用 C 编写 Fortran 的库）。</p>
<p>在其它系统上，编译器设计者们采取了截然相反的方法。多数汇编器和链接器允许在符号中使用 C 和 C++标识符中禁用的字符，如.或者$。运行库会使用带有禁用字符的名称来避免与应用程序的名称冲突，而不再是修改 C 或 fortran 程序中的名称。</p>
<h3 id="C-类型编码：类型和范围"><a href="#C-类型编码：类型和范围" class="headerlink" title="C++类型编码：类型和范围"></a>C++类型编码：类型和范围</h3><p>在一个 C++程序中，程序员可以定义很多具有相同名称但范围不同的函数和变量，对于函数，还有参数类型。一个单独的程序可以具有一个名为 V 的全局变量和一个类中的静态成员 C::V。C++允许函数名重载，即一些具有相同名称不同参数的函数，例如 f(int x)和 f(float x)。类的定义可以括入函数，括入重载名称，甚至括入重新定义了内嵌操作的函数，即一个类可以包含一个函数，它的名字实际上可以是&gt;&gt;或其它内建操作符。</p>
<p>C++类之外的数据变量名称不会进行任何的修改。一个名为 foo 的数组修改后的名称仍为 foo。与类无关的函数名称修改后增加了参数类型的编码，通过前缀<code>__F</code>后面跟表示参数类型的字母串来实现。下面列出了各种可能的类型表示。例如，函数<code>func(float, int, unsigned char)</code>变成了<code>func__FfiUc</code>。类的名称会被当作是各种类型来对待，编码为类名称长度数字后面跟类的名称，例如 4Pair。类还可以包含内部多级子类的名称，这种限定性（qualified）名称被编码为 Q，还有一个数字标明该成员的级别，然后是编码后的类名称。因此 <code>First::Second::Third</code>就变成了<code>Q35First6Second5Third</code>。这意味着采用两个类做为参数的函数<code>f(Pair, First::Second::Third)</code>就变成了<code>f__F4PairQ35First6Second5Third</code></p>
<table>
<thead>
<tr>
<th>类型</th>
<th>字母</th>
</tr>
</thead>
<tbody>
<tr>
<td>void</td>
<td>v</td>
</tr>
<tr>
<td>char</td>
<td>c</td>
</tr>
<tr>
<td>short</td>
<td>s</td>
</tr>
<tr>
<td>int</td>
<td>i</td>
</tr>
<tr>
<td>long</td>
<td>l</td>
</tr>
<tr>
<td>float</td>
<td>f</td>
</tr>
<tr>
<td>double</td>
<td>d</td>
</tr>
<tr>
<td>long double</td>
<td>r</td>
</tr>
<tr>
<td>varargs</td>
<td>e</td>
</tr>
<tr>
<td>unsigned</td>
<td>U</td>
</tr>
<tr>
<td>const</td>
<td>C</td>
</tr>
<tr>
<td>volatile</td>
<td>V</td>
</tr>
<tr>
<td>signed</td>
<td>S</td>
</tr>
<tr>
<td>pointer</td>
<td>P</td>
</tr>
<tr>
<td>reference</td>
<td>R</td>
</tr>
<tr>
<td>array of length n</td>
<td>An_</td>
</tr>
<tr>
<td>function</td>
<td>F</td>
</tr>
<tr>
<td>pointer to nth member</td>
<td>MnS</td>
</tr>
</tbody>
</table>
<p>类的成员函数编码为：先是函数名，然后是两个下划线，接着是编码后的类名称，然后是<code>F</code>和参数，所以<code>cl::fn(void)</code>就变成了<code>fn__2clFv</code>。所有的操作符都具有 4 到 5 个字符的编码后名称，诸如<code>*</code>对应<code>__ml</code>，<code>|=</code>对应<code>__aor</code>。包括构造、析构、new 和 delete 在内的特殊函数编码为<code>__ct</code>、<code>__dt</code>、<code>__nw</code>和<code>__dl</code>。因此具有两个字符指针参数的类<code>Pair</code>的构造函数<code>Pair(char *, char*)</code>的名称就变成了<code>__ct__4PairFPcPc</code>。最后，由于修改后的名称会变得很长，因此对具有多个相同类型参数的函数有两种简捷编码。代码<code>Tn</code>表示“与第 n 个参数类型相同”，<code>Nnm</code>表示“n 个参数与第 m 个参数的类型相同”。因此函数<code>segment(Pair, Pair)</code>的名称就成了<code>segment__F4PairT1</code>，而函数<code>trapezoid(Pair, Pair, Pair, Pair)</code>的名称就是<code>trapezoid__F4PairN31</code>。名称修改可以为每一个可能的 C++类提供唯一的名称，相应的代价就是在错误信息和列表中会出现惊人长度和（在没有链接器和调试器支持下）难以理解的名称。尽管如此，C++还有一个本质上的问题就是名字空间相当巨大。任何表示 C++对象名称的策略都会具有和名称修改相近的冗余，而名称修改的优势在于至少还有一些人可以读懂它。</p>
<p>名称修改的早期用户经常会发现虽然链接器在理论上支持长名称，但实际上长名称效果并不很好，尤其针对具有大量仅最后几个字符不同的名称的程序，性能非常糟糕。幸运的是，符号表算法是一个很好理解的方法，我们可以期望链接器通过它顺利的处理长名称。</p>
<h3 id="链接时类型检查"><a href="#链接时类型检查" class="headerlink" title="链接时类型检查"></a>链接时类型检查</h3><p>链接器类型检查的想法非常简单。多数语言都有声明了参数类型的过程，如果调用者没有将被调用过程期望的参数个数或类型传递给被调用者，那就是错误，如果调用者和被调用者在不同的文件中被编译，那这种错误是非常难以察觉的。对于链接器类型检查，每一个定义和未定义的全局符号都会有一个用字串表示的参数和返回值类型，与名称修改中的 C++参数类型相近。在链接器解析一个符号时，它将引用处的类型串与符号定义处的类型串进行比较，如果不匹配则报错。这个策略的好处之一就是链接器根本不需要理解类型编码的含义，仅仅比较字串是否相同就可以了。</p>
<p>即使在一个支持 C++名称修改的环境中，由于并不是所有的 C++类型信息都会被编码到修改的名称中，因此这种类型检查仍然非常有用。通过与此类似的策略来进行函数返回值类型、全局数据类型的检查也是非常有益的。</p>
<h2 id="维护调试信息"><a href="#维护调试信息" class="headerlink" title="维护调试信息"></a>维护调试信息</h2><p>编译器通过将调试信息插入目标文件来实现的，调试信息包括源代码行号到目标代码地址的映射，并描述了程序中用到的所有函数、变量、类型和数据结构。</p>
<h3 id="行号信息"><a href="#行号信息" class="headerlink" title="行号信息"></a>行号信息</h3><p>所有基于符号的调试器都必须将程序地址和源代码行号对应起来。这样就可以通过调试器将断点放入代码的适当位置来实现用户基于源代码行号的断点设置，并可以让调试器将调用堆栈中的程序地址和错误报告中的源代码行号关联起来。除优化编译代码外，行号信息是很简单的。优化编译的代码中会去除一些代码，导致目标文件中的代码序列与源代码行号的序列不匹配。</p>
<p>对于编译器生成代码所对应源代码文件中的每一行语句，编译器会产生一个行号项（包括行号和代码开始位置）。如果一个程序地址跨越了两个行号项，调试器会将两个行号中较小的报告出来。行号还需要被文件名称（包括源文件名称和头文件名称）限定。有一些格式会通过创建一个文件列表并将文件索引放入每一个行号项中来实现这一点，行号列表中的“begin include”和“end include”项，内在的维护了有行号成员组成的栈。</p>
<p>当编译器优化根据语句生成不连续的代码时，一些目标格式（DWARF）让编译器将每一个字节都映射回源代码中的一行，这会占用进程的大量空间，而其它格式则仅仅产生一个大概的位置。</p>
<h3 id="符号和变量信息"><a href="#符号和变量信息" class="headerlink" title="符号和变量信息"></a>符号和变量信息</h3><p>编译器还要为每一个程序变量生成名称、类型和位置。调试符号信息某种程度上要比名称修改更为复杂，因为它不仅要对类型名称编码，还有定义类型时的数据结构类型，这样才能保证调试器能够正确处理一个数据结构中的所有子域的格式。</p>
<p>符号信息可以是一个隐式或显式的树结构。每个文件的最顶层是在最顶层定义的类型、变量和函数的列表，每一个内部是数据结构的子域，或函数内部定义的变量，诸如此类。在函数内部，包含“begin block”和“end block”的树标识了对行号的引用，这样调试器就可以指出程序中每一个变量的范围了。</p>
<p>符号信息中最有趣的部分是位置信息。静态变量的位置不会改变，但一个例程中的局部变量可能是静态的，可能在栈里、在寄存器里、在优化后的代码里，在例程的不同部分可能会从一个地方移动到另一个地方。在多数体系结构上，标准的例程调用序列会为每一个嵌套的例程维护保存堆栈和框指针（frame pointer）的链，每个例程中的局部栈变量存放在相对于框指针的已知偏移量处。在叶子例程或者没有分配局部栈变量的例程中，有一个通常使用的优化就是跳过对框指针的设置。为了正确解释栈的调用轨迹并在没有框指针的例程中寻找局部变量，调试器就必须清楚这些。</p>
<h3 id="实际的问题"><a href="#实际的问题" class="headerlink" title="实际的问题"></a>实际的问题</h3><p>多数情况下，链接器仅仅传递调试信息而不对其进行解释，也可能在这个过程中会重定位和段相关的地址。链接器开始做的一件事情就是探测和去除重复调试信息。在 C 和某些特定的 C++中，程序通常都会有一系列定义类型和声明函数的头文件，每一个源文件会将定义了该文件可能使用的类型和函数的头文件都包括进来。</p>
<p>编译器会为每一个源代码文件包括的所有头文件中的所有内容都扫描生成调试信息。这意味着如果某个特定的头文件被 20 个会编译和链接到一起的源文件所包括的话，那链接器将会收到该文件的 20 份调试信息副本。虽然保留这些冗余信息调试器工作起来不会有任何麻烦，但头文件，尤其是在 C++中会有大量的头文件，这意味着重复的头文件信息是相当巨大的。链接器可以放心的忽略掉重复的部分，这样既可以加快链接器和调试器的速度，也可以节省空间。某些情况下，编译器会将调试信息直接放到文件或数据库中供调试器读取，而绕过了链接器。这样链接器就只需要添加和升级与分布在源文件中的各个段相对位置有关的信息即可，而诸如跳转表之类的数据会由链接器自己来创建。</p>
<p>当调试信息存储在目标文件中时，有时候调试信息会和链接器符号表混杂在一个大的符号表中，而有时，它们是独立的。很多年来，UNIX 系统一点一点增加了编译器中的调试信息，最后就变成了现在这个巨大的符号表。包括微软 ECOFF 在内的其它一些格式趋向于将链接器符号、调试符号和行号信息分开处理。</p>
<p>有时调试信息结果会存储到输出文件中，有时会输出到单独的调试文件，有时两者都会有。在构建过程中将所有调试信息都放到输出文件中的做法有一个显而易见的好处，就是调试程序所需要的信息都存放在一个地方。明显的缺点就是这将导致可执行程序体积非常庞大。</p>
<h1 id="库"><a href="#库" class="headerlink" title="库"></a>库</h1><h2 id="库的目的"><a href="#库的目的" class="headerlink" title="库的目的"></a>库的目的</h2><p>从本质上说，库文件就是由多个目标文件聚合而成的，通常还会加入一些有助于快速查找的目录信息。</p>
<h2 id="库的格式"><a href="#库的格式" class="headerlink" title="库的格式"></a>库的格式</h2><p>最简单的库格式就是仅仅将目标模块顺序排列。在诸如磁带和纸带这样的顺序访问介质上，对于增加目录要注意的是，由于链接器不得不将整个库读入，因此跳过库成员和将他们读入的速度差不多。但在磁盘上，目录可以相当显著的提高库搜索速度，现在已经成为了标准组件。</p>
<p>UNIX 链接器库使用一种称为“archive”的格式，它实际上可以用于任何类型文件的聚合，但实践中很少用于其它地方。库的组成，首先是一个 archive 头部，然后交替着是文件头部和目标文件。最早的 archive 没有符号目录，只有一系列的目标文件，但后续版本就出现了多种类型的目录。</p>
<p>所有的现代 UNIX 系统都采用大同小异的 archive 格式，如下所示。该格式在 archive头部中只使用文本字符，这意味着文本文件的 archive 文件本身就是文本的。archive 文件都是以 8 字符的标志串<code>!&lt;arch&gt;\n</code>开头，其中<code>\n</code>是换行符。在每一个 archive 成员之前是一个 60 字节的头部，包含有：</p>
<ul>
<li>该成员名称，补齐到 16 个字符（下面会讲到）。</li>
<li>修改时间，由从 1970 年到当时的十进制秒数表示。</li>
<li>十进制数字表示的用户和组 ID。</li>
<li>一个八进制数表示的 UNIX 文件模式。</li>
<li>以字节为单位的十进制数表示的文件尺寸。如果该尺寸为奇数，那么文件的内容中会补齐一个换行符使得总长度为偶数，但这个补齐的字符不会计算在文件尺寸域中。</li>
<li>保留的两个字节，为引号和换行符。这样就可以让头部成为一行文本，并可用来简单的验证当前头部的有效性。</li>
</ul>
<p>每一个成员头部都会包含修改时间、用户和组 ID、文件模式，尽管链接器会将它们忽略。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">File header:</span><br><span class="line">!&lt;arch&gt;\n</span><br><span class="line">Member header:</span><br><span class="line"><span class="keyword">char</span> name[<span class="number">16</span>]; <span class="comment">/* 成员名称 */</span></span><br><span class="line"><span class="keyword">char</span> modtime[<span class="number">12</span>]; <span class="comment">/* 修改时间 */</span></span><br><span class="line"><span class="keyword">char</span> uid[<span class="number">6</span>]; <span class="comment">/* 用户 ID */</span></span><br><span class="line"><span class="keyword">char</span> gid[<span class="number">6</span>]; <span class="comment">/* 组 ID */</span></span><br><span class="line"><span class="keyword">char</span> mode[<span class="number">8</span>]; <span class="comment">/* 8 进制文件模式 */</span></span><br><span class="line"><span class="keyword">char</span> size[<span class="number">10</span>]; <span class="comment">/* 成员大小 */</span></span><br><span class="line"><span class="keyword">char</span> eol[<span class="number">2</span>]; <span class="comment">/* 保留空间，一对引号/换行符 */</span></span><br></pre></td></tr></table></figure></p>
<p>成员名称是 15 个字符或更少，紧随其后的空格将它补齐为 16 个字符，或者在 COFF 或 ELF 的 archive 格式中，会在斜杠后面跟随足够多的空格将总数补齐为 16 个字符。</p>
<h3 id="搜索库文件"><a href="#搜索库文件" class="headerlink" title="搜索库文件"></a>搜索库文件</h3><p>一个库文件在创建后，链接器还要能够对它进行搜索。库的搜索通常发生在链接器的第一遍扫描时，在所有单独的输入文件都被读入之后。如果一个或多个库具有符号目录，那么链接器就将目录读入，然后根据链接器的符号表依次检查每个符号。如果该符号被使用但是未定义，链接器就会将符号所属文件从库中包含进来。仅将文件标识为稍后加载是不够的，链接器必须像处理那些在显式被链接的文件中的符号那样，来处理库里各个段中的符号。段会记入段表，而符号，包括定义的和未定义的，都会记入全局符号表。一个库例程引用了另一个库中例程的符号是相当普遍的现象，譬如诸如 printf 这样的高级 I/O 例程会引用像 putc 或 write 这样的低级例程。</p>
<p>库符号解析是一个迭代的过程，在链接器对目录中的符号完成一遍扫描后，如果在这遍扫描中它又从该库中包括进来了任何文件，那么就还需要再进行一次扫描来解析新包括进来的文件所需的符号，直到对整个目录彻底扫描后不再需要括入新的文件为止。并不是所有的链接器都这么做的，很多链接器只是对目录进行一次连续的扫描，并忽略在库中一个文件对另一个更早扫描的文件的向后依赖。像诸如 tsort 和 lorder 这样的程序可以尽量减少由于一遍扫描给链接器带来的困难，不过并不推荐程序员通过显式的将相同名称的库在链接器命令行中列出多次来强制进行多次扫描并解析所有符号。</p>
<p>UNIX 链接器和很多 Windows 链接器在命令行或者控制文件中会使用一种目标文件和库混合在一起的列表，然后依次处理，这样程序员就可以控制加载目标代码和搜索库的顺序了。虽然原则上这可以提供相当大的弹性并可以通过将同名私有例程列在库例程之前而在库例程中插入自己的私有同名例程，在实际中这种排序的搜索还可以提供一些额外的用处。程序员总是可以先列出所有他们自己的目标文件，然后是任何应用程序特定的库，然后是和数学、网络等相关的系统库，最后是标准系统库。</p>
<p>当程序员们使用多个库的时候，如果库之间存在循环依赖的时候经常需要将库列出多次。就是说，如果一个库 A 中的例程依赖一个库 B 中的例程，但是另一个库 B 中的例程又依赖了库 A 中的另一个例程，那么从 A 扫描到 B 或从 B 扫描到 A 都无法找到所有需要的例程。当这种循环依赖发生在三个或更多的库之间时情况会更加糟糕。告诉链接器去搜索 A B A 或者 B A B，甚至有时为 A B C D A B C D，这种方法看上去很丑陋，但是确实可以解决这个问题。</p>
<h3 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h3><p>和库相关的主要性能问题是花费在顺序扫描上的时间。一旦符号目录成为标准之后，从一个库中读取输入文件的速度就和读取单独的输入文件没有什么明显差别了，而且只要库是拓扑排序的，那链接器在基于符号目录进行扫描时很少会超过一遍。如果一个库有很多小尺寸成员的话，库搜索的速度也会很慢。一个典型的 UNIX 系统库有超过 600 个成员。尤其是现在很普遍的一种情况就是库的所有成员会在运行时合并为一个单一的共享库，因此如果创建一个单一的目标文件包定义库中所有的符号，而在链接时使用这个目标文件而不进行库的搜索，那么这种方法的速度似乎可以更快一点。</p>
<h2 id="弱外部符号"><a href="#弱外部符号" class="headerlink" title="弱外部符号"></a>弱外部符号</h2><p>符号解析和库成员选择中所采用的简单的定义引用模式对很多应用而言显得灵活有余效率不足。例如，大多数 C 程序会调用 printf 函数族中的例程来格式化输出数据。printf可以格式化各种类型的数据，包括浮点类型。这就意味着任何使用 printf 的程序都会将浮点库链接进来，即便它根本不使用浮点数。</p>
<p>C库的布局见下，它利用了链接器顺序搜索库的特点。如果程序使用了浮点，那么对 fltused 的引用将会导致链接真正的浮点例程，包括真正的 fcvt（浮点输出例程）。然后当 I/O 模块被链接进来以定义 printf 时，就已经有一个可以满足 I/O 模块引用的 fcvt 在那里了。在那些不使用浮点的程序中，由于不会有任何未解析的符号，在 I/O 模块中引用的 fcvt 将会<br>解析为库中跟在 I/O 例程后面的伪2浮点例程，因此真正的浮点例程将不会被加载。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">真正的浮点模块，定义 fltused 和 fcvt</span><br><span class="line">I/O 模块，定义调用 fcvt 的 printf 函数</span><br><span class="line">伪浮点例程，定义了伪 fcvt</span><br></pre></td></tr></table></figure>
<p>虽然这个技巧可以工作，但用它处理多于一个或两个以上的符号时就会变得很难处理，而且它的正确性严重依赖于库中模块的顺序，尤其在重新构建库之后很容易产生问题。解决这个困境的方法就是弱外部符号，就是不会导致加载库成员的外部符号。如果该符号存在一个有效的定义，无论是从一个显式链接的文件还是普通的外部引用而被链接进来的库成员中，一个弱外部符号会被解析为一个普通的外部引用。但是如果不存在有效的定义，弱外部符号就不被定义而实际上解析为 0，这样就不会被认为是一个错误。在上面这个例子中，I/O 模块将会产生一个对 fcvt 的弱引用，真正的浮点模块在库中跟在 I/O 模块后面，并且不再需要伪例程。现在如果有一个对 fltused 的引用，则链接浮点例程并定义 fcvt。否则，对 fcvt 的引用保持未定义。这将不再依赖于库的顺序，即使对于对库进行多次扫描解析也没有问题。</p>
<p>ELF 还添加了另一种弱符号，和弱引用（weak reference）等价的弱定义(weak definition)。“弱定义”定义了一个没有有效的普通定义的全局符号。如果存在有效的普通定义，那么就忽略弱定义。弱定义并不经常使用，但在定义错误伪函数而无须将其分散在独立的模块中的时候，是很有用的。</p>
<h1 id="重定位"><a href="#重定位" class="headerlink" title="重定位"></a>重定位</h1><p>为了决定段的大小、符号定义、符号引用，并指出包含那些库模块、将这些段放置在输出地址空间的什么地方，链接器会将所有的输入文件进行扫描。扫描完成后的下一步就是链接过程的核心，重定位。由于重定位过程的两个步骤，判断程序地址计算最初的非空段，和解析外部符号的引用，是依次、共同处理的，所以我们讲重定位即同时涉及这两个过程。</p>
<p>链接器的第一次扫描会列出各个段的位置，并收集程序中全局符号与段相关的值。一旦链接器确定了每一个段的位置，它需要修改所有的相关存储地址以反映这个段的新位置。在大多数体系结构中，数据中的地址是绝对的，那些嵌入到指令中的地址可能是绝对或者相对的。</p>
<h2 id="硬件和软件重定位"><a href="#硬件和软件重定位" class="headerlink" title="硬件和软件重定位"></a>硬件和软件重定位</h2><p>硬件重定位允许操作系统为每个进程从一个固定共知的位置开始分配独立的地址空间，这就使程序容易加载，并且可以避免在一个地址空间中的程序错误破坏其它地址空间中的程序。软件链接器或加载器重定位将输入文件合并为一个大文件以加载到硬件重定位提供的地址空间中，然后就根本不需要任何加载时的地址修改了。</p>
<p>在诸如 286 或 386 那样有几千个段的机器上，实际上有可能做到为每一个例程或全局数据分配一个段，独立的进行软件重定位。每一个例程或数据可以从各自段的 0 位置开始，所有的全局引用通过查找系统段表中的段间引用来处理并在程序运行时绑定。不幸的是，x86段查找非常的慢，而且如果程序对每一个段间模块调用或全局数据引用都要进行段查找的话那速度要比传统程序慢的多。由于可信的理由，程序文件最好绑定在一起并且在链接时确定地址，这样它们在调试时静止不变而出货后仍能保持一致性。</p>
<h3 id="链接时重定位和加载时重定位"><a href="#链接时重定位和加载时重定位" class="headerlink" title="链接时重定位和加载时重定位"></a>链接时重定位和加载时重定位</h3><p>很多系统即执行链接时重定位，也执行加载时重定位。链接器将一系列的输入文件合并成一个准备加载到特定地址的单一输出文件。当这个程序被加载后，所存储的那个地址是无效的，加载器必须重新定位被加载得程序以反应实际的加载地址。实际的地址是根据有效的存储空间而定的，这个程序在被加载时总是会被重定位的。</p>
<p>加载时重定位和链接时重定位比起来就颇为简单了。在链接时，不同的地址需要根据段的大小和位置重定位为不同的位置。在加载时，整个程序在重定位过程中会被认为是大的单一段，加载器只需要判断名义上的加载地址和实际加载地址的差异即可。</p>
<h3 id="符号和段重定位"><a href="#符号和段重定位" class="headerlink" title="符号和段重定位"></a>符号和段重定位</h3><p>链接器的第一遍扫描将各个段的位置列出，并收集程序中所有全局符号和段相关的值。一旦链接器决定了每一个段的位置，它就需要调整存储地址。</p>
<ul>
<li>数据地址和段内绝对程序地址引用需要进行调整。例如，如果一个指针指向位置 1000，但是段基址被重定位为 1000，那么这个指针就需要被调整到位置 1000。</li>
<li>程序中的段间引用也需要被调整。绝对地址引用要调整为可以反映目标地址段的新位置，同样相对地址需要调整为可以同时反映目标段和引用所在段的新位置。</li>
<li>对全局符号的引用需要进行解析。如果一个指令调用了例程 detonate，并且 detonate 位于起始地址为 1000 的段的偏移地址 500，在这个指令中涉及到的地址要调整为 1500。</li>
</ul>
<p>重定位和符号解析所要求的条件有些许不同。对于重定位，基址的数量相当小，也就是一个输入文件中的段的个数，不过目标文件格式允许对任何段中任何地址的引用进行重定位。对于符号解析，符号的数量远远大的多，但是大多数情况下链接器只需要对符号做一件事，即将符号的值插入到程序的一个字大小的空间中。</p>
<p>很多链接器将段重定位和符号重定位统一对待，这是因为它们将段当作是一种值为段基址的“伪符号”。这使得和段相关的重定位就成了和符号相关的重定位的特例。即使在将两种重定位统一对待的链接器中，此二者仍有一个重要区别：一个符号引用包括两个加数，即符号所在段的基值和符号在段内的偏移地址。有一些链接器在开始进入重定位阶段之前就会预先计算所有的符号地址，将段基址加到符号表中符号的值中。当每一项被重定位时会查找到段基址并相加。大多数情况下，并没有强制的理由要以这种或那种方法来进行这种操作。在少数链接器，尤其是那些针对实模式 x86 代码的链接器中，一个地址可以被重定位到和若干不同段相关的多个地址上，因此链接器只需要确定在上下文中一个特定引用的符号在特定段中的地址。</p>
<h3 id="符号查找"><a href="#符号查找" class="headerlink" title="符号查找"></a>符号查找</h3><p>目标代码格式总是将每个文件中的符号当作数组对待，并在内部使用一个小整数指代符号，即数组的索引。这对链接器带来了一些小麻烦，每一个输入文件均有不同的索引，如果输出文件是可以重链接的话那它们也会有不同的索引。最直截了当的解决办法是为每个输入文件保留一个指针数组，指向全局符号表中的表项。</p>
<h2 id="基本的重定位技术"><a href="#基本的重定位技术" class="headerlink" title="基本的重定位技术"></a>基本的重定位技术</h2><p>每一个可重定位的目标文件都含有一个重定位表，其中是在文件中各个段里需要被重定位的一系列地址。链接器读入段的内容，处理重定位项，然后再解决整个段，通常就是将它写入到输出文件中。通常而不总是，重定位是一次操作，处理后的结果文件不能被重定位第二次。但一些目标文件格式，是可以重定位的并在输出文件中包含所有重定位信息。对于 UNIX 链接器，有一个选项能产生可再次链接的输出文件，在某些情况下，尤其是共享库，由于它在加载时需要被重新定位因此总是带有重定位信息。</p>
<p>在最简单的情况中，一个段的重定位信息仅是段中需要被重定位的位置列表。在链接器处理段时，它将段基址加上由重定位项标识的每个位置的地址。这就处理了直接寻址和内存中指向某个段的指针数值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">address | address | address | ...</span><br></pre></td></tr></table></figure></p>
<p>由于支持多个段和寻址模式的原因，在现代计算机上实际的程序会比这更复杂一些。经典的 UNIX a.out 格式，可能是解决这些问题的最简单的实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int address /* 文本或数据段中的偏移量 */</span><br><span class="line">unsigned int r_symbolnum ：24， /* 加到符号上的序数号 */</span><br><span class="line">r_pcrel ：1， /* 如果是指令相关的则为 1 */</span><br><span class="line">r_length ：2， /* 数值宽度的以 2 为底的 log 数 */</span><br><span class="line">r_extern ：1， /* 如果需要将符号加到数值上则为 1 */</span><br></pre></td></tr></table></figure>
<p>每个目标文件都有两个重定位项集合，一个是文本段的，一个是数据段的（bss 段被定义为全 0，因此没有什么需要重定位的）。每一个重定位项都有标志位 r_extern 指明它是段相关或者符号相关的项。如果该位为空，它是段相关的并且 r_symbolnum 实际上是段的一个代码，可能是 N_TEXT(4)， N_DATA(6)，或者 N_BBS(8)。pc_relative 位指明该引用针对当前位置是绝对还是相对的。</p>
<p>每一个重定位项的其它多余信息是和它的类型及对应的段相关的。在下面的讨论中，TR，DR 和 BR 依次分别是文本段、数据段、BSS 段的重定位后基址。</p>
<p>对同一个段中的指针或直接地址，链接器将地址 TR 或 DR 加到段中已经保存的数值上。对于从一个段到另一个段的指针或直接地址，链接器将目标段的重定位基址，TR，DR或 BR，加到存储的数值上。由于 a.out 格式的输入文件中已经带有每一个重定位到新文件的段中的目标地址，这就是所有必须的了。例如，假定在输入文件中，文本从地址 0 开始，数据从地址 2000 开始，并且在文本段中的一个指针指向数据段中偏移量为 200 的位置。在输入文件中，被存储的指针的值为 2200。如果最后在输出文件中数据段的重定位位置为 15000，那么 DR 将为 13000，链接器将会把 13000 加入到已存在的 2200 产生最后的数值 15200。</p>
<h2 id="可重链接和重定位的输出格式"><a href="#可重链接和重定位的输出格式" class="headerlink" title="可重链接和重定位的输出格式"></a>可重链接和重定位的输出格式</h2><p>有一小部分格式是可以重链接的，即输出文件带有符号表和重定位信息，这样可以作为下一次链接的输入文件来使用。很多格式是可以重定位的，这意味着输出文件保存有供加载时重定位使用的重定位信息。</p>
<p>对于可重链接文件，链接器需要从输入文件的重定位项中建立输出文件的重定位项。有一些重定位项被原样传递给输出了，有一些被修改了，还有一些被忽略了。对于那些不在相连段中且段相对地址固定的重定位项，通常会直接传递给输出而不需要对段索引进行修改，这是因为最终链接器还会对其进行链接。而在那些段相连格式中的重定位项，每一项的偏移量需要修改。例如，在一个被链接的 a.out 格式文件中，有一个位于某个文本段中偏移量为400 的段相对地址重定位向，如果另一个段与它所在的段相连且重定位在地址 3500 处，那么这个重定位项就要被修改为 3900 而不是 400。</p>
<p>符号解析项可以不加修改的传递，或因为段重定位而被修改，或被忽略。如果一个外部符号仍未被定义，那么链接器会传递这个重定位项给输出，可能会为了反映链接的段而修改偏移量和符号索引，以及输出文件符号表中的符号顺序。若这个符号被链接器根据符号引用的细节而解析。如果这个引用是同一个段中的程序计数器相对地址，鉴于引用的相对地址和目标不会移动，故链接器可以忽略掉它的重定位项。如果这个引用是绝对引用或段间引用，那重定位项就是相对于段的。</p>
<p>对于可以重定位但不能重链接的输出格式，链接器忽略掉除相对段地址固定的以外所有的重定位项。</p>
<h2 id="其它重定位格式"><a href="#其它重定位格式" class="headerlink" title="其它重定位格式"></a>其它重定位格式</h2><p>虽然多数重定位项的普遍格式是数组，但也有别的可能，包括链表和位图。多数格式也具有需要被链接器特殊对待的段。</p>
<h3 id="以链表形式组织的引用"><a href="#以链表形式组织的引用" class="headerlink" title="以链表形式组织的引用"></a>以链表形式组织的引用</h3><p>对于外部符号引用，一种意料之外的有效格式是在目标文件自身中包含的引用链表。符号表项指向一个引用，对应位置的一个字（译者注：即 2 个字节）宽的数据指向后面的另一个引用，一直延伸下去直到遇到诸如空或者-1 这样的截止符。这种方法在那些地址引用是完全一个字宽的体系结构上有效，或者至少引用地址宽度足以表示目标文件中段的最大尺寸。</p>
<p>但这个技巧不能解决带偏移量的符号引用，对于代码引用这个限制通常是可以接受的，但是对于数据引用就有问题了。例如在 C 语言中，可以写一个指向数组中间的被初始化的静态指针：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> a[];</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> *ap = &amp;a[<span class="number">3</span>];</span><br></pre></td></tr></table></figure></p>
<p>在 32 位的机器上，ap 的内容是 a 加上 12。和此问题差不多的还有对数据指针使用这种方法，或对无偏移量引用的普通情况使用了链表，或对带偏移量引用其它处理方式。</p>
<h2 id="特殊情况的重定位"><a href="#特殊情况的重定位" class="headerlink" title="特殊情况的重定位"></a>特殊情况的重定位</h2><p>很多目标文件格式都有“弱”外部符号：如果输入文件碰巧定义了它的话，那么它就会被当作是普通的全局符号，否则就为空。无论是哪种方式，都会像其它符号那样进行引用解析。</p>
<h1 id="加载和重叠"><a href="#加载和重叠" class="headerlink" title="加载和重叠"></a>加载和重叠</h1><p>加载是将一个程序放到主存里使其能运行的过程。链接加载器和单纯的加载器没有太大的区别，主要和最明显的区别在于前者的输出放在内存重而不是在文件中。</p>
<h2 id="基本加载"><a href="#基本加载" class="headerlink" title="基本加载"></a>基本加载</h2><p>依赖于程序是通过虚拟内存系统被映射到进程地址空间，还是通过普通的 I/O 调用读入，加载会有一点小小的差别。在多数现代系统中，每一个程序被加载到一个新的地址空间，这就意味着所有的程序都被加载到一个已知的固定地址，并可以从这个地址被链接。这种情况下，加载是颇为简单的：</p>
<ul>
<li>从目标文件中读取足够的头部信息，找出需要多少地址空间。</li>
<li>分配地址空间，如果目标代码的格式具有独立的段，那么就将地址空间按独立的段划分。</li>
<li>将程序读入地址空间的段中。</li>
<li>将程序末尾的 bss 段空间填充为 0，如果虚拟内存系统不自动这么做得话。</li>
<li>如果体系结构需要的话，创建一个堆栈段(stack segment)。</li>
<li>设置诸如程序参数和环境变量的其他运行时信息。</li>
<li>开始运行程序。</li>
</ul>
<p>如果程序不是通过虚拟内存系统映射的，读取目标文件就意味着通过普通的 read 系统调用读取文件。在支持共享只读代码段的系统上，系统检查是否在内存中已经加载了该代码段的一个拷贝，而不是生成另外一份拷贝。在进行内存映射的系统上，这个过程会稍稍复杂一些。系统加载器需要创建段，然后以页对齐的方式将文件页映射到段中，并赋予适当的权限，只读(RO)或写时复制(COW)。在某些情况下，相同的页会被映射两次，一个在一个段的末尾，另一个在下一个段的开头，分别被赋予 RO 和 COW 权限，格式上类似于紧凑的 UNIX a.out。由于数据段通常是和 bss 段是紧挨着的，所以加载器会将数据段所占最后一页中数据段结尾以后的部分填充为 0，然后在数据分配足够的空页面覆盖 bss 段。</p>
<h2 id="带重定位的基本加载"><a href="#带重定位的基本加载" class="headerlink" title="带重定位的基本加载"></a>带重定位的基本加载</h2><p>仅有一小部分系统还仍然为执行程序在加载时进行重定位，大多数都是为共享库在加载时进行重定位。</p>
<p>加载时重定位要比链接时重定位简单的多，因为整个程序作为一个单元进行重定位。例如，如果一个程序被链接为从位置 0 开始，但是实际上被加载到位置 15000，那么需要所有程序中的空间都要被修正为“加上 15000”。在将程序读入主存后，加载器根据目标文件中的重定位项，并将重定位项指向的内存位置进行修改。加载时重定位会表现出性能的问题，由于在每一个地址空间内的修正值均不同，所以被加载到不同虚拟地址的代码通常不能在地址空间之间共享。</p>
<h2 id="位置无关代码-1"><a href="#位置无关代码-1" class="headerlink" title="位置无关代码"></a>位置无关代码</h2><p>对于将相同程序加载到普通地址的问题的一个常用的解决方案就是位置无关代码(position independent code， PIC)。他的思想很简单，就是将数据和普通代码中那些不会因为被加载的地址改变而变化的代码分离出来。这种方法中代码可以在所有进程间共享，只有数据页为各进程自己私有。</p>
<p>在现代体系结构中，生成 PIC 可执行代码并不困难。跳转和分支代码通常是位置相关的，或者与某一个运行时设置的基址寄存器相关，所以需要对他们进行非运行时的重定位。问题在于数据的寻址，代码无法获取任何的直接数据地址。由于代码是可重定位的，而数据不是位置无关的。普通的解决方案是在数据页中建立一个数据地址的表格，并在一个寄存器中保存这个表的地址，这样代码可以使用相对于寄存器中地址的被索引地址来获取数据。这种方式的成本在于对每一个数据引用需要进行一次额外的重定位，但是还存在一个问题就是如何获取保存到寄存器中去的初始地址。</p>
<h3 id="例程指针表"><a href="#例程指针表" class="headerlink" title="例程指针表"></a>例程指针表</h3><p>在许多 UNIX 系统中采用的一种简单修改是将一个过程的数据地址假当作这个过程的地址，并在这个地址上放置一个指向该过程代码的指针。如要调用一个过程，调用者就将该例程的数据地址加载到约定好的数据指针寄存器，然后从数据指针指向的位置中加载代码地址到一个寄存器，然后调用这个历程。这很容易实现，而且性能还算不错。</p>
<h3 id="目录表"><a href="#目录表" class="headerlink" title="目录表"></a>目录表</h3><p>IBM AIX 使用了这种方案的改良版本。AIX 程序将多个例程组成模块，模块就是使用单独的或一组相关的 C/C++源代码文件生成的目标代码。每个模块的数据段保存着一个目录表(Table Of Content， TOC)，该表是由模块中所有例程和这些例程的小的静态数据的指针组成的。寄存器 2 通常用来保存当前模块的 TOC 地址，在 TOC 中允许直接访问静态数据，并可通过 TOC 中保存的指针间接访问代码和数据。由于调用者和被调用者共享相同的 TOC，因此在一个模块内的调用就是一个简单的 call 指令。模块之间的调用必须在调用之前切换 TOC，调用后再切换回去。</p>
<p>编译器将所有的调用都生成为 call 指令，其后还紧跟一个占位控操作指令 no-op，对于模块内调用这是正确的。当链接器遇到一个模块间调用时，他会在模块文本段的末尾生成一个称为 global linkage 或 glink 的例程。Glink 将调用者的 TOC 保存在栈中，然后从调用者的 TOC 中指针中加载被调用者的 TOC 和各种地址，然后跳转到要调用的例程。链接器将每一个模块间调用都重定向为针对被调用历程的 glink，并将其后的空操作指令修改为从栈中恢复 TOC 的加载指令。过程的指针都变为 TOC/代码配对(TOC/code pair)的指针，所有通过指针的 call 都会借助一个使用了该指针指向的 TOC 和代码地址的普通 glink 例程。这种方案使得模块内调用尽可能的快。模块间调用由于借助了 glink 所以会稍微慢一些，但是比起我们接下来要看到的其它替代方案来，这种速度的降低是很小的。</p>
<h3 id="ELF-位置无关代码"><a href="#ELF-位置无关代码" class="headerlink" title="ELF 位置无关代码"></a>ELF 位置无关代码</h3><p>UNIX SVR4 为它的 ELF 共享库引入了一个类似于 TOC 的位置无关代码(PIC)方案。SVR4方案现在被使用 ELF 可执行程序的系统广泛支持。它的优势在于将过程调用恢复为普通方式，即一个过程的地址就是这个过程的代码地址，不管它是存在于 ELF 库中的 PIC 代码，或存在于普通 ELF 可执行文件中的非 PIC 代码，付出的代价就是这种方案比 TOC 的开销稍多一些。</p>
<p>ELF 的设计者注意到一个 ELF 可执行程序中的代码页组跟在数据页组后面，不论程序被加载到地址空间的什么位置，代码到数据的偏移量是不变的。所以如果代码可以将他自己的地址加载到一个寄存器中，数据将位于相对于代码地址确定的位置，并且程序可以通过相对于某一个固定偏移量的基址寻址方式有效的引用自己数据段的数据。链接器将可执行文件中寻址的所有全局变量的指针保存在它创建的全局偏移量表(Global Offset Table， GOT)中（每一个共享库拥有自己的 GOT，如果主程序和 PIC 代码一起编译，它也会有一个 GOT，虽然通常不这么做）。鉴于链接器创建了 GOT，所以对于每个 ELF可执行程序的数据只有一个地址，而不论在该可执行程序中有多少个例程引用了它。</p>
<p>如果一个过程需要引用全局或静态数据，那就需要过程自己加载 GOT 的地址。虽然具体细节随体系结构不同而有所变化，但 386 的代码是比较典型的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">call .L2 ;; push PC in on the stack</span><br><span class="line">.L2:</span><br><span class="line">popl %ebx ;; PC into register EBX</span><br><span class="line">addl $_GLOBAL_OFFSET_TABLE_+[.-.L2]，%ebx;; adjust ebx to GOT address</span><br></pre></td></tr></table></figure></p>
<p>它存在一个对后面紧接着位置的<code>call</code>指令，这可以将 PC压入栈中而不用跳转，然后用<code>pop</code>指令将保存的 PC 加载到一个寄存器中并立刻加上<code>call</code>的目标地址和<code>GOT</code>地址之间的差。在一个由编译器生成的目标文件中，专门有一个针对<code>addl</code>指令操作数的<code>R_386_GOTPC</code>重定位项。它告诉链接器替换从当前指令到<code>GOT</code>基地址的偏移量，同时也是告诉链接器在输出文件中建立<code>GOT</code>的一个标记。在输出文件中，由于<code>addl</code>到<code>GOT</code>之间的距离是固定的，所以就不再需要重定位了。</p>
<p>上面这段代码是比较典型的，主要目的是获取<code>GOT</code>的地址，保存在<code>ebx</code>中，为以后访问程序的全局/局部变量作准备。<code>_GLOBAL_OFFSET_TABLE</code>是链接器可以理解的一个量，在链接的时候链接器会将它替换为当前指令地址到<code>GOT</code>基地址之间的距离差值。由于在引用这个量的时候，<code>ebx</code>中的地址是<code>call</code>指令行的地址，不是<code>addl</code>指令行的地址，所以<code>ebx</code>在加上<code>_BLOBAL_OFFSET_TABLE</code>之后，还要加上<code>addl</code>指令行到<code>call</code>指令行的距离<code>[.-.L2]</code>，才能够调整为<code>GOT</code>的基地址。</p>
<p><code>GOT</code>寄存器被加载之后，程序数据段中的静态数据与<code>GOT</code>直接的距离在链接时被固定了，所以代码就可以将<code>GOT</code>寄存器作为一个基址寄存器来引用局部静态数据。全局数据的地址只有在程序被加载后才被确定，所以为了引用全局数据，代码必须从<code>GOT</code>中加载数据的指针，然后引用这个指针。这个多余的内存引用使得程序稍微慢了一些，尽管大多数程序员为了方面的使用动态链接库愿意付出这个代价。对速度要求较高的代码可以使用静态共享库或者根本不使用共享库。</p>
<p>为了支持位置无关代码(PIC)，ELF 还定义了<code>R_386_GOTPC</code>(或与之等价的标识)之外的一些特殊重定位类型代码。这些类型是体系结构相关的，但是 x86 下的是比较典型的：</p>
<ul>
<li><code>R_386_GOT32</code>：GOT 中槽位(slot)的相对位置，链接器在这里存放了对于给定符号的指针。用来标识被引用的全局变量。</li>
<li><code>R_386_GOTOFF</code>：给定符号或地址相对于 GOT 基地址的距离。用来相对于 GOT 对静态数据进行寻址。</li>
<li><code>R_386_RELATIVE</code>：用来标记那些在 PIC 共享库中并在加载时需要重定位的数据地址。</li>
</ul>
<p>例如，参看下列 C 代码片断：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> a; <span class="comment">/* static variable */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> b; <span class="comment">/* global variable */</span></span><br><span class="line">...</span><br><span class="line">a = <span class="number">1</span>; b= <span class="number">2</span>;</span><br></pre></td></tr></table></figure></p>
<p>变量<code>a</code>被分配在目标文件的 bss 段，这意味着它与 GOT 之间的距离是固定可知的。目标代码可以用<code>ebx</code>作为基址寄存器并结合一个与 GOT 的相对偏移量直接引用这个变量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">movl $1，a@GOTOFF(%ebx);; R_386_GOTOFF reference to variable &quot;a&quot;</span><br></pre></td></tr></table></figure></p>
<p>变量<code>b</code>是全局的，如果他在不同的 ELF 库或可执行文件中，那么它的位置只有在运行时才能知道。这种情况下，目标代码引用一个链接器在 GOT 中创建的指向 b 的指针：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">movl b@GOT(%ebx)，%eax;; R_386_GOT32 ref to address of variable &quot;b&quot;</span><br><span class="line">movl $2，(%eax)</span><br></pre></td></tr></table></figure></p>
<p>注意编译器仅创建一个<code>R_386_GOT32</code>引用，需要链接器收集所有类似的引用并为他们在<code>GOT</code>中创建槽位(slot)。</p>
<p>最终，ELF 共享库保存了若干供运行时加载器进行运行时重定位的<code>R_386_RELATIVE</code>重定位项。由于共享库中的文本总是位置无关代码，所以对于代码没有重定位项，但数据不是位置无关的，所以对于数据段的每一个指针都有一个重定位项。</p>
<h3 id="位置无关代码的开销和得益"><a href="#位置无关代码的开销和得益" class="headerlink" title="位置无关代码的开销和得益"></a>位置无关代码的开销和得益</h3><p>PIC 的得益是明显的：它使得不需加载时重定位即可加载代码成为可能；可以在进程间共享代码的内存页面，即使它们没有被分配到相同的地址空间中。可能的不利之处就是在加载时、在过程调用中以及在函数开始和结束时会降低速度，并使全部代码变得更慢。在加载时，虽然一个位置无关代码文件的代码段不需要被重定位，但是数据段需要。在一个大的库中，TOC 或 GOT 可能会非常大以至于要花费很长的时间去解析其中的所有项。</p>
<p>处理同一个可执行文件中的<code>R_386_RELATIVE</code>（或等价符号）来重定位 GOT 中的数据指针是相当快的，但是问题是很多 GOT项中的指针指向别的可执行文件并需要查找符号表来解析。在 ELF 可执行文件中的调用通常都是动态链接的，甚至于在相同库内部的调用，这就增加了明显的开销。</p>
<p>在 ELF 文件中函数的开始和结束是相当慢的。他们必须保存和恢复 GOT 寄存器，在 x86中就是 ebx，并且通过 call 和 pop 将程序计数器保存到一个寄存器中也是很慢的。从性能的观点来看，AIX 使用的 TOC 方法更好，因为每一个过程可以假定它的 TOC 寄存器已经在过程项中设置了。</p>
<p>最后，PIC 代码要比非 PIC 代码更大、更慢。到底会有多慢很大程度上依赖于体系结构。对于拥有大量寄存器且无法直接寻址的 RISC 系统来说，少一个用作 TOC 或 GOT 指针的寄存器影响并不明显，并且缺少直接寻址而需要的一些排序时间是不变的。最坏的情况是在 x86 下。它只有 6 个寄存器，所以用一个寄存器当作 GOT 指针对代码的影响非常大。由于 x86 可以直接寻址，一个对外部数据的引用在非 PIC 代码下可以是一个简单的 MOV 或 ADD，但在 PIC 代码下就要变成加载紧跟在 MOV 或 ADD 后面的地址，这既增加了额外的内存引用又占用了宝贵的寄存器作为临时指针。</p>
<p>特别在 x86 系统上，对于速度要求严格的任务，PIC 代码的性能降低是明显的，以至于某些系统对于共享库退而采用一种类似 PIC 的方法。</p>
<h2 id="自举加载"><a href="#自举加载" class="headerlink" title="自举加载"></a>自举加载</h2><p>在现代计算机中，计算机在硬件复位后运行的第一个程序总是存储在称为 bootstrap ROM 的随机只读存储器中。就像自己启动自己一样。当处理器上电或者复位后，它将寄存器复位为一致的状态。例如在 x86 系统中，复位序列跳转到系统地址空间顶部下面的 16 字节处。Bootstrap ROM 占用了地址空间顶端的 64K，然后这里的 ROM 代码就来启动计算机。在 IBM 兼容的 x86 系统上，引导 ROM 代码读取软盘上的第一个块，如果失败的话就读取硬盘上的第一个块，将它放置在内存位置 0，然后再跳转到位置 0。在第 0 块上的程序然后从磁盘上一个已知位置上加载另一个稍微大一些的操作系统引导程序到内存中，然后在跳转到这个程序，加载并运行操作系统。</p>
<p>为什么不直接加载操作系统？因为你无法将一个操作系统的引导程序放置在 512 个字节内。第一级引导程序只能从被引导磁盘的顶级目录中加载一个名字固定且大小不超过一个段的程序。操作系统引导程序具有更多的复杂代码如读取和解释配置文件，解压缩一个压缩的操作系统内核，寻址大量内存（在 x86 系统上的引导程序通常运行在实模式下，这意味着寻址 1MB 以上地址是比较复杂的）。完全的操作系统还要运行在虚拟内存系统上，可以加载需要的驱动程序，并运行用户级程序。很多 UNIX 系统使用一个近似的自举进程来运行用户台程序。内核创建一个进程，在其中装填一个只有几十个字节长度的小程序。然后这个小程序调用一个系统调用运行/etc/init 程序，这个用户模式的初始化程序然后依次运行系统所需要的各种配置文件，启动服务进程和登录程序。</p>
<p>这些对于应用级程序员没有什么影响，但是如果你想编写运行在机器裸设备上的程序时就变得有趣多了，因为你需要截取自举过程并运行自己的程序，而不是像通常那样依靠操作系统。一些系统很容易实现这一点，另外一些系统则几乎是不可能的。它同样也给定制系统提供了机会。例如可以通过将应用程序的名字改为/etc/init 基于 UNIX 内核构建单应用程序系统。</p>
<h1 id="共享库"><a href="#共享库" class="headerlink" title="共享库"></a>共享库</h1><p>程序库的产生可以追溯到计算技术的最早期，因为程序员很快就意识到通过重用程序的代码片段可以节省大量的时间和精力。随着如 Fortran and COBOL 等语言编译器的发展，程序库成为编程的一部分。当程序调用一个标准过程时，如<code>sqrt()</code>，编译过的语言显式地使用库，而且它们也隐式地使用用于 I/O、转换、排序及很多其它复杂得不能用内联代码解释的函数库。随着语言变得更为复杂，库也相应地变复杂了。当我在 20 年前写一个 Fortran 77 编译器时，运行库就已经比编译器本身的工作要多了，而一个 Fortran 77 库远比一个 C++库要来得简单。</p>
<p>语言库的增加意味着：不但所有的程序包含库代码，而且大部分程序包含许多相同的库代码。例如，每个 C 程序都要使用系统调用库，几乎所有的 C 程序都使用标准 I/O 库例程，如 printf，而且很多使用了别的通用库，如 math，networking，及其它通用函数。这就意味着在一个有一千个编译过的程序的 UNIX 系统中，就有将近一千份 printf 的拷贝。如果所有那些程序能共享一份它们用到的库例程的拷贝，对磁盘空间的节省是可观的。更重要的是，运行中的程序如能共享单个在内存中的库的拷贝，这对主存的节省是相当可观的，不但节省内存，也提高页交换。</p>
<p>所有共享库基本上以相同的方式工作。在链接时，链接器搜索整个库以找到用于解决那些未定义的外部符号的模块。但链接器不把模块内容拷贝到输出文件中，而是标记模块来自的库名，同时在可执行文件中放一个库的列表。当程序被装载时，启动代码找到那些库，并在程序开始前把它们映射到程序的地址空间。标准操作系统的文件映射机制自动共享那些以只读或写时拷贝的映射页。负责映射的启动代码可能是在操作系统中，或在可执行体，或在已经映射到进程地址空间的特定动态链接器中，或是这三者的某种并集。</p>
<h2 id="绑定时间"><a href="#绑定时间" class="headerlink" title="绑定时间"></a>绑定时间</h2><p>共享库提出的绑定时间问题，是常规链接的程序不会遇到的。一个用到了共享库的程序在运行时依赖于这些库的有效性。当所需的库不存在时，就会发生错误。在这情况下，除了打印出一个晦涩的错误信息并退出外，不会有更多的事情要做。当库已经存在，但是自从程序链接以来库已经改变了时，一个更有趣的问题就会发生。在一个常规链接的程序中，在链接时符号就被绑定到地址上而库代码就已经绑定到可执行体中了，所以程序所链接的库是那个忽略了随后变更的库。对于静态共享库，符号在链接时被绑定到地址上，而库代码要直到运行时才被绑定到可执行体上。</p>
<p>一个静态链接共享库不能改变太多，以防破坏它所绑定到的程序。因为例程的地址和库中的数据都已经绑定到程序中了，任何对这些地址的改变都将导致灾难。如果不改变程序所依赖的静态库中的任何地址，那么有时一个共享库就可以在不影响程序对它调用的前提下进行升级。这就是通常用于小 bug 修复的”小更新版”。更大的改变不可避免地要改变程序地址，这就意味着一个系统要么需要多个版本的库，要么迫使程序员在每次改变库时都重新链接它们所有的程序。实际中，永远不变的解决办法就是多版本，因为磁盘空间便宜，而要找到每个会用到共享库可执行体几乎是不可能的。</p>
<h2 id="地址空间管理"><a href="#地址空间管理" class="headerlink" title="地址空间管理"></a>地址空间管理</h2><p>共享库中最困难的就是地址空间管理。每一个共享库在使用它的程序里都占用一段固定的地址空间。不同的库，如果能够被使用在同一个程序中，它们还必须使用互不重叠的地址空间。虽然机械的检查库的地址空间是否重叠是可能的，但是给不同的库赋予相应的地址空间仍然是一种“魔法”。一方面，你还想在它们之间留一些余地，这样当其中某个新版本的库增长了一些时，它不会延伸到下一个库的空间而发生冲突。另一方面，你还想将你最常用的库尽可能紧密的放在一起以节省需要的页表数量（要知道在 x86 上，进程地址空间的每一个 4MB 的块都有一个对应的二级表）。</p>
<p>每个系统的共享库地址空间都必然有一个主表，库从离应用程序很远的地址空间开始。Linux 从十六进制的 60000000 开始，BSD/OS 从 A0000000 开始。商业厂家将会为厂家提供的库、用户和第三方库进一步细分地址空间，比如对 BSD/OS，用户和第三方库开始于地址 A0800000。</p>
<p>通常库的代码和数据地址都会被明确的定义，其中数据区域从代码区域结束地址后的一个或两个页对齐的地方开始。由于一般都不会更新数据区域的布局，而只是增加或者更改代码区域，所以这样就使小更新版本成为可能。每一个共享库都会输出符号，包括代码和数据，而且如果这个库依赖于别的库，那么通常也会引入符号。虽然以某种偶然的顺序将例程链接为一个共享库也能使用，但是真正的库使用一些分配地址的原则而使得链接更容易，或者至少使在更新库的时候不必修改输出符号的地址成为可能。对于代码地址，库中有一个可以跳转到所有例程的跳转指令表，并将这些跳转的地址作为相应例程的地址输出，而不是输出这些例程的实际地址。所有跳转指令的大小都是相同的，所以跳转表的地址很容易计算，并且只要表中不在库更新时加入或删除表项，那么这些地址将不会随版本而改变。每一个例程多出一条跳转指令不会明显的降低速度，由于实际的例程地址是不可见的，所以即使新版本与旧版本的例程大小和地址都不一样，库的新旧版本仍然是可兼容的。</p>
<p>对于输出数据，情况就要复杂一些，因为没有一种像对代码地址那样的简单方法来增加一个间接层。实际中的输出数据一般是很少变动的、尺寸已知的表，例如 C 标准 I/O 库中的 FILE 结构，或者像 errno 那样的单字数值（最近一次系统调用返回的错误代码），或者是 tzname（指向当前时区名称的两个字符串的指针）。建立共享库的程序员可以收集到这些输出数据并放置在数据段的开头，使它们位于每个例程中所使用的匿名数据的前面，这样使得这些输出地址在库更新时不太可能会有变化。</p>
<h2 id="共享库的结构"><a href="#共享库的结构" class="headerlink" title="共享库的结构"></a>共享库的结构</h2><p>共享库是一个包含所有准备被映射的库代码和数据的可执行格式文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">文件头，a.out， COFF 或 ELF 头</span><br><span class="line">(初始化例程，不总存在)</span><br><span class="line">跳转表</span><br><span class="line">代码</span><br><span class="line">全局数据</span><br><span class="line">私有数据</span><br></pre></td></tr></table></figure></p>
<p>一些共享库从一个小的自举例程开始，来映射库的剩余部分。之后是跳转表，如果它不是库的第一个内容，那么就把它对齐到下一个页的位置。库中每一个输出的公共例程的地址就是跳转表的表项；跟在跳转表后面的是文本段的剩余部分(由于跳转表是可执行代码，所以它被认为是文本)，然后是输出数据和私有数据。在逻辑上 bss 段应跟在数据的后面，但是就像在任何别的可执行文件中那样，它并不在于这个文件中。</p>
<h2 id="创建共享库"><a href="#创建共享库" class="headerlink" title="创建共享库"></a>创建共享库</h2><p>一个 UNIX 共享库实际上包含两个相关文件，即共享库本身和给链接器用的空占位库(stub library)。库创建工具将一个档案格式的普通库和一些包含控制信息的文件作为输入生成了这两个文件。空占位库根本不包含任何的代码和数据(可能会包含一个小的自举例程)，但是它包含程序链接该库时需要使用的符号定义。</p>
<p>创建一个共享库需要以下几步，我们将在后面更多的讨论它们：</p>
<ul>
<li>确定库的代码和数据将被定位到什么地址。</li>
<li>彻底扫描输入的库寻找所有输出的代码符号(如果某些符号是用来在库内通信的，那么就会有一个控制文件是这些不对外输出的符号的列表)。</li>
<li>创建一个跳转表，表中的每一项分别对应每个输出的代码符号。</li>
<li>如果在库的开头有一个初始化或加载例程，那么就编译或者汇编它。</li>
<li>创建共享库。运行链接器把所有内容都链接为一个大的可执行格式文件。</li>
<li>创建空占位库：从刚刚建立的共享库中提取出需要的符号，针对输入库的符号调整这些符号。为每一个库例程创建一个空占位例程。在 COFF 库中，也会有一个小的初始化代码放在占位库里并被链接到每一个可执行体中。</li>
</ul>
<h3 id="创建跳转表"><a href="#创建跳转表" class="headerlink" title="创建跳转表"></a>创建跳转表</h3><p>最简单的创建一个跳转表的方法就是编写一个全是跳转指令的汇编源代码文件，并汇编它。这些跳转指令需要使用一种系统的方法来标记，这样以后空占位库就能够把这些地址提出取来。</p>
<p>对于像 x86 这样具有多种长度的跳转指令的平台，可能稍微复杂一点。对于含有小于 64K 代码的库，3 个字节的短跳转指令就足够了。对于较大的库，需要使用更长的 5 字节的跳转指令。将不同长度的跳转指令混在一起是不能让人满意的，因为它使得表地址的计算更加困难，同时也更难在以后重建库时确保兼容性。最简单的解决方法就是都采用最长的跳转指令；或者全部都使用短跳转，对于那些使用短跳转太远的例程，则用一个短跳转指令跳转到放在表尾的匿名长跳转指令。(通常由此带来的麻烦比它的好处更多，因为第一跳转表很少会有好几百项。)</p>
<h3 id="创建共享库-1"><a href="#创建共享库-1" class="headerlink" title="创建共享库"></a>创建共享库</h3><p>一旦跳转表和加载例程(如果需要的话)建立好之后，创建共享库就很容易了。只需要使用合适的参数运行链接器，让代码和数据从正确的地址空间开始，并将自引导例程、跳转表和输入库中的所有例程都链接在一起。它同时完成了给库中每项分配地址和创建共享库文件两件事。</p>
<p>库之间的引用会稍微复杂一些。如果你正在创建，例如一个使用标准 C 库例程的共享数学库，那就要确保引用的正确。假定当链接器建立新库时需要用到的共享库中的例程已经建好，那么它只需要搜索该共享库的空占位库，就像普通的可执行程序引用共享库那样。这将让所有的引用都正确。只留下一个问题，就是需要有某种方法确保任何使用新库的程序也能够链接到旧库上。对新库的空占位库的适当设计可以确保这一点。</p>
<h3 id="创建空占位库"><a href="#创建空占位库" class="headerlink" title="创建空占位库"></a>创建空占位库</h3><p>创建空占位库是创建共享库过程中诡秘的部分之一。对于库中的每一个例程，空占位库中都要包含一个同时定义了输出和输入的全局符号的对应项。</p>
<p>数据全局符号会被链接器放在共享库中任何地方，获取它们的数值的最合理的办法就是创建一个带有符号表的共享库，并从符号表中提取符号。对代码全局符号，入口指针都在跳转表中，所以同样很简单，只需要从共享库中提取符号表或者根据跳转表的基地址和每一个符号在表中的位置来计算符号地址。</p>
<p>不同于普通库模块，空占位库模块既不包含代码也不包含数据，只包含符号定义。这些符号必须定义成绝对数而不是相对，因为共享库已经完成了所有的重定位。库创建程序从输入库中提取出每一个例程，并从这些例程中得到定义和未定义的全局变量，以及每一个全局变量的类型(文本或数据)。然后它创建空占位例程，通常都是一个很小的汇编程序，以跳转表中每一项的地址的形式定义每个文本全局变量，以共享库中实际地址的形式定义每个数据或 bss 全局变量，并以“未定义”的形式定义没有定义的全局变量。当它完成所有空占位后，就对其进行汇编并将它们合并到一个普通的库档案文件中。</p>
<p>COFF 空占位库使用了一种不同的、更简单的设计。它们是具有两个命名段的单一目标文件。“.lib”段包含了指向共享库的所有重定位信息，“.init”段包含了将会链接到每一个客户程序去的初始化代码，一般是来初始化库中的变量。Linux 共享库更简单，a.out文件中包含了带有设置向量（“set vector”） 的符号定义。</p>
<p>共享库的名称一般是原先的库名加上版本号。如果原先的库称为<code>/lib/libc.a</code>，这通常是 C 库的名字，当前的库版本是 4.0，空占位库可能是<code>/lib/libc_s.4.0.0.a</code>，共享库就是<code>/shlib/libc_s.4.0.0</code>（多出来的 0 可以允许小版本的升级）。一旦库被放置到合适的目录下面，它们就可以被使用了。</p>
<h3 id="版本命名"><a href="#版本命名" class="headerlink" title="版本命名"></a>版本命名</h3><p>任何共享库系统都需要有一种办法处理库的多个版本。当一个库被更新后，新版本相对于之前版本而言在地址和调用上都有可能兼容或不兼容。UNIX 系统使用前面提到的版本命名序号来解决这个问题。</p>
<p>第一个数字在每次发布一个不兼容的全新的库的时候才被改变。一个和 4.x.x 的库链接的程序不能使用 3.x.x 或 5.x.x 的库。第二个数是小版本。在 Sun 系统上，每一个可执行程序所链接的库都至少需要一个尽可能大的小版本号。例如，如果它链接的是 4.2.x，那么它就可以和 4.3.x 一起运行而 4.1.x 则不行。另一些系统将第二个数字当作第一个数字的扩展，这样的话使用一个 4.2.x 的库链接的程序就只能和 4.2.x 的库一起运行。第三个数字通常都被当作补丁级别。虽然任何的补丁级别都是可用的，可执行程序最好还是使用最高的有效补丁级别。</p>
<p>不同的系统在运行时查找对应库的方法会略有不同。Sun 系统有一个相当复杂的运行时加载器，在库目录中查看所有的文件名并挑选出最好的那个。Linux 系统使用符号链接而避免了搜索过程。如果库 libc.so 的最新版本是 4.2.2，库的名字是 libc_s.4.2.2，但是这个库也已经被链接到 libc_s.4.2，那么加载器将仅需打开名字较短的文件，就选好了正确的版本。</p>
<p>多数系统都允许共享库存在于多个目录中。类似于<code>LD_LIBRARY_PATH</code>的环境变量可以覆盖可执行程序中的路径，以允许开发者使用它们自己的库替代原先的库进行调试或性能测试。</p>
<h2 id="使用共享库链接"><a href="#使用共享库链接" class="headerlink" title="使用共享库链接"></a>使用共享库链接</h2><p>使用静态共享库来链接，比创建库要简单得多，因为几乎所有的确保链接器正确解析库中程序地址的困难工作，都在创建空占位库时完成了。唯一困难的部分就是在程序开始运行时将需要的共享库映射进来。</p>
<p>每一种格式都会提供一个小窍门让链接器创建一个库的列表，以便启动代码把库映射进来。COFF 库使用一种残忍的强制方法；链接器中的特殊代码在 COFF 文件中创建了一个以库名命名的段。Linux 链接器使用一种不那么残忍的方法，即创建一个称为设置向量的特殊符号类型。设置向量象普通的全局符号一样，但如果它有多个定义，这些定义会被放进一个以该符号命名的数组中。每个共享库定义一个设置向量符号<code>__SHARED_LIBRARIES__</code>，它是由库名、版本、加载地址等构成的一个数据结构的地址。 链接器创建一个指向每个这种数据结构的指针的数组，并称之为<code>__SHARED_LIBRARIES__</code>，好让启动代码可以使用它。BSD/OS 共享库没有使用任何的此类链接器窍门。它使用 shell 脚本建立一个共享的可执行程序，用来搜索作为参数或隐式传入的库列表，提取出这些文件的名字并根据系统文件中的列表来加载这些库的地址，然后编写一个小汇编源文件创建一个带有库名字和加载地址的结构数组，并汇编这个文件，把得到的目标文件加入到链接器的参数列表中。</p>
<p>在每一种情况中，从程序代码到库地址的引用都是通过空占位库中的地址自动解析的。</p>
<h2 id="使用共享库运行"><a href="#使用共享库运行" class="headerlink" title="使用共享库运行"></a>使用共享库运行</h2><p>启动一个使用共享库的程序需要三步：加载可执行程序，映射库，进行库特定的初始化操作。在每一种情况下，可执行程序都被系统按照通常的方法加载到内存中。之后，处理方法会有差别。系统 V.3 内核具有了处理链接 COFF 共享库的可执行程序的扩展性能，其内核会查看库列表并在程序运行之前将它们映射进来。这种方法的不利之处在于 “内核肿胀”，会给不可分页的内核增加更多的代码；并且由于这种方法不允许在未来版本中有灵活性和可升级性，所以它是不灵活的。</p>
<p>Linux 增加了一个单独的<code>uselib()</code>系统调用，以获取一个库的文件名字和地址，并将它映射到程序的地址空间中。绑定到可执行体中的启动例程搜索库列表，并对每一项执行<code>uselib()</code>。</p>
<p>BSD/OS 的方法是使用标准的<code>mmap()</code>系统调用将一个文件的多个页映射进地址空间，该方法还使用一个链接到每个共享库起始处的自举例程。可执行程序中的启动例程遍历共享库表，打开每个对应的文件，将文件的第一页映射到加载地址中，然后调用各自的自举例程，该例程位于可执行文件头之后的起始页附近的某个固定位置。然后自举例程再映射余下的文本段、数据段，然后为 bss 段映射新的地址空间，然后自举例程就返回了。</p>
<p>所有的段被映射了之后，通常还有一些库特定的初始化工作要做，例如，将一个指针指向 C 标准库中指定的系统环境全局变量 environ。COFF 的实现是从程序文件的<code>.init</code>段收集初始化代码，然后在程序启动代码中运行它。根据库的不同，它有时会调用共享库中的例程，有时不会。Linux 的实现中没有进行任何的库初始化，并且指出了在程序和库中定义相同的变量将不能很好工作的问题。</p>
<p>在 BSD/OS 实现中，C 库的自举例程会接收到一个指向共享库表的指针，并将所有其它的库都映射进来，减小了需要链接到单独的可执行体中的代码量。最近版本的 BSD 使用 ELF格式的可执行体。ELF 头有一个 interp 段，其中包含一个运行该文件时需要使用的解释器程序的名字。BSD 使用共享的 C 库作为解释器，这意味着在程序启动之前内核会将共享 C 库先映射进来，这就节省了一些系统调用的开销。库自举例程进行的是相同的初始化工作，将库的剩余部分映射进来，并且，通过一个指针，调用程序的 main 例程。</p>
<h2 id="malloc-hack-和其它共享库问题"><a href="#malloc-hack-和其它共享库问题" class="headerlink" title="malloc hack 和其它共享库问题"></a>malloc hack 和其它共享库问题</h2><p>在一个静态库中，所有的库内调用都被永久绑定了，所以不可能将某个程序中所使用的库例程通过重新定义替换为私有版本的例程。多数情况下，由于很少有程序会对标准库中例如<code>read()</code>、<code>strcmp()</code>等例程进行重新定义，所以永久绑定不是什么大问题；并且如果它们自己的程序使用私有版本的<code>strcmp()</code>，但库例程仍调用库中标准版本，那么也没有什么大问题。</p>
<p>但是很多程序定义了它们自己的<code>malloc()</code>和<code>free()</code>版本，这是分配堆存储的例程；如果在一个程序中存在这些例程的多个版本，那么程序将不能正常工作。例如，标准<code>strdup()</code>例程，返回一个指向用 malloc 分配的字符串指针，当程序不再使用它时可以释放它。如果库使用 malloc 的某个版本来分配字符串的空间，但是应用程序使用另一个版本的 free 来释放这个字符串的空间，那么就会发生混乱。</p>
<p>为了能够允许应用程序提供它们自己版本的<code>malloc</code>和<code>free</code>，System V.3 的共享 C 库使用了一种“丑陋”的技术。系统的维护者将<code>malloc</code>和<code>free</code>重新定义为间接调用，这是通过绑定到共享库的数据部分的函数指针实现的，我们将称它们为<code>malloc_ptr</code>和<code>free_ptr</code>。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">void</span> *(*malloc_ptr)(<span class="keyword">size_t</span>);</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="title">void</span> <span class="params">(*free_ptr)</span><span class="params">(<span class="keyword">void</span> *)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> malloc(s) (*malloc_ptr)(s)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> free(s) (*free_ptr)(s)</span></span><br></pre></td></tr></table></figure></p>
<p>然后它们重新编译了整个 C 库，并将下面的几行内容(或汇编同类内容)加入到占位库的<code>.init</code>段，这样它们就被加入到每个使用该共享库的程序中了。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> malloc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> free</span></span><br><span class="line">malloc_ptr = &amp;<span class="built_in">malloc</span>;</span><br><span class="line">free_ptr = &amp;<span class="built_in">free</span>;</span><br></pre></td></tr></table></figure></p>
<p>由于占位库将被绑定到应用程序中的，而不是共享库，所以它对<code>malloc</code>和<code>free</code>的引用是在链接时解析的。如果存在一个私有版本的<code>malloc</code>和<code>free</code>，它将指向私有版本函数的指针（译者注：指<code>malloc_ptr</code>和<code>free_ptr</code>），否则它将使用标准库的版本。不管哪种方法，库和应用程序使用的都是相同版本的<code>malloc</code>和<code>free</code>。</p>
<h1 id="动态链接和加载"><a href="#动态链接和加载" class="headerlink" title="动态链接和加载"></a>动态链接和加载</h1><p>动态链接将很多链接过程推迟到了程序启动的时候。它提供了一系列其它方法无法获得的优点：</p>
<ul>
<li>动态链接的共享库要比静态链接的共享库更容易创建。</li>
<li>动态链接的共享库要比静态链接的共享库更容易升级。</li>
<li>动态链接的共享库的语义更接近于那些非共享库。</li>
<li>动态链接允许程序在运行时加载和卸载例程，这是其它途径所难以提供的功能。</li>
</ul>
<p>当然这也有少许不利。由于每次程序启动的时候都要进行大量的链接过程，动态链接的运行时性能要比静态链接的低不少，这是付出的代价。程序中所使用的每一个动态链接的符号都必须在符号表中进行查找和解析。由于动态链接库还要包括符号表，所以它比静态库要大。</p>
<p>在调用的兼容性问题之上，一个顽固的麻烦根源是库语义的变化。和非共享或静态共享库而言，变更动态链接库要容易很多。所以很容易就可以改变已存在程序正在使用的动态链接库。这意味着即使程序没有任何改变，程序的行为也会改变。多数程序在出货时都带有它们所需库的副本，而安装程序经常会不假思索的将安装包中的旧版本共享库覆盖已存在的新版本库，这就破坏了那些依赖新版本库特性的程序。考虑周全的安装程序会在使用旧版本库覆盖新版本库的时候弹出告警框提示，但这样的话，依赖新版本库特性的那些应用程序又会发生旧版本库替换新版本库时发生的类似问题。</p>
<h2 id="ELF-文件内容"><a href="#ELF-文件内容" class="headerlink" title="ELF 文件内容"></a>ELF 文件内容</h2><p>一个 ELF 文件可以看成是由链接器解释的一系列区段（section），或由加载器解释的一系列段（segment）。ELF 程序和共享库的通用结构相同，但具体的段（segment）或者区段（section）有所区别。</p>
<p>ELF 共享库可被加载到任何地址，因此它们总是使用位置无关代码（PIC）的形式，这样文件的代码页无须重定位即可在多个进程之间共享。ELF 链接器通过全局偏移量表（GOT）支持 PIC 代码，每个共享库中都有 GOT，包含着程序所引用的静态数据的指针。动态链接器会解析和重定位 GOT 中的所有指针。这会引起性能的问题，但是在实际中除了非常巨大的库之外，GOT 都不大。通常使用的标准 C 库中超过 350K的代码的 GOT 也只有 180 个表项。</p>
<p>由于 GOT 位于代码所引用的可加载 ELF 文件中，因此无论被加载到何处，位于文件中的相对地址都不会发生变化。代码可以通过相对地址来定位 GOT，将 GOT 的地址加载到一个寄存器中，然后在需要寻址静态数据的时候从 GOT 中加载相应的指针。如果一个库没有引用任何的静态数据那么它可以不需 GOT，但实际中所有的库都有 GOT。</p>
<p>为了支持动态链接，每个 ELF 共享库和每个使用了共享库的可执行程序都有一个过程链接表（Procedure Linkage Table, PLT）。PLT 就像 GOT 对数据引用那样，对函数调用增添了一层间接途径。PLT 还允许进行“懒惰计算法”，即只有在第一次被调用时，才解析过程的地址。由于 PLT 表项要比 GOT 多很多（在上面提到的 C 库中会有超过 600 项），并且大多数例程在任何给定的程序中都不会被调用，因此“懒惰计算法”既可以提高程序启动的速度，也可以整体上节省相当可观的时间。</p>
<p>一个被动态链接的 ELF 文件包含了运行时链接器在重定位文件和解析任意未定义符号时所需的所有链接器信息。动态符号表，即<code>.dynsym</code>区段，包含了文件中所有的输入和输出符号。而<code>.dynstr</code>和<code>.hash</code>区段包含了符号的名称字串，以及有助于加快运行时链接器查找速度的散列表。最后一个 ELF 动态链接文件的额外部分是<code>DYNAMIC</code>段（也被标识为<code>.dynamic</code>区段），动态链接器使用它来寻找和该文件相关的信息。它作为数据段的一部分被加载，但由 ELF 文件头部的指针指向它，这样运行时动态链接器就可以找到它了。<code>DYNAMIC</code>区段是一个由被标记的数值和指针组成的列表。一些表项类型只会出现在程序中，一些表项类型只会出现在库中，还有一些类型在两者中都会出现。</p>
<ul>
<li><code>NEEDED</code>：该文件所需的库的名称。（通常在程序中，如果一个库依赖其它库时有时也会在这个库中，这种情况可以嵌套发生）</li>
<li><code>SONAME</code>：共享的对象名称。链接器所需要的文件的名称。（在库中）</li>
<li><code>SYMTAB</code>、<code>STRTAB</code>、<code>HASH</code>、<code>SYMENT</code>、<code>STRSZ</code>：指向符号表，相关联的字串表和散列表，符号表项大小，字串表大小。（程序和库中都有）</li>
<li><code>PLTGOT</code>：指向<code>GOT</code>，或者在某些架构下指向<code>PLT</code>。（程序和库中都有）</li>
<li><code>REL</code>、<code>RELSZ</code>和<code>RELENT</code>，或者<code>RELA</code>、<code>RELASZ</code>和<code>RELAENT</code>：重定位表的指针、大小和表项大小。重定位表中不包含加数，加数表中才包含它们。根据名字也能猜到，<code>RELA</code>、<code>RELASIZE</code>和<code>RELAENT</code>是加数表指针、加数表大小和加数表项的大小。（程序和库中都有）</li>
<li><code>JMPREL</code>、<code>PLTRELSZ</code>和<code>PLTREL</code>：由 PLT 引用的数据的重定位表的指针、大小和格式（REL或 RELA）。（程序和库中都有）</li>
<li><code>INIT</code>和<code>FINI</code>：初始化和终止例程的指针，在程序启动和终止的时候调用。（可选的，但是通常在库和程序中都有）</li>
</ul>
<h2 id="加载一个动态链接的程序"><a href="#加载一个动态链接的程序" class="headerlink" title="加载一个动态链接的程序"></a>加载一个动态链接的程序</h2><p>加载一个动态链接的程序，这个过程冗长但简单。</p>
<h3 id="启动动态链接器"><a href="#启动动态链接器" class="headerlink" title="启动动态链接器"></a>启动动态链接器</h3><p>在操作系统运行程序时，它会像通常那样将文件的页映射进来，但注意在可执行程序中存在一个<code>INTERPRETER</code>区段。这里特定的解释器是动态链接器，即<code>ld.so</code>，它自己也是ELF共享库的格式。操作系统并非直接启动程序，而是将动态链接器映射到地址空间的一个合适的位置，然后从<code>ld.so</code>处开始，并在栈中放入链接器所需要的辅助向量（auxiliary vector）信息。向量包括：</p>
<ul>
<li><code>AT_PHDR</code>，<code>AT_PHENT</code>，和<code>AT_PHNUM</code>：程序头部在程序文件中的地址，头部中每个表项的大小，和表项的个数。头部结构描述了被加载文件中的各个段。如果系统没有将程序映射到内存中，就会有一个<code>AT_EXECFD</code>项作为替换，它包含被打开程序文件的文件描述符。</li>
<li><code>AT_ENTRY</code>：程序的起始地址，当动态链接器完成了初始化工作之后，就会跳转到这个地址去。</li>
<li><code>AT_BASE</code>：动态链接器被加载到的地址。</li>
</ul>
<p>此时，位于<code>ld.so</code>起始处的自举代码找到它自己的 GOT，其中的第一项指向了<code>ld.so</code>文件中的<code>DYNAMIC</code>段。通过<code>dynamic</code>段，链接器在它自己的数据段中找到自己的重定位项表和重定位指针，然后解析例程需要加载的其它东西的代码引用（Linux ld.so 将所有的基础例程都命名为由字串<code>_dt_</code>起头，并使用专门代码在符号表中搜索以此字串开头的符号并解析它们）。</p>
<p>链接器然后通过指向程序符号表和链接器自己的符号表的若干指针来初始化一个符号表链。从概念上讲，程序文件和所有加载到进程中的库会共享一个符号表。但实际中链接器并不是在运行时创建一个合并后的符号表，而是将个个文件中的符号表组成一个符号表链。每个文件中都有一个散列表（一系列的散列头部，每个头部引领一个散列队列）以加速符号查找的速度。链接器可以通过计算符号的散列值，然后访问相应的散列队列进行查找以加速符号搜索的速度。</p>
<h3 id="库的查找"><a href="#库的查找" class="headerlink" title="库的查找"></a>库的查找</h3><p>链接器自身的初始化完成之后，它就会去寻找程序所需要的各个库。程序的程序头部有一个指针，指向<code>dynamic</code>段（包含有动态链接相关信息）在文件中的位置。在这个段中包含一个指针<code>DT_STRTAB</code>，指向文件的字串表，和一个偏移量表<code>DT_NEEDED</code>，其中每一个表项包含了一个所需库的名称在字串表中的偏移量。</p>
<p>对于每一个库，链接器会查找对应的 ELF 共享库文件，这本身也是一个颇为复杂的过程。在<code>DT_NEEDED</code>表项中的库名称看起来与 libXt.so.6（Xt 工具包，版本 6）类似。库文件可能会在若干库目录的任意一个之中，甚至可能文件的名称都不相同。在我的系统上，这个库的实际名称是<code>/usr/X11R6/lib/libXt.so.6</code>。末尾的“.0”是次版本号。链接器在以下位置搜索库：</p>
<ul>
<li>是否<code>dynamic</code>段有一个称为<code>DT_RPATH</code>的表项，它是由分号分隔开的可以搜索库的目录列表。它可以通过一个命令行参数或者在程序链接时常规（非动态）链接器的环境变量来添加。它经常会被诸如数据库类这样需要加载一系列程序并可将库放在单一目录的子系统使用，</li>
<li>是否有一个环境符号<code>LD_LIBRARY_PATH</code>，它可以是由分号分隔开的可供链接器搜索库的目录列表。这就可以让开发者创建一个新版本的库并将它放置在<code>LD_LIBRARY_PATH</code>的路径中，这样既可以通过已存在的程序来测试新的库，或用来监测程序的行为。（因为安全原因，如果程序设置了 set-uid，那么这一步会被跳过）</li>
<li>链接器查看库缓冲文件<code>/etc/ld.so.conf</code>，其中包含了库文件名和路径的列表。如果要查找的库名称存在于其中，则采用文件中相应的路径。大多数库都通过这种方法被找到。</li>
<li>如果所有的都失败了，就查找缺省目录<code>/usr/lib</code>，如果在这个目录中仍没有找到，就打印错误信息，并退出执行。</li>
</ul>
<p>一旦找到包含该库的文件，动态链接器会打开该文件，读取 ELF 头部寻找程序头部，它指向包括 dynamic 段在内的众多段。链接器为库的文本和数据段分配空间，并将它们映射进来，对于 BSS 分配初始化为 0 的页。从库的 dynamic 段中，它将库的符号表加入到符号表链中，如果该库还进一步需要其它尚未加载的库，则将那些新库置入将要加载的库链表中。在该过程结束时，所有的库都被映射进来了，加载器拥有了一个由程序和所有映射进来的库的符号表联合而成的逻辑上的全局符号表。</p>
<h3 id="共享库的初始化"><a href="#共享库的初始化" class="headerlink" title="共享库的初始化"></a>共享库的初始化</h3><p>现在加载器再次查看每个库并处理库的重定位项，填充库的 GOT，并进行库的数据段所需的任何重定位。在 x86 平台上，加载时的重定位包括：</p>
<ul>
<li><code>R_386_GLOB_DAT</code>：初始化一个 GOT 项，该项是在另一个库中定义的符号的地址。</li>
<li><code>R_386_32</code>：对在另一个库中定义的符号的非 GOT 引用，通常是静态数据区中的指针。</li>
<li><code>R_386_RELATIVE</code>：对可重定位数据的引用，典型的是指向字串（或其它局部定义静态数据）的指针。</li>
<li><code>R_386_JMP_SLOT</code>：用来初始化 PLT 的 GOT 项，稍后描述。</li>
</ul>
<p>如果一个库具有.init 区段，加载器会调用它来进行库特定的初始化工作，诸如 C++的静态构造函数。库中的.fini 区段会在程序退出的时候被执行。它不会对主程序进行初始化，因为主程序的初始化是有自己的启动代码完成的。当这个过程完成后，所有的库就都被完全加载并可以被执行了，此时加载器调用程序的入口点开始执行程序。</p>
<h1 id="高级技术"><a href="#高级技术" class="headerlink" title="高级技术"></a>高级技术</h1><h2 id="C-的技术"><a href="#C-的技术" class="headerlink" title="C++的技术"></a>C++的技术</h2><p>C++对链接器来说存在三个明显的挑战。一个是它复杂的命名规则，主要在于如果多个函数具有不同的参数类型则可以拥有相同的名称。name mangling 可以对他们进行很好的地址分配，所有的链接器都使用这种技术的不同形式。</p>
<p>第二个是全局的构造和析构代码，他们需要在 main 例程运行前运行和 main 例程退出后运行。这需要链接器将构造代码和析构代码片段（或者至少是指向它们的指针）都收集起来放在一个地方，以便在启动和退出时将他们一并执行。</p>
<p>第三，也是目前最复杂的问题即模板和“extern inline”过程。一个 C++模板定义了一个无穷的过程的家族，每一个家族成员都是由某个类型特定的模板。例如，一个模板可能定义了一个通用的 hash 表，则就有整数类型的 hash 表家族成员，浮点数类型的 hash 表家族成员，字符串类型的，或指向各种数据结构的指针的类型的。由于计算机的存储器容量是无穷的，被编译好的程序需要包含程序中用到的这个家族中实际用到的所有成员，并且不能包含其它的。如果 C++编译器采用传统方法单独处理每一个源代码文件，他不能确定是否所编译的源代码文件中用到的模板是否在其它源代码文件中还存在被使用的其它家族成员。如果编译器采用保守的方法为每一个文件中使用到的每一个家族成员都产生相应的代码，那么最后将可能对某些家族成员产生了多份代码，这就浪费了空间。如果它不产生那些代码，它就有漏掉某一个需要的家族成员的可能性存在。</p>
<p>inline 函数存在一个相似的问题。通常，inline 函数被像宏那样扩展开，但是在某些情况下编译器会产生该函数相反的 out of line 版本。如果若干个不同的文件使用某个包含一个 inline 函数的单一头文件，并且某些文件需要一个 out of line 的版本，就会产生代码重复的相同问题。</p>
<p>一些编译器采用改变源代码语言的方法以帮助产生可以被“哑”链接器（dump linkers）链接的目标代码。很多最近的 C++系统都把这个问题放到了首位，或者让链接器更聪明些，或者将程序开发系统的其它部分和链接器整合在一起，以解决这个问题。下面我们概要的看看后一种途径。</p>
<h3 id="试验链接"><a href="#试验链接" class="headerlink" title="试验链接"></a>试验链接</h3><p>对于使用“头脑简单”的链接器构建起来的系统，C++系统使用了多种技巧来使得 C++程序得以被链接。一种方法是先用传统的 C 前端实现来进行通常都会失败的试验链接，然后让编译器驱动（运行各种编译器、汇编器、链接器代码片段的程序）从链接结果中提取信息，再重新编译和链接以完成任务。</p>
<p>在 UNIX 系统上，如果 linker 在一次链接任务中不能够解析所有的未定义符号引用，他可以选择仍然输出一个作为后续链接任务的输入文件的输出文件。在链接过程中链接器使用普通的库查找规则，使得输出文件包含所需的库，这也是再次作为输入文件所包含的信息。试验链接解决了上面所有的 C++问题，虽然很慢，但却是有效的方法。</p>
<p>对于全局的构造和析构代码，C++编译器在每一个输入文件中建立了完成构造和析构功能的例程。这些例程在逻辑上是匿名的，但是编译器给他们分配了可识别的名称。例如，GNU C++编译器会对名为<code>junk</code>的类中的变量创建名为<code>_GLOBAL_.I.__4junk</code>和<code>_GLOBAL_.D.__4junk</code>的构造例程及析构例程。在试验链接结束后，链接器驱动程序会检测输出文件的符号表并为全局构造和析构例程建立一个链表，这是通过编写一个由数组构成的队列的源代码文件来实现的（通过 C 或者汇编语言）。然后在再次链接中，C++的启动和退出代码使用这个数组中的内容去调用所有对应的例程。这和那些针对 C++的链接器的功能基本相同，区别仅仅是它是在链接器之外实现的。</p>
<p>对于模板和 extern inline 来说，编译器最初不会为他们生成任何代码。试验链接会获得程序中实际使用到的所有模板和 extern inline 的未定义符号，编译器驱动程序会利用这些符号重新运行编译器并为之生成代码，然后再次进行链接。这里会有一个小问题是为模板寻找对应的源代码，因为所要找寻的目标可能潜伏在非常大量的源代码文件中。C 前端程序使用了一种简单而特别的技术：扫描头文件，然后猜测一个在 foo.h 中声明的模板会定义在 foo.cc 中。新近版本的 GCC 会使用一种在编译过程中生成，以注明模板定义代码的位置的小文件，称之为“仓库”（repository）。在试验链接后，编译器驱动程序仅需要扫描这些小文件就可以找到模板对应的源代码。</p>
<h3 id="消除重复代码"><a href="#消除重复代码" class="headerlink" title="消除重复代码"></a>消除重复代码</h3><p>试验链接的方法会产生尽可能小的代码，在试验链接之后会再为第一次处理遗留下的任何源代码继续产生代码。之所以采用这种前后颠倒的方法是为了生成所有可能的代码，然后让链接器将那些重复的丢掉。编译器为每一个源文件都生成了他们各自所需的每一个扩展模板和 extern line 代码。每一个可能冗余的代码块都被放到他们各自的段中并用唯一的名字来标识它是什么。例如，GCC 将每一个代码块放置在一个命名为<code>.gnu.linkonce.d.mangledname</code>的 ELF 或 COFF 段中，这里“缺损名称”（mangled name）是指增加了类型信息的函数名称。有一些格式可以仅仅通过名字就识别出可能的冗余段，如微软的 COFF 格式使用带有精确类型标志的 COMDAT 段来表示可能的冗余代码段。如果存在同一个名字的段的多个副本，那么链接器就会在链接时将多余的副本忽略掉。</p>
<p>这种方法非常好的做到了为每一个例程在可执行程序中仅仅生成一个副本，作为代价，会产生非常大的包含一个模板的多个副本的目标文件。但这种方法至少提供了可以产生比其它方法更小的最终代码的可能性。在很多情况下，当一个模板扩展为多个类型时所产生的代码是一样的。例如，鉴于 C++的指针都具有相同的表示方法，因此一个实现了类型为<code>&lt;TYPE&gt;</code>可进行边界检查的数组的模板，通常对所有指针类型所扩展的代码都是一样的。所以，那个已经删除了冗余段的链接器还可以检查内容一样的段，并将多个内容一样的段消除为只剩一个。</p>
<h3 id="借助于数据库的方法"><a href="#借助于数据库的方法" class="headerlink" title="借助于数据库的方法"></a>借助于数据库的方法</h3><p>GCC 所用的“仓库”实际上就是一个小的数据库。最终，工具开发者都会转而使用数据库来存储源代码和目标代码，就像 IBM 的 Viaual Age C++的 Montana 开发环境一样。数据库跟踪每一个声明和定义的位置，这样就可以在源代码改变后精确的指出哪些例程会对此修改具有依赖关系，并仅仅重新编译和链接那些修改了的地方。</p>
<h3 id="链接时的垃圾收集"><a href="#链接时的垃圾收集" class="headerlink" title="链接时的垃圾收集"></a>链接时的垃圾收集</h3><p>有一些链接器也提供从目标文件中去除无用的代码的功能。大多数程序的源代码文件和目标文件都包含有多于一个的例程。如果编译器在每个例程之间划分边界，那么链接器就能确定每一个例程都定义了哪些符号，哪些例程都引用了哪些符号。根本没有被引用的任何例程都可以被安全的忽略掉。每次当一个例程被忽略掉时，由于这个例程可能还引用了一些唯一被该历程引用的其它例程，而那些例程也会随后被忽略掉，因此链接器需要重新计算“定义/引用”表。</p>
<p>缺省情况下，所有的未引用例程都会被忽略掉，但是程序员可以通过链接器的开关参数告诉它不要进行任何的垃圾收集，或对特定的文件或段不进行垃圾收集。链接器查找那些没有被引用的段，并删除它们。在大多数情况下，链接器会同时查找相同内容的多个例程（通常从我们上面提到的模板的扩展而来）并将多于的副本清除。对可收集垃圾的链接器的一个替代方案就是更广泛的使用库。程序员可以将被链接到程序中的库转换为每个库成员只有一个例程的库，然后从这些库中进行链接，这样链接器可以挑选需要的例程而跳过那些没有被引用的例程。这种方法中最难的部分是重新处理源代码以将含有多个例程的源代码文件分割为很多只有单一例程的小文件，并为每一个都替换掉相应的数据声明及从头文件中包含过来的代码，并在内部重新对各个例程命名以防止名字冲突</p>
<p>原先属于多个源代码文件中的本地例程，在划分为每个库成员一个例程的库的时候，这些本地例程名字在对外公开后很有可能存在名字相同的若干个例程，因此需要为避免名字冲突进行一些处理。这样的结果是可以产生尺寸最小的可执行程序，相应的代价是编译和链接的速度非常之慢。</p>
<h3 id="链接时优化"><a href="#链接时优化" class="headerlink" title="链接时优化"></a>链接时优化</h3><p>在大多数系统上，链接器是在软件建立过程中唯一会同时检查程序所有部分的程序。这就意味着他可以做一些别的部件无法进行的全局优化，特别是当程序由多个使用不同语言和编译器编写的多个模块组成的时候。例如，在一个带有类继承的语言中，一个类的方法可能会在子类中被覆盖，因此对它的调用通常都是间接的。但是如果没有任何的子类，或者存在子类但是没有一个覆盖了这个方法，那就可以直接调用这个方法。链接器可以对这种情况进行特殊优化以避免面向对象语言在继承时的低效率。</p>
<p>一种更激进的方法是对整个程序在链接时进行标准的全局优化。Srivastava 和 Wall 编写过一个优化链接器，可以将 RISC 体系结构的目标代码反编译为一种中间格式的数据，并对之实施诸如 inline 这样的高层次优化或诸如将一个更快但限制更多的指令替换为一个稍慢但常用的指令的低层次优化，然后再重新生成目标代码。特别是在 64 位体系结构的 Alpha体系结构中，对静态或者全局数据，以及任意例程的寻址方法，是将指向地址池中某一项的地址指针从内存中加载到寄存器里，然后把这个寄存器作为基址寄存器使用（地址持通过一个全局的指针寄存器来寻址）。他们的 OM 优化链接器会寻找多个连续指令引用一系列地址足够紧接的全局变量或静态变量的情况（这些全局变量和静态变量的彼此位置接近到足够可以通过同一个指针即可对他们寻址），然后重写目标代码以去除多余的从全局地址池中加载地址的指针。它也寻找那些通过分支跳转指令在 32 位地址范围内的过程调用，并将他们替换为需加载一个地址的间接调用。它也可以重新排列普通块的位置，使得较小的块排列在一起，这样以增加同一个指针被引用的次数。</p>
<p>其它链接器都会对进行一些别的体系结构相关的优化。如多流的 VLIW 机器具有大量的寄存器，并且寄存器内容的保存和回复是一个主要的瓶颈。有一个测试工具会使用统计数据指出哪些例程会频繁的调用其它哪里例程。它修改了代码中所使用的寄存器以尽量减少例程调用者和被调用者之间重叠使用的寄存器数量，进而尽量减少了保存和恢复的次数。</p>
<h2 id="链接时代码生成"><a href="#链接时代码生成" class="headerlink" title="链接时代码生成"></a>链接时代码生成</h2><p>很多链接器会生成少量的输出目标代码，例如 UNIX ELF 文件的 PLT（译者注：procedure linkage table）中的跳转项。但是一些实验链接器会产生比那更多的代码。Srivastava 和 Wall 的优化链接器首先将目标文件反编译为一种中间格式的代码。多数情况下，如果链接器想要中间格式代码的话，他可以很容易的告诉编译器跳过代码生成，而创建中间格式的目标文件，让链接器去完成代码生成工作。上面这些确实是 Fernandez 优化器所描述的。链接器可以使用所有的中间格式代码，对其进行大量的优化工作，然后再为输出文件产生目标代码。</p>
<p>对于商业链接器有很多理由说明为什么它们根据中间格式代码进行代码生成。理由之一是中间格式代码的语言趋向于和编译器的目标语言相关。设计一种中间格式代码的语言以处理包括 C 和 C++在内的类 Fortran 语言并不是很难的事情，但是要设计既能处理那些语言又能处理诸如 Cobol 和 Lisp 这样鲜有共性的语言，那是一件相当难的事情。链接器通常都是链接从任何编译器和汇编器生成的目标代码，因此使其和特定语言关联起来是会有问题的。链接时统计和工具有一些小组曾编写过链接时统计和优化的工具。</p>
<p>在链接传统二进制目标代码和链接中间格式语言之间有一个有趣的妥协就是将汇编语言的源程序作为中间格式的目标语言。链接器同时将整个程序汇编以生成输出文件。作为 Linux 灵感来源的 MINIX（一种类 UNIX 的小操作系统）就是这么做的。汇编语言足够接近于机器语言因此任何编译器都可以生成它，并且它也足够高级到可以进行一些有用的优化，包括无用代码消除、代码重组、一些有力的代码缩减，以及诸如对某一操作在确保足够操作位数的前提下选择最小版本指令的标准汇编优化。</p>
<p>由于汇编的执行速度很快，因此这样的系统可以很快的执行，尤其是当目标语言是一种被进行了标识的汇编语言而不是完全的汇编源代码时（这是因为像在其它编译器中一样，在汇编中最初添加标识的过程是整个处理过程中最慢的部分）。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/积累/" rel="tag"># 积累</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/06/19/北京地铁规划/" rel="next" title="北京地铁2025年规划">
                <i class="fa fa-chevron-left"></i> 北京地铁2025年规划
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/07/19/Linux检测工具/" rel="prev" title="Linux检测工具">
                Linux检测工具 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/header.jpg" alt="Hao Yu">
            
              <p class="site-author-name" itemprop="name">Hao Yu</p>
              <p class="site-description motion-element" itemprop="description">Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author</p>
          </div>
          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">315</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>
        	<audio controls="controls" loop="loop" preload="auto" src="/resource/xiaomeihao.mp3">
	        </audio>
	

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yuhao0102" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:yuh18@mails.tsinghua.edu.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#链接和加载"><span class="nav-number">1.</span> <span class="nav-text">链接和加载</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#链接器和加载器做什么？"><span class="nav-number">1.1.</span> <span class="nav-text">链接器和加载器做什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#地址绑定：从历史的角度"><span class="nav-number">1.2.</span> <span class="nav-text">地址绑定：从历史的角度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#链接与加载"><span class="nav-number">1.3.</span> <span class="nav-text">链接与加载</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#两遍链接"><span class="nav-number">1.4.</span> <span class="nav-text">两遍链接</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#目标代码库"><span class="nav-number">1.5.</span> <span class="nav-text">目标代码库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#重定位和代码修改"><span class="nav-number">1.6.</span> <span class="nav-text">重定位和代码修改</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#编译器驱动"><span class="nav-number">1.7.</span> <span class="nav-text">编译器驱动</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#链接器命令语言"><span class="nav-number">1.8.</span> <span class="nav-text">链接器命令语言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#链接：一个真实的例子"><span class="nav-number">1.9.</span> <span class="nav-text">链接：一个真实的例子</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#体系结构的问题"><span class="nav-number">2.</span> <span class="nav-text">体系结构的问题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#应用程序二进制接口"><span class="nav-number">2.1.</span> <span class="nav-text">应用程序二进制接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内存地址"><span class="nav-number">2.2.</span> <span class="nav-text">内存地址</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#字节顺序和对齐"><span class="nav-number">2.2.1.</span> <span class="nav-text">字节顺序和对齐</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#地址构成"><span class="nav-number">2.3.</span> <span class="nav-text">地址构成</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#指令格式"><span class="nav-number">2.4.</span> <span class="nav-text">指令格式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#过程调用和可寻址性"><span class="nav-number">2.5.</span> <span class="nav-text">过程调用和可寻址性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#过程调用"><span class="nav-number">2.6.</span> <span class="nav-text">过程调用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分页和虚拟内存"><span class="nav-number">2.7.</span> <span class="nav-text">分页和虚拟内存</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#程序地址空间"><span class="nav-number">2.8.</span> <span class="nav-text">程序地址空间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#映射文件"><span class="nav-number">2.9.</span> <span class="nav-text">映射文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#共享库和程序"><span class="nav-number">2.10.</span> <span class="nav-text">共享库和程序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#位置无关代码"><span class="nav-number">2.11.</span> <span class="nav-text">位置无关代码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#嵌入式体系结构"><span class="nav-number">2.12.</span> <span class="nav-text">嵌入式体系结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#怪异的地址空间"><span class="nav-number">2.12.1.</span> <span class="nav-text">怪异的地址空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#非一致性内存"><span class="nav-number">2.12.2.</span> <span class="nav-text">非一致性内存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内存对齐"><span class="nav-number">2.12.3.</span> <span class="nav-text">内存对齐</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#目标文件"><span class="nav-number">3.</span> <span class="nav-text">目标文件</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#目标文件中都有什么"><span class="nav-number">3.1.</span> <span class="nav-text">目标文件中都有什么?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#设计一个目标文件格式"><span class="nav-number">3.2.</span> <span class="nav-text">设计一个目标文件格式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#代码区段：Unix-a-out-文件"><span class="nav-number">3.2.1.</span> <span class="nav-text">代码区段：Unix a.out 文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#a-out-头部"><span class="nav-number">3.2.2.</span> <span class="nav-text">a.out 头部</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#与虚拟内存的交互"><span class="nav-number">3.2.3.</span> <span class="nav-text">与虚拟内存的交互</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#重定位：MS-DOS-EXE-文件"><span class="nav-number">3.3.</span> <span class="nav-text">重定位：MS-DOS EXE 文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#符号和重定位"><span class="nav-number">3.4.</span> <span class="nav-text">符号和重定位</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#可重定位的-a-out-格式"><span class="nav-number">3.4.1.</span> <span class="nav-text">可重定位的 a.out 格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Unix-ELF-格式"><span class="nav-number">3.4.2.</span> <span class="nav-text">Unix ELF 格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可重定位文件"><span class="nav-number">3.4.3.</span> <span class="nav-text">可重定位文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ELF-可执行文件"><span class="nav-number">3.4.4.</span> <span class="nav-text">ELF 可执行文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ELF-格式小结"><span class="nav-number">3.4.5.</span> <span class="nav-text">ELF 格式小结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#存储空间分配"><span class="nav-number">4.</span> <span class="nav-text">存储空间分配</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#段和地址"><span class="nav-number">4.1.</span> <span class="nav-text">段和地址</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#简单的存储布局"><span class="nav-number">4.1.1.</span> <span class="nav-text">简单的存储布局</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多种段类型"><span class="nav-number">4.1.2.</span> <span class="nav-text">多种段类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#段与页面的对齐"><span class="nav-number">4.1.3.</span> <span class="nav-text">段与页面的对齐</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#公共块和其它特殊段"><span class="nav-number">4.1.4.</span> <span class="nav-text">公共块和其它特殊段</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#公共块"><span class="nav-number">4.1.4.1.</span> <span class="nav-text">公共块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#C-重复代码消除"><span class="nav-number">4.1.4.2.</span> <span class="nav-text">C++重复代码消除</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#符号管理"><span class="nav-number">5.</span> <span class="nav-text">符号管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#绑定和名字解析"><span class="nav-number">5.1.</span> <span class="nav-text">绑定和名字解析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#符号表格式"><span class="nav-number">5.2.</span> <span class="nav-text">符号表格式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#模块表"><span class="nav-number">5.2.1.</span> <span class="nav-text">模块表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#全局符号表"><span class="nav-number">5.2.2.</span> <span class="nav-text">全局符号表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#符号解析"><span class="nav-number">5.2.3.</span> <span class="nav-text">符号解析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#特殊符号"><span class="nav-number">5.2.4.</span> <span class="nav-text">特殊符号</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#名称修改"><span class="nav-number">5.3.</span> <span class="nav-text">名称修改</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#简单的-C-和-Fortran-名称修改"><span class="nav-number">5.3.1.</span> <span class="nav-text">简单的 C 和 Fortran 名称修改</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-类型编码：类型和范围"><span class="nav-number">5.3.2.</span> <span class="nav-text">C++类型编码：类型和范围</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#链接时类型检查"><span class="nav-number">5.3.3.</span> <span class="nav-text">链接时类型检查</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#维护调试信息"><span class="nav-number">5.4.</span> <span class="nav-text">维护调试信息</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#行号信息"><span class="nav-number">5.4.1.</span> <span class="nav-text">行号信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#符号和变量信息"><span class="nav-number">5.4.2.</span> <span class="nav-text">符号和变量信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实际的问题"><span class="nav-number">5.4.3.</span> <span class="nav-text">实际的问题</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#库"><span class="nav-number">6.</span> <span class="nav-text">库</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#库的目的"><span class="nav-number">6.1.</span> <span class="nav-text">库的目的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#库的格式"><span class="nav-number">6.2.</span> <span class="nav-text">库的格式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#搜索库文件"><span class="nav-number">6.2.1.</span> <span class="nav-text">搜索库文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#性能问题"><span class="nav-number">6.2.2.</span> <span class="nav-text">性能问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#弱外部符号"><span class="nav-number">6.3.</span> <span class="nav-text">弱外部符号</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#重定位"><span class="nav-number">7.</span> <span class="nav-text">重定位</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#硬件和软件重定位"><span class="nav-number">7.1.</span> <span class="nav-text">硬件和软件重定位</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#链接时重定位和加载时重定位"><span class="nav-number">7.1.1.</span> <span class="nav-text">链接时重定位和加载时重定位</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#符号和段重定位"><span class="nav-number">7.1.2.</span> <span class="nav-text">符号和段重定位</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#符号查找"><span class="nav-number">7.1.3.</span> <span class="nav-text">符号查找</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基本的重定位技术"><span class="nav-number">7.2.</span> <span class="nav-text">基本的重定位技术</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#可重链接和重定位的输出格式"><span class="nav-number">7.3.</span> <span class="nav-text">可重链接和重定位的输出格式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#其它重定位格式"><span class="nav-number">7.4.</span> <span class="nav-text">其它重定位格式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#以链表形式组织的引用"><span class="nav-number">7.4.1.</span> <span class="nav-text">以链表形式组织的引用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#特殊情况的重定位"><span class="nav-number">7.5.</span> <span class="nav-text">特殊情况的重定位</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#加载和重叠"><span class="nav-number">8.</span> <span class="nav-text">加载和重叠</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#基本加载"><span class="nav-number">8.1.</span> <span class="nav-text">基本加载</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#带重定位的基本加载"><span class="nav-number">8.2.</span> <span class="nav-text">带重定位的基本加载</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#位置无关代码-1"><span class="nav-number">8.3.</span> <span class="nav-text">位置无关代码</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#例程指针表"><span class="nav-number">8.3.1.</span> <span class="nav-text">例程指针表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#目录表"><span class="nav-number">8.3.2.</span> <span class="nav-text">目录表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ELF-位置无关代码"><span class="nav-number">8.3.3.</span> <span class="nav-text">ELF 位置无关代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#位置无关代码的开销和得益"><span class="nav-number">8.3.4.</span> <span class="nav-text">位置无关代码的开销和得益</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#自举加载"><span class="nav-number">8.4.</span> <span class="nav-text">自举加载</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#共享库"><span class="nav-number">9.</span> <span class="nav-text">共享库</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#绑定时间"><span class="nav-number">9.1.</span> <span class="nav-text">绑定时间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#地址空间管理"><span class="nav-number">9.2.</span> <span class="nav-text">地址空间管理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#共享库的结构"><span class="nav-number">9.3.</span> <span class="nav-text">共享库的结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#创建共享库"><span class="nav-number">9.4.</span> <span class="nav-text">创建共享库</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#创建跳转表"><span class="nav-number">9.4.1.</span> <span class="nav-text">创建跳转表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建共享库-1"><span class="nav-number">9.4.2.</span> <span class="nav-text">创建共享库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建空占位库"><span class="nav-number">9.4.3.</span> <span class="nav-text">创建空占位库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#版本命名"><span class="nav-number">9.4.4.</span> <span class="nav-text">版本命名</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用共享库链接"><span class="nav-number">9.5.</span> <span class="nav-text">使用共享库链接</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用共享库运行"><span class="nav-number">9.6.</span> <span class="nav-text">使用共享库运行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#malloc-hack-和其它共享库问题"><span class="nav-number">9.7.</span> <span class="nav-text">malloc hack 和其它共享库问题</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#动态链接和加载"><span class="nav-number">10.</span> <span class="nav-text">动态链接和加载</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#ELF-文件内容"><span class="nav-number">10.1.</span> <span class="nav-text">ELF 文件内容</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#加载一个动态链接的程序"><span class="nav-number">10.2.</span> <span class="nav-text">加载一个动态链接的程序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#启动动态链接器"><span class="nav-number">10.2.1.</span> <span class="nav-text">启动动态链接器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#库的查找"><span class="nav-number">10.2.2.</span> <span class="nav-text">库的查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#共享库的初始化"><span class="nav-number">10.2.3.</span> <span class="nav-text">共享库的初始化</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#高级技术"><span class="nav-number">11.</span> <span class="nav-text">高级技术</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#C-的技术"><span class="nav-number">11.1.</span> <span class="nav-text">C++的技术</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#试验链接"><span class="nav-number">11.1.1.</span> <span class="nav-text">试验链接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#消除重复代码"><span class="nav-number">11.1.2.</span> <span class="nav-text">消除重复代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#借助于数据库的方法"><span class="nav-number">11.1.3.</span> <span class="nav-text">借助于数据库的方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#链接时的垃圾收集"><span class="nav-number">11.1.4.</span> <span class="nav-text">链接时的垃圾收集</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#链接时优化"><span class="nav-number">11.1.5.</span> <span class="nav-text">链接时优化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#链接时代码生成"><span class="nav-number">11.2.</span> <span class="nav-text">链接时代码生成</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>
  <div id="DvelopmentTarget">     
  </div>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart" aria-hidden="false"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>

  
</div>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_uv"> 
  本站访客数<span id="busuanzi_value_site_uv"></span>人次
</span>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  


  <script type="text/javascript" src="/js/src/love.js"></script>

</body>
</html>
