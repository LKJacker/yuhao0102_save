<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zn-ch">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-center-simple.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="C++,">










<meta name="description" content="C++运算符重载运算符重载概述重载运算符的原因基本指导原则是：为了让自定义类的行为和内建类型一样。自定义类的行为越接近内建类型，就越便于这些类的客户使用。 运算符重载的限制下面列出了重载运算符时不能做的事情：  不能添加新的运算符。只能重定义语言中已经存在的运算符的意义。 有少数运算符不能重载，例如.(对象成员访问运算符)、:(作用域解析运算符)、sizeof、?(条件运算符)以及其他几个运算符。">
<meta name="keywords" content="C++">
<meta property="og:type" content="article">
<meta property="og:title" content="C++高级编程 第四版 笔记5">
<meta property="og:url" content="http://yoursite.com/2021/05/07/cpp高级编程 笔记5/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="C++运算符重载运算符重载概述重载运算符的原因基本指导原则是：为了让自定义类的行为和内建类型一样。自定义类的行为越接近内建类型，就越便于这些类的客户使用。 运算符重载的限制下面列出了重载运算符时不能做的事情：  不能添加新的运算符。只能重定义语言中已经存在的运算符的意义。 有少数运算符不能重载，例如.(对象成员访问运算符)、:(作用域解析运算符)、sizeof、?(条件运算符)以及其他几个运算符。">
<meta property="og:locale" content="zn-ch">
<meta property="og:image" content="http://yoursite.com/img/1619883633.jpg">
<meta property="og:image" content="http://yoursite.com/img/1619883679.jpg">
<meta property="og:image" content="http://yoursite.com/img/1619883699.jpg">
<meta property="og:image" content="http://yoursite.com/img/1619926098.jpg">
<meta property="og:image" content="http://yoursite.com/img/1619926131.jpg">
<meta property="og:image" content="http://yoursite.com/img/1619926262.jpg">
<meta property="og:image" content="http://yoursite.com/img/1619926380.jpg">
<meta property="og:image" content="http://yoursite.com/img/1619926439.jpg">
<meta property="og:image" content="http://yoursite.com/img/1619926474.jpg">
<meta property="og:image" content="http://yoursite.com/img/1619927358.jpg">
<meta property="og:image" content="http://yoursite.com/img/1619927511.jpg">
<meta property="og:image" content="http://yoursite.com/img/1619927550.jpg">
<meta property="og:image" content="http://yoursite.com/img/1619927625.jpg">
<meta property="og:image" content="http://yoursite.com/img/1619927652.jpg">
<meta property="og:image" content="http://yoursite.com/img/1619927695.jpg">
<meta property="og:image" content="http://yoursite.com/img/1619927735.jpg">
<meta property="og:image" content="http://yoursite.com/img/1619927755.jpg">
<meta property="og:image" content="http://yoursite.com/img/1619927803.jpg">
<meta property="og:image" content="http://yoursite.com/img/1619927862.jpg">
<meta property="og:image" content="http://yoursite.com/img/1619927898.jpg">
<meta property="og:image" content="http://yoursite.com/img/1619928233.jpg">
<meta property="og:image" content="http://yoursite.com/img/1619928319.jpg">
<meta property="og:image" content="http://yoursite.com/img/1619945239.jpg">
<meta property="og:image" content="http://yoursite.com/img/1619945467.jpg">
<meta property="og:image" content="http://yoursite.com/img/1619945484.jpg">
<meta property="og:image" content="http://yoursite.com/img/1620192765.jpg">
<meta property="og:image" content="http://yoursite.com/img/1620194725.jpg">
<meta property="og:image" content="http://yoursite.com/img/1620194766.jpg">
<meta property="og:updated_time" content="2021-05-07T06:07:41.955Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="C++高级编程 第四版 笔记5">
<meta name="twitter:description" content="C++运算符重载运算符重载概述重载运算符的原因基本指导原则是：为了让自定义类的行为和内建类型一样。自定义类的行为越接近内建类型，就越便于这些类的客户使用。 运算符重载的限制下面列出了重载运算符时不能做的事情：  不能添加新的运算符。只能重定义语言中已经存在的运算符的意义。 有少数运算符不能重载，例如.(对象成员访问运算符)、:(作用域解析运算符)、sizeof、?(条件运算符)以及其他几个运算符。">
<meta name="twitter:image" content="http://yoursite.com/img/1619883633.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2021/05/07/cpp高级编程 笔记5/">





  <title>C++高级编程 第四版 笔记5 | Hao Yu's blog</title>
  








 
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zn-ch">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hao Yu's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">The program monkey was eaten by the siege lion.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/resume.pdf" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-mybetterhalf">
          <a href="/mybetterhalf/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>
            
            mybetterhalf
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/05/07/cpp高级编程 笔记5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">C++高级编程 第四版 笔记5</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-05-07T14:07:41+08:00">
                2021-05-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="C-运算符重载"><a href="#C-运算符重载" class="headerlink" title="C++运算符重载"></a>C++运算符重载</h1><h2 id="运算符重载概述"><a href="#运算符重载概述" class="headerlink" title="运算符重载概述"></a>运算符重载概述</h2><h3 id="重载运算符的原因"><a href="#重载运算符的原因" class="headerlink" title="重载运算符的原因"></a>重载运算符的原因</h3><p>基本指导原则是：为了让自定义类的行为和内建类型一样。自定义类的行为越接近内建类型，就越便于这些类的客户使用。</p>
<h3 id="运算符重载的限制"><a href="#运算符重载的限制" class="headerlink" title="运算符重载的限制"></a>运算符重载的限制</h3><p>下面列出了重载运算符时不能做的事情：</p>
<ul>
<li>不能添加新的运算符。只能重定义语言中已经存在的运算符的意义。</li>
<li>有少数运算符不能重载，例如<code>.</code>(对象成员访问运算符)、<code>:</code>(作用域解析运算符)、<code>sizeof</code>、<code>?</code>(条件运算符)以及其他几个运算符。</li>
<li><code>arity</code>描述了运算符关联的参数或操作数的数量。只能修改函数调用、new和delete运算符的arity。其他运算符的arity不能修改。</li>
<li>不能修改运算符的优先级和结合性。这些规则确定了运算符在语句中的求值顺序。</li>
<li>不能对内建类型重定义运算符。运算符必须是类中的一个方法，或者全局重载运算符函数至少有一个参数必须是一种用户定义的类型(例如一个类)。</li>
</ul>
<h3 id="运算符重载的选择"><a href="#运算符重载的选择" class="headerlink" title="运算符重载的选择"></a>运算符重载的选择</h3><p>重载运算符时，需要编写名为<code>operatorX</code>的函数或方法，X是表示这个运算符的符号。例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SpreadsheetCell <span class="keyword">operator</span>+(<span class="keyword">const</span> SpreadsheetCells lhs, <span class="keyword">const</span> SpreadsheetCells rhs);</span><br></pre></td></tr></table></figure></p>
<h4 id="方法还是全局函数"><a href="#方法还是全局函数" class="headerlink" title="方法还是全局函数"></a>方法还是全局函数</h4><p>当运算符是类的方法时，运算符表达式的左侧必须是这个类的对象。当编写全局函数时，运算符表达式的左侧可以是不同类型的对象。有3种不同类型的运算符：</p>
<ul>
<li>必须为方法的运算符：C++语言要求一些运算符必须是类中的方法，因为这些运算符在类的外部没有意义。例如，<code>operator-</code>和类绑定得非常紧密，不能出现在其他地方。大部分运算符都没有施加这种要求。</li>
<li>必须为全局函数的运算符：如果允许运算符左侧的变量是除了自定义的类之外的任何类型，那么必须将这个运算符定义为全局函数。确切地讲，这条规则适用于<code>operator&lt;&lt;</code>和<code>operator&gt;&gt;</code>，这两个运算符的左侧是<code>iostream</code>对象，而不是自定义类的对象。此外，可交换的运算符(例如二元的+和-)允许运算符左侧的变量不是自定义类的对象。</li>
<li>既可为方法又可为全局函数的运算符，建议遵循如下规则：把所有运算符都定义为方法，除非根据以上描述必须定义为全局函数。这条规则的一个主要优点是，方法可以是虚方法，但全局函数不能是虚函数。因此，如果准备在继承树中编写重载的运算符，应尽可能将这些运算符定义为方法。</li>
</ul>
<p>将重载的运算符定义为方法时，如果这个运算符不修改对象，应将整个方法标记为const。这样，就可对const对象调用这个方法。</p>
<h4 id="选择参数类型"><a href="#选择参数类型" class="headerlink" title="选择参数类型"></a>选择参数类型</h4><p>参数类型的选择有一些限制，因为如前所述，大多数运算符不能修改参数数量。真正需要选择的地方在于判断是按值还是按引用接收参数，以及是否需要把参数标记为const。</p>
<p>按值传递还是按引用传递的决策很简单：<strong>应按引用接收每一个非基本类型的参数</strong>。</p>
<p>const决策也很简单：<strong>除非要真正修改参数，否则将每个参数都设置为const</strong>。</p>
<h4 id="选择返回类型"><a href="#选择返回类型" class="headerlink" title="选择返回类型"></a>选择返回类型</h4><p>应该让运算符返回的类型和运算符对内建类型操作时返回的类型一样。如果编写比较运算符，那么应该返回bool类型。如果编写算术运算符，那么应该返回表示运算结果的对象。返回值还是引用的一般原则是：<strong>如果可以，就返回一个引用，否则返回一个值</strong>：如果运算符构造了一个新对象，那么必须按值返回这个新对象。如果不构造新对象，可返回对调用这个运算符的对象的引用，或返回对其中一个参数的引用。</p>
<p>可作为左值(赋值表达式左侧的部分)修改的返回值必须是非const。否则，这个值应该是const。大部分很容易想到的运算符都要求返回左值，包括所有赋值运算符(operator-、operator+-和operator-等)。</p>
<h3 id="不应重载的运算符"><a href="#不应重载的运算符" class="headerlink" title="不应重载的运算符"></a>不应重载的运算符</h3><p>有些运算符即使允许重载，也不应该重载。具体来说，取地址运算符<code>operator&amp;</code>的重载一般没什么特别的用途，如果重载会导致混乱，因为这样做会以可能异常的方式修改基础语言的行为(获得变量的地址)。整个标准库大量使用了运算符重载，但从没有重载取地址运算符。</p>
<h3 id="可重载运算符小结"><a href="#可重载运算符小结" class="headerlink" title="可重载运算符小结"></a>可重载运算符小结</h3><p>在表15-1中，T表示要编写重载运算符的类名，E是一种不同的类型。<br><img src="/img/1619883633.jpg" alt><br><img src="/img/1619883679.jpg" alt><br><img src="/img/1619883699.jpg" alt></p>
<h3 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h3><p>表15-1列出的普通赋值运算符的原型如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> T&amp;);</span><br></pre></td></tr></table></figure></p>
<p>移动赋值运算符的原型几乎一致，但使用了右值引用。这个运算符会修改参数，因此不能传递const参数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T&amp; <span class="keyword">operator</span>=(T&amp;&amp;);</span><br></pre></td></tr></table></figure></p>
<p>表15-1没有包含右值引用语义的示例原型。然而，对于大部分运算符来说，编写一个使用普通左值引用的版本以及一个使用右值引用的版本都是有意义的，但是否真正有意义取决于类的实现细节。标准库中的<code>std:string</code>类利用右值引用实现了<code>operator+</code>，如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> <span class="keyword">operator</span>+(<span class="built_in">string</span>&amp;&amp; lhs, <span class="built_in">string</span>&amp;&amp; rhs);</span><br></pre></td></tr></table></figure></p>
<p>这个运算符的实现会重用其中一个参数的内存，因为这些参数是以右值引用传递的。也就是说，这两个参数表示的都是<code>operator+</code>完成之后销毁的临时对象。上述<code>operator+</code>的实现具有以下效果：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="built_in">std</span>::move(lhs.append(rhs));</span><br></pre></td></tr></table></figure></p>
<p>或<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="built_in">std</span>::move(ths.insert(<span class="number">0</span>, lhs));</span><br></pre></td></tr></table></figure></p>
<p>事实上，<code>std::string</code>定义了几个具有不同左值引用和右值引用组合的重载的<code>operator+</code>运算符。下面列出<code>std::string</code>中所有接收两个字符串参数的<code>operator+</code>运算符<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> <span class="keyword">operator</span>+(<span class="keyword">const</span> <span class="built_in">string</span>&amp; lhs, <span class="keyword">const</span> <span class="built_in">string</span>&amp; rhs);</span><br><span class="line"><span class="built_in">string</span> <span class="keyword">operator</span>+(<span class="built_in">string</span>&amp;&amp; lhs, <span class="keyword">const</span> <span class="built_in">string</span>&amp; rhs);</span><br><span class="line"><span class="built_in">string</span> <span class="keyword">operator</span>+(<span class="keyword">const</span> <span class="built_in">string</span>&amp; lhs, <span class="built_in">string</span>&amp;&amp; rhs);</span><br><span class="line"><span class="built_in">string</span> <span class="keyword">operator</span>+(<span class="built_in">string</span>&amp;&amp; lhs, <span class="built_in">string</span>&amp;&amp; rhs);</span><br></pre></td></tr></table></figure></p>
<h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><p>C++标准库有一个方便的<code>&lt;utility&gt;</code>头文件，它包含几个辅助函数和类，还在<code>std::rel_ops</code>名称空间中给关系运算符包含如下函数模板：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">bool</span> <span class="title">operator</span>!=(<span class="title">const</span> <span class="title">T</span>&amp; <span class="title">a</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">b</span>);</span><span class="comment">//Needs operator==</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">bool</span> <span class="title">operator</span>&gt;(<span class="title">const</span> <span class="title">T</span>&amp; <span class="title">a</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">b</span>);</span> <span class="comment">//Needs operator&lt;</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">bool</span> <span class="title">operator</span>&lt;=(const T&amp; a, const T&amp; b);//Needs operator&lt;</span></span><br><span class="line"><span class="class">template&lt;class T&gt; bool operator&gt;=(const T&amp; a, const T&amp; b);//Needs operator&lt;</span></span><br></pre></td></tr></table></figure></p>
<p>这些函数模板根据<code>==</code>和<code>&lt;</code>运算符给任意类定义了运算符<code>!=</code>、<code>&gt;</code>、<code>&lt;=</code>和<code>&gt;=</code>。如果在类中实现<code>operator--</code>和<code>operator&lt;</code>，就会通过这些模板自动获得其他关系运算符。只要添加<code>#include &lt;utility&gt;</code>和下面的using声明，就可将这些运算符用于自己的类：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>::rel_ops;</span><br></pre></td></tr></table></figure></p>
<p>但是，这种技术带来的一个问题在于，现在可能为用于关系操作的所有类(而非只为自己的类)创建这些运算符。还有一个问题是隐式转换不可行。</p>
<h2 id="重载算术运算符"><a href="#重载算术运算符" class="headerlink" title="重载算术运算符"></a>重载算术运算符</h2><h3 id="重载一元负号和一元正号运算符"><a href="#重载一元负号和一元正号运算符" class="headerlink" title="重载一元负号和一元正号运算符"></a>重载一元负号和一元正号运算符</h3><p>C++有几个一元算术运算符。一元负号和一元正号运算符是其中的两个。这些运算符不改变调用它们的对象，所以应把它们标记为const。下例将一元<code>operator-</code>运算符重载为SpreadsheetCell类的成员函数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SpreadsheetCell SpreadsheetCell::<span class="keyword">operator</span>-() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> SpreadsheetCell (-getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>operator-</code>没有修改操作数，因此这个方法必须构造一个新的带有相反值的SpreadsheetCell对象，并返回这个对象的副本。因此，这个运算符不能返回引用。可按以下方式使用这个运算符：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SpreadsheetCell <span class="title">c1</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">SpreadsheetCell c3 = -c1;</span><br></pre></td></tr></table></figure></p>
<h3 id="重载递增和递减运算符"><a href="#重载递增和递减运算符" class="headerlink" title="重载递增和递减运算符"></a>重载递增和递减运算符</h3><p>可采用4种方法给变量加1:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i = i + <span class="number">1</span>;</span><br><span class="line">i += <span class="number">1</span>;</span><br><span class="line">++ i;</span><br><span class="line">i ++;</span><br></pre></td></tr></table></figure></p>
<p>后两种称为递增运算符。第一种形式是前缀递增，这个操作将变量增加1，然后返回增加后的新值，供表达式的其他部分使用。第二种形式是后缀递增，返回旧值(增加之前的值)，供表达式的其他部分使用。递减运算符的功能类似。</p>
<p><code>operator++</code>和<code>operator--</code>的双重意义给重载带来了问题，C++引入了一种方法来区分前后缀：前缀版本的<code>operator++</code>和<code>operator--</code>不接收参数，而后缀版本的接收一个不使用的int类型参数。如果要为SpreadsheetCell类重载这些运算符，原型如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SpreadsheetCell&amp; <span class="keyword">operator</span>++(); <span class="comment">// Prefix</span></span><br><span class="line">Spreadsheetcell <span class="keyword">operator</span>++(<span class="keyword">int</span>); <span class="comment">// Postfix</span></span><br><span class="line">SpreadsheetCell&amp; <span class="keyword">operator</span>--(); <span class="comment">// Prefix</span></span><br><span class="line">SpreadsheetCell <span class="keyword">operator</span>--(<span class="keyword">int</span>); <span class="comment">// Postfix</span></span><br></pre></td></tr></table></figure></p>
<p>前缀形式的结果值和操作数的最终值一致，因此前缀递增和前缀递减返回被调用对象的引用。然而后缀版本的递增操作和递减操作返回的结果值和操作数的最终值不同，因此不能返回引用。下面是operator++运算符的实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SpreadsheetCell&amp; SpreadsheetCell::<span class="keyword">operator</span>++() &#123;</span><br><span class="line">    <span class="built_in">set</span>(getValue() + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SpreadsheetCell SpreadsheetCell::<span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">oldCell</span><span class="params">(*<span class="keyword">this</span>)</span></span>; <span class="comment">// Save current value</span></span><br><span class="line">    ++(*<span class="keyword">this</span>);           <span class="comment">// Increment using prefix + 1</span></span><br><span class="line">    <span class="keyword">return</span> oldCell;      <span class="comment">// Return the old value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>递增和递减还能应用于指针。当编写的类是智能指针或迭代器时，可重载<code>operator++</code>和<code>operator--</code>，以提供指针的递增和递减操作。</p>
<h2 id="重载按位运算符和二元逻辑运算符"><a href="#重载按位运算符和二元逻辑运算符" class="headerlink" title="重载按位运算符和二元逻辑运算符"></a>重载按位运算符和二元逻辑运算符</h2><p>按位运算符和算术运算符类似，简写的按位赋值运算符也和简写的算术赋值运算符类似。逻辑运算符要困难一些。建议不要重载&amp;&amp;和||。这些运算符并不应用于单个类型，而是整合布尔表达式的结果。此外，重载这些运算符会失去短路求值，原因是在将运算符左侧和右侧的值绑定至重载的&amp;&amp;和运算符之前，必须对运算符的左侧和右侧进行求值。因此，一般对特定类型重载这些运算符都没有意义。</p>
<h2 id="重载插入运算符和提取运算符"><a href="#重载插入运算符和提取运算符" class="headerlink" title="重载插入运算符和提取运算符"></a>重载插入运算符和提取运算符</h2><p>在编写插入和提取运算符前，需要决定如何将自定义的类向流输出，以及如何从流中提取自定义的类。在这个例子中，SpreadsheetCell将读取和写入double值。插入和提取运算符左侧的对象是<code>istream</code>或<code>ostream</code>(例如<code>cin</code>和<code>cout</code>)，而不是SpreadsheetCell对象。由于不能向<code>istream</code>类或<code>ostream</code>类添加方法，因此应将插入和提取运算符写为SpreadsheetCell类的全局函数。这些函数在SpreadsheetCell类中的声明如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpreadsheetCell</span>&#123;</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream&amp; ostr, <span class="keyword">const</span> SpreadsheetCell&amp; cell);</span><br><span class="line"><span class="built_in">std</span>::istream&amp; <span class="keyword">operator</span>&gt;&gt;(<span class="built_in">std</span>::istream&amp; istr, SpreadsheetCell&amp; cell);</span><br></pre></td></tr></table></figure></p>
<p>将插入运算符的第一个参数设置为<code>ostream</code>的引用，这个运算符就能应用于文件输出流、字符串输出流、cout、cerr和clog等。与此类似，将提取运算符的参数设置为<code>istream</code>的引用，这个运算符就能应用于文件输入流、字符串输入流和cin。</p>
<p><code>operator&lt;&lt;</code>和<code>operator&gt;&gt;</code>的第二个参数是对要写入或读取的SpreadsheetCell对象的引用。插入运算符不会修改写入的SpreadsheetCell对象，因此这个引用可以是const引用。然而提取运算符会修改SpreadsheetCell对象，因此要求这个参数为非const引用。</p>
<p>这两个运算符返回的都是第一个参数传入的流的引用，所以这两个运算符的调用可以嵌套。记住，运算符的语法实际上是显式调用全局<code>operator&gt;&gt;</code>函数或<code>operator&lt;&lt;</code>函数的简写形式。 例如下面这行代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cin</span> &gt;&gt; myCell &gt;&gt; anotherCell &gt;&gt; aThirdCell;</span><br></pre></td></tr></table></figure></p>
<p>实际上是如下代码行的简写形式：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">operator</span>&gt;&gt;(<span class="keyword">operator</span>&gt;&gt;(<span class="keyword">operator</span>&gt;&gt;(<span class="built_in">cin</span>, myCell), anotherCell), aThirdCell);</span><br></pre></td></tr></table></figure></p>
<p>从中可以看出，第一次调用<code>operator&gt;&gt;</code>的返回值被用作下一次调用的输入值。因此必须返回流的引用，结果才能用于下一次嵌套的调用。否则嵌套调用无法编译。</p>
<h2 id="重载下标运算符"><a href="#重载下标运算符" class="headerlink" title="重载下标运算符"></a>重载下标运算符</h2><p>一个动态分配的数组类允许设置和获取指定索引位置的元素，并会自动完成所有的内存分配操作，定义可能是这样的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Array</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Array();</span><br><span class="line">    <span class="keyword">virtual</span> ~Array();</span><br><span class="line">    Array&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Array&lt;T&gt;&amp; rhs) = <span class="keyword">delete</span>;</span><br><span class="line">    Array(<span class="keyword">const</span> Array&lt;T&gt;&amp; src) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> T&amp; <span class="title">getElementAt</span><span class="params">(<span class="keyword">size_t</span> x)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    void setElementat(size_t x, const T&amp; value):</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">size_t</span> getsize() <span class="keyword">const</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">size_t</span> kAllocSize = <span class="number">4</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">size_t</span> newSize)</span></span>;</span><br><span class="line">    T* mElements = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">size_t</span> mSize = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这个接口支持设置和访问元素。它为随机访问提供了保证：客户可创建数组，并设置元素1、100和1000，而不必考虑内存管理问题。下面是这些方法的实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; Array&lt;T&gt;::Array() &#123;</span><br><span class="line">    mSize = kAllocSize;</span><br><span class="line">    mElements = <span class="keyword">new</span> T[mSize] &#123;&#125;;<span class="comment">// Elements are zero-initialized!</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; Array&lt;T&gt;::~Array() &#123;</span><br><span class="line">    <span class="keyword">delete</span> [] mElements;</span><br><span class="line">    mElements = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> Array&lt;T&gt;::resize(<span class="keyword">size_t</span> newSize) &#123;</span><br><span class="line">    <span class="keyword">auto</span> newArray = <span class="built_in">std</span>::make_unique&lt;T[]&gt;(newSize);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mSize; i ++) &#123;</span><br><span class="line">        newArray[i] = mElements[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] mElements;</span><br><span class="line">    mSize = newSize;</span><br><span class="line">    mElements = newArray.release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>resize()</code>首先创建一个适当大小的新数组，将其存储在<code>unique_ptr</code>中。然后将所有元素从旧数组复制到新数组。如果在复制值时任何地方出错，<code>unique_ptr</code>会自动清理内存。最后，在成功分配新数组和复制所有元素后，即未抛出异常，我们才删除旧的mElements数组，并为其指定新数组。最后一行必须使用<code>release()</code>来释放<code>unique_ptr</code>的新数组的所有权，否则，在调用<code>unique_ptr</code>的析构函数时，将销毁这个数组。</p>
<p>通过以下方式给类添加<code>operator[]</code>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; T&amp; Array&lt;T&gt;::<span class="keyword">operator</span>[](<span class="keyword">size_t</span> x) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= mSize)</span><br><span class="line">        resize(x + kAllocSize);</span><br><span class="line">    <span class="keyword">return</span> mElements[x];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>operator[]</code>可设置和获取元素，因为它返回的是一个对位置x处的元素的引用。可通过这个引用对这个元素赋值。当<code>operator[]</code>用在赋值语句的左侧时，赋值操作实际上修改了mElements数组中位置x处的值。</p>
<h3 id="通过operator-提供只读访问"><a href="#通过operator-提供只读访问" class="headerlink" title="通过operator[]提供只读访问"></a>通过operator[]提供只读访问</h3><p>理想情况下，可提供两个<code>operator[]</code>：一个返回引用，另一个返回const引用。为此，编写下面这样的代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">const</span> T&amp; Array&lt;T&gt;::<span class="keyword">operator</span>[](<span class="keyword">size_t</span> x) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= mSize)</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">std</span>::out_of_range(<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">return</span> mElements[x];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为const对象调用<code>const operator[]</code>，因此无法增加数组大小。当给定索引越界时，当前实现抛出异常。另一种做法是返回零初始化值而非抛出零初始化元素。代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">const</span> T&amp; Array&lt;T&gt;::<span class="keyword">operator</span>[](<span class="keyword">size_t</span> x) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= mSize) &#123;</span><br><span class="line">        <span class="keyword">static</span> T nullValue = T();</span><br><span class="line">        <span class="keyword">return</span>.nullValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mElements [x];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="重载函数调用运算符"><a href="#重载函数调用运算符" class="headerlink" title="重载函数调用运算符"></a>重载函数调用运算符</h2><p>C++允许重载函数调用运算符，写作<code>operator()</code>。如果在自定义的类中编写了一个<code>operator()</code>，那么这个类的对象就可以当成函数指针使用。包含函数调用运算符的类对象称为<strong>函数对象</strong>，或简称为仿函数(functor)。只能将这个运算符重载为类中的非静态方法。下例是一个简单的类，它带有一个重载的<code>operator()</code>以及一个具有相同行为的类方法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FunctionObject</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span> param)</span></span>; <span class="comment">// Function call operator</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dosquare</span><span class="params">(<span class="keyword">int</span> param)</span> </span>&#123;<span class="keyword">return</span> param * param; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> FunctionObject::<span class="keyword">operator</span>() (<span class="keyword">int</span> param) &#123;</span><br><span class="line">    <span class="keyword">return</span> doSquare(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面是使用函数调用运算符的代码示例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">3</span>, xSquared, xSquaredAgain;</span><br><span class="line">Functionobject square;</span><br><span class="line">xSquared = square(x);</span><br><span class="line">xSquaredAgain = square.doSquare (x);</span><br></pre></td></tr></table></figure></p>
<p>相比标准的对象方法，函数对象的好处很简单：<strong>这些对象有时可以伪装成函数指针，可将这些函数对象当成回调函数传给其他函数</strong>。</p>
<p>相比全局函数，函数对象的好处较为复杂。有两个主要好处：</p>
<ul>
<li>对象可在函数对象运算符的重复调用之间，在数据成员中保存信息。</li>
<li>可通过设置数据成员来自定义函数对象的行为。</li>
</ul>
<p>当然，通过全局变量或静态变量都可实现上述任何好处。然而，函数对象提供了一种更简洁的方式，而使用全局变量或静态变量在多线程应用程序中可能会产生问题。</p>
<p>函数调用运算符还可用于提供多维数组的下标。只要编写一个行为类似于<code>operator[]</code>，但接收多个索引的<code>operator()</code>即可。这项技术的唯一问题是需要使用<code>()</code>而不是<code>[]</code>进行索引，例如myArray(3,4)-6。</p>
<h2 id="重载解除引用运算符"><a href="#重载解除引用运算符" class="headerlink" title="重载解除引用运算符"></a>重载解除引用运算符</h2><p>可重载3个解除引用运算符：<code>*</code>、<code>-&gt;</code>和<code>-&gt;*</code>，只考虑<code>*</code>和<code>-&gt;</code>的原始意义。<code>*</code>解除对指针的引用，允许直接访问这个指针指向的值，<code>-&gt;</code>是使用<code>*</code>解除引用之后再执行成员选择操作的简写。</p>
<p>在类中重载解除引用运算符，可使这个类的对象行为和指针一致。这种功能的主要用途是实现智能指针。还能用于标准库广泛使用的迭代器。</p>
<h3 id="实现operator"><a href="#实现operator" class="headerlink" title="实现operator*"></a>实现operator*</h3><p>当解除对指针的引用时，经常希望能访问这个指针指向的内存：<code>operator*</code>应该返回一个引用：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; T&amp; Pointer&lt;T&gt;::<span class="keyword">operator</span>*() &#123;</span><br><span class="line">    <span class="keyword">return</span> *mPtr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; T&amp; Pointer&lt;T&gt;::<span class="keyword">operator</span>*() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> *mPtr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从这个例子可看出，<code>operator*</code>返回的是底层普通指针指向的对象或变量的引用。与重载下标运算符一样，同时提供方法的const版本和非const版本也很有用。</p>
<h3 id="实现operator-gt"><a href="#实现operator-gt" class="headerlink" title="实现operator-&gt;"></a>实现operator-&gt;</h3><p>箭头运算符稍微复杂一些。应用箭头运算符的结果应该是对象的成员或方法。为实现这一点，应该能够实现<code>operator*</code>和<code>operator</code>，而C++有充足的理由不允许重载<code>operator.</code>：不可能编写单个原型来捕捉任何可能选择的成员或方法。因此，C++将<code>operator-&gt;</code>当成一种特例。例如下面这行代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">smartCell-&gt;<span class="built_in">set</span>(<span class="number">5</span>);</span><br></pre></td></tr></table></figure></p>
<p>C++将这行代码解释为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(smartCell.<span class="keyword">operator</span>-&gt;())-&gt;<span class="built_in">set</span>(<span class="number">5</span>);</span><br></pre></td></tr></table></figure></p>
<p>从中可看出，C++给重载的<code>operator-&gt;</code>返回的任何结果应用了另一个<code>operator-&gt;</code>。因此，必须返回一个指向对象的指针，如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Pointer</span></span></span><br><span class="line"><span class="class"><span class="title">public</span>:</span></span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;();</span><br><span class="line">    <span class="keyword">const</span> T* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; T* Pointer&lt;T&gt;::<span class="keyword">operator</span>-&gt;() &#123;</span><br><span class="line">    <span class="keyword">return</span> mPtr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">const</span> T* Pointer&lt;T&gt;::<span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> mPtr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="operator-和operator-gt-的含义"><a href="#operator-和operator-gt-的含义" class="headerlink" title="operator.和operator-&gt;的含义"></a>operator.<em>和operator-&gt;</em>的含义</h3><p>在C++中，不能在没有对象的情况下访问非静态数据成员或调用非静态方法。通过指针调用方法或访问数据成员时，必须在对象的上下文中解除对指针的引用。下例演示了这点。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SpreadsheetCell myCell;</span><br><span class="line"><span class="keyword">double</span> (Spreadsheetcell::*methodPtr) () <span class="keyword">const</span> = &amp;SpreadsheetCell::getValue();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (mycell.*methodPtr) () &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p>
<p>注意，<code>.*</code>运算符解除对方法指针的引用并调用这个方法。如果有一个指向对象的指针而不是对象本身，那么还有一个等效的<code>operator-&gt;*</code>可通过指针调用方法。这个运算符如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SpreadsheetCell* myCell = <span class="keyword">new</span> SpreadsheetCell();</span><br><span class="line"><span class="keyword">double</span> (Spreadsheetcell::*methodPtr)() <span class="keyword">const</span> = &amp;spreadsheetCell::getValue;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (myCell-&gt;*methodPtr)() &lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p>
<h2 id="编写转换运算符"><a href="#编写转换运算符" class="headerlink" title="编写转换运算符"></a>编写转换运算符</h2><p>可编写一个将SpreadsheetCell转换为double类型的转换运算符。原型如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>函数名为<code>operator double</code>。它没有返回类型，因为返回类型是通过运算符的名称确定的：<code>double</code>。这个函数是const，因为这个函数不会修改被调用的对象。实现如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SpreadsheetCell::<span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> getValue(); &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="使用显式转换运算符解决多义性问题"><a href="#使用显式转换运算符解决多义性问题" class="headerlink" title="使用显式转换运算符解决多义性问题"></a>使用显式转换运算符解决多义性问题</h3><p>注意，为SpreadsheetCell对象编写double转换运算符时会引入多义性问题。例如下面这行加粗代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SpreadsheetCell <span class="title">cell</span><span class="params">(<span class="number">1.23</span>)</span></span>;</span><br><span class="line"><span class="keyword">double</span> d2 = cell + <span class="number">3.3</span>;</span><br></pre></td></tr></table></figure></p>
<p>现在这行代码无法成功编译。编译器不知道应该通过<code>operator double()</code>将cell对象转换为double类型，再执行double加法，还是通过double构造函数将3.3转换为SpreadsheetCell，再执行SpreadsheetCell加法。</p>
<p>在C++11之前，通常解决这个难题的方法是将构造函数标记为explicit，以避免使用这个构造函数进行自动转换。自C++11以后，可将double类型转换运算符标记为explicit以解决这个问题。下面的代码演示了这种方法的应用：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SpreadsheetCell cell = <span class="number">6.6</span>;</span><br><span class="line"><span class="keyword">double</span> d1 = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(cell);</span><br><span class="line"><span class="keyword">double</span> d2 = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(cell + <span class="number">3.3</span>);</span><br></pre></td></tr></table></figure></p>
<p>下面解释上述代码中的各行：</p>
<ol>
<li>使用隐式类型转换从double转换到SpreadsheetCell。由于是在声明中，因此这是通过调用接收double参数的构造函数进行的。</li>
<li>使用<code>operator double()</code>转换运算符。注意，由于这个转换运算符现在声明为explicit，因此要求进行强制类型转换。</li>
<li>通过隐式类型转换将3.3转换为SpreadsheetCell，再进行两个SpreadsheetCell对象的operator+操作，之后进行必要的显式类型转换以调用<code>operator double()</code>。</li>
</ol>
<h2 id="重载内存分配和内存释放运算符"><a href="#重载内存分配和内存释放运算符" class="headerlink" title="重载内存分配和内存释放运算符"></a>重载内存分配和内存释放运算符</h2><h3 id="new和delete的工作原理"><a href="#new和delete的工作原理" class="headerlink" title="new和delete的工作原理"></a>new和delete的工作原理</h3><p>考虑下面这行代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SpreadsheetCell* cell = <span class="keyword">new</span> SpreadsheetCell();</span><br></pre></td></tr></table></figure></p>
<p><code>new SpreadsheetCell()</code>这部分称为new表达式。它完成了两件事情。首先，通过调用<code>operator new</code>为SpreadsheetCell对象分配了空间。然后，为这个对象调用构造函数。只有这个构造函数完成了，才返回指针。</p>
<p>delete的工作方式与此类似。考虑下面这行代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> cell;</span><br></pre></td></tr></table></figure></p>
<p>这一行称为delete表达式。它首先调用cell的析构函数，然后调用<code>operator delete</code>来释放内存。可重载<code>operator new</code>和<code>operator delete</code>来控制内存的分配和释放，但不能重载new表达式和delete表达式。</p>
<h4 id="new表达式和operator-new"><a href="#new表达式和operator-new" class="headerlink" title="new表达式和operator new"></a>new表达式和operator new</h4><p>有6种不同形式的new表达式，每种形式都有对应的<code>operator new</code>。前面的章节已经展示了4种new表达式：<code>new</code>、<code>new[]</code>、<code>new(nothrow)</code>和<code>new(nothrow) []</code>。下面列出了<code>&lt;new&gt;</code>头文件中对应的4种<code>operator new</code>形式：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="keyword">size_t</span> size);</span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="keyword">nothrow_t</span>&amp;)</span><span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="keyword">size_t</span> size, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="keyword">nothrow_t</span>&amp;) <span class="keyword">noexcept</span>;</span><br></pre></td></tr></table></figure></p>
<p>有两种特殊的new表达式，它们不进行内存分配，而在已有存储段上调用构造函数。这种操作称为<code>placement new</code>运算符。它们在已有的内存中构造对象，如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span>* ptr = allocateMemorySomehow();</span><br><span class="line">spreadsheetCell* cell = <span class="keyword">new</span> (ptr) SpreadsheetCe11();</span><br></pre></td></tr></table></figure></p>
<p>这个特性有点儿偏门，但知道这项特性的存在非常重要。如果需要实现内存池，以便在不释放内存的情况下重用内存，这项特性就非常方便。对应的<code>operator new</code>形式如下，但C++标准禁止重载它们：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">void</span>* p)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="keyword">size_t</span> size, <span class="keyword">void</span>* p) <span class="keyword">noexcept</span>;</span><br></pre></td></tr></table></figure></p>
<h4 id="delete表达式和operator-delete"><a href="#delete表达式和operator-delete" class="headerlink" title="delete表达式和operator delete"></a>delete表达式和operator delete</h4><p>只可调用两种不同形式的delete表达式：<code>delete</code>和<code>delete[]</code>，没有nothrow和placement形式。然而，<code>operator delete</code>有6种形式，nothrow和placement形式只有在构造函数抛出异常时才会使用。</p>
<p>这种情况下，匹配调用构造函数之前分配内存时使用的<code>operator new</code>的<code>operator delete</code>会被调用。然而，如果正常地删除指针，delete会调用<code>operator delete</code>或<code>operator delete[]</code>，绝不会调用nothrow或placement形式。C++标准指出，从delete抛出异常的行为是未定义的。也就是说，delete永远都不应该抛出异常。因此nothrow版本的<code>operator delete</code>是多余的；而placement版本的delete应该是一个空操作，因为在<code>placement new</code>中并没有分配内存，因此也不需要释放内存。</p>
<p>更有用的技术是重载特定类的<code>operator new</code>和<code>operator delete</code>。仅当分配或释放特定类的对象时，才会调用这些重载的运算符。下面这个类重载了4个非placement形式的<code>operator new</code>和<code>operator delete</code>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MemoryDemo</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(voId* ptr)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">    <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="keyword">size_t</span> size);</span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="keyword">void</span>* ptr) <span class="keyword">noexcept</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="keyword">nothrow_t</span>&amp;)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* ptr, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="keyword">nothrow_t</span>&amp;)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">    <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="keyword">size_t</span> size, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="keyword">nothrow_t</span>&amp;) <span class="keyword">noexcept</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="keyword">void</span>* ptr, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="keyword">nothrow_t</span>&amp;) <span class="keyword">noexcept</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>当重载<code>operator new</code>时，要重载对应形式的<code>operator delete</code>。否则，内存会根据指定的方式分配，但是根据内建的语义释放，这两者可能不兼容。</p>
<h3 id="显式地删除-默认化operator-new和operator-delete"><a href="#显式地删除-默认化operator-new和operator-delete" class="headerlink" title="显式地删除/默认化operator new和operator delete"></a>显式地删除/默认化operator new和operator delete</h3><p>下面的类删除了<code>operator new</code>和<code>new[]</code>。也就是说，这个类不能通过<code>new</code>或<code>new[]</code>动态创建：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span>*<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>= <span class="keyword">delete</span>;</span><br><span class="line">    <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="keyword">size_t</span> size) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="重载带有额外参数的operator-new和operator-delete"><a href="#重载带有额外参数的operator-new和operator-delete" class="headerlink" title="重载带有额外参数的operator new和operator delete"></a>重载带有额外参数的operator new和operator delete</h3><p>除了重载标准形式的<code>operator new</code>外，还可编写带额外参数的版本。这些额外参数可用于向内存分配例程传递各种标志或计数器。例如，一些运行时库在调试模式中使用这种形式。下面是MemoryDemo类中带有额外整数参数的<code>operator new</code>和<code>operator delete</code>原型：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">int</span> extra)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* ptr, <span class="keyword">int</span> extra)</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>编写带有额外参数的重载<code>operator new</code>时，编译器会自动允许编写对应的new表达式。new的额外参数以函数调用的语法传递。因此，可编写这样的代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MemoryDemo* memp = <span class="keyword">new</span> (<span class="number">5</span>) MemoryDemo();</span><br><span class="line"><span class="keyword">delete</span> memp;</span><br></pre></td></tr></table></figure></p>
<p>定义带有额外参数的<code>operator new</code>时，还应该定义带有额外参数的对应<code>operator delete</code>。不能自己调用这个带有额外参数的<code>operator delete</code>，只有在使用了带有额外参数的<code>operator new</code>且对象的构造函数抛出异常时，才调用这个<code>operator delete</code>。</p>
<h1 id="C-标准库概述"><a href="#C-标准库概述" class="headerlink" title="C++标准库概述"></a>C++标准库概述</h1><h2 id="编码原则"><a href="#编码原则" class="headerlink" title="编码原则"></a>编码原则</h2><ul>
<li><strong>使用模板</strong>：模板用于实现泛型编程。通过模板，才能编写适用于所有类型对象的代码，模板甚至可用于编写代码时未知的对象。</li>
<li><strong>使用运算符重载</strong>：C++标准库大量使用了运算符重载。</li>
</ul>
<h2 id="C-标准库概述-1"><a href="#C-标准库概述-1" class="headerlink" title="C++标准库概述"></a>C++标准库概述</h2><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>C++在<code>&lt;string&gt;</code>头文件提供内建的string类，处理内存管理：提供一些边界检查、赋值语义以及比较操作；还支持些操作，例如串联、子字符串提取以及子字符串或字符的替换。</p>
<blockquote>
<p>从技术角度看，<code>std::string</code>是对<code>std::basic_string</code>模板进行char实例化的类型别名。</p>
</blockquote>
<p>标准库还提供在<code>&lt;string_view&gt;</code>中定义的<code>string_view</code>类。这是各类字符串表示的只读视图，可用于简单替换<code>const string&amp;</code>，而且不会带来开销。它从不复制字符串!</p>
<h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p><code>&lt;regex&gt;</code>头文件提供了正则表达式。正则表达式简化了文本处理中常用的模式匹配任务。通过模式匹配可在字符串中搜索特定的模式，还能酌情将搜索到的模式替换为新模式。</p>
<h3 id="I-0流"><a href="#I-0流" class="headerlink" title="I/0流"></a>I/0流</h3><p>C++引入了一种新的使用流的输入输出模型。IO功能在如下几个头文件中定义：<code>&lt;fstream&gt;</code>、<br><code>&lt;iomanip&gt;</code>、<code>&lt;ios&gt;</code>、<code>&lt;iosfwd&gt;</code>、<code>&lt;iostream&gt;</code>、 <code>&lt;istream&gt;</code>、<code>&lt;ostream&gt;</code>、<code>&lt;sstream&gt;</code>、<code>&lt;streambuf&gt;</code>和<code>&lt;strstream&gt;</code>。</p>
<h3 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h3><ul>
<li>第一个问题是根本没有删除对象(没有释放存储)。这称为内存泄漏。</li>
<li>另一个问题是一段代码删除了存储，而另一段代码仍然引用了这个存储，导致指向那个存储的指针不再可用或已重新分配用作他用，这称为悬挂指针(dangling pointer)。</li>
<li>还有一个问题是一段代码释放了一块存储，而另一段代码试图释放同一块存储。这称为双重释放(doublefreeing)。</li>
</ul>
<p>所有这些问题都会导致程序发生某种故障。C++用智能指针<code>unique_ptr</code>、<code>shared_ptr</code>和<code>week_ptr</code>解决了这些问题。<code>shared_ptr</code>和<code>week_ptr</code>是线程安全的，在<code>&lt;memory&gt;</code>头文件中定义。</p>
<p>在C++11之前，<code>unique_ptr</code>的功能由名为<code>auto_ptr</code>的类型完成，C++17废弃了<code>auto_ptr</code>，不应再使用这种类型。</p>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>C++语言支持异常，函数和方法能通过异常将不同类型的错误向上传递至调用的函数或方法。异常支持在如下几个头文件中定义：<code>&lt;exception&gt;</code>、<code>&lt;stdexcept&gt;</code>和<code>&lt;system_error&gt;</code>。</p>
<h3 id="数学工具"><a href="#数学工具" class="headerlink" title="数学工具"></a>数学工具</h3><p>C++有完整且常见的数学函数可供使用，C++17增加了大量的特殊数学函数，处理勒让德多项式、B函数、椭圆积分、贝塞尔函数、柱函数和诺伊曼函数等。</p>
<p>标准库在<code>&lt;complex&gt;</code>头文件中提供了一个复数类，名为<code>complex</code>，这个类提供了对包含实部和虚部的复数的操作抽象。</p>
<p>标准库还在<code>&lt;valarray&gt;</code>头文件中包含一个<code>valarray</code>类，这个类和vector类相似，但对高性能数值应用做了特别优化。这个库提供了一些表示矢量切片概念的相关类。通过这些构件，可构建执行矩阵数学运算的类。</p>
<p>C++还提供了一种获取数值极限的标准方式，例如当前平台允许的整数的最大值。在C语言中，可以通过访问<code>#define</code>来获得这些信息，例如<code>INT_MAX</code>。尽管在C++中仍可使用这种方法，但建议使用定义在<code>&lt;limits&gt;</code>头文件中的<code>numeric_limits</code>类模板：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt;<span class="string">"Max int value:"</span> &lt;&lt;numeric_limits&lt;<span class="keyword">int</span>&gt;::max() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;<span class="string">"Min int value:"</span> &lt;&lt;numeric_limits&lt;<span class="keyword">int</span>&gt;::min() &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p>
<p>注意<code>min()</code>和<code>lowest()</code>之间的差异：</p>
<ul>
<li>对于整数而言，min值等于lowest值。</li>
<li>对于浮点类型而言，min值等于可表示的最小正值，而lowest值等于可表示的最大负值，即<code>-max()</code>。</li>
</ul>
<h3 id="时间工具"><a href="#时间工具" class="headerlink" title="时间工具"></a>时间工具</h3><p>C++在<code>&lt;chrono&gt;</code>头文件中包含了<code>Chrono</code>库。这个库简化了与时间相关的操作，例如特定时间间隔的定时操作和定时相关的操作。</p>
<h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p>标准库中的所有容器都是类模板，因此可通过这些容器保存任意类型的数据，从内建的int和double等类型到自定义的类。每个容器实例都只能保存一种类型的对象，也就是说，这些容器都是同构集合。如果需要大小可变的异构集合，可将每个元素包装在<code>std:any</code>实例中，并将这些实例存储在容器中。另外，可在容器中存储<code>std:variant</code>实例。</p>
<h4 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h4><p><code>&lt;vector&gt;</code>头文件定义了vector，vector保存了元素序列，提供对这些元素的随机访问。与数组一样，vector中的元素保存在连续内存中。</p>
<p>vector能够在vector尾部快速地插入和删除元素(摊还常量时间，amortized constant time)。摊还常量时间指的是<strong>大部分插入操作都是在常量时间内完成的</strong>。然而，有时vector需要增长大小以容纳新元素，此时的复杂度为O(N)。这个结果的平均复杂度为0(1)，或称为摊还常量时间。</p>
<p>vector其他部位的插入和删除操作比较慢(线性时间)，因为这种操作必须将所有元素向上或向下挪动一个位置，为新元素腾出空间，或填充删除元素后留下的空间。与数组一样，vector提供对任意元素的快速访问。</p>
<p>对于在<code>vector&lt;bool&gt;</code>中保存布尔值有一个专门的模板。这个特制模板特别对布尔元素进行空间分配的优化，然而标准并未规定<code>vector&lt;bool&gt;</code>的实现应该如何优化空间。<code>vector&lt;bool&gt;</code>和本章后面要讨论的bitset之间的区别在于，bitset容器的大小是固定的。</p>
<h4 id="list"><a href="#list" class="headerlink" title="list"></a>list</h4><p>标准库list是一种双向链表数据结构，在<code>&lt;list&gt;</code>中定义。与数组和vector一样，list保存了元素的序列。然而，与数组或vector的不同之处在于，list中的元素不一定保存在连续内存中。相反，list中的每个元素都指定了如何在list中找到前一个和后一个元素，所以得名双向链表。</p>
<p>list的性能特征和vector完全相反。list提供较慢的元素查找和访问(线性时间)，而找到相应的位置之后，元素的插入和删除却很快(常量时间)。然而，vector通常比list更快。可使用性能分析器确认这一点。</p>
<h4 id="forward-list"><a href="#forward-list" class="headerlink" title="forward_list"></a>forward_list</h4><p><code>&lt;forward_list&gt;</code>中定义的<code>forward_list</code>是一种单向链表，而list容器是双向链表。<code>forward_list</code>只支持前向迭代，需要的内存比list少。与list类似，一旦找到相关位置， <code>forward_list</code>允许在任何位置执行插入和删除操作(常量时间)；与list一样，不能快速地随机访问元素，</p>
<h4 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h4><p>deque是双头队列(double-ended queue)的简称。deque在<code>&lt;deque&gt;</code>中定义，能实现快速的元素访问(常量时间)。在序列的两端还实现了快速插入和删除(摊还常量时间)，但在序列中间插入和删除的速度较慢线性时间)，deque中的元素在内存中的存储不连续，速度可能比vector慢，如果需要在序列两头快速插入或删除元素，还要求快速访问所有元素，那么应该使用deque而不是vector。</p>
<h4 id="array"><a href="#array" class="headerlink" title="array"></a>array</h4><p><code>&lt;array&gt;</code>头文件定义了array，这是标准C风格数组的替代品。有时可事先知道容器中元素的确切数量，因此不需要vector或list提供的灵活性，。array特别适用于大小固定的集合，而且没有vector的开销。</p>
<p>使用array有几点好处：</p>
<ul>
<li>array总能知道自己的大小；</li>
<li>不会自动转换为指针类型，从而避免了某些类型的bug。</li>
</ul>
<p>array没有提供插入和删除操作，但大小固定。大小固定的优点是，允许array在堆栈上分配内存，而不总是像vector那样需要堆访问权限。与vector一样，对元素的访问速度极快(常量时间)。</p>
<h4 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h4><p>queue容器在<code>&lt;queue&gt;</code>中定义，提供标准的先入先出语义。在使用queue容器时，从一端插入元素，从另一端取出元素。插入元素(摊还常量时间)和删除元素(常量时间)的操作都很快。</p>
<h4 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h4><p>priority_queue也在<code>&lt;queue&gt;</code>中定义，提供与queue相同的功能，但其中的每个元素都有优先级。元素按优先顺序从队列中移除。在优先级相同的情况下，删除元素的顺序没有定义。对prionity_queue的插入和删除一般比简单的队列插入和删除要慢，因为只有对元素重排序，才能支持优先级。</p>
<h4 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h4><p><code>&lt;stack&gt;</code>头文件定义了stack，它提供标准的先入后出。在堆栈中，最新插入的元素第一个被移除。stack容器实现了元素的快速插入和删除(常量时间)。</p>
<h4 id="set和multiset"><a href="#set和multiset" class="headerlink" title="set和multiset"></a>set和multiset</h4><p>set类模板在<code>&lt;set&gt;</code>头文件中定义。顾名思义，标准库中的set保存的是元素的集合：每个元素都是唯一的，在集合中每个元素最多只有一个实例。标准库中的set和数学中集合的概念有一点区别：在标准库中，元素按照一定的顺序保存。set提供对数时间的插入、删除和查找操作。这意味着插入和删除操作比vector快，但比list慢。查找操作比list块，但比vector慢。</p>
<blockquote>
<p>如果需要保持顺序，而且要求插入，删除和查找操作的性能接近，那么应当优先使用set而不是vector或list。如果严禁出现重复元素，也应当使用set。</p>
</blockquote>
<p>注意，set不允许重复元素。也就是说，set中的每个元素都必须唯一。如果要存储重复元素，必须使用<code>&lt;set&gt;</code>头文件中定义的multiset。</p>
<h4 id="map和multimap"><a href="#map和multimap" class="headerlink" title="map和multimap"></a>map和multimap</h4><p><code>&lt;map&gt;</code>头文件定义了map类模板，这是一个关联数组。可将其用作数组，其中的索引可以是任意类型，如string。map保存的是键/值对。map按顺序保存元素，排序的依据是键值而非对象值。它还提供<code>operator[]</code>。如果需要关联键和值，就应该使用map。</p>
<p>multimap也在<code>&lt;map&gt;</code>头文件中定义，它和map的关系等同于multiset和set的关系。确切地讲，multimap是允许重复键的map。</p>
<h4 id="无序关联容器-哈希表"><a href="#无序关联容器-哈希表" class="headerlink" title="无序关联容器/哈希表"></a>无序关联容器/哈希表</h4><p>标准库支持哈希表(hash table)，哈希表也称为无序关联容器(unordered associative container)。有4个无序关联容器：</p>
<ul>
<li>unordered map</li>
<li>unordered_multimap</li>
<li>unordered_set</li>
<li>unordered multiset</li>
</ul>
<p>前两个在<code>&lt;unordered_map&gt;</code>中定义，后两个在<code>&lt;unordered_set&gt;</code>中定义。更贴切的名字应该是<code>hash_map</code>和<code>hash_set</code>等。</p>
<p>这些无序关联容器的插入、删除和查找操作能以平均常量时间完成。最坏情况是线性时间。在无序的容器中查找元素的速度比普通map或set中的查找速度快得多。</p>
<h4 id="bitset"><a href="#bitset" class="headerlink" title="bitset"></a>bitset</h4><p>bitset类抽象了位操作。<code>&lt;bitset&gt;</code>头文件定义了bitset容器，但没有实现某种特定的可插入或删除元素的数据结构；bitset有固定大小，不支持迭代器。可将bitset想象为可以读写的布尔值序列。</p>
<p>bitset不局限于int或其他基本数据类型的大小。因此，能操作40位的bitset，也能操作213位的bitset。bitset的实现会使用实现N个位所需的足够存储空间，通过<code>bitset&lt;N&gt;</code>声明bitset时指定N。</p>
<h4 id="标准库容器小结"><a href="#标准库容器小结" class="headerlink" title="标准库容器小结"></a>标准库容器小结</h4><p>表16-1总结了标准库提供的容器。<br><img src="/img/1619926098.jpg" alt><br><img src="/img/1619926131.jpg" alt></p>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>除容器外，标准库还提供了很多泛型算法的实现。算法指的是执行某项任务时采取的策略，例如排序任务和搜索任务。这些算法也是用函数模板实现的，因此可用于大部分不同类型的容器。<br><img src="/img/1619926262.jpg" alt></p>
<blockquote>
<p>迭代器是算法和容器之间的中介。选代器提供了顺序遍历容器中元素的标准接口，因此任何算法都可以操作任何容器。</p>
</blockquote>
<p>标准库中大约有100种算法，下面将这些算法分为不同的类别。除非特别说明，否则这些算法都在<code>&lt;algorithm&gt;</code>头文件中定义。</p>
<h4 id="非修改顺序算法"><a href="#非修改顺序算法" class="headerlink" title="非修改顺序算法"></a>非修改顺序算法</h4><p>非修改类的算法查找元素的序列，返回一些有关元素的信息。因为是非修改类的算法，所以这些算法不会改变序列中元素的值或顺序。<br><img src="/img/1619926380.jpg" alt></p>
<p>从C++17开始，search0接收一个可选的附加参数，以指定要使用的搜索算法(default_searcher、boyer_moore_searcher或boyer_moore_horspool_searcher)，使用boyer_moore搜索算法，最坏情况下，模式未找到时的复杂度是O(N+M)，模式找到时的复杂度为O(NM)。</p>
<p>标准库提供了表16-4中列出的比较算法。这些算法都不要求排序源序列。所有算法的最差复杂度都为线性复杂度<br><img src="/img/1619926439.jpg" alt></p>
<p>计数算法如表16-5所示。<br><img src="/img/1619926474.jpg" alt></p>
<h4 id="修改序列算法"><a href="#修改序列算法" class="headerlink" title="修改序列算法"></a>修改序列算法</h4><p>修改算法会修改序列中的一些元素或所有元素。有些修改算法在原位置修改元素，因此原始序列发生变化。另一些修改算法将结果复制到另一个不同的序列，所以原始序列没有变化。所有这些修改算法的最坏复杂度都为线性复杂度。表16-6汇总了这些修改算法。<br><img src="/img/1619927358.jpg" alt></p>
<h4 id="操作算法"><a href="#操作算法" class="headerlink" title="操作算法"></a>操作算法</h4><p>操作算法在单独的元素序列上执行函数。C++标准库提供了两种操作算法，如表16-7所示。它们的复杂度都是线性复杂度，不要求对原始序列进行排序。<br><img src="/img/1619927511.jpg" alt></p>
<h4 id="交换算法"><a href="#交换算法" class="headerlink" title="交换算法"></a>交换算法</h4><p>C++标准库提供如表16-8所示的交换算法。<br><img src="/img/1619927550.jpg" alt></p>
<h4 id="分区算法"><a href="#分区算法" class="headerlink" title="分区算法"></a>分区算法</h4><p>如果谓词返回true的所有元素都在谓词返回false的所有元素的前面，则按某个谓词对序列进行分区。序列中不满足谓词的第一个元素称为分区点(partition point)。C++标准库提供如表16-9所示的分区算法。<br><img src="/img/1619927625.jpg" alt></p>
<h4 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h4><p>C++标准库提供了一些不同的排序算法，不同的排序算法有不同的性能保证，如表16-10所示。<br><img src="/img/1619927652.jpg" alt></p>
<h4 id="二叉树搜索算法"><a href="#二叉树搜索算法" class="headerlink" title="二叉树搜索算法"></a>二叉树搜索算法</h4><p>下面的二叉树搜索算法通常用于已排序的序列。排好序的序列也满足这个要求。所有这些算法都具有对数复杂度。<br><img src="/img/1619927695.jpg" alt></p>
<h4 id="集合算法"><a href="#集合算法" class="headerlink" title="集合算法"></a>集合算法</h4><p>集合算法是特殊的修改算法，对序列执行集合操作，如表16-12所示。这些算法最适合操作set容器的序列，但也能操作大部分容器的排序后序列。<br><img src="/img/1619927735.jpg" alt></p>
<h4 id="堆算法"><a href="#堆算法" class="headerlink" title="堆算法"></a>堆算法</h4><p>堆(heap)是一种标准的数据结构，数组或序列中的元素在其中以半排序的方式排序，因此能够快速找到“顶部”元素。<br><img src="/img/1619927755.jpg" alt></p>
<h4 id="最大-最小算法"><a href="#最大-最小算法" class="headerlink" title="最大/最小算法"></a>最大/最小算法</h4><p><img src="/img/1619927803.jpg" alt></p>
<h4 id="数值处理算法"><a href="#数值处理算法" class="headerlink" title="数值处理算法"></a>数值处理算法</h4><p><code>&lt;numeric&gt;</code>头文件提供了下述数值处理算法。这些算法都不要求排序原始序列。所有算法的复杂度都为线性复杂度，如表16-15所示。<br><img src="/img/1619927862.jpg" alt></p>
<h4 id="置换算法"><a href="#置换算法" class="headerlink" title="置换算法"></a>置换算法</h4><p>序列的置换包含相同的元素，但顺序变了。表16-16列出了用于置换的算法。<br><img src="/img/1619927898.jpg" alt></p>
<h1 id="理解容器与迭代器"><a href="#理解容器与迭代器" class="headerlink" title="理解容器与迭代器"></a>理解容器与迭代器</h1><h2 id="容器概述"><a href="#容器概述" class="headerlink" title="容器概述"></a>容器概述</h2><p>标准库提供了16个容器，分为4大类。</p>
<ul>
<li>顺序容器<ul>
<li>vector(动态数组)</li>
<li>deque</li>
<li>list</li>
<li>forward_list</li>
<li>array</li>
</ul>
</li>
<li>关联容器<ul>
<li>map</li>
<li>multimap</li>
<li>set</li>
<li>multiset</li>
</ul>
</li>
<li>无序关联容器或哈希表<ul>
<li>unordered_map</li>
<li>unordered_multimap</li>
<li>unordered_set</li>
<li>unordered_multiset</li>
</ul>
</li>
<li>容器适配器<ul>
<li>queue</li>
<li>priority_queue</li>
<li>stack</li>
</ul>
</li>
</ul>
<p>此外，C++的string和流也可在某种程度上用作标准库容器，bitset可以用于存储固定数目的位。</p>
<h3 id="对元素的要求"><a href="#对元素的要求" class="headerlink" title="对元素的要求"></a>对元素的要求</h3><p>标准库容器对元素使用值语义(value semantic)。也就是说，<strong>在输入元素时保存元素的一份副本</strong>，通过赋值运算符给元素赋值，通过析构函数销毁元素。因此，编写要用于标准库的类时，一定要保证它们是可以复制的。请求容器中的元素时，会返回所存副本的引用。</p>
<p>如果喜欢引用语义，可存储元素的指针而非元素本身。当容器复制指针时，结果仍然指向同一元素。另一种方式是在容器中存储<code>std::reference_wrapper</code>。可使用<code>std::ref()</code>或<code>std::cref()</code>创建<code>reference_wrapper</code>，使引用变得可以复制。<code>reference_wrapper</code>类模板以及<code>ref()</code>和<code>cref()</code>函数模板在<code>&lt;functional&gt;</code>头文件中定义。</p>
<p>在容器中，可能存储“仅移动”类型，这是非可复制类型，但当这么做时，容器上的一些操作可能无法编译。“仅移动”类型的一个例子是<code>std::unique_ptr</code>。</p>
<p>标准库容器的一个模板类型参数是所谓的分配器(allocator)。标准库容器可使用分配器为元素分配或释放内存。分配器类型参数具有默认值，因此几乎总是可以忽略它。</p>
<p>有关使用默认内存分配器和比较器的容器中元素的特别需求在表17-1中列出。<br><img src="/img/1619928233.jpg" alt></p>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>标准库通过迭代器模式提供了访问容器元素使用的泛型抽象。每个容器都提供了容器特定的迭代器，迭代器实际上是增强版的智能指针，这种指针知道如何遍历特定容器的元素。可将迭代器想象为指向容器中特定元素的指针。与指向数组元素的指针一样，迭代器可以通过<code>operator++</code>移到下一个元素。C++标准定义了5大类迭代器，如表17-2所示。<br><img src="/img/1619928319.jpg" alt></p>
<p>另外，满足输出迭代器要求的迭代器称为“可变迭代器”，否则称为“不变迭代器”。还可使用<code>std::distance()</code>计算容器的两个迭代器之间的距离。迭代器的实现类似于智能指针类，因为它们都重载了特定的运算符。</p>
<p>基本的迭代器操作类似于普通指针(dumb pointer)支持的操作，因此普通指针可以合法用作特定容器的迭代器。事实上，vector选代器在技术上就是通过简单的普通指针实现的。</p>
<p>标准库中每个支持迭代器的容器类都为其选代器类型提供了公共类型别名，名为<code>iterator</code>和<code>const_iterator</code>。允许反向迭代元素的容器还提供了名为<code>reverse_iterator</code>和<code>const_reverse_iterator</code>的公共类型别名。通过这种方式，客户使用容器迭代器时不需要关心实际类型。</p>
<blockquote>
<p><code>const_iterator</code>和<code>const_reverse_iterator</code>提供对容器元素的只读访问。</p>
</blockquote>
<p>容器还提供了<code>begin()</code>和<code>end()</code>方法。<code>begin()</code>方法返回引用容器中第一个元素的迭代器，<code>end()</code>方法返回的选代器等于在引用序列中最后一个元素的选代器上执行<code>operator++</code>后的结果。<code>begin()</code>和<code>end()</code>一起提供了一个半开区间，包含第一个元素但不包含最后一个元素。采用这种看似复杂方式的原因是为了支持空区间(不包含任何元素的容器)，此时<code>begin()</code>等于<code>end()</code>。</p>
<p>与此类似，还有：</p>
<ul>
<li>返回const迭代器的<code>cbegin()</code>和<code>cend()</code>方法</li>
<li>返回反向选代器的<code>rbegin()</code>和<code>rend()</code>方法</li>
<li>返回const反向选代器的<code>crbegin()</code>和<code>crend()</code>方法</li>
</ul>
<h2 id="顺序容器"><a href="#顺序容器" class="headerlink" title="顺序容器"></a>顺序容器</h2><h3 id="vector-1"><a href="#vector-1" class="headerlink" title="vector"></a>vector</h3><p>可以在vector中建立索引，还可以在尾部或任何位置添加新的元素。向vector插入元素或从vector删除元素通常需要线性时间，但这些操作在vector尾部执行时，实际运行时间为摊还常量时间。</p>
<h4 id="vector概述"><a href="#vector概述" class="headerlink" title="vector概述"></a>vector概述</h4><p>vector在<code>&lt;vector&gt;</code>头文件中被定义为一个带有两个类型参数的类模板：一个参数为要保存的元素类型，另一个参数为分配器(allocator)类型<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Allocator</span> = <span class="title">allocator</span>&lt;T&gt;&gt; <span class="title">class</span> <span class="title">vector</span>;</span></span><br></pre></td></tr></table></figure></p>
<p>Allocator参数指定了内存分配器对象的类型， 客户可设置内存分配器，以便使用自定义的内存分配器。这个模板参数具有默认值。</p>
<blockquote>
<p>Allocator类型参数的默认值足够大部分应用程序使用。</p>
</blockquote>
<h4 id="固定长度的vector"><a href="#固定长度的vector" class="headerlink" title="固定长度的vector"></a>固定长度的vector</h4><p>使用vector的最简单方式是将其用作固定长度的数组。vector提供了一个可以指定元素数量的构造函数，还提供了一个重载的<code>operator[]</code>以便访问和修改这些元素。C++标准指出：通过<code>operator[]</code>访问vector边界之外的元素时，得到的结果是未定义的。</p>
<p>除使用<code>operator[]</code>运算符外，还可通过<code>at()</code>、<code>front()</code>和<code>back()</code>访问vector元素。<code>at()</code>方法等同于<code>operator[]</code>运算符，区别在于<code>at()</code>会执行边界检查，如果索引超出边界，<code>at()</code>会抛出<code>out_of_range</code>异常。<code>front()</code>和<code>back()</code>分别返回vector的第一个元素和最后一个元素的引用。</p>
<p>对vector应用<code>operator[]</code>运算符通常会返回一个对元素的引用，可将这个引用放在赋值语句的左侧。如果对<code>const vector</code>对象应用<code>operator[]</code>运算符，就会返回一个对const元素的引用，这个引用不能用作赋值的目标。</p>
<h4 id="动态长度的vector"><a href="#动态长度的vector" class="headerlink" title="动态长度的vector"></a>动态长度的vector</h4><p>vector的真正强大之处在于动态增长的能力。<code>push_back()</code>方法能为新元素分配空间。基于区间的for循环不需要做任何修改。</p>
<h4 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h4><p>默认的构造函数创建一个不包含元素的vector。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; intVector;</span><br></pre></td></tr></table></figure></p>
<p>可指定元素个数，还可指定这些元素的值，如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; intVector(<span class="number">10</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure></p>
<p>如果没有提供默认值，那么对新对象进行0初始化。0初始化通过默认构造函数构建对象。</p>
<p>可以使用包含初始元素的<code>initializer_list</code>构建vector：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; intVector(&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> ));</span><br></pre></td></tr></table></figure></p>
<p><code>initializer_list</code>还可以用于第1章提到的统一初始化。统一初始化可用于大部分标准库容器。例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; intVector1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; intVector2&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">还可以在堆上分配<span class="built_in">vector</span>:</span><br><span class="line">```C++</span><br><span class="line"><span class="keyword">auto</span> elementVector = make_unique&lt;<span class="built_in">vector</span>&lt;Element&gt;&gt;(<span class="number">10</span>);</span><br></pre></td></tr></table></figure></p>
<h4 id="vector的复制和赋值"><a href="#vector的复制和赋值" class="headerlink" title="vector的复制和赋值"></a>vector的复制和赋值</h4><p>vector存储对象的副本，其析构函数调用每个对象的析构函数。vector类的复制构造函数和赋值运算符对vector中的所有元素执行深度复制。因此，出于效率方面的考虑，应该通过引用或const引用向函数和方法传递vector。</p>
<p>除普通的复制和赋值外，vector还提供了<code>assign()</code>方法，这个方法删除所有现有的元素，并添加任意数目的新元素。这个方法特别适合于vector的重用。下面是一个简单的例子。intVector包含10个默认值为0的元素。然后通过<code>assign()</code>删除所有10个元素，并以5个值为100的元素代之。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; intVector(<span class="number">10</span>);</span><br><span class="line">intVector.assign(<span class="number">5</span>,<span class="number">100</span>);</span><br></pre></td></tr></table></figure></p>
<p>如下所示，<code>assign()</code>还可接收<code>initializer_list</code>。intVector现在有4个具有给定值的元素。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">intVector.assign(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;);</span><br></pre></td></tr></table></figure></p>
<p>vector还提供了<code>swap()</code>方法，这个方法可交换两个vector的内容，并且具有常量时间复杂度。下面举一个简单示例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vectorOne(<span class="number">10</span>);</span><br><span class="line">vectorcint&gt; vectorTwo(<span class="number">5</span>, <span class="number">100</span>);</span><br><span class="line">vectorOne.swap (vectorTwo);</span><br></pre></td></tr></table></figure></p>
<h4 id="vector的比较"><a href="#vector的比较" class="headerlink" title="vector的比较"></a>vector的比较</h4><p>标准库在vector中提供了6个重载的比较运算符：<code>==</code>、<code>!=</code>、<code>&lt;</code>、<code>&gt;</code>、<code>&lt;=</code>和<code>&gt;=</code>。如果两个vector的元素数量相等，而且对应元素都相等，那么这两个vector相等。两个vector的比较采用字典顺序：如果第一个vector中从0到i-1的所有元素都等于第二个vector中从0到i-1的所有元素，但第一个vector中的元素i小于第二个vector中的元素i，其中i在0到n之间，且n必须小于size()，那么第一个vector“小于”第二个vector。</p>
<p>通过<code>operator==</code>和<code>operator!=</code>比较两个vector时，要求每个元素都能通过<code>operator==</code>运算符进行比较。通过</p>
<h4 id="vector迭代器"><a href="#vector迭代器" class="headerlink" title="vector迭代器"></a>vector迭代器</h4><p>首先，看一下for循环的初始化语句：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;::iterator iter = begin (doubleVector);</span><br></pre></td></tr></table></figure></p>
<p><code>begin()</code>返回引用容器中第一个元素的相应类型的迭代器。因此，这条初始化语句在iter变量中获取了引用doubleVector中第一个元素的迭代器。下面看一下for循环的比较语句：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iter != end(doubleVector);</span><br></pre></td></tr></table></figure></p>
<p>这条语句检查迭代器是否超越了vector中元素序列的尾部。当到达这一点时，循环终止。递增语句<code>++iter</code>递增迭代器，以引用vector中的下一个元素。</p>
<blockquote>
<p>只要可能，尽量使用前递增而不要使用后递增，因为前递增至少效率不会差，一般更高效。<code>iter++</code>必须返回一个新的选代器对象，而<code>++iter</code>只是返回对iter的引用。</p>
</blockquote>
<p>上述使用迭代器的for循环可通过auto关键字简化：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> iter = begin(doubleVector); iter != end(doubleVector); ++iter)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *iter &lt;&lt; <span class="string">" "</span>;</span><br></pre></td></tr></table></figure></p>
<h4 id="访问对象元素中的字段"><a href="#访问对象元素中的字段" class="headerlink" title="访问对象元素中的字段"></a>访问对象元素中的字段</h4><p>如果容器中的元素是对象，那么可对迭代器使用<code>-&gt;</code>运算符，调用对象的方法或访问对象的成员。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; stringVector(<span class="number">10</span>, <span class="string">"hello"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = begin(stringVector); it!= end(stringVector); ++ it) </span><br><span class="line">    it-&gt;append(<span class="string">" there"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用基于区间的for循环，这段代码可以重写为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; stringVector(<span class="number">10</span>, <span class="string">"hello"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; str : stringVector) </span><br><span class="line">    str.append(<span class="string">"there"</span>);</span><br></pre></td></tr></table></figure></p>
<h4 id="const-iterator"><a href="#const-iterator" class="headerlink" title="const_iterator"></a>const_iterator</h4><p>const_iterator是只读的，不能通过const_iterator修改元素。iterator始终可以转换为const_iterator，因此下面这种写法是安全的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;type&gt;::const_iterator it = begin (myVector);</span><br></pre></td></tr></table></figure></p>
<p>然而，const_iterator不能转换为iterator。如果myVector是const_iterator，那么下面这行代码无法编译：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;type&gt;::iterator it = begin (myVector);</span><br><span class="line"></span><br><span class="line">在使用<span class="keyword">auto</span>关键字时，const_iterator的使用看上去有一点区别。假设有以下代码：</span><br><span class="line">```C++</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; stringVector(<span class="number">10</span>, <span class="string">"hello"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> iter = begin(stringVector); iter != end(stringVector); ++iter)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *iter &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p>
<p>由于使用了auto关键字，编译器会自动判定iter变量的类型，然后将其设置为普通的iterator，因为stringVector不是const_iterator。如果需要结合auto使用只读的const_iterator，那么需要使用<code>cbegin()</code>和<code>cend()</code>，而不是<code>begin()</code>和<code>end()</code>，如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; stringVector(<span class="number">10</span>, <span class="string">"hello"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> iter = cbegin(stringVector); iter != cend(stringVector); ++iter)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *iter &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p>
<p>现在编译器会将iter变量的类型设置为const_iterator，因为<code>cbegin()</code>返回的就是const_iterator。</p>
<p>基于区间的for循环也可用于强制使用const_ iterator，如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; stringVector(<span class="number">10</span>, <span class="string">"hello"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; element : stringVector)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; element &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p>
<h4 id="迭代器还是索引"><a href="#迭代器还是索引" class="headerlink" title="迭代器还是索引?"></a>迭代器还是索引?</h4><ul>
<li>使用迭代器可在容器的任意位置插入、删除元素或元素序列。</li>
<li>使用迭代器可使用标准库算法。</li>
<li>通过迭代器顺序访问元素，通常比编制容器索引以单独检索每个元素的效率要高。</li>
</ul>
<h4 id="在vector中存储引用"><a href="#在vector中存储引用" class="headerlink" title="在vector中存储引用"></a>在vector中存储引用</h4><p>可在诸如vector的容器中存储引用。为此，在容器中存储<code>std:reference_wrapper</code>。<code>std:ref()</code>和<code>cref()</code>函数模板用于创建非const和const reference_wrapper实例。需要包含<code>&lt;functional&gt;</code>头文件。示例如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str1 = <span class="string">"Hello"</span>;</span><br><span class="line"><span class="built_in">string</span> str2 = <span class="string">"World"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;reference_wrapper&lt;<span class="built_in">string</span>&gt;&gt; vec&#123; ref(str1) &#125;;</span><br><span class="line">vec.push_back(ref(str2));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Modify the string referred to by the second reference in the vector.</span></span><br><span class="line">vec[<span class="number">1</span>].get() += <span class="string">"!"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The end result is that str2 is actually modified.</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; str1 &lt;&lt; <span class="string">" "</span> &lt;&lt; str2 &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p>
<h4 id="添加和删除元素"><a href="#添加和删除元素" class="headerlink" title="添加和删除元素"></a>添加和删除元素</h4><p>根据前面的描述，通过<code>push_back()</code>方法可向vector追加元素。vector还提供了删除元素的对应方法：<code>pop_back()</code>。</p>
<p><code>pop_back()</code>不会返回已删除的元素。如果要访问这个元素，必须首先通过<code>back()</code>获得这个元素。通过<code>insert()</code>方法可在vector中的任意位置插入元素，这个方法在迭代器指定的位置添加一个或多个元素，将所有后续元素向后移动，给新元素腾出空间。<code>insert()</code>有5种不同的重载形式：</p>
<ul>
<li>插入单个元素</li>
<li>插入单个元素的n份副本</li>
<li>从某个迭代器范围插入元素</li>
<li>使用移动语义，将给定元素转移到vector中，插入一个元素</li>
<li>向vector中插入一列元素，这列元素是通过initializer_list指定的</li>
</ul>
<p><code>push_back()</code>和<code>insert()</code>还有把左值或右值作为参数的版本。两个版本都根据需要分配内存，以存储新元素。左值版本保存新元素的副本。右值版本使用移动语义，将给定元素的所有权转移到vector，而不是复制它们。</p>
<p>通过<code>erase()</code>可在vector中的任意位置删除元素，通过<code>clear()</code>可删除所有元素。<code>erase()</code>有两种形式：一种接收单个迭代器，删除单个元素；另一种接收两个迭代器，删除迭代器指定的元素范围。要删除满足指定条件的多个元素，一种解决方法是编写一个循环来遍历所有元素，然后删除每个满足条件的元素。然而，这种方法具有二次(平方)复杂度，对性能有很大影响。这种情况下，可使用删除擦除惯用法(remove-erase-idiom)，这种方法的复杂度为线性复杂度。</p>
<h4 id="移动语义"><a href="#移动语义" class="headerlink" title="移动语义"></a>移动语义</h4><p>所有的标准库容器都包含移动构造函数和移动赋值运算符，从而实现了移动语义。这带来的一大好处是可以通过传值的方式从函数返回标准库容器，而不会降低性能。分析下面这个函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; createVectorofsize(<span class="keyword">size_t</span> size) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec(size);</span><br><span class="line">    <span class="keyword">int</span> contents = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i : vec)</span><br><span class="line">        i = contents++;</span><br><span class="line">    <span class="keyword">return</span> vec;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myVector;</span><br><span class="line">myVector.createVectorofsize (<span class="number">123</span>);</span><br></pre></td></tr></table></figure></p>
<p>如果没有移动语义，那么将<code>createVectorOfSize()</code>赋给myVector时，会调用复制赋值运算符。有了标准库容器中支持的移动语义后，就可避免这种vector复制。相反，对myVector的赋值会触发调用移动赋值运算符。</p>
<p>与此类似，push操作在某些情况下也会通过移动语义提升性能。vector类还定义了<code>push_back(T&amp;&amp;val)</code>，这是<code>push_back(const T&amp; val)</code>的移动版本。如果按照下列方式调用<code>push_back()</code>方法，则可以避免这种复制：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vec.push_back(move(myElement));</span><br></pre></td></tr></table></figure></p>
<p>现在可以明确地说，myElement应移入vector。注意在执行这个调用后，myElement处于有效但不确定的状态。不应再使用myElement，除非通过调用<code>clear()</code>等使其重返确定状态。也可以这样调用<code>push_back()</code>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vec.push_back(<span class="built_in">string</span>(<span class="number">5</span>, <span class="string">'a'</span>));</span><br></pre></td></tr></table></figure></p>
<p>上述<code>vec.push_back()</code>调用会触发移动版本的调用，因为调用string构造函数后生成的是一个临时string对象。<code>push_back()</code>方法将这个临时string对象移到vector中，从而避免了复制。</p>
<h4 id="emplace操作"><a href="#emplace操作" class="headerlink" title="emplace操作"></a>emplace操作</h4><p>C++在大部分标准库容器中添加了对emplace操作的支持。emplace的意思是“放置到位”。emplace操作的一个示例是vector对象上的<code>emplace_back()</code>，这个方法在容器中分配空间，然后就地构建对象。例如：</p>
<p>从C++17开始，<code>emplace_back()</code>方法返回已插入元素的引用。在C++17之前，<code>emplace_back()</code>的返回类型是void。还有一个<code>emplace()</code>方法，可在vector的指定位置就地构建对象，并返回所插入元素的迭代器。</p>
<h4 id="算法复杂度和迭代器失效"><a href="#算法复杂度和迭代器失效" class="headerlink" title="算法复杂度和迭代器失效"></a>算法复杂度和迭代器失效</h4><p>在vector中插入或删除元素，引用插入点、删除点或随后位置的所有迭代器在操作之后都失效了。vector内部的重分配可能导致引用vector中元素的所有迭代器失效，而不只是那些引用插入点或删除点之后的元素的迭代器。</p>
<h4 id="vector内存分配方案"><a href="#vector内存分配方案" class="headerlink" title="vector内存分配方案"></a>vector内存分配方案</h4><p>vector会自动分配内存来保存插入的元素。每次vector申请更多内存时，要分配一块更大的内存块，将所有元素复制到新的内存块。这个过程非常耗时，因此 vector的实现在执行重分配时，会分配比所需内存更多的内存，以尽量避免这个复制转移过程。</p>
<p>必须理解vector内部的内存工作原理有两个原因：</p>
<ol>
<li>效率。vector分配方案能保证元素插入采用摊还常量时间复杂度：也就是说，大部分操作都采用常量时间，但是也会有线性时间(需要重新分配内存时)。如果关注运行效率，那么可控制vector执行内存重分配的时机。</li>
<li>迭代器失效。重分配会使引用vector内元素的所有选代器失效。因此，vector接口允许查询和控制vector的重分配。如果不显式地控制重分配，那么应该假定每次插入都会导致重分配以及所有迭代器失效。</li>
</ol>
<h4 id="大小和容量"><a href="#大小和容量" class="headerlink" title="大小和容量"></a>大小和容量</h4><p>vector提供了两个可获得大小信息的方法：<code>size()</code>和<code>capacity()</code>，<code>size()</code>方法返回vector中元素的个数，而<code>capacity()</code>返回的是vector在重分配之前可以保存的元素个数。因此，在重分配之前还能插入的元素个数为<code>capacity() - size()</code>。</p>
<p>C++17引入了非成员的<code>std::size()</code>和<code>std::empty()</code>全局函数。这些与用于获取迭代器的非成员函数(如<code>std::begin()</code>和<code>std::end()</code>等)类似。非成员函数<code>size()</code>和<code>empty()</code>可用于所有容器，也可用于静态分配的C风格数组(不通过指针访问)以及<code>initializer_list</code>。下面是一个将它们用于vector的例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; size(vec) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; empty(vec) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p>
<h4 id="预留容量"><a href="#预留容量" class="headerlink" title="预留容量"></a>预留容量</h4><p>一种预分配空间的方式是调用<code>reserve()</code>。这个方法负责分配保存指定数目元素的足够空间。</p>
<p>另一种预分配空间的方法是在构造函数中，或者通过<code>resize()</code>或<code>assign()</code>方法指定vector要保存的元素数目。这种方法会创建指定大小的vector(容量也可能就是这么大)。</p>
<h4 id="直接访问数据"><a href="#直接访问数据" class="headerlink" title="直接访问数据"></a>直接访问数据</h4><p>vector在内存中连续存储数据，可使用<code>data()</code>方法获取指向这块内存的指针。C++17引入了非成员的<code>std::data()</code>全局函数来获取数据的指针。它可用于array. vector容器、字符串、静态分配的C风格数组(不通过指针访问)和initializer_lists。下面是一个用于vector的示例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>* data1 = vec.data();</span><br><span class="line"><span class="keyword">int</span>* data2 = data(vec);</span><br></pre></td></tr></table></figure></p>
<h3 id="vector特化"><a href="#vector特化" class="headerlink" title="vector特化"></a>vector<bool>特化</bool></h3><p>C++标准要求对布尔值的vector进行部分特化，目的是通过“打包”布尔值的方式来优化空间分配。C++没有正好保存一个位的原始类型。一些编译器使用和char大小相同的类型来表示布尔值。其他一些编译器使用int类型。<code>vector&lt;bool&gt;</code>特化应该用单个位来存储“布尔数组”，从而节省空间。可将<code>vector&lt;bool&gt;</code>表示为位字段(bit-field)而不是vector。</p>
<p><code>vector&lt;bool&gt;</code>特化实际上定义了一个名为reference的类，用作底层布尔(或位)值的代理。当调用<code>operator[]</code>、<code>at()</code>或类似方法时，<code>vector&lt;bool&gt;</code>返回reference对象，这个对象是实际布尔值的代理。</p>
<blockquote>
<p>由于<code>vector&lt;bool&gt;</code>返回的引用实际上是代理，因此不能取地址以获得指向容器中实际元素的指针。</p>
</blockquote>
<p>在实际应用中，通过包装布尔值而节省一点空间似乎得不偿失。更糟糕的是，访问和修改<code>vector&lt;bool&gt;</code>中的元素比访问<code>vector&lt;int&gt;</code>中的元素慢得多。应该避免使用<code>vector&lt;bool&gt;</code>，而是使用bitset。</p>
<p>如果确实需要动态大小的位字段，建议使用<code>vector&lt;std::int_fast8_t&gt;</code>或<code>vector&lt;unsigned char&gt;</code>。<code>std::int_fast8_t</code>类型在<code>&lt;cstdint&gt;</code>中定义。这是一种带符号的整数类型，编译器必须为其使用最快的整数类型(至少8位)。</p>
<h3 id="deque-1"><a href="#deque-1" class="headerlink" title="deque"></a>deque</h3><p>deque(double-ended qucue的简称)几乎和vector是等同的，但用得更少。deque定义在<code>&lt;deque&gt;</code>头文件中。主要区别如下：</p>
<ul>
<li>不要求元素保存在连续内存中</li>
<li>deque支持首尾两端常量时间的元素插入和删除操作(vector只支持尾端的摊还常量时间)</li>
<li>deque提供了<code>push_front()</code>，<code>pop_front()</code>和<code>emplace_front()</code>，而vector没有提供</li>
<li>在开头和末尾插入元素时，deque未使选代器失效</li>
<li>deque没有通过<code>reserve()</code>和<code>capacity()</code>公开内存管理方案</li>
</ul>
<h3 id="list-1"><a href="#list-1" class="headerlink" title="list"></a>list</h3><p>list定义在<code>&lt;list&gt;</code>头文件中，是一种标准的双链表。list支持链表中任意位置常量时间的元素插入和删除操作，但访问单独元素的速度较慢(线性时间)。事实上，list根本没有提供诸如<code>operator[]</code>的随机访问操作。只有通过迭代器才能访问单个元素。</p>
<h4 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h4><p>list提供的访问元素的方法仅有<code>front()</code>和<code>back()</code>，这两个方法的复杂度都是常量时间。这两个方法返回链表中第一个元素和最后一个元素的引用。对所有其他元素的访问都必须通过迭代器进行。</p>
<p>list支持<code>begin()</code>方法，这个方法返回引用链表中第一个元素的迭代器；还支持<code>end()</code>方法，这个方法返回引用链表中最后一个元素之后那个元素的迭代器。与vector类似，list还支持<code>cbegin()</code>、<code>cend()</code>、<code>rbegin()</code>，<code>rend()</code>、<code>crbegin()</code>和<code>crend()</code>。</p>
<blockquote>
<p>list不支持元素的随机访问。</p>
</blockquote>
<h4 id="迭代器-1"><a href="#迭代器-1" class="headerlink" title="迭代器"></a>迭代器</h4><p>list迭代器是双向的，不像vector迭代器那样提供随机访问。这意味着list迭代器之间不能进行加减操作和其他指针运算。</p>
<h4 id="添加和删除元素-1"><a href="#添加和删除元素-1" class="headerlink" title="添加和删除元素"></a>添加和删除元素</h4><p>和vector一样，list也支持添加和删除元素的方法，包括<code>push_back()</code>、<code>pop_back()</code>、<code>emplace()</code>、<code>emplace_back()</code>5种形式的<code>insert()</code>以及两种形式的<code>erase()</code>和<code>clear()</code>。和deque一样，list还提供了<code>push_front()</code>、<code>emplace_front()</code>和<code>pop_front()</code>。list的奇妙之处在于，只要找到正确的操作位置，所有这些方法(clear()除外)的复杂度都是常量时间。</p>
<h4 id="list大小"><a href="#list大小" class="headerlink" title="list大小"></a>list大小</h4><p>list不公开底层的内存模型。因此，list支持<code>size()</code>、<code>empty()</code>和<code>resize()</code>，但不支持<code>reserve()</code>和<code>capacity()</code>。注意，list的<code>size()</code>方法具有常量时间复杂度。</p>
<h4 id="list特殊操作"><a href="#list特殊操作" class="headerlink" title="list特殊操作"></a>list特殊操作</h4><p>list提供了一些特殊操作，以利用其元素插入和删除很快这一特性。</p>
<h5 id="串联"><a href="#串联" class="headerlink" title="串联"></a>串联</h5><p>由于list类的本质是链表，因此可在另一个list的任意位置串联(splice)或插入整个list，其复杂度是常量时间。</p>
<p>串联���作对作为参数传入的list来说是破坏性的：从一个list中删除要插入另一个list的元素。</p>
<h5 id="更高效的算法版本"><a href="#更高效的算法版本" class="headerlink" title="更高效的算法版本"></a>更高效的算法版本</h5><p>除<code>splice()</code>外，list类还提供了一些泛型标准库算法的特殊实现。</p>
<p>表17-3总结了list以方法形式提供特殊实现的算法。<br><img src="/img/1619945239.jpg" alt></p>
<h3 id="forward-list-1"><a href="#forward-list-1" class="headerlink" title="forward_list"></a>forward_list</h3><p>forward_list在<code>&lt;forward_list&gt;</code>头文件中定义，forward_list是单链表，而list是双链表。这意味着forward_list只支持前向迭代，如果需要修改任何链表，首先需要访问第一个元素之前的那个元素。由于forward_list没有提供反向遍历的迭代器，因此没有简单的方法可以访问前一个元素。所以，要修改的范围(例如提供给<code>erase()</code>和<code>splice()</code>的范围)必须是前开的。</p>
<p>forward_list类定义了一个<code>before_begin()</code>方法，它返回一个指向链表开头元素之前的假想元素的迭代器。不能解除这个迭代器的引用，因为这个迭代器指向非法数据。然而，将这个迭代器递增1可得到与<code>begin()</code>返回的迭代器同样的效果；因此，这个方法可以用于构建前开的范围。表17-4总结了list和forward_list之间的区别。<br><img src="/img/1619945467.jpg" alt><br><img src="/img/1619945484.jpg" alt></p>
<p>forward_list和list的构造函数及赋值运算符类似。C++标准表明forward_list应该尽可能使用最小的空间。</p>
<h3 id="array-1"><a href="#array-1" class="headerlink" title="array"></a>array</h3><p>array类定义在<code>&lt;array&gt;</code>头文件中，和vector类似，区别在于array的大小是固定的，不能增加或收缩。这个类的目的是让array能分配在栈上，而不是像vector那样总是需要访问堆。和vector一样，array支持随机访问迭代器，元素都保存在连续内存中。array支持<code>front()</code>、<code>back()</code>、<code>at()</code>和<code>operator[]</code>，还支持使用<code>fill()</code>方法通过特定元素将array填满。由于array大小固定，因此不支持<code>push_back()</code>、<code>pop_back()</code>、<code>insert()</code>、<code>erase()</code>、<code>clear()</code>、<code>resize()</code>、<code>reserve()</code>、<code>capacity()</code>。</p>
<p>与vector相比，array的缺点是，array的<code>swap()</code>方法具有线性时间复杂度，而vector的<code>swap()</code>方法具有常量时间复杂度。array声明需要两个模板参数：第一个参数指定元素类型，第二个参数指定array中元素的固定数量：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">array</span>&lt;<span class="keyword">int</span>, 3&gt; arr = &#123;<span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>&#125;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;<span class="string">"Array size "</span>&lt;&lt; arr.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; i : arr)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">arr.fill(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> iter = cbegin(arr); iter != cend(arr); ++iter)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *iter &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p>
<p>可使用<code>std:get&lt;n&gt;()</code>函数模板，从<code>std::array</code>检索位于索引位置n的元素。索引必须是常量表达式，不能是循环变量等。使用<code>std:get&lt;n&gt;()</code>的优势在于编译器在编译时检查给定索引是有效的，否则将导致编译错误，如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">array</span>&lt;<span class="keyword">int</span>, 3&gt; myArray(<span class="number">11</span>，<span class="number">22</span>, <span class="number">33</span>);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; <span class="built_in">std</span>::get&lt;<span class="number">1</span>&gt;(myArray) &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::get&lt;<span class="number">10</span>&gt;(myArray)&lt;&lt; <span class="built_in">endl</span>; <span class="comment">// Compilation error!</span></span><br></pre></td></tr></table></figure></p>
<h2 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h2><p>除标准的顺序容器外，标准库还提供了3种容器适配器：queue，priority_queue和stack。每种容器适配器都是对一种顺序容器的包装。它们允许交换底层容器，无须修改其他代码。容器适配器的作用是简化接口，只提供那些stack和queue抽象所需的功能。</p>
<h3 id="queue-1"><a href="#queue-1" class="headerlink" title="queue"></a>queue</h3><p>queue容器适配器定义在头文件<code>&lt;queue&gt;</code>中，queue提供了标准的“先入先出”语义。与通常情况一样，queue也写为类模板形式，如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Container</span> = <span class="title">deque</span>&lt;T&gt; &gt; <span class="title">class</span> <span class="title">queue</span>;</span></span><br></pre></td></tr></table></figure></p>
<p>T模板参数指定要保存在queue中的类型。另一个模板参数指定queue适配的底层容器。不过，由于queue要求顺序容器同时支持<code>push_back()</code>和<code>pop_front()</code>两个操作，因此只有两个内建的选项：deque和list。大部分情况下，只使用默认的选项deque即可。</p>
<h4 id="queue操作"><a href="#queue操作" class="headerlink" title="queue操作"></a>queue操作</h4><p>queue接口非常简单：只有8个方法，再加上构造函数和普通的比较运算符。<code>push()</code>和<code>emplace()</code>方法在queue的尾部添加一个新元素，<code>pop()</code>从queue的头部移除元素。通过<code>front()</code>和<code>back()</code>可以分别获得第一个元素和最后一个元素的引用，而不会删除元素。与其他容器一样，在调用const对象时，<code>front()</code>和<code>back()</code>返回的是const引用：调用非const对象时，这些方法返回的是非const引用(可读写)。</p>
<blockquote>
<p><code>pop()</code>不会返回弹出的元素。如果需要获得一份元素的副本，必须首先通过<code>front()</code>获得这个元素。queue还支持<code>size()</code>、<code>empty()</code>和<code>swap()</code>。</p>
</blockquote>
<h3 id="priority-queue-1"><a href="#priority-queue-1" class="headerlink" title="priority_queue"></a>priority_queue</h3><p>优先队列(priority_queue)是一种按顺序保存元素的队列。优先队列不保证严格的FIFO顺序，而是保证在队列头部的元素任何时刻都具有最高优先级。这个元素可能是队列中最老的那个元素，也可能是最新的那个元素。如果两个元素的优先级相等，那么它们在队列中的相对顺序是未确定的。priority_queue容器适配器也定义在<code>&lt;queue&gt;</code>中。其模板定义如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Container</span> = <span class="title">vector</span>&lt;T&gt;, <span class="title">class</span> <span class="title">Compare</span> = <span class="title">less</span>&lt;T&gt;&gt;;</span></span><br></pre></td></tr></table></figure></p>
<p>这个类没有看上去这么复杂。之前看到了前两个参数：T是priority_queue中保存的元素类型；Container是priority_queue适配的底层容器。priority_queue默认使用vector，但是也可以使用deque。这里不能使用list，因为priority_queue要求随机访问元素。第3个参数Compare复杂一些。less是一个类模板，支持两个类型为T的元素通过<code>operator&lt;</code>运算符进行比较。也就是说，要根据<code>operator&lt;</code>来确定队列中元素的优先级，可以自定义这里使用的比较操作。目前，只要保证为保存在priority_queue中的类型正确定义了<code>operator&lt;</code>即可。</p>
<p>priority_queue的头元素是优先级最高的元素，默认情况下优先级是通过operator&lt;运算符来判断的，比其他元素“小”的元素的优先级比其他元素低</p>
<h4 id="priority-queue提供的操作"><a href="#priority-queue提供的操作" class="headerlink" title="priority_queue提供的操作"></a>priority_queue提供的操作</h4><p>priority_queue提供的操作比queue还要少。<code>push()</code>和<code>emplace()</code>可以插入元素，<code>pop()</code>可以删除元素，<code>top()</code>可以返回头元素的const引用。</p>
<blockquote>
<p>在非const对象上调用<code>top()</code>，<code>top()</code>返回的也是const引用，因为修改元素可能会改变元素的顺序，所以不允许修改。priority_queue没有提供获得尾元素的机制。</p>
</blockquote>
<blockquote>
<p><code>pop()</code>不返回弹出的元素。如果需要获得一份副本，必须首先通过<code>top()</code>获得这个元素。</p>
</blockquote>
<p>与queue一样，priority_queue支持<code>size()</code>、<code>empty()</code>和<code>swap()</code>。然而，priority_queue没有提供任何比较运算符。</p>
<h3 id="stack-1"><a href="#stack-1" class="headerlink" title="stack"></a>stack</h3><p>stack和queue几乎相同，区别在于stack提供先入后出(FILO)的语义，这种语义也称为后入先出，以区别于FIFO。stack定义在<code>&lt;stack&gt;</code>头文件中。模板定义如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Container</span> = <span class="title">deque</span>&lt;T&gt;&gt;<span class="title">class</span> <span class="title">stack</span>;</span></span><br></pre></td></tr></table></figure></p>
<p>可将vector、list或deque用作stack的底层容器。</p>
<h4 id="stack操作"><a href="#stack操作" class="headerlink" title="stack操作"></a>stack操作</h4><p>与queue类似，stack提供了<code>push()</code>、<code>emplace()</code>和<code>pop()</code>。区别在于：<code>push()</code>在stack项部添加一个新元素，将之前插入的所有元素都“向下推”；而<code>pop()</code>从stack顶部删除一个元素，这个元素就是最近插入的元素。如果在const对象上调用，<code>top()</code>方法返回顶部元素的const引用；如果在非const对象上调用，<code>top()</code>方法返回非const引用。</p>
<p><code>pop()</code>不返回弹出的元素。如果需要获得一份副本，必须首先通过<code>top()</code>获得这个元素。stack支持<code>empty()</code>、<code>size()</code>、<code>swap()</code>和标准的比较运算符。</p>
<h2 id="有序关联容器"><a href="#有序关联容器" class="headerlink" title="有序关联容器"></a>有序关联容器</h2><p>有序关联容器将键映射到值。通常情况下，有序关联容器的插入、删除和查找时间是相等的。标准库提供的4个有序关联容器分别为map、multimap、set和multiset。每种有序关联容器都将元素保存在类似于树的有序数据结构中。还有4个无序关联容器：unordered_map、unordered_multimap、unordered_set和unordered_multiset。</p>
<h3 id="pair工具类"><a href="#pair工具类" class="headerlink" title="pair工具类"></a>pair工具类</h3><p>pair类在<code>&lt;utility&gt;</code>头文件中定义。pair是一个类模板，它将两个可能属于不同类型的值组合起来。通过first和second公共数据成员访问这两个值。pair类定义了<code>operator==</code>和<code>operator&lt;</code>，用于比较first和second元素。下面给出了一些示例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; myPair(<span class="string">"hello"</span>, <span class="number">5</span>);</span><br><span class="line">pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; myotherPair;</span><br><span class="line"></span><br><span class="line">myotherPair.first = <span class="string">"hello"</span>;</span><br><span class="line">myotherPair.second = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; myThirdPair (myOtherPair);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mypair &lt; myOtherPair)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="string">"myPair is less than myotherPair"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"myPair is greater than or equal to myOtherPair"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (myotherPair == myThirdPair)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"myotherPair 1s equal to myThirdPair"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"myOtherPair is not equal to myThirdPair"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p>
<p>这个库还提供了一个工具函数模板<code>make_pair()</code>，用于从两个值构造一个pair。例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">double</span>&gt; aPair = make_ pair(<span class="number">5</span>，<span class="number">10.10</span>);</span><br></pre></td></tr></table></figure></p>
<p>如果需要向函数传递pair，或者把它赋予已有的变量，那么<code>make_pair()</code>更有用。与类模板不同，函数模板可从参数中推导类型，因此可通过<code>make_pair()</code>构建pair，而不需要显式地指定类型。还可结合使用<code>make_pair()</code>与auto关键字：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> aSecondPair = make_pair(<span class="number">5</span>, <span class="number">10.10</span>);</span><br></pre></td></tr></table></figure></p>
<p>结构化绑定是另一个C++17特性，可用于将pair的元素分解为单独的变量。下面是一个示例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; myPair(<span class="string">"hello"</span>, <span class="number">5</span>);</span><br><span class="line"><span class="keyword">auto</span>[thestring, theint] = myPair;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"theString:"</span> &lt;&lt; thestring &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"theInt: "</span>&lt;&lt; theInt &lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>map定义在<code>&lt;map&gt;</code>头文件中，它保存的是键/值对，而不是只保存值。插入、查找和删除操作都是基于键的，值只不过是附属品。map根据键对元素排序存储，因此插入、删除和查找的复杂度都是对数时间。由于排好了序，因此枚举元素时，元素按类型的<code>operator&lt;</code>或用户定义的比较器确定的顺序出现。通常情况下，map实现为某种形式的平衡树，例如红黑树。不过，树的结构并没有向客户公开。</p>
<h4 id="构建map"><a href="#构建map" class="headerlink" title="构建map"></a>构建map</h4><p>map类模板接收4种类型：键类型、值类型、比较类型以及分配器类型。比较类型和之前描述的priority_queue中的比较类型类似，允许提供与默认不同的比较类。如果忽略比较参数和分配器参数，那么map的构建和vector或list的构建是一样的，区别在于，在模板实例化中需要分别指定键和值的类型。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data</span> <span class="title">final</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    explicit Data(int value = 0): mValue(value) ()</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> mValue; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setValue</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123; mValue = value; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> mValue;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, Data&gt; dataMaps;</span><br></pre></td></tr></table></figure></p>
<p>map还支持统一初始化机制：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; m = &#123;</span><br><span class="line">&#123; <span class="string">"Marc G."</span>, <span class="number">123</span> &#125;,</span><br><span class="line">&#123; <span class="string">"Warren B."</span>, <span class="number">456</span>&#125;,</span><br><span class="line">&#123; <span class="string">"Peter V.W."</span>, <span class="number">789</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h4><p>map和其他关联容器插入时不需要指定位置。map的内部实现会判定要保存新元素的位置，只需要提供键和值即可。</p>
<blockquote>
<p>map和其他有序关联容器提供了接收选代器位置作为参数的<code>insert()</code>方法。然而，这个位置只是容器找到正确位置的一种“提示”。不强制容器在那个位置插入元素。</p>
</blockquote>
<p>在插入元素时，一定要记住map需要“唯一键”：map中的每个元素都要有不同的键。如果需要支持多个带有同一键的元素，有两个选择：可使用map，把另一个容器(如vector或array)用作键的值，也可以使用后面描述的multimap。</p>
<h4 id="insert-方法"><a href="#insert-方法" class="headerlink" title="insert()方法"></a>insert()方法</h4><p>可使用<code>insert()</code>方法向map添加元素，它有一个好处：允许判断键是否已经存在。<code>insert()</code>方法的一个问题是必须将键/值对指定为pair对象或<code>initializer_list</code>。<code>insert()</code>的基本形式的返回类型是迭代器和布尔值组成的pair，返回类型这么复杂的原因是，如果指定的键已经存在，那么<code>insert()</code>不会改写元素值。返回的pair中的bool元素指出，<code>insert()</code>是否真的插入了新的键/值对。迭代器引用的是map中带有指定键的元素。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, Data&gt; dataMap;</span><br><span class="line"><span class="keyword">auto</span> ret = dataMap.insert(&#123;<span class="number">1</span>, Data(<span class="number">4</span>) &#125;);</span><br><span class="line"><span class="keyword">if</span> (ret.second)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="string">"Insert succeeded!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Insert failed!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">ret = dataMap.insert(make_pair(<span class="number">1</span>, Data(<span class="number">6</span>))); <span class="comment">// Using a pair object</span></span><br><span class="line">it (ret.second)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Insert succeeded!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Insert failed!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p>
<p>ret变量的类型是pair，如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;<span class="built_in">map</span>&lt;<span class="keyword">int</span>, Data&gt;::iterator, <span class="keyword">bool</span>&gt;ret;</span><br></pre></td></tr></table></figure></p>
<p>pair的第一个元素是键类型为int、值类型为Data的map的map选代器。该pair的第二个元素为布尔值。</p>
<p>使用if语句的初始化器，只使用一条语句，即可将数据插入map并检查结果，如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">auto</span> result = dataMap.insert(&#123;<span class="number">1</span>, Data(<span class="number">4</span>) &#125;); result.second)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Insert succeeded!"</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="string">"Insert failed!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p>
<p>甚至可将其与C++17结构化绑定结合使用：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">auto</span> [iter, success] = dataMap.insert(&#123; <span class="number">1</span>, Data(<span class="number">4</span>) &#125;); success)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Insert succeeded!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="string">"Insert failed!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p>
<h4 id="insert-or-assign-方法"><a href="#insert-or-assign-方法" class="headerlink" title="insert_or_assign()方法"></a>insert_or_assign()方法</h4><p><code>insert_or_assign()</code>与<code>insert()</code>的返回类型类似。但是，如果已经存在具有给定键的元素，<code>insert_or_assign()</code>将用新值重写旧值，而<code>insert()</code>在这种情况下不重写旧值。与<code>insert()</code>的另一个区别在于，<code>insert_or_assign()</code>有两个独立的参数：键和值。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ret = dataMap.insert_or_assign(<span class="number">1</span>, Data(<span class="number">7</span>));</span><br><span class="line"><span class="keyword">if</span> (ret.second)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Inserted."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Overwritten."</span>&lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p>
<h4 id="operator"><a href="#operator" class="headerlink" title="operator[]"></a>operator[]</h4><p>向map插入元素的另一种方法是通过重载的<code>operator[]</code>。这种方法的区别主要在于语法：键和值是分别指定的。此外，<code>operator[]</code>总是成功。如果给定键没有对应的元素值，就会创建带有对应键值的新元素。如果具有给定键的元素已经存在，<code>operator[]</code>会将元素值替换为新指定的值。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, Data&gt; dataMap;</span><br><span class="line">dataMap[<span class="number">1</span>] = Data(<span class="number">4</span>);</span><br><span class="line">dataMap[<span class="number">1</span>] = Data(<span class="number">6</span>); <span class="comment">// Replaces the element with key 1</span></span><br></pre></td></tr></table></figure></p>
<p>不过，<code>operator[]</code>有一点要注意：它总会构建一个新的值对象，即使并不需要使用这个值对象也同样如此。因此，需要为元素值提供一个默认的构造函数，从而可能会比<code>insert()</code>的效率低。</p>
<p>如果请求的元素不存在，<code>operator[]</code>会在map中创建一个新元素，所以这个运算符没有被标记为const。尽管这很明显，但有时可能会看上去违背常理。</p>
<h4 id="emplace方法"><a href="#emplace方法" class="headerlink" title="emplace方法"></a>emplace方法</h4><p>map支持<code>emplace()</code>和<code>emplace_hint()</code>，从而在原位置构建元素，这与vector的emplace方法类似。C++17添加了<code>try_emplace()</code>方法，如果给定的键尚不存在，则在原位置插入元素；如果map中已经存在相应的键，则什么都不做。</p>
<h4 id="map迭代器"><a href="#map迭代器" class="headerlink" title="map迭代器"></a>map迭代器</h4><p>map迭代器的工作方式类似于顺序容器的选代器。主要区别在于选代器引用的是键值对，而不只是值。如果要访问值，必须通过pair对象的second字段来访问。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> iter = cbegin(dataMap); iter != cend(dataMap); ++iter)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; iter-&gt;second.getValue() &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p>
<h4 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h4><p>map可根据指定的键查找元素，复杂度为指数时间。如果知道指定键的元素存在于map中，那么查找它的最简单方式是，只要在非const map或对map的非const引用上调用，就通过<code>operator[]</code>进行查找。<code>operator[]</code>的好处在于返回可直接使用和修改的元素引用，而不必考虑从pair对象中获得值。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, Data&gt; dataMap;</span><br><span class="line">dataMap[<span class="number">1</span>] = Data(<span class="number">4</span>);</span><br><span class="line">dataMap[<span class="number">1</span>] = Data(<span class="number">6</span>);</span><br><span class="line">dataMap[<span class="number">1</span>].setValue(<span class="number">100</span>);</span><br></pre></td></tr></table></figure></p>
<p>然而，如果不知道元素是否存在，就不能使用<code>operator[]</code>。因为如果元素不存在，这个运算符会插入一个包含相应键的新元素。作为替换方案，map提供了<code>find()</code>方法。如果元素在map中存在， 这个方法返回指向具有指定键的元素的选代器；如果元素在map中不存在，则返回<code>end()</code>选代器。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> it = dataMap.find(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(it != end(dataMap))</span><br><span class="line">    it-&gt;second.setValue (<span class="number">100</span>);</span><br></pre></td></tr></table></figure></p>
<p>如果只想知道在map中是否存在具有给定键的元素，那么可以使用<code>count()</code>成员函数。这个函数返回map中给定键的元素个数。对于map来说，这个函数返回的结果不是0就是1，因为map中不允许有具有重复键的元素</p>
<h4 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h4><p>map允许在指定的选代器位置删除一个元素或删除指定迭代器范围内的所有元素，这两种操作的复杂度分别为摊还常量时间和对数时间。从客户的角度看，用于执行上述操作的两个<code>erase()</code>方法等同于顺序容器中的<code>erase()</code>方法。</p>
<h4 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h4><p>所有有序和无序的关联容器都被称为基于节点的数据结构。从C++17开始，标准库以节点句柄(node handle)的形式，提供对节点的直接访问。确切类型并未指定，但每个容器都有一个名为node_type的类型别名，它指定容器节点句柄的类型。节点句柄只能移动，是节点中存储的元素的所有者。它提供对键和值的读写访问。</p>
<p>可基于给定的选代器位置或键，从关联容器(作为节点句柄)提取节点。从容器提取节点时，将其从容器中删除，因为返回的节点句柄是所提取元素的唯一拥有者。</p>
<p>C++提供了新的<code>insert()</code>重载，以允许在容器中插入节点句柄。使用<code>extract()</code>来提取节点句柄，使用<code>insert()</code>来插入节点句柄，可有效地将数据从一个关联容器传递给另一个关联容器，而不需要执行任何复制或移动。甚至可将节点从map移到multimap，从set移到multiset。下面的代码将键为1的节点转到第二个map：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, Data&gt; dataMap2;</span><br><span class="line"><span class="keyword">auto</span> extractedNode = dataMap.extract(<span class="number">1</span>);</span><br><span class="line">dataMap2.insert(<span class="built_in">std</span>::move (extractedNode));</span><br></pre></td></tr></table></figure></p>
<p>还有一个操作<code>merge()</code>，可将所有节点从一个关联容器移到另一个关联容器。无法移动的节点留在源容器中。一个示例如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; src = &#123; &#123;<span class="number">1</span>, <span class="number">11</span>&#125;, &#123;<span class="number">2</span>, <span class="number">22</span>&#125; &#125;;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; dst = &#123; &#123;<span class="number">2</span>, <span class="number">22</span>&#125;, &#123;<span class="number">3</span>, <span class="number">33</span>&#125;, &#123;<span class="number">4</span>, <span class="number">44</span>&#125;, &#123;<span class="number">5</span>, <span class="number">55</span>&#125; &#125;;</span><br><span class="line">dst.merge(src);</span><br></pre></td></tr></table></figure></p>
<p>完成合并操作后，src仍然包含一个元素{2, 22}，因为目标已经包含这个元素，所以无法移动。操作后，dst包含{1, 11}、{2, 22}、{3, 33}、{4, 44}和{5, 55}。</p>
<h3 id="multimap"><a href="#multimap" class="headerlink" title="multimap"></a>multimap</h3><p>multimap是一种允许多个元素使用同一个键的map。和map一样，multimap支持统一初始化。multimap的接口和map的接口几乎相同，区别在于：</p>
<ul>
<li>multimap不提供<code>operator[]</code>和<code>at()</code>。它们的语义在多个元素可以使用同一个键的情况下没有意义。</li>
<li>在multimap上执行插入操作总是会成功。因此，添加单个元素的<code>multimap::insert()</code>方法只返回iterator而不返回pair。</li>
<li>map支持<code>insert_or_assign()</code>和<code>try_emplace()</code>方法，而multimap不支持。</li>
</ul>
<blockquote>
<p>multimap允许插入相同的键值对。如果要避免这种冗余，必须在插入新元素之前执行显式检查。</p>
</blockquote>
<p>multimap的最棘手之处是查找元素。不能使用<code>operator[]</code>，因为并没有提供<code>operator[]</code>。<code>find()</code>也不是非常有用，因为<code>find()</code>返回的是指向具有给定键的任意一个元素的iterator(未必是具有这个键的第一个元素)。</p>
<p>然而，multimap将所有带同一个键的元素保存在一起，并提供方法以获得这个子范围的iterator，这个子范围内的元素在容器中具有相同的键。<code>lower_bound()</code>和<code>upper_bound()</code>方法分别返回匹配给定键的第一个元素和最后一个元素之后那个元素的对应 iterator。如果没有元素匹配这个键，那么<code>lower_bound()</code>和<code>upper_bound()</code>返回的iterator相等。</p>
<p>如果需要获得具有给定键的元素对应的iterator，使用<code>equal_range()</code>方法比依次调用<code>lower_bound()</code>和<code>upper_bound()</code>更高效。<code>equal_range()</code>返回两个iterator的pair，这两个iterator分别是<code>lower_bound()</code>和<code>upper_bound()</code>返回的iterator。</p>
<blockquote>
<p>map中也有<code>lower_bound()</code>，<code>upper_bound()</code>和<code>equal_range()</code>方法，但由于map中不允许多个元素带有同一个键，因此在map中，这些方法的用处不大。</p>
</blockquote>
<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>set容器定义在<code>&lt;set&gt;</code>头文件中，和map非常类似。 区别在于set保存的不是键值对，在set中，值本身就是键。如果信息没有显式的键，且希望进行排序(不包含重复)以便快速地执行插入、查找和删除，就可以考虑使用set容器来存储此类信息。</p>
<p>set提供的接口几乎和map提供的接口完全相同，主要区别在于set没有提供<code>operator[]</code>、<code>insert_or_assign()</code>和<code>try_emplace()</code>。不能修改set中元素的键/值，因为修改容器中的set元素会破坏顺序。</p>
<h3 id="multiset"><a href="#multiset" class="headerlink" title="multiset"></a>multiset</h3><p>multiset和set的关系等同于multimap和map的关系。multiset支持set的所有操作，但允许容器中同时保存多个互等的元素。这里没有提供multiset的例子，因为multiset与set和multimap太相似了。</p>
<h2 id="无序关联容器-哈希表-1"><a href="#无序关联容器-哈希表-1" class="headerlink" title="无序关联容器/哈希表"></a>无序关联容器/哈希表</h2><p>标准库支持无序关联容器或哈希表。这种容器有4个：unordered_map，unordered_multimap，unordered_set和unordered_multiset。此前讨论的map、multimap、set和multiset容器对元素进行排序，而这些新的无序版本不会对元素进行排序。</p>
<h3 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h3><p>无序关联容器也称为哈希表，这是因为它们使用了哈希函数(hash function)。哈希表的实现通常会使用某种形式的数组，数组中的每个元素都称为桶(bucket)。每个桶都有一个特定的数值索引，哈希函数将键转换为哈希值，再转换为桶索引。与这个键关联的值在桶中存储。</p>
<p>哈希函数的结果未必是唯一的。两个或多个键哈希到同一个桶索引，就称为冲突(collision)。当使用不同的键得到相同的哈希值，或把不同的哈希值转换为同一桶索引时，会发生冲突。可采用多种方法来处理冲突，例如<strong>二次重哈希</strong>和<strong>线性链</strong>等方法。使用线性链时，桶不直接包含与键关联的数据值，而包含一个指向链表的指针。这个链表包含特定桶中的所有数据值。图17-1展示了原理。<br><img src="/img/1620192765.jpg" alt></p>
<p>从中能看出，相比普通map的查找方式，这种查找方式要快得多，但查找速度完全取决于冲突次数。哈希函数的选择非常重要。不产生冲突的哈希函数称为“完美哈希”。完美哈希的查找时间是常量：常规的哈希查找时间平均接近于1，与元素数量无关。随着冲突数的增加，查找时间会增加，性能会降低。增加基本哈希表的大小，可以减少冲突，但需要考虑高速缓存的大小。</p>
<p>C++标准为指针和所有基本数据类型提供了哈希函数，还为<code>error_code</code>、<code>error_condition</code>、<code>optional</code>、<code>variant</code>、<code>bitset</code>、<code>unique_ptr</code>、<code>shared_ptr</code>、<code>type_index</code>、<code>string</code>、<code>string_view</code>、<code>vector&lt;bool&gt;</code>、<code>thread::id</code>提供了哈希函数。如果要使用的键类型没有可用的标准哈希函数，就必须实现自己的哈希函数。</p>
<p>下面的示例演示了如何编写自定义哈希函数。这个示例仅将请求传递给可用的一个标准哈希函数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntWrapper</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    IntWrapper(<span class="keyword">int</span> i) : mWrappedInt(i) &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> mWrappedint; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> mWrappedint;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>--(<span class="keyword">const</span> IntWrapper&amp; lhs, <span class="keyword">const</span> IntWrapper&amp; rhs) &#123;</span><br><span class="line">    <span class="keyword">return</span> lhs.getValue() == ths.getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为给IntWrapper编写哈希函数，应给IntWrapper编写<code>std:hash</code>模板的特例。<code>std::hash</code>模板在<code>&lt;functional&gt;</code>中定义。这个特例需要实现函数调用运算符，以计算并返回给定IntWrapper实例的哈希。对于这个示例，仅把请求传递给整数的标准哈希函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span> &#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;&gt; <span class="class"><span class="keyword">struct</span> <span class="title">hash</span>&lt;IntWrapper&gt; &#123;</span></span><br><span class="line">        <span class="keyword">using</span> argument_type = IntWrapper;</span><br><span class="line">        <span class="keyword">using</span> result_type = <span class="keyword">size_t</span>;</span><br><span class="line">        <span class="function">result_type <span class="title">operator</span> <span class="params">()</span> <span class="params">(<span class="keyword">const</span> argument_type&amp; f)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::hash&lt;<span class="keyword">int</span>&gt;()(f.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意一般不允许把任何内容放在std名称空间中，但std类模板特例是这条规则的例外。hash类模板需要两个类型定义。函数调用运算符的实现只有一行代码，它为整数的标准哈希函数创建了一个实例<code>std:hash&lt;int&gt;()</code>，然后对该实例通过参数<code>f.getValue()</code>执行函数调用运算符。</p>
<h3 id="unordered-map"><a href="#unordered-map" class="headerlink" title="unordered_map"></a>unordered_map</h3><p>unordered_map容器在<code>&lt;unordered_map&gt;</code>头文件中定义，也是一个类模板，如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>,</span></span><br><span class="line"><span class="class">    <span class="title">class</span> <span class="title">T</span>,</span></span><br><span class="line"><span class="class">    <span class="title">class</span> <span class="title">Hash</span> = <span class="title">hash</span>&lt;Key&gt;,</span></span><br><span class="line"><span class="class">    <span class="title">Class</span> <span class="title">Pred</span> = <span class="title">std</span>:</span>:equal_to&lt;Key&gt;,</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Alloc</span> = <span class="title">std</span>:</span>:allocator&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">const</span> Key，T&gt;&gt;</span><br><span class="line">&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">unordered_map</span>;</span></span><br></pre></td></tr></table></figure></p>
<p>共有5个模板参数：键类型、值类型、哈希类型、判等比较类型和分配器类型。通过后面3个参数可以分别自定义哈希函数、判等比较函数和分配器函数。通常可忽略这些参数，因为它们有默认值。建议保留默认值。最重要的参数是前两个参数。与map一样，可使用统一初始化机制来初始化unordered_map, 如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; m = &#123;</span><br><span class="line">&#123; <span class="number">1</span>, <span class="string">"Item 1"</span>&#125;,</span><br><span class="line">&#123; <span class="number">2</span>, <span class="string">"Item 2"</span>&#125;,</span><br><span class="line">&#123; <span class="number">3</span>, <span class="string">"Item 3"</span>&#125;,</span><br><span class="line">&#123; <span class="number">4</span>, <span class="string">"Item 4"</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; key &lt;&lt; <span class="string">" "</span> &lt;&lt;value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp;[key, value] : m) </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; key &lt;&lt; value &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/1620194725.jpg" alt><br><img src="/img/1620194766.jpg" alt></p>
<p>与普通的map一样，unordered_map中的所有键都应该是唯一的。</p>
<h3 id="unordered-multimap"><a href="#unordered-multimap" class="headerlink" title="unordered_multimap"></a>unordered_multimap</h3><p>unordered_multimap是允许多个元素带有同一个键的unordered_map。 两者的接口几乎相同，区别在于：</p>
<ul>
<li>unordered_multimap没有提供<code>operator[]</code>运算符和<code>at()</code>，它们的语义在多个元素可以使用同一个键的情况下没有意义。</li>
<li>在unordered_multimap上执行插入操作总是会成功。因此，添加单个元素的<code>unordered_multimap:insert()</code>方法只返回迭代器而非pair。</li>
<li>unordered_map支持<code>insert_or_assign()</code>和<code>try_emplace()</code>方法，而ordered_multimap不支持这两个方法。</li>
</ul>
<h3 id="unordered-set-unordered-multiset"><a href="#unordered-set-unordered-multiset" class="headerlink" title="unordered_set/unordered_multiset"></a>unordered_set/unordered_multiset</h3><p><code>&lt;unordered_set&gt;</code>头文件定义了unordered_set和unordered_multiset，这两者分别类似于set和multiset；区别在于它们不会对键进行排序，而且使用了哈希函数。unordered_set和unordered_map的区别和之前讨论的set和map之间的区别类似，因此这里不再赘述。</p>
<h2 id="其他容器"><a href="#其他容器" class="headerlink" title="其他容器"></a>其他容器</h2><h3 id="标准C风格数组"><a href="#标准C风格数组" class="headerlink" title="标准C风格数组"></a>标准C风格数组</h3><h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><p>可将string看成字符的顺序容器。因此，C++ string实际上是一种功能完备的顺序容器。string包含的<code>begin()</code>和<code>end()</code>方法返回string中的选代器，还包含<code>insert()</code>、<code>push_back()</code>、<code>erase()</code>、<code>size()</code>和<code>empty()</code>方法，以及基本顺序容器包含的其他所有内容。string非常接近于vector，甚至还提供了<code>reserve()</code>和<code>capacity()</code>方法。</p>
<h3 id="流"><a href="#流" class="headerlink" title="流"></a>流</h3><p>传统意义上，输入流和输出流并不是容器，因为它们并不保存元素。然而，可以把它们看成元素的序列，因而具有标准库容器的一些特性。C++流没有直接提供与标准库相关的任何方法，但是标准库提供了名为<code>istream_iterator</code>和<code>ostream_iterator</code>的特殊迭代器，用于“遍历”输入流和输出流。</p>
<h3 id="bitset-1"><a href="#bitset-1" class="headerlink" title="bitset"></a>bitset</h3><p>bitset是固定长度的位序列的抽象。一个位只能表示两个值——1和0，这两个值可以表示开关和真/假等意义。bitset还使用了设置(set)和清零(unset)两个术语。可将一个位从一个值切换(toggle)或翻转(nip)为另一个值。</p>
<p>bitset并不是真正的标准库容器：bitset的大小固定，没有对元素类型进行模板化，也不支持迭代。</p>
<h4 id="bitset基础"><a href="#bitset基础" class="headerlink" title="bitset基础"></a>bitset基础</h4><p>bitset定义在<code>&lt;bitset&gt;</code>头文件中，根据保存的位数进行模板化。默认构造函数将bitset的所有字段初始化为0。另一个构造函数根据由0和1字符组成的字符串创建bitset。可通过<code>set()</code>、<code>reset()</code>和<code>flip()</code>方法改变单个位的值，通过重载的<code>operator[]</code>运算符可访问和设置单个字段的值。</p>
<p>注意对非const对象应用<code>operator[]</code>会返回一个代理对象，可为这个代理对象赋予一个布尔值，调用<code>flip()</code>或<code>~</code>取反。还可通过<code>test()</code>方法访问单独字段。此外，通过普通的插入和抽取运算符可以流式处理<code>bitset</code>，<code>bitset</code>以包含0和1字符的字符串形式进行流式处理。</p>
<p>下面是一个简单例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bitset</span>&lt;10&gt; myBitset;</span><br><span class="line">myBitset.<span class="built_in">set</span>(<span class="number">3</span>);</span><br><span class="line">myBitset.<span class="built_in">set</span>(<span class="number">6</span>);</span><br><span class="line">myBitset[<span class="number">8</span>] = <span class="literal">true</span>;</span><br><span class="line">myBitset[<span class="number">9</span>] = myBitset[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (myBitset.test (<span class="number">3</span>)) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Bit 3 is set!"</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; myBitset &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="按位运算符"><a href="#按位运算符" class="headerlink" title="按位运算符"></a>按位运算符</h4><p>除基本的位操作外，bitset还实现了所有的按位运算符：<code>&amp;</code>、<code>|</code>、<code>^</code>、<code>~</code>、<code>&lt;&lt;</code>、<code>&gt;&gt;</code>、<code>&amp;=</code>、<code>|=</code>、<code>^=</code>、<code>&lt;&lt;=</code>和<code>&gt;&gt;=</code>。这些运算符的行为和操作真正的位序列相同。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> str1 = <span class="string">"0011001100"</span>;</span><br><span class="line"><span class="keyword">auto</span> str2 - <span class="string">"0000111100"</span>;</span><br><span class="line"><span class="built_in">bitset</span>&lt;10&gt; bitsOne(stri);</span><br><span class="line"><span class="built_in">bitset</span>&lt;10&gt; bitsTwo(str2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> bitsThree = bitsOne &amp; bitsTwo;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; bitsThree &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">bitsThree &lt;&lt;=<span class="number">4</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; bitsThree &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/C/" rel="tag"># C++</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/05/02/cpp高级编程 笔记4/" rel="next" title="C++高级编程 第四版 笔记4">
                <i class="fa fa-chevron-left"></i> C++高级编程 第四版 笔记4
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/05/09/cpp高级编程 笔记7/" rel="prev" title="C++高级编程 第四版 笔记7">
                C++高级编程 第四版 笔记7 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/header.jpg" alt="Hao Yu">
            
              <p class="site-author-name" itemprop="name">Hao Yu</p>
              <p class="site-description motion-element" itemprop="description">Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author</p>
          </div>
          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">327</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>
        	<audio controls="controls" loop="loop" preload="auto" src="/resource/xiaomeihao.mp3">
	        </audio>
	

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yuhao0102" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:yuh18@mails.tsinghua.edu.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#C-运算符重载"><span class="nav-number">1.</span> <span class="nav-text">C++运算符重载</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#运算符重载概述"><span class="nav-number">1.1.</span> <span class="nav-text">运算符重载概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#重载运算符的原因"><span class="nav-number">1.1.1.</span> <span class="nav-text">重载运算符的原因</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#运算符重载的限制"><span class="nav-number">1.1.2.</span> <span class="nav-text">运算符重载的限制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#运算符重载的选择"><span class="nav-number">1.1.3.</span> <span class="nav-text">运算符重载的选择</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#方法还是全局函数"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">方法还是全局函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#选择参数类型"><span class="nav-number">1.1.3.2.</span> <span class="nav-text">选择参数类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#选择返回类型"><span class="nav-number">1.1.3.3.</span> <span class="nav-text">选择返回类型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#不应重载的运算符"><span class="nav-number">1.1.4.</span> <span class="nav-text">不应重载的运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可重载运算符小结"><span class="nav-number">1.1.5.</span> <span class="nav-text">可重载运算符小结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#右值引用"><span class="nav-number">1.1.6.</span> <span class="nav-text">右值引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关系运算符"><span class="nav-number">1.1.7.</span> <span class="nav-text">关系运算符</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#重载算术运算符"><span class="nav-number">1.2.</span> <span class="nav-text">重载算术运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#重载一元负号和一元正号运算符"><span class="nav-number">1.2.1.</span> <span class="nav-text">重载一元负号和一元正号运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重载递增和递减运算符"><span class="nav-number">1.2.2.</span> <span class="nav-text">重载递增和递减运算符</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#重载按位运算符和二元逻辑运算符"><span class="nav-number">1.3.</span> <span class="nav-text">重载按位运算符和二元逻辑运算符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#重载插入运算符和提取运算符"><span class="nav-number">1.4.</span> <span class="nav-text">重载插入运算符和提取运算符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#重载下标运算符"><span class="nav-number">1.5.</span> <span class="nav-text">重载下标运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#通过operator-提供只读访问"><span class="nav-number">1.5.1.</span> <span class="nav-text">通过operator[]提供只读访问</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#重载函数调用运算符"><span class="nav-number">1.6.</span> <span class="nav-text">重载函数调用运算符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#重载解除引用运算符"><span class="nav-number">1.7.</span> <span class="nav-text">重载解除引用运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#实现operator"><span class="nav-number">1.7.1.</span> <span class="nav-text">实现operator*</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实现operator-gt"><span class="nav-number">1.7.2.</span> <span class="nav-text">实现operator-&gt;</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#operator-和operator-gt-的含义"><span class="nav-number">1.7.3.</span> <span class="nav-text">operator.和operator-&gt;的含义</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#编写转换运算符"><span class="nav-number">1.8.</span> <span class="nav-text">编写转换运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用显式转换运算符解决多义性问题"><span class="nav-number">1.8.1.</span> <span class="nav-text">使用显式转换运算符解决多义性问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#重载内存分配和内存释放运算符"><span class="nav-number">1.9.</span> <span class="nav-text">重载内存分配和内存释放运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#new和delete的工作原理"><span class="nav-number">1.9.1.</span> <span class="nav-text">new和delete的工作原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#new表达式和operator-new"><span class="nav-number">1.9.1.1.</span> <span class="nav-text">new表达式和operator new</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#delete表达式和operator-delete"><span class="nav-number">1.9.1.2.</span> <span class="nav-text">delete表达式和operator delete</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#显式地删除-默认化operator-new和operator-delete"><span class="nav-number">1.9.2.</span> <span class="nav-text">显式地删除/默认化operator new和operator delete</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重载带有额外参数的operator-new和operator-delete"><span class="nav-number">1.9.3.</span> <span class="nav-text">重载带有额外参数的operator new和operator delete</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C-标准库概述"><span class="nav-number">2.</span> <span class="nav-text">C++标准库概述</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#编码原则"><span class="nav-number">2.1.</span> <span class="nav-text">编码原则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-标准库概述-1"><span class="nav-number">2.2.</span> <span class="nav-text">C++标准库概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#字符串"><span class="nav-number">2.2.1.</span> <span class="nav-text">字符串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#正则表达式"><span class="nav-number">2.2.2.</span> <span class="nav-text">正则表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#I-0流"><span class="nav-number">2.2.3.</span> <span class="nav-text">I/0流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#智能指针"><span class="nav-number">2.2.4.</span> <span class="nav-text">智能指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#异常"><span class="nav-number">2.2.5.</span> <span class="nav-text">异常</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数学工具"><span class="nav-number">2.2.6.</span> <span class="nav-text">数学工具</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#时间工具"><span class="nav-number">2.2.7.</span> <span class="nav-text">时间工具</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#容器"><span class="nav-number">2.2.8.</span> <span class="nav-text">容器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#vector"><span class="nav-number">2.2.8.1.</span> <span class="nav-text">vector</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#list"><span class="nav-number">2.2.8.2.</span> <span class="nav-text">list</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#forward-list"><span class="nav-number">2.2.8.3.</span> <span class="nav-text">forward_list</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#deque"><span class="nav-number">2.2.8.4.</span> <span class="nav-text">deque</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#array"><span class="nav-number">2.2.8.5.</span> <span class="nav-text">array</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#queue"><span class="nav-number">2.2.8.6.</span> <span class="nav-text">queue</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#priority-queue"><span class="nav-number">2.2.8.7.</span> <span class="nav-text">priority_queue</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#stack"><span class="nav-number">2.2.8.8.</span> <span class="nav-text">stack</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#set和multiset"><span class="nav-number">2.2.8.9.</span> <span class="nav-text">set和multiset</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#map和multimap"><span class="nav-number">2.2.8.10.</span> <span class="nav-text">map和multimap</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#无序关联容器-哈希表"><span class="nav-number">2.2.8.11.</span> <span class="nav-text">无序关联容器/哈希表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#bitset"><span class="nav-number">2.2.8.12.</span> <span class="nav-text">bitset</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#标准库容器小结"><span class="nav-number">2.2.8.13.</span> <span class="nav-text">标准库容器小结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#算法"><span class="nav-number">2.2.9.</span> <span class="nav-text">算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#非修改顺序算法"><span class="nav-number">2.2.9.1.</span> <span class="nav-text">非修改顺序算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#修改序列算法"><span class="nav-number">2.2.9.2.</span> <span class="nav-text">修改序列算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#操作算法"><span class="nav-number">2.2.9.3.</span> <span class="nav-text">操作算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#交换算法"><span class="nav-number">2.2.9.4.</span> <span class="nav-text">交换算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分区算法"><span class="nav-number">2.2.9.5.</span> <span class="nav-text">分区算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#排序算法"><span class="nav-number">2.2.9.6.</span> <span class="nav-text">排序算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二叉树搜索算法"><span class="nav-number">2.2.9.7.</span> <span class="nav-text">二叉树搜索算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#集合算法"><span class="nav-number">2.2.9.8.</span> <span class="nav-text">集合算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#堆算法"><span class="nav-number">2.2.9.9.</span> <span class="nav-text">堆算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#最大-最小算法"><span class="nav-number">2.2.9.10.</span> <span class="nav-text">最大/最小算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数值处理算法"><span class="nav-number">2.2.9.11.</span> <span class="nav-text">数值处理算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#置换算法"><span class="nav-number">2.2.9.12.</span> <span class="nav-text">置换算法</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#理解容器与迭代器"><span class="nav-number">3.</span> <span class="nav-text">理解容器与迭代器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#容器概述"><span class="nav-number">3.1.</span> <span class="nav-text">容器概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#对元素的要求"><span class="nav-number">3.1.1.</span> <span class="nav-text">对元素的要求</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#迭代器"><span class="nav-number">3.1.2.</span> <span class="nav-text">迭代器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#顺序容器"><span class="nav-number">3.2.</span> <span class="nav-text">顺序容器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#vector-1"><span class="nav-number">3.2.1.</span> <span class="nav-text">vector</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#vector概述"><span class="nav-number">3.2.1.1.</span> <span class="nav-text">vector概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#固定长度的vector"><span class="nav-number">3.2.1.2.</span> <span class="nav-text">固定长度的vector</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#动态长度的vector"><span class="nav-number">3.2.1.3.</span> <span class="nav-text">动态长度的vector</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#构造函数和析构函数"><span class="nav-number">3.2.1.4.</span> <span class="nav-text">构造函数和析构函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#vector的复制和赋值"><span class="nav-number">3.2.1.5.</span> <span class="nav-text">vector的复制和赋值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#vector的比较"><span class="nav-number">3.2.1.6.</span> <span class="nav-text">vector的比较</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#vector迭代器"><span class="nav-number">3.2.1.7.</span> <span class="nav-text">vector迭代器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#访问对象元素中的字段"><span class="nav-number">3.2.1.8.</span> <span class="nav-text">访问对象元素中的字段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#const-iterator"><span class="nav-number">3.2.1.9.</span> <span class="nav-text">const_iterator</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#迭代器还是索引"><span class="nav-number">3.2.1.10.</span> <span class="nav-text">迭代器还是索引?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#在vector中存储引用"><span class="nav-number">3.2.1.11.</span> <span class="nav-text">在vector中存储引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#添加和删除元素"><span class="nav-number">3.2.1.12.</span> <span class="nav-text">添加和删除元素</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#移动语义"><span class="nav-number">3.2.1.13.</span> <span class="nav-text">移动语义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#emplace操作"><span class="nav-number">3.2.1.14.</span> <span class="nav-text">emplace操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#算法复杂度和迭代器失效"><span class="nav-number">3.2.1.15.</span> <span class="nav-text">算法复杂度和迭代器失效</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#vector内存分配方案"><span class="nav-number">3.2.1.16.</span> <span class="nav-text">vector内存分配方案</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#大小和容量"><span class="nav-number">3.2.1.17.</span> <span class="nav-text">大小和容量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#预留容量"><span class="nav-number">3.2.1.18.</span> <span class="nav-text">预留容量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#直接访问数据"><span class="nav-number">3.2.1.19.</span> <span class="nav-text">直接访问数据</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#vector特化"><span class="nav-number">3.2.2.</span> <span class="nav-text">vector特化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#deque-1"><span class="nav-number">3.2.3.</span> <span class="nav-text">deque</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#list-1"><span class="nav-number">3.2.4.</span> <span class="nav-text">list</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#访问元素"><span class="nav-number">3.2.4.1.</span> <span class="nav-text">访问元素</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#迭代器-1"><span class="nav-number">3.2.4.2.</span> <span class="nav-text">迭代器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#添加和删除元素-1"><span class="nav-number">3.2.4.3.</span> <span class="nav-text">添加和删除元素</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#list大小"><span class="nav-number">3.2.4.4.</span> <span class="nav-text">list大小</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#list特殊操作"><span class="nav-number">3.2.4.5.</span> <span class="nav-text">list特殊操作</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#串联"><span class="nav-number">3.2.4.5.1.</span> <span class="nav-text">串联</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#更高效的算法版本"><span class="nav-number">3.2.4.5.2.</span> <span class="nav-text">更高效的算法版本</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#forward-list-1"><span class="nav-number">3.2.5.</span> <span class="nav-text">forward_list</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#array-1"><span class="nav-number">3.2.6.</span> <span class="nav-text">array</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#容器适配器"><span class="nav-number">3.3.</span> <span class="nav-text">容器适配器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#queue-1"><span class="nav-number">3.3.1.</span> <span class="nav-text">queue</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#queue操作"><span class="nav-number">3.3.1.1.</span> <span class="nav-text">queue操作</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#priority-queue-1"><span class="nav-number">3.3.2.</span> <span class="nav-text">priority_queue</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#priority-queue提供的操作"><span class="nav-number">3.3.2.1.</span> <span class="nav-text">priority_queue提供的操作</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#stack-1"><span class="nav-number">3.3.3.</span> <span class="nav-text">stack</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#stack操作"><span class="nav-number">3.3.3.1.</span> <span class="nav-text">stack操作</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#有序关联容器"><span class="nav-number">3.4.</span> <span class="nav-text">有序关联容器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#pair工具类"><span class="nav-number">3.4.1.</span> <span class="nav-text">pair工具类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#map"><span class="nav-number">3.4.2.</span> <span class="nav-text">map</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#构建map"><span class="nav-number">3.4.2.1.</span> <span class="nav-text">构建map</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#插入元素"><span class="nav-number">3.4.2.2.</span> <span class="nav-text">插入元素</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#insert-方法"><span class="nav-number">3.4.2.3.</span> <span class="nav-text">insert()方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#insert-or-assign-方法"><span class="nav-number">3.4.2.4.</span> <span class="nav-text">insert_or_assign()方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#operator"><span class="nav-number">3.4.2.5.</span> <span class="nav-text">operator[]</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#emplace方法"><span class="nav-number">3.4.2.6.</span> <span class="nav-text">emplace方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#map迭代器"><span class="nav-number">3.4.2.7.</span> <span class="nav-text">map迭代器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#查找元素"><span class="nav-number">3.4.2.8.</span> <span class="nav-text">查找元素</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#删除元素"><span class="nav-number">3.4.2.9.</span> <span class="nav-text">删除元素</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#节点"><span class="nav-number">3.4.2.10.</span> <span class="nav-text">节点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#multimap"><span class="nav-number">3.4.3.</span> <span class="nav-text">multimap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#set"><span class="nav-number">3.4.4.</span> <span class="nav-text">set</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#multiset"><span class="nav-number">3.4.5.</span> <span class="nav-text">multiset</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#无序关联容器-哈希表-1"><span class="nav-number">3.5.</span> <span class="nav-text">无序关联容器/哈希表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#哈希函数"><span class="nav-number">3.5.1.</span> <span class="nav-text">哈希函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#unordered-map"><span class="nav-number">3.5.2.</span> <span class="nav-text">unordered_map</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#unordered-multimap"><span class="nav-number">3.5.3.</span> <span class="nav-text">unordered_multimap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#unordered-set-unordered-multiset"><span class="nav-number">3.5.4.</span> <span class="nav-text">unordered_set/unordered_multiset</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#其他容器"><span class="nav-number">3.6.</span> <span class="nav-text">其他容器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#标准C风格数组"><span class="nav-number">3.6.1.</span> <span class="nav-text">标准C风格数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#string"><span class="nav-number">3.6.2.</span> <span class="nav-text">string</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#流"><span class="nav-number">3.6.3.</span> <span class="nav-text">流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bitset-1"><span class="nav-number">3.6.4.</span> <span class="nav-text">bitset</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#bitset基础"><span class="nav-number">3.6.4.1.</span> <span class="nav-text">bitset基础</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#按位运算符"><span class="nav-number">3.6.4.2.</span> <span class="nav-text">按位运算符</span></a></li></ol></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>
  <div id="DvelopmentTarget">     
  </div>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart" aria-hidden="false"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>

  
</div>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_uv"> 
  本站访客数<span id="busuanzi_value_site_uv"></span>人次
</span>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  


  <script type="text/javascript" src="/js/src/love.js"></script>

</body>
</html>
