<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zn-ch">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-center-simple.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Linux,">










<meta name="description" content="线程线程概念典型的UNIX进程可以看成只有一个控制线程：一个进程在某一时刻只能做一件事情。每个线程处理各自独立的任务有很多好处，通过为每种事件类型分配单独的处理线程，可以简化处理异步事件的代码。每个线程在进行事件处理时可以采用同步编程模式，同步编程模式要比异步编程模式简单得多。 多个进程必须使用操作系统提供的复杂机制才能实现内存和文件描述符的共享，而多个线程自动地可以访问相同的存储地址空间和文件播">
<meta name="keywords" content="Linux">
<meta property="og:type" content="article">
<meta property="og:title" content="UNIX高级编程 笔记5">
<meta property="og:url" content="http://yoursite.com/2021/05/29/UNIX高级编程 笔记5/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="线程线程概念典型的UNIX进程可以看成只有一个控制线程：一个进程在某一时刻只能做一件事情。每个线程处理各自独立的任务有很多好处，通过为每种事件类型分配单独的处理线程，可以简化处理异步事件的代码。每个线程在进行事件处理时可以采用同步编程模式，同步编程模式要比异步编程模式简单得多。 多个进程必须使用操作系统提供的复杂机制才能实现内存和文件描述符的共享，而多个线程自动地可以访问相同的存储地址空间和文件播">
<meta property="og:locale" content="zn-ch">
<meta property="og:image" content="http://yoursite.com/img/1622445555.jpg">
<meta property="og:updated_time" content="2021-06-01T12:59:30.019Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="UNIX高级编程 笔记5">
<meta name="twitter:description" content="线程线程概念典型的UNIX进程可以看成只有一个控制线程：一个进程在某一时刻只能做一件事情。每个线程处理各自独立的任务有很多好处，通过为每种事件类型分配单独的处理线程，可以简化处理异步事件的代码。每个线程在进行事件处理时可以采用同步编程模式，同步编程模式要比异步编程模式简单得多。 多个进程必须使用操作系统提供的复杂机制才能实现内存和文件描述符的共享，而多个线程自动地可以访问相同的存储地址空间和文件播">
<meta name="twitter:image" content="http://yoursite.com/img/1622445555.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2021/05/29/UNIX高级编程 笔记5/">





  <title>UNIX高级编程 笔记5 | Hao Yu's blog</title>
  








 
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zn-ch">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hao Yu's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">The program monkey was eaten by the siege lion.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-mybetterhalf">
          <a href="/mybetterhalf/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>
            
            mybetterhalf
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="Searching..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/05/29/UNIX高级编程 笔记5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">UNIX高级编程 笔记5</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-05-29T16:20:00+08:00">
                2021-05-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><h2 id="线程概念"><a href="#线程概念" class="headerlink" title="线程概念"></a>线程概念</h2><p>典型的UNIX进程可以看成只有一个控制线程：一个进程在某一时刻只能做一件事情。每个线程处理各自独立的任务有很多好处，通过为每种事件类型分配单独的处理线程，可以简化处理异步事件的代码。每个线程在进行事件处理时可以采用同步编程模式，同步编程模式要比异步编程模式简单得多。</p>
<p>多个进程必须使用操作系统提供的复杂机制才能实现内存和文件描述符的共享，而多个线程自动地可以访问相同的存储地址空间和文件播述符。</p>
<p>每个线程都包含有表示执行环境所必需的信息，其中包括进程中标识线程的线程ID、一组寄存器值、栈、调度优先级和策略、信号屏蔽字、errno变量以及线程私有数据。一个进程的所有信息对该进程的所有线程都是共享的，包括可执行程序的代码、程序的全局内存和堆内存、栈以及文件描述符。线程接口也称为“pthread”或“POSIX线程”。</p>
<p>POSIX线程的功能测试宏是<code>_POSTX_THREADS</code>。应用程序可以把这一个宏用于<code>#ifdef</code>测试，从而在编译时确定是否支持线程：也可以把<code>_SC_THREADS</code>常数用于调用<code>sysconf</code>函数，进而在运行时确定是否支持线程。</p>
<h2 id="线程标识"><a href="#线程标识" class="headerlink" title="线程标识"></a>线程标识</h2><p>就像每个进程有一个进程ID一样，每个线程也有一个线程ID。进程ID在整个系统中是唯一的，但线程ID不同，线程ID只有在它所属的进程上下文中才有意义。进程ID是用<code>pid_t</code>数据类型来表示的，是一个非负整数。线程ID是用<code>pthread_t</code>数据类型来表示的，实现的时候可以用一个结构来代表<code>pthread_t</code>数据类型，所以可移植的操作系统实现不能把它作为整数处理。因此必须使用一个函数来对两个线程ID进行比较。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_equal</span> <span class="params">(<span class="keyword">pthread_t</span> tid1, <span class="keyword">pthread_t</span> tid2)</span></span>;</span><br><span class="line"><span class="comment">// 返回值。若相等，返回非0数值；否则，返回0</span></span><br></pre></td></tr></table></figure></p>
<p>用结构表示<code>pthread_t</code>数据类型的后果是不能用一种可移植的方式打印该数据类型的值。在程序调试过程中打印线程ID有时是非常有用的， 而在其他情况下通常不需要打印线程ID。</p>
<p>线程可以通过调用<code>pthread_self</code>函数获得自身的线程ID。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="keyword">pthread_t</span> pthzead_self (<span class="keyword">void</span>);</span><br><span class="line"><span class="comment">// 返回值，调用线程的线程ID</span></span><br></pre></td></tr></table></figure></p>
<p>当线程需要识别以线程ID作为标识的数据结构时，<code>pthread_self</code>函数可以与<code>pthread_equal</code>函数一起使用。例如，主线程可能把工作任务放在一个队列中，用线程ID来控制每个工作线程处理哪些作业。主线程把新的作业放到一个工作队列中，由3个工作线程组成的线程池从队列中移出作业。主线程不允许每个线程任意处理从队列顶端取出的作业，而是由主线程控制作业的分配，主线程会在每个待处理作业的结构中放置处理该作业的线程ID，每个工作线程只能移出标有自己线程ID的作业。</p>
<h2 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h2><p>在传统UNIX进程模型中，每个进程只有一个控制线程。从概念上讲，这与基于线程的模型中每个进程只包含一个线程是相同的。在POSIX线程(pthread)的情况下，程序开始运行时，它也是以单进程中的单个控制线程启动的。在创建多个控制线程以前，程序的行为与传统的进程并没有什么区别。新增的线程可以通过调用<code>pthread_create</code>函数创建。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_create</span> <span class="params">(<span class="keyword">pthread_t</span> *<span class="keyword">restrict</span> tidp, <span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *<span class="keyword">restrict</span> attr,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">void</span> *(*start_rtn) (<span class="keyword">void</span> *), <span class="keyword">void</span> *<span class="keyword">restrict</span> arg)</span></span>;</span><br><span class="line"><span class="comment">// 返回值，若成功，返回0；否则，返回错误编号</span></span><br></pre></td></tr></table></figure></p>
<p>当<code>pthread_create</code>成功返回时， 新创建线程的线程ID会被设置成<code>tidp</code>指向的内存单元。<code>attr</code>参数用于定制各种不同的线程属性。新创建的线程从<code>start_rtn</code>函数的地址开始运行， 该函数只有一个无类型指针参数<code>arg</code>。如果需要向<code>start_rtn</code>函数传递的参数有一个以上，那么需要把这些参数放到一个结构中，然后把这个结构的地址作为<code>arg</code>参数传入。</p>
<p>线程创建时并不能保证哪个线程会先运行，是新创建的线程，还是调用线程。新创建的线程可以访问进程的地址空间，并且继承调用线程的浮点环境和信号屏蔽字，但是该线程的挂起信号集会被清除。</p>
<p>注意，phread函数在调用失败时通常会返回错误码，它们并不像其他的POSIX函数–样设置errno。每个线程都提供errno的副本，这只是为了与使用errno的现有函数兼容。在线程中，从函数中返回错误码更为清晰整洁，不需要依赖那些随着函数执行不断变化的全局状态，这样可以把错误的范围限制在引起出错的函数中。</p>
<p>可以写一个小的测试程序来完成打印线程ID任务。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_t</span> ntid;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">printids(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">pid_t</span>           pid;</span><br><span class="line">        <span class="keyword">pthread_t</span>       tid;</span><br><span class="line"></span><br><span class="line">        pid = getpid();</span><br><span class="line">        tid = pthread_self();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s pid %lu tid %lu (0x%lx)\n"</span>, s, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)pid,</span><br><span class="line">          (<span class="keyword">unsigned</span> <span class="keyword">long</span>)tid, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)tid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *</span><br><span class="line">thr_fn(<span class="keyword">void</span> *arg)</span><br><span class="line">&#123;</span><br><span class="line">        printids(<span class="string">"new thread: "</span>);</span><br><span class="line">        <span class="keyword">return</span>((<span class="keyword">void</span> *)<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">        err = pthread_create(&amp;ntid, <span class="literal">NULL</span>, thr_fn, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (err != <span class="number">0</span>)</span><br><span class="line">            err_exit(err, <span class="string">"can't create thread"</span>);</span><br><span class="line">        printids(<span class="string">"main thread:"</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个实例有两个特别之处，需要处理主线程和新线程之间的竞争。第一个特别之处在于，主线程需要休眠，如果主线程不休眼，它就可能会退出，这样新线程还没有机会运行，整个进程可能就已经终止了，这种行为特征依赖于操作系统中的线程实现和调度算法。</p>
<p>第二个特别之处在于新线程是通过调用<code>pthread_self</code>函数获取自己的线程ID的，而不是从共享内存中读出的，或者从线程的启动例程中以参数的形式接收到的。<code>pthread_create</code>函数会通过第一个参数(<code>tidp</code>)返回新建线程的线程ID。在这个例子中，主线程把新线程ID存放在<code>ntid</code>中，但是新建的线程并不能安全地使用它，如果新线程在主线程调用<code>pthread_create</code>返回之前就运行了，那么新线程看到的是未经初始化的<code>ntid</code>的内容，这个内容并不是正确的线程ID。</p>
<p>运行程序，得到：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out</span><br><span class="line">main thread: pid 20075 tid 1 (0x1)</span><br><span class="line">new thread: p1d 20075 tid 2 (0x2)</span><br></pre></td></tr></table></figure></p>
<p>正如我们期望的，两个线程的进程ID相同，但线程ID不同。在FreeBSD上运行程序，得到：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out</span><br><span class="line">main thread: pid 37396 tid 673190208 (0x28201140)</span><br><span class="line">new thread: pid 37396 tid 673200320 (0x28217140)</span><br></pre></td></tr></table></figure></p>
<p>也如我们期望的，两个线程有相同的进程ID。把它们转化成十六进制，就像前面提到的，FreeBSD使用指向线程数据结构的指针作为它的线程ID。</p>
<h2 id="线程终止"><a href="#线程终止" class="headerlink" title="线程终止"></a>线程终止</h2><p>如果进程中的任意线程调用了<code>exit</code>、<code>_Exit</code>或者<code>_exit</code>，那么整个进程就会终止。与此相类似，如果默认的动作是终止进程，那么，发送到线程的信号就会终止整个进程。</p>
<p>单个线程可以通过3种方式退出，因此可以在不终止整个进程的情况下，停止它的控制流。</p>
<ol>
<li>线程可以简单地从启动例程中返回，返回值是线程的退出码。</li>
<li>线程可以被同一进程中的其他线程取消。</li>
<li>线程调用<code>pthread_exit</code>。</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line">void pthread_exit (void *rval_ptr):</span><br></pre></td></tr></table></figure>
<p><code>rval_ptr</code>参数是一个无类型指针，与传给启动例程的单个参数类似。进程中的其他线程也可以通过调用<code>pthread_join</code>函数访问到这个指针。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_join</span> <span class="params">(<span class="keyword">pthread_t</span> thread_void **rval_ptr)</span></span>;</span><br><span class="line"><span class="comment">// 返回值，若成功，返回0；否则，返回错误编号</span></span><br></pre></td></tr></table></figure></p>
<p>调用线程将一直阻塞，直到指定的线程调用<code>pthread_exit</code>。从启动例程中返回或者被取消。如果线程简单地从它的启动例程返回，<code>rval_ptr</code>就包含返回码。如果线程被取消，由<code>rval_ptr</code>指定的内存单元就设置为<code>PTHREAD_CANCELED</code>。</p>
<p>可以通过调用<code>pthread_join</code>自动把线程置于分离状态，这样资源就可以恢复。如果线程已经处于分离状态，<code>pthread_join</code>调用就会失败，返回EINVAL，尽管这种行为是与具体实现相关的。</p>
<p>如果对线程的返回值并不感兴趣，那么可以把<code>rval_ptr</code>设置为NULL。在这种情况下，调用<code>pthread_join</code>函数可以等待指定的线程终止，但并不获取线程的终止状态。</p>
<p>程序展示了如何获取已终止的线程的退出码。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *</span><br><span class="line">thr_fn1(<span class="keyword">void</span> *arg)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"thread 1 returning\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>((<span class="keyword">void</span> *)<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *</span><br><span class="line">thr_fn2(<span class="keyword">void</span> *arg)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"thread 2 exiting\n"</span>);</span><br><span class="line">        pthread_exit((<span class="keyword">void</span> *)<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">int</span>                     err;</span><br><span class="line">        <span class="keyword">pthread_t</span>       tid1, tid2;</span><br><span class="line">        <span class="keyword">void</span>            *tret;</span><br><span class="line"></span><br><span class="line">        err = pthread_create(&amp;tid1, <span class="literal">NULL</span>, thr_fn1, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (err != <span class="number">0</span>)</span><br><span class="line">                err_exit(err, <span class="string">"can't create thread 1"</span>);</span><br><span class="line">        err = pthread_create(&amp;tid2, <span class="literal">NULL</span>, thr_fn2, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (err != <span class="number">0</span>)</span><br><span class="line">                err_exit(err, <span class="string">"can't create thread 2"</span>);</span><br><span class="line">        err = pthread_join(tid1, &amp;tret);</span><br><span class="line">        <span class="keyword">if</span> (err != <span class="number">0</span>)</span><br><span class="line">                err_exit(err, <span class="string">"can't join with thread 1"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"thread 1 exit code %ld\n"</span>, (<span class="keyword">long</span>)tret);</span><br><span class="line">        err = pthread_join(tid2, &amp;tret);</span><br><span class="line">        <span class="keyword">if</span> (err != <span class="number">0</span>)</span><br><span class="line">                err_exit(err, <span class="string">"can't join with thread 2"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"thread 2 exit code %ld\n"</span>, (<span class="keyword">long</span>)tret);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行程序，得到的结果是：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out</span><br><span class="line">thread 1 returning</span><br><span class="line">thread 2 exiting</span><br><span class="line">thread 1 <span class="built_in">exit</span> code 1</span><br><span class="line">thread 2 <span class="built_in">exit</span> code 2</span><br></pre></td></tr></table></figure></p>
<p>可以看到，当一个线程通过调用<code>pthread_exit</code>退出或者简单地从启动例程中返回时，进程中的其他线程可以通过调用<code>pthread_join</code>函数获得该线程的退出状态。</p>
<p><code>pthread_create</code>和<code>pthread_exit</code>函数的无类型指针参数可以传递的值不止一个，这个指针可以传递包含复杂信息的结构的地址，但是注意，这个结构所使用的内存在调用者完成调用以后必须仍然是有效的。例如，在调用线程的栈上分配了该结构，那么其他的线程在使用这个结构时内存内容可能已经改变了。又如，线程在自己的栈上分配了一个结构，然后把指向这个结构的指针传给<code>pthread_exit</code>，那么调用<code>pthread_join</code>的线程试图使用该结构时，这个核有可能已经被撤销，这块内存也已另作他用。</p>
<p>程序给出了用自动变量(分配在栈上)作为<code>pthread_exit</code>的参数时出现的问题。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">foo</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> a, b, c, d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">printfoo(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">const</span> struct foo *fp)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"  structure at 0x%lx\n"</span>, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)fp);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"  foo.a = %d\n"</span>, fp-&gt;a);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"  foo.b = %d\n"</span>, fp-&gt;b);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"  foo.c = %d\n"</span>, fp-&gt;c);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"  foo.d = %d\n"</span>, fp-&gt;d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *</span><br><span class="line">thr_fn1(<span class="keyword">void</span> *arg)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">foo</span>      <span class="title">foo</span> = &#123;</span><span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">        printfoo(<span class="string">"thread 1:\n"</span>, &amp;foo);</span><br><span class="line">        pthread_exit((<span class="keyword">void</span> *)&amp;foo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *</span><br><span class="line">thr_fn2(<span class="keyword">void</span> *arg)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"thread 2: ID is %lu\n"</span>, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)pthread_self());</span><br><span class="line">        pthread_exit((<span class="keyword">void</span> *)<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">int</span>             err;</span><br><span class="line">        <span class="keyword">pthread_t</span>       tid1, tid2;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">foo</span>      *<span class="title">fp</span>;</span></span><br><span class="line"></span><br><span class="line">        err = pthread_create(&amp;tid1, <span class="literal">NULL</span>, thr_fn1, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (err != <span class="number">0</span>)</span><br><span class="line">                err_exit(err, <span class="string">"can't create thread 1"</span>);</span><br><span class="line">        err = pthread_join(tid1, (<span class="keyword">void</span> *)&amp;fp);</span><br><span class="line">        <span class="keyword">if</span> (err != <span class="number">0</span>)</span><br><span class="line">                err_exit(err, <span class="string">"can't join with thread 1"</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"parent starting second thread\n"</span>);</span><br><span class="line">        err = pthread_create(&amp;tid2, <span class="literal">NULL</span>, thr_fn2, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (err != <span class="number">0</span>)</span><br><span class="line">                err_exit(err, <span class="string">"can't create thread 2"</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        printfoo(<span class="string">"parent:\n"</span>, fp);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在Linux上运行此程序，得到：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out</span><br><span class="line">thread 1:</span><br><span class="line">structure at 0x7f2c83682ed0</span><br><span class="line">foo.a = 1</span><br><span class="line">foo.b = 2</span><br><span class="line">foo.c = 3</span><br><span class="line">foo.d = 4</span><br><span class="line">parent starting second thread</span><br><span class="line">thread 2: ID is 139829159933636</span><br><span class="line">parent:</span><br><span class="line">structure at 0x7t2c83682ed0</span><br><span class="line">foo.a = -2090321472</span><br><span class="line">foo.b = 32556</span><br><span class="line">foo.c = 1</span><br><span class="line">foo.d = 0</span><br></pre></td></tr></table></figure></p>
<p>可以看到，当主线程访问这个结构时，结构的内容已经改变了。注意第二个线程(tid2)的栈是如何覆盖第一个线程的栈的。为了解决这个问题，可以使用全局结构，或者用<code>malloc</code>函数分配结构。</p>
<p>线程可以通过调用pthread_cancel函数来请求取消同一进程中的其他线程。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cancel</span> <span class="params">(<span class="keyword">pthread_t</span> tid)</span></span>;</span><br><span class="line"><span class="comment">// 返回值，若成功，返回0；否则，返回错误编号</span></span><br></pre></td></tr></table></figure></p>
<p>在默认情况下，<code>pthread_cancel</code>函数会使得由<code>tid</code>标识的线程的行为表现为如同调用了参数为<code>PTHREAD_CANCELED</code>的<code>pthread_exit</code>函数，但是，线程可以选择忽略取消或者控制如何被取消。注意<code>pthread_cancel</code>并不等待线程终止，它仅仅提出请求。</p>
<p>线程可以安排它退出时需要调用的函数，这与进程在退出时可以用<code>atexit</code>函数安排退出是类似的。这样的函数称为<strong>线程清理处理程序</strong>(thread cleanup handier)，一个线程可以建立多个清理处理程序。处理程序记录在栈中，也就是说，它们的执行顺序与它们注册时相反。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_eleanup_push</span> <span class="params">(<span class="keyword">void</span> (*rtn) (<span class="keyword">void</span> *), <span class="keyword">void</span> *arg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_cleanup_pop</span> <span class="params">(<span class="keyword">int</span> execute)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>当线程执行以下动作时，清理函数<code>rm</code>是由<code>pthread_cleanup_push</code>函数调度的，调用时只有一个参数<code>arg</code>：</p>
<ul>
<li>调用<code>pthread_exit</code>时：</li>
<li>响应取消请求时：</li>
<li>用非零<code>execute</code>参数调用<code>pthread_cleanup_pop</code>时。</li>
</ul>
<p>如果<code>execute</code>参数设置为0，清理函数将不被调用。不管发生上述哪种情况，<code>pthread_cleanup_pop</code>都将删除上次<code>pthread_cleanup_push</code>调用建立的清理处理程序.这些函数有一个限制，由于它们可以实现为宏，所以必须在与线程相同的作用域中以匹配对的形式使用。<code>pthread_cleanup_push</code>的宏定义可以包含字符<code>{</code>，这种情况下，在<code>pthread_cleanup_pop</code>的定义中要有对应的匹配字符<code>}</code>。</p>
<p>给出一个如何使用线程清理处理程序的例子，它描述了其中涉及的清理机制。注意，虽然我们从来没想过要传一个参数0给线程启动例程，但还是需要把<code>pthread_cleanup_pop</code>调用和<code>pthread_cleanup_push</code>调用匹配起来，否则，程序编译就可能通不过。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">cleanup(<span class="keyword">void</span> *arg)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"cleanup: %s\n"</span>, (<span class="keyword">char</span> *)arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *</span><br><span class="line">thr_fn1(<span class="keyword">void</span> *arg)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"thread 1 start\n"</span>);</span><br><span class="line">        pthread_cleanup_push(cleanup, <span class="string">"thread 1 first handler"</span>);</span><br><span class="line">        pthread_cleanup_push(cleanup, <span class="string">"thread 1 second handler"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"thread 1 push complete\n"</span>);</span><br><span class="line">        <span class="keyword">if</span> (arg)</span><br><span class="line">                <span class="keyword">return</span>((<span class="keyword">void</span> *)<span class="number">1</span>);</span><br><span class="line">        pthread_cleanup_pop(<span class="number">0</span>);</span><br><span class="line">        pthread_cleanup_pop(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span>((<span class="keyword">void</span> *)<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *</span><br><span class="line">thr_fn2(<span class="keyword">void</span> *arg)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"thread 2 start\n"</span>);</span><br><span class="line">        pthread_cleanup_push(cleanup, <span class="string">"thread 2 first handler"</span>);</span><br><span class="line">        pthread_cleanup_push(cleanup, <span class="string">"thread 2 second handler"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"thread 2 push complete\n"</span>);</span><br><span class="line">        <span class="keyword">if</span> (arg)</span><br><span class="line">                pthread_exit((<span class="keyword">void</span> *)<span class="number">2</span>);</span><br><span class="line">        pthread_cleanup_pop(<span class="number">0</span>);</span><br><span class="line">        pthread_cleanup_pop(<span class="number">0</span>);</span><br><span class="line">        pthread_exit((<span class="keyword">void</span> *)<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">int</span>             err;</span><br><span class="line">        <span class="keyword">pthread_t</span>       tid1, tid2;</span><br><span class="line">        <span class="keyword">void</span>            *tret;</span><br><span class="line"></span><br><span class="line">        err = pthread_create(&amp;tid1, <span class="literal">NULL</span>, thr_fn1, (<span class="keyword">void</span> *)<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (err != <span class="number">0</span>)</span><br><span class="line">                err_exit(err, <span class="string">"can't create thread 1"</span>);</span><br><span class="line">        err = pthread_create(&amp;tid2, <span class="literal">NULL</span>, thr_fn2, (<span class="keyword">void</span> *)<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (err != <span class="number">0</span>)</span><br><span class="line">                err_exit(err, <span class="string">"can't create thread 2"</span>);</span><br><span class="line">        err = pthread_join(tid1, &amp;tret);</span><br><span class="line">        <span class="keyword">if</span> (err != <span class="number">0</span>)</span><br><span class="line">                err_exit(err, <span class="string">"can't join with thread 1"</span>);</span><br></pre></td></tr></table></figure></p>
<p>运行程序会得到：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out</span><br><span class="line">thread 1 start</span><br><span class="line">thread 1 push complete</span><br><span class="line">thread 2 start</span><br><span class="line">thread 2 push complete</span><br><span class="line">cleanup: thread 2 second handler</span><br><span class="line">cleanup: thread 2 first handler</span><br><span class="line">thread 1 <span class="built_in">exit</span> code 1</span><br><span class="line">thread 2 <span class="built_in">exit</span> code 2</span><br></pre></td></tr></table></figure></p>
<p>从输出结果可以看出，两个线程都正确地启动和退出了，但是只有第二个线程的清理处理程序被调用了。因此，如果线程是通过从它的启动例程中返回而终止的话，它的清理处理程序就不会被调用。还要注意，清理处理程序是按照与它们安装时相反的顺序被调用的。</p>
<p>在FreeBSD或者MacOSX上，<code>pthread_cleanup_push</code>是用宏实现的，而宏把某些上下文存放在栈上。当线程1在调用<code>pthread_cleanup_push</code>和调用<code>pthread_cleanup_pop</code>之间返回时，栈已被改写，而这两个平台在调用清理处理程序时就用了这个被改写的上下文。在Single UNIX Specification中，函数如果在调用<code>pthread_cleanup_push</code>和<code>pthread_cleanup_pop</code>之间返回，会产生未定义行为。唯一的可移植方法是调用<code>pthread_exit</code>。</p>
<p>现在，让我们了解一下线程函数和进程函数之间的相似之处。</p>
<table>
<thead>
<tr>
<th>进程原语</th>
<th>线程原语</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>fork</td>
<td>pthread_create</td>
<td>创建新的控制流</td>
</tr>
<tr>
<td>exit</td>
<td>pthread_exit</td>
<td>从现有的控制流中退出</td>
</tr>
<tr>
<td>waitpid</td>
<td>pthread_join</td>
<td>从控制流中得到退出状态</td>
</tr>
<tr>
<td>atexit</td>
<td>pthread_cancel_push</td>
<td>注册在退出控制流时调用的函数</td>
</tr>
<tr>
<td>getpid</td>
<td>pthread_self</td>
<td>获取控制流的ID</td>
</tr>
<tr>
<td>abort</td>
<td>pthread_cancel</td>
<td>请求控制流的非正常退出</td>
</tr>
</tbody>
</table>
<p>在默认情况下，线程的终止状态会保存直到对该线程调用<code>pthread_join</code>。如果线程已经被分离，线程的底层存储资源可以在线程终止时立即被收回。在线程被分离后，我们不能用<code>pthread_join</code>函数等待它的终止状态，因为对分离状态的线程调用<code>pthread_join</code>会产生未定义行为。可以调用<code>pthread_detach</code>分离线程。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_detach</span> <span class="params">(<span class="keyword">pthread_t</span> sid)</span></span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回0；否则，返回情谈编号</span></span><br></pre></td></tr></table></figure></p>
<h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><p>当一个线程可以修改的变量，其他线程也可以读取或者修改的时候，我们就需要对这些线程进行同步，确保它们在访问变量的存储内容时不会访问到无效的值。在变量修改时间多于一个存储器访问周期的处理器结构中，当存储器读与存储器写这两个周期交叉时，这种不一致就会出现。</p>
<p>为了解决这个问题，线程不得不使用锁，同一时间只允许一个线程访问该变量。如果线程B希望读取变量，它首先要获取锁。同样，当线程A更新变量时，也需要获取同样的这把锁。这样，线程B在线程A释放锁以前就不能读取变量。</p>
<p>两个或多个线程试图在同一时间修改同一变量时，也需要进行同步。考虑变量增量操作的情况，增量操作通常分解为以下3步。</p>
<ol>
<li>从内存单元读入寄存器</li>
<li>在寄存器中对变量做增量操作，</li>
<li>把新的值写回内存单元</li>
</ol>
<p>如果两个线程试图几乎在同一时间对同一个变量做增量操作而不进行同步的话，结果就可能出现不一致。如果修改操作是原子操作，那么就不存在竞争。如果数据总是以顺序一致出现的，就不需要额外的同步。当多个线程观察不到数据的不一致时，那么操作就是顺序一致的。在现代计算机系统中，存储访问需要多个总线周期，多处理器的总线周期通常在多个处理器上是交叉的，所以我们并不能保证数据是顺序一致的。</p>
<h3 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h3><p>可以使用pthread的互斥接口来保护数据，确保同一时间只有一个线程访问数据。互斥量(mutex)从本质上说是一把锁，在访问共享资源前对互斥量进行设置(加锁)，在访问完成后释放(解锁)互斥量。对互斥量进行加锁以后，任何其他试图再次对互斥量加锁的线程都会被阻塞，直到当前线程释放该互斥锁。如果释放互斥量时有一个以上的线程阻塞，那么所有该锁上的阻塞线程都会变成可运行状态，第一个变为运行的线程就可以对互斥量加锁，其他线程就会看到互斥量依然是锁着的，只能回去再次等待它重新变为可用。在这种方式下，每次只有一个线程可以向前执行。</p>
<p>只有将所有线程都设计成遵守相同数据访问规则的。互斥机制才能正常工作。操作系统并不会为我们做数据访问的申行化。如果允许其中的某个线程在没有得到锁的情况下也可以访问共享资源，那么即使其他的线程在使用共享资源前都申请锁，也还是会出现数据不一致的问题。</p>
<p>互斥变量是用<code>pthread_mutex_t</code>数据类型表示的。在使用互斥变量以前，必须首先对它进行初始化，可以把它设置为常量<code>PTHREAD_MUTEX_ INITIALIZER</code>(只适用于静态分配的互斥量)，也可以通过调用<code>pthread_mutex_init</code>函数进行初始化。如果动态分配互斥量(例如，通过调用<code>malloc</code>函数)，在释放内存前需要调用<code>pthread_mutex_destroy</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_init</span> <span class="params">(<span class="keyword">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex, <span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span> *<span class="keyword">restrict</span> attr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_destroy</span> <span class="params">(<span class="keyword">pthread_mutex_t</span>* mutex)</span></span>;</span><br><span class="line"><span class="comment">// 两个函数的返回值：若成功，返回0；否则，返回错误编号</span></span><br></pre></td></tr></table></figure></p>
<p>要用默认的属性初始化互斥量，只需把<code>attr</code>设为NULL。</p>
<p>对互斥量进行加锁，需要调用<code>pthread_mutex_lock</code>。如果互斥量已经上锁，调用线程将阻塞直到互斥量被解锁。对互斥量解锁，需要调用<code>pthread_mutex_unlock</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> epthread.h&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_lock</span> <span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_trylock</span> <span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_unlock</span> <span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"><span class="comment">// 所有函数的返回值，若成功，返回0；否则，返回错误编号</span></span><br></pre></td></tr></table></figure></p>
<p>如果线程不希望被阻塞，它可以使用<code>pthread_mutex_trylock</code>尝试对互斥量进行加锁。如果调用<code>pthread_mutex_trylock</code>时互斥量处于未锁住状态，那么<code>pthread_mutex_trylock</code>将锁住互斥量，不会出现阻塞直接返回0；否则<code>pthread_mutex_trylock</code>就会失败，不能锁住互斥量，返回EBUSY。</p>
<p>当一个以上的线程需要访问动态分配的对象时，我们可以在对象中嵌入引用计数，确保在所有使用该对象的线程完成数据访问之前，该对象内存空间不会被释放。</p>
<p>在使用该对象前，线程需要调用<code>foo_hold</code>对这个对象的引用计数加1。当对象使用完毕时，必须调用<code>foo_rele</code>释放引用。最后一个引用被释放时，对象所占的内存空间就被释放。在这个例子中，我们忽略了线程在调用<code>foo_hold</code>之前是如何找到对象的。如果有另一个线程在调用<code>foo_hold</code>时阻塞等待互斥锁，这时即使该对象引用计数为0，<code>foo_rele</code>释放该对象的内存仍然是不对的。可以通过确保对象在释放内存前不会被找到这种方式来避免上述问题。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">foo</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span>             f_count;</span><br><span class="line">	<span class="keyword">pthread_mutex_t</span> f_lock;</span><br><span class="line">	<span class="keyword">int</span>             f_id;</span><br><span class="line">	<span class="comment">/* ... more stuff here ... */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">foo</span> *</span></span><br><span class="line"><span class="class"><span class="title">foo_alloc</span>(<span class="title">int</span> <span class="title">id</span>) /* <span class="title">allocate</span> <span class="title">the</span> <span class="title">object</span> */</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">foo</span> *<span class="title">fp</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((fp = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct foo))) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		fp-&gt;f_count = <span class="number">1</span>;</span><br><span class="line">		fp-&gt;f_id = id;</span><br><span class="line">		<span class="keyword">if</span> (pthread_mutex_init(&amp;fp-&gt;f_lock, <span class="literal">NULL</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">free</span>(fp);</span><br><span class="line">			<span class="keyword">return</span>(<span class="literal">NULL</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/* ... continue initialization ... */</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>(fp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">foo_hold(struct foo *fp) <span class="comment">/* add a reference to the object */</span></span><br><span class="line">&#123;</span><br><span class="line">	pthread_mutex_lock(&amp;fp-&gt;f_lock);</span><br><span class="line">	fp-&gt;f_count++;</span><br><span class="line">	pthread_mutex_unlock(&amp;fp-&gt;f_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">foo_rele(struct foo *fp) <span class="comment">/* release a reference to the object */</span></span><br><span class="line">&#123;</span><br><span class="line">	pthread_mutex_lock(&amp;fp-&gt;f_lock);</span><br><span class="line">	<span class="keyword">if</span> (--fp-&gt;f_count == <span class="number">0</span>) &#123; <span class="comment">/* last reference */</span></span><br><span class="line">		pthread_mutex_unlock(&amp;fp-&gt;f_lock);</span><br><span class="line">		pthread_mutex_destroy(&amp;fp-&gt;f_lock);</span><br><span class="line">		<span class="built_in">free</span>(fp);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		pthread_mutex_unlock(&amp;fp-&gt;f_lock);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h3><p>如果线程试图对同一个互斥量加锁两次，那么它自身就会陷入死锁状态，但是使用互斥量时，还有其他不太明显的方式也能产生死锁。例如，程序中使用一个以上的互斥量时，如果允许一个线程一直占有第一个互斥量，并且在试图锁住第二个互斥量时处于阻塞状态，但是拥有第二个互斥最的线程也在试图锁住第一个互斥量。因为两个线程都在相互请求另一个线程拥有的资源，所以这两个线程都无法向前运行，于是就产生死锁。</p>
<p>可以通过仔细控制互斥量加锁的顺序来避免死锁的发生。例如，假设需要对两个互斥量A和B同时加锁。如果所有线程总是在对互斥量B加锁之前锁住互斥量A，那么使用这两个互斥量就不会产生死锁(当然在其他的资源上仍可能出现死锁)。可能出现的死锁只会发生在一个线程试图锁住另一个线程以相反的顺序锁住的互斥量。</p>
<p>可以先释放占有的锁，然后过一段时间再试。这种情况可以使用<code>pthread_mutex_trylock</code>接口避免死锁。如果已经占有某些锁而且<code>pthread_mutex_trylock</code>接口返回成功，那么就可以前进。但是，如果不能获取锁，可以先释放已经占有的锁，做好清理工作，然后过一段时间再重新试。</p>
<p>在同时需要两个互斥量时，总是让它们以相同的顺序加锁，这样可以避免死锁。第二个互斥量维护着一个用于跟踪<code>foo</code>数据结构的散列列表。这样<code>hashlock</code>互斥量既可以保护<code>foo</code>数据结构中的散列表fh，又可以保护散列链字段<code>e_next</code>。<code>foo</code>结构中的<code>t_lock</code>互斥量保护对<code>foo</code>结构中的其他字段的访问。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NHASH 29</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HASH(id) (((unsigned long)id)%NHASH)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">foo</span> *<span class="title">fh</span>[<span class="title">NHASH</span>];</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> hashlock = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">foo</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span>             f_count;</span><br><span class="line">	<span class="keyword">pthread_mutex_t</span> f_lock;</span><br><span class="line">	<span class="keyword">int</span>             f_id;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">foo</span>     *<span class="title">f_next</span>;</span> <span class="comment">/* protected by hashlock */</span></span><br><span class="line">	<span class="comment">/* ... more stuff here ... */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">foo</span> *</span></span><br><span class="line"><span class="class"><span class="title">foo_alloc</span>(<span class="title">int</span> <span class="title">id</span>) /* <span class="title">allocate</span> <span class="title">the</span> <span class="title">object</span> */</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">foo</span>	*<span class="title">fp</span>;</span></span><br><span class="line">	<span class="keyword">int</span>			idx;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((fp = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct foo))) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		fp-&gt;f_count = <span class="number">1</span>;</span><br><span class="line">		fp-&gt;f_id = id;</span><br><span class="line">		<span class="keyword">if</span> (pthread_mutex_init(&amp;fp-&gt;f_lock, <span class="literal">NULL</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">free</span>(fp);</span><br><span class="line">			<span class="keyword">return</span>(<span class="literal">NULL</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		idx = HASH(id);</span><br><span class="line">		pthread_mutex_lock(&amp;hashlock);</span><br><span class="line">		fp-&gt;f_next = fh[idx];</span><br><span class="line">		fh[idx] = fp;</span><br><span class="line">		pthread_mutex_lock(&amp;fp-&gt;f_lock);</span><br><span class="line">		pthread_mutex_unlock(&amp;hashlock);</span><br><span class="line">		<span class="comment">/* ... continue initialization ... */</span></span><br><span class="line">		pthread_mutex_unlock(&amp;fp-&gt;f_lock);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>(fp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">foo_hold(struct foo *fp) <span class="comment">/* add a reference to the object */</span></span><br><span class="line">&#123;</span><br><span class="line">	pthread_mutex_lock(&amp;fp-&gt;f_lock);</span><br><span class="line">	fp-&gt;f_count++;</span><br><span class="line">	pthread_mutex_unlock(&amp;fp-&gt;f_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">foo</span> *</span></span><br><span class="line"><span class="class"><span class="title">foo_find</span>(<span class="title">int</span> <span class="title">id</span>) /* <span class="title">find</span> <span class="title">an</span> <span class="title">existing</span> <span class="title">object</span> */</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">foo</span>	*<span class="title">fp</span>;</span></span><br><span class="line"></span><br><span class="line">	pthread_mutex_lock(&amp;hashlock);</span><br><span class="line">	<span class="keyword">for</span> (fp = fh[HASH(id)]; fp != <span class="literal">NULL</span>; fp = fp-&gt;f_next) &#123;</span><br><span class="line">		<span class="keyword">if</span> (fp-&gt;f_id == id) &#123;</span><br><span class="line">			foo_hold(fp);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	pthread_mutex_unlock(&amp;hashlock);</span><br><span class="line">	<span class="keyword">return</span>(fp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">foo_rele(struct foo *fp) <span class="comment">/* release a reference to the object */</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">foo</span>	*<span class="title">tfp</span>;</span></span><br><span class="line">	<span class="keyword">int</span>			idx;</span><br><span class="line"></span><br><span class="line">	pthread_mutex_lock(&amp;fp-&gt;f_lock);</span><br><span class="line">	<span class="keyword">if</span> (fp-&gt;f_count == <span class="number">1</span>) &#123; <span class="comment">/* last reference */</span></span><br><span class="line">		pthread_mutex_unlock(&amp;fp-&gt;f_lock);</span><br><span class="line">		pthread_mutex_lock(&amp;hashlock);</span><br><span class="line">		pthread_mutex_lock(&amp;fp-&gt;f_lock);</span><br><span class="line">		<span class="comment">/* need to recheck the condition */</span></span><br><span class="line">		<span class="keyword">if</span> (fp-&gt;f_count != <span class="number">1</span>) &#123;</span><br><span class="line">			fp-&gt;f_count--;</span><br><span class="line">			pthread_mutex_unlock(&amp;fp-&gt;f_lock);</span><br><span class="line">			pthread_mutex_unlock(&amp;hashlock);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/* remove from list */</span></span><br><span class="line">		idx = HASH(fp-&gt;f_id);</span><br><span class="line">		tfp = fh[idx];</span><br><span class="line">		<span class="keyword">if</span> (tfp == fp) &#123;</span><br><span class="line">			fh[idx] = fp-&gt;f_next;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">while</span> (tfp-&gt;f_next != fp)</span><br><span class="line">				tfp = tfp-&gt;f_next;</span><br><span class="line">			tfp-&gt;f_next = fp-&gt;f_next;</span><br><span class="line">		&#125;</span><br><span class="line">		pthread_mutex_unlock(&amp;hashlock);</span><br><span class="line">		pthread_mutex_unlock(&amp;fp-&gt;f_lock);</span><br><span class="line">		pthread_mutex_destroy(&amp;fp-&gt;f_lock);</span><br><span class="line">		<span class="built_in">free</span>(fp);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fp-&gt;f_count--;</span><br><span class="line">		pthread_mutex_unlock(&amp;fp-&gt;f_lock);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>分配函数现在锁住了散列列表锁，把新的结构添加到了散列桶中，而且在对散列列表的锁解锁之前，先锁定了新结构中的互斥量。因为新的结构是放在全局列表中的，其他线程可以找到它，所以在初始化完成之前，需要阻塞其他线程试图访问新结构。</p>
<p><code>foo_find</code>函数锁住散列列表锁，然后搜索被请求的结构。如果找到了，就增加其引用计数并返回指向该结构的指针。注意，加锁的顺序是，先在<code>foo_find</code>函数中锁定散列列表锁，然后再在<code>foo_hold</code>函数中锁定<code>foo</code>结构中的<code>f_lock</code>互斥量。</p>
<p>现在有了两个锁以后，<code>foo_rele</code>函数就变得更加复杂了。如果这是最后一个引用，就需要对这个结构互斥量进行解锁，因为我们需要从散列列表中删除这个结构，这样才可以获取散列列表锁，然后重新获取结构互斥量。从上一次获得结构互斥量以来我们可能被阻塞着，所以需要重新检查条件，判断是否还需要释放这个结构。如果另一个线程在我们为满足锁顺序而阻塞时发现了这个结构并对其引用计数加1，那么只需要简单地对整个引用计数减1，对所有的东西解锁，然后返回。</p>
<h3 id="函数pthread-mutex-timedlock"><a href="#函数pthread-mutex-timedlock" class="headerlink" title="函数pthread_mutex_timedlock"></a>函数pthread_mutex_timedlock</h3><p>当线程试图获取一个已加锁的互斥量时，<code>pthread_mutex_timedlock</code>互斥量原语允许绑定线程阻塞时间。<code>pthread_mutex_timedlock</code>函数与<code>pthread_mutex_lock</code>是基本等价的，但是在达到超时时间值时，<code>pthread_mutex_timedlock</code>不会对互斥量进行加锁。而是返回错误码ETIMEDOUT。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_timedlock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex, <span class="keyword">const</span> struct tinespec *<span class="keyword">restrict</span> tsptr)</span></span>;</span><br><span class="line"><span class="comment">// 返回值，若成功，返回0；否则，返回错误编号</span></span><br></pre></td></tr></table></figure></p>
<p>超时指定愿意等待的绝对时间(与相对时间对比而言，指定在时间X之前可以阻塞等待，而不是说愿意阻塞Y秒)。这个超时时间是用<code>timespec</code>结构来表示的，它用秒和纳秒来描述时间。</p>
<p>程序给出了如何用<code>pthread_mutex_timedlock</code>避免永久阻塞。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">int</span> err;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">tout</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> *<span class="title">tmp</span>;</span></span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">64</span>];</span><br><span class="line">        <span class="keyword">pthread_mutex_t</span> lock = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line">        pthread_mutex_lock(&amp;lock);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"mutex is locked\n"</span>);</span><br><span class="line">        clock_gettime(CLOCK_REALTIME, &amp;tout);</span><br><span class="line">        tmp = localtime(&amp;tout.tv_sec);</span><br><span class="line">        strftime(buf, <span class="keyword">sizeof</span>(buf), <span class="string">"%r"</span>, tmp);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"current time is %s\n"</span>, buf);</span><br><span class="line">        tout.tv_sec += <span class="number">10</span>;      <span class="comment">/* 10 seconds from now */</span></span><br><span class="line">        <span class="comment">/* caution: this could lead to deadlock */</span></span><br><span class="line">        err = pthread_mutex_timedlock(&amp;lock, &amp;tout);</span><br><span class="line">        clock_gettime(CLOCK_REALTIME, &amp;tout);</span><br><span class="line">        tmp = localtime(&amp;tout.tv_sec);</span><br><span class="line">        strftime(buf, <span class="keyword">sizeof</span>(buf), <span class="string">"%r"</span>, tmp);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"the time is now %s\n"</span>, buf);</span><br><span class="line">        <span class="keyword">if</span> (err == <span class="number">0</span>)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"mutex locked again!\n"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"can't lock mutex again: %s\n"</span>, strerror(err));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果输出如下：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out</span><br><span class="line">mutex is locked</span><br><span class="line">current time <span class="keyword">in</span> 12:41:58 MI</span><br><span class="line">the time is now 11:42:08 AM</span><br><span class="line">can<span class="string">'t lock mutex again: Connection timed out</span></span><br></pre></td></tr></table></figure></p>
<p>这个程序故意对它已有的互斥量进行加锁，目的是演示<code>pthread_mutex_timedlock</code>是如何工作的。不推荐在实际中使用这种策略，因为它会导致死锁。</p>
<h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p>读写锁(reader-writerlock)与互斥量类似，不过读写锁允许更高的并行性。互斥量要么是锁住状态，要么就是不加锁状态，而且一次只有一个线程可以对其加锁。读写锁可以有3种状态：</p>
<ul>
<li>读模式下加锁状态，</li>
<li>写模式下加锁状态，</li>
<li>不加锁状态。</li>
</ul>
<p>一次只有一个线程可以占有写模式的读写锁，但是多个线程可以同时占有读模式的读写锁。当读写锁是写加锁状态时，在这个锁被解锁之前，所有试图对这个锁加锁的线程都会被阻塞。当读写锁在读加锁状态时，所有试图以读模式对它进行加锁的线程都可以得到访问权，但是任何希望以写模式对此锁进行加锁的线程都会阻塞，直到所有的线程释放它们的读锁为止。</p>
<p>虽然各操作系统对读写锁的实现各不相同，但当读写锁处于读模式锁住的状态，而这时有一个线程试图以写模式获取锁时，读写锁通常会阻塞随后的读模式锁请求。这样可以避免读模式锁长期占用，而等待的写模式锁请求一直得不到满足。</p>
<p>读写锁非常适合于对数据结构读的次数远大于写的情况。当读写锁在写模式下时，它所保护的数据结构就可以被安全地修改，因为一次只有一个线程可以在写模式下拥有这个锁。当读写锁在读模式下时，只要线程先获取了读模式下的读写镇，该锁所保护的数据结构就可以被多个获得读模式锁的线程读取。</p>
<p>读写锁也叫做<strong>共享互斥锁</strong>(shared-exclusive lock)。 当读写锁是读模式锁住时，就可以说成是以共享模式锁住的。当它是写模式锁住的时候，就可以说成是以互斥模式锁住的。与互斥量相比，读写锁在使用之前必须初始化，在释放它们底层的内存之前必须销毁。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_init</span> <span class="params">(<span class="keyword">pthread_rwlock_t</span> *<span class="keyword">restrict</span> rwlock, <span class="keyword">const</span> <span class="keyword">pthread_rwlockattr_t</span> *<span class="keyword">restrict</span> attr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_destroy</span> <span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class="line"><span class="comment">// 两个函数的返回值，若成功，返回0；否则，返回错误编号</span></span><br></pre></td></tr></table></figure></p>
<p>读写锁通过调用<code>pthread_rwlock_init</code>进行初始化。如果希望读写锁有默认的属性，可以传一个null指针给attr。Single UNIX Specification在XSI扩展中定义了<code>PTHREAD_RWLOCK_INITIALIZER</code>常量。如果默认属性就足够的话，可以用它对静态分配的读写锁进行初始化。</p>
<p>在释放读写锁占用的内存之前，需要调用<code>pthread_rwlock_destroy</code>做清理工作。如果<code>pthread_rwlock_init</code>为读写锁分配了资源，<code>pthread_nwlock_destroy</code>将释放这些资源。如果在调用<code>pthread_rwlock_destroy</code>之前就释放了读写锁占用的内存空间，那么分配给这<br>个锁的资源就会丢失。要在读模式下锁定读写锁，需要调用<code>pthread_rwlock_rdlock</code>。要在写模式下锁定读写锁，需要调用<code>pthread_rwlock_wrlock</code>。不管以何种方式锁住读写锁，都可以调用<code>pthread_rwlock_unlock</code>进行解锁。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_rdlock</span> <span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_wrlock</span> <span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_unlock</span> <span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class="line"><span class="comment">// 所有函数的返回值，若成功，返回0；否则，返回错误编号</span></span><br></pre></td></tr></table></figure></p>
<p>各种实现可能会对共享模式下可获取的读写锁的次数进行限制，所以需要检查<code>pthread_rwlock_rdlock</code>的返回值。即使<code>pthread_rwlock_wrlock</code>和<code>pthread_rwlock_unlock</code>有错误返回，而且从技术上来讲，在调用函数时应该总是检查错误返回，但是如果锁设计合理的话，就不需要检查它们。错误返回值的定义只是针对不正确使用读写锁的情况(如未经初始化的锁)，或者试图获取已拥有的锁从而可能产生死锁的情况。但是需要注意，有些特定的实现可能会定义另外的错误返回。</p>
<p>Single UNIX Specification还定义了读写锁原语的条件版本。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthreed_rwlock_tryrdlock</span> <span class="params">(<span class="keyword">pthread_rwlock_t</span>*rwlock)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_trywrlock</span> <span class="params">(<span class="keyword">pthread_rwlock_t</span>*rwlock)</span></span>;</span><br><span class="line"><span class="comment">// 两个函数的返回值：若成功，返回0；否则，返阀错误编号</span></span><br></pre></td></tr></table></figure></p>
<p>可以获取锁时，这两个函数返回0；否则，它们返回错误EBUSY。这两个函数可以用于我们前面讨论的遵守某种锁层次但还不能完全避免死锁的情况。</p>
<p>程序解释了读写锁的使用。作业请求队列由单个读写锁保护。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">job</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">job</span> *<span class="title">j_next</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">job</span> *<span class="title">j_prev</span>;</span></span><br><span class="line">	<span class="keyword">pthread_t</span>   j_id;   <span class="comment">/* tells which thread handles this job */</span></span><br><span class="line">	<span class="comment">/* ... more stuff here ... */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">queue</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">job</span>      *<span class="title">q_head</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">job</span>      *<span class="title">q_tail</span>;</span></span><br><span class="line">	<span class="keyword">pthread_rwlock_t</span> q_lock;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Initialize a queue.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">queue_init(struct <span class="built_in">queue</span> *qp)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">	qp-&gt;q_head = <span class="literal">NULL</span>;</span><br><span class="line">	qp-&gt;q_tail = <span class="literal">NULL</span>;</span><br><span class="line">	err = pthread_rwlock_init(&amp;qp-&gt;q_lock, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (err != <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span>(err);</span><br><span class="line">	<span class="comment">/* ... continue initialization ... */</span></span><br><span class="line">	<span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Insert a job at the head of the queue.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">job_insert(struct <span class="built_in">queue</span> *qp, struct job *jp)</span><br><span class="line">&#123;</span><br><span class="line">	pthread_rwlock_wrlock(&amp;qp-&gt;q_lock);</span><br><span class="line">	jp-&gt;j_next = qp-&gt;q_head;</span><br><span class="line">	jp-&gt;j_prev = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span> (qp-&gt;q_head != <span class="literal">NULL</span>)</span><br><span class="line">		qp-&gt;q_head-&gt;j_prev = jp;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		qp-&gt;q_tail = jp;	<span class="comment">/* list was empty */</span></span><br><span class="line">	qp-&gt;q_head = jp;</span><br><span class="line">	pthread_rwlock_unlock(&amp;qp-&gt;q_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Append a job on the tail of the queue.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">job_append(struct <span class="built_in">queue</span> *qp, struct job *jp)</span><br><span class="line">&#123;</span><br><span class="line">	pthread_rwlock_wrlock(&amp;qp-&gt;q_lock);</span><br><span class="line">	jp-&gt;j_next = <span class="literal">NULL</span>;</span><br><span class="line">	jp-&gt;j_prev = qp-&gt;q_tail;</span><br><span class="line">	<span class="keyword">if</span> (qp-&gt;q_tail != <span class="literal">NULL</span>)</span><br><span class="line">		qp-&gt;q_tail-&gt;j_next = jp;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		qp-&gt;q_head = jp;	<span class="comment">/* list was empty */</span></span><br><span class="line">	qp-&gt;q_tail = jp;</span><br><span class="line">	pthread_rwlock_unlock(&amp;qp-&gt;q_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Remove the given job from a queue.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">job_remove(struct <span class="built_in">queue</span> *qp, struct job *jp)</span><br><span class="line">&#123;</span><br><span class="line">	pthread_rwlock_wrlock(&amp;qp-&gt;q_lock);</span><br><span class="line">	<span class="keyword">if</span> (jp == qp-&gt;q_head) &#123;</span><br><span class="line">		qp-&gt;q_head = jp-&gt;j_next;</span><br><span class="line">		<span class="keyword">if</span> (qp-&gt;q_tail == jp)</span><br><span class="line">			qp-&gt;q_tail = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			jp-&gt;j_next-&gt;j_prev = jp-&gt;j_prev;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (jp == qp-&gt;q_tail) &#123;</span><br><span class="line">		qp-&gt;q_tail = jp-&gt;j_prev;</span><br><span class="line">		jp-&gt;j_prev-&gt;j_next = jp-&gt;j_next;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		jp-&gt;j_prev-&gt;j_next = jp-&gt;j_next;</span><br><span class="line">		jp-&gt;j_next-&gt;j_prev = jp-&gt;j_prev;</span><br><span class="line">	&#125;</span><br><span class="line">	pthread_rwlock_unlock(&amp;qp-&gt;q_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Find a job for the given thread ID.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">job</span> *</span></span><br><span class="line"><span class="class"><span class="title">job_find</span>(<span class="title">struct</span> <span class="title">queue</span> *<span class="title">qp</span>, <span class="title">pthread_t</span> <span class="title">id</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">job</span> *<span class="title">jp</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pthread_rwlock_rdlock(&amp;qp-&gt;q_lock) != <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span>(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (jp = qp-&gt;q_head; jp != <span class="literal">NULL</span>; jp = jp-&gt;j_next)</span><br><span class="line">		<span class="keyword">if</span> (pthread_equal(jp-&gt;j_id, id))</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	pthread_rwlock_unlock(&amp;qp-&gt;q_lock);</span><br><span class="line">	<span class="keyword">return</span>(jp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这个例子中，凡是需要向队列中增加作业或者从队列中删除作业的时候，都采用了写模式来锁住队列的读写锁。不管何时搜索队列，都需要获取读模式下的锁，允许所有的工作线程并发地搜索队列。在这种情况下，只有在线程搜索作业的频率远远高于增加或剩除作业时，使用读写锁才可能改善性能。工作线程只能从队列中读取与它们的线程ID匹配的作业。由于作业结构同一时间只能由一个线程使用，所以不需要额外的加锁。</p>
<h3 id="带有超时的读写锁"><a href="#带有超时的读写锁" class="headerlink" title="带有超时的读写锁"></a>带有超时的读写锁</h3><p>与互斥量一样，Single UNIX Specification提供了带有超时的读写锁加锁函数，使应用程序在获取读写锁时避免陷入永久阻塞状态。这两个函数是<code>pthread_rwlock_timedrdlock</code>和<code>pthread_rwlock_timedwrlock</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlook_timedrdlock</span> <span class="params">(<span class="keyword">pthread_rwlock_t</span> *<span class="keyword">restrict</span> rwlock, <span class="keyword">const</span> struct timespec *<span class="keyword">restrict</span> tsptr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_timedwrlock</span> <span class="params">(<span class="keyword">pthread_rwlock_t</span> *<span class="keyword">restrict</span> rwlock, <span class="keyword">const</span> struct timespec *<span class="keyword">restrict</span> tsptr)</span></span>;</span><br><span class="line"><span class="comment">// 两个函数的返回值：若成功，返回0；否则，返回错误编号</span></span><br></pre></td></tr></table></figure></p>
<p>这两个函数的行为与它们“不计时的”版本类似。<code>tsptr</code>参数指向<code>timespec</code>结构，指定线程应该停止阻塞的时间。如果它们不能获取锁，那么超时到期时，这两个函数将返回ETIMEDOUT错误。与<code>pthread_mutex_timedlock</code>函数类似，超时指定的是绝对时间，而不是相对时间。</p>
<h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><p>条件变量是线程可用的另一种同步机制。条件变量给多个线程提供了一个会合的场所。条件变量与互斥量一起使用时，允许线程以无竞争的方式等待特定的条件发生。条件本身是由互斥量保护的。线程在改变条件状态之前必须首先锁住互斥量。其他线程在获得互斥量之前不会察觉到这种改变，因为互斥量必须在锁定以后才能计算条件。</p>
<p>在使用条件变量之前，必须先对它进行初始化。由<code>pthread_cond_t</code>数据类型表示的条件变量可以用两种方式进行初始化，可以把常量<code>PTHREAD_COND_INITIALIZER</code>赋给静态分配的条件变量，但是如果条件变量是动态分配的，则需要使用<code>pthread_cond_init</code>函数对它进行初始化。</p>
<p>在释放条件变量底层的内存空间之前，可以使用<code>pthread_cond_destroy</code>函数对条件变量进行反初始化(deinitialize)。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_init</span> <span class="params">(<span class="keyword">pthread_cond_t</span> *<span class="keyword">restrict</span> cond, <span class="keyword">const</span> <span class="keyword">pthread_condattr_t</span> *<span class="keyword">restrict</span> attr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_destroy</span> <span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br><span class="line"><span class="comment">// 两个函数的返回值：若成功，返回0；否则，返回错误编号</span></span><br></pre></td></tr></table></figure></p>
<p>除非需要创建一个具有非默认属性的条件变量，否则<code>pthread_cond_init</code>函数的attr参数可以设置为NULL。我们使用<code>pthread_cond_wait</code>等待条件变量变为真。如果在给定的时间内条件不能满足，那么会生成一个返回错误码的变量。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_wait</span> <span class="params">(<span class="keyword">pthread_cond_t</span> *<span class="keyword">restrict</span> cond, <span class="keyword">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthcead_cond_timedwast</span> <span class="params">(<span class="keyword">pthread_cond_t</span> *<span class="keyword">restrict</span> cond, <span class="keyword">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex, <span class="keyword">const</span> struct timespec *<span class="keyword">restrict</span> tsptr)</span></span>;</span><br><span class="line"><span class="comment">// 两个函数的返回值：若成功，返回0；否则，返回错误编号</span></span><br></pre></td></tr></table></figure></p>
<p>传递给<code>pthread_cond_wait</code>的互斥量对条件进行保护。调用者把锁住的互斥量传给函数，函数然后自动把调用线程放到等待条件的线程列表上，对互斥量解锁。这就关闭了条件检查和线程进入休眠状态等待条件改变这两个操作之间的时间通道，这样线程就不会错过条件的任何变化。<code>pthread_cond_wait</code>返回时，互斥量再次被锁住，<code>pthread_cond_timedwait</code>函数的功能与<code>pthread_cond_wait</code>函数相似，只是多了一<br>个超时(<code>tsptr</code>)。超时值指定了我们愿意等待多长时间，它是通过timespec结构指定的。</p>
<p>如果超时到期时条件还是没有出现，<code>pthread_cond_timewait</code>将重新获取互斥最，然后返回错误ETIMEDOUT。从<code>pthread_cond_wait</code>或者<code>pthread_cond_timedwait</code>调用成功返回时，线程需要重新计算条件，因为另一个线程可能已经在运行并改变了条件。</p>
<p>有两个函数可以用于通知线程条件已经满足。<code>pthread_cond_signal</code>函数至少能唤醒一个等待该条件的线程，而<code>pthread_cond_broadcast</code>函数则能唤醒等待该条件的所有线程。POSIX规范为了简化<code>pthread_cond_signal</code>的实现，允许它在实现的时候唤醒一个以上的线程。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> (pthread.h&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_signal</span> <span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_broadcast</span> <span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br><span class="line"><span class="comment">// 两个函数的返回值：若成功，返回0：否则，返回锗误编号</span></span><br></pre></td></tr></table></figure></p>
<p>在调用<code>pthread_cond_signal</code>或者<code>pthread_cond_broadcast</code>时，我们说这是在给线程或者条件发信号。必须注意，一定要在改变条件状态以后再给线程发信号。</p>
<p>给出了如何结合使用条件变量和互斥量对线程进行同步。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg</span> *<span class="title">m_next</span>;</span></span><br><span class="line">	<span class="comment">/* ... more stuff here ... */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg</span> *<span class="title">workq</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_cond_t</span> qready = PTHREAD_COND_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> qlock = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">process_msg(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg</span> *<span class="title">mp</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		pthread_mutex_lock(&amp;qlock);</span><br><span class="line">		<span class="keyword">while</span> (workq == <span class="literal">NULL</span>)</span><br><span class="line">			pthread_cond_wait(&amp;qready, &amp;qlock);</span><br><span class="line">		mp = workq;</span><br><span class="line">		workq = mp-&gt;m_next;</span><br><span class="line">		pthread_mutex_unlock(&amp;qlock);</span><br><span class="line">		<span class="comment">/* now process the message mp */</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">enqueue_msg(struct msg *mp)</span><br><span class="line">&#123;</span><br><span class="line">	pthread_mutex_lock(&amp;qlock);</span><br><span class="line">	mp-&gt;m_next = workq;</span><br><span class="line">	workq = mp;</span><br><span class="line">	pthread_mutex_unlock(&amp;qlock);</span><br><span class="line">	pthread_cond_signal(&amp;qready);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>条件是工作队列的状态。我们用互斥量保护条件，在while循环中判断条件。把消息放到工作队列时，需要占有互斥量，但在给等待线程发信号时，不需要占有互斥量。只要线程在调用<code>pthread_cond_signal</code>之前把消息从队列中拖出了，就可以在释放互斥量以后完成这部分工作。因为我们是在while循环中检查条件，所以不存在这样的问题：线程醒来，发现队列仍为空，然后返回继续等待。如果代码不能容忍这种竞争，就需要在给线程发信号的时候占有互斥量。</p>
<h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>自旋锁与互斥量类似，但它不是通过休眠使进程阻塞，而是在获取锁之前一直处于忙等(自旋)阻塞状态。自旋锁可用于以下情况：锁被持有的时间短，而且线程并不希望在重新调度上花费太多的成本。</p>
<p>自旋锁通常作为底层原语用于实现其他类型的锁。根据它们所基于的系统体系结构，可以通过使用测试并设置指令有效地实现。当自旋锁用在非抢占式内核中时是非常有用的：除了提供互斥机制以外，它们会阻塞中断，这样中断处理程序就不会让系统陷入死锁状态，因为它需要获取已被加锁的自旋锁。在这种类型的内核中，中断处理程序不能休眠，因此它们能用的同步原语只能是自旋锁。</p>
<p>很多互斥量的实现非常高效。以至于应用程序采用互斥锁的性能与曾经采用过自旋锁的性能基本是相同的。事实上，有些互斥量的实现在试图获取互斥量的时候会自旋一小段时间，只有在自旋计数到达某一阙值的时候才会休眠。</p>
<p>自旋锁的接口与互斥量的接口类似，这使得它可以比较容易地从一个替换为另一个。可以用<code>pthread_spin_init</code>函数对自旋锁进行初始化。用<code>pthread_spin_destroy</code>函数进行自旋锁的反初始化。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_spin_init</span> <span class="params">(<span class="keyword">pthread_spinlock_t</span> *lock, <span class="keyword">int</span> pshared)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthzead_spin_destroy</span> <span class="params">(<span class="keyword">pthread_spinlock_t</span> *lock)</span></span>;</span><br><span class="line"><span class="comment">// 两个函数的返回值：若成功，返回0；否则，返回错误编号</span></span><br></pre></td></tr></table></figure></p>
<p>只有一个属性是自旋锁特有的，这个属性只在支持线程进程共享同步(Thread Process SharedSynchronization)选项的平台上才用得到。<code>pshared</code>参数表示进程共享属性，表明自旋锁是如何获取的。如果它设为<code>PTHREAD_PROCESS_SHARED</code>，则自旋锁能被可以访问锁底层内存的线程所获取，即便那些线程属于不同的进程，情况也是如此。否则<code>pshared</code>参数设为<code>PTHREAD_PROCESS_PRIVATE</code>，自旋锁就只能被初始化该锁的进程内部的线程所访问。</p>
<p>可以用<code>pthread_spin_lock</code>或<code>pthread_spin_trylock</code>对自旋锁进行加锁，前者在获取锁之前一直自旋，后者如果不能获取锁，就立即返回EBUSY错误。注意，<code>pthread_spin_trylock</code>不能自旋。不管以何种方式加锁，自旋锁都可以调用<code>pthread_spin_unlock</code>函数解锁。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_spin_lock</span> <span class="params">(<span class="keyword">pthread_spinlock_t</span> *lock)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_spin_trylock</span> <span class="params">(<span class="keyword">pthread_spinlock_t</span> *lock)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_spin_unlock</span> <span class="params">(<span class="keyword">pthread_spinlock_t</span> *lock)</span></span>;</span><br><span class="line"><span class="comment">// 所有函数的返回值，若成功，返回0；否则，返回错误编号</span></span><br></pre></td></tr></table></figure></p>
<p>注意，如果自旋锁当前在解锁状态的话，<code>pthread_spin_lock</code>函数不要自旋就可以对它加锁。如果线程已经对它加锁了，结果就是未定义的。调用<code>pthread_spin_lock</code>会返回EDEADLK错误(或其他错误)，或者调用可能会永久自旋。具体行为依赖于实际的实现。试图对没有加锁的自旋锁进行解锁，结果也是未定义的。</p>
<p>不管是<code>pthread_spin_lock</code>还是<code>pthread_spin_trylock</code>，返回值为0的话就表示自旋锁被加锁。需要注意，不要调用在持有自旋锁情况下可能会进入休眠状态的函数。如果调用了这些函数，会浪费CPU资源，因为其他线程需要获取自旋锁需要等待的时间就延长了。</p>
<h3 id="屏障"><a href="#屏障" class="headerlink" title="屏障"></a>屏障</h3><p>屏障(barrier)是用户协调多个线程并行工作的同步机制。屏障允许每个线程等待，直到所有的合作线程都到达某一点，然后从该点继续执行。我们已经看到一种屏障，<code>pthread_join</code>函数就是一种屏障，允许一个线程等待，直到另一个线程退出。</p>
<p>但是屏障对象的概念更广，它们允许任意数量的线程等待，直到所有的线程完成处理工作，而线程不需要退出。所有线程达到屏障后可以接着工作，可以使用<code>pthread_barrier_init</code>函数对屏障进行初始化，用<code>thread_barrier_destroy</code>函数反初始化。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_barrier_init</span> <span class="params">(<span class="keyword">pthreed_barrier_t</span> *<span class="keyword">restrict</span> barrier,</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="keyword">const</span> <span class="keyword">pthread_barrierattr_t</span> *<span class="keyword">restrict</span> attr,</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="keyword">unsigned</span> <span class="keyword">int</span> count)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_barrier_destroy</span> <span class="params">(<span class="keyword">pthread_barrier_t</span> *barrier)</span></span>;</span><br><span class="line"><span class="comment">// 两个函数的返回值：若成功，返回0；否则，返回错误编号</span></span><br></pre></td></tr></table></figure></p>
<p>初始化屏障时，可以使用<code>count</code>参数指定，在允许所有线程继续运行之前，必须到达屏障的线程数目。使用<code>attr</code>参数指定屏障对象的属性。现在设置<code>attr</code>为NULL，用默认属性初始化屏障。如果使用<code>pthread_barrier_init</code>函数为屏障分配资源，那么在反初始化屏障时可以调用<code>pthread_barrier_destroy</code>函数释放相应的资源。</p>
<p>可以使用<code>pthread_barrier_wait</code>函数来表明，线程已完成工作，准备等所有其他线程赶上来。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_barrier_wait</span> <span class="params">(<span class="keyword">pthread_barrier_t</span> *barrier)</span></span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回0或者PTHREAD_BARRIER_SERIAL_THREAD；否则，返回错误编号</span></span><br></pre></td></tr></table></figure></p>
<p>调用<code>pthread_barrier_wait</code>的线程在屏障计数(调用<code>pthread_barrier_init</code>时设定)未满足条件时，会进入休眠状态。如果该线程是最后一个调用<code>pthread_barrier_wait</code>的线程，就满足了屏障计数，所有的线程都被唤醒。</p>
<p>对于一个任意线程，<code>pthread_barrier_wait</code>函数返回了<code>PTHREAD_BARRIER_SERIAL_THREAD</code>。剩下的线程看到的返回值是0。这使得一个线程可以作为主线程，它可以工作在其他所有线程已完成的工作结果上。</p>
<p>一旦达到屏障计数值，而且线程处于非阻塞状态，屏障就可以被重用。但是除非在调用了<code>pthread_barrier_destroy</code>函数之后，又调用了<code>pthread_barrier_init</code>函数对计数用另外的数进行初始化，否则屏障计数不会改变。</p>
<p>给出了在一个任务上合作的多个线程之间如何用屏障进行同步。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NTHR   8				<span class="comment">/* number of threads */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUMNUM 8000000L			<span class="comment">/* number of numbers to sort */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TNUM   (NUMNUM/NTHR)	<span class="comment">/* number to sort per thread */</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> nums[NUMNUM];</span><br><span class="line"><span class="keyword">long</span> snums[NUMNUM];</span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_barrier_t</span> b;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> SOLARIS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> heapsort qsort</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">heapsort</span><span class="params">(<span class="keyword">void</span> *, <span class="keyword">size_t</span>, <span class="keyword">size_t</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">int</span> (*)(<span class="keyword">const</span> <span class="keyword">void</span> *, <span class="keyword">const</span> <span class="keyword">void</span> *))</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Compare two long integers (helper function for heapsort)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">complong(<span class="keyword">const</span> <span class="keyword">void</span> *arg1, <span class="keyword">const</span> <span class="keyword">void</span> *arg2)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">long</span> l1 = *(<span class="keyword">long</span> *)arg1;</span><br><span class="line">	<span class="keyword">long</span> l2 = *(<span class="keyword">long</span> *)arg2;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (l1 == l2)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (l1 &lt; l2)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Worker thread to sort a portion of the set of numbers.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> *</span><br><span class="line">thr_fn(<span class="keyword">void</span> *arg)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">long</span>	idx = (<span class="keyword">long</span>)arg;</span><br><span class="line"></span><br><span class="line">	heapsort(&amp;nums[idx], TNUM, <span class="keyword">sizeof</span>(<span class="keyword">long</span>), complong);</span><br><span class="line">	pthread_barrier_wait(&amp;b);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Go off and perform more work ...</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">return</span>((<span class="keyword">void</span> *)<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Merge the results of the individual sorted ranges.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">merge()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">long</span>	idx[NTHR];</span><br><span class="line">	<span class="keyword">long</span>	i, minidx, sidx, num;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NTHR; i++)</span><br><span class="line">		idx[i] = i * TNUM;</span><br><span class="line">	<span class="keyword">for</span> (sidx = <span class="number">0</span>; sidx &lt; NUMNUM; sidx++) &#123;</span><br><span class="line">		num = LONG_MAX;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NTHR; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> ((idx[i] &lt; (i+<span class="number">1</span>)*TNUM) &amp;&amp; (nums[idx[i]] &lt; num)) &#123;</span><br><span class="line">				num = nums[idx[i]];</span><br><span class="line">				minidx = i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		snums[sidx] = nums[idx[minidx]];</span><br><span class="line">		idx[minidx]++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>	i;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timeval</span>	<span class="title">start</span>, <span class="title">end</span>;</span></span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span>		startusec, endusec;</span><br><span class="line">	<span class="keyword">double</span>			elapsed;</span><br><span class="line">	<span class="keyword">int</span>				err;</span><br><span class="line">	<span class="keyword">pthread_t</span>		tid;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Create the initial set of numbers to sort.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	srandom(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NUMNUM; i++)</span><br><span class="line">		nums[i] = random();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Create 8 threads to sort the numbers.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	gettimeofday(&amp;start, <span class="literal">NULL</span>);</span><br><span class="line">	pthread_barrier_init(&amp;b, <span class="literal">NULL</span>, NTHR+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NTHR; i++) &#123;</span><br><span class="line">		err = pthread_create(&amp;tid, <span class="literal">NULL</span>, thr_fn, (<span class="keyword">void</span> *)(i * TNUM));</span><br><span class="line">		<span class="keyword">if</span> (err != <span class="number">0</span>)</span><br><span class="line">			err_exit(err, <span class="string">"can't create thread"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	pthread_barrier_wait(&amp;b);</span><br><span class="line">	merge();</span><br><span class="line">	gettimeofday(&amp;end, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Print the sorted list.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	startusec = start.tv_sec * <span class="number">1000000</span> + start.tv_usec;</span><br><span class="line">	endusec = end.tv_sec * <span class="number">1000000</span> + end.tv_usec;</span><br><span class="line">	elapsed = (<span class="keyword">double</span>)(endusec - startusec) / <span class="number">1000000.0</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"sort took %.4f seconds\n"</span>, elapsed);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NUMNUM; i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%ld\n"</span>, snums[i]);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个例子给出了多个线程只执行一个任务时，使用屏障的简单情况。在更加实际的情况下，工作线程在调用<code>pthread_barrier_wait</code>函数返回后会接着执行其他的活动。</p>
<p>在这个实例中，使用8个线程分解了800万个数的排序工作。每个线程用堆排序算法对100万个数进行排序。然后主线程调用一个函数对这些结果进行合并。并不需要使用<code>pthread_barrier_wait</code>函数中的返回值<code>PTHREAD_BARRIER_SERIAL_THREAD</code>来决定哪个线程执行结果合并操作，因为我们使用了主线程来完成这个任务。这也是把屏障计数值设为工作线程数加1的原因，主线程也作为其中的一个候选线程。</p>
<h1 id="线程控制"><a href="#线程控制" class="headerlink" title="线程控制"></a>线程控制</h1><h2 id="线程限制"><a href="#线程限制" class="headerlink" title="线程限制"></a>线程限制</h2><p>Single UNIX Speeification定义了与线程操作有关的一些限制，与其他的系统限制一样，这些限制也可以通过sysconf函数进行查询。</p>
<table>
<thead>
<tr>
<th>限制名称</th>
<th>描述</th>
<th>name参数</th>
</tr>
</thead>
<tbody>
<tr>
<td>PTHREAD_DESTRUCTOR_ITERATIONS</td>
<td>线程退出时操作系统实现试图销毁线程特定数据的最大次数</td>
<td><code>_SC_THREAD_DESTRUCTOR_ITERATIONS</code></td>
</tr>
<tr>
<td>PTHREAD_KEYS_MAX</td>
<td>进程可以创建的健的最大数目</td>
<td><code>_SC_THREAD_KEYS_MAX</code></td>
</tr>
<tr>
<td>PTHREAD_STACK_HIN</td>
<td>一个线程的栈可用的最小字节数</td>
<td><code>_SC_THREAD_STACK_MIN</code></td>
</tr>
<tr>
<td>PTHREAD_THREADS_MAX</td>
<td>进程可以创建的最大线程数</td>
<td><code>SC_THREAD_THREADS_MAX</code></td>
</tr>
</tbody>
</table>
<p>这些限制的使用是为了增强应用程序在不同的操作系统实现之间的可移植性。</p>
<h2 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h2><p>pthread接口允许我们通过设置每个对象关联的不同属性来细调线程和同步对象的行为。通常，管理这些属性的函数都遵循相同的模式。</p>
<ol>
<li>每个对象与它自己类型的属性对象进行关联(线程与线程属性关联，互斥量与互斥量属性关联，等等)。一个属性对象可以代表多个属性。属性对象对应用程序来说是不透明的。这意味着应用程序并不需要了解有关属性对象内部结构的详细细节，这样可以增强应用程序的可移植性。取而代之的是，需要提供相应的函数来管理这些属性对象。</li>
<li>有一个初始化函数，把属性设置为默认值。</li>
<li>还有一个销毁属性对象的函数。如果初始化函数分配了与属性对象关联的资源，销毁函数负责释放这些资源。</li>
<li>每个属性都有一个从属性对象中获取属性值的函数。由于函数成功时会返回0；失败时会返回错误编号，所以可以通过把属性值存储在函数的某一个参数指定的内存单元中，把属性值返回给调用者。</li>
<li>每个属性都有一个设置属性值的函数。在这种情况下，属性值作为参数按值传递。</li>
</ol>
<p>所有调用<code>pthread_create</code>函数的实例中，传入的参数都是空指针，而不是指向<code>pthread_attr_t</code>结构的指针。可以使用<code>pthread_attr_t</code>结构修改线程默认属性，并把这些属性与创建的线程联系起来。可以使用<code>pthread_attr_init</code>函数初始化<code>pthread_attr_t</code>结构。在调用<code>pthread_attr_init</code>以后，<code>pthread_attr_t</code>结构所包含的就是操作系统实现支持的所有线程属性的默认值。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_init</span> <span class="params">(<span class="keyword">pthread_attr_t</span> *attr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_destroy</span> <span class="params">(<span class="keyword">pthread_attr_t</span> *attr)</span></span>;</span><br><span class="line"><span class="comment">// 两个函数的返回值：若成功，返回0；否则，返回错误编号</span></span><br></pre></td></tr></table></figure></p>
<p>如果要反初始化    <code>pthread_attr_t</code>结构， 可以调用<code>pthread_attr_destroy</code>函数。如果<code>pthread_attr_init</code>的实现对属性对象的内存空间是动态分配的，<code>pthread_attr_destroy</code>就会释放该内存空间。除此之外，<code>pthread_attr_ destroy</code>还会用无效的值初始化属性对象，因此，如果该属性对象被误用，将会导致<code>pthread_create</code>函数返回错误码。</p>
<p>下表总结了POSIX.1定义的线程属性。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>detachstate</td>
<td>线程的分离状态属性</td>
</tr>
<tr>
<td>guardsize</td>
<td>线程栈未尾的警戒缓冲区大小(字节数)</td>
</tr>
<tr>
<td>stackaddr</td>
<td>线程栈的最低地址</td>
</tr>
<tr>
<td>stackstze</td>
<td>线程栈的最小长度(字节数)</td>
</tr>
</tbody>
</table>
<p>如果在创建线程时就知道不需要了解线程的终止状态，就可以修改<code>pthread_attr_t</code>结构中的<code>detachstate</code>线程属性，让线程一开始就处于分离状态。可以使用<code>pthread_attr_setdetachstate</code>函数把线程属性<code>detachstate</code>设置成以下两个合法值之一：<code>PTHREAD_CREATE_DETACHED</code>，以分离状态启动线程；或者<code>PTHREAD_CREATE_JOINABLE</code>，正常启动线程，应用程序可以获取线程的终止状态。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthreed_attr_getdetachatate</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *<span class="keyword">restrict</span> attr, <span class="keyword">int</span> *detackstate)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_setdetachstate</span> <span class="params">(<span class="keyword">pthread_attr_t</span> *attr, <span class="keyword">int</span> *detachstate)</span></span>;</span><br><span class="line"><span class="comment">// 两个函数的返回值：若成功，返回0；否则，返回错误编号</span></span><br></pre></td></tr></table></figure></p>
<p>可以调用<code>pthread_attr_getdetachstate</code>函数获取当前的<code>detachstate</code>线程属性。第二个参数所指向的整数要么设置成<code>PTHREAD_CREATE_DETACHED</code>，要么设置成<code>PTHREAD_CREATE_JOINABLE</code>，具体要取决于给定<code>pthread_attr_t</code>结构中的属性值。</p>
<p>给出了一个以分离状态创建线程的函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">makethread(<span class="keyword">void</span> *(*fn)(<span class="keyword">void</span> *), <span class="keyword">void</span> *arg)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span>				err;</span><br><span class="line">	<span class="keyword">pthread_t</span>		tid;</span><br><span class="line">	<span class="keyword">pthread_attr_t</span>	attr;</span><br><span class="line"></span><br><span class="line">	err = pthread_attr_init(&amp;attr);</span><br><span class="line">	<span class="keyword">if</span> (err != <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span>(err);</span><br><span class="line">	err = pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);</span><br><span class="line">	<span class="keyword">if</span> (err == <span class="number">0</span>)</span><br><span class="line">		err = pthread_create(&amp;tid, &amp;attr, fn, arg);</span><br><span class="line">	pthread_attr_destroy(&amp;attr);</span><br><span class="line">	<span class="keyword">return</span>(err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意，此例忽略了<code>pthread_attr_destroy</code>函数调用的返回值。在这个实例中，我们对线程属性进行了合理的初始化，因此<code>pthread_attr_destroy</code>应该不会失败。但是，如果<code>pthread_attr_destroy</code>确实出现了失败的情况，将难以清理：必须销毁刚刚创建的线程，也许这个线程可能已经运行，并且与<code>pthread_attr_destroy</code>函数可能是异步执行的。忽略<code>pthread_attr_destroy</code>的错误返回可能出现的最坏情况是，如果<code>pthread_attr_init</code>已经分配了内存空间，就会有少量的内存泄漏。另一方面，如果<code>pthread_attr_init</code>成功地对线程属性进行了初始化，但之后<code>pthread_attr_ destroy</code>的清理工作失败，那么将没有任何补救策略，因为线程属性结构对应用程序来说是不透明的，可以对线程属性结构进行清理的唯一接口是<code>pthread_attr_destroy</code>，但它失败了。</p>
<p>可以在编译阶段使用<code>_POSIX_THREAD_ATTR_STACKADDR</code>和<code>_POSIX_THREAD_ATTR_STACKSIZE</code>符号来检查系统是否支持每一个线程栈属性。如果系统定义了这些符号中的一个，就说明它支持相应的线程栈属性。或者，也可以在运行阶段把<code>_SC_THREAD_ATTR_STACKADDR</code>和<code>_SC_THREAD_ATTR_STACKSIZE</code>参数传给<code>sysconf</code>函数，检查运行时系统对线程视属性的支持情况。</p>
<p>可以使用函数<code>pthread_attr_getstack</code>和<code>pthread_attr_setstack</code>对线程栈属性进行管理。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_getstack</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *<span class="keyword">restrict</span> attr,</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">void</span> **<span class="keyword">restrict</span> stackaddr,</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">size_t</span> *<span class="keyword">restrict</span> stacksize)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_setstack</span> <span class="params">(<span class="keyword">pthread_attr_t</span> *attr, <span class="keyword">void</span> *stackaddr, <span class="keyword">size_t</span> stacksize)</span></span>;</span><br><span class="line"><span class="comment">// 两个函数的返回值：若成功，返回0；否则，返回错误编号</span></span><br></pre></td></tr></table></figure></p>
<p>对于进程来说，虚地址空间的大小是固定的。因为进程中只有一个栈，所以它的大小通常不是问题。但对于线程来说，同样大小的虚地址空间必须被所有的线程栈共享。如果应用程序使用了许多线程，以致这些线程栈的累计大小超过了可用的虚地址空间，就需要减少默认的线程栈大小。另一方面，如果线程调用的函数分配了：大量的自动变量，或者调用的函数涉及许多很深的栈帧(stack frame)，那么需要的栈大小可能要比默认的大。</p>
<p>如果线程栈的虚地址空间都用完了，那可以使用<code>malloc</code>或者<code>mmap</code>来为可替代的栈分配空间，并用<code>pthread_attr_setstack</code>函数来改变新建线程的栈位置。由<code>stackaddr</code>参数指定的地址可以用作线程栈的内存范围中的最低可寻址地址，该地址与处理器结构相应的边界应对齐。当然，这要假设<code>malloc</code>和<code>mmap</code>所用的虚地址范围与线程栈当前使用的虚地址范围不同。</p>
<p><code>stackaddr</code>线程属性被定义为栈的最低内存地址，但这并不一定是栈的开始位置。对于一个给定的处理器结构来说，如果栈是从高地址向低地址方向增长的，那么<code>stackaddr</code>线程属性将是栈的结尾位置，而不是开始位置。</p>
<p>应用程序也可以通过<code>pthread_attr_getstacksize</code>和<code>pthread_attr_setstacksize</code>函数读取或设置线程属性<code>stacksize</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_getstacksize</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *<span class="keyword">restrict</span> attr,</span></span></span><br><span class="line"><span class="function"><span class="params">					<span class="keyword">size_t</span> *<span class="keyword">restrict</span> stacksize)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_setstacksize</span> <span class="params">(<span class="keyword">pthread_attr_t</span> *addr, <span class="keyword">size_t</span> stacksize)</span></span>;</span><br><span class="line"><span class="comment">// 两个函数的返回值：若成功，返回0；否则，返回错误编号</span></span><br></pre></td></tr></table></figure></p>
<p>如果希望改变默认的栈大小，但又不想自己处理线程栈的分配问题，这时使用<code>pthread_attr_setstacksize</code>函数就非常有用。设置<code>stacksize</code>属性时，选择的<code>stacksize</code>不能小于<code>PTHREAD_STACK_MIN</code>。</p>
<p>线程属性<code>guardsize</code>控制着线程栈未尾之后用以避免栈溢出的扩展内存的大小。可以把<code>guardsize</code>线程属性设置为0，不允许属性的这种特征行为发生，在这种情况下，不会提供警戒缓冲区。同样，如果修改了线程属性<code>stackaddr</code>，系统就认为我们将自己管理栈，使栈警戒缓冲区机制无效，这等同于把<code>guardsize</code>线程属性设置为0。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_getquardsize</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *<span class="keyword">restrict</span> attr, <span class="keyword">size_t</span> *<span class="keyword">restrict</span> guardsie)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_setguardsize</span> <span class="params">(<span class="keyword">pthread_attr_t</span> *attr, <span class="keyword">size_t</span> guandsite)</span></span>;</span><br><span class="line"><span class="comment">// 两个函数的返回值：若成功，返回0；否则，返回锖谟编号</span></span><br></pre></td></tr></table></figure></p>
<p>如果<code>guardsize</code>线程属性被修改了，操作系统可能会把它取为页大小的整数倍。如果线程的栈指针溢出到警戒区域，应用程序就可能通过信号接收到出错信息。</p>
<h2 id="同步属性"><a href="#同步属性" class="headerlink" title="同步属性"></a>同步属性</h2><h2 id="互斥量属性"><a href="#互斥量属性" class="headerlink" title="互斥量属性"></a>互斥量属性</h2><p>互斥量属性是用<code>pthread_mutexattr_t</code>结构表示的。对互斥量进行初始化时，可以通过使用<code>PTHREAD_MUTEX_INITIALIZER</code>常量或者用指向互斥量属性结构的空指针作为参数调用<code>pthread_mutex_init</code>函数，得到互斥量的默认属性。</p>
<p>对于非默认属性，可以用<code>pthread_mutexattr_init</code>初始化<code>pthread_mutexattr_t</code>结构，用<code>pthread_mutexattr_destroy</code>来反初始化。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutexattr_init</span> <span class="params">(<span class="keyword">pthread_mutexattr_t</span> *attr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutexattr_destroy</span> <span class="params">(<span class="keyword">pthread_mutexattr_t</span> *attr)</span></span>;</span><br><span class="line"><span class="comment">// 两个函数的返回值：若成功，返回0；否则，返回错误编号</span></span><br></pre></td></tr></table></figure></p>
<p><code>pthread_mutexattr_init</code>函数将用默认的互斥量属性初始化<code>pthread_mutexattr_t</code>结构。值得注意的3个属性是：进程共享属性、健壮属性以及类型属性。POSIX.1中，进程共享属性是可选的。可以通过检查系统中是否定义了<code>_POSIX_THREAD_PROCESS_SHARED</code>符号来判断这个平台是否支持进程共享这个属性，也可以在运行时把<code>_SC_THREAD_PROCESS_SHARED</code>参数传给<code>sysconf</code>函数进行检查。</p>
<p>在进程中，多个线程可以访问同一个同步对象，进程共享互斥量属性需设置为<code>PTHREAD_PROCESS_PRIVATE</code>。如果进程共享互斥量属性设置为<code>PTHREAD_PROCESS_SHARED</code>，从多个进程彼此之间共享的内存数据块中分配的互斥量就可以用于这些进程的同步。</p>
<p>可以使用<code>pthread_mutexattr_getpshared</code>函数查询<code>pthread_mutexattr_t</code>结构，得到它的进程共享属性，使用<code>pthread_mutexattr_ setpshared</code>函数修改进程共享属性。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutexattr_getpahared</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span> *<span class="keyword">restrict</span> attr, <span class="keyword">int</span> *<span class="keyword">restrict</span> prhared)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutexattr_setpshared</span> <span class="params">(<span class="keyword">pthread_mutexattr_t</span> *attr, <span class="keyword">int</span> pthared)</span></span>;</span><br><span class="line"><span class="comment">// 两个函数的返回值：若成功，返回0；否则，返回错误编号</span></span><br></pre></td></tr></table></figure></p>
<p>进程共享互斥量属性设置为<code>PTHREAD_PROCESS_PRIVATE</code>时，允许pthread线程库提供更有效的互斥量实现，这在多线程应用程序中是默认的情况。在多个进程共享多个互斥量的情况下，pthread线程库可以限制开销较大的互斥量实现。</p>
<p>互斥量健壮属性与在多个进程间共享的互斥量有关。这意味着，当持有互斥量的进程终止时，需要解决互斥量状态恢复的问题。这种情况发生时，互斥量处于锁定状态，恢复起来很困难。其他阻塞在这个锁的进程将会一直阻塞下去，可以使用<code>pthread_mutexattr_getrobust</code>函数获取健壮的互斥量属性的值。可以调用<code>pthread_mutexattr_setrobust</code>函数设置健壮的互斥最属性的值。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutexattr_getrobust</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span> *<span class="keyword">restrict</span> attr, <span class="keyword">int</span> *<span class="keyword">restrict</span> robust)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutexattr_setrobust</span> <span class="params">(<span class="keyword">pthread_mutexattr_t</span> *attr, <span class="keyword">int</span> robust)</span></span>;</span><br><span class="line"><span class="comment">// 两个函数的返回值，若成功，返回0；否则，返回错误编号</span></span><br></pre></td></tr></table></figure></p>
<p>健壮属性取值有两种可能的情况。默认值是<code>PTHREAD_MUTEX_STALLED</code>，这意味着持有互斥量的进程终止时不需要采取特别的动作。这种情况下，使用互斥量后的行为是未定义的，等待该互斥量解锁的应用程序会被有效地“拖住”。另一个取值是<code>PTHREAD_MUTEX_ROBUST</code>。这个值将导致线程调用<code>pthread_mutex_lock</code>获取锁，而该锁被另一个进程持有，但它终止时并没有对该镇进行解锁，此时线程会阻塞，从<code>pthread_mutex_lock</code>返回的值为<code>EOWNERDEAD</code>而不是0。</p>
<p>使用健壮的互斥量改变了我们使用<code>pthread_mutex_lock</code>的方式，因为现在必须检查3个返回值而不是之前的两个：不需要恢复的成功、需要恢复的成功以及失败。但是，即使不用健壮的互斥量，也可以只检查成功或者失败。</p>
<p>如果应用状态无法恢复，在线程对互斥量解锁以后，该互斥量将处于永久不可用状态。为了避免这样的问题，线程可以调用<code>pthread_mutex_consistent</code>函数，指明与该互斥量相关的状态在互斥量解锁之前是一致的。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_consistent</span> <span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"><span class="comment">// 返回值，若成功，返回0；否则，返回错误编号</span></span><br></pre></td></tr></table></figure></p>
<p>如果线程没有先调用<code>pthread_mutex_consistent</code>就对互斥最进行了解锁，那么其他试图获取该互斥最的阻塞线程就会得到错误码<code>ENOTRECOVERABLE</code>。如果发生这种情况，互斥量将不再可用。线程通过提前调用<code>pthread_mutex_consistent</code>，能让互斥量正常工作，这样它就<br>可以持续被使用。</p>
<p><strong>类型互斥量</strong>属性控制着互斥量的锁定特性。POSIX.1定义了4种类型：</p>
<ul>
<li><code>PTHREAD_MUTEX_NORMAL</code>：标准互斥量类型，不做任何特殊的错误检查或死锁检测。</li>
<li><code>PTHREAD_MUTEX_ERRORCHECK</code>：此互斥量类型提供错误检查。</li>
<li><code>PTHREAD_MUTEX_RECURSIVE</code>：此互斥量类型允许同一线程在互斥量解锁之前对该互斥量进行多次加锁。递归互斥量维护锁的计数，在解锁次数和加锁次数不相同的情况下，不会释放锁。所以，如果对一个递归互斥量加锁两次，然后解锁一次，那么这个互斥量将依然处于加锁状态，对它再次解锁以前不能释放该锁。</li>
<li><code>PTHREAD_MUTEX_DEFAULT</code>：此互斥量类型可以提供默认特性和行为。操作系统在实现它的时候可以把这种类型自由地映射到其他互斥量类型中的一种。</li>
</ul>
<p>这4种类型的行为如表所示。”不占用时解锁”这一栏指的是，一个线程对被另一个线程加锁的互斥量进行解锁的情况。“在已解锁时解锁”这一栏指的是， 当一个线程对已经解锁的互斥量进行解锁时将会发生什么，这通常是编码错误引起的。</p>
<table>
<thead>
<tr>
<th>互斥量类型</th>
<th>没有解锁时重新加镇?</th>
<th>不占用时解锁?</th>
<th>在已解锁时解锁?</th>
</tr>
</thead>
<tbody>
<tr>
<td>PTHREAD_MUTEX_NORMAL</td>
<td>死锁</td>
<td>未定义</td>
<td>未定义</td>
</tr>
<tr>
<td>PTHREAD_MUTEX_ERRORCHECK</td>
<td>返回错误</td>
<td>返回错误</td>
<td>返回错误</td>
</tr>
<tr>
<td>PTHREAD_MUTEX RECURSIVE</td>
<td>允许</td>
<td>返回错误</td>
<td>返回错误</td>
</tr>
<tr>
<td>PTHREAD_MUTEX_DEFAULT</td>
<td>未定义</td>
<td>未定义</td>
<td>未定义</td>
</tr>
</tbody>
</table>
<p>可以用<code>pthread_mutexattr_gettype</code>函数得到互斥量类型属性，用<code>pthread_mutexattr_settype</code>函数修改互斥量类型属性。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutexattr_gettype</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span> *<span class="keyword">restrict</span> attr, <span class="keyword">int</span> *<span class="keyword">restrict</span> type)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutexattr_settype</span> <span class="params">(<span class="keyword">pthread_mutexattr_t</span> *attr, <span class="keyword">int</span> type)</span></span>;</span><br><span class="line"><span class="comment">// 两个函数的返回值：若成功，返回0；否则，返回错误编号</span></span><br></pre></td></tr></table></figure></p>
<p>如果递归互斥量被多次加锁，然后用在调用<code>pthread_cond_wait</code>函数中，那么条件永远都不会得到满足，因为<code>pthread_cond_wait</code>所做的解锁操作并不能释放互斥量。如果需要把现有的单线程接口放到多线程环境中，递归互斥量是非常有用的，但由于现有程序兼容性的限制，不能对函数接口进行修改。然而，使用递归锁可能很难处理，因此应该只在没有其他可行方案的时候才使用它们。</p>
<p>程序解释了有必要使用递归互斥量的另一 种情况。这里，有一个“超时”(timeout)函数，它允许安排另一个函数在未来的某个时间运行。假设线程并不是很昂贵的资源，就可以为每个挂起的超时函数创建一个线程。线程在时间来到时将一 直等待，时间到了以后再调用请求的函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">makethread</span><span class="params">(<span class="keyword">void</span> *(*)(<span class="keyword">void</span> *), <span class="keyword">void</span> *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">to_info</span> &#123;</span></span><br><span class="line">	<span class="keyword">void</span>	      (*to_fn)(<span class="keyword">void</span> *);	<span class="comment">/* function */</span></span><br><span class="line">	<span class="keyword">void</span>           *to_arg;			<span class="comment">/* argument */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">to_wait</span>;</span>		<span class="comment">/* time to wait */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SECTONSEC  1000000000	<span class="comment">/* seconds to nanoseconds */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(CLOCK_REALTIME) || defined(BSD)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clock_nanosleep(ID, FL, REQ, REM)	nanosleep((REQ), (REM))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CLOCK_REALTIME</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLOCK_REALTIME 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> USECTONSEC 1000		<span class="comment">/* microseconds to nanoseconds */</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">clock_gettime(<span class="keyword">int</span> id, struct timespec *tsp)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line"></span><br><span class="line">	gettimeofday(&amp;tv, <span class="literal">NULL</span>);</span><br><span class="line">	tsp-&gt;tv_sec = tv.tv_sec;</span><br><span class="line">	tsp-&gt;tv_nsec = tv.tv_usec * USECTONSEC;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *</span><br><span class="line">timeout_helper(<span class="keyword">void</span> *arg)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">to_info</span>	*<span class="title">tip</span>;</span></span><br><span class="line"></span><br><span class="line">	tip = (struct to_info *)arg;</span><br><span class="line">	clock_nanosleep(CLOCK_REALTIME, <span class="number">0</span>, &amp;tip-&gt;to_wait, <span class="literal">NULL</span>);</span><br><span class="line">	(*tip-&gt;to_fn)(tip-&gt;to_arg);</span><br><span class="line">	<span class="built_in">free</span>(arg);</span><br><span class="line">	<span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">timeout(<span class="keyword">const</span> struct timespec *when, <span class="keyword">void</span> (*func)(<span class="keyword">void</span> *), <span class="keyword">void</span> *arg)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timespec</span>	<span class="title">now</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">to_info</span>	*<span class="title">tip</span>;</span></span><br><span class="line">	<span class="keyword">int</span>				err;</span><br><span class="line"></span><br><span class="line">	clock_gettime(CLOCK_REALTIME, &amp;now);</span><br><span class="line">	<span class="keyword">if</span> ((when-&gt;tv_sec &gt; now.tv_sec) ||</span><br><span class="line">	  (when-&gt;tv_sec == now.tv_sec &amp;&amp; when-&gt;tv_nsec &gt; now.tv_nsec)) &#123;</span><br><span class="line">		tip = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct to_info));</span><br><span class="line">		<span class="keyword">if</span> (tip != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			tip-&gt;to_fn = func;</span><br><span class="line">			tip-&gt;to_arg = arg;</span><br><span class="line">			tip-&gt;to_wait.tv_sec = when-&gt;tv_sec - now.tv_sec;</span><br><span class="line">			<span class="keyword">if</span> (when-&gt;tv_nsec &gt;= now.tv_nsec) &#123;</span><br><span class="line">				tip-&gt;to_wait.tv_nsec = when-&gt;tv_nsec - now.tv_nsec;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				tip-&gt;to_wait.tv_sec--;</span><br><span class="line">				tip-&gt;to_wait.tv_nsec = SECTONSEC - now.tv_nsec +</span><br><span class="line">				  when-&gt;tv_nsec;</span><br><span class="line">			&#125;</span><br><span class="line">			err = makethread(timeout_helper, (<span class="keyword">void</span> *)tip);</span><br><span class="line">			<span class="keyword">if</span> (err == <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="built_in">free</span>(tip);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We get here if (a) when &lt;= now, or (b) malloc fails, or</span></span><br><span class="line"><span class="comment">	 * (c) we can't make a thread, so we just call the function now.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	(*func)(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_mutexattr_t</span> attr;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">retry(<span class="keyword">void</span> *arg)</span><br><span class="line">&#123;</span><br><span class="line">	pthread_mutex_lock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* perform retry steps ... */</span></span><br><span class="line"></span><br><span class="line">	pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span>				err, condition, arg;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timespec</span>	<span class="title">when</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((err = pthread_mutexattr_init(&amp;attr)) != <span class="number">0</span>)</span><br><span class="line">		err_exit(err, <span class="string">"pthread_mutexattr_init failed"</span>);</span><br><span class="line">	<span class="keyword">if</span> ((err = pthread_mutexattr_settype(&amp;attr,</span><br><span class="line">	  PTHREAD_MUTEX_RECURSIVE)) != <span class="number">0</span>)</span><br><span class="line">		err_exit(err, <span class="string">"can't set recursive type"</span>);</span><br><span class="line">	<span class="keyword">if</span> ((err = pthread_mutex_init(&amp;mutex, &amp;attr)) != <span class="number">0</span>)</span><br><span class="line">		err_exit(err, <span class="string">"can't create recursive mutex"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* continue processing ... */</span></span><br><span class="line"></span><br><span class="line">	pthread_mutex_lock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Check the condition under the protection of a lock to</span></span><br><span class="line"><span class="comment">	 * make the check and the call to timeout atomic.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (condition) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Calculate the absolute time when we want to retry.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		clock_gettime(CLOCK_REALTIME, &amp;when);</span><br><span class="line">		when.tv_sec += <span class="number">10</span>;	<span class="comment">/* 10 seconds from now */</span></span><br><span class="line">		timeout(&amp;when, retry, (<span class="keyword">void</span> *)((<span class="keyword">unsigned</span> <span class="keyword">long</span>)arg));</span><br><span class="line">	&#125;</span><br><span class="line">	pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* continue processing ... */</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果我们不能创建线程，或者安排函数运行的时间已过，这时问题就出现了。在这些情况下，我们只需在当前上下文中调用之前请求运行的函数。因为函数要获取的愤和我们现在占有的锁是同一个，所以除非该锁是递归的，否则就会出现死锁。</p>
<p>我们使用<code>makethread</code>函数以分离状态创建线程，因为传递给<code>timeout</code>函数的<code>func</code>函数参数将在未来运行，所以我们不希望一直空等线程结束。可以调用<code>sleep</code>等待超时到期，但它提供的时间粒度是秒级的。如果希望等待的时间不是整数秒，就需要用<code>nanosleep</code>或者<code>clock_nanosleep</code>函数，它们两个提供了更高精度的休眠时间。</p>
<h3 id="读写锁属性"><a href="#读写锁属性" class="headerlink" title="读写锁属性"></a>读写锁属性</h3><p>读写锁与互斥量类似，也是有属性的。可以用<code>pthread_rwlockattr_init</code>初始化<code>pthread_rwlockattr_t</code>结构，用<code>pthread_rwlockattr_destroy</code>反初始化该结构。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlockattr_init</span> <span class="params">(<span class="keyword">pthread_rwlockattr_t</span> *attr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlockattr_deatroy</span> <span class="params">(<span class="keyword">pthread_rwlockattr_t</span> *attr)</span></span>;</span><br><span class="line"><span class="comment">// 两个函数的返回值：若成功，返回0；否则，返回错误编号</span></span><br></pre></td></tr></table></figure></p>
<p>读写锁支持的唯一属性是进程共享属性。它与互斥量的进程共享属性是相同的。就像互斥量的进程共享属性一样，有一对函数用于读取和设置读写锁的进程共享属性。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlockattr_getpshared</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_rwlockattr_t</span> *<span class="keyword">restrict</span> attr, <span class="keyword">int</span> *<span class="keyword">restrict</span> pshared)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlockattr_setpshared</span> <span class="params">(<span class="keyword">pthread_rwlockattr_t</span> *attr, <span class="keyword">int</span> pshared)</span></span>;</span><br><span class="line"><span class="comment">// 两个函数的返回值，若成功，返回0；否则，返回错误编号</span></span><br></pre></td></tr></table></figure></p>
<h3 id="条件变量属性"><a href="#条件变量属性" class="headerlink" title="条件变量属性"></a>条件变量属性</h3><p>目前定义了条件变量的两个属性：进程共享属性和时钟属性。与其他的属性对象一样，有一对函数用于初始化和反初始化条件变量属性。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_condattr_init</span> <span class="params">(<span class="keyword">pthread_condattr_t</span> *attr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_condattr_destroy</span> <span class="params">(<span class="keyword">pthread_condattr_t</span> *attr)</span></span>;</span><br><span class="line"><span class="comment">// 两个函数的返回值，若成功，返回0；否则，返回错误编号</span></span><br></pre></td></tr></table></figure></p>
<p>与其他的同步属性一样，条件变量支持进程共享属性。它控制着条件变量是可以被单进程的多个线程使用，还是可以被多进程的线程使用。要获取进程共享属性的当前值，可以用<code>pthread_condattr_getpshared</code>函数。设置该值可以用<code>pthread_condattr_setpshared</code>函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_condattr_getpshared</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_condattr_t</span> *<span class="keyword">restrict</span> attr, <span class="keyword">int</span> *<span class="keyword">restrict</span> pshared)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_condattr_setpshared</span> <span class="params">(<span class="keyword">pthread_condattr_t</span> *attr, <span class="keyword">int</span> pshared)</span></span>;</span><br><span class="line"><span class="comment">// 两个函数的返回值，若成功，返回0；否则，返回错误编号</span></span><br></pre></td></tr></table></figure></p>
<p>时钟属性控制计算<code>pthread_cond_timedwait</code>函数的超时参数(<code>tspr</code>)时采用的是哪个时钟。可以使用<code>pthread_condattr_getclock</code>函数获取可被用于<code>pthread_cond_timedwait</code>函数的时钟ID，在使用<code>pthread_cond_timedwait</code>函数前需要用<code>pthread_condattr_t</code>对象对条件变量进行初始化。可以用<code>pthread_condattr_setclock</code>函数对时钟ID进行修改。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> epthread.h&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_condattr_getclock</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_condattr_t</span> *<span class="keyword">restrict</span> attr, <span class="keyword">clockid_t</span> *<span class="keyword">restrict</span> clock_id)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_condattr_setclock</span> <span class="params">(<span class="keyword">pthread_condattr_t</span> *attr, <span class="keyword">clockid_t</span> clock_d)</span></span>;</span><br><span class="line"><span class="comment">// 两个函数的返回值；若成功，返回0；否则，返回镨误编号</span></span><br></pre></td></tr></table></figure></p>
<h3 id="屏障属性"><a href="#屏障属性" class="headerlink" title="屏障属性"></a>屏障属性</h3><p>屏障也有属性。可以使用<code>pthread_barrierattr_init</code>函数对屏障属性对象进行初始化，用<code>pthread_barrierattr_destroy</code>函数对屏障属性对象进行反初始化。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_barrierattr_init</span> <span class="params">(pthread_barrier *attr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_barrierattr_destroy</span> <span class="params">(<span class="keyword">pthread_barrierattr_t</span> *attr)</span></span>;</span><br><span class="line"><span class="comment">// 两个函数的返回值，若成功，返回0；否则，返回错误编号</span></span><br></pre></td></tr></table></figure></p>
<p>目前定义的屏障属性只有进程共享属性，它控制着屏障是可以被多进程的线程使用，还是只能被初始化屏障的进程内的多线程使用。与其他属性对象一样，有一个获取属性值的函数(<code>pthread_barrierattr_getpshared</code>)和一个设置属性值的函数(<code>pthread_barrierattr_setpshared</code>)。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_barrierattr_getpshared</span> <span class="params">(<span class="keyword">const</span> pthread_barrier *<span class="keyword">restrict</span> attr, <span class="keyword">int</span> *<span class="keyword">restrict</span> pthared)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_barrierattr_setpshared</span> <span class="params">(<span class="keyword">pthread_barrierattr_t</span> *attr, <span class="keyword">int</span> pshared)</span></span>;</span><br><span class="line"><span class="comment">// 两个函数的返回值，若成功，返回0；否则，返回错误编号</span></span><br></pre></td></tr></table></figure></p>
<p>进程共享属性的值可以是<code>PTHREAD_PROCESS_SHARED</code>(多进程中的多个线程可用)，也可以是<code>PTHREAD_PROCESS_PRIVATE</code>(只有初始化屏障的那个进程内的多个线程可用)。</p>
<h2 id="重入"><a href="#重入" class="headerlink" title="重入"></a>重入</h2><p>如果一个函数在相同的时间点可以被多个线程安全地调用，就称该函数是<strong>线程安全</strong>的。除了图中列出的函数，其他函数都保证是线程安全的。<br><img src="/img/1622445555.jpg" alt></p>
<p>另外，<code>ctermid</code>和<code>tmpnam</code>函数在参数传入空指针时并不能保证是线程安全的。类似地。如果参数<code>mbstate_t</code>传入的是空指针，也不能保证<code>wertomb</code>和<code>wcsrtombs</code>函数是线程安全的。</p>
<p>支持线程安全函数的操作系统实现会在<code>&lt;unistd.h&gt;</code>中定义符号<code>_POSIX_THREAD_SAFE_FUNCTIONS</code>。应用程序也可以在<code>sysconf</code>函数中传入<code>_SC_THREAD_SAFE_FUNCTIONS</code>参数在运行时检查是否支持线程安全函数。</p>
<p>操作系统实现支持线程安全函数这个特性时，对POSIX.1中的一些非线程安全函数，它会提供可替代的线程安全版本，图中列出了这些函数的线程安全版本。这些函数的命名方式与它们的非线程安全版本的名字相似，只不过在名字最后加了<code>_r</code>，表明这些版本是可重入的。很多函数并不是线程安全的，因为它们返回的数据存放在静态的内存缓冲区中。通过修改接口，要求调用者自己提供缓冲区可以使函数变为线程安全。</p>
<table>
<thead>
<tr>
<th>线程安全函数</th>
</tr>
</thead>
<tbody>
<tr>
<td>getgrgid_r</td>
</tr>
<tr>
<td>localtime_r</td>
</tr>
<tr>
<td>getgrnam_r</td>
</tr>
<tr>
<td>readdir_r</td>
</tr>
<tr>
<td>getlogin_r</td>
</tr>
<tr>
<td>strerror_r</td>
</tr>
<tr>
<td>getpwnam_r</td>
</tr>
<tr>
<td>strtok_z</td>
</tr>
<tr>
<td>getpwuid_r</td>
</tr>
<tr>
<td>ttynane_r</td>
</tr>
<tr>
<td>gmtime_r</td>
</tr>
</tbody>
</table>
<p>如果函数对异步信号处理程序的重入是安全的，那么就可以说函数是异步信号安全的。</p>
<p>POSIX.1还提供了以线程安全的方式管理<code>FILE</code>对象的方法。可以使用<code>flockfile</code>和<code>ftrylockfile</code>获取给定<code>FILE</code>对象关联的锁。这个锁是递归的：当你占有这把锁的时候，还是可以再次获取该锁，而且不会导致死锁。虽然这种锁的具体实现并无规定，但要求所有操作<code>FILE</code>对象的标准例程的动作行为必须看起来就像它们内部调用了<code>flockfile</code>和<code>funlockfile</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ftrylockfile</span><span class="params">(FILE *fp)</span></span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回0；若不能获取，返回非0数值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flocktile</span><span class="params">(FILE *fp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">funlockfile</span> <span class="params">(FTLE *fp)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>如果标准例程都获取它们各自的锁，那么在做一次一个字符的I/O时就会出现严重的性能下降。在这种情况下，需要对每一个字符的读写操作进行获取锁和释放锁的动作。为了避免这种开销，出现了不加锁版本的基于字符的标准I/O例程。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getchar_unlocked</span> <span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getc_unlocked</span> <span class="params">(FILE *fp)</span></span>;</span><br><span class="line"><span class="comment">// 两个函数的返回值：若成功，返回下一个字符，若遇到文件尾或者出错，返回EOF</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">putchar_unlocked</span><span class="params">(<span class="keyword">int</span> e)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">putc_unlocked</span><span class="params">(<span class="keyword">int</span> e, FILE *fp)</span></span>;</span><br><span class="line"><span class="comment">// 两个函数的返回值，若成功，返回c；若出错，返回BOF</span></span><br></pre></td></tr></table></figure></p>
<p>除非被<code>flockfile</code>(或<code>ftrylockfile</code>)和<code>funlockfile</code>的调用包围，否则尽量不要调用这4个函数，因为它们会导致不可预期的结果(比如，由于多个控制线程非同步访问数据引起的种种问题)。一旦对FILE对象进行加锁，就可以在释放锁之前对这些函数进行多次调用。这样就可以在多次的数据读写上分摊总的加解锁的开销。</p>
<p>给出了<code>getenv</code>的可重入的版本。这个版本叫做<code>getenv_r</code>。它使用<code>pthread_once</code>函数来确保不管多少线程同时竞争调用<code>getenv_r</code>，每个进程只调用<code>thread_init</code>函数一次。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> **environ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> env_mutex;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_once_t</span> init_done = PTHREAD_ONCE_INIT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">thread_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">pthread_mutexattr_t</span> attr;</span><br><span class="line"></span><br><span class="line">	pthread_mutexattr_init(&amp;attr);</span><br><span class="line">	pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_RECURSIVE);</span><br><span class="line">	pthread_mutex_init(&amp;env_mutex, &amp;attr);</span><br><span class="line">	pthread_mutexattr_destroy(&amp;attr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">getenv_r(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">char</span> *buf, <span class="keyword">int</span> buflen)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> i, len, olen;</span><br><span class="line"></span><br><span class="line">	pthread_once(&amp;init_done, thread_init);</span><br><span class="line">	len = <span class="built_in">strlen</span>(name);</span><br><span class="line">	pthread_mutex_lock(&amp;env_mutex);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; environ[i] != <span class="literal">NULL</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((<span class="built_in">strncmp</span>(name, environ[i], len) == <span class="number">0</span>) &amp;&amp;</span><br><span class="line">		  (environ[i][len] == <span class="string">'='</span>)) &#123;</span><br><span class="line">			olen = <span class="built_in">strlen</span>(&amp;environ[i][len+<span class="number">1</span>]);</span><br><span class="line">			<span class="keyword">if</span> (olen &gt;= buflen) &#123;</span><br><span class="line">				pthread_mutex_unlock(&amp;env_mutex);</span><br><span class="line">				<span class="keyword">return</span>(ENOSPC);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">strcpy</span>(buf, &amp;environ[i][len+<span class="number">1</span>]);</span><br><span class="line">			pthread_mutex_unlock(&amp;env_mutex);</span><br><span class="line">			<span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	pthread_mutex_unlock(&amp;env_mutex);</span><br><span class="line">	<span class="keyword">return</span>(ENOENT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>要使<code>getenv_r</code>可重入，需要改变接口，调用者必须提供它自己的缓冲区，这样每个线程可以使用各自不同的缓冲区避免其他线程的干扰。但是，注意，要想使<code>getenv_r</code>成为线程安全的，这样做还不够，需要在搜索请求的字符时保护环境不被修改。可以使用互斥量，通过<code>getenv_r</code>和<code>putenv</code>函数对环境列表的访问进行串行化。</p>
<p>可以使用读写锁，从而允许对<code>getenv_r</code>进行多次并发访问，但增加的并发性可能并不会在很大程度上改善程序的性能，这里面有两个原因第一，环境列表通常并不会很长，所以扫描列表时并不需要长时间地占有互斥量；第二，对<code>getenv</code>和<code>putenv</code>的调用也不是频繁发生的，所以改善它们的性能并不会对程序的整体性能产生很大的影响。</p>
<p>即使可以把<code>getenv_r</code>变成线程安全的，这也不意味着它对信号处理程序是可重入的。如果使用的是非递归的互斥量，线程从信号处理程序中调用<code>getenv_r</code>就有可能出现死锁。如果信号处理程序在线程执行<code>getenv_r</code>时中断了该线程，这时我们已经占有加锁的<code>env_mutex</code>，这样其他线程试图对这个互斥量的加锁就会被阻塞，最终导致线程进入死锁状态。所以，必须使用递归互斥量阻止其他线程改变我们正需要的数据结构，还要阻止来自信号处理程序的死锁。</p>
<h2 id="线程特定数据"><a href="#线程特定数据" class="headerlink" title="线程特定数据"></a>线程特定数据</h2><p><strong>线程特定数据</strong>(thread-specific data), 也称为线程私有数据(thread-private data)，是存储和查询某个特定线程相关数据的一种机制。我们希望每个线程可以访问它自己单独的数据副本，而不需要担心与其他线程的同步访问问题。</p>
<p>线程模型促进了进程中数据和属性的共享，许多人在设计线程模型时会遇到各种麻烦。那么为什么有人想在这样的模型中促进阻止共享的接口呢?这其中有两个原因。</p>
<ul>
<li>有时候需要维护基于每线程(per-bread)的数据。因为线程ID并不能保证是小而连续的整数，所以就不能简单地分配一个每线程数据数组，用线程ID作为数组的索引。</li>
<li>它提供了让基于进程的接口适应多线程环境的机制。系统调用和库例程在调用或执行失败时设置<code>errno</code>，为了让线程也能够使用那些原本基于进程的系统调用和库例程，<code>errno</code>被重新定义为线程私有数据。这样，一个线程做了重置<code>errno</code>的操作也不会影响进程中其他线程的<code>errno</code>值。</li>
</ul>
<p>在分配线程特定数据之前，需要创建与该数据关联的键。这个键将用于获取对线程特定数据的访问。使用<code>pthread_key_create</code>创建一个键<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_key_create</span> <span class="params">(<span class="keyword">pthread_key_t</span> *keyp, <span class="keyword">void</span> (*destructor) (<span class="keyword">void</span> *))</span></span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回0；否则，返回错误编号</span></span><br></pre></td></tr></table></figure></p>
<p>创建的键存储在<code>keyp</code>指向的内存单元中，这个键可以被进程中的所有线程使用，但每个线程把这个键与不同的线程特定数据地址进行关联。创建新键时，每个线程的数据地址设为空值。除了创建键以外，<code>pthread_key_create</code>可以为该键关联一个可选择的析构函数。当这个线程退出时，如果数据地址已经被置为非空值，那么析构函数就会被调用，它唯一的参数就是该数据地址。如果传入的析构函数为空，就表明没有析构函数与这个键关联。当线程调用<code>pthread_exit</code>或者线程执行返回，正常退出时，析构函数就会被调用。同样，线程取消时，只有在最后的清理处理程序返回之后，析构函数才会被调用。如果线程调用了<code>exit</code>、<code>_exit</code>、<code>_Exit</code>或<code>abort</code>，或者出现其他非正常的退出时，就不会调用析构函数。</p>
<p>线程通常使用<code>malloc</code>为线程特定数据分配内存，析构函数通常释放已分配的内存。如果线程在没有释放内存之前就退出了，那么这块内存就会丢失，即线程所属进程就出现了内存泄漏。</p>
<p>线程退出时，线程特定数据的析构函数将按照操作系统实现中定义的顺序被调用。析构函数可能会调用另一个函数，该函数可能会创建新的线程特定数据，并且把这个数据与当前的键关联起来。当所有的析构函数都调用完成以后，系统会检查是否还有非空的线程特定数据值与键关联，如果有的话，再次调用析构函数。这个过程将会一直重复直到线程所有的键都为空线程特定数据值，或者已经做了<code>PTHREAD_DESTRUCTOR_LITERATIONS</code>中定义的最大次数的尝试。</p>
<p>对所有的线程，我们都可以通过调用<code>pthread_key_delete</code>来取消键与线程特定数据值之间的关联关系。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_key_delete</span> <span class="params">(<span class="keyword">pthreed_key_t</span> key)</span></span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回0；否则，返回错误编号</span></span><br></pre></td></tr></table></figure></p>
<p>注意，调用<code>pthread_key_delete</code>并不会激活与键关联的析构函数。要释放任何与键关联的线程特定数据值的内存，需要在应用程序中采取额外的步骤。</p>
<p>需要确保分配的键并不会由于在初始化阶段的竞争而发生变动。下面的代码会导致两个线程都调用<code>pthread_key_create</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destructor</span> <span class="params">(<span class="keyword">void</span> *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_key_t</span> key;</span><br><span class="line"><span class="keyword">int</span> init_done = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">threadfunc</span> <span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!init_done) &#123;</span><br><span class="line">		init_done = <span class="number">1</span>;</span><br><span class="line">		err = pthread_key_create (&amp;key, destructor);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>有些线程可能看到一个键值，而其他的线程看到的可能是另一个不同的键值，这取决于系统是如何调度线程的，解决这种竞争的办法是使用<code>pthread_once</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="keyword">pthread_once_t</span> iniflag = PTHREAD_ONCE_INIT;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_once</span> <span class="params">(<span class="keyword">pthread_once_t</span> *initflag, <span class="keyword">void</span> (*inifn(<span class="keyword">void</span>));</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">// 返回值：若成功，返回0；否则，返回错误编号</span></span></span></span><br></pre></td></tr></table></figure></p>
<p><code>initflag</code>必须是一个非本地变量(如全局变量或静态变量)，而且必须初始化为<code>PTHREAD_ONCE_INIT</code>。</p>
<p>如果每个线程都调用<code>pthread_once</code>，系统就能保证初始化例程<code>initfn</code>只被调用一次，即系统首次调用<code>pthread_once</code>时。创建键时避免出现冲突的一个正确方法如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destructor</span> <span class="params">(<span class="keyword">void</span> *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_key_t</span> key;</span><br><span class="line"><span class="keyword">pthreed_once_t</span> init_done = PTHREAD_ONCE_INTT;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_init</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">exit</span> = pthread_key_create(&amp;key, destructor);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">threadfunc</span> <span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">	pthread_once(&amp;init_done, thread_init);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>键一旦创建以后，就可以通过调用<code>pthread_setspecific</code>函数把键和线程特定数据关联起来。可以通过<code>pthread_getspecific</code>函数获得线程特定数据的地址。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">pthread_getspecitic</span> <span class="params">(<span class="keyword">pthread_key_t</span> key)</span></span>;</span><br><span class="line"><span class="comment">// 返回值，线程特定数据值，若没有值与该键关联，返回NULL</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_setspecific</span> <span class="params">(<span class="keyword">pthread_key_t</span> key, <span class="keyword">const</span> <span class="keyword">void</span> *value)</span></span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回0；否则，返回错误编号</span></span><br></pre></td></tr></table></figure></p>
<p>如果没有线程特定数据值与键关联，<code>pthread_getspecific</code>将返回一个空指针，我们可以用这个返回值来确定是否需要调用<code>pthread_setspecific</code>。</p>
<p>可以使用线程特定数据来维护每个线程的数据缓冲区副本，用于存放各自的返回字符串。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSTRINGSZ	4096</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_key_t</span> key;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_once_t</span> init_done = PTHREAD_ONCE_INIT;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> env_mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> **environ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">thread_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	pthread_key_create(&amp;key, <span class="built_in">free</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *</span><br><span class="line">getenv(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span>		i, len;</span><br><span class="line">	<span class="keyword">char</span>	*envbuf;</span><br><span class="line"></span><br><span class="line">	pthread_once(&amp;init_done, thread_init);</span><br><span class="line">	pthread_mutex_lock(&amp;env_mutex);</span><br><span class="line">	envbuf = (<span class="keyword">char</span> *)pthread_getspecific(key);</span><br><span class="line">	<span class="keyword">if</span> (envbuf == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		envbuf = <span class="built_in">malloc</span>(MAXSTRINGSZ);</span><br><span class="line">		<span class="keyword">if</span> (envbuf == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			pthread_mutex_unlock(&amp;env_mutex);</span><br><span class="line">			<span class="keyword">return</span>(<span class="literal">NULL</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		pthread_setspecific(key, envbuf);</span><br><span class="line">	&#125;</span><br><span class="line">	len = <span class="built_in">strlen</span>(name);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; environ[i] != <span class="literal">NULL</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((<span class="built_in">strncmp</span>(name, environ[i], len) == <span class="number">0</span>) &amp;&amp;</span><br><span class="line">		  (environ[i][len] == <span class="string">'='</span>)) &#123;</span><br><span class="line">			<span class="built_in">strncpy</span>(envbuf, &amp;environ[i][len+<span class="number">1</span>], MAXSTRINGSZ<span class="number">-1</span>);</span><br><span class="line">			pthread_mutex_unlock(&amp;env_mutex);</span><br><span class="line">			<span class="keyword">return</span>(envbuf);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	pthread_mutex_unlock(&amp;env_mutex);</span><br><span class="line">	<span class="keyword">return</span>(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们使用<code>pthread_once</code>来确保只为我们将使用的线程特定数据创建一个键。如果<code>pthread_getspecific</code>返回的是空指针，就需要先分配内存缓冲区，然后再把键与该内存缓冲区关联。否则，如果返回的不是空指针，就使用<code>pthread_getspecific</code>返回的内存缓冲区。</p>
<p>对析构函数，使用<code>free</code>来释放之前由<code>malloc</code>分配的内存。只有当线程特定数据值为非空时，析构函数才会被调用。</p>
<h2 id="取消选项"><a href="#取消选项" class="headerlink" title="取消选项"></a>取消选项</h2><p>有两个线程属性并没有包含在<code>pthread_attr_t</code>结构中，它们是可取消状态和可取消类型。这两个属性影响着线程在响应<code>pthread_cancel</code>函数调用时所呈现的行为。</p>
<p>可取消状态属性可以是<code>PTHREAD_CANCEL_ENABLE</code>，也可以是<code>PTHREAD_CANCEL_DISABLE</code>。线程可以通过调用<code>pthread_setcancelstate</code>修改它的可取消状态。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_setcancelstate</span> <span class="params">(<span class="keyword">int</span> state, <span class="keyword">int</span> *oldstate)</span></span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回0；否则，返回错误编号</span></span><br></pre></td></tr></table></figure></p>
<p><code>pthread_setcancelstate</code>把当前的可取消状态设置为state，把原来的可取消状态存储在由oldstare指向的内存单元，这两步是一个原子操作。</p>
<p>线程启动时默认的可取消状态是<code>PTHREAD_CANCEL_ENABLE</code>。当状态设为<code>PTHREAD_CANCEL_DISABLE</code>时，对<code>pthread_cancel</code>的调用并不会杀死线程。相反，取消请求对这个线程来说还处于挂起状态，当取消状态再次变为<code>PTHREAD_CANCEL_ENABLE</code>时，线程将在下一个取消点上对所有挂起的取消请求进行处理。</p>
<p>可以调用<code>pthread_testcancel</code>函数在程序中添加自己的取消点。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_testcancel</span> <span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>调用<code>pthread_testcancel</code>时，如果有某个取消请求正处于挂起状态，而且取消并没有置为无效，那么线程就会被取消。但是，如果取消被置为无效，<code>pthread_testcancel</code>调用就没有任何效果了。</p>
<p>我们所描述的默认的取消类型也称为推迟取消。调用<code>pthread_cancel</code>以后，在线程到达取消点之前，并不会出现真正的取消。可以通过调用<code>pthread_setcanceltype</code>来修改取消类型。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.b&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_setcanceltype</span><span class="params">(<span class="keyword">int</span> tyye, <span class="keyword">int</span> *oldtype)</span></span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回0；否则，返回错误编号</span></span><br></pre></td></tr></table></figure></p>
<p><code>pthread_setcanceltype</code>函数把取消类型设置为<code>type</code>(类型参数可以是<code>PTHREADCANCEL_DEFERRED</code>，也可以是<code>PTHREAD_CANCEL_ASYNCKRONOUS</code>)，把原来的取消类型返回到<code>oldype</code>指向的整型单元。</p>
<p>异步取消与推迟取消不同，因为使用异步取消时，线程可以在任意时间撒消，不是非得遇到取消点才能被取消。</p>
<h2 id="线程和信号"><a href="#线程和信号" class="headerlink" title="线程和信号"></a>线程和信号</h2><p>每个线程都有自己的信号屏蔽字，但是信号的处理是进程中所有线程共享的。这意味着单个线程可以阻止某些信号，但当某个线程修改了与某个给定信号相关的处理行为以后，所有的线程都必须共享这个处理行为的改变。这样，如果一个线程选择忽略某个给定信号，那么另一个线程就可以通过以下两种方式撤消上述线程的信号选择：恢复信号的默认处理行为，或者为信号设置个新的信号处理程序。</p>
<p>进程中的信号是递送到单个线程的。如果一个信号与硬件故障相关，那么该信号一般会被发送到引起该事件的线程中去，而其他的信号则被发送到任意一个线程。</p>
<p>10.12节讨论了进程如何使用<code>sigprocmask</code>函数来阻止信号发送。然而，<code>sigprocmask</code>的行为在多线程的进程中并没有定义，线程必须使用<code>pthread_sigmask</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_sigmask</span><span class="params">(<span class="keyword">int</span> how, <span class="keyword">const</span> <span class="keyword">sigset_t</span> *<span class="keyword">restrict</span> <span class="built_in">set</span>, <span class="keyword">sigset_t</span> *<span class="keyword">restrict</span> oset)</span></span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回0：否则，返回错误编号</span></span><br></pre></td></tr></table></figure></p>
<p><code>pthread_sigmask</code>函数与<code>sigprocmask</code>函数基本相同，不过<code>pthread_sigmask</code>工作在线程中，而且失败时返回错误码，不再像<code>sigprocmask</code>中那样设置<code>errno</code>并返回-1，<code>set</code>参数包含线程用于修改信号屏蔽字的信号集。<code>how</code>参数可以取下列3个值之一：</p>
<ul>
<li><code>SIG_BLOCK</code>，把信号集添加到线程信号屏蔽字中，</li>
<li><code>SIG_SETMASK</code>，用信号集替换线程的信号屏蔽字，</li>
<li><code>SIG_UNBLOCK</code>，从线程信号屏蔽字中移除信号集。</li>
</ul>
<p>如果<code>oset</code>参数不为空，线程之前的信号屏蔽字就存储在它指向的<code>sigset_t</code>结构中。线程可以通过把<code>set</code>参数设置为NULL，并把<code>oset</code>参数设置为<code>sigset_t</code>结构的地址，来获取当前的信号屏蔽字。这种情况中的<code>how</code>参数会被忽略。</p>
<p>线程可以通过调用<code>sigwait</code>等待一个或多个信号的出现<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigwait</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">sigset_t</span> *<span class="keyword">restrict</span> <span class="built_in">set</span>, <span class="keyword">int</span> *<span class="keyword">restrict</span> signop)</span></span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回0；否则，返回错误编号</span></span><br></pre></td></tr></table></figure></p>
<p><code>set</code>参数指定了线程等待的信号集。返回时，<code>signop</code>指向的整数将包含发送信号的数量。如果信号集中的某个信号在<code>sigwait</code>调用的时候处于挂起状态，那么<code>sigwait</code>将无阻塞地返回。在返回之前，<code>sigwait</code>将从进程中移除那些处于挂起等待状态的信号。如果具体实现支持捧队信号，并且信号的多个实例被挂起，那么<code>sigwait</code>将会移除该信号的一个实例，其他的实例还要继续捧队。</p>
<p>为了避免错误行为发生，线程在调用<code>sigwait</code>之前，必须阻塞那些它正在等待的信号。<code>sigwait</code>函数会原子地取消信号集的阻塞状态，直到有新的信号被递送。在返回之前，<code>sigwait</code>将恢复线程的信号屏蔽字。如果信号在<code>sigwait</code>被调用的时候没有被阻塞，那么在线程完成对<code>sigwait</code>的调用之前会出现一个时间窗，在这个时间窗中，信号就可以被发送给线程。使用<code>sigwait</code>的好处在于它可以简化信号处理，允许把异步产生的信号用同步的方式处理。</p>
<p>为了防止信号中断线程，可以把信号加到每个线程的信号屏蔽字中。然后可以安排专用线程处理信号。这些专用线程可以进行函数调用，不需要担心在信号处理程序中调用哪些函数是安全的，因为这些函数调用来自正常的线程上下文，而非会中断线程正常执行的传统信号处理程序。如果多个线程在<code>sigwait</code>的调用中因等待同一个信号而阻塞，那么在信号递送的时候，就只有一个线程可以从<code>sigwait</code>中返回。如果一个信号被捕获，而且一个线程正在<code>sigwait</code>调用中等待同一信号，那么这时将由操作系统实现来决定以何种方式递送信号。操作系统实现可以让<code>sigwait</code>返回，也可以激活信号处理程序，但这两种情况不会同时发生。</p>
<p>要把信号发送给进程，可以调用<code>kill</code>。要把信号发送给线程，可以调用<code>pthread_kill</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_kill</span> <span class="params">(<span class="keyword">pthread_t</span> thread, <span class="keyword">int</span> signo)</span></span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回0；否则，返回错误编号</span></span><br></pre></td></tr></table></figure></p>
<p>可以传一个0值的<code>signo</code>来检查线程是否存在。如果信号的默认处理动作是终止该进程，那么把信号传递给某个线程仍然会杀死整个进程。</p>
<p>注意，闹钟定时器是进程资源，并且所有的线程共享相同的闹钟。所以，进程中的多个线程不可能互不干扰(或互不合作)地使用闹钟定时器。</p>
<h2 id="线程和fork"><a href="#线程和fork" class="headerlink" title="线程和fork"></a>线程和fork</h2><p>当线程调用<code>fork</code>时，就为子进程创建了整个进程地址空间的副本。子进程通过继承整个地址空间的副本，还从父进程那儿继承了每个互斥量、读写锁和条件变量的状态。如果父进程包含一个以上的线程，子进程在<code>fork</code>返回以后，如果紧接着不是马上调用<code>exec</code>的话，就需要清理锁状态。</p>
<p>在子进程内部，只存在一个线程，它是由父进程中调用<code>fork</code>的线程的副本构成的。如果父进程中的线程占有锁，子进程将同样占有这些锁。问题是子进程并不包含占有锁的线程的副本，所以子进程没有办法知道它占有了哪些锁、需要释放哪些锁。如果子进程从<code>fork</code>返回以后马上调用其中一个<code>exec</code>函数，就可以避免这样的问题。这种情况下，旧的地址空间就被丢弃，所以锁的状态无关紧要。但如果子进程需要继续做处理工作的话，这种策略就行不通，还需要使用其他的策略。</p>
<p>在多线程的进程中，为了避免不一致状态的问题，POSIX.1声明，在<code>fork</code>返回和子进程调用其中一个<code>exec</code>函数之间，子进程只能调用异步信号安全的函数。这就限制了在调用<code>exec</code>之前子进程能做什么，但不涉及子进程中锁状态的问题，要清除锁状态，可以通过调用<code>pthread_atfork</code>函数建立<code>fork</code>处理程序。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_atfork</span> <span class="params">(<span class="keyword">void</span> (*prepare) (<span class="keyword">void</span>), <span class="keyword">void</span> (*parent) (<span class="keyword">void</span>), <span class="keyword">void</span> (*child)(<span class="keyword">void</span>))</span></span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回0：否则，返回借误编号</span></span><br></pre></td></tr></table></figure></p>
<p>用<code>pthread_atfork</code>函数最多可以安装3个帮助清理锁的函数。<code>prepare</code> fork处理程序由父进程在<code>fork</code>创建子进程前调用。这个<code>fork</code>处理程序的任务是获取父进程定义的所有锁。<code>parent</code> fork处理程序是在<code>fork</code>创建子进程以后、返回之前在父进程上下文中调用的。这个<code>fork</code>处理程序的任务是对<code>prepare</code> fork处理程序获取的所有锁进行解锁。<code>child</code> fork处理程序在<code>fork</code>返回之前在子进程上下文中调用。与<code>parent</code> fork处理程序一样，<code>child</code> fork处理程序也必须释放<code>prepare</code> fork处理程序获取的所有锁。</p>
<p>注意，不会出现加锁一次解锁两次的情况，虽然看起来也许会出现。子进程地址空间在创建时就得到了父进程定义的所有锁的副本。因为<code>prepare</code> fork处理程序获取了所有的镜，父进程中的内存和子进程中的内存内容在开始的时候是相同的。当父进程和子进程对它们锁的副本进程解锁的时候，新的内存是分配给子进程的，父进程的内存内容是复制到子进程的内存中(写时复制)，所以看起来父进程对它所有的锁的副本进行了加锁，子进程对它所有的锁的副本进行了加锁。父进程和子进程对在不同内存单元的重复的锁都进行了解锁操作，就好像出现了下列事件序列。</p>
<ol>
<li>父进程获取所有的锁</li>
<li>子进程获取所有的锁</li>
<li>父进程释放它的锁</li>
<li>子进程释放它的锁</li>
</ol>
<p>可以多次调用<code>pthread_atfork</code>函数从而设置多套<code>fork</code>处理程序。如果不需要使用其中某个处理程序，可以给特定的处理程序参数传入空指针，它就不会起任何作用了。使用多个<code>fork</code>处理程序时，处理程序的调用顺序并不相同。<code>parent</code>和<code>child</code> fork处理程序是以它们注册时的顺序进行调用的，而<code>prepare</code> fork处理程序的调用顺序与它们注册时的顺序相反。这样可以允许多个模块注册它们自己的<code>fork</code>处理程序，而且可以保持锁的层次。</p>
<p>例如，假设模块A调用模块B中的函数，而且每个模块有自己的一套锁。如果锁的层次是A在B之前，模块B必须在模块A之前设置它的<code>fork</code>处理程序。当父进程调用<code>fork</code>时，就会执行以下的步骤，假设子进程在父进程之前运行：</p>
<ol>
<li>调用模块A的<code>prepare fork</code>处理程序获取模块A的所有锁。</li>
<li>调用模块B的<code>prepare fork</code>处理程序获取模块B的所有锁。</li>
<li>创建子进程</li>
<li>调用模块B中的<code>child fork</code>处理程序释放子进程中模块B的所有镜。</li>
<li>调用模块A中的<code>child fork</code>处理程序释放子进程中模块A的所有锁。</li>
<li>fork函数返回到子进程</li>
<li>调用模块B中的<code>parent fork</code>处理程序释放父进程中模块B的所有锁。</li>
<li>调用模块A中的<code>parent fork</code>处理程序来释放父进程中模块才的所有锁。</li>
<li><code>fork</code>函数返同到父进程</li>
</ol>
<figure class="highlight plain"><figcaption><span>"apue.h"</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line"></span><br><span class="line">pthread_mutex_t lock1 = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line">pthread_mutex_t lock2 = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line">void</span><br><span class="line">prepare(void)</span><br><span class="line">&#123;</span><br><span class="line">	int err;</span><br><span class="line"></span><br><span class="line">	printf(&quot;preparing locks...\n&quot;);</span><br><span class="line">	if ((err = pthread_mutex_lock(&amp;lock1)) != 0)</span><br><span class="line">		err_cont(err, &quot;can&apos;t lock lock1 in prepare handler&quot;);</span><br><span class="line">	if ((err = pthread_mutex_lock(&amp;lock2)) != 0)</span><br><span class="line">		err_cont(err, &quot;can&apos;t lock lock2 in prepare handler&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void</span><br><span class="line">parent(void)</span><br><span class="line">&#123;</span><br><span class="line">	int err;</span><br><span class="line"></span><br><span class="line">	printf(&quot;parent unlocking locks...\n&quot;);</span><br><span class="line">	if ((err = pthread_mutex_unlock(&amp;lock1)) != 0)</span><br><span class="line">		err_cont(err, &quot;can&apos;t unlock lock1 in parent handler&quot;);</span><br><span class="line">	if ((err = pthread_mutex_unlock(&amp;lock2)) != 0)</span><br><span class="line">		err_cont(err, &quot;can&apos;t unlock lock2 in parent handler&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void</span><br><span class="line">child(void)</span><br><span class="line">&#123;</span><br><span class="line">	int err;</span><br><span class="line"></span><br><span class="line">	printf(&quot;child unlocking locks...\n&quot;);</span><br><span class="line">	if ((err = pthread_mutex_unlock(&amp;lock1)) != 0)</span><br><span class="line">		err_cont(err, &quot;can&apos;t unlock lock1 in child handler&quot;);</span><br><span class="line">	if ((err = pthread_mutex_unlock(&amp;lock2)) != 0)</span><br><span class="line">		err_cont(err, &quot;can&apos;t unlock lock2 in child handler&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void *</span><br><span class="line">thr_fn(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">	printf(&quot;thread started...\n&quot;);</span><br><span class="line">	pause();</span><br><span class="line">	return(0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int</span><br><span class="line">main(void)</span><br><span class="line">&#123;</span><br><span class="line">	int			err;</span><br><span class="line">	pid_t		pid;</span><br><span class="line">	pthread_t	tid;</span><br><span class="line"></span><br><span class="line">	if ((err = pthread_atfork(prepare, parent, child)) != 0)</span><br><span class="line">		err_exit(err, &quot;can&apos;t install fork handlers&quot;);</span><br><span class="line">	if ((err = pthread_create(&amp;tid, NULL, thr_fn, 0)) != 0)</span><br><span class="line">		err_exit(err, &quot;can&apos;t create thread&quot;);</span><br><span class="line"></span><br><span class="line">	sleep(2);</span><br><span class="line">	printf(&quot;parent about to fork...\n&quot;);</span><br><span class="line"></span><br><span class="line">	if ((pid = fork()) &lt; 0)</span><br><span class="line">		err_quit(&quot;fork failed&quot;);</span><br><span class="line">	else if (pid == 0)	/* child */</span><br><span class="line">		printf(&quot;child returned from fork\n&quot;);</span><br><span class="line">	else		/* parent */</span><br><span class="line">		printf(&quot;parent returned from fork\n&quot;);</span><br><span class="line">	exit(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义了两个互斥量，<code>lock1</code>和<code>lock2</code>，<code>prepare fork</code>处理程序获取这两把锁，<code>child fork</code>处理程序在子进程上下文中释放它们，<code>parent fork</code>处理程序在父进程上下文中释放它们。运行该程序，得到如下输出：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out</span><br><span class="line">thread started.</span><br><span class="line">parent about to tork...</span><br><span class="line">preparing locks.</span><br><span class="line">child unlocking locks.</span><br><span class="line">child returned from fork</span><br><span class="line">parent unlocking locks.</span><br><span class="line">parent returned from fork</span><br></pre></td></tr></table></figure></p>
<p>可以看到，<code>prepare fork</code>处理程序在调用<code>fork</code>以后运行，<code>child fork</code>处理程序在<code>fork</code>调用返回到子进程之前运行，<code>parent fork</code>处理程序在<code>fork</code>调用返回给父进程之前运行。虽然<code>pthread_atfork</code>机制的意图是使<code>fork</code>之后的锁状态保持一致，但它还是存在一些不足之处，只能在有限情况下可用。</p>
<ul>
<li>没有很好的办法对较复杂的同步对象(如条件变量或者屏障)进行状态的重新初始化。</li>
<li>某些错误检查的互斥量实现在<code>child fork</code>处理程序试图对被父进程加锁的互斥量进行解锁时会产生错误。</li>
<li>递归互斥量不能在<code>child fork</code>处理程序中清理，因为没有办法确定该互斥量被加锁的次数。</li>
<li>如果子进程只允许调用异步信号安全的函数，<code>child fork</code>处理程序就不可能清理同步对象，因为用于操作清理的所有函数都不是异步信号安全的。实际的问题是同步对象在某个线程调用<code>fork</code>时可能处于中间状态，除非同步对象处于一致状态，否则无法被清理。</li>
<li>如果应用程序在信号处理程序中调用了fork(这是合法的，因为fork本身是异步信号安全的)，<code>pthread_atfork</code>注册的<code>fork</code>处理程序只能调用异步信号安全的函数，否则结果将是未定义的。</li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Linux/" rel="tag"># Linux</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/05/24/UNIX高级编程 笔记4/" rel="next" title="UNIX高级编程 笔记4">
                <i class="fa fa-chevron-left"></i> UNIX高级编程 笔记4
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/06/02/UNIX高级编程 笔记6/" rel="prev" title="UNIX高级编程 笔记6">
                UNIX高级编程 笔记6 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/header.jpg" alt="Hao Yu">
            
              <p class="site-author-name" itemprop="name">Hao Yu</p>
              <p class="site-description motion-element" itemprop="description">Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author</p>
          </div>
          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">302</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>
        	<audio controls="controls" loop="loop" preload="auto" src="/resource/xiaomeihao.mp3">
	        </audio>
	

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yuhao0102" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:yuh18@mails.tsinghua.edu.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#线程"><span class="nav-number">1.</span> <span class="nav-text">线程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#线程概念"><span class="nav-number">1.1.</span> <span class="nav-text">线程概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程标识"><span class="nav-number">1.2.</span> <span class="nav-text">线程标识</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程创建"><span class="nav-number">1.3.</span> <span class="nav-text">线程创建</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程终止"><span class="nav-number">1.4.</span> <span class="nav-text">线程终止</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程同步"><span class="nav-number">1.5.</span> <span class="nav-text">线程同步</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#互斥量"><span class="nav-number">1.5.1.</span> <span class="nav-text">互斥量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#避免死锁"><span class="nav-number">1.5.2.</span> <span class="nav-text">避免死锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数pthread-mutex-timedlock"><span class="nav-number">1.5.3.</span> <span class="nav-text">函数pthread_mutex_timedlock</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#读写锁"><span class="nav-number">1.5.4.</span> <span class="nav-text">读写锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#带有超时的读写锁"><span class="nav-number">1.5.5.</span> <span class="nav-text">带有超时的读写锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#条件变量"><span class="nav-number">1.5.6.</span> <span class="nav-text">条件变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自旋锁"><span class="nav-number">1.5.7.</span> <span class="nav-text">自旋锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#屏障"><span class="nav-number">1.5.8.</span> <span class="nav-text">屏障</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#线程控制"><span class="nav-number">2.</span> <span class="nav-text">线程控制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#线程限制"><span class="nav-number">2.1.</span> <span class="nav-text">线程限制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程属性"><span class="nav-number">2.2.</span> <span class="nav-text">线程属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#同步属性"><span class="nav-number">2.3.</span> <span class="nav-text">同步属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#互斥量属性"><span class="nav-number">2.4.</span> <span class="nav-text">互斥量属性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#读写锁属性"><span class="nav-number">2.4.1.</span> <span class="nav-text">读写锁属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#条件变量属性"><span class="nav-number">2.4.2.</span> <span class="nav-text">条件变量属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#屏障属性"><span class="nav-number">2.4.3.</span> <span class="nav-text">屏障属性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#重入"><span class="nav-number">2.5.</span> <span class="nav-text">重入</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程特定数据"><span class="nav-number">2.6.</span> <span class="nav-text">线程特定数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#取消选项"><span class="nav-number">2.7.</span> <span class="nav-text">取消选项</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程和信号"><span class="nav-number">2.8.</span> <span class="nav-text">线程和信号</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程和fork"><span class="nav-number">2.9.</span> <span class="nav-text">线程和fork</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>
  <div id="DvelopmentTarget">     
  </div>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart" aria-hidden="false"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>

  
</div>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_uv"> 
  本站访客数<span id="busuanzi_value_site_uv"></span>人次
</span>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  


  <script type="text/javascript" src="/js/src/love.js"></script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
