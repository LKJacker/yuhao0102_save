<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zn-ch">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-center-simple.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="C++,">










<meta name="description" content="精通类与对象友元C++运行某个类将其他类、其他类的成员函数或非成员函数声明为友元，友元可访问类的protected、private数据成员和方法。可将Bar类或或其中的一个方法、独立函数设置为Foo类的友元；12345class Foo &amp;#123;    friend void Bar::processFoo(const Foo&amp;amp; foo);    friend class Bar;">
<meta name="keywords" content="C++">
<meta property="og:type" content="article">
<meta property="og:title" content="C++高级编程 第四版 笔记2">
<meta property="og:url" content="http://yoursite.com/2021/05/02/cpp高级编程 笔记2/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="精通类与对象友元C++运行某个类将其他类、其他类的成员函数或非成员函数声明为友元，友元可访问类的protected、private数据成员和方法。可将Bar类或或其中的一个方法、独立函数设置为Foo类的友元；12345class Foo &amp;#123;    friend void Bar::processFoo(const Foo&amp;amp; foo);    friend class Bar;">
<meta property="og:locale" content="zn-ch">
<meta property="og:image" content="http://yoursite.com/img/1619270636.jpg">
<meta property="og:updated_time" content="2021-05-02T14:07:40.705Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="C++高级编程 第四版 笔记2">
<meta name="twitter:description" content="精通类与对象友元C++运行某个类将其他类、其他类的成员函数或非成员函数声明为友元，友元可访问类的protected、private数据成员和方法。可将Bar类或或其中的一个方法、独立函数设置为Foo类的友元；12345class Foo &amp;#123;    friend void Bar::processFoo(const Foo&amp;amp; foo);    friend class Bar;">
<meta name="twitter:image" content="http://yoursite.com/img/1619270636.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2021/05/02/cpp高级编程 笔记2/">





  <title>C++高级编程 第四版 笔记2 | Hao Yu's blog</title>
  








 
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zn-ch">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hao Yu's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">The program monkey was eaten by the siege lion.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-mybetterhalf">
          <a href="/mybetterhalf/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>
            
            mybetterhalf
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/05/02/cpp高级编程 笔记2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">C++高级编程 第四版 笔记2</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-05-02T22:07:40+08:00">
                2021-05-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="精通类与对象"><a href="#精通类与对象" class="headerlink" title="精通类与对象"></a>精通类与对象</h1><h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><p>C++运行某个类将其他类、其他类的成员函数或非成员函数声明为友元，友元可访问类的protected、private数据成员和方法。可将Bar类或或其中的一个方法、独立函数设置为Foo类的友元；<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">void</span> Bar::processFoo(<span class="keyword">const</span> Foo&amp; foo);</span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Bar</span>;</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">dumpFoo</span><span class="params">(<span class="keyword">const</span> Foo&amp; foo)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="对象的动态分配"><a href="#对象的动态分配" class="headerlink" title="对象的动态分配"></a>对象的动态分配</h2><h3 id="使用移动语义处理移动"><a href="#使用移动语义处理移动" class="headerlink" title="使用移动语义处理移动"></a>使用移动语义处理移动</h3><p>对象的移动语义(movesemantics)需要实现移动构造函数(move constructor)和移动赋值运算符(move assignment operator)。如果源对象是操作结束后被销毁的临时对象，编译器就会使用这两个方法。移动构造函数和移动赋值运算符将数据成员从源对象移动到新对象，然后使源对象处于有效但不确定的状态。通常会将源代码的数据成员重置为空值。这样做实际上将内存和其他资源的所有权从一个对象移动到另一个对象。这两个方法基本上只对成员变量进行表层复制(shallow copy)，然后转换已分配内存和其他资源的所有权，从而阻止悬挂指针和内存泄漏。</p>
<p>在实现移动语义前，你需要学习右值(rvalue)和右值引用(rvalue reference)。</p>
<h4 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h4><p>在C++中，左值(value)是可获取其地址的一个量，例如一个有名称的变量。由于经常出现在赋值语句的左边，因此将其称作左值。另外，所有不是左值的量都是右值(rvalue)，例如字面量、临时对象或临时值。通常右值位于赋值运算符的右边。例如，考虑下面的语句:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">4</span>*<span class="number">2</span>;</span><br></pre></td></tr></table></figure></p>
<p>在这条语句中，a是左值，它具有名称，它的地址为&amp;a。右侧表达式<code>4 * 2</code>的结果是右值。它是一个临时值，将在语句执行完毕时销毁。在本例中，将这个临时副本存储在变量a中。右值引用是一个对右值(rvalue)的引用。特别地，这是一个当右值是临时对象时才适用的概念。右值引用的目的是在涉及临时对象时提供可选用的特定函数。由于知道临时对象会被销毁，通过右值引用，某些涉及复制大量值的操作可通过简单地复制指向这些值的指针来实现。</p>
<p>函数可将<code>&amp;&amp;</code>作为参数说明的一部分(例如<code>type &amp;&amp;name</code>)，以指定右值引用参数。通常，临时对象被当作<code>const type&amp;</code>，但当函数重载使用了右值引用时，可以解析临时对象，用于该函数重载。下面的示例说明了这一点。代码首先定义了两个<code>handleMessage()</code>函数，一个接收左值引用，另一个接收右值引用:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lvalue reference parameter</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>&amp; message)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"handleMessage with lvalue reference: "</span> &lt;&lt; message &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// rvalue reference parameter</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handleMessage</span> <span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>&amp;&amp; message)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"handleMessage with rvalue reference: "</span> &lt;&lt; message &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可使用具有名称的变量作为参数调用<code>handleMessage()</code>函数:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> a = <span class="string">"Hello "</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> b = <span class="string">"World"</span>;</span><br><span class="line">handleMessage(a);</span><br><span class="line"><span class="comment">// Calls handleMessage (string&amp; value)</span></span><br></pre></td></tr></table></figure></p>
<p>由于a是一个命名变量，调用<code>handleMessage()</code>函数时，该函数接收一个左值引用。<code>handleMessage()</code>函数通过其引用参数所执行的任何更改来更改a的值。还可用表达式作为参数来调用<code>handleMessage()</code>函数:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">handleMessage(a + b);</span><br><span class="line"><span class="comment">// Calls handleMessage (string&amp;&amp; value)</span></span><br></pre></td></tr></table></figure></p>
<p>此时无法使用接收左值引用作为参数的<code>handleMessage()</code>函数，因为表达式a+b的结果是临时的，这不是一个左值。在此情况下，会调用右值引用版本。由于参数是一个临时值，<code>handleMessage()</code>函数调用结束后，会丢失通过引用参数所做的任何更改。</p>
<p>字面量也可作为<code>handleMessage()</code>调用的参数，此时同样会调用右值引用版本，因为字面量不能作为左值(但字面量可作为const引用形参的对应实参传递)。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">handleMessage(<span class="string">"Hello World"</span>); <span class="comment">// Calls handldMessage (string&amp;&amp; value)</span></span><br></pre></td></tr></table></figure></p>
<p>如果删除接收左值引用的<code>handleMessage()</code>函数，使用有名称的变量调用<code>handleMessage()</code>，会导致编译错误，因为右值引用参数(<code>string&amp;&amp; message</code>)永远不会与左值(b)绑定。如下所示，可使用<code>std:move()</code>将左值转换为右值，强迫编译器调用<code>handleMessage()</code>函数的右值引用版本:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">handleMessage (<span class="built_in">std</span>::move(b)); <span class="comment">// Calls handleMessage (string&amp;&amp; value)</span></span><br></pre></td></tr></table></figure></p>
<p>重申一次，有名称的变量是左值。因此，在<code>handleMessage()</code>函数中，右值引用参数message本身是一个左值，原因是它具有名称!如果希望将这个左值引用参数，作为右值传递给另一个函数，则需要使用<code>std:move()</code>，将左值转换为右值。例如，假设要添加以下函数，使用右值引用参数:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">helper</span> <span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>&amp;&amp; message)</span></span></span><br></pre></td></tr></table></figure></p>
<p>如果按如下方式调用，则无法编译:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handleMessage</span> <span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>&amp;&amp; message)</span> </span>&#123;</span><br><span class="line">    helper (message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>helper()</code>函数需要右值引用，而<code>handleMessage()</code>函数传递<code>message</code>，<code>message</code>具有名称，因此是左值，导致编译错误。正确的方式是使用<code>std:move()</code>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handleMessage</span> <span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>&amp;&amp; message)</span> </span>&#123;</span><br><span class="line">    helper (<span class="built_in">std</span>::move(message));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>有名称的右值引用，如右值引用参数，本身就是左值，因为它具有名称!</p>
</blockquote>
<p>右值引用并不局限于函数的参数。可以声明右值引用类型的变量，并对其赋值，尽管这一用法并不常见。</p>
<p>考虑下面的代码，在C++中这是不合法的:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>&amp; i = <span class="number">2</span>;<span class="comment">// Invalid: reference to a constant</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>, b = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span>&amp; j = a + b; <span class="comment">// Invalid: reference to a temporary</span></span><br></pre></td></tr></table></figure></p>
<p>使用右值引用后，下面的代码完全合法:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>&amp;&amp; i = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>, b = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span>&amp;&amp; j = a + b;</span><br></pre></td></tr></table></figure></p>
<p>前面示例中单独使用右值引用的情况很少见。</p>
<h4 id="实现移动语义"><a href="#实现移动语义" class="headerlink" title="实现移动语义"></a>实现移动语义</h4><p>移动语义是通过右值引用实现的。为了对类增加移动语义，需要实现移动构造函数和移动赋值运算符。移动构造函数和移动赋值运算符应使用<code>noexcept</code>限定符标记，这告诉编译器，它们不会抛出任何异常。这对于与标准库兼容非常重要，因为如果实现了移动语义，与标准库的完全兼容只会移动存储的对象，且确保不抛出异常。</p>
<p>下面的Spreadsheet类定义包含一个移动构造函数和一个移动赋值运算符。也引入了两个辅助方法<code>cleanup()</code>和<code>moveFrom()</code>。前者在析构函数和移动赋值运算符中调用。后者用于把成员变量从源对象移动到目标对象，接着重置源对象。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Spreadsheet</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Spreadsheet(Spreadsheet&amp;&amp; src) <span class="keyword">noexcept</span>; <span class="comment">// Move constructor</span></span><br><span class="line">    Spreadsheet&amp; <span class="keyword">operator</span>= (Spreadsheet&amp;&amp; rhs) <span class="keyword">noexcept</span>; <span class="comment">// Move assign</span></span><br><span class="line"><span class="comment">// Remaining code omitted for brevity</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cleanup</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">moveFrom</span> <span class="params">(Spreadsheet&amp; src)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">    <span class="comment">// Remaining code omitted for brevity</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>实现代码如下所示:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Spreadsheet::cleanup() <span class="keyword">noexcept</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">0</span>; i &lt; mWidth; i ++)</span><br><span class="line">        <span class="keyword">delete</span>[] mCells[i];</span><br><span class="line">    <span class="keyword">delete</span>[] mCells;</span><br><span class="line">    mCells = <span class="literal">nullptr</span>;</span><br><span class="line">    mWidth = <span class="number">0</span>;</span><br><span class="line">    mHeight = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Spreadsheet::moveFrom (Spreadsheet&amp; src) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">    <span class="comment">// Shallow copy of data</span></span><br><span class="line">    mWidth = src.mWidth; .</span><br><span class="line">    mHeight = src.mHeight;</span><br><span class="line">    mCells = src.mCells;</span><br><span class="line">    <span class="comment">// Reset the source object, because ownership has been moved ! </span></span><br><span class="line">    src.mWidth = <span class="number">0</span>;</span><br><span class="line">    src.mHeight = <span class="number">0</span>;</span><br><span class="line">    src.mCells = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Move constructor</span></span><br><span class="line">Spreadsheet::Spreadsheet (Spreadsheet&amp;&amp; src) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">    moveFrom(src);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Move assignment operator</span></span><br><span class="line">Spreadsheet&amp; Spreadsheet::<span class="keyword">operator</span>= (Spreadsheet&amp;&amp; rhs) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">    <span class="comment">// check for self-assignment</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> = &amp;rhs)</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// free the old memory</span></span><br><span class="line">    cleanup() ;</span><br><span class="line">    moveFrom(rhs);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>移动构造函数和移动赋值运算符都将mCells的内存所有权从源对象移动到新对象，这两个方法将源对象的mCells指针设置为空指针，以防源对象的析构函数释放这块内存，因为新的对象现在拥有了这块内存。很明显，只有你知道将销毁源对象时，移动语义才有用。例如，就像普通的构造函数或复制赋值运算符一样，可显式将移动构造函数和/或移动赋值运算符设置为默认或将其删除。</p>
<p>仅当类没有用户声明的复制构造函数、复制赋值运算符、移动赋值运算符或析构函数时，编译器才会为类自动生成默认的移动构造函数。仅当类没有用户声明的复制构造函数、移动构造函数、复制赋值运算符或析构函数时，才会为类生成默认的移动赋值运算符。</p>
<h4 id="移动对象数据成员"><a href="#移动对象数据成员" class="headerlink" title="移动对象数据成员"></a>移动对象数据成员</h4><p><code>moveFrom()</code>方法对三个数据成员直接赋值，因为这些成员都是基本类型。如果对象还将其他对象作为数据成员，则应当使用<code>std:move()</code>移动这些对象。假设Spreadsheet类有一个名为mName的<code>std::string</code>数据成员。接着采用以下方式实现<code>moveFrom()</code>方法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Spreadsheet::moveFrom (Spreadsheet&amp; src) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">    <span class="comment">// Move object data members</span></span><br><span class="line">    mName = <span class="built_in">std</span>::move(src.mName) ;</span><br><span class="line">    <span class="comment">// Move primitives :</span></span><br><span class="line">    <span class="comment">// Shallow copy of data</span></span><br><span class="line">    mwidth = src.mWidth;</span><br><span class="line">    mHeight = src.mHeight;</span><br><span class="line">    mCells = src.mCells;</span><br><span class="line">    <span class="comment">// Reset the source object, because ownership has been moved!</span></span><br><span class="line">    src.mWidth = <span class="number">0</span>;</span><br><span class="line">    src.mHeight = <span class="number">0</span></span><br><span class="line">    src.mCells = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>前面的移动构造函数和移动赋值运算符的实现都使用了<code>moveFrom()</code>辅助方法，该辅助方法通过执行浅表复制来移动所有数据成员。</p>
<h3 id="零规则"><a href="#零规则" class="headerlink" title="零规则"></a>零规则</h3><p>前面的讨论解释如何编写以下5个特殊的成员函数:析构函数、复制构造函数、移动构造函数、复制赋值运算符和移动赋值运算符。但在现代C++中，你需要接受零规则(rule of zero)。</p>
<p>“零规则”指出，在设计类时，应当使其不需要上述5个特殊成员函数。如何做到这一点？基本上，应当避免拥有任何旧式的、动态分配的内存。而改用现代结构，如标准库容器。例如，在Spreadsheet 类中，用<code>vector&lt;vector&lt;SpreadsheetCell&gt;&gt;</code>替代<code>SpreadsheetCell**</code>数据成员。该vector自动处理内存，因此不需要上述5个特殊成员函数。</p>
<h2 id="与方法有关的更多内容"><a href="#与方法有关的更多内容" class="headerlink" title="与方法有关的更多内容"></a>与方法有关的更多内容</h2><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>与数据成员类似，方法有时会应用于全部类对象而不是单个对象，此时可以像静态数据成员那样编写静态方法。以第8章的SpreadsheetCell类为例，这个类有两个辅助方法：<code>stringToDouble()</code>和<code>doubleToString()</code>。这两个方法没有访问特定对象的信息，因此可以是静态的。下面的类定义将这些方法设置为静态的:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpreadsheetCell</span> &#123;</span></span><br><span class="line"><span class="comment">// Omitted for brevity</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">doubleToString</span> <span class="params">(<span class="keyword">double</span> inValue)</span> </span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">stringToDouble</span><span class="params">(<span class="built_in">std</span>::string_view inString)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这两个方法的实现与前面的实现相同，在方法定义前不需要重复static关键字。然而，注意静态方法不属于特定对象，因此<strong>没有this指针</strong>，当用某个特定对象调用静态方法时，静态方法不会访问这个对象的非静态数据成员。实际上，静态方法就像普通函数，唯一区别在于静态方法可以访问类的private和protected静态数据成员。如果同一类型的其他对象对于静态方法可见，那么静态方法也可访问其他对象的private和protected非静态数据成员。</p>
<p>类中的任何方法都可像调用普通函数那样调用静态方法，因此SpreadsheetCell类中所有方法的实现都没有改变。如果要在类的外面调用静态方法，需要用类名和作用域解析运算符来限定方法的名称(就像静态数据成员那样)，静态方法的访问控制与普通方法一样。</p>
<p>将<code>stringToDouble()</code>和<code>doubleTostring()</code>设置为public，这样类外面的代码也可以使用它们。此时，可在任意位置这样调用这两个方法:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str = SpreadsheetCell::doubleToString(<span class="number">5.0</span>);</span><br></pre></td></tr></table></figure></p>
<h3 id="const-方法"><a href="#const-方法" class="headerlink" title="const 方法"></a>const 方法</h3><p>const(常量)对象的值不能改变。如果使用常量对象、常量对象的引用和指向常量对象的指针，编译器将不允许调用对象的任何方法，除非这些方法承诺不改变任何数据成员。为了保证方法不改变数据成员，可以用const关键字标记方法本身。下面的SpreadsheetCell类包含了用const标记的不改变任何数据成员的方法。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpreadsheetCell</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Omitted for brevity</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getValue</span><span class="params">()</span> <span class="keyword">const</span> </span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">getstring</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="comment">// Omitted for brevity</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>const规范是方法原型的一部分，必须放在方法的定义中:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> SpreadsheetCell::getValue() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> mValue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> SpreadsheetCell::getString() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> doubleToString (mValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>将方法标记为const，就是与客户代码立下了契约，承诺不会在方法内改变对象内部的值。如果将实际上修改了数据成员的方法声明为const，编译器将会报错。不能将静态方法声明为const，因为这是多余的。静态方法没有类的实例，因此不可能改变内部的值。</p>
<p>const 的工作原理是将方法内用到的数据成员都标记为const引用，因此如果试图修改数据成员，编译器会报错。非const对象可调用const方法和非const方法。然而，const 对象只能调用const方法，下面是一些示例:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SpreadsheetCell <span class="title">myCell</span> <span class="params">(<span class="number">5</span>)</span> </span>;</span><br><span class="line"><span class="built_in">cout</span>. &lt;&lt; myCell.getValue() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">// OK</span></span><br><span class="line">myCell.setString(<span class="string">"6"</span>);</span><br><span class="line"><span class="comment">// OK</span></span><br><span class="line"><span class="keyword">const</span> SpreadsheetCell&amp; myCellConstRef = myCell;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; myCellConstRef.getValue() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// OK</span></span><br><span class="line">myCellConstRef.setString(<span class="string">"6"</span>);</span><br><span class="line"><span class="comment">// Compilation Error!</span></span><br></pre></td></tr></table></figure></p>
<p>应该养成习惯，将不修改对象的所有方法声明为const，这样就可在程序中引用const对象。注意const对象也会被销毁，它们的析构函数也会被调用，因此不应该将析构函数标记为const。</p>
<h4 id="mutable数据成员"><a href="#mutable数据成员" class="headerlink" title="mutable数据成员"></a>mutable数据成员</h4><p>有时编写的方法“逻辑上”是const方法，但是碰巧改变了对象的数据成员。这个改动对于用户可见的数据没有任何影响，但在技术上确实做了改动，因此编译器不允许将这个方法声明为const。解决方法是将变量设置为mutable，告诉编译器在const方法中允许改变这个值。</p>
<h3 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h3><p>注意，在类中可编写多个构造函数，所有这些构造函数的名称都相同。这些构造函数只是参数数量或类型不同。在C++中，可对任何方法或函数做同样的事情。具体来讲，可重载函数或方法，具体做法是将函数或方法的名称用于多个函数，但是参数的类型或数目不同。例如在SpreadsheetCell类中，可将<code>setString()</code>和<code>setValue()</code>全部重命名为<code>set()</code>。类定义如下所示:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpreadsheetCell</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Omitted for brevity</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">double</span> inValue)</span> </span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="built_in">std</span>::string_view inString)</span> </span>;</span><br><span class="line">    <span class="comment">// Omitted for brevity</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>set()</code>方法的实现保持不变。当编写调用<code>set()</code>方法的代码时，编译器根据传递的参数判断调用哪个实例，这称为重载解析。</p>
<h4 id="基于const的重载"><a href="#基于const的重载" class="headerlink" title="基于const的重载"></a>基于const的重载</h4><p>还要注意，可根据const来重载方法。也就是说，可以编写两个名称相同、参数也相同的方法，其中一个是const，另一个不是。如果是const对象，就调用const方法；如果是非const对象，就调用非const方法。</p>
<p>通常情况下，const版本和非const版本的实现是一样的。为避免代码重复，可使用<code>const_cast()</code>模式。你可像往常一样实现const版本，此后通过适当转换，传递对const版本的调用，以实现非const版本。基本上，你使用<code>std:as_const()</code>(在<code>&lt;utility&gt;</code>中定义)将<code>*this</code>转换为<code>const Spreadsheet&amp;</code>，调用<code>getCellAt()</code>的const版本，然后使用<code>const_cast()</code>，从结果中删除const：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> SpreadsheetCell&amp; Spreadsheet::getCellAt(<span class="keyword">size_t</span> x，<span class="keyword">size_t</span> y) <span class="keyword">const</span> &#123;</span><br><span class="line">    verifyCoordinate(x，y);</span><br><span class="line">    <span class="keyword">return</span> mCel1s[x][y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SpreadsheetCell&amp; Spreadsheet::getCe1lAt(<span class="keyword">size_t</span> x, <span class="keyword">size_t</span> y) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">const_cast</span>&lt;SpreadsheetCell&amp;&gt; (<span class="built_in">std</span>::as_const(*<span class="keyword">this</span>).getCellAt(x, y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>自C++17起，<code>st::as_const()</code>函数可供使用。如果你的编译器还不支持该函数，可改用以下<code>static_cast()</code>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">const_cast</span>&lt;SpreadsheetCell&amp;&gt; ( <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> Spreadsheet&amp;&gt;(*<span class="keyword">this</span>).getCellAt(x, y));</span><br></pre></td></tr></table></figure></p>
<p>有了这两个重载的<code>getCellAt()</code>，现在可在const和非const的Spreadsheet对象上调用<code>getCellAt()</code>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Spreadsheet sheet1 (5，6).</span><br><span class="line">SpreadsheetCell&amp; cel11 = sheet1.getCel1At(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> Spreadsheet <span class="title">sheet2</span><span class="params">(<span class="number">5</span>， <span class="number">6</span>)</span></span>;</span><br><span class="line"><span class="keyword">const</span> SpreadsheetCell&amp; cell2 = sheet2.getCellAt(<span class="number">1</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure></p>
<p>这里，<code>getCellAt()</code>的const版本做的事情不多，因此使用<code>const_cast()</code>模式的优势不明显。</p>
<h4 id="显式删除重载"><a href="#显式删除重载" class="headerlink" title="显式删除重载"></a>显式删除重载</h4><p>重载方法可被显式删除，可以用这种方法禁止调用具有特定参数的成员函数。例如，考虑下面的类:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>可以用下面的方式调用<code>foo()</code>方法:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyClass c;</span><br><span class="line">c.foo(<span class="number">123</span>);</span><br><span class="line">c.foo(<span class="number">1.23</span>);</span><br></pre></td></tr></table></figure></p>
<p>在第三行，编译器将double值(1.23)转换为整型值(1)，然后调用foo(int i)。 编译器可能会给出警告，但是仍然会执行这一隐式转换。显式删除<code>foo()</code>的double实例，可以禁止编译器执行这一转换:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">double</span> d)</span> </span>= <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>通过这一改动， 以double为参数调用foo()时，编译器会给出错误提示，而不是将其转换为整数。</p>
<h3 id="内联方法"><a href="#内联方法" class="headerlink" title="内联方法"></a>内联方法</h3><p>编译器可以将方法体或函数体直接插入到调用方法或函数的位置。这个过程称为内联(inline)。内联比使用#define安全。inline 关键字只是提示编译器。如果编译器认为这会降低性能，就会忽略该关键字。</p>
<p>如果编写了内联函数或内联方法，应该将定义与原型一起放在头文件中。</p>
<p>高级C++编译器不要求把内联方法的定义放在头文件中。例如，Microsoft Visual C++支持连接时代码生成(LTCG)，会自动将较小的函数内联，哪怕这些函数没有声明为内联的或者没有在头文件中定义，也同样如此。</p>
<p>C++提供了另一种声明内联方法的语法，这种语法根本不使用inline关键字，而是直接将方法定义放在类定义中。下面是使用了这种语法的SpreadsheetCell类定义:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpreadsheetCell</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getValue</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; mNumAccesses++; <span class="keyword">return</span> mValue; &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">getString</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        mNumAccesses++;</span><br><span class="line">        <span class="keyword">return</span> doubleToString (mValue) ;</span><br><span class="line">        <span class="comment">// Omitted for brevity </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>编译器只会内联最简单的方法和函数，如果将编译器不想内联的方法定义为内联方法，编译器会自动忽略这个指令。现代编译器在内联方法或函数之前，会考虑代码膨胀等指标，因此不会内联任何没有效益的方法。</p>
<h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><p>C++中，默认参数(default arguments)与方法重载类似。在原型中可为函数或方法的参数指定默认值。如果用户指定了这些参数，默认值会被忽略；如果用户忽略了这些参数，将会使用默认值。但是存在一个限制：<strong>能从最右边的参数开始提供连续的默认参数列表，否则编译器将无法用默认参数匹配缺失的参数</strong>。默认参数可用于函数、方法和构造函数。例如，可在Spreadsheet构造函数中设置宽度和高度的默认值:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Spreadsheet</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Spreadsheet(<span class="keyword">size_t</span> width = <span class="number">100</span>，<span class="keyword">size_t</span> height = <span class="number">100</span>);</span><br><span class="line">    <span class="comment">// Omitted for brevity</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>现在可以用0个、1个或2个参数调用Spreadsheet构造函数，尽管只有一个非复制构造函数:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Spreadsheet s1;</span><br><span class="line"><span class="function">Spreadsheet <span class="title">s2</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="function">Spreadsheet <span class="title">s3</span><span class="params">(<span class="number">5</span>, <span class="number">6</span>)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>所有参数都有默认值的构造函数等同于默认构造函数。也就是说，可构建类的对象而不指定任何参数。如果试图同时声明默认构造函数，以及具有多个参数并且所有参数都有默认值的构造函数，编译器会报错。因为如果不指定任何参数，编译器不知道该调用哪个构造函数。</p>
<h2 id="不同的数据成员类型"><a href="#不同的数据成员类型" class="headerlink" title="不同的数据成员类型"></a>不同的数据成员类型</h2><p>C++为数据成员提供了多种选择。除了在类中简单地声明数据成员外，还可创建静态数据成员(类的所有对象共享)、静态常量数据成员、引用数据成员、常量引用数据成员和其他成员。</p>
<h3 id="静态数据成员"><a href="#静态数据成员" class="headerlink" title="静态数据成员"></a>静态数据成员</h3><p>静态数据成员属于类但不是对象的数据成员，可将静态数据成员当作类的全局变量。下面是Spreadsheet类的定义，其中包含了新的静态数据成员sCounter:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Spreadsheet</span> &#123;</span></span><br><span class="line"><span class="comment">// Omitted for brevity </span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">size_t</span> sCounter;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>不仅要在类定义中列出static类成员，还需要在源文件中为其分配内存，通常是定义类方法的那个源文件。在此还可初始化静态成员，但注意与普通的变量和数据成员不同，默认情况下它们会初始化为0。static 指针会初始化为nullptr。</p>
<h4 id="内联变量"><a href="#内联变量" class="headerlink" title="内联变量"></a>内联变量</h4><p>从C++17开始，可将静态数据成员声明为inline。这样做的好处是不必在源文件中为它们分配空间。下面是一个实例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Spreadsheet</span> &#123;</span></span><br><span class="line">    <span class="comment">// Omitted for brevity</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">size_t</span> sCounter = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>注意其中的inline关键字。有了这个类定义，可从源文件中删除下面的代码行:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> Spreadsheet::sCounter;</span><br></pre></td></tr></table></figure></p>
<h4 id="在类方法内访问静态数据成员"><a href="#在类方法内访问静态数据成员" class="headerlink" title="在类方法内访问静态数据成员"></a>在类方法内访问静态数据成员</h4><p>在类方法内部，可以像使用普通数据成员那样使用静态数据成员。例如，为Spreadsheet类创建一个<code>mId</code>成员，并在Spreadsheet构造函数中用sCounter成员初始化它。下面是包含了mId成员的Spreadsheet 类定义:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Spreadsheet</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">size_t</span> getId() <span class="keyword">const</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">size_t</span> sCounter;</span><br><span class="line">    <span class="keyword">size_t</span> mId = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>下面是Spreadsheet构造函数的实现，在此赋予初始ID:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Spreadsheet::Spreadsheet (<span class="keyword">size_t</span> width, <span class="keyword">size_t</span> height) </span><br><span class="line">    : mId (sCounter++), mwidth (width), mHeight (height) &#123;</span><br><span class="line">    mCells = <span class="keyword">new</span> SpreadsheetCell* [mWidth] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mwidth; i++) &#123;</span><br><span class="line">        mCells[i] = <span class="keyword">new</span> SpreadsheetCell [mHeight] ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看出，构造函数可访问sCounter，就像这是一个普通成员。在复制构造函数中，也要指定新的ID。由于Spreadsheet复制构造函数委托给非复制构造函数(会自动创建新的ID)，因此这可以自动进行处理。在赋值运算符中不应该复制ID。一旦给某个对象指定ID,就不应该再改变。建议把mId设置为const数据成员。</p>
<h4 id="在方法外访问静态数据成员"><a href="#在方法外访问静态数据成员" class="headerlink" title="在方法外访问静态数据成员"></a>在方法外访问静态数据成员</h4><p>访问控制限定符适用于静态数据成员：sCounter 是私有的，因此不能在类方法之外访问。如果sCounter是公有的，就可在类方法外访问，具体方法是用::作用域解析运算符指出这个变量是Spreadsheet类的一部分:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> c = Spreadsheet::sCounter;</span><br></pre></td></tr></table></figure></p>
<h3 id="静态常量数据成员"><a href="#静态常量数据成员" class="headerlink" title="静态常量数据成员"></a>静态常量数据成员</h3><p>类中的数据成员可声明为const，意味着在创建并初始化后，数据成员的值不能再改变。如果某个常量只适用于类，应该使用静态常量(static const或const static)数据成员，而不是全局常量。可在类定义中定义和初始化整型和枚举类型的静态常量数据成员，而不需要将其指定为内联变量。Spreadsheet类的static const成员:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Spreadsheet</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">size_t</span> kMaxHeight = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">size_t</span> kMaxWidth = <span class="number">100</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>非静态数据成员也可声明为const。例如，mId数据成员就可声明为const。因为不能给const数据成员赋值，所以需要在类内初始化器或ctor initializer中初始化它们。这意味着根据使用情形，可能无法为具有非静态常量数据成员的类提供赋值运算符。如果属于这种情况，通常将赋值运算符标记为deleted。</p>
<p>kMaxHeight和kMaxWidth是公有的，因此可在程序的任何位置访问它们，就像它们是全局变量一样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Maximum height is: "</span> &lt;&lt; Spreadsheet::kMaxHeight &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="引用数据成员"><a href="#引用数据成员" class="headerlink" title="引用数据成员"></a>引用数据成员</h3><p>Spreadsheets和SpreadsheetCells可一起放入SpreadsheetApplication类。Spreadsheet类必须知道SpreadsheetApplication 类，SpreadsheetApplication类也必须知道Spreadsheet类。这是一个循环引用问题，无法用普通的#include解决。解决方案是在其中一个头文件中使用前置声明。下面是新的使用了前置声明的Spreadsheet类定义，用来通知编译器关于SpreadsheetApplication类的信息。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpreadsheetApplication</span>;</span> <span class="comment">// forward declaration</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Spreadsheet</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Spreadsheet(<span class="keyword">size_t</span> width, <span class="keyword">size_t</span> height, SpreadsheetApplication&amp; theApp);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    SpreadsheetApplicatoin&amp; mTheApp;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这个定义将一个SpreadsheetApplication引用作为数据成员添加进来。在此情况下建议使用引用而不是指针，因为Spreadsheet总要引用一个 SpreadsheetApplication，而指针则无法保证这一点。</p>
<h3 id="常量引用数据成员"><a href="#常量引用数据成员" class="headerlink" title="常量引用数据成员"></a>常量引用数据成员</h3><p>就像普通引用可引用常量对象一样，引用成员也可引用常量对象。例如，为让Spreadsheet只包含应用程序对象的常量引用，只需要在类定义中将mTheApp声明为常量引用:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Spreadsheet</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Spreadsheet(<span class="keyword">size_t</span> width, <span class="keyword">size_t</span> height, <span class="keyword">const</span> SpreadsheetApplication&amp; theApp);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> SpreadsheetApplication&amp; mTheApp;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>常量引用和非常量引用之间存在一个重要差别。常量引用SpreadsheetApplication 数据成员只能用于调用SpreadsheetApplication 对象上的常量方法。如果试图通过常量引用调用非常量方法，编译器会报错。还可创建静态引用成员或静态常量引用成员，但一般不需要这么做。</p>
<h2 id="嵌套类"><a href="#嵌套类" class="headerlink" title="嵌套类"></a>嵌套类</h2><p>类定义不仅可包含成员函数和数据成员，还可编写嵌套类和嵌套结构、声明typedef或者创建枚举类型。类中声明的一切内容都具有类作用域。如果声明的内容是公有的，那么可在类外使用<code>ClassName::</code>作用域解析语法访问。</p>
<p>可在类的定义中提供另一个类定义。例如，假定SpreadsheetCell类实际上是Spreadsheet类的一部分，因此不妨将SpreadsheetCell重命名为Cell。可将二者定义为:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Spreadsheet</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Cell</span>&#123;</span></span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            Cell() = <span class="keyword">default</span>;</span><br><span class="line">            Cell(<span class="keyword">double</span> initialValue);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Spreadsheet(<span class="keyword">size_t</span> width, <span class="keyword">size_t</span> height, <span class="keyword">const</span> SpreadsheetApplication&amp; theApp);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>现在Cell类定义位于Spreadsheet类内部，因此在Spreasheet类外引用Cell必须用<code>Spreadsheet::</code>作用域限定名称，即使在方法定义时也是如此。例如，Cell的double构造函数应如下所示:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Spreadsheet::Cell::Cell (<span class="keyword">double</span> initialValue) : mValue (initialValue) &#123; &#125;</span><br></pre></td></tr></table></figure></p>
<p>甚至在Spreadsheet类中方法的返回类型(不是参数)也必须使用这一语法:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Spreadsheet::Cell&amp; Spreadsheet::getCellAt(<span class="keyword">size_t</span> x, <span class="keyword">size_t</span> y) &#123;</span><br><span class="line">    verifyCoordinate(x, y)</span><br><span class="line">    <span class="keyword">return</span> mCells[x][y];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果在Spreadsheet类中直接完整定义嵌套的Cell类，将使Spreadsheet类的定义略显臃肿。为缓解这一点，只需要在Spreadsheet中为Cell添加前置声明，然后独立地定义Cell类，如下所示:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Spreadsheet</span></span></span><br><span class="line"><span class="class"><span class="title">public</span>:</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Cell</span> ;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Spreadsheet</span>:</span>:Cell &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Cell() = <span class="keyword">default</span>; </span><br><span class="line">    Cell (<span class="keyword">double</span> initialValue);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>普通的访问控制也适用于嵌套类定义。如果声明了一个private或protected嵌套类，这个类只能在外围类(outer class，即包含它的类)中使用。嵌套的类有权访问外围类中的所有private或protected成员；而外围类却只能访问嵌套类中的public成员。</p>
<h2 id="类内的枚举类型"><a href="#类内的枚举类型" class="headerlink" title="类内的枚举类型"></a>类内的枚举类型</h2><p>如果想在类内定义许多常量，应该使用枚举类型而不是#define。例如，可在SpreadsheetCell类中支持单元格颜色，如下所示:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpreadsheetCell</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Color</span> &#123;</span> Red = <span class="number">1</span>; Green, Blue, Yel1ow &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setColor</span> <span class="params">(Color color)</span></span>;</span><br><span class="line">    <span class="function">Color <span class="title">getColor</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Color mColor = Color::Red; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>setColor()</code>和<code>getColor()</code>方法的实现简单明了:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SpreadsheetCell::setColor (Color color) &#123; mColor = color; &#125;</span><br><span class="line">SpreadsheetCell::Color SpreadsheetCell::getColor() <span class="keyword">const</span> &#123; <span class="keyword">return</span> mColor; &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><p>C++允许编写自己的加号版本，为此可编写一个名为<code>operator+</code>的方法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpreadsheetCell</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SpreadsheetCell <span class="keyword">operator</span>+(<span class="keyword">const</span> SpreadsheetCell&amp; cell) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SpreadsheetCell(getValue() + cell.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当C++编译器分析一个程序，遇到运算符(例如，+、-、=或&lt;&lt;)时，就会试着查找名为<code>operator+</code>、<code>operator-</code>、<code>operator=</code>或<code>operator&lt;&lt;</code>，且具有适当参数的函数或方法。例如，当编译器看到下面这行时，就会试着查找SpreadsheetCell类中名为<code>operator+</code>并将另一个SpreadsheetCell对象作为参数的方法，或者查找用两个SpreadsheetCell对象作为参数、名为operator+的全局函数:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SpreadsheetCell aThirdCell = myCell + anotherCell;</span><br></pre></td></tr></table></figure></p>
<p>如果SpreadsheetCell类包含<code>operator+</code>方法，上述代码就 会转换为:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SpreadsheetCell aThirdCell = myCell.<span class="keyword">operator</span>+ (anotherCell);</span><br></pre></td></tr></table></figure></p>
<p>注意，用作operator+参数的对象类型并不一定要与编写operator+的类相同。</p>
<p>此外还要注意，可任意指定operator+的返回值类型。运算符重载是函数重载的一种形式，函数重载对函数的返回类型并没有要求。</p>
<h4 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h4><p>令人惊讶的是，一旦编写前面所示的operator+，不仅可将两个单元格相加，还可将单元格与string_view、double或int 值相加。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SpreadsheetCell myCell(4), aThirdCell;</span><br><span class="line"><span class="built_in">string</span> str = <span class="string">"hello"</span>;</span><br><span class="line">aThirdCell = myCell + string_view(str);</span><br><span class="line">aThirdCell = myCell + <span class="number">5.6</span>;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码之所以可运行，是因为编译器会试着查找合适的<code>operator+</code>，而不是只查找指定类型的那个<code>operator+</code>。为找到<code>operator+</code>，编译器还试图查找合适的类型转换，构造函数会对有问题的类型进行适当的转换。</p>
<p>隐式转换通常会带来便利。但在上例中，将SpreadsheetCell与string_view相加并没有意义。可使用explicit关键字标记构造函数，禁止将string_view隐式地转换为SpreadsheetCell：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpreadsheetCell</span> &#123;</span> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SpreadsheetCell() = <span class="keyword">default</span>;</span><br><span class="line">    SpreadsheetCell (<span class="keyword">double</span> initialValue);</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">SpreadsheetCe1l</span> <span class="params">(<span class="built_in">std</span>::string_view initialvalue)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>explicit关键字只在类定义内使用，只适用于只有一个参数的构造函数，例如单参构造函数或为参数提供默认值的多参构造函数。由于必须创建临时对象，隐式使用构造函数的效率不高。为避免与double值相加时隐式地使用构造函数，可编写第二个operator+，如下所示:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SpreadsheetCell SpreadsheetCell::<span class="keyword">operator</span>+(<span class="keyword">double</span> rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> SpreadsheetCell(getValue() + rhs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="第三次尝试：全局operator"><a href="#第三次尝试：全局operator" class="headerlink" title="第三次尝试：全局operator+"></a>第三次尝试：全局operator+</h4><p>隐式转换允许使用<code>operator+</code>方法将SpreadsheetCell对象与int和double值相加。然而，这个运算符不具有互换性，如下所示:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">aThirdcell = myCell + <span class="number">4</span>; <span class="comment">// Works fine.</span></span><br><span class="line">aThirdCell = <span class="number">4</span> + myCell; <span class="comment">// FAILS TO COMPILE!</span></span><br></pre></td></tr></table></figure></p>
<p>当SpreadsheetCell对象在运算符的左边时，隐式转换正常运行，但在右边时无法运行。加法是可互换的，因此这里存在错误。问题在于必须在SpreadsheetCell对象上调用operator+ 方法，对象必须在operator+的左边。这是C++语言定义的方式，因此使用operator+方法无法让上面的代码运行。</p>
<p>然而，如果用不局限于某个特定对象的全局operator+函数替换类内的operator+方法，上面的代码就可以运行，需要在头文件中声明运算符:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpreadsheetCell</span> &#123;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SpreadsheetCell <span class="keyword">operator</span>+ (<span class="keyword">const</span> SpreadsheetCell&amp; lhs, <span class="keyword">const</span> SpreadsheetCell&amp; rhs);</span><br></pre></td></tr></table></figure></p>
<p>那么，如果编写以下代码，会发生什么情况呢?<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aThirdCell = <span class="number">4.5</span> + <span class="number">5.5</span>;</span><br></pre></td></tr></table></figure></p>
<p>这段代码可编译并运行，但并没有调用前面编写的operator+。这段代码将普通的double型数值4.5和5.5相加，得到了下面所示的中间语句:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aThirdCell = <span class="number">10</span>;</span><br></pre></td></tr></table></figure></p>
<p>为了让赋值操作继续，运算符右边应该是SpreadsheetCell对象。编译器找到并非显式由用户定义的用double值作为参数的构造函数，然后用这个构造函数隐式地将double值转换为一个临时SpreadsheeCell对象，最后调用赋值运算符。</p>
<p>在C++中，不能更改运算符的优先级。例如，*和/始终在+和一之前计算。对于用户定义的运算符，唯一能做的只是在确定运算的优先级后指定实现。C++也不允许发明新的运算符号，不允许更改运算符的实参个数。</p>
<h3 id="重载算术运算符"><a href="#重载算术运算符" class="headerlink" title="重载算术运算符"></a>重载算术运算符</h3><p>必须显式地重载简写算术运算符(Arithmetic Shorthand Operators)。这些运算符与基本算术运算符不同，它们会改变运算符左边的对象，而不是创建一个新对象。此外还有一个微妙差别，它们生成的结果是对被修改对象的引用，这一点与赋值运算符类似。简写算术运算符的左边总要有一个对象，因此应该将其作为方法而不是全局函数。下面是SpreadsheetCell类的声明:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpreadsheetCell</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SpreadsheetCell&amp; <span class="keyword">operator</span>+= (<span class="keyword">const</span> SpreadsheetCell&amp; rhs);</span><br><span class="line">    SpreadsheetCell&amp; <span class="keyword">operator</span>-= (<span class="keyword">const</span> SpreadsheetCe1l&amp; rhs);</span><br><span class="line">    SpreadsheetCell&amp; <span class="keyword">operator</span>*= (<span class="keyword">const</span> SpreadsheetCell&amp; rhs);</span><br><span class="line">    SpreadsheetCell&amp; <span class="keyword">operator</span>/= (<span class="keyword">const</span> SpreadsheetCell&amp; rhs);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>下面是<code>operator+=</code>的实现，其他的与此类似。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SpreadsheetCell&amp; SpreadsheetCell::<span class="keyword">operator</span>+= (<span class="keyword">const</span> SpreadsheetCell&amp; rhs) &#123;</span><br><span class="line">    <span class="built_in">set</span>(getValue() + rhs.getValue());</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>简写算术运算符是对基本算术运算符和赋值运算符的结合。根据上面的定义，可编写如下代码:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SpreadsheetCell myCell(4), aThirdCell(2);</span><br><span class="line">aThirdCell -= myCell;</span><br><span class="line">aThirdCell += <span class="number">5.4</span>;</span><br></pre></td></tr></table></figure></p>
<p>然而不能编写这样的代码<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5.4</span> += aThirdCell;</span><br></pre></td></tr></table></figure></p>
<p>如果既有某个运算符的普通版本，又有简写版本，建议你基于简写版本实现普通版本，以避免代码重复。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SpreadsheetCell <span class="keyword">operator</span>+ (<span class="keyword">const</span> SpreadsheetCell&amp; lhs, <span class="keyword">const</span> SpreadsheetCell&amp; rhs) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">result</span><span class="params">(lhs)</span></span>; <span class="comment">// Local copy</span></span><br><span class="line">    result += rhs;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="重载比较运算符"><a href="#重载比较运算符" class="headerlink" title="重载比较运算符"></a>重载比较运算符</h3><p>与基本的算术运算符类似，它们也应该是全局函数，这样就可在运算符的左边和右边使用隐式转换。所有比较运算符的返回值都是布尔值。当然，可改变返回类型，但并不建议这么做。下面是比较运算符的声明；<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt;op&gt; (<span class="keyword">const</span> SpreadsheetCell&amp; lhs，<span class="keyword">const</span> SpreadsheetCell&amp; rhs) ;</span><br></pre></td></tr></table></figure></p>
<p>下面是<code>operator==</code>的定义，其他的与此类似:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>== (<span class="keyword">const</span> SpreadsheetCell&amp; lhs, <span class="keyword">const</span> SpreadsheetCell&amp; rhs) &#123;</span><br><span class="line">    <span class="keyword">return</span> (lhs.getValue() == rhs.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当类中的数据成员较多时，比较每个数据成员可能比较痛苦。然而，当实现了==和&lt;之后，可以根据这两个运算符编写其他比较运算符。例如，下面的<code>operator&gt;=</code>定义使用了<code>operator&lt;</code>。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&gt;= (<span class="keyword">const</span> SpreadsheetCell&amp; lhs, <span class="keyword">const</span> SpreadsheetCell&amp; rhs) &#123;</span><br><span class="line">    <span class="keyword">return</span> !(lhs &lt; rhs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可使用这些运算符将某个SpreadsheetCell与其他SpreadsheetCell进行比较，也可与double和int值进行比较：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (myCell &gt; aThirdCell || myCell &lt; <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; myCell.getValue() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="揭秘继承技术"><a href="#揭秘继承技术" class="headerlink" title="揭秘继承技术"></a>揭秘继承技术</h1><h2 id="使用继承构建类"><a href="#使用继承构建类" class="headerlink" title="使用继承构建类"></a>使用继承构建类</h2><h3 id="扩展类"><a href="#扩展类" class="headerlink" title="扩展类"></a>扩展类</h3><p>当使用C++编写类定义时，可以告诉编译器，该类继承(或扩展)了一个已有的类。通过这种方式，该类将自动包含原始类的数据成员和方法；原始类称为父类(parent class)、基类或超类(superclass)。扩展已有类可以使该类(现在称为派生类或子类)只描述与父类不同的那部分内容。</p>
<p>在C++中，为扩展一个类，可在定义类时指定要扩展的类。为说明继承的语法，此处使用了名为Base和Derived的类。首先考虑Base类的定义:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">someMethod</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> mProtectedInt;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> mPrivateInt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>如果要构建一个从Base类继承的新类Derived，应该使用下面的语法告诉编译器：Derived类派生自Base类：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">someOtherMethod</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>Derived本身就是一个完整的类，这个类只是刚好共享了Base类的特性而已。Derived不一定是Base唯一的派生类。其他类也可是Base的派生类，这些类是Derived的同级类(sibling)。</p>
<h4 id="客户对继承的看法"><a href="#客户对继承的看法" class="headerlink" title="客户对继承的看法"></a>客户对继承的看法</h4><p>对于客户或代码的其他部分而言，Derived类型的对象仍然是Base对象，因为Derived类从Base类继承。这意味着Base类的所有public方法和数据成员，以及Derived类的所有public方法和数据成员都是可供使用的。</p>
<p>在调用某个方法时，使用派生类的代码不需要知道是继承链中的哪个类定义了这个方法。例如，下面的代码调用了Derived对象的两个方法，而其中一个方法是在Base类中定义的:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Derived myDerived;</span><br><span class="line">myDerived.someMethod() ;</span><br><span class="line">myDerived.someOtherMethod() ;</span><br></pre></td></tr></table></figure></p>
<p>指向某个对象的指针或引用可以指向声明类的对象，也可以指向其任意派生类的对象。此时需要理解的概念是，指向Base对象的指针可以指向Derived对象，对于引用也是如此。客户仍然只能访问Base类的方法和数据成员，但是通过这种机制，任何操作Base对象的代码都可以操作Derived对象。</p>
<p>例如，下面的代码可以正常编译并运行，尽管看上去好像类型并不匹配:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Base* base = <span class="keyword">new</span> Derived() ; <span class="comment">// Create Derived， store it in Base pointer .</span></span><br></pre></td></tr></table></figure></p>
<p>然而，不能通过Base指针调用Derived类的方法。下面的代码无法运行:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">base-&gt;someOtherMethod();</span><br></pre></td></tr></table></figure></p>
<h4 id="从派生类的角度分析继承"><a href="#从派生类的角度分析继承" class="headerlink" title="从派生类的角度分析继承"></a>从派生类的角度分析继承</h4><p>派生类可访问基类中声明的public、 protected 方法和数据成员，就好像这些方法和数据成员是派生类自己的，因为从技术上讲，它们属于派生类。例如，Derived 类中someOtherMethod()的实现可以使用在Base类中声明的数据成员mProtectedInt。下面的代码显示了这一实现，访问基类的数据成员和方法与访问派生类中的数据成员和方法并无不同之处。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Derived::someOtherMethod() &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"I can access base class data member mProtectedInt."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Its value is "</span>&lt;&lt; mProtectedInt &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果类将数据成员和方法声明为protected，派生类就可以访问它们；如果声明为private，派生类就不能访问。</p>
<p>private访问说明符可控制派生类与基类的交互方式。建议将所有数据成员都默认声明为private，如果希望任何代码都可以访问这些数据成员，就可以提供public的获取器和设置器。如果仅希望派生类访问它们，就可以提供受保护的获取器和设置器。把数据成员默认设置为private的原因是，这会提供最高级别的封装，这意味着可改变数据的表示方式，而public或protected接口保持不变。不直接访问数据成员，也可在public或protected设置其中方便地添加对数据的检查。方法也应默认设置为private，只有需要公开的方法才设置为public，只有派生类需要访问的方法才设置为protected。</p>
<h4 id="禁用继承"><a href="#禁用继承" class="headerlink" title="禁用继承"></a>禁用继承</h4><p>C++允许将类标记为final，这意味着继承这个类会导致编译错误。将类标记为final的方法是直接在类名的后面使用final关键字。例如，下面的Base类被标记为final：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> <span class="title">final</span> &#123;</span> &#125;;</span><br></pre></td></tr></table></figure></p>
<p>下面的Derived类试图从Base类继承，但是这会导致编译错误，因为Base类被标记为final。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base &#123; &#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="重写方法"><a href="#重写方法" class="headerlink" title="重写方法"></a>重写方法</h3><p>从某个类继承的主要原因是为了添加或替换功能。Derived类定义在父类的基础上添加了功能。在许多情况下，可能需要替换或重写某个方法来修改类的行为。</p>
<h4 id="将所有方法都设置为virtual，以防万一"><a href="#将所有方法都设置为virtual，以防万一" class="headerlink" title="将所有方法都设置为virtual，以防万一"></a>将所有方法都设置为virtual，以防万一</h4><p>在C++中，重写(verride)方法有一点别扭，因为必须使用关键字vitual。只有在基类中声明为virtual的方法才能被派生类正确地重写。virtual关键字出现在方法声明的开头，下面显示了Base类的修改版本：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">someMethod</span><span class="params">()</span> </span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> mProtectedInt;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> mPrivateInt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>virtual关键字有些微妙之处，常被当作语言的设计不当部分。经验表明，最好将所有方法都设置为virtual。即使Derived类不大可能扩展，也最好还是将这个类的方法设置为virtual。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base &#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">someOtherMethod</span><span class="params">()</span> </span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>为避免因为遗漏virtual关键字引发的问题，可将所有方法设置为virtual(包括析构函数，但不包括构造函数)。注意，由编译器生成的析构函数不是virtual!</p>
<h4 id="重写方法的语法"><a href="#重写方法的语法" class="headerlink" title="重写方法的语法"></a>重写方法的语法</h4><p>为了重写某个方法，需要在派生类的定义中重新声明这个方法，就像在基类中声明的那样，并在派生类的实现文件中提供新的定义。例如，Base类包含了一个<code>someMethod()</code>方法，在Base.cpp中提供的<code>someMethod()</code>方法定义如下:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Base::someMethod() &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"This is Base's version of someMethod() ."</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意在方法定义中不需要重复使用virtual关键字。</p>
<p>如果希望在Derived类中提供<code>someMethod()</code>的新定义，首先应该在Derived类定义中添加这个方法，如下所示:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">someMethod</span><span class="params">()</span> override</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">someOtherMethod</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>建议在重写方法的声明末尾添加override关键字。</p>
<p>一旦将方法或析构函数标记为virtual，它们在所有派生类中就一直是 virtual，即使在派生类中删除了virtual关键字，也同样如此。例如，Derived类中，<code>someMethod()</code>仍然是virtual，可以被Derived的派生类重写，因为在Base类中将其标记为virtual。</p>
<h4 id="客户对重写方法的看法"><a href="#客户对重写方法的看法" class="headerlink" title="客户对重写方法的看法"></a>客户对重写方法的看法</h4><p>现在someMethod()的行为将根据对象所属类的不同而变化。例如，下面的代码与先前一样可以运行，调用Base版本的<code>someMethod()</code>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Base myBase;</span><br><span class="line">myBase.someMethod();</span><br></pre></td></tr></table></figure></p>
<p>如果声明一个Derived类对象，将自动调用派生类版本的<code>someMethod()</code>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Derived myDerived;</span><br><span class="line">myDerived.someMethod();</span><br></pre></td></tr></table></figure></p>
<p>Derived类对象的其他方面维持不变。<strong>从Base 类继承的其他方法仍然保持Base类提供的定义，除非在Derived类中显式地重写这些方法</strong>。</p>
<p>如前所述，指针或引用可指向某个类或其派生类的对象。对象本身“知道”自己所属的类，因此只要这个方法声明为vitual，就会自动调用对应的方法。例如，如果一个对Base对象的引用实际引用的是Derived对象，调用<code>someMethod()</code>实际上会调用派生类版本，如下所示。如果在基类中省略了virtual 关键字，重写功能将无法正确运行。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Derived myDerived;</span><br><span class="line">Base&amp; ref = myDerived;</span><br><span class="line">ref.someMethod(); <span class="comment">// Calls Derived's version</span></span><br></pre></td></tr></table></figure></p>
<p>记住，即使基类的引用或指针知道这实际上是一个派生类，也无法访问没有在基类中定义的派生类方法或成员。下面的代码无法编译，因为Base引用没有<code>someOtherMethod()</code>方法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Derived myDerived;</span><br><span class="line">Base&amp; ref = myDerived;</span><br><span class="line">myDerived.someOtherMethod(); <span class="comment">// This is fine.</span></span><br><span class="line">ref.someOtherMethod();  <span class="comment">// Error</span></span><br></pre></td></tr></table></figure></p>
<p>非指针或非引用对象无法正确处理派生类的特征信息。可将Derived对象转换为Base对象，或将Derived对象赋值给Base对象，因为Derived对象也是Base对象。然而，此时这个对象将遗失派生类的所有信息：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Derived myDerived;</span><br><span class="line">Base assignedobject = myDerived; <span class="comment">//Assigns a Derived to a Base .</span></span><br><span class="line">assignedObject.someMethod();     <span class="comment">// Calls Base's version of someMethod()</span></span><br></pre></td></tr></table></figure></p>
<p>为记住这个看上去有点奇怪的行为，可考虑对象在内存中的状态。将Base对象当作占据内存的盒子。Derived对象是稍微大一点的盒子，因为它拥有Base对象的一切，还添加了一点内容。对于指向Derived对象的引用或指针，这个盒子并没有变，只是可以用新的方法访问它。然而，如果将Derived对象转换为Base对象，就会为了适应较小的盒子而扔掉Derived类全部的“独有特征”。</p>
<blockquote>
<p>基类的指针或引用指向派生类对象时，派生类保留其重写方法。但是通过类型转换将派生类对象转换为基类对象时，就会丢失其独有特征。重写方法和派生类数据的丢失称为截断(slicing)。</p>
</blockquote>
<h4 id="override关键字"><a href="#override关键字" class="headerlink" title="override关键字"></a>override关键字</h4><p>如果修改了Base类但忘记更新所有派生类，就会发生重载失败的问题。实际上就是创建了一个新的虚方法，而不是正确的重写这个方法。可用override关键字避免这种情况，如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">someMethod</span><span class="params">(<span class="keyword">int</span> i)</span> override </span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>Derived类的定义将导致编译错误，因为override关键字表明，重写Base类的<code>someMethod()</code>方法，但Base类中的<code>someMethod()</code>方法只接收双精度数，而不接收整数。重命名基类中的某个方法，但忘记重命名派生类中的重写方法时，就会出现上述“不小心创建了新方法，而不是正确重写方法”的问题。</p>
<blockquote>
<p>要想重写基类方法，始终在方法上使用override关键字。</p>
</blockquote>
<h4 id="virtual的真相"><a href="#virtual的真相" class="headerlink" title="virtual的真相"></a>virtual的真相</h4><p>如果方法不是virtual，也可以试着重写这个方法，但是这样做会导致微妙的错误。</p>
<p><strong>隐藏而不是重写</strong></p>
<p>下面的代码显示了一个基类和一个派生类，每个类都有一个方法。派生类试图重写基类的方法，但是在基类中没有将这个方法声明为virtual。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">go</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"go() called on Base"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">go</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"go() called on Derived"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>试着用Derived对象调用<code>go()</code>方法好像没有问题。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Derived myDerived;</span><br><span class="line">myDerived.go();</span><br></pre></td></tr></table></figure></p>
<p>正如预期的那样，这个调用的结果是“go() called on Derived”。然而，由于这个方法不是virtual，因此实际上没有被重写。相反，Derived类创建了一个新的方法，名称也是<code>go()</code>，这个方法与Base类的<code>go()</code>方法完全没有关系。为证实这一点，只需要用Base指针或引用调用这个方法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Derived myDerived;</span><br><span class="line">Base&amp; ref = myDerived;</span><br><span class="line">ref.go();</span><br></pre></td></tr></table></figure></p>
<p>你可能希望输出是“go() called on Derived”，但实际上，输出是“go() called on Base”。这是因为ref变量是一个Base引用，并省略了virtual关键字。当调用<code>go()</code>方法时，只是执行了Base类的<code>go()</code>方法。由于不是虛方法，不需要考虑派生类是否重写了这个方法。</p>
<p><strong>如何实现virtual</strong></p>
<p>为理解如何避免隐藏方法，需要了解virtual关键字的真正作用。C++在编译类时，会创建一个包含类中所有方法的二进制对象。在非虚情况下，将控制交给正确方法的代码是硬编码，此时会根据编译时的类型调用方法。这称为<strong>静态绑定</strong>(static binding)，也称为早绑定(early binding)。</p>
<p>如果方法声明为vitual, 会使用名为虚表(vtable)的特定内存区域调用正确的实现。每个具有一个或多个虚方法的类都有一张虚表，这种类的每个对象都包含指向虚表的指针，这个虚表包含指向虛方法实现的指针。通过这种方法，当使用某个对象调用方法时，指针也进入虚表，然后根据实际的对象类型执行正确版本的方法。</p>
<p>这称为动态绑定(dynamic binding)或晚绑定(late binding)。</p>
<p>为更好地理解虚表是如何实现方法的重写的，考虑下面的Base和Derived类:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func2</span> <span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">nonVirtualFunc</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span> override </span>&#123; &#125;</span><br><span class="line">    <span class="keyword">void</span> nonVirtualFunc &#123; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>对于这个示例，考虑下面的两个实例:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Base myBase;</span><br><span class="line">Derived myDerived;</span><br></pre></td></tr></table></figure></p>
<p>图10-4 显示了这两个实例虚表的高级视图。myBase对象包含了指向虚表的一个指针，虚表有两项，一项是<code>func1()</code>，另一项是<code>func2()</code>。这两项指向<code>Base::func1()</code>和<code>Base::func2()</code>的实现。<br><img src="/img/1619270636.jpg" alt></p>
<p>myDerived也包含指向虚表的一个指针，这个虚表也包含两项，一项是<code>func1()</code>，另一项是<code>func2()</code>。myDerived虚表的<code>func1()</code>项指向<code>Base::func1()</code>，因为Derived类没有重写<code>func1()</code>；但是myDerived虛表的<code>func2()</code>项指向<code>Derived::func2()</code>。</p>
<p><strong>使用virtual的理由</strong></p>
<p>首先创建virtual的原因，与虚表的开销有关。要调用虚方法，程序需要执行一项附加操作，即对指向要执行的适当代码的指针解除应用。在多数情况下，这样做会轻微地影响性能。如果方法永远不会重写，就没必要将其声明为virtual，从而影响性能。在多数应用程序中，无法察觉到使用虛方法和不使用虛方法带来的性能差别，因此应该遵循建议，将所有方法声明为virtual，包括析构函数。</p>
<p>但在某些情况下，性能开销确实不小，需要避免。例如，假设Point类有一个虚方法。 如果另一个数据结构存储着数百万个甚至数十亿个Point对象，在每个Point 对象上调用虚方法将带来极大的开销。此时，最好避免在Point类中使用虚方法。</p>
<p>virtual对于每个对象的内存使用也有轻微影响。除了方法的实现之外，每个对象还需要一个指向虚表的指针，这个指针会占用一点空间。</p>
<p><strong>虚析构函数的需求</strong></p>
<p>即使认为不应将所有方法都声明为virtual的程序员，也坚持认为应该将析构函数声明为virtual。原因是，如果析构函数未声明为virtual，很容易在销毁对象时不释放内存。唯一允许不把析构函数声明为virtual的例外情况是，类被标记为final。</p>
<p>例如，派生类使用的内存在构造函数中动态分配，在析构函数中释放。如果不调用析构函数，这块内存将无法释放。类似地，如果派生类具有一些成员，这些成员在类的实例销毁时自动删除，如<code>stl:unique_ptrs</code>，那么如果从未调用析构函数，将不会删除这些成员。</p>
<p>如果在析构函数中什么都不做，只想把它设置为virtual, 可显式地设置“default”，例如:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~Base() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>除非有特别原因，或者类被标记为final，否则强烈建议将所有方法(包括析构函数，构造函数除外)声明为virtual，构造函数不需要，也无法声明为virtual，因为在创建对象时，总会明确地指定类。</p>
</blockquote>
<h4 id="禁用重写"><a href="#禁用重写" class="headerlink" title="禁用重写"></a>禁用重写</h4><p>C++允许将方法标记为final，这意味着无法在派生类中重写这个方法。考虑下面的Base类:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~Base() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">someMethod</span><span class="params">()</span> final</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在下面的Derived类中重写<code>someMethod()</code>会导致编译错误，因为<code>someMethod()</code>在Base类中标记为final。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base &#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">someMethod</span><span class="params">()</span> override</span>; <span class="comment">// Error</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="利用父类"><a href="#利用父类" class="headerlink" title="利用父类"></a>利用父类</h2><p>编写派生类时，需要知道父类和派生类之间的交互方式。创建顺序、构造函数链和类型转换都是潜在的bug来源。</p>
<h3 id="父类构造函数"><a href="#父类构造函数" class="headerlink" title="父类构造函数"></a>父类构造函数</h3><p>创建对象时必须同时创建父类和包含于其中的对象。C++定义了如下创建顺序:</p>
<ol>
<li>如果某个类具有基类，执行基类的默认构造函数。除非在ctor-initializer中调用了基类构造函数，否则此时调用这个构造函数而不是默认构造函数。</li>
<li>类的非静态数据成员按照声明的顺序创建。</li>
<li>执行该类的构造函数。</li>
</ol>
<p>下面的代码显示了创建顺序。代码正确执行时输出结果为123。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Something</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Something() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"2"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    Base() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"1"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Derived() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"3"</span>; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Something mDataMember;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Derived myDerived;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>创建myDerived对象时，首先调用Base构造函数，输出字符串“1”。 随后，初始化mDataMember，调用Something构造函数，输出字符串“2”。最后调用Derived构造函数，输出“3”。</p>
<p>注意Base构造函数是自动调用的。C++将自动调用父类的默认构造函数(如果存在的话)。如果父类的默认构造函数不存在，或者存在默认构造函数但希望使用其他构造函数，可在构造函数初始化器(constructor initializer)中像初始化数据成员那样链接构造函数。例如，下面的代码显示了没有默认构造函数的Base版本。相关版本的Derived必须显式地告诉编译器如何调用Base构造函数，否则代码将无法编译。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base(<span class="keyword">int</span> i);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Derived();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Derived::Derived() : Base(<span class="number">7</span>) &#123; &#125;</span><br></pre></td></tr></table></figure></p>
<p>在前面的代码中，Derived 构造函数向Base构造函数传递了固定值(7)。如果Derived构造函数需要一个参数，也可以传递变量:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Derived::Derived(<span class="keyword">int</span> i) : Base(i) &#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>从派生类向基类传递构造函数的参数很正常，毫无问题，但是无法传递数据成员。如果这么做，代码可以编译，但是记住在调用基类构造函数之后才会初始化数据成员。如果将数据成员作为参数传递给父类构造函数，数据成员不会初始化。</p>
<h4 id="父类的析构函数"><a href="#父类的析构函数" class="headerlink" title="父类的析构函数"></a>父类的析构函数</h4><p>由于析构函数没有参数，因此始终可自动调用父类的析构函数。析构函数的调用顺序刚好与构造函数相反:</p>
<ol>
<li>调用类的析构函数。</li>
<li>销毁类的数据成员，与创建的顺序相反。</li>
<li>如果有父类，调用父类的析构函数。</li>
</ol>
<p>也可递归使用这些规则。链的最底层成员总是第一个被销毁。下面的代码在前面的示例中加入了析构函数。所有析构函数都声明为virtual。执行时代码将输出“123321”。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Something</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~Something() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"2"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~Base() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"1"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Derived() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"3"</span>; &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~Derived() &#123; <span class="built_in">cout</span> &lt; &lt; <span class="string">"3"</span>; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Something mDataMember;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>即使前面的析构函数没有声明为vitual，代码也可以继续运行。然而，如果代码使用delete删除一个实际指向派生类的基类指针，析构函数调用链将被破坏。例如，下面的代码与前面示例类似，但析构函数不是virtual。当使用指向Base对象的指针访问Derived对象并删除对象时，就会出问题。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Base* ptr = <span class="keyword">new</span> Derived() ;</span><br><span class="line"><span class="keyword">delete</span> ptr;</span><br></pre></td></tr></table></figure></p>
<p>代码的输出很短，是“1231”。当删除ptr 变量时，只调用了Base析构函数，因为析构函数没有声明为virtual。结果是没有调用Derived析构函数，也没有调用其数据成员的析构函数。</p>
<p>从技术角度看，将Base 析构函数声明为virtual,可纠正上面的问题。派生类将自动“虚化”。然而，建议显式地将所有析构函数声明为virtual，这样就不必担心这个问题。</p>
<blockquote>
<p>将所有析构函数声明为virtual！编译器生成的默认析构函数不是virtual，因此应该定义自己(或显式设置为默认)的虚析构函数，至少在父类中应该这么做。</p>
</blockquote>
<blockquote>
<p>与构造函数一样，在析构函数中调用虚方法时，虚方法的行为将有所不同。如果派生类重写了基类中的虚方法，在基类的析构函数中调用该方法，会执行该方法的基类实现，而不是派生类的重写版本。</p>
</blockquote>
<h3 id="使用父类方法"><a href="#使用父类方法" class="headerlink" title="使用父类方法"></a>使用父类方法</h3><p>在派生类中重写方法时，将有效地替换原始方法。然而，方法的父类版本仍然存在，仍然可以使用这些方法。考虑WeatherPrediction类中的<code>getTemperature()</code>方法，这个方法返回当前温度的字符串表示:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeatherPrediction</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">getTemperature</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在MyWeatherPrediction类中，可按如下方式重写这个方法:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyWeatherPrediction</span> :</span> <span class="keyword">public</span> WeatherPrediction</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">getTemperature</span><span class="params">()</span> <span class="keyword">const</span> override</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>假定派生类要先调用基类的<code>getTemperature()</code>方法，然后将“°F”添加到string。为此，编写如下代码:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> MyWeatherPrediction::getTemperature() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getTemperature() + <span class="string">"\u00B0E"</span>; <span class="comment">// BUG</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然而，上述代码无法运行，根据C++的名称解析规则，首先解析的是局部作用域，然后是类作用域，根据这个顺序，函数中调用的是<code>MyWeatherPrediction::getTemperature()</code>。其结果是无限递归，直到耗尽堆栈空间。</p>
<p>为让代码运行，需要使用作用域解析运算符，如下所示:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> MyWeatherPrediction::getTemperature() <span class="keyword">const</span> &#123; </span><br><span class="line">    <span class="keyword">return</span> WeatherPrediction::getTemperature() + <span class="string">" \u00B0F"</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在C++中，调用当前方法的父类版本是一种常见操作。如果存在派生类链，每个派生类都可能想执行基类中已经定义的操作，同时添加自己的附加功能。如果父类没有重写祖父类中的函数，C++会沿着类层次结构向上寻找实现了这个函数的类。</p>
<h3 id="向上转型和向下转型"><a href="#向上转型和向下转型" class="headerlink" title="向上转型和向下转型"></a>向上转型和向下转型</h3><p>如前所述，对象可转换为父类对象，或者赋值给父类。如果类型转换或赋值是对某个普通对象执行，会产生截断:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Base myBase = myDerived; <span class="comment">// Slicing!</span></span><br></pre></td></tr></table></figure></p>
<p>这种情况下会导致截断，因为赋值结果是Base对象，而Base对象缺少Derived类中定义的附加功能。然而，如果用派生类对基类的指针或引用赋值，则不会产生截断:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Base&amp; myBase = myDerived; <span class="comment">// No slicing!</span></span><br></pre></td></tr></table></figure></p>
<p>这是通过基类使用派生类的正确途径，也叫作向上转型(upcating)。这也是让方法和函数使用类的引用而不是直接使用类对象的原因。使用引用时，派生类在传递时没有截断。</p>
<blockquote>
<p>当向上转型时，使用基类指针或引用以避免截断。</p>
</blockquote>
<p>将基类转换为其派生类也叫作向下转型(downcasting)，专业的C++程序员通常不赞成这种转换，因为无法保证对象实际上属于派生类，也因为向下转型是不好的设计。如果打算进行向下转型，应该使用<code>dynamic_cast()</code>，以使用对象内建的类型信息，拒绝没有意义的类型转换。这种内建信息通常驻留在虚表中，这意味着<code>dynamic_cast</code>只能用于具有虚表的对象，即至少有一个虚编号的对象。如果针对某个指针的<code>dynamic_cast()</code>失败，这个指针的值就是nullptr，而不是指向某个无意义的数据。如果针对对象引用的<code>dynamic_cast()</code>失败，将抛出<code>stl::bad_cast</code>异常。</p>
<h2 id="继承与多态性"><a href="#继承与多态性" class="headerlink" title="继承与多态性"></a>继承与多态性</h2><h3 id="回到电子表格"><a href="#回到电子表格" class="headerlink" title="回到电子表格"></a>回到电子表格</h3><p>下面给出了简化的SpreadsheetCell类定义。注意单元格可以是双精度值或字符串，然而这个示例中单元格的当前值总以字符串的形式返回。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpreadsheetCell</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">double</span> inDouble)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="built_in">std</span>::string_view inString)</span></span>;</span><br><span class="line">        <span class="keyword">virtual</span> <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">getString</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">static</span> <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">doubleTostring</span><span class="params">(<span class="keyword">double</span> inValue)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">stringToDouble</span><span class="params">(<span class="built_in">std</span>::string_view inString)</span></span>;</span><br><span class="line">        <span class="keyword">double</span> mValue;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="设计多态性的电子表格单元格"><a href="#设计多态性的电子表格单元格" class="headerlink" title="设计多态性的电子表格单元格"></a>设计多态性的电子表格单元格</h3><p>SpreadsheeCell类急需改变层次结构。一种合理方法是让SpreadsheetCell只包含字符串，从而限制其范围，在此过程中或许将其重命名为StringSpreadsheetCell。为处理双精度值，可使用第二个类DoubleSpreadsheetCell。因为包含字符串的单元格与包含双精度值的单元格存在明显的关系。让这两个类地位同等，并有共同的父类SpreadsheetCell</p>
<ul>
<li>两个派生类都支持由基类定义的同一接口(方法集)。</li>
<li>使用SpreadsheetCell对象的代码可调用接口中的任何方法，而不需要知道这个单元格是StringSpreadsheetCell还是DoubleSpreadsheetCell。</li>
<li>由于虚方法的特殊能力，会根据对象所属的类调用接口中每个方法的正确实例。</li>
<li>其他数据结构可通过引用父类类型，包含一组多类型的单元格。</li>
</ul>
<h3 id="SpreadsheetCell基类"><a href="#SpreadsheetCell基类" class="headerlink" title="SpreadsheetCell基类"></a>SpreadsheetCell基类</h3><h4 id="初次尝试"><a href="#初次尝试" class="headerlink" title="初次尝试"></a>初次尝试</h4><p>SpreadsheeCell基类负责定义所有派生类支持的行为。在本例中，所有单元格都需要将值设置为字符串。此外，所有单元格都需要将当前值返回为字符串。基类定义中声明了这些方法，以及显式设置为默认的虚析构函数，但没有数据成员:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpreadsheetCell</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~SpreadsheetCell() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">set</span> <span class="params">(<span class="built_in">std</span>::string_view inString)</span> </span>;</span><br><span class="line">    <span class="keyword">virtual</span> <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">getString</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="纯虚方法和抽象基类"><a href="#纯虚方法和抽象基类" class="headerlink" title="纯虚方法和抽象基类"></a>纯虚方法和抽象基类</h4><p>纯虚方法(pure virtual methods)在类定义中显式说明该方法不需要定义。如果将某个方法设置为纯虚方法，就是告诉编译器当前类中不存在这个方法的定义。具有至少一个纯虚方法的类称为<strong>抽象类</strong>，因为这个类没有实例。编译器会强制接受这个事实：如果某个类包含一个或多个纯虚方法，就无法构建这种类型的对象。</p>
<p>采用专门的语法指定纯虚方法：方法声明后紧接着=0。不需要编写任何代码。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpreadsheetCell</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~Spreadsheetcell()  = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">set</span> <span class="params">(<span class="built_in">std</span>::string_view inString)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">getString</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>一旦实现了StringSpreadsheetCell 类，下面的代码就可成功编译，原因在于实例化了抽象基类的派生类：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;SpreadsheetCell&gt; cell (<span class="keyword">new</span> StringSpreadsheetCell());</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>抽象类提供了一种禁止其他代码直接实例化对象的方法，而它的派生类可以实例化对象。</p>
</blockquote>
<h3 id="独立的派生类"><a href="#独立的派生类" class="headerlink" title="独立的派生类"></a>独立的派生类</h3><h4 id="StringSpreadsheetCell类定义"><a href="#StringSpreadsheetCell类定义" class="headerlink" title="StringSpreadsheetCell类定义"></a>StringSpreadsheetCell类定义</h4><p>编写StringSpreadsheetCell类定义的第一步是从SpreadsheetCell类继承。第二步是重写继承的纯虚方法，此次不将其设置为0。最后一步是为字符串单元格添加一个私有数据成员mValue，在其中存储实际单元格数据。这个数据成员是<code>stl::optional</code>，从C++17开始定义在<code>&lt;optional&gt;</code>头文件中。optional类型是一个类模板，因此必须在尖括号之间指定所需的实际类型，如<code>optional&lt;string&gt;</code>。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StringSpreadsheetCell</span> :</span> <span class="keyword">public</span> SpreadsheetCell &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="built_in">std</span>::string_view inString)</span> override</span>;</span><br><span class="line">    <span class="keyword">virtual</span> <span class="built_in">std</span>: :<span class="function"><span class="built_in">string</span> <span class="title">getString</span><span class="params">()</span> <span class="keyword">const</span> override</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::optional&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; mValue;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="StringSpreadsheetCell的实现"><a href="#StringSpreadsheetCell的实现" class="headerlink" title="StringSpreadsheetCell的实现"></a>StringSpreadsheetCell的实现</h4><p>StringSpreadsheetCell 的源文件包含方法的实现。<code>set()</code>方法十分简单，因为内部表示已经是一个字符串。如果mValue不具有值，<code>getString()</code>将返回一个空字符串。可使用<code>std:optional</code>的<code>value_or()</code>方法对此进行简化。使用<code>mValue.value_or(&quot; &quot;)</code>。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> StringSpreadsheetCell::<span class="built_in">set</span>(string_view inString) &#123;</span><br><span class="line">    mValue = inString;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">string</span> StringSpreadsheetCell::getString() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> mValue.value_or(<span class="string">""</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="DoubleSpreadsheetCell-类的定义和实现"><a href="#DoubleSpreadsheetCell-类的定义和实现" class="headerlink" title="DoubleSpreadsheetCell 类的定义和实现"></a>DoubleSpreadsheetCell 类的定义和实现</h4><p>与StringSpreadsheetCell相同，这个类也有一个mValue数据成员，此时这个成员的类型是<code>optional&lt;double&gt;</code>。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoubleSpreadsheetCell</span> :</span> <span class="keyword">public</span> SpreadsheetCell &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">set</span> <span class="params">(<span class="keyword">double</span> inDouble)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">set</span> <span class="params">(<span class="built_in">std</span>::string_view inString)</span> override</span>;</span><br><span class="line">    <span class="keyword">virtual</span> <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">getString</span><span class="params">()</span> <span class="keyword">const</span> override</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">doubleToString</span> <span class="params">(<span class="keyword">double</span> inValue)</span> </span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">stringToDouble</span><span class="params">(<span class="built_in">std</span>::string_view inValue)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::optional&lt;<span class="keyword">double</span>&gt; mValue;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> DoubleSpreadsheetCell::<span class="built_in">set</span> (<span class="keyword">double</span> inDouble) &#123;</span><br><span class="line">    mValue = inDouble;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> DoubleSpreadsheetCell::<span class="built_in">set</span>(string_view inString) &#123;</span><br><span class="line">    mValue = stringToDouble (inString);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">string</span> DoubleSpreadsheetCell::getString() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (mValue.has_value() ? doubleToString(mValue.value()) : <span class="string">""</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="考虑将来"><a href="#考虑将来" class="headerlink" title="考虑将来"></a>考虑将来</h3><p>首先，即使不考虑改进设计，现在仍然缺少一个功能: 将某个单元格类型转换为其他类型。应添加一个转换构造函数(或类型构造函数)，这个构造函数类似于复制构造函数，但参数不是对同类对象的引用，而是对同级类对象的引用。另外注意，现在必须声明一个默认构造函数，可将其显式设置为默认，因为一旦自行声明任何构造函数，编译器将停止生成:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StringSpreadsheetCell</span> :</span> <span class="keyword">public</span> SpreadsheetCell &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    StringSpreadsheetCell() = <span class="keyword">default</span>;</span><br><span class="line">    StringSpreadsheetCell (<span class="keyword">const</span> DoubleSpreadsheetCell&amp; inDoubleCell) ;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>将转换构造函数实现为如下形式:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">StringSpreadsheetCell::StringSpreadsheetCell (</span><br><span class="line"><span class="keyword">const</span> DoubleSpreadsheetCell&amp; inDoubleCell) &#123;</span><br><span class="line">    mValue = inDoubleCell.getString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过转换构造函数，可很方便地用DoubleSpreadsheetCell创建StringSpreadsheetCell。然而不要将其与指针或引用的类型转换混淆，类型转换无法将一个指针或引用转换为同级的另一个指针或引用。</p>
<p>其次，如何为单元格实现运算符重载是一个很有趣的问题，一种方案是给出一种通用表示，前面的实现已将字符串作为标准化的通用类型表示。通过这种通用表示，一个<code>operator+</code>函数就可以处理所有情况。假定两个单元格相加的结果始终是字符串单元格，那么一个可能的实现如下所示:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">StringSpreadsheetCell <span class="keyword">operator</span>+ (<span class="keyword">const</span> StringSpreadsheetCell&amp; lhs, <span class="keyword">const</span> StringSpreadsheetCell&amp; rhs) &#123;</span><br><span class="line">    StringSpreadsheetCell newCell;</span><br><span class="line">    newCell.<span class="built_in">set</span>(lhs.getString() + rhs.getString()) ;</span><br><span class="line">    <span class="keyword">return</span> newCell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h2><h3 id="从多个类继承"><a href="#从多个类继承" class="headerlink" title="从多个类继承"></a>从多个类继承</h3><p>从语法角度看，定义具有多个父类的类很简单。为此，只需要在声明类名时分别列出基类：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Baz</span> :</span> <span class="keyword">public</span> Foo, <span class="keyword">public</span> Bar</span><br><span class="line">&#123; &#125;;</span><br></pre></td></tr></table></figure></p>
<p>由于列出了多个父类，Baz 对象具有如下特性:</p>
<ul>
<li>Baz对象支持Foo和Bar类的public方法，并且包含这两个类的数据成员。</li>
<li>Baz类的方法有权访问Foo和Bar类的protected数据成员和方法。</li>
<li>Baz对象可以向上转型为Foo或Bar对象。</li>
<li>创建新的Baz对象将自动调用Foo和Bar类的默认构造函数，并按照类定义中列出的类顺序进行。</li>
<li>删除Baz对象将自动调用Foo和Bar类的析构函数，调用顺序与类在类定义中的顺序相反。</li>
</ul>
<h3 id="名称冲突和歧义基类"><a href="#名称冲突和歧义基类" class="headerlink" title="名称冲突和歧义基类"></a>名称冲突和歧义基类</h3><p>多重继承崩溃的场景并不难想象，下面的示例显示了一些必须考虑的边缘情况。</p>
<h4 id="名称歧义"><a href="#名称歧义" class="headerlink" title="名称歧义"></a>名称歧义</h4><p>如果两个类都有一个<code>eat()</code>方法，会发生什么？<code>eat()</code>方法的一个版本无法重写另一个版本——在派生类中这两个方法都存在。如果客户代码试图调用派生类的<code>eat()</code>方法，编译器将报错，指出对<code>eat()</code>方法的调用有歧义。</p>
<p>为了消除歧义，可使用<code>dynamic_cast()</code>显式地将对象向上转型(本质上是向编译器隐藏多余的方法版本)，也可以使用歧义消除语法。下面的代码显示了调用<code>eat()</code>方法的Dog版本的两种方案:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dynamic_cast</span>&lt;Dog&amp;&gt; (myConfusedAnimal).eat(); <span class="comment">// Calls Dog::eat()</span></span><br><span class="line">myConfusedAnimal.Dog::eat();</span><br></pre></td></tr></table></figure></p>
<p>使用与访问父类方法相同的语法(::运算符)，派生类的方法本身可以显式地为同名的不同方法消除歧义。例如，派生类可以定义自己的<code>eat()</code>方法，从而消除其他代码中的歧义错误。在方法内部，可以判断调用哪个父类版本:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DogBird</span> :</span> <span class="keyword">public</span> Dog，<span class="keyword">public</span> Bird &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> override</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> DogBird::eat() &#123;</span><br><span class="line">    Dog::eat();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>另一种防止歧义错误的方式是使用using 语句显式指定，在派生类中应继承哪个版本的<code>eat()</code>方法，如下面的DogBird类定义所示:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DogBird</span> :</span> <span class="keyword">public</span> Dog, <span class="keyword">public</span> Bird</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Dog::eat; <span class="comment">// Explicitly inherit Dog's version of eat()</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="歧义基类"><a href="#歧义基类" class="headerlink" title="歧义基类"></a>歧义基类</h4><p>另一种引起歧义的情况是从同一个类继承两次。例如，如果出于某种原因Bird类从Dog类继承，DogBird类的代码将无法编译，因为Dog变成了歧义基类。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span> :</span> <span class="keyword">public</span> Dog &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DogBird</span> :</span> <span class="keyword">public</span> Bird, <span class="keyword">public</span> Dog &#123;&#125;; <span class="comment">// Error!</span></span><br></pre></td></tr></table></figure></p>
<p>数据成员也可以引起歧义。如果Dog和Bird类具有同名的数据成员，当客户代码试图访问这个成员时，就会发生歧义错误。</p>
<p>多个父类本身也可能有共同的父类。例如，Bird和Dog类可能都是Animal类的派生类（菱形类结构）。</p>
<p>使用“菱形”类层次结构的最佳方法是将最顶部的类设置为抽象类，将所有方法都设置为纯虚方法。由于类只声明方法而不提供定义，在基类中没有方法可以调用，因此在这个层次上就没有歧义。</p>
<h2 id="有趣而晦涩的继承问题"><a href="#有趣而晦涩的继承问题" class="headerlink" title="有趣而晦涩的继承问题"></a>有趣而晦涩的继承问题</h2><h3 id="修改重写方法的特征"><a href="#修改重写方法的特征" class="headerlink" title="修改重写方法的特征"></a>修改重写方法的特征</h3><p>重写某个方法的主要原因是为了修改方法的实现。然而，有时是为了修改方法的其他特征。</p>
<h4 id="修改方法的返回类型"><a href="#修改方法的返回类型" class="headerlink" title="修改方法的返回类型"></a>修改方法的返回类型</h4><p>重写方法要使用与基类一致的方法声明(或方法原型)。实现可以改变，但原型保持不变。然而事实未必总是如此，在C++中，如果原始的返回类型是某个类的指针或引用，重写的方法可将返回类型改为派生类的指针或引用。这种类型称为<strong>协变返回类型</strong>(covariant return types)。如果基类和派生类处于平行层次结构(parallel hierarchy)中，使用这个特性可以带来便利。平行层次结构是指，一个类层次结构与另一个类层次结构没有相交，但是存在联系。</p>
<h4 id="修改方法的参数"><a href="#修改方法的参数" class="headerlink" title="修改方法的参数"></a>修改方法的参数</h4><p>如果在派生类的定义中使用父类中虚方法的名称，但参数与父类中同名方法的参数不同，那么这不是重写父类的方法，而是创建一个新方法。回到本章前面的Base 和Derived类示例，可试着在Derived类中使用新的参数列表重写<code>someMethod()</code>方法，如下所示:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">someMethod</span><span class="params">()</span> </span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">someMethod</span><span class="params">(<span class="keyword">int</span> i)</span></span>; <span class="comment">// Compiles, but doesn't override </span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">someOtherMethod</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这个方法的实现如下所示:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Derived::someMethod(<span class="keyword">int</span> i) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"This is Derived's version of someMethod with argument "</span>&lt;&lt; i &lt;&lt; <span class="string">"."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>实际上，C++标准指出，当Derived 类定义了这个方法时，原始的方法被隐藏。下面的代码无法编译，因为没有参数的<code>someMethod()</code>方法不再存在。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Derived myDerived;</span><br><span class="line">myDerived.someMethod(); <span class="comment">// Error! Won't compile because original method is hidden.</span></span><br></pre></td></tr></table></figure></p>
<p>如果希望重写基类中的<code>someMethod()</code>方法，就应该像前面建议的那样使用override关键字。如果在重写方法时发生错误，编译器会报错。</p>
<p>可使用一种较晦涩的技术兼顾二者。也就是说，可使用这一技术在派生类中有效地用新的原型“重写”某个方法，并继承该方法的基类版本。这一技术使用using关键字显式地在派生类中包含这个方法的基类定义:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">someMethod</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Base::someMethod;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">someMethod</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">someOtherMethod</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="继承的构造-函数"><a href="#继承的构造-函数" class="headerlink" title="继承的构造 函数"></a>继承的构造 函数</h3><p>允许在派生类中继承基类的构造函数。考虑下面的Base和Derived类定义:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line">    <span class="keyword">virtual</span> ~Base() = <span class="keyword">default</span>;</span><br><span class="line">    Base() = <span class="keyword">default</span>;</span><br><span class="line">    Base(<span class="built_in">std</span>::string_view str);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Derived(<span class="keyword">int</span> i);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>只能用提供的Base构造函数构建Base对象，要么是默认构造函数，要么是包含string_view 参数的构造函数。另外，只能用Derived构造函数创建Derived 对象，这个构造函数需要一个整数作为参数。不能使用Base类中使用接收string_view 的构造函数来创建Derived对象。例如:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Base <span class="title">base</span> <span class="params">(<span class="string">"Hello"</span>)</span></span>;  <span class="comment">// OK, calls string_view Base ctor</span></span><br><span class="line"><span class="function">Derived <span class="title">derived1</span> <span class="params">(<span class="number">1</span>)</span></span>; <span class="comment">// OK, calls integer Derived ctor</span></span><br><span class="line"><span class="function">Derived <span class="title">derived2</span> <span class="params">(<span class="string">"Hel1o"</span>)</span></span>; <span class="comment">// Error, Derived does not inherit string_view ctor</span></span><br></pre></td></tr></table></figure></p>
<p>如果喜欢使用基于string_view的Base构造函数构建Derived对象，可在Derived 类中显式地继承Base构造函数，如下所示:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Base::Base;</span><br><span class="line">    Derived(<span class="keyword">int</span> i);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>using语句从父类继承除默认构造函数外的其他所有构造函数，现在可通过两种方法构建Derived对象:</p>
<p>Derived类定义的构造函数可与从Base类继承的构造函数有相同的参数列表。与所有的重写一样，此时Derived类的构造函数的优先级高于继承的构造函数。</p>
<p>使用using子句从基类继承构造函数有一些限制。当从基类继承构造函数时，会继承除默认构造函数外的其他全部构造函数，不能只是继承基类构造函数的一个子集。第二个限制与多重继承有关。如果一个基类的某个构造函数与另一个基类的构造函数具有相同的参数列表，就不可能从基类继承构造函数，因为那样会导致歧义。为解决这个问题，Derived类必须显式地定义冲突的构造函数。例如，下面的Derived类试图继承Base1和Base2基类的所有构造函数，这会产生编译错误，因为使用浮点数作为参数的构造函数存在歧义。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~Base1() = <span class="keyword">default</span>;</span><br><span class="line">    Base1() = <span class="keyword">default</span>;</span><br><span class="line">    Base1(<span class="keyword">float</span> f);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~Base2() = <span class="keyword">default</span>;</span><br><span class="line">    Base2() = <span class="keyword">default</span>;</span><br><span class="line">    Base2 (<span class="built_in">std</span>::string_view str);</span><br><span class="line">    Base2(<span class="keyword">float</span> f);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Base1::Base1;</span><br><span class="line">    <span class="keyword">using</span> Base2::Base2;</span><br><span class="line">    Derived(<span class="keyword">char</span> c);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>Derived类定义中的第一条using 语句继承了Base1类的构造函数。这意味着Derived类具有如下构造函数:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Derived(<span class="keyword">float</span> f); <span class="comment">// Inherited from Base1</span></span><br></pre></td></tr></table></figure></p>
<p>Derived类定义中的第二条using子句试图继承Base2类的全部构造函数。然而，这会导致编译错误，因为这意味着Derived类拥有第二个<code>Derived(float f)</code>构造函数。为解决这个问题，可在Derived类中显式声明冲突的构造函数，如下所示:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Base1::Basel;</span><br><span class="line">    <span class="keyword">using</span> Base2::Base2;</span><br><span class="line">    Derived(<span class="keyword">char</span> c);</span><br><span class="line">    Derived(<span class="keyword">float</span> f);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>现在，Derived 类显式地声明了一个采用浮点数作为参数的构造函数，从而解决了歧义问题。如果愿意，在Derived 类中显式声明的使用浮点数作为参数的构造函数仍然可以在ctor-initializer中调用Base1和Base2构造函数，如下所示:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Derived::Derived(<span class="keyword">float</span> f) : Base1(f), Base2(f) &#123;&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="重写方法时的特殊情况"><a href="#重写方法时的特殊情况" class="headerlink" title="重写方法时的特殊情况"></a>重写方法时的特殊情况</h3><p>当重写方法时，需要注意几种特殊情况。本节将列出可能遇到的一些情况。</p>
<h4 id="静态基类方法"><a href="#静态基类方法" class="headerlink" title="静态基类方法"></a>静态基类方法</h4><p>在C++中，不能重写静态方法。对于多数情况而言，知道这一点就足够了。然而，在此需要了解一些推论。首先，方法不可能既是静态的又是虚的。出于这个原因，试图重写一个静态方法并不能得到预期的结果。如果派生类中存在的静态方法与基类中的静态方法同名，实际上这是两个独立的方法。下面的代码显示了两个类，这两个类都有一个名为<code>beStatic()</code>的静态方法。这两个方法毫无关系。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseStatic</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">beStatic</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"BaseStatic being static."</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DerivedStatic</span> :</span> <span class="keyword">public</span> BaseStatic &#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">beStatic</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Derivedstatic keepin' it static."</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>由于静态方法属于类，调用两个类的同名方法时，将调用各自的方法。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BaseStatic::beStatic();</span><br><span class="line">DerivedStatic::beStatic();</span><br></pre></td></tr></table></figure></p>
<p>输出为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BaseStatic being static.</span><br><span class="line">DerivedStatic keepin&apos; it static.</span><br></pre></td></tr></table></figure></p>
<p>用类名访问这些方法时一切都很正常。当涉及对象时，这一行为就不是那么明显。在C++中，可以使用对象调用静态方法，但由于方法是静态的，因此没有this指针，也无法访问对象本身，使用对象调用静态方法，等价于使用<code>classname:method()</code>调用静态方法。回到前面的示例，可以编写如下代码，但是结果令人惊讶:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DerivedStatic myDerivedStatic;</span><br><span class="line">BaseStatic&amp; ref = myDerivedStatic;</span><br><span class="line">myDerivedStatic.beStatic();</span><br><span class="line">ref.beStatic();</span><br></pre></td></tr></table></figure></p>
<p>对<code>beStatic()</code>的第一次调用显然调用了<code>DerivedStatic</code>版本，因为调用它的对象被显式地声明为<code>DerivedStatic</code>。第二次调用的对象是一个<code>BaseStatic</code>引用，但指向的是一个<code>DerivedStatic</code>对象。在此情况下，会调用<code>BaseStatic</code>版本的<code>beStatic()</code>。 原因是当调用静态方法时，C++不关心对象实际上是什么，只关心编译时的类型。在此情况下，该类型为指向BaseStatic对象的引用。</p>
<blockquote>
<p>静态方法属于定义它的类，而不属于特定的对象。当类中的方法调用静态方法时，所调用的版本是通过正常的名称解析来决定的。当使用对象调用时，对象实际上并不涉及调用，只是用来判断编译时的类型。</p>
</blockquote>
<h4 id="重载基类方法"><a href="#重载基类方法" class="headerlink" title="重载基类方法"></a>重载基类方法</h4><p>当指定名称和一组参数以重写某个方法时，编译器隐式地隐藏基类中同名方法的所有其他实例。考虑下面的Derived类，它重写了一个方法，而没有重写相关的同级重载方法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~Base() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">overload</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base's overload()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">overload</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base's overload(int i)"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">overload</span><span class="params">()</span> override </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Derived's overload()"</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>如果试图用Derived对象调用以int值作为参数的<code>overload()</code>版本，代码将无法编译，因为没有显式地重写这个方法。然而，使用Derived对象访问该版本的方法是可行的。只需要使用指向Base对象的指针或引用:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Derived myDerived;</span><br><span class="line">Base&amp; ref = myDerived;</span><br><span class="line">ref.overload(<span class="number">7</span>) ;</span><br></pre></td></tr></table></figure></p>
<p>在C++中，隐藏未实现的重载方法只是表象。显式声明为子类型实例的对象无法使用这些方法，但可将其转换为基类类型，以使用这些方法。</p>
<p>如果只想改变一个方法，可以使用using关键字避免重载该方法的所有版本。在下面的代码中，Derived类定义中使用了从Base类继承的一个<code>overload()</code>版本，并显式地重写了另一个版本:<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Base::overload;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">overload</span><span class="params">()</span> override</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="基类方法具有默认参数"><a href="#基类方法具有默认参数" class="headerlink" title="基类方法具有默认参数"></a>基类方法具有默认参数</h4><p>派生类与基类可具有不同的默认参数，但使用的参数取决于声明的变量类型，而不是底层的对象。下面是一个简单的派生类示例，派生类在重写的方法中提供了不同的默认参数:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">go</span><span class="params">(<span class="keyword">int</span> i = <span class="number">2</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">go</span><span class="params">(<span class="keyword">int</span> i = <span class="number">7</span>)</span> override</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>如果调用Derived对象的<code>go()</code>，将执行Derived版本的<code>go()</code>，默认参数为7。如果调用Base对象的<code>go()</code>，将执行Base版本的<code>go()</code>，默认参数为2。然而(有些怪异)，如果使用实际指向Derived对象的Base指针或Base引用调用<code>go()</code>，将调用Derived版本的<code>go()</code>，但使用Base版本的默认参数2。</p>
<p>产生这种行为的原因是C++根据表达式的编译时类型(而非运行时类型)绑定默认参数。在C++中，默认参数不会被“继承”。如果上面的Derived类没有像父类那样提供默认参数，就用新的非0参数版本重载<code>go()</code>方法。</p>
<blockquote>
<p>当重写具有默认参数的方法时，也应该提供默认参数，这个参数的值应该与基类版本相同。建议使用符号常量作为默认值，这样可在派生类中使用同一个符号常量。</p>
</blockquote>
<h3 id="派生类中的复制构造函数和赋值运算符"><a href="#派生类中的复制构造函数和赋值运算符" class="headerlink" title="派生类中的复制构造函数和赋值运算符"></a>派生类中的复制构造函数和赋值运算符</h3><p>当定义派生类时，必须注意复制构造函数和operator=。如果派生类没有任何需要使用非默认复制构造函数或operator=的特殊数据(通常是指针)，无论基类是否有这类数据，都不需要它们。如果派生类省略了复制构造函数或operator=，派生类中指定的数据成员就使用默认的复制构造函数或operator=，基类中的数据成员使用基类的复制构造函数或operator=。</p>
<p>另外，如果在派生类中指定了复制构造函数，就需要显式地链接到父类的复制构造函数，下面的代码演示了这一内容。如果不这么做，将使用默认构造函数(不是复制构造函数!)初始化对象的父类部分。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Derived() = <span class="keyword">default</span>;</span><br><span class="line">    Derived (<span class="keyword">const</span> Derived&amp; src);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Derived::Derived(<span class="keyword">const</span> Derived&amp; src) : Base (src);</span><br></pre></td></tr></table></figure></p>
<p>与此类似，如果派生类重写了operator=， 则几乎总是需要调用父类版本的operator=。唯一的例外是因为某些奇怪的原因，在赋值时只想给对象的一部分赋值。下面的代码显示了如何在派生类中调用父类的赋值运算符。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Derived&amp; Derived: :<span class="keyword">operator</span>= (<span class="keyword">const</span> Derived&amp; rhs) &#123;</span><br><span class="line">    <span class="keyword">if</span> (&amp;rhs == <span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Base::<span class="keyword">operator</span>=(rhs); <span class="comment">// calls parent's operator=.</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果派生类不指定自己的复制构造函数或operator=，基类的功能将继续运行。否则，就需要显式引用基类版本。</p>
<h3 id="运行时类型工具"><a href="#运行时类型工具" class="headerlink" title="运行时类型工具"></a>运行时类型工具</h3><p>在C++中，有些特性提供了对象的运行时视角。这些特性通常归属于一个名为运行时类型信息(RunTime Type Information, RTTI)的特性集。RTTI的一个特性是typeid运算符，这个运算符可在运行时查询对象，从而判别对象的类型。大多数情况下，不应该使用typeid，因为最好用虚方法处理基于对象类型运行的代码。下面的代码使用了typeid，根据对象的类型输出消息:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">(<span class="keyword">const</span> Animal&amp; animal)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeid</span>(animal) == <span class="keyword">typeid</span>(Dog)) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Woof!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeid</span>(animal) == <span class="keyword">typeid</span>(Bird)) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Chirp!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一旦看到这样的代码，就应该立即考虑用虚方法重新实现该功能。</p>
<p>类至少有一个虚方法，typeid 运算符才能正常运行。如果在没有虚方法的类上使用<code>dynamic_cast()</code>，会导致编译错误。typeid 运算符也会从实参中去除引用和const限定符。</p>
<p>typeid运算符的主要价值之一在于日志记录和调试。</p>
<h3 id="非public继承"><a href="#非public继承" class="headerlink" title="非public继承"></a>非public继承</h3><p>将父类的关系声明为protected，意味着在派生类中，基类所有的public方法和数据成员都成为受保护的。与此类似，指定private继承意味着基类所有的public、protected方法和数据成员在派生类中都成为私有的。使用这种方法统一降低父类的访问级别有许多原因，但多数原因都是层次结构的设计缺陷。</p>
<h3 id="虚基类"><a href="#虚基类" class="headerlink" title="虚基类"></a>虚基类</h3><p>如果希望被共享的父类拥有自己的功能，C++提供了另一种机制来解决这个问题。如果被共享的基类是一个虚基类(virtual base class)，就不存在歧义。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/C/" rel="tag"># C++</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/05/02/cpp高级编程 笔记1/" rel="next" title="C++高级编程 第四版 笔记1">
                <i class="fa fa-chevron-left"></i> C++高级编程 第四版 笔记1
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/05/02/cpp高级编程 笔记3/" rel="prev" title="C++高级编程 第四版 笔记3">
                C++高级编程 第四版 笔记3 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/header.jpg" alt="Hao Yu">
            
              <p class="site-author-name" itemprop="name">Hao Yu</p>
              <p class="site-description motion-element" itemprop="description">Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author</p>
          </div>
          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">303</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>
        	<audio controls="controls" loop="loop" preload="auto" src="/resource/xiaomeihao.mp3">
	        </audio>
	

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yuhao0102" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:yuh18@mails.tsinghua.edu.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#精通类与对象"><span class="nav-number">1.</span> <span class="nav-text">精通类与对象</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#友元"><span class="nav-number">1.1.</span> <span class="nav-text">友元</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对象的动态分配"><span class="nav-number">1.2.</span> <span class="nav-text">对象的动态分配</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用移动语义处理移动"><span class="nav-number">1.2.1.</span> <span class="nav-text">使用移动语义处理移动</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#右值引用"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">右值引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实现移动语义"><span class="nav-number">1.2.1.2.</span> <span class="nav-text">实现移动语义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#移动对象数据成员"><span class="nav-number">1.2.1.3.</span> <span class="nav-text">移动对象数据成员</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#零规则"><span class="nav-number">1.2.2.</span> <span class="nav-text">零规则</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#与方法有关的更多内容"><span class="nav-number">1.3.</span> <span class="nav-text">与方法有关的更多内容</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#静态方法"><span class="nav-number">1.3.1.</span> <span class="nav-text">静态方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#const-方法"><span class="nav-number">1.3.2.</span> <span class="nav-text">const 方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#mutable数据成员"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">mutable数据成员</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法重载"><span class="nav-number">1.3.3.</span> <span class="nav-text">方法重载</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#基于const的重载"><span class="nav-number">1.3.3.1.</span> <span class="nav-text">基于const的重载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#显式删除重载"><span class="nav-number">1.3.3.2.</span> <span class="nav-text">显式删除重载</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内联方法"><span class="nav-number">1.3.4.</span> <span class="nav-text">内联方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#默认参数"><span class="nav-number">1.3.5.</span> <span class="nav-text">默认参数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#不同的数据成员类型"><span class="nav-number">1.4.</span> <span class="nav-text">不同的数据成员类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#静态数据成员"><span class="nav-number">1.4.1.</span> <span class="nav-text">静态数据成员</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#内联变量"><span class="nav-number">1.4.1.1.</span> <span class="nav-text">内联变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#在类方法内访问静态数据成员"><span class="nav-number">1.4.1.2.</span> <span class="nav-text">在类方法内访问静态数据成员</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#在方法外访问静态数据成员"><span class="nav-number">1.4.1.3.</span> <span class="nav-text">在方法外访问静态数据成员</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#静态常量数据成员"><span class="nav-number">1.4.2.</span> <span class="nav-text">静态常量数据成员</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#引用数据成员"><span class="nav-number">1.4.3.</span> <span class="nav-text">引用数据成员</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常量引用数据成员"><span class="nav-number">1.4.4.</span> <span class="nav-text">常量引用数据成员</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#嵌套类"><span class="nav-number">1.5.</span> <span class="nav-text">嵌套类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类内的枚举类型"><span class="nav-number">1.6.</span> <span class="nav-text">类内的枚举类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#运算符重载"><span class="nav-number">1.7.</span> <span class="nav-text">运算符重载</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#隐式转换"><span class="nav-number">1.7.0.1.</span> <span class="nav-text">隐式转换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#第三次尝试：全局operator"><span class="nav-number">1.7.0.2.</span> <span class="nav-text">第三次尝试：全局operator+</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重载算术运算符"><span class="nav-number">1.7.1.</span> <span class="nav-text">重载算术运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重载比较运算符"><span class="nav-number">1.7.2.</span> <span class="nav-text">重载比较运算符</span></a></li></ol></li></ol><li class="nav-item nav-level-1"><a class="nav-link" href="#揭秘继承技术"><span class="nav-number">2.</span> <span class="nav-text">揭秘继承技术</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#使用继承构建类"><span class="nav-number">2.1.</span> <span class="nav-text">使用继承构建类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#扩展类"><span class="nav-number">2.1.1.</span> <span class="nav-text">扩展类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#客户对继承的看法"><span class="nav-number">2.1.1.1.</span> <span class="nav-text">客户对继承的看法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#从派生类的角度分析继承"><span class="nav-number">2.1.1.2.</span> <span class="nav-text">从派生类的角度分析继承</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#禁用继承"><span class="nav-number">2.1.1.3.</span> <span class="nav-text">禁用继承</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重写方法"><span class="nav-number">2.1.2.</span> <span class="nav-text">重写方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#将所有方法都设置为virtual，以防万一"><span class="nav-number">2.1.2.1.</span> <span class="nav-text">将所有方法都设置为virtual，以防万一</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#重写方法的语法"><span class="nav-number">2.1.2.2.</span> <span class="nav-text">重写方法的语法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#客户对重写方法的看法"><span class="nav-number">2.1.2.3.</span> <span class="nav-text">客户对重写方法的看法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#override关键字"><span class="nav-number">2.1.2.4.</span> <span class="nav-text">override关键字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#virtual的真相"><span class="nav-number">2.1.2.5.</span> <span class="nav-text">virtual的真相</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#禁用重写"><span class="nav-number">2.1.2.6.</span> <span class="nav-text">禁用重写</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#利用父类"><span class="nav-number">2.2.</span> <span class="nav-text">利用父类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#父类构造函数"><span class="nav-number">2.2.1.</span> <span class="nav-text">父类构造函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#父类的析构函数"><span class="nav-number">2.2.1.1.</span> <span class="nav-text">父类的析构函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用父类方法"><span class="nav-number">2.2.2.</span> <span class="nav-text">使用父类方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#向上转型和向下转型"><span class="nav-number">2.2.3.</span> <span class="nav-text">向上转型和向下转型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#继承与多态性"><span class="nav-number">2.3.</span> <span class="nav-text">继承与多态性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#回到电子表格"><span class="nav-number">2.3.1.</span> <span class="nav-text">回到电子表格</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#设计多态性的电子表格单元格"><span class="nav-number">2.3.2.</span> <span class="nav-text">设计多态性的电子表格单元格</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SpreadsheetCell基类"><span class="nav-number">2.3.3.</span> <span class="nav-text">SpreadsheetCell基类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#初次尝试"><span class="nav-number">2.3.3.1.</span> <span class="nav-text">初次尝试</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#纯虚方法和抽象基类"><span class="nav-number">2.3.3.2.</span> <span class="nav-text">纯虚方法和抽象基类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#独立的派生类"><span class="nav-number">2.3.4.</span> <span class="nav-text">独立的派生类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#StringSpreadsheetCell类定义"><span class="nav-number">2.3.4.1.</span> <span class="nav-text">StringSpreadsheetCell类定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#StringSpreadsheetCell的实现"><span class="nav-number">2.3.4.2.</span> <span class="nav-text">StringSpreadsheetCell的实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DoubleSpreadsheetCell-类的定义和实现"><span class="nav-number">2.3.4.3.</span> <span class="nav-text">DoubleSpreadsheetCell 类的定义和实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#考虑将来"><span class="nav-number">2.3.5.</span> <span class="nav-text">考虑将来</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多重继承"><span class="nav-number">2.4.</span> <span class="nav-text">多重继承</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#从多个类继承"><span class="nav-number">2.4.1.</span> <span class="nav-text">从多个类继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#名称冲突和歧义基类"><span class="nav-number">2.4.2.</span> <span class="nav-text">名称冲突和歧义基类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#名称歧义"><span class="nav-number">2.4.2.1.</span> <span class="nav-text">名称歧义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#歧义基类"><span class="nav-number">2.4.2.2.</span> <span class="nav-text">歧义基类</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#有趣而晦涩的继承问题"><span class="nav-number">2.5.</span> <span class="nav-text">有趣而晦涩的继承问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#修改重写方法的特征"><span class="nav-number">2.5.1.</span> <span class="nav-text">修改重写方法的特征</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#修改方法的返回类型"><span class="nav-number">2.5.1.1.</span> <span class="nav-text">修改方法的返回类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#修改方法的参数"><span class="nav-number">2.5.1.2.</span> <span class="nav-text">修改方法的参数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#继承的构造-函数"><span class="nav-number">2.5.2.</span> <span class="nav-text">继承的构造 函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重写方法时的特殊情况"><span class="nav-number">2.5.3.</span> <span class="nav-text">重写方法时的特殊情况</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#静态基类方法"><span class="nav-number">2.5.3.1.</span> <span class="nav-text">静态基类方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#重载基类方法"><span class="nav-number">2.5.3.2.</span> <span class="nav-text">重载基类方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#基类方法具有默认参数"><span class="nav-number">2.5.3.3.</span> <span class="nav-text">基类方法具有默认参数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#派生类中的复制构造函数和赋值运算符"><span class="nav-number">2.5.4.</span> <span class="nav-text">派生类中的复制构造函数和赋值运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#运行时类型工具"><span class="nav-number">2.5.5.</span> <span class="nav-text">运行时类型工具</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#非public继承"><span class="nav-number">2.5.6.</span> <span class="nav-text">非public继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#虚基类"><span class="nav-number">2.5.7.</span> <span class="nav-text">虚基类</span></a></li></ol></li></ol></li></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>
  <div id="DvelopmentTarget">     
  </div>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart" aria-hidden="false"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>

  
</div>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_uv"> 
  本站访客数<span id="busuanzi_value_site_uv"></span>人次
</span>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  


  <script type="text/javascript" src="/js/src/love.js"></script>

</body>
</html>
