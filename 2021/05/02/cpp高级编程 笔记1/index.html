<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zn-ch">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-center-simple.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="C++,">










<meta name="description" content="C++和标准库速成基础知识类型枚举类型只是一个整数值，如果试图对枚举类型进行算术操作，编译器会给出警告或错误信息。如果没有给出一个枚举成员的整型值，编译器会将上一个枚举成员的值递增1，再赋予当前的枚举成员。如果没有给第一个枚举成员赋值，编译器就给它赋值0。 强类型枚举上面给出的枚举并不是强类型的，这意味着其并非类型安全的。它们总被解释为整型数据，因此可以比较完全不同的枚举类型中的枚举值。强类型的e">
<meta name="keywords" content="C++">
<meta property="og:type" content="article">
<meta property="og:title" content="C++高级编程 第四版 笔记1">
<meta property="og:url" content="http://yoursite.com/2021/05/02/cpp高级编程 笔记1/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="C++和标准库速成基础知识类型枚举类型只是一个整数值，如果试图对枚举类型进行算术操作，编译器会给出警告或错误信息。如果没有给出一个枚举成员的整型值，编译器会将上一个枚举成员的值递增1，再赋予当前的枚举成员。如果没有给第一个枚举成员赋值，编译器就给它赋值0。 强类型枚举上面给出的枚举并不是强类型的，这意味着其并非类型安全的。它们总被解释为整型数据，因此可以比较完全不同的枚举类型中的枚举值。强类型的e">
<meta property="og:locale" content="zn-ch">
<meta property="og:image" content="http://yoursite.com/img/1618647122.jpg">
<meta property="og:image" content="http://yoursite.com/img/1618729866.jpg">
<meta property="og:image" content="http://yoursite.com/img/1619223966.jpg">
<meta property="og:updated_time" content="2021-05-02T14:07:40.227Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="C++高级编程 第四版 笔记1">
<meta name="twitter:description" content="C++和标准库速成基础知识类型枚举类型只是一个整数值，如果试图对枚举类型进行算术操作，编译器会给出警告或错误信息。如果没有给出一个枚举成员的整型值，编译器会将上一个枚举成员的值递增1，再赋予当前的枚举成员。如果没有给第一个枚举成员赋值，编译器就给它赋值0。 强类型枚举上面给出的枚举并不是强类型的，这意味着其并非类型安全的。它们总被解释为整型数据，因此可以比较完全不同的枚举类型中的枚举值。强类型的e">
<meta name="twitter:image" content="http://yoursite.com/img/1618647122.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2021/05/02/cpp高级编程 笔记1/">





  <title>C++高级编程 第四版 笔记1 | Hao Yu's blog</title>
  








 
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zn-ch">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hao Yu's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">The program monkey was eaten by the siege lion.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/resume.pdf" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-mybetterhalf">
          <a href="/mybetterhalf/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>
            
            mybetterhalf
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/05/02/cpp高级编程 笔记1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">C++高级编程 第四版 笔记1</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-05-02T22:07:40+08:00">
                2021-05-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="C-和标准库速成"><a href="#C-和标准库速成" class="headerlink" title="C++和标准库速成"></a>C++和标准库速成</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p>枚举类型只是一个整数值，如果试图对枚举类型进行算术操作，编译器会给出警告或错误信息。如果没有给出一个枚举成员的整型值，编译器会将上一个枚举成员的值递增1，再赋予当前的枚举成员。如果没有给第一个枚举成员赋值，编译器就给它赋值0。</p>
<h4 id="强类型枚举"><a href="#强类型枚举" class="headerlink" title="强类型枚举"></a>强类型枚举</h4><p>上面给出的枚举并不是强类型的，这意味着其并非类型安全的。它们总被解释为整型数据，因此可以比较完全不同的枚举类型中的枚举值。强类型的<code>enum class</code>枚举解决了这些问题，例如，下面定义前述PieceType枚举的类型安全版本:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">PieceType</span> </span></span><br><span class="line"><span class="class">    <span class="title">King</span> = 1,</span></span><br><span class="line"><span class="class">    <span class="title">Queen</span>,</span></span><br><span class="line"><span class="class">    <span class="title">Rook</span> = 10,</span></span><br><span class="line"><span class="class">    <span class="title">Pawn</span></span></span><br><span class="line"><span class="class">&#125;;</span></span><br></pre></td></tr></table></figure></p>
<p>对于enumclass，枚举值名不会自动超出封闭的作用域，这表示总要使用作用域解析操作符:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PieceType piece = PieceType::King;</span><br></pre></td></tr></table></figure></p>
<p>这也意味着给枚举值指定了更简短的名称，例如，用King替代PieceTypeKing。另外，枚举值不会自动转换为整数。因此，下面的代码是不合法的:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (PieceType: :Queen == <span class="number">2</span>) &#123;...&#125;</span><br></pre></td></tr></table></figure></p>
<p>默认情况下，枚举值的基本类型是整型，但可采用以下方式加以改变:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Class PieceType : <span class="keyword">unsigned</span> <span class="keyword">long</span></span><br><span class="line">    King = <span class="number">1</span>,</span><br><span class="line">    Queen,</span><br><span class="line">    Rook = <span class="number">10</span>,</span><br><span class="line">    Pawn</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="if-else"><a href="#if-else" class="headerlink" title="if/else"></a>if/else</h3><p>C++17允许在if中包含一个初始化器：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (&lt;initializer&gt;; &lt;conditional_expression&gt;) &#123;&lt;body&gt;&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><p>一旦找到与switch条件匹配的case表达式，就执行其后的所有语句，直至遇到break语句为止。即使遇到另一个case表达式，执行也会继续，这称为fallthrough。下例有一组语句，会为不同的case执行:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (backgroundColor) &#123;</span><br><span class="line">    <span class="keyword">case</span> Color::DarkBlue:</span><br><span class="line">    <span class="keyword">case</span> Color::Black:</span><br><span class="line">    <span class="comment">// Code to execute for both a dark blue or black background color </span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> Color::Red:</span><br><span class="line">        <span class="comment">// Code to execute for a red background color</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果你无意间忘掉了break语句，fllthrough 将成为bug的来源。因此，如果在switch语句中检测到fallthrough，编译器将生成警告信息，除非像上例那样case 为空。从C++17开始，你可以使用allthrough]特性，告诉编译器某个fallthrough 是有意为之，如下所示:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (backgroundColor) &#123;</span><br><span class="line">    <span class="keyword">case</span> Color::DarkBlue:</span><br><span class="line">        doSomethingForDarkBlue () ;</span><br><span class="line">        [[fallthrough]] ;</span><br><span class="line">    <span class="keyword">case</span> Color::Black:</span><br><span class="line">        <span class="comment">// Code is executed for both a dark blue or black background color</span></span><br><span class="line">        <span class="function">doSome <span class="title">thingForBlackOrDarkBlue</span><span class="params">()</span> </span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> Color::Red:</span><br><span class="line">    <span class="keyword">case</span> Color::Green:</span><br><span class="line">        <span class="comment">// Code to execute for a red or green background color</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="逻辑符"><a href="#逻辑符" class="headerlink" title="逻辑符"></a>逻辑符</h3><p>C++对表达式求值时会采用短路逻辑。这意味着一旦最终结果可确定，就不对表达式的剩余部分求值。例如，当执行如下所示的多个布尔表达式的逻辑或操作时，如果发现其中一个表达式的值为true，立刻可判定其结果为true，就不再检测剩余部分。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> result = bool1 || bool2 || (i &gt; <span class="number">7</span>) || (<span class="number">27</span> / <span class="number">13</span> % i + <span class="number">1</span>)&lt;<span class="number">2</span>;</span><br></pre></td></tr></table></figure></p>
<p>在此例中，如果bool1的值是true，整个表达式的值必然为true，因此不会对其他部分求值。这种方法可阻止代码执行多余操作。然而，如果后面的表达式以某种方式影响程序的状态，就会带来难以发现的bug。</p>
<p>短路做法对性能有好处。在使用逻辑短路时，可将代价更低的测试放在前面，以避免执行代价更高的测试。在指针上下文中，它也可避免指针无效时执行表达式的一部分的情况。本章后面将讨论指针以及包含短路的指针。</p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="函数返回类型的推断"><a href="#函数返回类型的推断" class="headerlink" title="函数返回类型的推断"></a>函数返回类型的推断</h4><p>C++14允许要求编译器自动推断出函数的返回类型。要使用这个功能，需要把auto指定为返回类型：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">addNumbers</span> <span class="params">(<span class="keyword">int</span> number1, <span class="keyword">int</span> number2)</span></span></span><br><span class="line">    return number1 + number2;</span><br></pre></td></tr></table></figure></p>
<p>编译器根据return语句使用的表达式推断返回类型。函数中可有多个return语句，但它们应解析为相同的类型。这种函数甚至可包含递归调用(调用自身)，但函数中的第一个return语句必须是非递归调用。</p>
<h4 id="当前函数的名称"><a href="#当前函数的名称" class="headerlink" title="当前函数的名称"></a>当前函数的名称</h4><p>每个函数都有一个预定义的局部变量<code>__func__</code>， 其中包含当前函数的名称。这个变量的一个用途是用于日志记录：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">addNumbers</span><span class="params">(<span class="keyword">int</span> number1, <span class="keyword">int</span> number2)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Entering function "</span> &lt;&lt; func &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> numberl + number2 ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="std-array"><a href="#std-array" class="headerlink" title="std::array"></a>std::array</h3><p>上一节讨论的数组来自C,仍能在C++中使用。但C++有一种大小固定的特殊容器<code>std:array</code>，这种容器在<code>&lt;array&gt;</code>头文件中定义。它基本上是对C风格的数组进行了简单包装。用<code>std:array</code>替代C风格的数组会带来很多好处。它总是知道自身大小，不会自动转换为指针，从而避免了某些类型的bug；具有迭代器，可方便地遍历元素。</p>
<p>下例演示了array 容器的用法，必须在尖括号中指定两个参数。第一个参数表示数组中元素的类型，第二个参数表示数组的大小。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">array</span>&lt;<span class="keyword">int</span>, 3&gt; arr = &#123;<span class="number">9</span>，<span class="number">8</span>，<span class="number">7</span>&#125;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Array size = "</span> &lt;&lt; arr.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"2nd element = "</span> &lt;&lt; arr[<span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span> ;</span><br></pre></td></tr></table></figure></p>
<p>C风格的数组和<code>std:array</code>都具有固定的大小，在编译时必须知道这一点。在运行时数组不会增大或缩小。</p>
<h3 id="std-vector"><a href="#std-vector" class="headerlink" title="std::vector"></a>std::vector</h3><p>标准库提供了多个不同的非固定大小容器，可用于存储信息。<code>std:vector</code>就是此类容器的一个示例，它在<code>&lt;vector&gt;</code>中声明，用一种更灵活和安全的机制取代C中数组的概念。用户不需要担心内存的管理，因为vector将自动分配足够的内存来存放其元素。vector 是动态的，意味着可在运行时添加和删除元素。下面的示例演示了vector的基本功能。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a vector of integers</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myVector = &#123; <span class="number">11</span>, <span class="number">22</span> &#125;;</span><br><span class="line"><span class="comment">// Add some more integers to the vector using push_ back()</span></span><br><span class="line">myVector.push_back(<span class="number">33</span>);</span><br><span class="line">myVector.push_back(<span class="number">44</span>);</span><br></pre></td></tr></table></figure></p>
<h2 id="深入研究C"><a href="#深入研究C" class="headerlink" title="深入研究C++"></a>深入研究C++</h2><h3 id="C-中的字符串"><a href="#C-中的字符串" class="headerlink" title="C++中的字符串"></a>C++中的字符串</h3><p>在C++中使用字符串有三种方法。一种是C风格，将字符串看成字符数组；一种是C++风格，将字符串封装到一种易于使用的string类型中；还有一种是非标准的普通类。</p>
<p>与I/0流一样，string类型位于std名称空间中。下面的示例说明了string 如何像字符数组那样使用:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> myString = <span class="string">"He1lo, world"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"The value of myString is"</span> &lt;&lt; myString &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"The second letter is "</span> &lt;&lt; myString[<span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="指针和动态内存"><a href="#指针和动态内存" class="headerlink" title="指针和动态内存"></a>指针和动态内存</h3><p>动态内存允许所创建的程序具有在编译时大小可变的数据,大多数复杂程序都会以某种方式使用动态内存。</p>
<h4 id="堆栈和堆"><a href="#堆栈和堆" class="headerlink" title="堆栈和堆"></a>堆栈和堆</h4><p>C++程序中的内存分为两个部分——堆栈和堆。当前函数中声明的所有变量将占用顶部堆栈帧的内存。如果当前函数调用了另一个函数<code>bar()</code>，<code>bar()</code>就会拥有自己的堆栈帧供其运行。任何从<code>foo()</code>传递给<code>bar()</code>的参数都会从<code>foo()</code>堆栈帧复制到<code>bar()</code>堆栈帧。</p>
<p>堆栈帧很好，因为它为每个函数提供了独立的内存空间。如果在<code>foo()</code>堆栈帧中声明了一个变量，那么除非专门要求，否则调用<code>bar()</code>函数不会更改该变量。此外，<code>foo()</code>函数执行完毕时，堆栈帧就会消失，该函数中声明的所有变量都不会再占用内存。在堆栈上分配内存的变量不需要由程序员释放内存，这个过程是自动完成的。</p>
<p>堆是与当前函数或堆栈帧完全没有关系的内存区域。如果想在函数调用结束之后仍然保存其中声明的变量，可以将变量放到堆中。程序可在任何时候向堆中添加新位或修改堆中已有的位。必须确保释放在堆上分配的任何内存，这个过程不会自动完成。</p>
<h4 id="动态分配的数组"><a href="#动态分配的数组" class="headerlink" title="动态分配的数组"></a>动态分配的数组</h4><p>堆也可以用于动态分配数组。使用<code>new[]</code>操作符可给数组分配内存：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arraySize = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">int</span>* myVariableSizedArray = <span class="keyword">new</span> <span class="keyword">int</span>[arraySize] ;</span><br></pre></td></tr></table></figure></p>
<p>这条语句分配的内存用于存储8个整数，内存的大小与arraySize变量对应。图1-3显示了执行这条语句后堆栈和堆的情况。可以看到，指针变量仍在堆栈中，但动态创建的数组在堆中。</p>
<p><img src="/img/1618647122.jpg" alt></p>
<p>现在已经分配了内存，可将myVariableSizedArray当作基于堆栈的普通数组使用</p>
<p>在C++中，每次调用new时，都必须相应地调用delete；每次调用<code>new[]</code>时，都必须相应地调用<code>delete[]</code>，以避免内存泄漏。如果未调用<code>delete</code>或<code>delete[]</code>，或调用不匹配，会导致内存泄漏。</p>
<h4 id="空指针常量"><a href="#空指针常量" class="headerlink" title="空指针常量"></a>空指针常量</h4><p>在C++11之前，常量NULL用于表示空指针。将NULL定义为常量0会导致一些问题。分析下面的例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">char</span>* str)</span> </span>&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"char* version"</span> &lt;&lt; end1; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"int version"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    func (<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>main()</code>函数通过参数NULL调用<code>func()</code>, NULL是一个空指针常量。换言之，该例要用空指针作为实参，调用<code>func()</code>的<code>char*</code>版本。但是，NULL不是指针，而等价于整数0，所以实际调用的是<code>func()</code>的整数版本。</p>
<p>可引入真正的空指针常量nullptr解决这个问题。</p>
<h2 id="统一初始化"><a href="#统一初始化" class="headerlink" title="统一初始化"></a>统一初始化</h2><p>C++11之前，Struct变量和Class变量的初始化是不同的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CircleStruct myCircle1 = &#123;<span class="number">10</span>, <span class="number">10</span>, <span class="number">2.5</span>&#125;;</span><br><span class="line"><span class="function">CircleClass <span class="title">myCircle2</span><span class="params">(<span class="number">10</span>, <span class="number">10</span>, <span class="number">2.5</span>)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>对于结构版本，可使用{…}语法。然而，对于类版本，需要使用函数符号(..)调用构造函数。自C++11以后，允许使用{…}语法初始化类型，如下所示:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CircleStruct myCircle3 = &#123;<span class="number">10</span>， <span class="number">10</span>， <span class="number">2.5</span>&#125;;</span><br><span class="line">CircleClass myCircle4 = &#123;<span class="number">10</span>，<span class="number">10</span>， <span class="number">2.5</span>&#125;;</span><br></pre></td></tr></table></figure></p>
<p>定义myCircle4时将自动调用CircleClass的构造函数。甚至等号也是可选的，因此下面的代码与前面的代码等价:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CircleStruct myCircle5&#123;<span class="number">10</span>， <span class="number">10</span>， <span class="number">2.5</span>&#125;;</span><br><span class="line">CircleClass myCircle6&#123;<span class="number">10</span>，<span class="number">10</span>, <span class="number">2.5</span>&#125;;</span><br></pre></td></tr></table></figure></p>
<p>统一初始化并不局限于结构和类，它还可用于初始化C++中的任何内容。例如，下面的代码把所有4个变量都初始化为3：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">b</span><span class="params">(<span class="number">3</span>)</span> </span>;</span><br><span class="line"><span class="keyword">int</span> c = &#123;<span class="number">3</span>&#125;; <span class="comment">// Uniform initial ization</span></span><br><span class="line"><span class="keyword">int</span> d&#123;<span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure></p>
<p>统一初始化还可用于将变量初始化为0；使用默认构造函数构造对象，将基本整数类型（如char和int等）初始化为0，将浮点类型初始化为0.0，将指针类型初始化为nullptr。例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> e&#123;&#125;;</span><br><span class="line"><span class="comment">// Uniform initialization, e will be 0</span></span><br></pre></td></tr></table></figure></p>
<p>使用统一初始化还可以阻止窄化。C++隐式地执行窄化，例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; <span class="comment">/*... */</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">3.14</span>;</span><br><span class="line">    func(<span class="number">3.14</span>) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这两种情况下，C++在对x赋值或调用func()之前，会自动将3.14截断为3。注意有些编译器会针对窄化给出警告信息，而另一些编译器则不会。使用统一初始化，如果编译器完全支持C++11标准，x的赋值和func()的调用都会生成编译错误:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = &#123;<span class="number">3.14</span>&#125;;</span><br><span class="line">    <span class="comment">// Error because narrowing</span></span><br><span class="line">    func(&#123;<span class="number">3.14</span>&#125;);</span><br><span class="line">    <span class="comment">// Error because narrowing</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>统一初始化还可用来初始化动态分配的数组：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* pArray = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>]&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>，<span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure></p>
<p>统一初始化还可在构造函数初始化器中初始化类成员数组：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        MyClass() : mArray&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; ()</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> mArray[<span class="number">4</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="直接列表初始化与复制列表初始化"><a href="#直接列表初始化与复制列表初始化" class="headerlink" title="直接列表初始化与复制列表初始化"></a>直接列表初始化与复制列表初始化</h3><p>有两种初始化类型使用包含在大括号中的初始化列表：</p>
<ul>
<li>复制列表初始化：<code>T obj = {argl, arg2, ...};</code></li>
<li>直接列表初始化：<code>T obj {argl, arg2, ...};</code></li>
</ul>
<p>在C++17中，与auto类型推断相结合，直接列表初始化与复制列表初始化存在重要区别。从C++17开始，可得到以下结果：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copy list initialization</span></span><br><span class="line"><span class="keyword">auto</span> a = &#123;<span class="number">11</span>&#125;;     <span class="comment">// initializer_list&lt;int&gt;</span></span><br><span class="line"><span class="keyword">auto</span> b = &#123;<span class="number">11</span>, <span class="number">22</span>&#125;; <span class="comment">// initializer_list&lt;int&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Direct list initialization</span></span><br><span class="line"><span class="keyword">auto</span> c &#123;<span class="number">11</span>&#125;;       <span class="comment">// int</span></span><br><span class="line"><span class="keyword">auto</span> d &#123;<span class="number">11</span>, <span class="number">22</span>&#125;;   <span class="comment">// Error, too many elements.</span></span><br></pre></td></tr></table></figure></p>
<p>注意，对于复制列表初始化，放在大括号中的初始化器的所有元素都必须使用相同的类型。例如，以下代码无法编译：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> b = &#123;<span class="number">11</span>, <span class="number">22.33</span>&#125;; <span class="comment">// Compilation error</span></span><br></pre></td></tr></table></figure></p>
<p>在早期标准版本(C++11/14)中，复制列表初始化和直接列表初始化会推导出<code>initializer_ list&lt;&gt;</code>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copy list initialization</span></span><br><span class="line"><span class="keyword">auto</span> a = &#123;<span class="number">11</span>&#125;;     <span class="comment">// initializer_list&lt;int&gt;</span></span><br><span class="line"><span class="keyword">auto</span> b = &#123;<span class="number">11</span>, <span class="number">22</span>&#125;; <span class="comment">// initializer_list&lt;int&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Direct list initialization</span></span><br><span class="line"><span class="keyword">auto</span> c &#123;<span class="number">11</span>&#125;;       <span class="comment">// initializer_list&lt;int&gt;</span></span><br><span class="line"><span class="keyword">auto</span> d &#123;<span class="number">11</span>, <span class="number">22</span>&#125;;  <span class="comment">// initializer_list&lt;int&gt;</span></span><br></pre></td></tr></table></figure></p>
<h1 id="使用string和string-view"><a href="#使用string和string-view" class="headerlink" title="使用string和string_view"></a>使用string和string_view</h1><h2 id="动态字符串"><a href="#动态字符串" class="headerlink" title="动态字符串"></a>动态字符串</h2><p>C语言中并没有真正好用的string数据类型，只有固定的字节数组。“字符串库”只不过是一组非常原始的函数，甚至没有边界检查的功能。C++提供了string 类型作为数据类型。</p>
<h3 id="C风格的字符串"><a href="#C风格的字符串" class="headerlink" title="C风格的字符串"></a>C风格的字符串</h3><p>在C语言中，字符串表示为字符的数组。字符串中的最后-一个字符是null字符(‘\0’)，目前，程序员使用C字符串时最常犯的错误是忘记为’\0’字符分配空间。</p>
<p>C++包含一些来自C语言的字符串操作函数，它们在<code>&lt;string&gt;</code>头文件中定义。为字符串分配内存的正确方式是在实际字符所需的空间加1。所以在使用C风格的字符串时要记住这一点。正确的实现代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">copyString</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* result = <span class="keyword">new</span> <span class="keyword">char</span> [<span class="built_in">strlen</span>(str) + <span class="number">1</span>] ;</span><br><span class="line">    <span class="built_in">strcpy</span>(result, str);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>C和C++中的<code>sizeof()</code>操作符可用于获得给定数据类型或变量的大小。例如，<code>sizeof(char)</code>返回1，因为字符的大小是1字节。但在C风格的字符串中，<code>sizeof()</code>和<code>strlen()</code>是不同的。绝对不要通过<code>sizeof()</code>获得字符串的大小。它根据C风格的字符串的存储方式来返回不同大小。如果C风格的字符串存储为<code>char[]</code>，则<code>sizeof()</code>返回字符串使用的实际内存，包括’\0’字符。例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> text1[] = <span class="string">"abcdef"</span>;</span><br><span class="line"><span class="keyword">size_t</span> s1 = <span class="keyword">sizeof</span>(text1); <span class="comment">// is 7</span></span><br><span class="line"><span class="keyword">size_t</span> s2 = <span class="built_in">strlen</span>(text1); <span class="comment">// is 6</span></span><br></pre></td></tr></table></figure></p>
<p>但是，如果C风格的字符串存储为<code>char*</code>，<code>sizeof()</code>就返回指针的大小。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* text2 = <span class="string">"abcdef"</span>;</span><br><span class="line"><span class="keyword">size_t</span> s3 = <span class="keyword">sizeof</span>(text2); <span class="comment">// is platform-dependent</span></span><br><span class="line"><span class="keyword">size_t</span> s4 = <span class="built_in">strlen</span>(text2); <span class="comment">// is 6</span></span><br></pre></td></tr></table></figure></p>
<p>在32位模式下编译时，s3的值为4；而在64位模式下编译时，s3的值为8，因为这返回的是指针<code>const char*</code>的大小。</p>
<h3 id="字符串字面量"><a href="#字符串字面量" class="headerlink" title="字符串字面量"></a>字符串字面量</h3><p>与字符串字面量关联的真正内存位于内存的只读部分。通过这种方式，编译器可重用等价字符串字面量的引用，从而优化内存的使用。也就是说，即使一个程序使用了500次”hello”字符串字面量，编译器也只在内存中创建一个 hello 实例。这种技术称为字面量池（literal pooling）。</p>
<p>字符串字面量可赋值给变量，但因为字符串字面量位于内存的只读部分，且使用了字面量池，所以这样做会产生风险。C++标准正式指出：字符串字面量的类型为“n个const char 的数组”，然而为了向后兼容较老的不支持const的代码，大部分编译器不会强制程序将字符串字面量赋值给<code>const char*</code>类型的变量。这些编译器允许将字符串字面量赋值给不带有const的<code>char*</code>，而且整个程序可正常运行，除非试图修改字符串。一般情况下，试图修改字符串字面量的行为是没有定义的。可能会导致程序崩溃；可能使程序继续执行，看起来却有莫名其妙的副作用：可能不加通告地忽略修改行为；可能修改行为是有效的，这完全取决于编译器。</p>
<p>还可将字符串字面量用作字符数组(<code>char[]</code>)的初始值。这种情况下，编译器会创建一个足以放下这个字符串的数组，然后将字符串复制到这个数组。因此，编译器不会将字面量放在只读的内存中，也不会进行字面量的<br>池操作。</p>
<p>原始字符串字面量（raw string literal）是可横跨多行代码的字符串字面量，不需要转义嵌入的双引号，像\t和\n这种转义序列不按照转义序列的方式处理，而是按照普通文本的方式处理。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* str = <span class="string">R"(Hello "World"!)"</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="C-std-string类"><a href="#C-std-string类" class="headerlink" title="C++ std::string类"></a>C++ std::string类</h3><p>在C++的string 类中，<code>operator==</code>、<code>operator!=</code>和<code>operator&lt;</code>等运算符都被重载了，这些运算符可以操作真正的字符串字符。单独的字符可通过运算符<code>operator[]</code>访问。如下面的代码所示，当string操作需要扩展string时，string 类能够自动处理内存需求，因此不会再出现内存溢出的情况了：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> myString = <span class="string">"hello"</span>;</span><br><span class="line">myString += <span class="string">", there"</span>;</span><br><span class="line"><span class="built_in">string</span> myOtherString = myString;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (myString == myOtherString)</span><br><span class="line">    myOtherString[<span class="number">0</span>] = <span class="string">'H'</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; myString &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; myOtherString &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p>
<p>在这个例子中有几点需要注意。一是要注意即使字符串被分配和调整大小，也不会出现内存泄漏的情况。所有这些string对象都创建为堆栈变量。尽管string类肯定需要完成大量分配内存和调整大小的工作，但是string<br>类的析构函数会在string对象离开作用域时清理内存。另外需要注意的是，运算符以预期的方式工作。例如，=运算符复制字符串，这是最有可能预期的操作。</p>
<p>为达到兼容的目的，还可应用string类的<code>c_str()</code>方法获得一个表示C风格字符串的const字符指针。不过，一旦string执行任何内存重分配或string对象被销毁了，返回的这个const指针就失效了。应该在使用结果之前调用这个方法，以便它准确反映string当前的内容。永远不要从函数中返回在基于堆栈的string上调用<code>c_str()</code>的结果。</p>
<p>还有一个<code>data()</code>方法，在C++14及更早的版本中，始终与<code>c_str()</code>一样返回<code>const char*</code>。 从C++17开始，在非const字符上调用时，<code>data()</code>返回<code>char*</code>。</p>
<h4 id="std-string字面量"><a href="#std-string字面量" class="headerlink" title="std:string字面量"></a>std:string字面量</h4><p>源代码中的字符串字面量通常解释为<code>const char*</code>。 使用用户定义的标准字面量s可以把字符串字面量解释为<code>std:string</code>。例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> string1 = <span class="string">"Hello World"</span>;</span><br><span class="line"><span class="comment">// string1 is a const char*</span></span><br><span class="line"><span class="keyword">auto</span> string2 = <span class="string">"Hello World"</span>s;</span><br><span class="line"><span class="comment">// string2 is an std::string</span></span><br></pre></td></tr></table></figure></p>
<p>用户定义的标准字面量s需要<code>using namespace std:string_literals;</code>或<code>using namespace std;</code>。</p>
<h4 id="高级数值转换"><a href="#高级数值转换" class="headerlink" title="高级数值转换"></a>高级数值转换</h4><p>std名称空间包含很多辅助函数，以便完成数值和字符串之间的转换。下面的函数可用于将数值转换为字符串。所有这些函数都负责内存分配，它们会创建一个新的string对象并返回。</p>
<ul>
<li><code>string to_string(int val);</code></li>
<li><code>string to_string(unsigned val);</code></li>
<li><code>string to_string(long val);</code></li>
<li><code>string to_string(unsigned long val);</code></li>
<li><code>string to_string(long long val);</code></li>
<li><code>string to string(unsigned long long val);</code></li>
<li><code>string to_string(float val);</code></li>
<li><code>string to_string(double val);</code></li>
<li><code>string to_string(long double val);</code></li>
</ul>
<p>通过下面这组也在std名称空间中定义的函数将字符串转换为数值。在这些函数原型中，<code>str</code>表示要转换的字符串，<code>idx</code>是一个指针，这个指针将接收第一个未转换的字符的索引，<code>base</code>表示转换过程中使用的进制。<code>idx</code>指针可以是空指针，如果是空指针，则被忽略。如果不能执行任何转换，这些函数会抛出<code>invalid_argument</code>异常，如果转换的值超出返回类型的范围，则抛出<code>out_of_range</code>异常。</p>
<ul>
<li><code>int stoi(const string&amp; str, size_t *idx=0, int base= 10);</code></li>
<li><code>long stol(const string&amp; str, size_t *idx=0, int base=10);</code></li>
<li><code>unsigned long stoul(const string&amp; str, size_t *idx=0, int base=10);</code></li>
<li><code>long long stol(const string&amp; str, size_t *idx=0, int base=10);</code></li>
<li><code>unsigned long long stoul(const string&amp; str, size_t *idx=0, int base= 10);</code></li>
<li><code>float stof(const string&amp; str, size_t *idx=0);</code></li>
<li><code>double stod(const string&amp; str, size_t *idx=0);</code></li>
<li><code>long double stold(const string&amp; str, size_t *idx=0);</code></li>
</ul>
<h3 id="std-string-view类"><a href="#std-string-view类" class="headerlink" title="std::string_view类"></a>std::string_view类</h3><p>在C++17中，引入<code>std:string_view</code>类解决了开销和易用性的问题，<code>std:string_view</code>类是<code>std:basic_string_view</code>类模板的实例化，在<code>&lt;string_view&gt;</code>头文件中定义。<code>string_view</code>基本上就是<code>const string&amp;</code>的简单替代品，但不会产生开销。它从不复制字符串，<code>string_view</code>支持与<code>std:string</code>类似的接口。一个例外是缺少<code>c_str()</code>，但<code>data()</code>是可用的。另外，<code>string_view</code>确实添加了<code>remove_prefix(size_t)</code>和<code>remove sufix(size_t)</code>方法；前者将起始指针前移给定的偏移量来收缩字符串，后者则将结尾指针倒退给定的偏移量来收缩字符串。</p>
<p>注意，无法连接一个string和一个string_view。下面的代码将无法编译：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str = <span class="string">"Hello"</span>;</span><br><span class="line">string_view sv = <span class="string">"world"</span>;</span><br><span class="line"><span class="keyword">auto</span> result = str + sv;</span><br></pre></td></tr></table></figure></p>
<p>为进行编译，必须将最后一行替代为:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> result = str + sv.data() ;</span><br></pre></td></tr></table></figure></p>
<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h2 id="使用动态内存"><a href="#使用动态内存" class="headerlink" title="使用动态内存"></a>使用动态内存</h2><p>这个例子展示了指针既可在堆栈中，也可在堆中。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>** handle = <span class="literal">nullptr</span>;</span><br><span class="line">handle = <span class="keyword">new</span> <span class="keyword">int</span>*;</span><br><span class="line">*handle = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码首先声明一个指向整数指针的指针变量handle。然后，动态分配足够的内存来保存一个指向整数的指针，并将指向这个新内存的指针保存在handle中。接下来，将另一块足以保存整数的动态内存的指针保存在<code>*handle</code>的内存位置。一个指针保存在堆栈中(handle)，另一个指针保存在堆中(*handle)。<br><img src="/img/1618729866.jpg" alt></p>
<h3 id="分配和释放"><a href="#分配和释放" class="headerlink" title="分配和释放"></a>分配和释放</h3><p>要为变量创建空间，可使用new关键字。要释放这个空间给程序中的其他部分使用，可使用delete关键字。</p>
<h4 id="使用new和delete"><a href="#使用new和delete" class="headerlink" title="使用new和delete"></a>使用new和delete</h4><p>要分配一块内存，可调用new，并提供需要空间的变量的类型。new 返回指向那个内存的指针，但程序员应将这个指针保存在变量中。如果忽略了new的返回值，或这个指针变量离开了作用域，那么这块内存就被孤立了，因为无法再访问这块内存。这也称为<strong>内存泄漏</strong>。</p>
<p>除非计算机能提供无限制的高速内存，否则就需要告诉编译器，对象关联的内存什么时候可以释放，用作他用。为释放堆中的内存，只需要使用delete关键字，并提供指向那块内存的指针，如下所示:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* ptr = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line"><span class="keyword">delete</span> ptr</span><br><span class="line">ptr = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure></p>
<p>建议在释放指针的内存后，将指针重新设置为nullptr. 这样就不会在无意中使用一个指向已释放内存的指针。</p>
<p>在C++中不应该使用<code>malloc()</code>和<code>free()</code>函数。只使用new和delete运算符。<code>malloc()</code>和<code>free()</code>函数不会调用构造函数和析构函数。</p>
<p>在C++中有一个继承自C语言的函数realloc()。不要使用它！在C中，<code>reallo()</code>用 于改变数组的大小，采取的方法是分配新大小的新内存块，然后将所有旧数据复制到新位置，再删除旧内存块。在C++中这种做法是极其危险的，因为用户定义的对象不能很好地适应按位复制。</p>
<h4 id="当内存分配失败时"><a href="#当内存分配失败时" class="headerlink" title="当内存分配失败时"></a>当内存分配失败时</h4><p>默认情况下，如果new失败了，程序会终止。当new因为没有足以满足请求的内存而抛出异常失败时，程序退出。也有不抛出异常的new版本。相反，它会返回nullptr,这类似于C语言中malloc()的行为。使用这个版本的语法如下所示:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* ptr = <span class="keyword">new</span> (nothrow) <span class="keyword">int</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="对象的数组"><a href="#对象的数组" class="headerlink" title="对象的数组"></a>对象的数组</h4><p>对象的数组和简单类型的数组没有区别。通过<code>new[N]</code>分配N个对象的数组时，实际上分配了N个连续的内存块，每一块足以容纳单个对象。使用<code>new[]</code>时，每个对象的无参构造函数<code>=default</code>会自动调用。这样，通过<code>new[]</code>分配对象数组时，会返回一个指向数组的指针，这个数组中的所有对象都被初始化了。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Simple</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Simple() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Simple constructor called!"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">        ~Simple() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Simple destructor called!"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>如果要分配包含4个Simple对象的数组，那么Simple构造函数会被调用4次。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Simple* mySimpleArray = <span class="keyword">new</span> Simple[<span class="number">4</span>];</span><br></pre></td></tr></table></figure></p>
<h4 id="删除数组"><a href="#删除数组" class="headerlink" title="删除数组"></a>删除数组</h4><p>如前所述，通过数组版本的new(<code>new[]</code>)分配内存时，必须通过数组版本的delete(<code>delete[]</code>)释放相应的内存。这个版本的delete会自动析构数组中的对象，并释放这些对象的内存。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Simple* mySimpleArray = <span class="keyword">new</span> Simple[<span class="number">4</span>];</span><br><span class="line"><span class="comment">// Use mySimpleArray</span></span><br><span class="line"><span class="keyword">delete</span> [] mySimpleArray;</span><br><span class="line">mySimpleArray = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure></p>
<p>如果不使用数组版本的delete， 程序就可能出现异常行为。在一些编译器中，可能只会调用数组中第1个元素的析构函数，因为编译器只知道要删除指向一个对象的指针，而数组中的其他所有元素都变成了孤立对象。在其他编译器中，可能出现内存崩溃的情况，因为<code>new</code>和<code>new[]</code>可能采用完全不同的内存分配方案。</p>
<h2 id="数组-指针的对偶性"><a href="#数组-指针的对偶性" class="headerlink" title="数组-指针的对偶性"></a>数组-指针的对偶性</h2><p>在堆上分配的数组通过指向该数组中第一个元素的指针来引用。基于堆栈的数组通过数组语法([])和普通的变量声明来引用。</p>
<h3 id="数组就是指针"><a href="#数组就是指针" class="headerlink" title="数组就是指针"></a>数组就是指针</h3><p>通过指针不仅能指向基于堆的数组，也可以通过指针语法来访问基于堆栈的数组的元素。数组的地址就是第1个元素(索引0)的地址。编译器知道，通过变量名引用整个数组时，实际上引用的是第1个元素的地址。从这个角度看，指针用起来就像基于堆的数组。下面的代码创建了一个堆栈上的数组，数组元素初始化为0，但通过一个指针来访问这个数组：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> myIntArray[<span class="number">10</span>] = &#123;&#125;;</span><br><span class="line"><span class="keyword">int</span>* myIntPtr = myIntArray;</span><br><span class="line"></span><br><span class="line">myIntPtr[<span class="number">4</span>] = <span class="number">5</span>;</span><br></pre></td></tr></table></figure></p>
<p>向函数传递数组时，通过指针引用基于堆栈的数组的能力非常有用。下面的函数以指针的方式接收一个整数数组。请注意，调用者需要显式地传入数组的大小，因为<strong>指针没有包含任何与大小有关的信息</strong>。事实上，任何形式的C++数组，不论是不是指针，都没有内含大小信息。这是应使用现代容器(例如标准库提供的容器)的另一个原因。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doubleInts</span> <span class="params">(<span class="keyword">int</span>* theArray, size_ <span class="keyword">_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span>; i &lt; size; i++)&#123;</span><br><span class="line">        theArray[i] *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个函数的调用者可以传入基于堆栈或堆的数组。在传入基于堆的数组时，指针已经存在了，且按值传入函数。在传入基于堆栈的数组时，调用者可以传入一个数组变量，编译器会自动把这个数组变量当作指向数组的指针处理，还可以显式地传入第一个元素的地址。这里展示了所有三种形式:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> arrsize = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">int</span>* heapArray = <span class="keyword">new</span> <span class="keyword">int</span>[arrSize]&#123; <span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span> &#125;;</span><br><span class="line">doubleInts(heapArray, arrSize) ;</span><br><span class="line"><span class="keyword">delete</span> [] heapArray;</span><br><span class="line">heapArray = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> stackArray[] = &#123; <span class="number">5</span>, <span class="number">7</span>，<span class="number">9</span>, <span class="number">11</span> &#125;;</span><br><span class="line">arrSize = <span class="built_in">std</span>::size(stackArray);</span><br><span class="line">doubleInts(stackArray, arrSize) ;</span><br><span class="line">doubleInts(&amp;stackArray[<span class="number">0</span>]，arrSize) ;</span><br></pre></td></tr></table></figure></p>
<p>数组参数传递的语义和指针参数传递的语义十分相似，因为当把数组传递给函数时，编译器将数组视为指针。函数如果接收数组作为参数，并修改数组中元素的值，实际上修改的是原始数组而不是副本。与指针一样，传递数组实际上模仿的是按引用传递的功能，因为真正传入函数的是原始数组的地址而不是副本。</p>
<p>为什么在函数定义中使用数组语法时编译器不复制数组?这样做是为了提高效率——复制数组中的元素需要时间，而且数组可能占用大量的内存。总是传递指针，编译器就不需要包括复制数组的代码。</p>
<p>可“按引用”给函数传递长度已知的基于堆栈的数组，但其语法并不明显。它不适用于基于堆的数组。例如，下面的doubleIntsStack0仅接收大小为4的基于堆栈的数组:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doubleIntsStack</span><span class="params">(<span class="keyword">int</span> (&amp;theArray) [<span class="number">4</span>])</span></span>;</span><br></pre></td></tr></table></figure></p>
<h2 id="低级内存操作"><a href="#低级内存操作" class="headerlink" title="低级内存操作"></a>低级内存操作</h2><p>如果代码使用了对象，只需要确保每个类都妥善管理自己的内存。通过构造和析构，编译器可提示什么时候管理内存。将内存管理隐藏在类中可以极大地改变可用性。</p>
<h3 id="指针运算"><a href="#指针运算" class="headerlink" title="指针运算"></a>指针运算</h3><p>C++编译器通过声明的指针类型允许执行指针运算。如果声明一个指向int的指针，然后将这个指针递增1，那么这个指针在内存中向前移动1个int 的大小，而不是1个字节。此类操作对数组最有用，因为数组在内存中包含同构的数据序列。例如，假设在堆中声明一个整数数组：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* myArray = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">8</span>];</span><br></pre></td></tr></table></figure></p>
<p>下面的语法给该数组中位置2的元素设置值：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myArray[<span class="number">2</span>] = <span class="number">33</span>;</span><br></pre></td></tr></table></figure></p>
<p>使用指针运算可等价地使用下面的语法，这个语法获得myArray数组中“向前2个int”位置的内存地址，然后解除引用来设置值:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*(myArray + <span class="number">2</span>) = <span class="number">33</span>;</span><br></pre></td></tr></table></figure></p>
<p>作为访问单个元素的替代语法，指针运算似乎没有太大吸引力。其真正的作用在于以下事实：像<code>myArray+2</code>这样的表达式仍是一个指向int的指针，因而可以表示一个更小的整数数组。</p>
<h3 id="自定义内存管理"><a href="#自定义内存管理" class="headerlink" title="自定义内存管理"></a>自定义内存管理</h3><p>在99%的情况下，C++中内置的内存分配设施是足够使用的。new和delete在后台完成了所有相关工作：分配正确大小的内存块、管理可用的内存区域列表以及释放内存时将内存块释放回可用内存列表。</p>
<p>自行管理内存可能减少开销。当使用new分配内存时，程序还需要预留少量的空间来记录分配了多少内存。这样，当调用delete时，可以释放正确数量的内存。对于大多数对象，这个开销比实际分配的内存小得多，所以差别不大。然而，对于很小的对象或分配了大量对象的程序来说，这个开销的影响可能会很大。</p>
<p>当自行管理内存时，可事先了解每个对象的大小，因此可避免每个对象的开销。</p>
<h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><p>内存清理的另一个方面是垃圾回收。在支持垃圾回收的环境中，程序员几乎不必显式地释放与对象关联的内存。运行时库会在某时刻自动清理没有任何引用的对象。在现代C++中，使用智能指针管理内存，在旧代码中，则在对象层次通过new和delete管理内存。</p>
<p>标记(mark)和清扫(sweep)是一种垃圾回收的方法。使用这种方法的垃圾回收器定期检查程序中的每个指针，并将指针引用的内存标记为仍在使用。在每一轮周期结束时，未标记的内存视为没有在使用，因而被释放。</p>
<p>如果愿意执行以下操作，那么可以在C++中实现标记和清扫算法:</p>
<ol>
<li>在垃圾回收器中注册所有指针，这样垃圾回收器可轻松遍历所有指针。</li>
<li>让所有对象都从一个混入类中派生，这个混入类可能是GartbageCollectible，允许垃圾回收器将对象标记为正在使用中。</li>
<li>确保在垃圾回收器运行时不能修改指针，从而保护对象的并发访问。</li>
</ol>
<p>垃圾回收存在以下缺点:</p>
<ul>
<li>当垃圾回收器正在运行时，程序可能停止响应。</li>
<li>使用垃圾回收器时，析构函数具有不确定性。由于对象在被垃圾回收之前不会销毁，因此对象离开作用域时不会立即执行析构函数。这意味着，由析构函数完成的资源清理操作要在将来某个不确定的时刻进行。</li>
</ul>
<h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><p>智能指针可帮助管理动态分配的内存，这是避免内存泄漏建议采用的技术。这样，智能指针可保存动态分配的资源，如内存。当堆栈变量离开作用域或被重置时，会自动释放所占用的资源。智能指针可用于管理在函数作用域内(或作为类的数据成员)动态分配的资源。也可通过函数实参来传递动态分配的资源的所有权。</p>
<p>C++提供的一些语言特性使智能指针具有吸引力。首先，可通过模板为任何指针类型编写类型安全的智能指针类。其次，可使用运算符重载为智能指针对象提供一个接口，使智能指针对象的使用和普通指针一样。确切地讲，可重载<code>*</code>和<code>-&gt;</code>运算符，使客户代码解除对智能指针对象的引用的方式和解除对普通指针的引用相同。</p>
<p>智能指针有多种类型。最简单的智能指针类型对资源有唯一的所有权， 当智能指针离开作用域或被重置时，会释放所引用的内存。标准库提供了<code>std::unique_ptr</code>，这是一个具有“唯一所有权” 语义的智能指针。</p>
<p>然而，指针的管理不仅是在指针离开作用域时释放它们。有时，多个对象或代码段包含同一个指针的多个副本。这个问题称为别名。为正确释放所有内存，使用这个资源的最后一个代码块应该释放该指针指向的资源，一种更成熟的智能指针类型实现了“引用计数”来跟踪指针的所有者。每次复制这个“引用计数”智能指针时，都会创建一个指向同一资源的新实例，将引用计数增加1。当这样的一个智能指针实例离开作用域或被重置时，引用计数会减1。当引用计数降为0时，则资源不再有所有者，因此智能指针释放资源。标准库提供了<code>stl:shared_ptr</code>，这是一个使用引用计数且具有“共享所有权”语义的智能指针。标准的<code>shared_ptr</code>是线程安全的，但这不意味着所指向的资源是线程安全的。</p>
<h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ _ptr"></a>unique_ _ptr</h3><p>作为经验法则，总将动态分配的对象保存在堆栈的<code>unique_ptr</code>实例中。</p>
<h4 id="创建unique-ptrs"><a href="#创建unique-ptrs" class="headerlink" title="创建unique_ptrs"></a>创建unique_ptrs</h4><p>考虑下面的函数，这个函数在堆上分配了一个Simple对象，但是不释放这个对象，故意产生内存泄漏。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">leaky</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Simple* mySimplePtr = <span class="keyword">new</span> Simple(); <span class="comment">// BUG! Memory is never released!</span></span><br><span class="line">    mySimplePtr-&gt;go() ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>实例<code>unique_ptr</code>离开作用域时(在函数的末尾，或者因为抛出了异常)，就会在其析构函数中自动释放Simple对象:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">notLeaky</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> mySimpleSmartPtr = make_unique&lt;Simple&gt;() ;</span><br><span class="line">    mySimpleSmartPtr-&gt;go();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这段代码使用C++14中的<code>make_unique()</code>和auto关键字，所以只需要指定指针的类型，本例中是Simple。如果Simple构造函数需要参数，就把它们放在<code>make_unique()</code>调用的圆括号中。</p>
<p>如果编译器不支持<code>make_unique()</code>， 可创建自己的<code>unique_ptr</code>，如下所示，注意Simple必须写两次:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unique_ptr</span>&lt;Simple&gt; mySimpleSmartPtr (<span class="keyword">new</span> Simple());</span><br></pre></td></tr></table></figure></p>
<p>在C++17之前，必须使用<code>make_unique()</code>，一是因为只能将类型指定一次， 二是出于安全考虑！考虑下面对<code>foo()</code>函数的调用：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo(<span class="built_in">unique_ptr</span>&lt;simple&gt; (<span class="keyword">new</span> Simple()), <span class="built_in">unique_ptr</span>&lt;Bar&gt;(<span class="keyword">new</span> Bar (data())));</span><br></pre></td></tr></table></figure></p>
<p>如果Simple、Bar 或data()函数的构造函数抛出异常(具体取决于编译器的优化设置)，很可能是Simple 或Bar对象出现了内存泄漏。而使用<code>make_unique()</code>，则不会发生内存泄漏：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo(make_unique&lt;Simple&gt;(), make_unique&lt;Bar&gt; (data()));</span><br></pre></td></tr></table></figure></p>
<h4 id="使用unique-ptrs"><a href="#使用unique-ptrs" class="headerlink" title="使用unique_ptrs"></a>使用unique_ptrs</h4><p>这个标准智能指针最大的一个亮点是：用户不需要学习大量的新语法，就可以获得巨大好处。与标准指针一样，也可将其写作：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(*mySimpleSmartPtr).go();</span><br></pre></td></tr></table></figure></p>
<p><code>get()</code>方法可用于直接访问底层指针。这可将指针传递给需要普通指针的函数<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> mySimpleSmartPtr = make_unique&lt;Simple&gt;() ;</span><br><span class="line">processData(mySimpleSmartPtr.get());</span><br></pre></td></tr></table></figure></p>
<p>可释放<code>unique_ptr</code>的底层指针，并使用reset()根据需要将其改成另一个指针。例如:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mySimpleSmartPtr.reset();</span><br><span class="line"><span class="comment">// Free resource and set to nullptr </span></span><br><span class="line">mySimpleSmartPtr.reset (<span class="keyword">new</span> Simple()); <span class="comment">// Free resource and set to a new</span></span><br><span class="line"><span class="comment">// Simple instance</span></span><br></pre></td></tr></table></figure></p>
<p>可使用<code>release()</code>断开<code>unique_ptr</code>与底层指针的连接。<code>release()</code>方法返回资源的底层指针，然后将智能指针设置为nullptr。实际上，智能指针失去对资源的所有权，负责在你用完资源时释放资源。例如:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Simple* simple = mySimpleSmartPtr.release(); <span class="comment">// Release ownership</span></span><br><span class="line"><span class="comment">// Use the simple pointer...</span></span><br><span class="line"><span class="keyword">delete</span> simple;</span><br><span class="line">simple = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure></p>
<p>由于<code>unique_ptr</code>代表唯一拥有权，因此无法复制它！使用<code>std:move()</code>实用工具，可使用移动语义将一个<code>unique_ptr</code>移到另一个。这用于显式移动所有权，如下所示:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Foo (unique_ ptr&lt;<span class="keyword">int</span>&gt; data) : mData (move (data)) &#123; &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; mData;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> myIntSmartPtr = make_unique&lt;<span class="keyword">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line"><span class="function">Foo <span class="title">f</span><span class="params">(move (myIntSmartPtr))</span></span>;</span><br></pre></td></tr></table></figure></p>
<h4 id="unique-ptr和C风格数组"><a href="#unique-ptr和C风格数组" class="headerlink" title="unique_ptr和C风格数组"></a>unique_ptr和C风格数组</h4><p><code>unique_ptr</code>适用于存储动态分配的旧式C风格数组。下例创建了一个<code>unique_ptr</code>来保存动态分配的、包含10个整数的C风格数组:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> myVariableSizedArray = make_unique&lt;<span class="keyword">int</span>[]&gt;(<span class="number">10</span>) ;</span><br></pre></td></tr></table></figure></p>
<p>即使可使用<code>unique_ptr</code>存储动态分配的C风格数组，也建议改用标准库容器，例如<code>std:array</code>和<code>std:vector</code>等。</p>
<h4 id="自定义deleter"><a href="#自定义deleter" class="headerlink" title="自定义deleter"></a>自定义deleter</h4><p>默认情况下，<code>unique_ ptr</code>使用标准的new和delete运算符来分配和释放内存。可将此行为改成：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">malloc_int</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* p = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    *p = value;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>, <span class="keyword">decltype</span>(<span class="built_in">free</span>)*&gt; myIntSmartPtr(malloc_int(<span class="number">42</span>)， <span class="built_in">free</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这段代码使用<code>malloc_int()</code>给整数分配内存。<code>unique_ptr</code>调用标准的free()函数来释放内存。如前所述，在C++中不应该使用malloc()，而应改用new。然而，<code>unique_ ptr</code>的这项特性是很有用的，因为还可管理其他类型的资源而不仅是内存。例如，当<code>unique_ptr</code>离开作用域时，可自动关闭文件或网络套接字以及其他任何资源。</p>
<p>但是，<code>unique_ptr</code>的自定义deleter的语法有些费解。需要将自定义deleter的类型指定为模板类型参数。在本例中，<code>dcltype(free)</code>用于返回free()类型。 模板类型参数应当是函数指针的类型，因此另外附加一个<em>，如`decltype(free)</em>`。</p>
<h3 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h3><p><code>shared_ptr</code>的用法与<code>unique_ptr</code>类似。要创建<code>shared_ptr</code>，可使用<code>make_shared()</code>，它比直接创建<code>shared_ptr</code>更高效。例如:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> mySimpleSmartPtr = make_shared&lt;Simple&gt;();</span><br></pre></td></tr></table></figure></p>
<p>从C++17开始，<code>shared_ptr</code>可用于存储动态分配的旧式C风格数组的指针。这在C++17之前是无法实现的。但是，尽管这在C++17中是可能的，仍建议使用标准库容器而非C风格数组。与<code>unique_ptr</code>一样，<code>shared_ptr</code>也支持get()和reset()方法。</p>
<p>与<code>unique_ptr</code>类似，<code>shared_ptr</code>默认情况下使用标准的new和delete运算符来分配和释放内存:在C++17中存储C风格数组时，使用<code>new[]</code>和<code>delete[]</code>。可更改此行为，如下所示:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Implementation of malloc_ int() as before.</span></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; myIntSmartPtr (malloc_int(<span class="number">42</span>), <span class="built_in">free</span>) ;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，不必将自定义deleter的类型指定为模板类型参数，这比<code>unique_ptr</code>的自定义deleter更简便。</p>
<h4 id="强制转换shared-ptr"><a href="#强制转换shared-ptr" class="headerlink" title="强制转换shared_ptr"></a>强制转换shared_ptr</h4><p>可用于强制转换<code>shared_ptrs</code>的函数是<code>const_pointer_cast()</code>、<code>dynamic_pointer_cast()</code>和<code>static_pointer_cast()</code>。C++17又添加了<code>reinterpret_pointer_cast()</code>。它们的行为和工作方式类似于非智能指针转换函数<code>const_cast()</code>、<code>dynamic_cast()</code>、<code>static_cast()</code>和<code>reinterpret_cast()</code>。</p>
<h4 id="引用计数的必要性"><a href="#引用计数的必要性" class="headerlink" title="引用计数的必要性"></a>引用计数的必要性</h4><p>作为一般概念， 引用计数(reference counting)用于跟踪正在使用的某个类的实例或特定对象的个数。引用计数的智能指针跟踪为引用一个真实指针(或某个对象)而建立的智能指针的数目。通过这种方式，智能指针可以避免双重删除。</p>
<h4 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h4><p><code>shared_ptr</code>支持所谓的别名。这允许一个<code>shared_ptr</code>与另一个<code>shared_ptr</code>共享一个指针(拥有的指针)， 但指向不同的对象(存储的指针)。例如，这可用于使用一个<code>shared_ptr</code>指向一个对象的成员，同时拥有该对象本身，例如:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Foo(<span class="keyword">int</span> value) : mData (value) &#123; &#125;</span><br><span class="line">    <span class="keyword">int</span> mData;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> foo = make_shared&lt;Foo&gt; (<span class="number">42</span>) ;</span><br><span class="line"><span class="keyword">auto</span> aliasing = <span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt;(foo，&amp;foo-&gt;mData) ;</span><br></pre></td></tr></table></figure></p>
<p>仅当两个<code>shared_ptrs</code>(foo和aliasing)都销毁时，才销毁Foo对象。</p>
<p>“拥有的指针”用于引用计数；当对指针解引用或调用它的get()时，将返回“存储的指针”。存储的指针用于大多数操作，如比较运算符。可以使用<code>owner_before()</code>方法或<code>std:owner_less</code>类，基于拥有的指针执行比较。</p>
<p>在某些情况下(例如在<code>std::set</code>中存储<code>shared_ptrs</code>)，这很有用。</p>
<h3 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h3><p>在C++中还有一个类与<code>shared_ptr</code>模板有关，那就是<code>weak_ptr</code>。<code>weak_ptr</code>可包含由<code>shared_ptr</code>管理的资源的引用。<code>weak_ptr</code>不拥有这个资源，所以不能阻止<code>shared_ptr</code>释放资源。<code>weak_ptr</code> 销毁时(例如离开作用域时)不会销毁它指向的资源：然而，它可用于判断资源是否已经被关联的<code>shared_ptr</code>释放了。<code>weak_ptr</code>的构造函数要求将一个<code>shared_ptr</code>或另一个<code>weak_ptr</code>作为参数。为了访问<code>weak_ptr</code>中保存的指针，需要将<code>weak_ptr</code>转换为<code>shared_ptr</code>。这有两种方法：</p>
<ul>
<li>使用<code>weak_ptr</code>实例的<code>lock()</code>方法， 这个方法返回一个<code>shared_ptr</code>。如果同时释放了与<code>weak_ptr</code>关联的<code>shared_ptr</code>， 返回的<code>shared_ptr</code>是nullptr。</li>
<li>创建一个新的<code>shared_ptr</code>实例，将<code>weak_ptr</code> 作为<code>shared_ptr</code>构造函数的参数。如果释放了与<code>weak_ptr</code>关联的<code>shared_ptr</code>，将抛出<code>std::bad_weak_ptr</code>异常。</li>
</ul>
<p>下例演示了<code>weak_ptr</code>的用法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">useResource</span> <span class="params">(weak_ptr&lt;Simple&gt;&amp; weakSimple)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> resource = weakSimple.lock();</span><br><span class="line">    <span class="keyword">if</span> (resource) </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Resource still alive."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Resource has been freed!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> sharedSimple = make_shared&lt;Simple&gt;() ;</span><br><span class="line">    weak_ptr&lt;Simple&gt; weakSimple(sharedSimple) ;</span><br><span class="line">    <span class="comment">// Try to use the `weak_ptr`.</span></span><br><span class="line">    useResource(weakSimple) ;</span><br><span class="line">    <span class="comment">// Reset the shared_ptr.</span></span><br><span class="line">    <span class="comment">// Since there is only 1 `shared_ptr`to the Simple resource, this will</span></span><br><span class="line">    <span class="comment">// free the resource， even though there is still a `weak_ptr` alive.</span></span><br><span class="line">    sharedSimple.reset();</span><br><span class="line">    <span class="comment">// Try to use the `weak_ptr` a second time.</span></span><br><span class="line">    useResource (weakSimple);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述代码的输出如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Simple constructor called!</span><br><span class="line">Resource still alive.</span><br><span class="line">Simple destructor called!</span><br><span class="line">Resource has been freed!</span><br></pre></td></tr></table></figure></p>
<p>从C++17开始，<code>shared_ptr</code>支持C风格的数组；与此类似，<code>weak_ptr</code> 也支持C风格的数组。</p>
<h2 id="常见的内存陷阱"><a href="#常见的内存陷阱" class="headerlink" title="常见的内存陷阱"></a>常见的内存陷阱</h2><h3 id="分配不足的字符串"><a href="#分配不足的字符串" class="headerlink" title="分配不足的字符串"></a>分配不足的字符串</h3><p>大多数情况下，都是因为程序员没有分配尾部的\0终止字符。当程序员假设某个固定的最大大小时，也会发生字符串分配不足的情况。基本的内置C风格字符串函数不会针对固定的大小操作——而是有 多少写多少，如果超出字符串的末尾，就写入未分配的内存。</p>
<p>有三种方法用于解决可能的分配不足问题。按照优先级降序排列，这三种方法为:</p>
<ol>
<li>使用C++风格的字符串，它可自动处理与连接字符串关联的内存。</li>
<li>不要将缓冲区分配为全局变量或分配在堆栈上，而是分配在堆上。当剩余空间不足时，分配一个新缓冲区，它大到至少能保存当前内容加上新内存块的内容，将原来缓冲区的内容复制到新缓冲区，将新内容追加到后面，然后删除原来的缓冲区。</li>
<li>创建另一个版本的<code>getMoreData()</code>，这个版本接收一个最大计数值(包括\0字符)，返回的字符数不多于这个值；然后跟踪剩余的空间数以及缓冲区中当前的位置。</li>
</ol>
<h3 id="访问内存越界"><a href="#访问内存越界" class="headerlink" title="访问内存越界"></a>访问内存越界</h3><p>本章前面提到，指针只不过是一个内存地址，因此指针可能指向内存中的任何一个位置。这种情况很容易出现。例如，考虑一个C风格的字符串，它不小心丢失了’\0’终止字符。下面这个函数试图将字符串填满m字符，但实际上可能会继续在字符串后面填充m:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fillWithM</span><span class="params">(<span class="keyword">char</span>* inStr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (inStr[i] != <span class="string">'\0'</span>) &#123;</span><br><span class="line">        inStr [i] = <span class="string">'m'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果把不正确的终止字符串传入这个函数，那么内存的重要部分被改写而导致程序崩溃只是时间问题。许多内存检测工具也能检测缓冲区溢出。使用像C++ string 和vector这样的高级结构有助于避免产生一些和C风格字符串和数组相关的bug。</p>
<h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><p>随着程序的运行，吞掉的内存越来越多。这是因为程序有内存泄漏。通过智能指针避免内存泄漏是解决这个问题的首选方法。分配了内存，但没有释放，就会发生内存泄漏。</p>
<h3 id="双重删除和无效指针"><a href="#双重删除和无效指针" class="headerlink" title="双重删除和无效指针"></a>双重删除和无效指针</h3><p>通过delete 释放某个指针关联的内存时，这个内存就可以由程序的其他部分使用了。然而，无法禁止再次使用这个指针，这个指针成为悬挂指针(dangling pointer)。双重删除也是一个问题。如果第二次在同一个指针上执行delete操作，程序可能会释放重新分配给另一个对象的内存。双重删除和使用已释放的内存都是很难追查的问题，因为症状可能不会立即显现。</p>
<p>如果双重删除在较短的时间内发生，程序可能产生未定义的行为，因为关联的内存可能不会那么快重用。同样，如果删除的对象在删除后立即使用，这个对象很有可能仍然完好无缺。当然，无法保证这种行为会继续出现。一旦删除对象，内存分配器就没有义务保存任何对象。</p>
<h1 id="熟悉类和对象"><a href="#熟悉类和对象" class="headerlink" title="熟悉类和对象"></a>熟悉类和对象</h1><h2 id="编写类"><a href="#编写类" class="headerlink" title="编写类"></a>编写类</h2><p>类中每个成员和方法都可用三种访问说明符之一来说明：public、protected或private。类的默认访问说明符是private：在第一个访问说明符之前声明的所有成员的访问都是私有的。类似的C++中的struct也可以拥有方法，不过struct默认的访问说明符是public。</p>
<p><code>::</code>称为作用域解析运算符。每个普通的方法调用都会传递一个指向对象的指针，这是称为“隐藏”参数的this指针。使用这个参数可以访问数据成员或调用方法，也可将其传递给其他方法或函数。</p>
<p>在堆中创建对象时，通过“-&gt;”访问其成员，如同必须释放堆中的其他内存一样，也必须在对象上调用delete，释放堆中为对象分配的内存。为了避免发生内存错误，建议使用智能指针。使用智能指针不需要手动释放内存，内存会自动释放。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> myCellp = make_unique&lt;SpreadsheetCell&gt;();</span><br><span class="line">myCellp-&gt;setValue(<span class="number">3.7</span>);</span><br></pre></td></tr></table></figure></p>
<h2 id="对象的生命周期"><a href="#对象的生命周期" class="headerlink" title="对象的生命周期"></a>对象的生命周期</h2><h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><p>声明对象或使用new显式分配空间时，就会创建对象。当创建对象时，会同时创建内嵌的对象。声明并编写一个构造函数可以初始化对象。从语法上讲，构造函数是与类同名的方法。构造函数没有返回类型，可以有也可以没有参数，没有参数的构造函数称为<strong>默认构造函数</strong>。可以是无参构造函数，也可以让所有参数都使用默认值。许多情况下，都必须提供默认构造函数，如果不提供，就会导致编译器错误。</p>
<p>构造函数用来创建对象并初始化其值。在基于堆栈和堆进行分配时可以使用构造函数。在堆栈中分配SpreadsheetCell对象时，可这样使用构造函数:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SpreadsheetCell myCe11(5), anotherCe1l(4);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"cell 1:"</span>&lt;&lt; myCell.getValue() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"cell 2:"</span>&lt;&lt; anotherCell.getValue() &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p>
<p>当动态分配SpreadsheetCell对象时，可这样使用构造函数:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> smartCellp = make_unique&lt;SpreadsheetCell&gt;(<span class="number">4</span>);</span><br><span class="line"><span class="comment">//... do something with the cell, no need to delete the smart pointer</span></span><br><span class="line"><span class="comment">// Or with raw pointers, without smart pointers (not recommended)</span></span><br><span class="line">SpreadsheetCell* myCellp = <span class="keyword">new</span> SpreadsheetCell(<span class="number">5</span>);</span><br><span class="line">SpreadsheetCe11* anotherCellp = <span class="literal">nullptr</span>;</span><br><span class="line">anotherCellp = <span class="keyword">new</span> SpreadsheetCell (<span class="number">4</span>) ;</span><br><span class="line"><span class="comment">// ... do something with the cells</span></span><br><span class="line"><span class="keyword">delete</span> myCellp;</span><br><span class="line">myCellp = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">delete</span> anotherCellp;</span><br><span class="line">anotherCellp = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure></p>
<p>注意可以声明一个指向SpreadsheetCell对象的指针，而不立即调用构造函数。堆栈中的对象在声明时会调用构造函数。</p>
<p>无论在堆栈中(在函数中)还是在类中(作为类的数据成员)声明指针，如果没有立即初始化指针，都应该像前面声明anotherCellp那样将指针初始化为nullptr。</p>
<p>在一个类中可提供多个构造函数。所有构造函数的名称相同(类名)，但不同的构造函数具有不同数量的参数或者不同的参数类型。当具有多个构造函数时，在一个构造函数中执行另一个构造函数的想法很诱人。例如，以下面的方式让string构造函数调用double构造函数:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SpreadsheetCell::SpreadsheetCell (string_view initialValue) &#123;</span><br><span class="line">    SpreadsheetCell(stringToDouble(initialValue));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>显式调用SpreadsheetCell构造函数实际上新建了一个SpreadsheetCell类型的临时未命名对象，而并不是像预期的那样调用构造函数以初始化对象。然而，C++支持委托构造函数(delegating constructors)， 允许构造函数初始化器调用同一个类的其他构造函数。</p>
<p>默认构造函数没有参数，也称为无参构造函数。使用默认构造函数可以在客户不指定值的情况下初始化数据成员。C++没有提供任何语法，让创建数组的代码直接调用不同的构造函数。如果想创建某个类的对象数组，最好还是定义类的默认构造函数。如果没有定义自己的构造函数，编译器会自动创建默认构造函数。如果想在标准库容器(例如<code>stl::vector)</code>中存储类，也需要默认构造函数。</p>
<p>与基于堆栈的对象的其他构造函数不同，调用默认构造函数不需要使用函数调用的语法。根据其他构造函数的语法，用户或许会试着这样调用默认构造函数:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SpreadsheetCell <span class="title">myCell</span><span class="params">()</span></span>; <span class="comment">// WRONG， but will compile.</span></span><br><span class="line">myCell.setValue (<span class="number">6</span>);</span><br><span class="line"><span class="comment">// However, this line will not compile.</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"cell 1:"</span>&lt;&lt; myCell.getValue() &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p>
<p>试图调用默认构造函数的行可以编译，但是后面的行无法编译。问题在于常说的most vexing parse，编译器实际上将第一行当作函数声明，函数名为<code>myCell</code>，没有参数，返回值为SpreadsheetCell对象。当编译第二行时，编译器认为用户将函数名用作对象!</p>
<p>对于堆中的对象，可以这样使用默认构造函数:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> smartcellp = make_unique&lt;SpreadsheetCell&gt;();</span><br><span class="line"><span class="comment">// Or with a raw pointer (not recommended)</span></span><br><span class="line">SpreadsheetCell* myCellp = <span class="keyword">new</span> SpreadsheetCell ();</span><br><span class="line"><span class="comment">// SpreadsheetCell* myCellp = new SpreadsheetCell;</span></span><br></pre></td></tr></table></figure></p>
<h4 id="编译器生成的默认构造函数"><a href="#编译器生成的默认构造函数" class="headerlink" title="编译器生成的默认构造函数"></a>编译器生成的默认构造函数</h4><p>本章的第一个SpreadsheetCell类定义如下所示:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpreadsheetCell</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setvalue</span><span class="params">(<span class="keyword">double</span> invalue)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getValue</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> mValue;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这个类定义没有声明任何默认构造函数，但以下代码仍然可以正常运行:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SpreadsheetCell myCell;</span><br><span class="line">myCell.setValue(<span class="number">6</span>) ;</span><br></pre></td></tr></table></figure></p>
<p>下面的定义与前面的定义相同，只是添加了一个显式的构造函数，用一个double值作为参数。这个定义仍然没有显式声明默认构造函数:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpreadsheetCell</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SpreadsheetCell (<span class="keyword">double</span> initialValue); <span class="comment">// No default constructor</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>使用这个定义，下面的代码将无法编译:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SpreadsheetCell myCell;</span><br><span class="line">myCell.setValue(<span class="number">6</span>);</span><br></pre></td></tr></table></figure></p>
<p>原因在于如果没有指定任何构造函数，编译器将自动生成无参构造函数。类所有的对象成员都可以调用编译器生成的默认构造函数，但不会初始化语言的原始类型，例如int 和double。 尽管如此，也可用它来创建类的对象。然而，如果声明了默认构造函数或其他构造函数，编译器就不会再自动生成默认构造函数。</p>
<p>默认构造函数与无参构造函数是一回事。术语“默认构造函数”并不仅仅是说如果没有声明任何构造函数，就会自动生成一个构造函数；而且指如果没有参数，构造函数就采用默认值。</p>
<h4 id="显式的默认构造函数"><a href="#显式的默认构造函数" class="headerlink" title="显式的默认构造函数"></a>显式的默认构造函数</h4><p>在C++03或更早版本中，必须显式地编写空的默认构造函数，为了避免手动编写空的默认构造函数，C++现在支持显式的默认构造函数(explicitly defaulted constnuctor)。可按如下方法编写类的定义，而不需要在实现文件中实现默认构造函数:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpreadsheetCell</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    SpreadsheetCell() = <span class="keyword">default</span>;</span><br><span class="line">    SpreadsheetCell (<span class="keyword">double</span> initialValue) ;</span><br><span class="line">    SpreadsheetCell (<span class="built_in">std</span>::string_view initialValue) ;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// Remainder of the class definition omitted for brevity</span></span><br></pre></td></tr></table></figure></p>
<p>SpreadsheetCell定义了两个定制的构造函数。然而，由于使用了default 关键字，编译器仍然会生成一个标准的由编译器生成的默认构造函数。</p>
<p>C++还支持显式删除构造函数(explicitly deleted constructors)。例如，可定义一个只有静态方法的类，这个类没有任何构造函数，也不想让编译器生成默认构造函数。在此情况下可以显式删除默认构造函数:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyClass() = <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure></p>
<h4 id="构造函数初始化器"><a href="#构造函数初始化器" class="headerlink" title="构造函数初始化器"></a>构造函数初始化器</h4><p>本章到现在为止，都是在构造函数体内初始化数据成员，例如:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SpreadsheetCell::SpreadsheetCell (<span class="keyword">double</span> initialValue) &#123;</span><br><span class="line">    setValue (initialValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>C++提供了另一种在构造函数中初始化数据成员的方法，叫作构造函数初始化器或ctor-initializer。 下面的代码使用ctor-initializer语法重写了没有参数的SpreadsheetCell构造函数:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SpreadsheetCell::SpreadsheetCell (<span class="keyword">double</span> initialValue) : mValue (initialValue) &#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看出，ctor-initializer 出现在构造函数参数列表和构造函数体的左大括号之间。这个列表以冒号开始，由逗号分隔。列表中的每个元素都使用函数符号、统一的初始化语法、调用基类构造函数，或者调用委托构造函数以初始化某个数据成员。</p>
<p>使用ctor-initializer初始化数据成员与在构造函数体内初始化数据成员不同。当C++创建某个对象时，必须在调用构造函数前创建对象的所有数据成员。如果数据成员本身就是对象，那么在创建这些数据成员时，必须为其调用构造函数。在构造函数体内给某个对象赋值时，并没有真正创建这个对象，而只是改变对象的值。</p>
<p>ctor-initializer允许在创建数据成员时赋初值，<strong>这样做比在后面赋值效率高</strong>。对于类型，它少了一次调用构造函数的过程，而在函数体中赋值则会多一次调用。而对于内置数据类型则没有差别。编译器会一一操作初始化列表，以适当的顺序在构造函数之内安插初始化操作，并且在任何显示用户代码之前；list中的项目顺序是由类中的成员声明顺序决定的，不是由初始化列表的顺序决定的；</p>
<p>如果类的数据成员是具有默认构造函数的类的对象，则不必在ctor-initializer中显式初始化对象。例如，如果有一个std::string数据成员，其默认构造函数将字符串初始化为空字符串，那么在ctor initializer中将其初始化为””是多余的。</p>
<p>而如果类的数据成员是没有默认构造函数的类的对象，则必须在ctor-initializer 中显式初始化对象。例如，考虑下面的SpreadsheetCell类:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpreadsheetCell</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SpreadsheetCell (<span class="keyword">double</span> d); </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这个类只有一个采用double 值作为参数的显式构造函数，而没有默认构造函数。可在另一个类中将这个类用作数据成员，如下所示:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SomeClass();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    SpreadsheetCell mCell;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在ctor-initializer中初始化mCell数据成员，如下所示:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SomeClass::SomeClass() : mCell(<span class="number">1.0</span>) &#123; &#125;</span><br></pre></td></tr></table></figure></p>
<p>赋值初始化，通过在函数体内进行赋值初始化；列表初始化，在冒号后使用初始化列表进行初始化。这两种方式的主要区别在于：</p>
<ul>
<li>对于在函数体中初始化，是在所有的数据成员被分配内存空间后才进行的。</li>
<li>列表初始化是给数据成员分配内存空间时就进行初始化，就是说分配一个数据成员只要冒号后有此数据成员的赋值表达式(此表达式必须是括号赋值表达式)，那么分配了内存空间后在进入函数体之前给数据成员赋值，就是说初始化这个数据成员此时函数体还未执行。</li>
</ul>
<p>2)  一个派生类构造函数的执行顺序如下：</p>
<ul>
<li>虚拟基类的构造函数（多个虚拟基类则按照继承的顺序执行构造函数）。</li>
<li>基类的构造函数（多个普通基类也按照继承的顺序执行构造函数）。</li>
<li>类类型的成员对象的构造函数（按照初始化顺序）</li>
<li>派生类自己的构造函数。</li>
</ul>
<p>必须使用成员初始化的四种情况</p>
<ul>
<li>当初始化一个引用成员时；</li>
<li>当初始化一个常量成员时；</li>
<li>当调用一个基类的构造函数，而它拥有一组参数时；</li>
<li>当调用一个成员类的构造函数，而它拥有一组参数时；</li>
</ul>
<h4 id="复制构造函数"><a href="#复制构造函数" class="headerlink" title="复制构造函数"></a>复制构造函数</h4><p>复制构造函数(copy constructor)允许所创建的对象是另一个对象的精确副本。如果没有编写复制构造函数，C++会自动生成一个，用源对象中相应数据成员的值初始化新对象的每个数据成员。如果数据成员是对象，初始化意味着调用它们的复制构造函数。下面是SpreadsheetCell类中复制构造函数的声明:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpreadsheetCell</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SpreadsheetCell (<span class="keyword">const</span> SpreadsheetCell&amp; src) ;</span><br><span class="line"><span class="comment">// Remainder of the class definition omitted for brevity</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>复制构造函数采用源对象的const引用作为参数。与其他构造函数类似，它也没有返回值。在复制构造函数内部，应该复制源对象的所有数据成员。当然，从技术角度看，可在复制构造函数内完成任何操作，但最好按照预期的行为将新对象初始化为已有对象的副本。下面是SpreadsheetCell复制构造函数的示例实现，注意ctor-initializer的用法。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SpreadsheetCell::SpreadsheetCell (<span class="keyword">const</span> SpreadsheetCell&amp; src) : mValue (src.mValue)</span><br></pre></td></tr></table></figure></p>
<p>假定有一组成员变量，名为m1、m2、…. mn，编译器生成的复制构造函数为:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">classname::classname (<span class="keyword">const</span> classname&amp; src) : m1(src.m1), m2(src.m2), ... mn(src.mn) &#123; &#125;</span><br></pre></td></tr></table></figure></p>
<p>因此多数情况下，不需要亲自编写复制构造函数!</p>
<p>C++中传递函数参数的默认方式是值传递，这意味着函数或方法接收某个值或对象的副本。因此，<strong>无论什么时候给函数或方法传递一个对象，编译器都会调用新对象的复制构造函数进行初始化</strong>。</p>
<p>当调用<code>setString()</code>并传递一个string参数时，这个string参数会调用复制构造函数进行初始化。为初始化<code>printString()</code>中的inString对象，会调用string复制构造函数，其参数为name:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> name = <span class="string">"heading one"</span>;</span><br><span class="line">printString(name) ; <span class="comment">// Copies name</span></span><br></pre></td></tr></table></figure></p>
<p>当<code>printString()</code>方法结束时，inString 被销毁，因为它只是name的一个副本， 所以name完好无缺。当然，可通过将参数作为const引用来传递，从而避免复制构造函数的开销。</p>
<h4 id="显式调用复制构造函数"><a href="#显式调用复制构造函数" class="headerlink" title="显式调用复制构造函数"></a>显式调用复制构造函数</h4><p>也可显式地使用复制构造函数，从而将某个对象作为另一个对象的精确副本。例如，可这样创建SpreadsheetCell对象的副本:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SpreadsheetCell <span class="title">myCelll</span> <span class="params">(<span class="number">4</span>)</span> </span>;</span><br><span class="line"><span class="function">SpreadsheetCell <span class="title">myCe112</span> <span class="params">(myCe111)</span></span>; <span class="comment">// myCe112 has the same values as myCe111</span></span><br></pre></td></tr></table></figure></p>
<h4 id="按引用传递对象"><a href="#按引用传递对象" class="headerlink" title="按引用传递对象"></a>按引用传递对象</h4><p>向函数或方法传递对象时，为避免复制对象，可让函数或方法采用对象的引用作为参数。按引用传递对象通常比按值传递对象的效率更高，因为只需要复制对象的地址，而不需要复制对象的全部内容。此外，按引用传递可避免对象动态内存分配的问题。</p>
<p>按引用传递某个对象时，使用对象引用的函数或方法可修改原始对象。如果只是为了提高效率才按引用传递，可将对象声明为const以排除这种可能。这称为按const引用传递对象。</p>
<p>为了提高性能，最好按const引用而不是按值传递对象。但是诸如int和double等基本类型应当按值传递。按const引用传递这些类型什么也得不到。</p>
<h4 id="初始化列表构造函数"><a href="#初始化列表构造函数" class="headerlink" title="初始化列表构造函数"></a>初始化列表构造函数</h4><p>初始化列表构造函数(nitializer-list constructors)将<code>std:initializer_list&lt;T&gt;</code>作为第一个参数, 并且没有任何其他参数。下面的类演示了这种用法。该类只接收<code>initializer_list&lt;T&gt;</code>，元素个数应为偶数，否则将抛出异常。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EvenSequence</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    EvenSequence (initializer_ <span class="built_in">list</span>&lt;<span class="keyword">double</span>&gt; args) &#123;</span><br><span class="line">        <span class="keyword">if</span> (args.size() % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> invalid_ argument (<span class="string">"initializer_ list should contain even number of elements."</span>);</span><br><span class="line">        mSequence. reserve(args.size());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; value : args)</span><br><span class="line">            mSequence.push_back (value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dump</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; value : mSequence)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; value &lt;&lt; <span class="string">", "</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; mSequence;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在初始化列表构造函数的内部，可使用基于区间的for循环来访问初始化列表的元素。使用<code>size()</code>方法可获取初始化列表中元素的数目。</p>
<p>EvenSequence初始化列表构造函数使用基于区间的for循环来复制给定initializer_list 中的元素。也可以使用vector 的assign()方法。</p>
<p>标准库完全支持初始化列表构造函数。例如，可使用初始化列表初始化<code>stl::vector</code>容器。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; myVec = &#123;<span class="string">"String 1"</span>, <span class="string">"String 2"</span>, <span class="string">"String 3"</span>&#125;;</span><br></pre></td></tr></table></figure></p>
<p>如果不使用初始化列表构造函数，可通过一些<code>push_back()</code>调用来初始化vector:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; myVec;</span><br><span class="line">myVec.push_back(<span class="string">"String 1"</span>);</span><br><span class="line">myVec.push_back(<span class="string">"String 2"</span>);</span><br><span class="line">myVec.push_back(<span class="string">"String 3"</span>);</span><br></pre></td></tr></table></figure></p>
<p>初始化列表并不限于构造函数，还可以用于普通函数。</p>
<h4 id="委托构造函数"><a href="#委托构造函数" class="headerlink" title="委托构造函数"></a>委托构造函数</h4><p>委托构造函数(delegating constructors)允许构造函数调用同一个类的其他构造函数。然而，这个调用不能放在构造函数体内，而必须放在构造函数初始化器中，且必须是列表中唯一的成员初始化器。下面给出了一个示例:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SpreadsheetCell::SpreadsheetCell (string_view initialvalue)</span><br><span class="line">: SpreadsheetCell (str ingToDouble (ini tialValue) )</span><br><span class="line">&#123; &#125;</span><br></pre></td></tr></table></figure></p>
<p>当调用这个<code>string_view</code>构造函数(委托构造函数)时，首先将调用委托给目标构造函数，也就是double构造函数。当目标构造函数返回时，再执行委托构造函数。当使用委托构造函数时，要注意避免出现构造函数的递归。例如:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">    MyClass (<span class="keyword">char</span> c) : MyClass(<span class="number">1.2</span>) &#123; &#125;</span><br><span class="line">    MyClass (<span class="keyword">double</span> d) : MyClass(<span class="string">'m'</span>) &#123; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>第一个构造函数委托第二个构造函数，第二个构造函数又委托第一个构造函数。C++标准没有定义此类代码的行为，这取决于编译器。</p>
<h4 id="总结编译器生成的构造函数"><a href="#总结编译器生成的构造函数" class="headerlink" title="总结编译器生成的构造函数"></a>总结编译器生成的构造函数</h4><p>编译器为每个类自动生成没有参数的构造函数和复制构造函数。然而，编译器自动生成的构造函数取决于你自己定义的构造函数，对应的规则如表8-3所示。<br><img src="/img/1619223966.jpg" alt></p>
<h3 id="销毁对象"><a href="#销毁对象" class="headerlink" title="销毁对象"></a>销毁对象</h3><p>当销毁对象时，会发生两件事：调用对象的析构函数，释放对象占用的内存。在析构函数中可以执行对象的清理，例如释放动态分配的内存或者关闭文件句柄。如果没有声明析构函数，编译器将自动生成一个，析构函数会逐一销毁成员，然后删除对象。</p>
<p>当堆栈中的对象超出作用域时，意味着当前的函数、方法或其他执行代码块结束，对象会被销毁。换句话说，当代码遇到结束大括号时，这个大括号中所有创建在堆栈中的对象都会被销毁。下面的程序显示了这一行为:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">SpreadsheetCell <span class="title">myCell</span> <span class="params">(<span class="number">5</span>)</span> </span>;</span><br><span class="line">    <span class="keyword">if</span> (myCell .getValue() == <span class="number">5</span>)</span><br><span class="line">        <span class="function">SpreadsheetCell <span class="title">anotherCell</span><span class="params">(<span class="number">6</span>)</span> </span>;</span><br><span class="line">    &#125; <span class="comment">// anotherCell is destroyed as this block ends.</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"myCell: "</span> &lt;&lt; myCell.getValue() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="comment">// myCell is destroyed as this block ends .</span></span><br></pre></td></tr></table></figure></p>
<p>堆栈中对象的销毁顺序与声明顺序(和构建顺序)相反。如果某个对象是其他对象的数据成员，这顺序也适用。数据成员的初始化顺序是它们在类中声明的顺序。因此，按对象的销毁顺序与创建顺序相反这一规则， 数据成员对象的销毁顺序与其在类中声明的顺序相反。</p>
<p>没有智能指针的帮助，在堆中分配的对象不会自动销毁。必须使用delete 删除对象指针，从而调用析构函数并释放内存。下面的程序显示了这一行为:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    SpreadsheetCell* cellPtrl </span>= <span class="keyword">new</span> SpreadsheetCell (<span class="number">5</span>) ;</span><br><span class="line">    SpreadsheetCell* cellPtr2 = <span class="keyword">new</span> SpreadsheetCell (<span class="number">6</span>) ;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"cellPtr1: "</span>&lt;&lt; cellPtr1-&gt;getvalue() &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    <span class="keyword">delete</span> cellPtrl; <span class="comment">// Destroys cellPtrl</span></span><br><span class="line">    cel1Ptrl = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="comment">// cellPtr2 is NOT destroyed because delete was not called on it.</span></span><br></pre></td></tr></table></figure></p>
<h3 id="对象赋值"><a href="#对象赋值" class="headerlink" title="对象赋值"></a>对象赋值</h3><p>就像可将一个int变量的值赋给另一个int变量一样, 在C++中也可将一个对象的值赋给另一个对象。例如，下面的代码将myCell的值赋给anotherCell:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SpreadsheetCell myCell(5), anotherCell;</span><br><span class="line">anotherCell = myCell;</span><br></pre></td></tr></table></figure></p>
<p>在C++中，“复制”只在初始化对象时发生。如果一个已经具有值的对象被改写，更精确的术语是“赋值”。注意C++提供的复制工具是复制构造函数。因为这是一个构造函数，所以只能用在创建对象时，而不能用于对象的赋值。</p>
<p>因此，C++为所有的类提供了执行赋值的方法。这个方法叫作赋值运算符(assignment operator)， 名称是<code>operator=</code>，因为实际上是为类重载了<code>=</code>运算符。在上例中，调用了anotherCell的赋值运算符，参数为myCell。</p>
<p>如果没有编写自己的赋值运算符，C++将自动生成一个，从而允许将对象赋给另一个对象。默认的C++赋值行为几乎与默认的复制行为相同：以递归方式用源对象的每个数据成员并赋值给目标对象。</p>
<h4 id="声明赋值运算符"><a href="#声明赋值运算符" class="headerlink" title="声明赋值运算符"></a>声明赋值运算符</h4><p>下面是SpreadsheetCell类的赋值运算符:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpreadsheetCell</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SpreadsheetCell&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> SpreadsheetCell&amp; rhs) ;</span><br><span class="line">    <span class="comment">// Remainder of the class definition omitted for brevity</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>赋值运算符与复制构造函数类似，采用了源对象的const引用。在此情况下，将源对象称为rths，代表等号的“右边”(可为其指定其他任何名称)，调用赋值运算符的对象在等号的左边。与复制构造函数不同的是，赋值运算符返回SpreadsheetCell对象的引用。原因是赋值可以链接在一起。</p>
<h4 id="定义赋值运算符"><a href="#定义赋值运算符" class="headerlink" title="定义赋值运算符"></a>定义赋值运算符</h4><p>赋值运算符的实现与复制构造函数类似，但存在一些重要的区别。首先，<strong>复制构造函数只有在初始化时才调用</strong>，此时目标对象还没有有效的值。<strong>赋值运算符可以改写对象的当前值</strong>。其次，在C++中允许将对象的值赋给自身。例如，下面的代码可以编译并运行:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SpreadsheetCell <span class="title">cell</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">cell = cell;</span><br></pre></td></tr></table></figure></p>
<p>赋值运算符不应该阻止自赋值。在SpreadsheetCell类中，这并不重要，因为它的唯一数据成员是基本类型double。但当类具有动态分配的内存或其他资源时，必须将自赋值考虑在内，为阻止此类情况下的问题发生，赋值运算符通常在方法开始时检测自赋值，如果发现自赋值，则立刻返回。下面是SpreadsheetCell类的赋值运算符的定义:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SpreadsheetCell&amp; SpreadsheetCell::<span class="keyword">operator</span>= (<span class="keyword">const</span> SpreadsheetCell&amp; rhs) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;rhs) &#123;</span><br></pre></td></tr></table></figure></p>
<p>第一行检测自赋值，但有一个神秘之处。当等号的左边和右边相同时，就是自赋值。判断两个对象是否相同的方法之一是检查它们在内存中的位置是否相同，更明确地说，是检查指向它们的指针是否相等。由于返回类型是<code>SpreadsheeCell&amp;</code>，因此必须返回一个正确的值。所有赋值运算符都返回<code>*this</code>，自赋值情况也不例外:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>this指针指向执行方法的对象，因此<code>*this</code>就是对象本身。编译器将返回一个对象的引用，从而与声明的返回值匹配。如果不是自赋值，就必须对每个成员赋值:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mValue = rhs.mValue;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br></pre></td></tr></table></figure></p>
<p>这个方法在这里复制了值。最后返回<code>*this</code>。</p>
<h4 id="显式地默认或删除赋值运算符"><a href="#显式地默认或删除赋值运算符" class="headerlink" title="显式地默认或删除赋值运算符"></a>显式地默认或删除赋值运算符</h4><p>可显式地默认或删除编译器生成的赋值运算符，如下所示:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SpreadsheetCell&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> SpreadsheetCell&amp; rhs) = <span class="keyword">default</span>;</span><br></pre></td></tr></table></figure></p>
<p>或者<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SpreadsheetCell&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> SpreadsheetCell&amp; rhs) = <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="编译器生成的复制构造函数和复制赋值运算符"><a href="#编译器生成的复制构造函数和复制赋值运算符" class="headerlink" title="编译器生成的复制构造函数和复制赋值运算符"></a>编译器生成的复制构造函数和复制赋值运算符</h3><p>在C++11中，如果类具有用户声明的复制赋值构造函数或析构函数，那么已经不赞成生成复制构造函数（可能是编译器觉得需要特殊处理，不能简单地直接复制么）。如果在此类情况下仍然需要编译器生成的复制构造函数，可以显式指定default:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyClass (<span class="keyword">const</span> MyClass&amp; src) = <span class="keyword">default</span>;</span><br></pre></td></tr></table></figure></p>
<p>同样，在C++11中，如果类具有用户声明的复制赋值构造函数或析构函数，也不赞成生成复制赋值运算符。如果在此类情况下仍然需要编译器生成的复制赋值运算符，可以显式指定default:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyClass&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> MyClass&amp; rhs) = <span class="keyword">default</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="复制和赋值的区别"><a href="#复制和赋值的区别" class="headerlink" title="复制和赋值的区别"></a>复制和赋值的区别</h3><p>有时很难区分对象什么时候用复制构造函数初始化，什么时候用赋值运算符赋值。基本上，声明时会使用复制构造函数，赋值语句会使用赋值运算符。考虑下面的代码:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SpreadsheetCell <span class="title">myCe11</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="function">SpreadsheetCell <span class="title">anotherCell</span> <span class="params">(myCell)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>AnotherCell由复制构造函数创建。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SpreadsheetCell aThirdCell = myCell;</span><br></pre></td></tr></table></figure></p>
<p>aThirdCell也是由复制构造函数创建的，因为这条语句是一个声明。这行代码不会调用<code>operator=</code>。不过，考虑以下代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">anotherCell = myCell; <span class="comment">// Calls operator= for anotherCell</span></span><br></pre></td></tr></table></figure></p>
<p>此处，anotherCell 已经构建，因此编译器会调用operator=。</p>
<h4 id="按值返回对象"><a href="#按值返回对象" class="headerlink" title="按值返回对象"></a>按值返回对象</h4><p>当函数或方法返回对象时，有时很难看出究竟执行了什么样的复制和赋值。例如，SpreadseetCel:etString0的实现如下所示:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> SpreadsheetCell::getString() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> doubleToString (mValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在考虑下面的代码:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SpreadsheetCell <span class="title">myCe112</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="built_in">string</span> s1;</span><br><span class="line">s1 = myCell2.getString();</span><br></pre></td></tr></table></figure></p>
<p>当<code>getString()</code>返回mString时，编译器实际上调用string复制构造函数，创建一个未命名的临时字符串对象。将结果赋给s1时，会调用s1的赋值运算符，将这个临时字符串作为参数。然后，这个临时的字符串对象被销毁。因此，这行简单的代码调用了复制构造函数和赋值运算符(针对两个不同的对象)。然而，编译器可实现(有时需要实现)返回值优化(Returm Value Optimization, RVO)，在返回值时优化掉成本高昂的复制构造函数。RVO<br>也称为复制省略(copy elision)。</p>
<p>了解到上面的内容后，考虑下面的代码:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SpreadsheetCell <span class="title">myCell3</span><span class="params">(<span class="number">5</span>)</span> </span>;</span><br><span class="line"><span class="built_in">string</span> s2 = myCell3.getString() ;</span><br></pre></td></tr></table></figure></p>
<p>在此情况下，<code>getString()</code>返回时创建了一个临时的未命名字符串对象。但现在s2调用的是复制构造函数，而不是赋值运算符。通过移动语义(move semantics)，编译器可使用移动构造函数而不是复制构造函数，从getString()返回该字符串，这样做效率更高。</p>
<h4 id="复制构造函数和对象成员"><a href="#复制构造函数和对象成员" class="headerlink" title="复制构造函数和对象成员"></a>复制构造函数和对象成员</h4><p>还应注意构造函数中赋值和调用复制构造函数的不同之处。如果某个对象包含其他对象，编译器生成的复制构造函数会递归调用每个被包含对象的复制构造函数。当编写自己的复制构造函数时，可使用前面所示的ctor initializer提供相同的语义。如果在ctor initializer中省略某个数据成员，在执行构造函数体内的代码之前，编译器将对该成员执行默认的初始化(为对象调用默认构造函数)。这样，在执行构造函数体时，所有数据成员都已经初始化。</p>
<p>例如，可这样编写复制构造函数:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SpreadsheetCell::SpreadsheetCell (<span class="keyword">const</span> SpreadsheetCell&amp; src)</span><br><span class="line">mValue = src.mValue;</span><br></pre></td></tr></table></figure></p>
<p>然而，在复制构造函数的函数体内对数据成员赋值时，使用的是赋值运算符而不是复制构造函数，因为它们已经初始化。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/C/" rel="tag"># C++</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/04/29/cpp高级编程 笔记6/" rel="next" title="C++高级编程 第四版 笔记6">
                <i class="fa fa-chevron-left"></i> C++高级编程 第四版 笔记6
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/05/02/cpp高级编程 笔记2/" rel="prev" title="C++高级编程 第四版 笔记2">
                C++高级编程 第四版 笔记2 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/header.jpg" alt="Hao Yu">
            
              <p class="site-author-name" itemprop="name">Hao Yu</p>
              <p class="site-description motion-element" itemprop="description">Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author</p>
          </div>
          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">304</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>
        	<audio controls="controls" loop="loop" preload="auto" src="/resource/xiaomeihao.mp3">
	        </audio>
	

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yuhao0102" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:yuh18@mails.tsinghua.edu.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#C-和标准库速成"><span class="nav-number">1.</span> <span class="nav-text">C++和标准库速成</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#基础知识"><span class="nav-number">1.1.</span> <span class="nav-text">基础知识</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#类型"><span class="nav-number">1.1.1.</span> <span class="nav-text">类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#强类型枚举"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">强类型枚举</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#if-else"><span class="nav-number">1.1.2.</span> <span class="nav-text">if/else</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#switch"><span class="nav-number">1.1.3.</span> <span class="nav-text">switch</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#逻辑符"><span class="nav-number">1.1.4.</span> <span class="nav-text">逻辑符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数"><span class="nav-number">1.1.5.</span> <span class="nav-text">函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#函数返回类型的推断"><span class="nav-number">1.1.5.1.</span> <span class="nav-text">函数返回类型的推断</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#当前函数的名称"><span class="nav-number">1.1.5.2.</span> <span class="nav-text">当前函数的名称</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#std-array"><span class="nav-number">1.1.6.</span> <span class="nav-text">std::array</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#std-vector"><span class="nav-number">1.1.7.</span> <span class="nav-text">std::vector</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#深入研究C"><span class="nav-number">1.2.</span> <span class="nav-text">深入研究C++</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#C-中的字符串"><span class="nav-number">1.2.1.</span> <span class="nav-text">C++中的字符串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#指针和动态内存"><span class="nav-number">1.2.2.</span> <span class="nav-text">指针和动态内存</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#堆栈和堆"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">堆栈和堆</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#动态分配的数组"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">动态分配的数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#空指针常量"><span class="nav-number">1.2.2.3.</span> <span class="nav-text">空指针常量</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#统一初始化"><span class="nav-number">1.3.</span> <span class="nav-text">统一初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#直接列表初始化与复制列表初始化"><span class="nav-number">1.3.1.</span> <span class="nav-text">直接列表初始化与复制列表初始化</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#使用string和string-view"><span class="nav-number">2.</span> <span class="nav-text">使用string和string_view</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#动态字符串"><span class="nav-number">2.1.</span> <span class="nav-text">动态字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#C风格的字符串"><span class="nav-number">2.1.1.</span> <span class="nav-text">C风格的字符串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字符串字面量"><span class="nav-number">2.1.2.</span> <span class="nav-text">字符串字面量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-std-string类"><span class="nav-number">2.1.3.</span> <span class="nav-text">C++ std::string类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#std-string字面量"><span class="nav-number">2.1.3.1.</span> <span class="nav-text">std:string字面量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#高级数值转换"><span class="nav-number">2.1.3.2.</span> <span class="nav-text">高级数值转换</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#std-string-view类"><span class="nav-number">2.1.4.</span> <span class="nav-text">std::string_view类</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#内存管理"><span class="nav-number">3.</span> <span class="nav-text">内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#使用动态内存"><span class="nav-number">3.1.</span> <span class="nav-text">使用动态内存</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#分配和释放"><span class="nav-number">3.1.1.</span> <span class="nav-text">分配和释放</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#使用new和delete"><span class="nav-number">3.1.1.1.</span> <span class="nav-text">使用new和delete</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#当内存分配失败时"><span class="nav-number">3.1.1.2.</span> <span class="nav-text">当内存分配失败时</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数组"><span class="nav-number">3.1.2.</span> <span class="nav-text">数组</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#对象的数组"><span class="nav-number">3.1.2.1.</span> <span class="nav-text">对象的数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#删除数组"><span class="nav-number">3.1.2.2.</span> <span class="nav-text">删除数组</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组-指针的对偶性"><span class="nav-number">3.2.</span> <span class="nav-text">数组-指针的对偶性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数组就是指针"><span class="nav-number">3.2.1.</span> <span class="nav-text">数组就是指针</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#低级内存操作"><span class="nav-number">3.3.</span> <span class="nav-text">低级内存操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#指针运算"><span class="nav-number">3.3.1.</span> <span class="nav-text">指针运算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自定义内存管理"><span class="nav-number">3.3.2.</span> <span class="nav-text">自定义内存管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#垃圾回收"><span class="nav-number">3.3.3.</span> <span class="nav-text">垃圾回收</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#智能指针"><span class="nav-number">3.4.</span> <span class="nav-text">智能指针</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#unique-ptr"><span class="nav-number">3.4.1.</span> <span class="nav-text">unique_ _ptr</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#创建unique-ptrs"><span class="nav-number">3.4.1.1.</span> <span class="nav-text">创建unique_ptrs</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用unique-ptrs"><span class="nav-number">3.4.1.2.</span> <span class="nav-text">使用unique_ptrs</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#unique-ptr和C风格数组"><span class="nav-number">3.4.1.3.</span> <span class="nav-text">unique_ptr和C风格数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#自定义deleter"><span class="nav-number">3.4.1.4.</span> <span class="nav-text">自定义deleter</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#shared-ptr"><span class="nav-number">3.4.2.</span> <span class="nav-text">shared_ptr</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#强制转换shared-ptr"><span class="nav-number">3.4.2.1.</span> <span class="nav-text">强制转换shared_ptr</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#引用计数的必要性"><span class="nav-number">3.4.2.2.</span> <span class="nav-text">引用计数的必要性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#别名"><span class="nav-number">3.4.2.3.</span> <span class="nav-text">别名</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#weak-ptr"><span class="nav-number">3.4.3.</span> <span class="nav-text">weak_ptr</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#常见的内存陷阱"><span class="nav-number">3.5.</span> <span class="nav-text">常见的内存陷阱</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#分配不足的字符串"><span class="nav-number">3.5.1.</span> <span class="nav-text">分配不足的字符串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#访问内存越界"><span class="nav-number">3.5.2.</span> <span class="nav-text">访问内存越界</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内存泄漏"><span class="nav-number">3.5.3.</span> <span class="nav-text">内存泄漏</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#双重删除和无效指针"><span class="nav-number">3.5.4.</span> <span class="nav-text">双重删除和无效指针</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#熟悉类和对象"><span class="nav-number">4.</span> <span class="nav-text">熟悉类和对象</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#编写类"><span class="nav-number">4.1.</span> <span class="nav-text">编写类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对象的生命周期"><span class="nav-number">4.2.</span> <span class="nav-text">对象的生命周期</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#创建对象"><span class="nav-number">4.2.1.</span> <span class="nav-text">创建对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#编译器生成的默认构造函数"><span class="nav-number">4.2.1.1.</span> <span class="nav-text">编译器生成的默认构造函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#显式的默认构造函数"><span class="nav-number">4.2.1.2.</span> <span class="nav-text">显式的默认构造函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#构造函数初始化器"><span class="nav-number">4.2.1.3.</span> <span class="nav-text">构造函数初始化器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#复制构造函数"><span class="nav-number">4.2.1.4.</span> <span class="nav-text">复制构造函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#显式调用复制构造函数"><span class="nav-number">4.2.1.5.</span> <span class="nav-text">显式调用复制构造函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#按引用传递对象"><span class="nav-number">4.2.1.6.</span> <span class="nav-text">按引用传递对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#初始化列表构造函数"><span class="nav-number">4.2.1.7.</span> <span class="nav-text">初始化列表构造函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#委托构造函数"><span class="nav-number">4.2.1.8.</span> <span class="nav-text">委托构造函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#总结编译器生成的构造函数"><span class="nav-number">4.2.1.9.</span> <span class="nav-text">总结编译器生成的构造函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#销毁对象"><span class="nav-number">4.2.2.</span> <span class="nav-text">销毁对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对象赋值"><span class="nav-number">4.2.3.</span> <span class="nav-text">对象赋值</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#声明赋值运算符"><span class="nav-number">4.2.3.1.</span> <span class="nav-text">声明赋值运算符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#定义赋值运算符"><span class="nav-number">4.2.3.2.</span> <span class="nav-text">定义赋值运算符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#显式地默认或删除赋值运算符"><span class="nav-number">4.2.3.3.</span> <span class="nav-text">显式地默认或删除赋值运算符</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#编译器生成的复制构造函数和复制赋值运算符"><span class="nav-number">4.2.4.</span> <span class="nav-text">编译器生成的复制构造函数和复制赋值运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#复制和赋值的区别"><span class="nav-number">4.2.5.</span> <span class="nav-text">复制和赋值的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#按值返回对象"><span class="nav-number">4.2.5.1.</span> <span class="nav-text">按值返回对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#复制构造函数和对象成员"><span class="nav-number">4.2.5.2.</span> <span class="nav-text">复制构造函数和对象成员</span></a></li></ol></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>
  <div id="DvelopmentTarget">     
  </div>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart" aria-hidden="false"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>

  
</div>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_uv"> 
  本站访客数<span id="busuanzi_value_site_uv"></span>人次
</span>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  


  <script type="text/javascript" src="/js/src/love.js"></script>

</body>
</html>
