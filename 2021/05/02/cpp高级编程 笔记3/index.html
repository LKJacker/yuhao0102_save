<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zn-ch">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-center-simple.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="C++,">










<meta name="description" content="理解灵活而奇特的C++引用在C++中，引用是另一个变量的别名。对引用的所有修改都会改变被引用的变量的值。可将引用当作隐式指针，这个指针没有取变量地址和解除引用的麻烦。也可将引用当作原始变量的另一个名称。 引用变量引用变量在创建时必须初始化，如下所示:12int x = 3;int&amp;amp; xRef = x; 使用xRef就是使用x的当前值。对xRef赋值会改变x的值。  创建引用时必须总是初始化">
<meta name="keywords" content="C++">
<meta property="og:type" content="article">
<meta property="og:title" content="C++高级编程 第四版 笔记3">
<meta property="og:url" content="http://yoursite.com/2021/05/02/cpp高级编程 笔记3/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="理解灵活而奇特的C++引用在C++中，引用是另一个变量的别名。对引用的所有修改都会改变被引用的变量的值。可将引用当作隐式指针，这个指针没有取变量地址和解除引用的麻烦。也可将引用当作原始变量的另一个名称。 引用变量引用变量在创建时必须初始化，如下所示:12int x = 3;int&amp;amp; xRef = x; 使用xRef就是使用x的当前值。对xRef赋值会改变x的值。  创建引用时必须总是初始化">
<meta property="og:locale" content="zn-ch">
<meta property="og:image" content="http://yoursite.com/img/1619420180.jpg">
<meta property="og:image" content="http://yoursite.com/img/1619504039.jpg">
<meta property="og:updated_time" content="2021-05-02T14:07:41.343Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="C++高级编程 第四版 笔记3">
<meta name="twitter:description" content="理解灵活而奇特的C++引用在C++中，引用是另一个变量的别名。对引用的所有修改都会改变被引用的变量的值。可将引用当作隐式指针，这个指针没有取变量地址和解除引用的麻烦。也可将引用当作原始变量的另一个名称。 引用变量引用变量在创建时必须初始化，如下所示:12int x = 3;int&amp;amp; xRef = x; 使用xRef就是使用x的当前值。对xRef赋值会改变x的值。  创建引用时必须总是初始化">
<meta name="twitter:image" content="http://yoursite.com/img/1619420180.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2021/05/02/cpp高级编程 笔记3/">





  <title>C++高级编程 第四版 笔记3 | Hao Yu's blog</title>
  








 
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zn-ch">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hao Yu's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">The program monkey was eaten by the siege lion.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/resume.pdf" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-mybetterhalf">
          <a href="/mybetterhalf/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>
            
            mybetterhalf
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/05/02/cpp高级编程 笔记3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">C++高级编程 第四版 笔记3</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-05-02T22:07:41+08:00">
                2021-05-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="理解灵活而奇特的C"><a href="#理解灵活而奇特的C" class="headerlink" title="理解灵活而奇特的C++"></a>理解灵活而奇特的C++</h1><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>在C++中，引用是另一个变量的别名。对引用的所有修改都会改变被引用的变量的值。可将引用当作隐式指针，这个指针没有取变量地址和解除引用的麻烦。也可将引用当作原始变量的另一个名称。</p>
<h3 id="引用变量"><a href="#引用变量" class="headerlink" title="引用变量"></a>引用变量</h3><p>引用变量在创建时必须初始化，如下所示:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span>&amp; xRef = x;</span><br></pre></td></tr></table></figure></p>
<p>使用xRef就是使用x的当前值。对xRef赋值会改变x的值。</p>
<blockquote>
<p>创建引用时必须总是初始化它。通常会在声明引用时对其进行初始化，但是对于包含类而言，需要在构造函数初始化器中初始化引用数据成员。</p>
</blockquote>
<p>不能创建对未命名值(例如一个整数字面量)的引用，除非这个引用是一个const值。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>&amp; unnamedRef1 = <span class="number">5</span>; <span class="comment">// DOES NOT COMPILE</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; unnamedRef2 = <span class="number">5</span>; <span class="comment">// Works as expected</span></span><br></pre></td></tr></table></figure></p>
<p>临时对象同样如此。不能具有临时对象的非const引用，但可具有const引用。例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">getString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"Hello world!"</span>; &#125;</span><br></pre></td></tr></table></figure></p>
<p>对于调用<code>getString()</code>的结果，可以有一个const引用；在该const引用超出作用域之前，将使std::string对象一直处于活动状态：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span>&amp; string1 = getString();    <span class="comment">// DOES NOT COMPILE</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; string2 = getString(); <span class="comment">// Works as expected</span></span><br></pre></td></tr></table></figure></p>
<h4 id="修改引用"><a href="#修改引用" class="headerlink" title="修改引用"></a>修改引用</h4><p>引用总是引用初始化的那个变量，且无法修改。如果在声明引用时用一个变量“赋值”，那么这个引用就指向这个变量。然而，如果在此后使用变量对引用赋值，被引用变量的值就变为被赋值变量的值。<strong>引用不会更新为指向这个变量</strong>。下面是示例代码:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">3</span>, y = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">int</span>&amp; xRef = x;</span><br><span class="line">xRef = y; <span class="comment">// Changes value of x to 4. Doesn't make xRef refer to y.</span></span><br></pre></td></tr></table></figure></p>
<p>将一个引用赋值给另一个引用会让第一个引用指向第二个引用所指的变量吗？<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">3</span>, z = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span>&amp; xRef = x;</span><br><span class="line"><span class="keyword">int</span>&amp; zRef = z;</span><br><span class="line">zRef = xRef; <span class="comment">// Assigns values, not references</span></span><br></pre></td></tr></table></figure></p>
<p>最后一行代码没有改变zRef，只是将z的值设置为3，因为xRef指向x，x的值是3。</p>
<p><strong>在初始化引用之后无法改变引用所指的变量，而只能改变该变量的值。</strong></p>
<h4 id="指向指针的引用和指向引用的指针"><a href="#指向指针的引用和指向引用的指针" class="headerlink" title="指向指针的引用和指向引用的指针"></a>指向指针的引用和指向引用的指针</h4><p>可创建任何类型的引用，包括指针类型。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* intP;</span><br><span class="line"><span class="keyword">int</span>*&amp; ptrRef = intP;</span><br><span class="line">ptrRef = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">*ptrRef = <span class="number">5</span>;</span><br></pre></td></tr></table></figure></p>
<p>语义实际上很简单：<code>ptrRef</code>是一个指向<code>intP</code>的引用，<code>intP</code>是一个指向int值的指针。修改<code>ptrRef</code>会更改<code>intP</code>。</p>
<p>注意，对引用取地址的结果与对被引用变量取地址的结果相同。例如:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span>* xPtr = &amp;xRef; <span class="comment">// Address of a reference is pointer to value</span></span><br><span class="line">*xPtr = <span class="number">100</span>;</span><br></pre></td></tr></table></figure></p>
<p>上述代码通过取x引用的地址，使xPtr指向x。将<code>*xPtr</code>赋值为100，x的值也变为100。比较表达式<code>xPtr==xRef</code>将无法编译，因为类型不匹配；</p>
<h3 id="引用数据成员"><a href="#引用数据成员" class="headerlink" title="引用数据成员"></a>引用数据成员</h3><p>如果不指向其他变量，引用就无法存在。因此，必须在构造函数初始化器(constructor initializer)中初始化引用数据成员，而不是在构造函数体内。下面列举一个简单示例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyClass(<span class="keyword">int</span>&amp; ref) : mRef(ref) &#123; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span>&amp; mRef;</span><br></pre></td></tr></table></figure></p>
<h3 id="引用参数"><a href="#引用参数" class="headerlink" title="引用参数"></a>引用参数</h3><p>引用经常用作函数或方法的参数。当使用引用参数时，函数将引用作为参数。如果引用被修改，最初的参数变量也会被修改。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>&amp; first, <span class="keyword">int</span>&amp; second)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = first;</span><br><span class="line">    first = second;</span><br><span class="line">    second = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>就像无法用常量初始化普通引用变量一样， 不能将常量作为参数传递给“按非const引用传递”的函数:</p>
<blockquote>
<p>使用“按const引用传递”或“按右值引用传递”，可将常量作为参数传递给函数。</p>
</blockquote>
<h4 id="将指针转换为引用"><a href="#将指针转换为引用" class="headerlink" title="将指针转换为引用"></a>将指针转换为引用</h4><p>某个函数或方法需要以一个引用作为参数，而你拥有一个指向被传递值的指针，在此情况下，可对指针解除引用(dereferencing)，将指针“转换”为引用。这一行为会给出指针所指的值，随后编译器用这个值初始化引用参数。例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">5</span>, y = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">int</span>* xp = &amp;x, *yp = &amp;y;</span><br><span class="line">swap(*xp, *yp);</span><br></pre></td></tr></table></figure></p>
<h4 id="按引用传递与按值传递"><a href="#按引用传递与按值传递" class="headerlink" title="按引用传递与按值传递"></a>按引用传递与按值传递</h4><p>按引用传递不需要将参数的副本复制到函数，在有些情况下这会带来两方面的好处。</p>
<ol>
<li>效率：复制较大的对象或结构需要较长时间。按引用传递只是把指向对象或结构的指针传递给函数。</li>
<li>正确性：并非所有对象都允许按值传递，即使允许按值传递的对象，也可能不支持正确的深度复制(deep copying)。第9章提到，为支持深度复制，动态分配内存的对象必须提供自定义复制构造函数或复制赋值运算符。</li>
</ol>
<p>如果要利用这些好处，但不想修改原始对象，可将参数标记为const，从而实现按常量引用传递参数。</p>
<h3 id="将引用作为返回值"><a href="#将引用作为返回值" class="headerlink" title="将引用作为返回值"></a>将引用作为返回值</h3><p>还可让函数或方法返回一个引用。这样做的主要原因是为了提高效率。返回对象的引用而不是返回整个对象可避免不必要的复制。当然，只有涉及的对象在函数终止之后仍然存在的情况下才能使用。</p>
<blockquote>
<p>如果变量的作用域局限于函数或方法(例如堆栈中自动分配的变量，在函数结束时会被销毁)，绝不能返回这个变量的引用。</p>
</blockquote>
<p>如果从函数返回的类型支持移动语义，按值返回就几乎与返回引用一样高效。</p>
<p>返回引用的另一个原因是希望将返回值直接赋为左值(lvalue)(赋值语句的左边)。一些重载的运算符通常会返回引用。</p>
<h3 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h3><p>右值(rvalue)就是非左值(Ivalue)，例如常量值、临时对象或值。通常而言，右值位于赋值运算符的右侧：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lvalue reference parameter</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>&amp; message)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"handleMessage with lvalue reference: "</span>&lt;&lt; message &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于这个<code>handleMessage()</code>版本，不能采用如下方式调用它:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">handleMessage(<span class="string">"Hello World"</span>); <span class="comment">// A literal is not an lvalue.</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> a = <span class="string">"Hello "</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> b = <span class="string">"World"</span>;</span><br><span class="line">handleMessage(a + b); <span class="comment">// A temporary is not an 1value .</span></span><br></pre></td></tr></table></figure></p>
<p>要支持此类调用，需要一个接收右值引用的版本:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// rvalue reference parameter</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handleMessage</span> <span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>&amp;&amp; message )</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"handleMessage with rvalue reference: "</span> &lt;&lt; message &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="使用引用还是指针"><a href="#使用引用还是指针" class="headerlink" title="使用引用还是指针"></a>使用引用还是指针</h3><p>引用比指针安全，不可能存在无效引用，也不需要显式地解除引用，因此不会遇到像指针那样的解除引用问题。</p>
<p>大多数情况下，应该使用引用而不是指针。对象的引用甚至可像指向对象的指针那样支持多态性。但也有一些情况要求使用指针，一个例子是更改指向的位置，因为无法改变引用所指的变量。例如，动态分配内存时，应该将结果存储在指针而不是引用中。</p>
<p>需要使用指针的另一种情况是可选参数，即指针参数可以定义为带默认值nullptr的可选参数，而引用参数不能这样定义。还有一种情况是要在容器中存储多态类型。</p>
<p>有一种方法可以判断使用指针还是引用作为参数和返回类型：考虑谁拥有内存。如果接收变量的代码负责释放相关对象的内存，那么必须使用指向对象的指针，最好是智能指针，这是传递拥有权的推荐方式。如果接收变量的代码不需要释放内存，那么应该使用引用。</p>
<p>考虑将一个int数组分割为两个数组的函数：一个是偶数数组；另一个是奇数数组。这个函数并不知道源数组中有多少奇数和偶数，因此只有在检测完源数组后，才能为目标数组动态分配内存，此外还需要返回这两个新数组的大小。因此总共需要返回4项：指向两个新数组的指针和两个新数组的大小。显然必须使用按引用传递，用规范的C语言方式编写的这个函数如下所示:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">separateOddsAndEvens</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> arr[], <span class="keyword">size_t</span> size, <span class="keyword">int</span>** odds, <span class="keyword">size_t</span>* numOdds, <span class="keyword">int</span>** evens, <span class="keyword">size_t</span>* numEvens)</span></span></span><br></pre></td></tr></table></figure></p>
<p>如果要调用<code>separateOddsAndEvens()</code>，就必须传递两个指针的地址，这样函数才能修改实际的指针，还必须传递两个int值的地址，这样函数才能修改实际的int值。另外注意，主调方负责删除由<code>separateOddsAndEvens()</code>创建的两个数组！</p>
<p>如果觉得这种语法很难理解(应该是这样的)，可以用引用实现真正的按引用传递，如下所示:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">separateOddsAndEvens</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> arr[], <span class="keyword">size_t</span> size, <span class="keyword">int</span>*&amp; odds, <span class="keyword">size_t</span>&amp; numOdds, <span class="keyword">int</span>*&amp; evens, <span class="keyword">size_t</span>&amp; numEvens)</span></span></span><br></pre></td></tr></table></figure></p>
<p>在此情况下, adds和evens参数是指向<code>int*</code>的引用。<code>separateOddsAndEvens()</code>可以修改用作函数参数的<code>int*</code>(通过引用)，而不需要显式地解除引用。使用这个版本的函数时，不再需要传递指针或int值的地址，引用参数会自动进行处理：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">separateOddsAndEvens(unSplit, <span class="built_in">std</span>::size(unSplit), oddNums，numOdds, evenNums, numEvens);</span><br></pre></td></tr></table></figure></p>
<h2 id="关键字的疑问"><a href="#关键字的疑问" class="headerlink" title="关键字的疑问"></a>关键字的疑问</h2><h3 id="const-关键字"><a href="#const-关键字" class="headerlink" title="const 关键字"></a>const 关键字</h3><p>const是constant的缩写，指保持不变的量。任何尝试改变常量的行为都会被当作错误处理。此外，当启用优化时，编译器可利用此信息生成更好的代码。关键字const有两种相关的用法。可以用这个关键字标记变量或参数，也可以用其标记方法。</p>
<h4 id="const-变量和参数"><a href="#const-变量和参数" class="headerlink" title="const 变量和参数"></a>const 变量和参数</h4><p>可使用const来“保护”变量不被修改。这个关键字的一个重要用法是替换<code>#define</code>来定义常量，这是const最直接的应用。例如，可以这样声明常量PI:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="number">3.141592653589793238462</span>;</span><br></pre></td></tr></table></figure></p>
<p>可将任何变量标记为const，包括全局变量和类数据成员。</p>
<p>还可使用const指定函数或方法的参数保持不变。例如，下面的函数接收一个const参数。在函数体内，不能修改整数param。如果试图修改这个变量，编译器将生成错误。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> param)</span></span></span><br></pre></td></tr></table></figure></p>
<p>下面详细讨论两种特殊的const变量或参数:const指针和const引用。</p>
<h5 id="const指针"><a href="#const指针" class="headerlink" title="const指针"></a>const指针</h5><p>当变量通过指针包含一层或多层间接取值时，const的应用将变得十分微妙。考虑下面的代码行:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* ip;</span><br><span class="line">ip = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">ip[<span class="number">4</span>] = <span class="number">5</span>;</span><br></pre></td></tr></table></figure></p>
<p>为阻止修改所指的值，可在ip的声明中这样添加关键字const:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* ip;</span><br><span class="line">ip = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">ip[<span class="number">4</span>] = <span class="number">5</span>;</span><br></pre></td></tr></table></figure></p>
<p>下面是在语义上等价的另一种方法，将const放在int的前面还是后面并不影响其功能。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="keyword">const</span>* ip;</span><br><span class="line">ip[<span class="number">4</span>] = <span class="number">5</span>; <span class="comment">// DOES NOT COMPILE!</span></span><br></pre></td></tr></table></figure></p>
<p>如果要将ip本身标记为const(而不是ip所指的值)，可以这样做:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* <span class="keyword">const</span> ip = <span class="literal">nullptr</span>;</span><br><span class="line">ip = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]; <span class="comment">// DOES NOT COMPILE !</span></span><br><span class="line">ip[<span class="number">4</span>] = <span class="number">5</span>; <span class="comment">// Error: dereferencing a null pointer</span></span><br></pre></td></tr></table></figure></p>
<p>现在ip本身无法修改，编译器要求在声明ip时就执行初始化，可以使用前面代码中的nullptr，也可以使用新分配的内存，如下所示:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* <span class="keyword">const</span> ip = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">ip[<span class="number">4</span>] = <span class="number">5</span>;</span><br></pre></td></tr></table></figure></p>
<p>还可将指针和所指的值全部标记为const，如下所示:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="keyword">const</span>* <span class="keyword">const</span> ip = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* <span class="keyword">const</span> ip = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure></p>
<p>尽管这些语法看上去有点混乱，但规则实际上非常简单：<strong>将const 关键字应用于直接位于它左边的任何内容</strong>。再次考虑这一行：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="keyword">const</span>* <span class="keyword">const</span> ip = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure></p>
<p>从左到右，第一个const直接位于int的右边，因此将const应用到ip所指的int，从而指定无法修改ip所指的值。第二个const直接位于*的右边，因此将const应用于指向int变量的指针，也就是ip变量。因此，无法修改ip(指针)本身。</p>
<blockquote>
<p>还有一种易于记忆的、用于指出复杂变量声明的规则：从右向左读。考虑示例<code>int* const ip</code>。从右向左读这条语句，就可以知道<strong>ip是一个指向int值的const指针</strong>。另外，<code>int const* ip</code>读作<strong>ip 是一个指向const int的指针</strong>。</p>
</blockquote>
<h5 id="const引用"><a href="#const引用" class="headerlink" title="const引用"></a>const引用</h5><p>将const应用于引用通常比应用于指针更简单，原因有两个。首先，引用默认为const，无法改变引用所指的对象。因此，不必显式地将引用标记为const。其次，无法创建指向引用的引用，所以引用通常只有一层间接取值。获取多层间接取值的唯一方法是创建指向指针的引用。</p>
<p>因此，C++程序员提到“const 引用”时，含义如下所示:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> z;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; zRef = z;</span><br><span class="line">zRef = <span class="number">4</span>; <span class="comment">// DOES NOT COMPILE</span></span><br></pre></td></tr></table></figure></p>
<p>由于将const应用到int，因此无法对zRef赋值，如前所示。与指针类似，<code>const int&amp; zRef</code>等价于<code>int const&amp; zRef</code>。然而要注意，将zRef标记为const对z没有影响。仍然可以修改z的值，具体做法是直接改变z，而不是通过引用。</p>
<p>const引用经常用作参数，这非常有用。如果为了提高效率，想按引用传递某个值，但不想修改这个值，可将其标记为const引用。例如:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span> <span class="params">(<span class="keyword">const</span> BigClass&amp; arg)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// Implementation here</span></span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>将对象作为参数传递时，默认选择是const引用。只有在明确需要修改对象时，才能忽略const。</p>
</blockquote>
<h5 id="const方法"><a href="#const方法" class="headerlink" title="const方法"></a>const方法</h5><p>可将类方法标记为const，以禁止方法修改类的任何非可变(non-mutable)数据成员。</p>
<h5 id="constexpr关键字"><a href="#constexpr关键字" class="headerlink" title="constexpr关键字"></a>constexpr关键字</h5><p>在某些情况下需要常量表达式。例如当定义数组时，数组的大小就必须是一个常量表达式。由于这一限制，下面的代码在C++中是无效的:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span> <span class="title">getArraySize</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">32</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> myArray [getArraySize()]; <span class="comment">// Invalid in C++</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可使用constexpr关键字重新定义<code>getAraySize()</code>函数，把它变成常量表达式。<strong>常量表达式在编译时计算</strong>。</p>
<p>将函数声明为constexpr会对函数的行为施加一些限制， 因为编译器必须在编译期间对constexpr函数求值，函数也不允许有任何副作用。下面是几个限制： </p>
<ul>
<li>函数体不包含goto语句、try catch块、未初始化的变量、非字面量类型的变量定义，也不抛出异常，但可调用其他constexpr 函数。<ul>
<li>“字面量类型”(literal type)是<code>constexpr</code>变量的类型，可从constexpr函数返回。</li>
<li>字面量类型可以是void(可能有const、volatile限定符)、标量类型(整型和浮点类型、枚举类型、指针类型、成员指针类型，这些类型有const/volatile 限定符)、引用类型、字面量数组类型或类类型。</li>
<li>类类型可能也有const、volatile限定符，具有普通的(即非用户提供的)析构函数，至少有一个constexpr构造函数，所有非静态数据成员和基类都是字面量类型。</li>
</ul>
</li>
<li>函数的返回类型应该是字面量类型。</li>
<li>如果constexpr函数是类的一个成员，那么这个函数不能是虚函数。</li>
<li>函数所有的参数都应该是字面量类型。</li>
<li>在编译单元(ranslation unit)中定义了constexpr函数后，才能调用这个函数，因为编译器需要知道完整的定义。</li>
<li>不允许使用<code>dynamic_cast()</code>和<code>reinterpret_cast()</code>。</li>
<li>不允许使用new和delete表达式。</li>
</ul>
<p>通过定义constexpr构造函数，可创建用户自定义类型的常量表达式变量。constexpr构造函数具有很多限制，其中的一些限制如下所示:</p>
<ul>
<li>类不能具有任何虚基类。</li>
<li>构造函数的所有参数都应该是字面量类型。</li>
<li>构造函数体不应该是function-try-block。</li>
<li>构造函数体应该满足与constexpr函数体相同的要求，并显式设置为默认(=default)。</li>
<li>所有数据成员都应该用常量表达式初始化。</li>
</ul>
<h3 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h3><h4 id="静态数据成员和方法"><a href="#静态数据成员和方法" class="headerlink" title="静态数据成员和方法"></a>静态数据成员和方法</h4><p>可声明类的静态数据成员和方法。静态数据成员不是对象的一部分，这个数据成员只有一个副本，这个副本存在于类的任何对象之外。静态方法与此类似，位于类层次(而不是对象层次)。静态方法不会在某个特定对象环境中执行。</p>
<h4 id="静态链接-static-linkage"><a href="#静态链接-static-linkage" class="headerlink" title="静态链接(static linkage)"></a>静态链接(static linkage)</h4><p>默认情况下，函数和全局变量都拥有外部链接。然而，可在声明的前面使用关键字static指定内部(或静态)链接。如果<code>f()</code>函数具有内部(静态)链接，另一个文件无法使用这个函数。如果在源文件中定义了静态方法但是没有使用它，有些编译器会给出警告(指出这些方法不应该是静态的，因为其他文件可能会用到它们)。</p>
<p>将static用于内部链接的另一种方式是使 用匿名名称空间(anonymous namespaces)。可将变量或函数封装到一个没有名字的名称空间，而不是使用static，如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"f\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在同一源文件中，可在声明匿名名称空间之后的任何位置访问名称空间中的项，但不能在其他源文件中访问。这一语义与static关键字相同。</p>
<h5 id="extern关键字"><a href="#extern关键字" class="headerlink" title="extern关键字"></a>extern关键字</h5><p>extern关键字将它后面的名称指定为外部链接。某些情况下可使用这种方法。例如，const和typedef在默认情况下是内部链接，可使用extern使其变为外部链接。然而，extern有一点复杂。当指定某个名称为extern时，编译器将这条语句当作声明而不是定义。对于变量而言，这意味着编译器不会为这个变量分配空间。必须为这个变量提供单独的、不使用extern关键字的定义行。例如，下面是AnotherFile.cpp的内容:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">3</span>;</span><br></pre></td></tr></table></figure></p>
<p>也可在extern行初始化x，这一行既是声明又是定义:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> x = <span class="number">3</span>;</span><br></pre></td></tr></table></figure></p>
<p>这种情形下的extern并不是非常有用，因为x默认具有外部链接。当另一个源文件FirstFile.cpp使用x时，才会真正用到extern:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> x;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>FirstFile.cpp 使用了extern 声明，因此可使用x。编译器需要知道x的声明，才能在<code>main()</code>函数中使用这个变量。然而，如果声明x时未使用extern关键字，编译器会认为这是定义，因而会为x分配空间，导致链接步<br>骤失败(因为有两个全局作用域的x变量)。使用extern，就可在多个源文件中全局访问这个变量。</p>
<h5 id="函数中的静态变量"><a href="#函数中的静态变量" class="headerlink" title="函数中的静态变量"></a>函数中的静态变量</h5><p>C++中static关键字的最终目的是创建离开和进入作用域时都可保留值的局部变量。函数中的静态变量就像只能在函数内部访问的全局变量。静态变量最常见的用法是“记住”某个函数是否执行了特定的初始化操作。</p>
<h3 id="非局部变量的初始化顺序"><a href="#非局部变量的初始化顺序" class="headerlink" title="非局部变量的初始化顺序"></a>非局部变量的初始化顺序</h3><p>程序中所有的全局变量和类的静态数据成员都会在<code>main()</code>函数开始之前初始化。给定源文件中的变量以在源文件中出现的顺序初始化。例如，在下面的文件中，<code>Demo::x</code>一定会在y之前初始化：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> Demo::x = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> y = <span class="number">34</span>;</span><br></pre></td></tr></table></figure></p>
<p>然而，C++没有提供规范，用以说明在不同源文件中初始化非局部变量的顺序。如果在某个源文件中有一个全局变量x，在另一个源文件中有一个全局变量y，无法知道哪个变量先初始化。如果某个全局变量或静态变量依赖于另一个变量，这两个全局对象在不同的源文件中声明，就不能指望一个全局对象在另一个全局对象之前构建，也无法控制它们的初始化顺序。不同编译器可能有不同的初始化顺序，即使同一编译器的不同版本也可能如此。</p>
<blockquote>
<p>不同源文件中非局部变量的初始化顺序是不确定的。</p>
</blockquote>
<h3 id="非局部变量的销毁顺序"><a href="#非局部变量的销毁顺序" class="headerlink" title="非局部变量的销毁顺序"></a>非局部变量的销毁顺序</h3><p>非局部变量按初始化的逆序进行销毁。不同源文件中非局部变量的初始化顺序是不确定的，所以销毁顺序也是不确定的。</p>
<h2 id="类型和类型转换"><a href="#类型和类型转换" class="headerlink" title="类型和类型转换"></a>类型和类型转换</h2><h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><p>类型别名为现有的类型声明提供了新名称。下面为<code>int*</code>类型声明指定新名称IntPtr：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> IntPtr = <span class="keyword">int</span>*;</span><br></pre></td></tr></table></figure></p>
<p>类型别名最常见的用法是当实际类型的声明过于笨拙时，提供易于管理的名称。标准库广泛使用类型别名来提供类型的简短名称。例如，std:string实际上就是这样一个类型别名：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="built_in">string</span> = basic_string&lt;<span class="keyword">char</span>&gt;;</span><br></pre></td></tr></table></figure></p>
<h3 id="函数指针的类型别名"><a href="#函数指针的类型别名" class="headerlink" title="函数指针的类型别名"></a>函数指针的类型别名</h3><p>在C++中，可使用函数的地址，就像使用变量那样。函数指针的类型取决于兼容函数的参数类型的返回类型。处理函数指针的一种方式是使用类型别名。类型别名允许将一个类型名指定给具有指定特征的一系列函数。 例如，下面的代码行定义了MatchFunction类型，该类型表示一个指针，这个指针指向具有两个int参数并返回布尔值的任何函数:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> MatchFunction = <span class="keyword">bool</span>(*) (<span class="keyword">int</span>, <span class="keyword">int</span>);</span><br></pre></td></tr></table></figure></p>
<p>有了这个新类型，可编写将MatchFunction作为参数的函数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findMatches</span><span class="params">(<span class="keyword">int</span> values1[], <span class="keyword">int</span> values2[], <span class="keyword">size_t</span> numValues, MatchFunction matcher)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; numValues; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (matcher (values1[i]，values2[i]) &#123;</span><br><span class="line">            <span class="comment">// ......</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用函数指针，可根据matcher参数自定义单个<code>findMatches()</code>函数的功能。</p>
<blockquote>
<p>如果不使用这些旧式的函数指针，还可以使用<code>stl::function</code>。</p>
</blockquote>
<h3 id="方法和数据成员的指针的类型别名"><a href="#方法和数据成员的指针的类型别名" class="headerlink" title="方法和数据成员的指针的类型别名"></a>方法和数据成员的指针的类型别名</h3><p>在C++中，取得类成员和方法的地址，获得指向它们的指针是完全合法的。但不能访问非静态成员，也不能在没有对象的情况下调用非静态方法。类数据成员和方法完全依赖于对象的存在。因此，通过指针调用方法或访问数据成员时，一定要在对象的上下文中解除对指针的引用。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Employee employee;</span><br><span class="line"><span class="keyword">int</span> (Employee::*methodPtr) () <span class="keyword">const</span> = &amp;Employee::getSalary;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (employee.*methodPtr) () &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p>
<p>不必担心上述语法。第二行声明了一个指针类型的变量methodPtr，该指针指向Employee类的一个非静态const方法，这个方法不接收参数并返回一个int值。同时，这行代码将这个变量初始化为指向Employee类的<code>getSalary()</code>方法。这种语法和声明简单函数指针的语法非常类似，只不过在<code>*methodPtr</code>的前面添加了<code>Employee::</code>。还要注意，在这种情况下需要使用&amp;。</p>
<p>第3行代码调用employee对象的<code>getSalary()</code>方法(通过<code>methodPtr</code>指针)。注意在<code>employlee.*methodPtr</code>的周围使用了括号。</p>
<p>可通过类型别名简化第二行代码:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Employee employee;</span><br><span class="line"><span class="keyword">using</span> PtrToGet = <span class="keyword">int</span> (Employee::*) () <span class="keyword">const</span>;</span><br><span class="line">PtrToGet methodPtr = &amp;Employee::getSalary;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (employee.*methodPtr) () &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p>
<p>使用auto可进一步简化:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Employee employee;</span><br><span class="line"><span class="keyword">auto</span> methodPtr = &amp;Employee::getSalary;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (employee.*methodPtr)() &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p>
<p>方法和数据成员的指针通常不会出现在程序中。然而，要记住，<strong>不能在没有对象的情况下解除对非静态方法或数据成员的指针的引用</strong>。C++允许在没有对象的情况下解除对静态方法或静态数据成员的指针的引用。</p>
<h3 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a>typedef</h3><p>与类型别名一样，typedef为已有的类型声明提供新名称。例如，使用以下类型别名:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> IntPtr = <span class="keyword">int</span>*;</span><br></pre></td></tr></table></figure></p>
<p>如果不使用类型别名，就必须使用如下typedef:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span>* IntPtr;</span><br></pre></td></tr></table></figure></p>
<p>在引入类型别名之前，必须为函数指针使用typedef，这更复杂。例如，对于以下类型别名:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> FunctionType = <span class="keyword">int</span> (*) (<span class="keyword">char</span>, <span class="keyword">double</span>);</span><br></pre></td></tr></table></figure></p>
<p>如果用typedef定义相同的FunctionType， 形式将如下:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*FunctionType)</span> <span class="params">(<span class="keyword">char</span>, <span class="keyword">double</span>)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>类型别名和typedef并非完全等效。与typedef相比，类型别名与模板一起使用时功能更强大。</p>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>C++还提供了4种类型转换：<code>const_cast()</code>、<code>static_cast()</code>、<code>reinterpret_cast()</code>和<code>dynamic_cast()</code>。使用<code>()</code>的C风格类型转换在C++中仍然有效。</p>
<h4 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast()"></a>const_cast()</h4><p><code>const_cast()</code>最直接，可用于给变量添加常量特性，或去掉变量的常量特性。这是上述4种类型转换中唯可舍弃常量特性的类型转换。当然从理论上讲，并不需要const类型转换。如果某个变量是const，那么应该一直是const。然而实际中，有时某个函数需要采用const变量，但必须将这个变量传递给采用非const变量作为参数的函数。因此，有时需要舍弃变量的常量特性，但只有在确保调用的函数不修改对象的情况下才能这么做，否则就只能重新构建程序。下面是一个示例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">ThirdPartyLibraryMethod</span><span class="params">(<span class="keyword">char</span>* str)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span></span></span><br><span class="line"><span class="function"><span class="title">ThirdPartyLibraryMethod</span><span class="params">(<span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>*&gt;(str))</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>从C++17开始，<code>&lt;utility&gt;</code>中定义了一个辅助方法<code>std:as_const()</code>，该方法返回引用参数的const引用版本。<code>as_const(obj)</code>基本上等同于<code>const_cast&lt;const T&amp;&gt;(obj)</code>，其中，T的类型为obj。可以看到，与使用<code>const_cast()</code>相比，使用<code>as_const()</code>更简短。示例如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> str = <span class="string">"C++"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; constStr = <span class="built_in">std</span>::as_const(str);</span><br></pre></td></tr></table></figure></p>
<p>将<code>as_const()</code>与<code>auto</code>一起使用时要保持警惕。auto将去除引用和const限定符!因此，下面的result变量具有类型<code>std::string</code>而非<code>const std:string&amp;</code>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> result = <span class="built_in">std</span>::as_const(str);</span><br></pre></td></tr></table></figure></p>
<h4 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast()"></a>static_cast()</h4><p>可使用<code>static_cast()</code>显式地执行C++语言直接支持的转换。例如，如果编写了一个算术表达式，其中需要将int转换为double以避免整除，可以使用<code>static_cast()</code>。 </p>
<p>如果用户定义了相关的构造函数或转换例程，也可使用<code>static_cast()</code>执行显式转换。例如，如果类A的构造函数将类B的对象作为参数，就可使用<code>static_cast()</code>将B对象转换为A对象。许多情况下都需要这一行为，然而编译器会自动执行这个转换。</p>
<p><code>static_cast()</code>的另一种用法是在继承层次结构中执行向下转换。例如:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~Base() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~Derived() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* b;</span><br><span class="line">    Derived* d = <span class="keyword">new</span> Derived();</span><br><span class="line">    b = d; <span class="comment">// Don't need a cast to go up the inheritance hierarchy</span></span><br><span class="line">    d = <span class="keyword">static_cast</span>&lt;Derived*&gt;(b); <span class="comment">// Need a cast to go down the hierarchy</span></span><br><span class="line"></span><br><span class="line">    Base base;</span><br><span class="line">    Derived derived;</span><br><span class="line">    Base&amp; br = derived;</span><br><span class="line">    Derived&amp; dr = <span class="keyword">static_cast</span>&lt;Derived&amp;&gt; (br) ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种类型转换可以用于指针和引用，而不适用于对象本身。</p>
<p>注意<code>static_cast()</code>类型转换不执行运行期间的类型检测。它允许将任何Base指针转换为Derived指针，或将Base引用转换为Derived引用，哪怕在运行时Base对象实际上并不是Derived对象，也是如此。例如，下面的代码可以编译并执行，但使用指针d可能导致灾难性结果，包括内存重写超出对象的边界。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Base* b = <span class="keyword">new</span> Base() ;</span><br><span class="line">Derived* d = <span class="keyword">static_cast</span>&lt;Derived*&gt;(b);</span><br></pre></td></tr></table></figure></p>
<p>使用<code>static_cast()</code>无法将某种类型的指针转换为不相关的其他类型的指针。如果没有可用的转换构造函数，<code>static_cast()</code>无法将某种类型的对象直接转换为另一种类型的对象。</p>
<h4 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast()"></a>reinterpret_cast()</h4><p><code>reinterpret_cast()</code>的功能比<code>static_cast()</code>更强大，同时安全性更差。这种用法经常用于将指针转换为<code>void*</code>；这可隐式完成，不需要进行显式转换。但将<code>void*</code>转换为正确类型的指针需要<code>reinterpret_cast()</code>。<code>void*</code>指针指向内存的某个位置。<code>void*</code>指针没有相关的类型信息。下面是一些示例:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Y</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    X x;</span><br><span class="line">    Y y;</span><br><span class="line">    X* xp = &amp;x;</span><br><span class="line">    Y* yp = &amp;y;</span><br><span class="line">    <span class="comment">// Need reinterpret cast for pointer conversion from unrelated classes</span></span><br><span class="line">    <span class="comment">// static_cast doesn't work.</span></span><br><span class="line">    xp = <span class="keyword">reinterpret_cast</span>&lt;X*&gt;(yp);</span><br><span class="line">    <span class="comment">// No cast required for conversion from pointer to void*</span></span><br><span class="line">    <span class="keyword">void</span>* p = xp;</span><br><span class="line">    <span class="comment">// Need reinterpret cast for pointer conversion from void*</span></span><br><span class="line">    xp = <span class="keyword">reinterpret_cast</span>&lt;X*&gt;(p) ;</span><br><span class="line">    <span class="comment">// Need reinterpret cast for reference conversion from unrelated classes</span></span><br><span class="line">    <span class="comment">// static_cast doesn't work.</span></span><br><span class="line">    X&amp; xr = x;</span><br><span class="line">    Y&amp; yr = <span class="keyword">reinterpret_cast</span>&lt;Y&amp;&gt;(x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>reinterpret_cast()</code>的一种用法是与普通可复制类型的二进制I/O起使用。所谓普通可复制类型，是指<strong>构成对象的基础字节的类型可复制到数组中</strong>。如果此后要将数组的数据复制回对象，对象将保持其原始值。例如，可将这种类型的单独字节写入文件中。将文件读入内存时，可使用<code>reinterpret_cast()</code>来正确地解释从文件读入的字节。</p>
<h4 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast()"></a>dynamic_cast()</h4><p><code>dynamic_cast()</code>为继承层次结构内的类型转换提供运行时检测。可用它转换指针或引用。<code>dynamic_cast()</code>在运行时检测底层对象的类型信息。如果类型转换没有意义，<code>dynamic_cast()</code>将返回一个空指针(用于指针)或抛出一个<code>stl::bad_cast</code>异常(用于引用)。例如，下面用于引用的<code>dynamic_cast()</code>将拋出一个异常：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Base base;</span><br><span class="line">Derived derived;</span><br><span class="line">Base&amp; br = base;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Derived&amp; dr = <span class="keyword">dynamic_cast</span>&lt;Derived&amp;&gt;(br);</span><br><span class="line">&#125; <span class="keyword">catch</span> (<span class="keyword">const</span> bad_cast&amp;) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Bad cast!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意可使用<code>static_cast()</code>或<code>reinterpret_cast()</code>沿着继承层次结构向下执行同样的类型转换。<code>dynamic_cast()</code>的不同之处在于它会执行运行时(动态)类型检测，而<code>static_cast()</code>和<code>reinterpret_cast()</code>甚至会执行不正确的类型转换。因此，为使用<code>dynamic_cast()</code>，类至少要有一个虚方法。如果类不具有虚表，尝试使用<code>dynamic_cast()</code>将导致编译错误。</p>
<h4 id="类型转换总结"><a href="#类型转换总结" class="headerlink" title="类型转换总结"></a>类型转换总结</h4><p>表11-1总结了不同情形下应该使用的类型转换。<br><img src="/img/1619420180.jpg" alt></p>
<h2 id="作用域解析"><a href="#作用域解析" class="headerlink" title="作用域解析"></a>作用域解析</h2><p>可使用名称空间、函数定义、花括号界定的块和类定义创建作用域。在一个for循环的初始化语句中，初始化的变量的作用域仅限于这个for循环，在这个for循环之外不可见。当试图访问某个变量、函数或类时，首先在最近的作用域内查找这个名称，然后查找相邻的作用域，以此类推，直到全局作用域。任何不在名称空间、函数、花括号界定的块和类中的名称都被认为在全局作用域内。如果在全局作用域内也找不到这个名称，编译器会给出未定义符号错误。</p>
<p>有时某个作用域内的名称会隐藏其他作用域内的同一名称。在另一些情况下，程序的特定行中的默认作用域解析并不包含需要的作用域。如果不想用默认的作用域解析某个名称，就可以使用作用域解析运算符::和特定的作用域限定这个名称。例如，为访问类的静态方法，第一种方法是将类名(方法的作用域)和作用域解析运算符放在方法名的前面，第二种方法是通过类的对象访问这个静态方法。下例演示了这两种方法。这个示例定义了一个具有静态方法<code>get()</code>的Demo类、一个具有全局作用域的<code>get()</code>函数以及一个位于NS名称空间的<code>get()</code>函数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">5</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">10</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> NS &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">20</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>全局作用域没有名称，但可使用作用域解析运算符本身(没有名称前缀)来访问。可采用以下方式调用不同的<code>get()</code>函数。在这个示例中，代码本身在<code>main()</code>函数中，<code>main()</code>函数总是位于全局作用域内:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> pd = <span class="built_in">std</span>::make_unique&lt;Demo&gt;();</span><br><span class="line">    Demo d;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; pd-&gt;get() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// prints 5</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; d.get() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// prints 5</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; NS::get() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// prints 20</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; Demo::get() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// prints 5</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ::get() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// prints 10</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; get() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// prints 10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意，如果NS名称空间是一个匿名名称空间，下面的行将导致名称解析歧义错误，因为在全局作用域内定义了一个<code>get()</code>函数，在匿名名称空间中也定义了一个<code>get()</code>函数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; get() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p>
<p>如果在<code>main()</code>函数之前使用using子句，也会发生同样的错误:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> NS;</span><br></pre></td></tr></table></figure></p>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p>特性(ttribute)是在源代码中添加可选信息(或者供应商指定的信息)的一种机制。 在C++11之前，供应商决定如何指定这些信息，例如<code>__atribute__</code>和<code>__declspec</code>等。自C++11以后，使用两个方括号语法<code>[[attribute]]</code>支持特性。C++标准只定义了6个标准特性。</p>
<h3 id="noreturn-特性"><a href="#noreturn-特性" class="headerlink" title="[[noreturn]]特性"></a>[[noreturn]]特性</h3><p><code>[[noreturm]]</code>意味着函数永远不会将控制交还调用点。典型情况是函数导致某种终止(进程终止或线程终止)或者抛出异常。使用该特性，编译器可避免给出某种警告或错误，因为它现在对函数的意图了解更多。下面是<br>一个例子:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[[noreturn]] <span class="function"><span class="keyword">void</span> <span class="title">forceProgramTermination</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isDongleAvailable</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> isAvailable = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// Check whether a licensing dongle is available...</span></span><br><span class="line">    <span class="keyword">return</span> isAvailable;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isFeatureLicensed</span><span class="params">(<span class="keyword">int</span> featureId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isDongleAvailable())</span><br><span class="line">        <span class="comment">// No licensing dongle found, abort program execution! </span></span><br><span class="line">        forceProgramTermination() ;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">bool</span> isLicensed = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// Dongle available, perform license check of the given feature...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isLicensed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个代码片段可正常编译，不会发出任何警告或错误。但如果删除<code>[[noretum]]</code>特性，编译器将生成以下警告消息:<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">warning C4715: ' isFeatureLicensed': not all control paths return a value</span><br></pre></td></tr></table></figure></p>
<h3 id="deprecated-特性"><a href="#deprecated-特性" class="headerlink" title="[[deprecated]]特性"></a>[[deprecated]]特性</h3><p><code>[[deprecated]]</code>特性可用于把某个对象标记为废弃，表示仍可以使用，但不鼓励使用。这个特性接收一个可选参数，可用于解释废弃的原因，例如:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[deprecated (<span class="string">"Unsafe method, please use xyz"</span>)]] <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>如果使用这个特性，将看到编译错误或警告。例如，GCC会给出以下警告消息:<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">warning: 'void func()' is deprecated: Unsafe method, please use xyz</span><br></pre></td></tr></table></figure></p>
<h3 id="allthrough-特性"><a href="#allthrough-特性" class="headerlink" title="[[allthrough]]特性"></a>[[allthrough]]特性</h3><p>从C++17开始，可使用<code>[[allthrough]]</code>特性告诉编译器：在switch语句中，fall through是有意安排的。如果没有指定该特性，用以说明这是有意为之的，编译器将给出警告消息。不需要为空的case分支指定这个特性。例如:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (backgroundColor) &#123;</span><br><span class="line">    <span class="keyword">case</span> Color::DarkBlue:</span><br><span class="line">        doSomethingForDarBlue();</span><br><span class="line">        [[fallthrough]];</span><br><span class="line">    <span class="keyword">case</span> Color::Black:</span><br><span class="line">        <span class="comment">// Code is executed for both a dar blue or black background color</span></span><br><span class="line">        doSomethingForBlackOrDarkBlue();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> Color::Red:</span><br><span class="line">    <span class="keyword">case</span> Color::Green:</span><br><span class="line">        <span class="comment">// Code to execute for a red or green background color</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="nodiscard-特性"><a href="#nodiscard-特性" class="headerlink" title="[[nodiscard]]特性"></a>[[nodiscard]]特性</h3><p><code>[[nodiscard]]</code>特性可用于返回值的函数，如果函数什么也没做，还返回值，编译器将发出警告消息。下面是一个示例:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[[nodiscard]] <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    func();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译器将给出如下警告消息:<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">warning C4834: discarding return value of function with 'nodiscard' attribute</span><br></pre></td></tr></table></figure></p>
<p>例如，可将这个特性用于返回错误代码的函数。通过给此类函数添加<code>[[nodiscard]]</code>特性，将无法忽略错误代码。</p>
<h3 id="maybe-unused-特性"><a href="#maybe-unused-特性" class="headerlink" title="[[maybe_unused]]特性"></a>[[maybe_unused]]特性</h3><p>如果未使用某项，[[maybe_unused]]特性可用于阻止编译器发出警告消息:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span> <span class="params">(<span class="keyword">int</span> param1, [[maybe_unused]] <span class="keyword">int</span> param2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里给第二个参数标记了<code>[[maybe__unused]]</code>特性。编译器将只为param1显示警告消息:<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">warning C4100: 'param1': unreferenced formal parameter</span><br></pre></td></tr></table></figure></p>
<h2 id="用户定义的字面量"><a href="#用户定义的字面量" class="headerlink" title="用户定义的字面量"></a>用户定义的字面量</h2><p>C++有许多可在代码中使用的标准字面量(iteral)，如下所示。</p>
<ul>
<li>‘a’: 字符</li>
<li>“character array”:以0结尾的字符数组(C风格的字符串)</li>
<li>3.14f: 浮点数</li>
<li>0xabc: 十六进制值</li>
</ul>
<p>C++11允许定义自己的字面量。用户定义的字面量应该以下划线开头，下划线之后的第一个字符必须小写，例如<code>_i</code>、<code>_s</code>、<code>_km</code>和<code>miles</code>等。可通过编写字面量运算符(literal operators)来实现。 字面量运算符能以生(raw)模式或熟(cooked)模式运行。在生模式中，字面量运算符接收一个字符序列；在熟模式中，字面量运算符接收一种经过解释的特定类型。例如，考虑C++字面量<code>123</code>。生模式字面量运算符会将其作为字符<code>1</code>、<code>2</code>、<code>3</code>，而熟模式字面量运算符会将其作为整数<code>123</code>。</p>
<p>另一个示例:考虑C++字面量<code>0x23</code>。生模式字面量运算符将接收字符<code>0</code>、<code>x</code>、<code>2</code>、<code>3</code>，而熟模式字面量运算符将接收整数<code>35</code>。</p>
<p>最后一个示例: 考虑C++字面量<code>3.14</code>，生模式字面量运算符将接收字符<code>3</code>、<code>.</code>、<code>1</code>、<code>4</code>，而熟模式字面量运算符将接收浮点值<code>3.14</code>。</p>
<p>熟模式字面量运算符应该具有: </p>
<ul>
<li>一个unsigned long long、long double、char、wchar_t、char16_t或char32_t类型的参数，用来处理数值。</li>
<li>或者两个参数，第一个参数是字符数组，第二个参数是字符数组的长度，用来处理字符串，例如<code>const char* str</code>和<code>size_t len</code>。</li>
</ul>
<p>下例使用熟模式字面量运算符实现了用户定义的字面量<code>_i</code>，<code>_i</code>用来定义一个复数字面量。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="keyword">complex</span>&lt;<span class="keyword">long</span> <span class="keyword">double</span>&gt; <span class="keyword">operator</span><span class="string">""</span> _i (<span class="keyword">long</span> <span class="keyword">double</span> d) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::<span class="keyword">complex</span>&lt;<span class="keyword">long</span> <span class="keyword">double</span>&gt;(<span class="number">0</span>, d) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>_i</code>字面量可这样使用:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="keyword">complex</span>&lt;<span class="keyword">long</span> <span class="keyword">double</span>&gt; c1 = <span class="number">9.634</span>_i;</span><br><span class="line"><span class="keyword">auto</span> c2 = <span class="number">1.23</span>_i;</span><br><span class="line"><span class="comment">// c2 has as type std::complex&lt;long double&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>另一个示例用熟模式字面量运算符实现了用户定义的字面量s，用于定义<code>std::string</code>字面量：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="keyword">operator</span><span class="string">""</span>_s(<span class="keyword">const</span> <span class="keyword">char</span>* str, <span class="keyword">size_t</span> len) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">string</span>(str, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这一字面量可这样使用：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> str1 = <span class="string">"Hello World"</span>_s;</span><br><span class="line"><span class="keyword">auto</span> str2 = <span class="string">"Hello World"</span>_s;</span><br><span class="line"><span class="comment">// str2 has as type std::string</span></span><br></pre></td></tr></table></figure></p>
<p>如果没有<code>_s</code>字面量，自动推导的类型将是<code>const char*</code>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> str3 = <span class="string">"Hello World"</span>;</span><br><span class="line"><span class="comment">// str has as type const char*</span></span><br></pre></td></tr></table></figure></p>
<p>生模式字面量运算符需要一个<code>const char*</code>类型的参数，这是一个以0结尾的C风格字符串。下面的示例定义了字面量<code>_i</code>，此时使用的是生模式字面量运算符:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="keyword">complex</span>&lt;<span class="keyword">long</span> <span class="keyword">double</span>&gt; <span class="keyword">operator</span><span class="string">""</span>_i (<span class="keyword">const</span> <span class="keyword">char</span>* p)</span><br><span class="line"><span class="comment">// Implementation omitted; it requires parsing the C-style</span></span><br><span class="line"><span class="comment">// string and converting it to a complex number</span></span><br></pre></td></tr></table></figure></p>
<p>生模式字面量运算符的用法与熟模式字面量运算符的用法相同。</p>
<h3 id="标准的用户定义字面量"><a href="#标准的用户定义字面量" class="headerlink" title="标准的用户定义字面量"></a>标准的用户定义字面量</h3><p>C++定义了如下标准的用户定义字面量。注意，这些标准的用户定义字面量并非以下画线开头:</p>
<ul>
<li>“s”用于创建<code>std::string</code><ul>
<li>例如: <code>auto myString = &quot;Hello World&quot;s;</code></li>
<li>需要<code>using namespace std::string_literals;</code></li>
</ul>
</li>
<li>“sv”用于创建<code>std::string_views</code><ul>
<li>例如：<code>auto myStringView = &quot;Hello world&quot;sv;</code></li>
<li>需要<code>using namespace std::string_view_literals;</code></li>
</ul>
</li>
<li>“h” “min” “s” “ms” “us” “ns”用于创建<code>stl::chrono::duration</code>时间段<ul>
<li>例如：<code>auto myDuration = 42min;</code></li>
<li>需要<code>using namespace std::chrono_literals;</code></li>
</ul>
</li>
<li>“i”、“il”、“if”分别用于创建复数<code>complex&lt;double&gt;</code>、<code>complex&lt;long double&gt;</code>和<code>complex&lt;float&gt;</code><ul>
<li>例如：<code>auto myComplexNumber = 1.3i;</code></li>
<li>需要<code>using namespace std::complex_literals;</code></li>
</ul>
</li>
</ul>
<h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><p>头文件是为子系统或代码段提供抽象接口的一种机制。使用头文件需要注意的一点是：要避免循环引用或多次包含同一个头文件。可使用<strong>文件保护机制</strong>(include guards)来避免重复定义。在每个头文件的开头，用<code>#ifndef</code>指令检测是否还没有定义某个键值。如果这个键值已经定义，编译器<br>将跳到对应的<code>#endif</code>，这个指令通常位于文件的结尾。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> LOGGER_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOGGER_H</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span> &#123;</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOGGER_H</span></span></span><br></pre></td></tr></table></figure></p>
<p>如今，几乎所有编译器都支持<code>#pragma once</code>指令(该指令可替代前面的文件保护机制)。例如:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span> &#123;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>前置声明</strong>是另一个避免产生头文件问题的工具。如果需要使用某个类，但是无法包含它的头文件，就可告诉编译器存在这么一个类，但是无法使用<code>#include</code>机制提供正式的定义，可在代码中使用这个类的指针或引用。也可声明函数，使其按值返回这种前置声明类，或将这种前置声明类作为按值传递的函数参数。当然，定义函数的代码以及调用函数的任何代码都需要添加正确的头文件，在头文件中要正确定义前置声明类。</p>
<p><strong>建议尽可能在头文件中使用前置声明，而不是包含其他头文件</strong>。这可减少编译和重编译时间，因为破坏了一个头文件对其他头文件的依赖。当然，实现文件需要包含前置声明类的正确头文件，否则就不能编译。</p>
<p>为了查询是否存在某个头文件，C++17添加了<code>__has_include(&quot;flename&quot;)</code>和<code>__has_include(&lt;filename&gt;)</code>预处理器常量。如果头文件存在，这些常量的结果就是1；如果头文件不存在，常量的结果就是0。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __has_include(<span class="meta-string">&lt;optional&gt;)</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;optional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> __has_include(<span class="meta-string">&lt;experimental/optional&gt;)</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;experimental/optional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<h2 id="C的实用工具"><a href="#C的实用工具" class="headerlink" title="C的实用工具"></a>C的实用工具</h2><h3 id="变长参数列表"><a href="#变长参数列表" class="headerlink" title="变长参数列表"></a>变长参数列表</h3><p>C/C++可以编写参数数目可变的自定义函数。例如，假定要编写一个快速调试函数，这个函数应能接收任意数目和类型的参数并输出字符串。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdarg&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debugOut</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str, ...)</span> </span>&#123;</span><br><span class="line">    va_list ap</span><br><span class="line">    va_start(ap, str) ;</span><br><span class="line">    <span class="built_in">vfprintf</span>(<span class="built_in">stderr</span>, str, ap);</span><br><span class="line">    va_end(ap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先，注意<code>debugOut()</code>函数的原型包含一个具有类型和名称的参数str，之后<code>...</code>代表任意数目和类型的参数。声明一个<code>va_list</code>类型的变量，并调用<code>va_start()</code>来初始化它。<code>va_start()</code>的第二个参数必须是参数列表中最右边的已命名变量。所有具有变长参数列表的函数都至少应该有一个已命名参数。当<code>vfprintf()</code>返回时，<code>debugOut()</code>调用<code>va_end()</code>来终止对变长参数列表的访问。在调用<code>va_start()</code>之后必须调用<code>va_end()</code>，以确保函数结束后，堆栈处于稳定状态。</p>
<h4 id="访问参数"><a href="#访问参数" class="headerlink" title="访问参数"></a>访问参数</h4><p>如果要自行访问实参，可使用<code>va_arg()</code>；它的第一个实参是<code>va_list</code>，接收要截获的实参类型。遗憾的是，如果不提供显式的方法，就无法知道参数列表的结尾是什么。例如，可以让第一个参数计算参数的数目，或者当参数是一组指针时，可以要求最后一个指针是nullptr。</p>
<p>下例演示了这种技术，其中调用者在第一个已命名参数中指定了所提供参数的数目。函数接收任意数目的int参数，并将其输出。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printInts</span><span class="params">(<span class="keyword">size_t</span> num, ...)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    va_list ap</span><br><span class="line">    va_start(ap, num) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; num; ++i) &#123;</span><br><span class="line">        temp = va_arg(ap, <span class="keyword">int</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    va_end(ap);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>访问C风格的变长参数列表并不十分安全，这种方法存在以下风险:</p>
<ul>
<li>不知道参数的数目。</li>
<li>不知道参数的类型。<code>va_arg()</code>接收一种类型，用来解释当前的值。然而，可让<code>va_arg()</code>将这个值解释为任意类型，无法验证正确的类型。</li>
</ul>
<h3 id="预处理器宏"><a href="#预处理器宏" class="headerlink" title="预处理器宏"></a>预处理器宏</h3><p>可使用C++预处理器编写宏，这与函数有点相似。下面是一个示例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SQUARE(x) ((x) * (x)) <span class="comment">// No semicolon after the macro definition!</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;<span class="built_in">cout</span> &lt;&lt; SQUARE(<span class="number">5</span>) &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br></pre></td></tr></table></figure></p>
<p>宏是C遗留下来的特性，非常类似于内联函数，但不执行类型检测。在调用宏时，预处理器会自动用扩展式替换。预处理器并不会真正地应用函数调用语义，这一行为可能导致无法预测的结果。</p>
<p>宏还会影响性能，假定按如下方式调用SQUARE宏:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; SQUARE (veryExpensiveFunctionCallToComputeNumber()) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p>
<p>预处理器把它替换为:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; ( (veryExpensiveFunctionCallToComputeNumber()) * (veryExpensiveFunctionCallToComputeNumber())) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p>
<p>现在，这个开销很大的函数调用了两次。这是避免使用宏的另一个原因。</p>
<p>宏还会导致调试问题，因为编写的代码并非编译器看到的代码或者调试工具中显示的代码(因为预处理器的查找和替换功能)。为此，应该全部用内联函数替代宏。</p>
<h1 id="利用模板编写泛型代码"><a href="#利用模板编写泛型代码" class="headerlink" title="利用模板编写泛型代码"></a>利用模板编写泛型代码</h1><h2 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h2><p>类模板定义了一个类，其中，将一些变量的类型、方法的返回类型和或方法的参数类型指定为参数。</p>
<h3 id="编写类模板"><a href="#编写类模板" class="headerlink" title="编写类模板"></a>编写类模板</h3><p>最好编写一个通用的Grid类，该类可用于存储多种类型，编写类模板可避免编写需要指定一种或多种类型的类。客户通过指定要使用的类型对模板进行实例化。这称为<strong>泛型编程</strong>，其最大的优点是类型安全。</p>
<p>下例展示了如何得到模板化的Grid类。这里选用不带多态性的值语义来实现这个解决方案。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grid</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Grid</span><span class="params">(<span class="keyword">size_t</span> width = kDefaultWidth, <span class="keyword">size_t</span> height = kDefaultHeight)</span></span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~Grid() = <span class="keyword">default</span>;</span><br><span class="line"><span class="comment">// Explicitly default a copy constructor and assignment operator.</span></span><br><span class="line">    Grid(<span class="keyword">const</span> Grid&amp; src) = <span class="keyword">default</span>;</span><br><span class="line">    Grid&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Grid&amp; rhs) = <span class="keyword">default</span>;</span><br><span class="line"><span class="comment">// Explicitly default a move constructor and assignment operator.</span></span><br><span class="line">    Grid(Grid&amp;&amp; src) = <span class="keyword">default</span>;</span><br><span class="line">    Grid&lt;T&gt;&amp; <span class="keyword">operator</span>=(Grid&amp;&amp; rhs) = <span class="keyword">default</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::optional&lt;T&gt;&amp; at(<span class="keyword">size_t</span> x,<span class="keyword">size_t</span> y) ;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::optional&lt;T&gt;&amp; at(<span class="keyword">size_t</span> x,<span class="keyword">size_t</span> y) <span class="keyword">const</span>;</span><br><span class="line">    <span class="keyword">size_t</span> getHeight() <span class="keyword">const</span> &#123; <span class="keyword">return</span> mHeight; &#125;</span><br><span class="line">    <span class="keyword">size_t</span> getWidth() <span class="keyword">const</span> &#123; <span class="keyword">return</span> mWidth; &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">size_t</span> kDefaultWidth = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">size_t</span> kDefaultHeight = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">verifyCoordinate</span><span class="params">(<span class="keyword">size_t</span> x, <span class="keyword">size_t</span> y)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::optional&lt;T&gt;&gt;&gt; mCells;</span><br><span class="line">    <span class="keyword">size_t</span> mWidth, mHeight;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>template &lt;typename T&gt;</code>：第一行表示，下面的类定义是基于模板。<code>template</code>和<code>typename</code>都是C++中的关键字。在模板中使用模板参数名称(例如T)表示调用者要指定的类型。基于历史原因，指定模板类型参数时，可用关键字<code>class</code>替代<code>typename</code>。</p>
<p>在Grid类中，mCells是可选值的矢量的矢量，所以编译器生成的复制构造函数和赋值运算符可以运行得很好。一旦有了用户声明的析构函数，建议不要使用编译器隐式生成复制构造函数或赋值运算符，因此Grid类模板将其显式设置为默认，并且将移动构造函数和赋值运算符显式设置为默认。下面将复制赋值运算符显式设置为默认:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Grid&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Grid&amp; rhs) = <span class="keyword">default</span>;</span><br></pre></td></tr></table></figure></p>
<p>从中可以看出，rths参数的类型是<code>const Grid&amp;</code>，还可将其指定为<code>const Grid&lt;T&gt;&amp;</code>。在类定义中，编译器根据需要将<code>Grid</code>解释为<code>Grid&lt;T&gt;</code>。但在类定义之外，需要使用<code>Grid&lt;T&gt;</code>。在编写类模板时，以前的类名(Grid)现在实际上是模板名称。<code>at()</code>方法现在返回<code>optional&lt;T&gt;&amp;</code>或<code>const optional&lt;T&gt;&amp;</code>，而不是返回<code>unique_ptr</code>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::optional&lt;T&gt;&amp; at(<span class="keyword">size_t</span> x, <span class="keyword">size_t</span> y);</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::optional&lt;T&gt;&amp; at(<span class="keyword">size_t</span> x, <span class="keyword">size_t</span> y) <span class="keyword">const</span>;</span><br></pre></td></tr></table></figure></p>
<h4 id="Grid类的方法定义"><a href="#Grid类的方法定义" class="headerlink" title="Grid类的方法定义"></a>Grid类的方法定义</h4><p><code>template &lt;typename T&gt;</code>访问说明符必须在Grid模板的每一个方法定义的前面。构造函数如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Grid&lt;T&gt;::Grid(<span class="keyword">size_t</span> width, <span class="keyword">size_t</span> height) : mWidth(width), mHeight(height) &#123;</span><br><span class="line">    mCells.resize(mWidth);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; column : mCells)</span><br><span class="line">        column.resize(mHeight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>模板要求将方法的实现也放在头文件中，因为编译器在创建模板的实例之前，需要知道完整的定义，包括方法的定义。</p>
</blockquote>
<p>注意<code>::</code>之前的类名是<code>Grid&lt;T&gt;</code>。必须在所有的方法和静态数据成员定义中将<code>Grid&lt;T&gt;</code>指定为类名：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> Grid&lt;T&gt;::verifyCoordinate(<span class="keyword">size_t</span> x, <span class="keyword">size_t</span> y) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= mWidth || y &gt;= mHeight) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">std</span>::out_of_range(<span class="string">""</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果类模板方法的实现需要特定模板类型参数(例如T)的默认值，可使用<code>T()</code>语法。如果T是类类型，<code>T()</code>调用对象的默认构造函数，或者如果T是简单类型，则生成0。这称为“初始化为0”语法。最好为类型尚不确定的变量提供合理的默认值。</p>
<h4 id="使用Grid模板"><a href="#使用Grid模板" class="headerlink" title="使用Grid模板"></a>使用Grid模板</h4><p>创建网格对象时，不能单独使用Grid作为类型；必须指定这个网格保存的元素类型。为某种类型创建一个模板类对象的过程称为<strong>模板的实例化</strong>。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Grid&lt;<span class="keyword">int</span>&gt; myIntGrid; <span class="comment">// declares a grid that stores ints,</span></span><br><span class="line">Grid&lt;<span class="keyword">double</span>&gt; myDoubleGrid(<span class="number">11</span>, <span class="number">11</span>); <span class="comment">// declares an 11x11 Grid of doubles</span></span><br><span class="line">myIntGrid.at(<span class="number">0</span>, <span class="number">0</span>) = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> x = myIntGrid.at(<span class="number">0</span>, <span class="number">0</span>).value_or(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">Grid&lt;<span class="keyword">int</span>&gt; grid2 (myIntGrid); <span class="comment">// Copy constructor</span></span><br><span class="line">Grid&lt;<span class="keyword">int</span>&gt; anotherIntGrid;</span><br><span class="line">anotherIntGrid = grid2; </span><br><span class="line"><span class="comment">// Assignment operator</span></span><br></pre></td></tr></table></figure></p>
<p>这里使用了<code>value_or()</code>。<code>at()</code>方法返回<code>stl::optional</code>引用。<code>optional</code>可包含值，也可不包含值。如果<code>optional</code>包含值，<code>value_or()</code>方法返回这个值；否则返回给<code>value_or()</code>提供的实参。</p>
<p>可在堆上动态分配Grid模板实例:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> myGridOnHeap = make_unique&lt;Grid&lt;<span class="keyword">int</span>&gt;&gt;(<span class="number">2</span>, <span class="number">2</span>); <span class="comment">// 2x2 Grid on the heap</span></span><br><span class="line">myGridOnHeap-&gt;at(<span class="number">0</span>, <span class="number">0</span>) = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> x = myGridOnHeap-&gt;at(<span class="number">0</span>, <span class="number">0</span>).value_or(<span class="number">0</span>);</span><br></pre></td></tr></table></figure></p>
<h3 id="尖括号"><a href="#尖括号" class="headerlink" title="尖括号"></a>尖括号</h3><p>本书的一些示例使用带双尖括号的模板，例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;&gt; mCells;</span><br></pre></td></tr></table></figure></p>
<p>自C++11以来，上述语法都是正确的。但在C++11之前，双尖括号<code>&gt;&gt;</code>只表示<code>&gt;&gt;</code>运算符。根据所涉及的类型，这个<code>&gt;&gt;</code>运算符可以是右移位运算符或流提取运算符。这与模板代码相左，因为必须在双尖括号之间放置一个空格。前面的声明可以写为:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt; &gt; mCells;</span><br></pre></td></tr></table></figure></p>
<h3 id="编译器处理模板的原理"><a href="#编译器处理模板的原理" class="headerlink" title="编译器处理模板的原理"></a>编译器处理模板的原理</h3><p>编译器遇到模板方法定义时，会进行语法检查，但是并不编译模板。编译器无法编译模板定义，因为它不知道要使用什么类型。编译器遇到一个实例化的模板时，例如<code>Grid&lt;int&gt; myIntGrid</code>，就会将模板类定义中的每一个T替换为int，从而生成Grid模板的int版本代码。编译器生成代码的方式就好像语言不支持模板时程序员编写代码的方式：为每种元素类型编写一个不同的类。</p>
<h4 id="选择性实例化"><a href="#选择性实例化" class="headerlink" title="选择性实例化"></a>选择性实例化</h4><p>编译器总为泛型类的所有虚方法生成代码。但对于非虚方法，编译器只会为那些实际为某种类型调用的非虚方法生成代码。例如，给定前面定义的Grid模板类，假设在<code>main()</code>中编写这段代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Grid&lt;<span class="keyword">int</span>&gt; myIntGrid;</span><br><span class="line">myIntGrid.at(<span class="number">0</span>, <span class="number">0</span>) = <span class="number">10</span>;</span><br></pre></td></tr></table></figure></p>
<p>编译器只会为int版本的Grid类生成无参构造函数、析构函数和非常量<code>at()</code>方法的代码，不会为其他方法生成代码，例如复制构造函数、赋值运算符或<code>getHeight()</code>。</p>
<h4 id="模板对类型的要求"><a href="#模板对类型的要求" class="headerlink" title="模板对类型的要求"></a>模板对类型的要求</h4><p>编写与类型无关的代码时，肯定对这些类型有一些假设。如果在程序中试图用一种不支持模板使用的所有操作的类型对模板进行实例化，那么这段代码无法编译，而且错误消息几乎总是晦涩难懂。然而，就算要使用的类型不支持所有模板代码所需的操作，也仍然可以利用选择性实例化使用某些方法，而避免使用另一些方法。</p>
<h3 id="将模板代码分布在多个文件中"><a href="#将模板代码分布在多个文件中" class="headerlink" title="将模板代码分布在多个文件中"></a>将模板代码分布在多个文件中</h3><p>在任何使用了模板的源代码文件中，编译器都应该能同时访问模板类定义和方法定义。</p>
<h4 id="将模板定义放在头文件中"><a href="#将模板定义放在头文件中" class="headerlink" title="将模板定义放在头文件中"></a>将模板定义放在头文件中</h4><p>方法定义可与类定义直接放在同一个头文件中。当使用了这个模板的源文件通过include包含这个文件时，编译器就能访问需要的所有代码。该机制用于前面的Grid实现。此外，还可将模板方法定义放在另一个头文件中，然后在类定义的头文件中通过#include包含这个头文件。一定要保证方法定义的#include在类定义之后，否则代码无法编译。例如:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grid</span> &#123;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"GridDefinitions.h"</span></span></span><br></pre></td></tr></table></figure></p>
<p>任何需要使用Grid模板的客户只需要包含Grid.h头文件即可。这种分离方式有助于分开类定义和方法定义。</p>
<h4 id="将模板定义放在源文件中"><a href="#将模板定义放在源文件中" class="headerlink" title="将模板定义放在源文件中"></a>将模板定义放在源文件中</h4><p>将方法实现放在头文件中看上去很奇怪。如果不喜欢这种语法，可将方法定义放在一个源代码文件中。然而，仍然需要让使用模板的代码能访问到定义，因此可在模板类定义头文件中通过#include包含类方法实现的源文件。尽管如果之前没有看过这种方式，会感到有点奇怪，但是这在C++中是合法的。头文件如下所示:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grid</span> &#123;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// Class definition omitted for brevity</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Grid.cpp"</span></span></span><br></pre></td></tr></table></figure></p>
<p>使用这种技术时，一定不要把Grid.cpp文件添加到项目中，因为这个文件本不应在项目中，而且无法单独编译；这个文件只能通过#include包含在一个头文件中。</p>
<p>实际上，可任意命名包含方法实现的文件。有些程序员喜欢给包含的源代码文件添加.inl后缀，例如Grid.inl。</p>
<h4 id="限制模板类的实例化"><a href="#限制模板类的实例化" class="headerlink" title="限制模板类的实例化"></a>限制模板类的实例化</h4><p>如果希望模板类仅用于某些已知的类型，就可使用下面的技术。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Grid.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Grid&lt;T&gt;::Grid(<span class="keyword">size_t</span> width, <span class="keyword">size_t</span> height) : mWidth(width), mHeight (height) &#123;</span><br><span class="line">    mCells.resize(mWidth);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; column : mCells)</span><br><span class="line">        column.resize(mHeight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为使这个方法能运行，需要给允许客户使用的类型显式实例化模板。这个文件的末尾应如下所示:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Explicit instantiations for the types you want to allow.</span></span><br><span class="line"><span class="keyword">template</span> <span class="class"><span class="keyword">class</span> <span class="title">Grid</span>&lt;int&gt;;</span></span><br><span class="line"><span class="keyword">template</span> <span class="class"><span class="keyword">class</span> <span class="title">Grid</span>&lt;double&gt;;</span></span><br><span class="line"><span class="keyword">template</span> <span class="class"><span class="keyword">class</span> <span class="title">Grid</span>&lt;std::vector&lt;int&gt;&gt;;</span></span><br></pre></td></tr></table></figure></p>
<p>有了这些显式的实例化，就不允许客户代码给其他类型使用Grid类模板。</p>
<blockquote>
<p>使用显式类模板实例化，无论是否调用方法，编译器都会为类模板的所有方法生成代码。</p>
</blockquote>
<h3 id="模板参数"><a href="#模板参数" class="headerlink" title="模板参数"></a>模板参数</h3><p><code>template &lt;typename T&gt;</code>这个参数列表类似于函数或方法中的参数列表。与函数或方法一样，可使用任意多个模板参数来编写类。此外，这些参数未必是类型，而且可以有默认值。</p>
<h4 id="非类型的模板参数"><a href="#非类型的模板参数" class="headerlink" title="非类型的模板参数"></a>非类型的模板参数</h4><p>非类型的模板参数只能是整数类型(char、int、 long 等)、枚举类型、指针、引用和<code>std:nullptr_t</code>。从C++17开始，可指定<code>auto</code>、<code>auto&amp;</code>和<code>auto*</code>等作为非类型模板参数的类型。此时，编译器会自动推导类型。在模板列表中指定非类型参数而不是在构造函数中指定的主要好处是：在编译代码之前就知道这些参数的值了。下面是新的类定义:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">size_t</span> WIDTH, <span class="keyword">size_t</span> HEIGHT&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grid</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Grid() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~Grid() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="comment">// Explicitly default a copy constructor and assignment operator.</span></span><br><span class="line">    Grid(<span class="keyword">const</span> Grid&amp; src) = <span class="keyword">default</span>;</span><br><span class="line">    Grid&lt;T, WIDTH, HEIGHT&gt;&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> Grid&amp; rhs) = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">std</span>::optional&lt;T&gt;&amp; at(<span class="keyword">size_t</span> x, <span class="keyword">size_t</span> y);</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::optional&lt;T&gt;&amp; at (<span class="keyword">size_t</span> x, <span class="keyword">size_t</span> y) <span class="keyword">const</span>;</span><br><span class="line">    <span class="keyword">size_t</span> getHeight() <span class="keyword">const</span> &#123; <span class="keyword">return</span> HEIGHT; &#125;</span><br><span class="line">    <span class="keyword">size_t</span> getwidth() <span class="keyword">const</span> &#123; <span class="keyword">return</span> WIDTH; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">verifyCoordinate</span><span class="params">(<span class="keyword">size_t</span> X, <span class="keyword">size_t</span> y)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::optional&lt;T&gt; mCells [WIDTH] [HEIGHT];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这个类没有显式地将移动构造函数和移动赋值运算符设置为默认，原因是C风格的数组不支持移动语义。注意，模板参数列表需要3个参数：网格中保存的对象类型以及网格的宽度和高度。宽度和高度用于创建保存对象的二维数组。下面是类方法定义:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">size_t</span> WIDTH, <span class="keyword">size_t</span> HEIGHT&gt;</span><br><span class="line"><span class="keyword">void</span> Grid&lt;T, WIDTH, HEIGHT&gt;::verifyCoordinate(<span class="keyword">size_t</span> x, <span class="keyword">size_t</span> y) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= WIDTH || y &gt;= HEIGHT) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">std</span>::out_of_range (<span class="string">""</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">size_t</span> WIDTH, <span class="keyword">size_t</span> HEIGHT&gt;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::optional&lt;T&gt;&amp; Grid&lt;T, WIDTH, HEIGHT&gt;::at(<span class="keyword">size_t</span> x, <span class="keyword">size_t</span> y) <span class="keyword">const</span> &#123;</span><br><span class="line">    verifyCoordinate(x, y);</span><br><span class="line">    <span class="keyword">return</span> mCells[x] [y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">size_t</span> WIDTH, <span class="keyword">size_t</span> HEIGHT&gt;</span><br><span class="line"><span class="built_in">std</span>::optional&lt;T&gt;&amp; Grid&lt;T, WIDTH, HEIGHT&gt;::at(<span class="keyword">size_t</span> x, <span class="keyword">size_t</span> y) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">const_cast</span>&lt;<span class="built_in">std</span>::optional&lt;T&gt;&amp;&gt; (<span class="built_in">std</span>::as_const(*<span class="keyword">this</span>).at(x, y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意之前所有指定<code>Grid&lt;T&gt;</code>的地方，现在都必须指定<code>Grid&lt;T, WIDTH, HEIGHT&gt;</code>来表示这3个模板参数。可通过以下方式实例化这个模板:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Grid&lt;<span class="keyword">int</span>, <span class="number">10</span>, <span class="number">10</span>&gt; myGrid;</span><br><span class="line">Grid&lt;<span class="keyword">int</span>, <span class="number">10</span>, <span class="number">10</span>&gt; anotherGrid;</span><br><span class="line">myGrid.at(<span class="number">2</span>, <span class="number">3</span>) = <span class="number">42</span>;</span><br><span class="line">anotherGrid = myGrid;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; anotherGrid.at(<span class="number">2</span>, <span class="number">3</span>).value_or(<span class="number">0</span>);</span><br></pre></td></tr></table></figure></p>
<p>这段代码看上去很棒。遗憾的是，实际中的限制比想象中的要多。首先，不能通过非常量的整数指定高度或宽度。下面的代码无法编译:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> height = <span class="number">10</span>;</span><br><span class="line">Grid&lt;<span class="keyword">int</span>, <span class="number">10</span>, height&gt; testGrid; <span class="comment">// DOES NOT COMPILE</span></span><br></pre></td></tr></table></figure></p>
<p>然而，如果把height声明为const，这段代码就可以编译了：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">size_t</span> height = <span class="number">10</span>;</span><br><span class="line">Grid&lt;<span class="keyword">int</span>, <span class="number">10</span>, height&gt; testGrid; <span class="comment">// Compiles and works</span></span><br></pre></td></tr></table></figure></p>
<p>带有正确返回类型的constexpr函数也可以编译。例如，如果有一个返回size_t的constexpr函数，就可以使用它初始化height模板参数:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> size_t <span class="title">getHeight</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">10</span>; &#125;</span><br><span class="line">Grid&lt;<span class="keyword">double</span>，<span class="number">2</span>，getHeight()&gt; myDoubleGrid;</span><br></pre></td></tr></table></figure></p>
<p>另一个限制可能更明显。既然宽度和高度都是模板参数，那么它们也是每种网格类型的一部分。这意味着<code>Grid&lt;int, 10, 10&gt;</code>和<code>Grid&lt;int, 10, 11&gt;</code>是两种不同类型。不能将一种类型的对象赋给另一种类型的对象，而且一种类型的变量不能传递给接收另一种类型的变量的函数或方法。</p>
<blockquote>
<p>非类型模板参数是实例化的对象的类型规范中的一部分。</p>
</blockquote>
<h4 id="类型参数的默认值"><a href="#类型参数的默认值" class="headerlink" title="类型参数的默认值"></a>类型参数的默认值</h4><p>如果继续采用将高度和宽度作为模板参数的方式，就可能需要为高度和宽度(它们是非类型模板参数)提供默认值，就像之前<code>Grid&lt;T&gt;</code>类的构造函数一样。C++允许使用类似的语法向模板参数提供默认值。在这里也可<br>以给T类型参数提供默认值。下面是类定义:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T = <span class="keyword">int</span>, <span class="keyword">size_t</span> WIDTH = <span class="number">10</span>, <span class="keyword">size_t</span> HEIGHT = <span class="number">10</span>&gt;</span><br><span class="line">class Grid</span><br><span class="line"><span class="comment">// Remainder is identical to the previous version .</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>不需要在方法定义的模板规范中指定T、WIDTH和HEIGHT的默认值。例如，下面是<code>at()</code>方法的实现:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">size_t</span> WIDTH, <span class="keyword">size_t</span> HEIGHT&gt;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::optional&lt;T&gt;&amp; Grid&lt;T, WIDTH, HEIGHT&gt;::at(<span class="keyword">size_t</span> x, <span class="keyword">size_t</span> y) <span class="keyword">const</span> &#123;</span><br><span class="line">    verifyCoordinate(x,  y);</span><br><span class="line">    <span class="keyword">return</span> mCells[x][y];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在，实例化Grid时，可不指定模板参数，只指定元素类型，或者指定元素类型和宽度，或者指定元素类型、宽度和高度:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Grid&lt;&gt; myIntGrid;</span><br><span class="line">Grid&lt;<span class="keyword">int</span>&gt; myGrid;</span><br><span class="line">Grid&lt;<span class="keyword">int</span>, <span class="number">5</span>&gt; anotherGrid;</span><br><span class="line">Grid&lt;<span class="keyword">int</span>, <span class="number">5</span>, <span class="number">5</span>&gt; aFourthGrid;</span><br></pre></td></tr></table></figure></p>
<h4 id="构造函数的模板参数推导"><a href="#构造函数的模板参数推导" class="headerlink" title="构造函数的模板参数推导"></a>构造函数的模板参数推导</h4><p>C++17添加了一些功能，支持通过传递给类模板构造函数的实参自动推导模板参数。在C++17之前，必须显式地为类模板指定所有模板参数。函数模板始终支持基于传递给函数模板的实参自动推导模板参数。因此，<code>make_pair()</code>能根据传递给它的值自动推导模板类型参数。例如，编译器为以下调用推导<code>pair&lt;int, double&gt;</code>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> pair2 = <span class="built_in">std</span>::make_pair(<span class="number">1</span>, <span class="number">2.3</span>);</span><br></pre></td></tr></table></figure></p>
<p>在C++17中，不再需要这样的辅助函数模板。现在，编译器可以根据传递给构造函数的实参自动推导模板类型参数。对于pair类模板，只需要编写以下代码:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="function">pair <span class="title">pair3</span><span class="params">(<span class="number">1</span>, <span class="number">2.3</span>)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>当然，推导的前提是类模板的所有模板参数要么有默认值，要么用作构造函数中的参数。</p>
<h4 id="用户定义的推导原则"><a href="#用户定义的推导原则" class="headerlink" title="用户定义的推导原则"></a>用户定义的推导原则</h4><p>也可编写自己的推导原则，即用户定义的推导原则。这允许你编写如何推导模板参数的规则。这是一个高级主题，这里不对其进行详细讨论，但会举一个例子来演示其功能。假设具有以下SpreadsheetCell类模板:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpreadsheetCell</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SpreadsheetCell (<span class="keyword">const</span> T&amp; t) : mContent(t) &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> T&amp; <span class="title">getContent</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> mContent; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T mContent;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>通过自动推导模板参数，可使用<code>std::string</code>类型创建SpreadsheetCell：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> myString = <span class="string">"Hello world!"</span>;</span><br><span class="line"><span class="function">SpreadsheetCell <span class="title">cell</span> <span class="params">(myString)</span> </span>;</span><br></pre></td></tr></table></figure></p>
<p>但是，如果给SpreadsheetCell构造函数传递<code>const char*</code>，那么会将类型T推导为<code>const char*</code>，这不是需要的结果。可创建以下用户定义的推导原则，在将<code>const char*</code>作为实参传递给构造函数时，将T推导为<code>std::string</code>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SpreadsheetCell (<span class="keyword">const</span> <span class="keyword">char</span>*) -&gt; SpreadsheetCell&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;;</span><br></pre></td></tr></table></figure></p>
<h3 id="方法模板"><a href="#方法模板" class="headerlink" title="方法模板"></a>方法模板</h3><p>C++允许模板化类中的单个方法。这些方法可以在类模板中，也可以在非模板化的类中。但是不能用方法模板编写虚方法和析构函数。</p>
<p>在Grid类中添加模板化的复制构造函数和赋值运算符，可生成将一种网格类型转换为另一种网格类型的方法。下面是新的Grid类定义:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grid</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span> &lt; <span class="keyword">typename</span> E&gt;</span><br><span class="line">    Grid(<span class="keyword">const</span> Grid&lt;E&gt;&amp; src);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line">    Grid&lt;T&gt;&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> Grid&lt;E&gt;&amp; rhs);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span> <span class="params">(Grid&amp; other)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>首先检查新的模板化的复制构造函数:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Grid(<span class="keyword">const</span> Grid&lt;E&gt;&amp; src);</span><br></pre></td></tr></table></figure></p>
<p>可看到另一个具有不同类型名称E(Element的简写)的模板声明。这个类在类型T上被模板化，这个新的复制构造函数又在另一个不同的类型E上被模板化。通过这种双重模板化可将一种类型的网格复制到另一种类型<br>的网格。下面是新的复制构造函数的定义:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line">Grid&lt;T&gt;::Grid(<span class="keyword">const</span> Grid&lt;E&gt;&amp; src) : Grid (src.getwidth(), src.getHeight()) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mWidth; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> j = <span class="number">0</span>; j &lt; mHeight; j++)</span><br><span class="line">            mCells[i][j] = src.at(i, j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看出，必须将声明类模板的那一行(带有T参数)放在成员模板的那一行声明(带有E参数)的前面。不能像下面这样合并两者:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> E&gt; <span class="comment">// Wrong for nested template constructor!</span></span><br><span class="line">Grid&lt;T&gt;::Grid(<span class="keyword">const</span> Grid&lt;E&gt;&amp; src)</span><br></pre></td></tr></table></figure></p>
<p>除了构造函数定义之前的额外模板参数行之外，注意必须通过公共的访问方法<code>getWidth()</code>、<code>getHeight()</code>和<code>at()</code>访问src中的元素。这是因为复制目标对象的类型为<code>Grid&lt;T&gt;</code>，而复制来源对象的类型为<code>Grid&lt;E&gt;</code>。 这两者不是同一类型，因此必须使用公共方法。</p>
<p>模板化的赋值运算符接收<code>const Grid&lt;E&gt;&amp;</code>作为参数，但返回<code>Grid&lt;T&gt;&amp;</code>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line">Grid&lt;T&gt;&amp; Grid&lt;T&gt;::<span class="keyword">operator</span>= (<span class="keyword">const</span> Grid&lt;E&gt;&amp; rhs) &#123;</span><br><span class="line">    Grid&lt;T&gt; temp(rhs); <span class="comment">// Do all the work in a temporary instance</span></span><br><span class="line">    swap(temp) ; <span class="comment">// Commit the work with only non-throwing operations</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="带有非类型参数的方法模板"><a href="#带有非类型参数的方法模板" class="headerlink" title="带有非类型参数的方法模板"></a>带有非类型参数的方法模板</h4><p>有了赋值运算符和复制构造函数的方法模板后，完全可实现对不同大小的网格进行赋值和复制。下面是类定义:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">size_t</span> WIDTH = <span class="number">10</span>, <span class="keyword">size_t</span> HEIGHT = <span class="number">10</span>&gt;</span><br><span class="line">class Grid &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Grid(<span class="keyword">const</span> Grid&amp; src) = <span class="keyword">default</span>;</span><br><span class="line">    Grid&lt;T, WIDTH, HEIGHT&gt;&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Grid&amp; rhs) = <span class="keyword">default</span>;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> E, <span class="keyword">size_t</span> WIDTH2, <span class="keyword">size_t</span> HEIGHT2&gt;</span><br><span class="line">    Grid(<span class="keyword">const</span> Grid&lt;E, WIDTH2,  HEIGHT2&gt;&amp; src) ;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> E, <span class="keyword">size_t</span> WIDTH2, <span class="keyword">size_t</span> HEIGHT2&gt;</span><br><span class="line">    Grid&lt;T, WIDTH, HEIGHT&gt;&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> Grid&lt;E, WIDTH2, HEIGHT2&gt;&amp; rhs);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span> <span class="params">(Grid&amp; other)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::optional&lt;T&gt;&amp; at(<span class="keyword">size_t</span> x, <span class="keyword">size_t</span> y);</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::optional&lt;T&gt;&amp; at(<span class="keyword">size_t</span> x, <span class="keyword">size_t</span> y) <span class="keyword">const</span>;</span><br><span class="line">    <span class="keyword">size_t</span> getHeight() <span class="keyword">const</span> &#123; <span class="keyword">return</span> HEIGHT; &#125;</span><br><span class="line">    <span class="keyword">size_t</span> getwidth() <span class="keyword">const</span> &#123; <span class="keyword">return</span> WIDTH; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">verifyCoordinate</span><span class="params">(<span class="keyword">size_t</span> x, <span class="keyword">size_t</span> y)</span> <span class="keyword">const</span></span>; .</span><br><span class="line">    <span class="built_in">std</span>::optional&lt;T&gt; mCells [WIDTH] [HEIGHT];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这个新定义包含复制构造函数和赋值运算符的方法模板，还包含辅助方法swap()。注意，将非模板化的复制构造函数和赋值运算符显式设置为默认(原因在于用户声明的析构函数)。这些方法只是将mCells从源对象复制或赋值到目标对象，语义和两个一样大小的网格的语义完全一致。</p>
<p>下面是模板化的复制构造函数:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">size_t</span> WIDTH,  <span class="keyword">size_t</span> HEIGHT&gt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E, size t WIDTH2,  size t HEIGHT2&gt;</span><br><span class="line">Grid&lt;T, WIDTH,  HEIGHT&gt;::Grid(<span class="keyword">const</span> Grid&lt;E, WIDTH2, HEIGHT2&gt;&amp; src) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i; i &lt; WIDTH; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> j; j &lt; HEIGHT; j ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; WIDTH2 &amp;&amp; j &lt; HEIGHT2 ) &#123;</span><br><span class="line">                mCells[i][j] = src.at(i, j);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mcells[i][j].reset();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="类模板的特例化"><a href="#类模板的特例化" class="headerlink" title="类模板的特例化"></a>类模板的特例化</h3><p>模板的另一个实现称为模板特例化(template specialization)。编写一个模板类特例化时，必须指明这是一个模板，以及正在为哪种特定的类型编写这个模板。下面是为<code>const char*</code>特例化：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Grid.h"</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grid</span>&lt;const char*&gt; &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Grid</span><span class="params">(<span class="keyword">size_t</span> width = kDefaultwidth, <span class="keyword">size_t</span> height = kDefaultHeight)</span></span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~Grid() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="comment">// Explicitly default a copy constructor and ass ignment operator.</span></span><br><span class="line">    Grid&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt;&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> Grid&amp; rhs) = <span class="keyword">default</span>; </span><br><span class="line">    <span class="comment">// Explicitly default a move constructor and assignment operator.</span></span><br><span class="line">    Grid&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt;&amp; <span class="keyword">operator</span>= (Grid&amp;&amp; rhs) = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">std</span>::optional&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;&amp; at(<span class="keyword">size_t</span> x, <span class="keyword">size_t</span> y);</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::optional&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;&amp; at(<span class="keyword">size_t</span> x, <span class="keyword">size_t</span> y) <span class="keyword">const</span>;</span><br><span class="line">    <span class="keyword">size_t</span> getHeight() <span class="keyword">const</span> &#123; <span class="keyword">return</span> mHeight; &#125;</span><br><span class="line">    <span class="keyword">size_t</span> getwidth() <span class="keyword">const</span> &#123; <span class="keyword">return</span> mWidth;&#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">size_t</span> kDefaultwidth = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">size_t</span> kDefaultHeight = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">verifyCoordinate</span><span class="params">(<span class="keyword">size_t</span> x, <span class="keyword">size_t</span> y)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::optional&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;&gt;&gt; mCells; .</span><br><span class="line">    <span class="keyword">size_t</span> mWidth, mHeight;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grid</span>&lt;const char*&gt;</span></span><br></pre></td></tr></table></figure>
<p>上述语法告诉编译器，这个类是Grid类的<code>const char*</code>特例化版本。假设没有使用这种语法，而是尝试编写下面这样的代码:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grid</span></span></span><br></pre></td></tr></table></figure></p>
<p>编译器不允许这样做，因为已经有一个名为Grid的类(原始的类模板)。只能通过特例化重用这个名称。特例化的主要好处就是可对用户隐藏。当用户创建int或SpreadsheetCell类型的Grid时，编译器从原始的Grid 模板生成代码。当用户创建<code>const char*</code>类型的Grid时，编译器会使用<code>const char*</code>的特例化版本。这些全部在后台自动完成。</p>
<p>下面是<code>const char*</code>特例化版本的方法的实现。与模板定义不同，不必在每个方法定义之前重复<code>template&lt;&gt;</code>语法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Grid&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt;::Grid(<span class="keyword">size_t</span> width, <span class="keyword">size_t</span> height) : mWidth(width), mHeight (height) &#123;</span><br><span class="line">    mCells.resize (mWidth);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; column : mCells)&#123;</span><br><span class="line">        column.resize (mHeight) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="从类模板派生"><a href="#从类模板派生" class="headerlink" title="从类模板派生"></a>从类模板派生</h3><p>可从类模板派生。如果一个派生类从模板本身继承，那么这个派生类也必须是模板。此外，还可从类模板派生某个特定实例，这种情况下，这个派生类不需要是模板。下面针对前一种情况举一个例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameBoard</span> :</span> <span class="keyword">public</span> Grid&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">GameBoard</span><span class="params">(<span class="keyword">size_t</span> width = Grid&lt;T&gt;::kDefaultwidth, <span class="keyword">size_t</span> height = Grid&lt;T&gt;::kDefaultHeight)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">size_t</span> xSrc, <span class="keyword">size_t</span> ySrc, <span class="keyword">size_t</span> xDest, <span class="keyword">size_t</span> yDest)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>继承的语法和普通继承一样，区别在于基类是<code>Grid&lt;T&gt;</code>，而不是<code>Grid</code>。<code>: public Grid&lt;T&gt;</code>语法表明，这个类继承了Grid实例化对类型参数T有意义的所有内容。</p>
<p>下面是构造函数和<code>move()</code>方法的实现。同样，要注意调用基类构造函数时对<code>Grid&lt;T&gt;</code>的使用。此外，尽管很多编译器并没有强制使用<code>this</code>指针或<code>Grid&lt;T&gt;::</code>引用基类模板中的数据成员和方法，但名称查找规则要求使用<code>this</code>指针或<code>Grid&lt;T&gt;::</code>。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">GameBoard&lt;T&gt;::GameBoard(<span class="keyword">size_t</span> width, <span class="keyword">size_t</span> height) : Grid&lt;T&gt; (width, height) &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> GameBoard&lt;T&gt;::move(<span class="keyword">size_t</span> xSrc, <span class="keyword">size_t</span> ySrc, <span class="keyword">size_t</span> xDest, <span class="keyword">size_t</span> yDest) &#123;</span><br><span class="line">    Grid&lt;T&gt;::at(xDest, yDest) = <span class="built_in">std</span>::move (Grid&lt;T&gt;::at(xSrc, ySrc));</span><br><span class="line">    Grid&lt;T&gt;::at(xSrc, ySrc).reset();</span><br><span class="line">    <span class="comment">// or:</span></span><br><span class="line">    <span class="comment">// this-&gt;at (xDest, yDest) = std::move (this-&gt;at(xSrc, ySrc));</span></span><br><span class="line">    <span class="comment">// this-&gt;at (xSrC, ySrc).reset() ;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="继承还是特例化"><a href="#继承还是特例化" class="headerlink" title="继承还是特例化"></a>继承还是特例化</h3><p>表12-1总结了两者的区别。<br><img src="/img/1619504039.jpg" alt></p>
<blockquote>
<p>通过继承来扩展实现和使用多态。通过特例化自定义特定类型的实现。</p>
</blockquote>
<h3 id="模板别名"><a href="#模板别名" class="headerlink" title="模板别名"></a>模板别名</h3><p>可使用类型别名给模板化的类赋予另一个名称。假定有如下类模板:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTemplateClass</span> &#123;</span>  &#125;;</span><br></pre></td></tr></table></figure></p>
<p>可定义如下类型别名，给定两个模板类型参数:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> OtherName = MyTemplateClass&lt;<span class="keyword">int</span>, <span class="keyword">double</span>&gt;;</span><br></pre></td></tr></table></figure></p>
<p>还可仅指定一些类型， 其他类型则保持为模板类型参数，这称为别名模板(alias template)，例如:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1&gt;</span><br><span class="line"><span class="keyword">using</span> OtherName = MyTemplateClass&lt;T1, <span class="keyword">double</span>&gt;;</span><br></pre></td></tr></table></figure></p>
<h2 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h2><p>还可为独立函数编写模板。例如，可编写一个通用函数，该函数在数组中查找一个值并返回这个值的索引：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">size_t</span> NOT_FOUND = <span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;(<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">size_t</span> Find(<span class="keyword">const</span> T&amp; value, <span class="keyword">const</span> T* arr, <span class="keyword">size_t</span> size) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; size; i ++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] == value)</span><br><span class="line">            <span class="keyword">return</span> i; <span class="comment">// Found it; return the index</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NOT_FOUND; <span class="comment">// Failed to find it; return NOT_FOUND</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可通过两种方式调用这个函数；一种是通过尖括号显式地指定类型；另一种是忽略类型，让编译器根据参数自动推断类型。下面列举一些例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> myInt = <span class="number">3</span>, intArray[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">size_t</span> sizeIntArray = <span class="built_in">std</span>::size(intArray);</span><br><span class="line"><span class="keyword">size_t</span> res;</span><br><span class="line">res = Find(myInt，intArray, sizeIntArray);   <span class="comment">// calls Find&lt;int&gt; by deduction</span></span><br><span class="line">res = Find&lt;<span class="keyword">int</span>&gt;(myInt, intArray, sizeIntArray); <span class="comment">// calls Find&lt;int&gt; explicitly</span></span><br><span class="line"><span class="keyword">if</span> (res != NOT_FOUND)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Not found"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">double</span> myDouble = <span class="number">5.6</span>, doubleArray[] = &#123;<span class="number">1.2</span>, <span class="number">3.4</span>, <span class="number">5.7</span>, <span class="number">7.5</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">size_t</span> sizeDoubleArray = <span class="built_in">std</span>::size(doubleArray);</span><br><span class="line"></span><br><span class="line"><span class="comment">// calls Find&lt;double&gt; by deduction</span></span><br><span class="line">res = Find (myDouble, doubleArray, sizeDoubleArray);</span><br><span class="line"><span class="comment">// calls Find&lt;double&gt; explicitly</span></span><br><span class="line">res = Find&lt;<span class="keyword">double</span>&gt;(myDouble, doubleArray, sizeDoubleArray);</span><br><span class="line"><span class="keyword">if</span> (res != NOT_FOUND)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Not found"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">res = Find&lt;<span class="keyword">double</span>&gt; (myInt, doubleArray, sizeDoubleArray);</span><br><span class="line"></span><br><span class="line">SpreadsheetCe1l cell1(10), cellArray[] = &#123;SpreadsheetCell(4), SpreadsheetCel1(10) &#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">size_t</span> sizeCellArray = <span class="built_in">std</span>::size(cellArray);</span><br><span class="line">res = Find(cell1, cellArray, sizeCellArray) ;</span><br><span class="line">res = Find&lt;Spreadsheetcell&gt;(celll, cellArray, sizeCellArray) ;</span><br></pre></td></tr></table></figure></p>
<p>前面<code>Find()</code>函数的实现需要把数组的大小作为一个参数。有时编译器知道数组的确切大小，例如，基于堆栈的数组。用这种数组调用<code>Find()</code>函数，就不需要传递数组的大小。为此，可添加如下函数模板。该实现仅把调用传递给前面的<code>Find()</code>函数模板。这也说明函数模板可接收非类型的参数，与类模板一样。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">size_t</span> Find(<span class="keyword">const</span> T&amp; value, <span class="keyword">const</span> T(&amp;arr) [N]) &#123;</span><br><span class="line">    <span class="keyword">return</span> Find(value, arr, N);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>与类模板方法定义一样，函数模板定义(不仅是原型)必须能用于使用它们的所有源文件。因此，如果多个源文件使用函数模板，或使用本章前面讨论的显式实例化，就应把其定义放在头文件中。函数模板的模板参数可以有默认值，与类模板一样。</p>
<h3 id="函数模板的特例化"><a href="#函数模板的特例化" class="headerlink" title="函数模板的特例化"></a>函数模板的特例化</h3><p>就像类模板的特例化一样，函数模板也可特例化。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">size_t</span> Find&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt; (<span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span>&amp; value, <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span>* arr, <span class="keyword">size_t</span> size) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(arr[i], value) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> i; <span class="comment">// Found it; return the index</span></span><br><span class="line">    <span class="keyword">return</span> NOT_FOUND; <span class="comment">// Failed to find it; return NOT_FOUND</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果参数类型可通过参数推导出来，那么可在函数名中忽略<code>&lt;const char*&gt;</code>，将这个函数原型简化为:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">size_t</span> Find(<span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span>&amp; value, <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span>* arr, <span class="keyword">size_t</span> size)</span><br></pre></td></tr></table></figure></p>
<h3 id="函数模板的重载"><a href="#函数模板的重载" class="headerlink" title="函数模板的重载"></a>函数模板的重载</h3><p>还可用非模板函数重载模板函数。例如，如果不编写用于<code>const char*</code>的Find()函数模板，那么需要编写一个非模板的独立Find()函数以直接操作<code>const char*</code>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> Find(<span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span>&amp; value, <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span>* arr, <span class="keyword">size_t</span> size) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; size; i ++)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(arr[i], value) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">return</span> NOT_FOUND;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个函数的调用规则有所不同:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* word = <span class="string">"two"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* words [] = &#123;<span class="string">"two"</span>, <span class="string">"three"</span>, <span class="string">"four"</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">size_t</span> sizeWords = <span class="built_in">std</span>::size(words);</span><br><span class="line"><span class="keyword">size_t</span> res;</span><br><span class="line"></span><br><span class="line">res = Find(word, words, sizeWords) ; <span class="comment">// Calls non-template function!</span></span><br></pre></td></tr></table></figure></p>
<p>因此，如果想要函数在显式指定了<code>const char*</code>时能正常工作，以及在没有指定时能通过自动类型推导正常工作，那么应该编写一个特例化的模板版本，而不是编写一个非模板的重载版本。</p>
<h4 id="同时使用函数模板重载和特例化"><a href="#同时使用函数模板重载和特例化" class="headerlink" title="同时使用函数模板重载和特例化"></a>同时使用函数模板重载和特例化</h4><p>可同时编写一个适用于<code>const char*</code>的特例化<code>Find()</code>函数模板，以及一个适用于<code>const char*</code>的独立<code>Find()</code>函数。编译器总是优先选择非模板化的函数，而不是选择模板化的版本。然而，如果显式地指定模板的实例化，那么会强制编译器使用模板化的版本。</p>
<h3 id="类模板的友元函数模板"><a href="#类模板的友元函数模板" class="headerlink" title="类模板的友元函数模板"></a>类模板的友元函数模板</h3><p>如果需要在类模板中重载运算符，函数模板会非常有用。假定operator+是一个独立的函数模板，其定义应该直接放在Grid.h中，如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Grid&lt;T&gt; <span class="keyword">operator</span>+ (<span class="keyword">const</span> Grid&lt;T&gt;&amp; lhs，<span class="keyword">const</span> Grid&lt;T&gt;&amp; rhs) &#123;</span><br><span class="line">    <span class="keyword">size_t</span> minwidth = <span class="built_in">std</span>::min (lhs.getwidth(), rhs.getwidth());</span><br><span class="line">    <span class="keyword">size_t</span> minHeight = <span class="built_in">std</span>::min(lhs.getHeight(), rhs.getHeight());</span><br><span class="line">    Grid&lt;T&gt; result (minWidth, minHeight);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> y = <span class="number">0</span>; y &lt; minHeight; ++y) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> x = <span class="number">0</span>; x &lt; minWidth; ++x) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">auto</span>&amp; leftElement = lhs.mCells[x][y];</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">auto</span>&amp; rightElement = rhs.mCells[x][y];</span><br><span class="line">            <span class="keyword">if</span>(leftElement.has_value() &amp;&amp; rightElement.has_value())</span><br><span class="line">                result.at(x, y) = leftElement.value() + rightElement.value();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="对模板参数推导的更多介绍"><a href="#对模板参数推导的更多介绍" class="headerlink" title="对模板参数推导的更多介绍"></a>对模板参数推导的更多介绍</h3><p>编译器根据传递给函数模板的实参来推导模板参数的类型；而对于无法推导的模板参数，则需要显式指定。例如，如下<code>add()</code>函数模板需要三个模板参数：返回值的类型以及两个操作数的类型。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> RetType, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function">RetType <span class="title">add</span><span class="params">(<span class="keyword">const</span> T1&amp; t1, <span class="keyword">const</span> T2&amp; t2)</span> </span>&#123; <span class="keyword">return</span> t1+t2;&#125;</span><br></pre></td></tr></table></figure></p>
<p>调用这个函数模板时，可指定如下所有三个参数:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> result = add&lt;<span class="keyword">long</span> <span class="keyword">long</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure></p>
<p>但由于模板参数T1和T2是函数的参数，编译器可以推导这两个参数，因此调用<code>add()</code>时可仅指定返回值的类型:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> result = add&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure></p>
<p>当然，仅在要推导的参数位于参数列表的最后时，这才可行。假设以如下方式定义函数模板:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> RetType, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function">RetType <span class="title">add</span><span class="params">(<span class="keyword">const</span> T1&amp; t1, <span class="keyword">const</span> T2&amp; t2)</span> </span>&#123; <span class="keyword">return</span> t1 + t2; &#125;</span><br></pre></td></tr></table></figure></p>
<p>必须指定RetType,因为编译器无法推导该类型。但由于RetType 是第二个参数，因此必须显式指定T1:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> result = add&lt;<span class="keyword">int</span>, <span class="keyword">long</span> <span class="number">1</span>ong&gt;(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure></p>
<p>也可提供返回类型模板参数的默认值，这样调用add()时可不指定任何类型:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> RetType = <span class="keyword">long</span> <span class="keyword">long</span>, <span class="keyword">typename</span> T1,<span class="keyword">typename</span> T2&gt;</span><br><span class="line">RetType add(<span class="keyword">const</span> T2&amp; t2) &#123; <span class="keyword">return</span> t1 + t2; &#125;</span><br><span class="line"><span class="keyword">auto</span> result = add(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure></p>
<h3 id="函数模板的返回类型"><a href="#函数模板的返回类型" class="headerlink" title="函数模板的返回类型"></a>函数模板的返回类型</h3><p><code>add()</code>函数模板的返回类型取决于模板类型参数，如何才能做到这一点?例如，考虑如下模板函数:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function">RetType <span class="title">add</span><span class="params">(<span class="keyword">const</span> T1&amp; t1, <span class="keyword">const</span> T2&amp; t2)</span> </span>&#123; <span class="keyword">return</span> t1 + t2; &#125;</span><br></pre></td></tr></table></figure></p>
<p>在这个示例中，RetType应当是表达式t1+t2的类型，但由于不知道T1和T2是什么，因此并不知道这一点。只需要编写如下<code>add()</code>函数模板:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(<span class="keyword">const</span> T1&amp; t1, <span class="keyword">const</span> T2&amp; &amp; t2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t1 + t2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是，使用auto来推导表达式类型时去掉了引用和const限定符；<code>decltype</code>没有去除这些。在继续使用<code>add()</code>函数模板前，先分析auto和decltype(使用非模板示例)之间的区别。假设有以下函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> message = <span class="string">"Test"</span>; </span><br><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span>&amp; <span class="title">getString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> message;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>auto s1 = getString();</code>，由于auto会去掉引用和const限定符，因此s1的类型是string，并制作一个副本。如果需要一个const引用，可将其显式地设置为引用，并标记为const，如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span>&amp; s2 = getString();</span><br></pre></td></tr></table></figure></p>
<p>另一个解决方案是使用<code>decltype</code>，<code>decltype</code>不会去掉引用和const限定符:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span> (getString()) s3 = getString();</span><br></pre></td></tr></table></figure></p>
<p>这里，s3的类型是<code>const string&amp;</code>，但存在代码冗余，因为需要将<code>getString()</code>指定两次。如果<code>getString()</code>是更复杂的表达式，这将很麻烦。为解决这个问题，可使用decltype(auto):<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) s4 = getString();</span><br></pre></td></tr></table></figure></p>
<p>s4的类型也是<code>const string&amp;</code>。</p>
<p>了解到这些后，可使用<code>decltype(auto)</code>编写<code>add()</code>函数，以避免去掉任何const和引用限定符:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="keyword">decltype</span> (<span class="keyword">auto</span>) add (<span class="keyword">const</span> T1&amp; t1, <span class="keyword">const</span> T2&amp; t2) &#123;</span><br><span class="line">    <span class="keyword">return</span> t1 + t2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在C++14之前，不支持推导函数的返回类型和<code>decltype(auto)</code>。C++11 引入的<code>decltype(expression)</code>解决了这个问题。例如，你或许会编写如下代码:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1，<span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="keyword">decltype</span>(t1+t2) add(<span class="keyword">const</span> T1&amp; t1, <span class="keyword">const</span> T2&amp; t2) &#123; <span class="keyword">return</span> t1 + t2; &#125;</span><br></pre></td></tr></table></figure></p>
<p>但这是错误的。你在原型行的开头使用了t1和t2，但这些尚且不知。在语义分析器到达参数列表的末尾时，才能知道t1和t2。</p>
<p>通常使用<strong>替换函数语法</strong>(alternative function syntax)解决这个问题。注意在这种新语法中，返回类型是在参数列表之后指定的(拖尾返回类型)，因此在解析时参数的名称(以及参数的类型，因此也包括t1+t2类型)是已知的:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line">auto add(const T1&amp; t1, const T2&amp; t2) -&gt; decltype(t1+t2) &#123;</span><br><span class="line">    <span class="keyword">return</span> t1 + t2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但现在，C++支持自动返回类型推导和<code>decltype(auto)</code>，建议你使用其中的一种机制， 而不要使用替换函数语法。</p>
<h2 id="可变模板"><a href="#可变模板" class="headerlink" title="可变模板"></a>可变模板</h2><p>除了类模板、类方法模板和函数模板外，C++14 还添加了编写可变模板的功能。语法如下:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">constexpr</span> T pi = T(<span class="number">3.141592653589793238462643383279502884</span>);</span><br></pre></td></tr></table></figure></p>
<p>这是pi值的可变模板。为了在某种类型中获得pi值，可使用如下语法:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> piFloat = pi&lt;<span class="keyword">float</span>&gt;;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">double</span> piLongDouble = pi&lt;<span class="keyword">long</span> <span class="keyword">double</span>&gt;;</span><br></pre></td></tr></table></figure></p>
<p>这样总会得到在所请求的类型中可表示的pi近似值。与其他类型的模板一样， 可变模板也可以特殊化。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/C/" rel="tag"># C++</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/05/02/cpp高级编程 笔记2/" rel="next" title="C++高级编程 第四版 笔记2">
                <i class="fa fa-chevron-left"></i> C++高级编程 第四版 笔记2
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/05/02/cpp高级编程 笔记4/" rel="prev" title="C++高级编程 第四版 笔记4">
                C++高级编程 第四版 笔记4 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/header.jpg" alt="Hao Yu">
            
              <p class="site-author-name" itemprop="name">Hao Yu</p>
              <p class="site-description motion-element" itemprop="description">Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author</p>
          </div>
          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">272</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>
        	<audio controls="controls" loop="loop" preload="auto" src="/resource/xiaomeihao.mp3">
	        </audio>
	

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yuhao0102" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:yuh18@mails.tsinghua.edu.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#理解灵活而奇特的C"><span class="nav-number">1.</span> <span class="nav-text">理解灵活而奇特的C++</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#引用"><span class="nav-number">1.1.</span> <span class="nav-text">引用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#引用变量"><span class="nav-number">1.1.1.</span> <span class="nav-text">引用变量</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#修改引用"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">修改引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#指向指针的引用和指向引用的指针"><span class="nav-number">1.1.1.2.</span> <span class="nav-text">指向指针的引用和指向引用的指针</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#引用数据成员"><span class="nav-number">1.1.2.</span> <span class="nav-text">引用数据成员</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#引用参数"><span class="nav-number">1.1.3.</span> <span class="nav-text">引用参数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#将指针转换为引用"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">将指针转换为引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#按引用传递与按值传递"><span class="nav-number">1.1.3.2.</span> <span class="nav-text">按引用传递与按值传递</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#将引用作为返回值"><span class="nav-number">1.1.4.</span> <span class="nav-text">将引用作为返回值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#右值引用"><span class="nav-number">1.1.5.</span> <span class="nav-text">右值引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用引用还是指针"><span class="nav-number">1.1.6.</span> <span class="nav-text">使用引用还是指针</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关键字的疑问"><span class="nav-number">1.2.</span> <span class="nav-text">关键字的疑问</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#const-关键字"><span class="nav-number">1.2.1.</span> <span class="nav-text">const 关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#const-变量和参数"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">const 变量和参数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#const指针"><span class="nav-number">1.2.1.1.1.</span> <span class="nav-text">const指针</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#const引用"><span class="nav-number">1.2.1.1.2.</span> <span class="nav-text">const引用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#const方法"><span class="nav-number">1.2.1.1.3.</span> <span class="nav-text">const方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#constexpr关键字"><span class="nav-number">1.2.1.1.4.</span> <span class="nav-text">constexpr关键字</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#static关键字"><span class="nav-number">1.2.2.</span> <span class="nav-text">static关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#静态数据成员和方法"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">静态数据成员和方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#静态链接-static-linkage"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">静态链接(static linkage)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#extern关键字"><span class="nav-number">1.2.2.2.1.</span> <span class="nav-text">extern关键字</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#函数中的静态变量"><span class="nav-number">1.2.2.2.2.</span> <span class="nav-text">函数中的静态变量</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#非局部变量的初始化顺序"><span class="nav-number">1.2.3.</span> <span class="nav-text">非局部变量的初始化顺序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#非局部变量的销毁顺序"><span class="nav-number">1.2.4.</span> <span class="nav-text">非局部变量的销毁顺序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类型和类型转换"><span class="nav-number">1.3.</span> <span class="nav-text">类型和类型转换</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#类型别名"><span class="nav-number">1.3.1.</span> <span class="nav-text">类型别名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数指针的类型别名"><span class="nav-number">1.3.2.</span> <span class="nav-text">函数指针的类型别名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法和数据成员的指针的类型别名"><span class="nav-number">1.3.3.</span> <span class="nav-text">方法和数据成员的指针的类型别名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#typedef"><span class="nav-number">1.3.4.</span> <span class="nav-text">typedef</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类型转换"><span class="nav-number">1.3.5.</span> <span class="nav-text">类型转换</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#const-cast"><span class="nav-number">1.3.5.1.</span> <span class="nav-text">const_cast()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#static-cast"><span class="nav-number">1.3.5.2.</span> <span class="nav-text">static_cast()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#reinterpret-cast"><span class="nav-number">1.3.5.3.</span> <span class="nav-text">reinterpret_cast()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#dynamic-cast"><span class="nav-number">1.3.5.4.</span> <span class="nav-text">dynamic_cast()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#类型转换总结"><span class="nav-number">1.3.5.5.</span> <span class="nav-text">类型转换总结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#作用域解析"><span class="nav-number">1.4.</span> <span class="nav-text">作用域解析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#特性"><span class="nav-number">1.5.</span> <span class="nav-text">特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#noreturn-特性"><span class="nav-number">1.5.1.</span> <span class="nav-text">[[noreturn]]特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#deprecated-特性"><span class="nav-number">1.5.2.</span> <span class="nav-text">[[deprecated]]特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#allthrough-特性"><span class="nav-number">1.5.3.</span> <span class="nav-text">[[allthrough]]特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#nodiscard-特性"><span class="nav-number">1.5.4.</span> <span class="nav-text">[[nodiscard]]特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#maybe-unused-特性"><span class="nav-number">1.5.5.</span> <span class="nav-text">[[maybe_unused]]特性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#用户定义的字面量"><span class="nav-number">1.6.</span> <span class="nav-text">用户定义的字面量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#标准的用户定义字面量"><span class="nav-number">1.6.1.</span> <span class="nav-text">标准的用户定义字面量</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#头文件"><span class="nav-number">1.7.</span> <span class="nav-text">头文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C的实用工具"><span class="nav-number">1.8.</span> <span class="nav-text">C的实用工具</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#变长参数列表"><span class="nav-number">1.8.1.</span> <span class="nav-text">变长参数列表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#访问参数"><span class="nav-number">1.8.1.1.</span> <span class="nav-text">访问参数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#预处理器宏"><span class="nav-number">1.8.2.</span> <span class="nav-text">预处理器宏</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#利用模板编写泛型代码"><span class="nav-number">2.</span> <span class="nav-text">利用模板编写泛型代码</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#类模板"><span class="nav-number">2.1.</span> <span class="nav-text">类模板</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#编写类模板"><span class="nav-number">2.1.1.</span> <span class="nav-text">编写类模板</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Grid类的方法定义"><span class="nav-number">2.1.1.1.</span> <span class="nav-text">Grid类的方法定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用Grid模板"><span class="nav-number">2.1.1.2.</span> <span class="nav-text">使用Grid模板</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#尖括号"><span class="nav-number">2.1.2.</span> <span class="nav-text">尖括号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#编译器处理模板的原理"><span class="nav-number">2.1.3.</span> <span class="nav-text">编译器处理模板的原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#选择性实例化"><span class="nav-number">2.1.3.1.</span> <span class="nav-text">选择性实例化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#模板对类型的要求"><span class="nav-number">2.1.3.2.</span> <span class="nav-text">模板对类型的要求</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#将模板代码分布在多个文件中"><span class="nav-number">2.1.4.</span> <span class="nav-text">将模板代码分布在多个文件中</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#将模板定义放在头文件中"><span class="nav-number">2.1.4.1.</span> <span class="nav-text">将模板定义放在头文件中</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#将模板定义放在源文件中"><span class="nav-number">2.1.4.2.</span> <span class="nav-text">将模板定义放在源文件中</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#限制模板类的实例化"><span class="nav-number">2.1.4.3.</span> <span class="nav-text">限制模板类的实例化</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#模板参数"><span class="nav-number">2.1.5.</span> <span class="nav-text">模板参数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#非类型的模板参数"><span class="nav-number">2.1.5.1.</span> <span class="nav-text">非类型的模板参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#类型参数的默认值"><span class="nav-number">2.1.5.2.</span> <span class="nav-text">类型参数的默认值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#构造函数的模板参数推导"><span class="nav-number">2.1.5.3.</span> <span class="nav-text">构造函数的模板参数推导</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#用户定义的推导原则"><span class="nav-number">2.1.5.4.</span> <span class="nav-text">用户定义的推导原则</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法模板"><span class="nav-number">2.1.6.</span> <span class="nav-text">方法模板</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#带有非类型参数的方法模板"><span class="nav-number">2.1.6.1.</span> <span class="nav-text">带有非类型参数的方法模板</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类模板的特例化"><span class="nav-number">2.1.7.</span> <span class="nav-text">类模板的特例化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#从类模板派生"><span class="nav-number">2.1.8.</span> <span class="nav-text">从类模板派生</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#继承还是特例化"><span class="nav-number">2.1.9.</span> <span class="nav-text">继承还是特例化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#模板别名"><span class="nav-number">2.1.10.</span> <span class="nav-text">模板别名</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数模板"><span class="nav-number">2.2.</span> <span class="nav-text">函数模板</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#函数模板的特例化"><span class="nav-number">2.2.1.</span> <span class="nav-text">函数模板的特例化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数模板的重载"><span class="nav-number">2.2.2.</span> <span class="nav-text">函数模板的重载</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#同时使用函数模板重载和特例化"><span class="nav-number">2.2.2.1.</span> <span class="nav-text">同时使用函数模板重载和特例化</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类模板的友元函数模板"><span class="nav-number">2.2.3.</span> <span class="nav-text">类模板的友元函数模板</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对模板参数推导的更多介绍"><span class="nav-number">2.2.4.</span> <span class="nav-text">对模板参数推导的更多介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数模板的返回类型"><span class="nav-number">2.2.5.</span> <span class="nav-text">函数模板的返回类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#可变模板"><span class="nav-number">2.3.</span> <span class="nav-text">可变模板</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>
  <div id="DvelopmentTarget">     
  </div>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart" aria-hidden="false"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>

  
</div>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_uv"> 
  本站访客数<span id="busuanzi_value_site_uv"></span>人次
</span>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  


  

  


  <script type="text/javascript" src="/js/src/love.js"></script>

</body>
</html>
