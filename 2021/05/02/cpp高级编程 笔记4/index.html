<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zn-ch">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-center-simple.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="C++,">










<meta name="description" content="C++ IO揭秘C++通过流(stream)提供了更精良的输入输出方法。流是一种灵活且面向对象的IO方法。 使用流流的含义所有的流都可以看成数据滑槽。流的方向不同，关联的来源和目的地也不同。cout和cin都是C++在std名称空间中预定义的流实例。表13-1简要描述了所有预定义的流。     流 说明     cin 输入流，从“输入控制台”读取数据   cout 缓冲的输出流，向“输出控制台”">
<meta name="keywords" content="C++">
<meta property="og:type" content="article">
<meta property="og:title" content="C++高级编程 第四版 笔记4">
<meta property="og:url" content="http://yoursite.com/2021/05/02/cpp高级编程 笔记4/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="C++ IO揭秘C++通过流(stream)提供了更精良的输入输出方法。流是一种灵活且面向对象的IO方法。 使用流流的含义所有的流都可以看成数据滑槽。流的方向不同，关联的来源和目的地也不同。cout和cin都是C++在std名称空间中预定义的流实例。表13-1简要描述了所有预定义的流。     流 说明     cin 输入流，从“输入控制台”读取数据   cout 缓冲的输出流，向“输出控制台”">
<meta property="og:locale" content="zn-ch">
<meta property="og:image" content="http://yoursite.com/img/1619834310.jpg">
<meta property="og:updated_time" content="2021-05-02T14:07:41.703Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="C++高级编程 第四版 笔记4">
<meta name="twitter:description" content="C++ IO揭秘C++通过流(stream)提供了更精良的输入输出方法。流是一种灵活且面向对象的IO方法。 使用流流的含义所有的流都可以看成数据滑槽。流的方向不同，关联的来源和目的地也不同。cout和cin都是C++在std名称空间中预定义的流实例。表13-1简要描述了所有预定义的流。     流 说明     cin 输入流，从“输入控制台”读取数据   cout 缓冲的输出流，向“输出控制台”">
<meta name="twitter:image" content="http://yoursite.com/img/1619834310.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2021/05/02/cpp高级编程 笔记4/">





  <title>C++高级编程 第四版 笔记4 | Hao Yu's blog</title>
  








 
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zn-ch">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hao Yu's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">The program monkey was eaten by the siege lion.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/resume.pdf" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-mybetterhalf">
          <a href="/mybetterhalf/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>
            
            mybetterhalf
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/05/02/cpp高级编程 笔记4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">C++高级编程 第四版 笔记4</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-05-02T22:07:41+08:00">
                2021-05-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="C-IO揭秘"><a href="#C-IO揭秘" class="headerlink" title="C++ IO揭秘"></a>C++ IO揭秘</h1><p>C++通过<strong>流</strong>(stream)提供了更精良的输入输出方法。流是一种灵活且面向对象的IO方法。</p>
<h2 id="使用流"><a href="#使用流" class="headerlink" title="使用流"></a>使用流</h2><h3 id="流的含义"><a href="#流的含义" class="headerlink" title="流的含义"></a>流的含义</h3><p>所有的流都可以看成数据滑槽。流的方向不同，关联的来源和目的地也不同。cout和cin都是C++在std名称空间中预定义的流实例。表13-1简要描述了所有预定义的流。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>流</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>cin</td>
<td>输入流，从“输入控制台”读取数据</td>
</tr>
<tr>
<td>cout</td>
<td>缓冲的输出流，向“输出控制台”写入数据</td>
</tr>
<tr>
<td>cerr</td>
<td>非缓冲的输出流，向“错误控制台”写入数据，“ 错误控制台”通常等同于“输出控制台”</td>
</tr>
<tr>
<td>clog</td>
<td>cerr的缓冲版本</td>
</tr>
</tbody>
</table>
</div>
<p>缓冲的流和非缓冲的流的区别在于，前者不是立即将数据发送到目的地，而是缓冲输入的数据，然后<strong>以块方式发送</strong>；而非缓冲的流则<strong>立即将数据发送到目的地</strong>。缓冲的目的通常是提高性能，对于某些目的地(如文件)而言，一次性写入较大的块时速度更快。注意，始终可使用<code>flush()</code>方法刷新缓冲区，强制要求缓冲的流将其当前所有的缓冲数据发送到目的地。</p>
<p>有关流的另一个要点是：流不仅包含普通数据，还包含称为当前位置(current position)的特殊数据。当前位置指的是流将要进行下一次读写操作的位置。</p>
<h3 id="流的来源和目的地"><a href="#流的来源和目的地" class="headerlink" title="流的来源和目的地"></a>流的来源和目的地</h3><p>在C++中，流可使用3个公共的来源和目的地：控制台、文件和字符串。</p>
<ul>
<li>控制台输入流允许程序在运行时从用户那里获得输入，使程序具有交互性。</li>
<li>文件流从文件系统中读取数据并向文件系统写入数据。</li>
<li>字符串流是将流隐喻应用于字符串类型的例子。使用字符串流时，可像处理其他任何流一样处理字符数据。</li>
</ul>
<h3 id="流式输出"><a href="#流式输出" class="headerlink" title="流式输出"></a>流式输出</h3><h4 id="输出的基本概念"><a href="#输出的基本概念" class="headerlink" title="输出的基本概念"></a>输出的基本概念</h4><p>输出流定义在<code>&lt;ostream&gt;</code>头文件中。大部分程序员都会在程序中包含<code>&lt;iostream&gt;</code>头文件，这个头文件又包含输入流和输出流的头文件。<code>&lt;iostream&gt;</code>头文件还声明了所有预定义的流实例：cout、cin、cerr、clog以及对应的宽版本。</p>
<p>使用输出流的最简单方法是使用<code>&lt;&lt;</code>运算符。通过<code>&lt;&lt;</code>可输出C++的基本类型。此外，C++的string类也兼容<code>&lt;&lt;</code>。</p>
<p>cout流是写入控制台的内建流，控制台也称为标准输出(standard output)。可将<code>&lt;&lt;</code>的使用串联起来，从而输出多个数据段。这是因为<code>&lt;&lt;</code>运算符<strong>返回一个流的引用</strong>，因此可以立即对同一个流再次应用<code>&lt;&lt;</code>运算符。</p>
<p>C++流可正确解析C风格的转义字符，例如包含<code>\n</code>的字符串，也可使用<code>std::endl</code>开始一个新行。<code>\n</code>和<code>endl</code>的区别是，<code>\n</code>仅开始一个新行，而<code>endl</code>还会刷新缓存区。使用<code>endl</code>时要小心，因为过多的缓存区刷新会降低性能。</p>
<h4 id="输出流的方法"><a href="#输出流的方法" class="headerlink" title="输出流的方法"></a>输出流的方法</h4><h5 id="put-和write"><a href="#put-和write" class="headerlink" title="put()和write()"></a>put()和write()</h5><p><code>put()</code>和<code>write()</code>是原始的输出方法。这两个方法接收的不是定义了输出行为的对象或变量，<code>put()</code>接收单个字符，<code>write()</code>接收一个字符数组。传给这些方法的数据按照原本的形式输出，没有做任何特殊的格式化和处理操作。例如，下面的代码段接收一个C风格的字符串，并将它输出到控制台，这个函数没有使用&lt;&lt;运算符：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* test = <span class="string">"hello there\n"</span>;</span><br><span class="line"><span class="built_in">cout</span>.write(test, <span class="built_in">strlen</span>(test));</span><br></pre></td></tr></table></figure></p>
<p>下面的代码段通过<code>put()</code>方法，将C风格字符串的给定索引输出到控制台：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span>.put(<span class="string">'a'</span>);</span><br></pre></td></tr></table></figure></p>
<h4 id="flush"><a href="#flush" class="headerlink" title="flush()"></a>flush()</h4><p>向输出流写入数据时，大部分输出流都会进行缓冲，也就是积累数据，而不是立即将得到的数据写出去。在以下任意一种条件下，流将刷新(或写出)积累的数据：</p>
<ul>
<li>遇到sentinel(如endl标记)时。</li>
<li>流离开作用域被析构时。</li>
<li>要求从对应的输入流输入数据时(即要求从cin输入时，cout会刷新)。</li>
<li>流缓存满时。</li>
<li>显式地要求流刷新缓存时。</li>
</ul>
<p>显式要求流刷新缓存的方法是调用流的<code>flush()</code>方法。</p>
<blockquote>
<p>不是所有的输出流都会缓存。例如，cer 流就不会缓存其输出。</p>
</blockquote>
<h4 id="处理输出错误"><a href="#处理输出错误" class="headerlink" title="处理输出错误"></a>处理输出错误</h4><p>当一个流处于正常的可用状态时，称这个流是“好的”。调用流的<code>good()</code>方法可以判断这个流当前是否处于正常状态。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">cout</span>.good())</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"All good"</span> &lt;&lt; end1;</span><br></pre></td></tr></table></figure></p>
<p>通过<code>good()</code>方法可方便地获得流的基本验证信息，但不能提供流不可用的原因。还有一个<code>bad()</code>方法提供了稍多信息。如果<code>bad()</code>方法返回true，意味着发生了致命错误(相对于非致命错误，例如到达文件结尾)。另一个方法<code>fail()</code>在最近一次操作失败时返回true，但没有说明下一次操作是否也会失败。例如，对输出流调用<code>flush()</code>后，可调用<code>fail()</code>确保流仍然可用。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span>.flush();</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">cout</span>.fall())</span><br><span class="line">    <span class="built_in">cerr</span> &lt;&lt; <span class="string">"Unable to flush to standard out"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p>
<p>流具有可转换为bool类型的转换运算符。转换运算符与调用<code>fail()</code>时返回的结果相同。因此，可将前面的代码段重写为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span>.flush();</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">cout</span>)</span><br><span class="line">    <span class="built_in">cerr</span> &lt;&lt; <span class="string">"Unable to flush to standard out"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>有一点需要指出，遇到文件结束标记时，<code>good()</code>和<code>fail()</code>都会返回false。关系如下：<code>good() == (!fail() &amp;&amp; !eof())</code>。</p>
</blockquote>
<p>还可要求流在发生故障时抛出异常。然后编写一个catch处理程序来捕捉<code>ios_base::failure</code>异常，然后对这个异常调用<code>what()</code>方法，获得错误的描述信息，调用<code>code()</code>方法获得错误代码。不过，是否能获得有用信息取决于所使用的标准库实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span>.exceptions(ios::failbit | ios::badbit | ios::eofbit);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello World."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (<span class="keyword">const</span> ios_base::failure&amp; ex) &#123;</span><br><span class="line">    <span class="built_in">cerr</span> &lt;&lt; <span class="string">"Caught exception:"</span> &lt;&lt; ex.what() &lt;&lt; <span class="string">", error code ="</span>&lt;&lt; ex.code() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="输出操作算子"><a href="#输出操作算子" class="headerlink" title="输出操作算子"></a>输出操作算子</h4><p>C++流还能识别操作算子(manipulator)，操作算子是能修改流行为的对象，而不是(或额外提供)流能够操作的数据。</p>
<p><code>endl</code>就是一个操作算子。<code>endl</code>操作算子封装了数据和行为。它要求流输出一个行结束序列，并且刷新缓存。其他有用的操作算子大部分定义在<code>&lt;ios&gt;</code>和<code>&lt;iomanip&gt;</code>标准头文件中。列表后的例子展示了如何使用这些操作算子。</p>
<ul>
<li>boolalpha和noboolalpha：要求流将布尔值输出为<code>true</code>和<code>false</code>(boolalpha)或1和0(noboolalpha)。默认行为是noboolalpha。</li>
<li>hex、oct和dec：分别以十六进制、八进制和+进制输出数字。</li>
<li>stprecision：设置输出小数时的小数位数。这是一个参数化的操作算子。</li>
<li>setw：设置输出数值数据的字段宽度。这是一个参数化的操作算子。</li>
<li>setfill：当数字宽度小于指定宽度时，设置用于填充的字符。这是一个参数化的操作算子。</li>
<li>showpoint和noshowpoint：对于不带小数部分的浮点数，强制流总是显示或不显示小数点。</li>
<li>put_money：一个参数化的操作算子，向流写入一个格式化的货币值。</li>
<li>put_time：一个参数化的操作算子，向流写入一个格式化的时间值。</li>
<li>quoted：一个参数化的操作算子，把给定的字符串封装在引号中，并转义嵌入的引号。</li>
</ul>
<p>上述操作算子对后续输出到流中的内容有效，直到重置操作算子为止，但<code>setw</code>仅对下一个输出有效。</p>
<p>如果不关心操作算子的概念，通常也能应付过去。流通过<code>precision()</code>这类方法提供了大部分相同的功能。以如下代码为例:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"This should be '1.2346': "</span>&lt;&lt; setprecision(<span class="number">5</span>) &lt;&lt; <span class="number">1.23456789</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p>
<p>这行代码可转换为方法调用。该方法的优点是，它们返回前面的值以便恢复：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span>.precision(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"This should be '1.2346'; "</span>&lt;&lt; <span class="number">1.23456789</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="流式输入"><a href="#流式输入" class="headerlink" title="流式输入"></a>流式输入</h3><p>输入流为结构化数据和非结构化数据的读入提供了简单方法。</p>
<h4 id="输入的基本概念"><a href="#输入的基本概念" class="headerlink" title="输入的基本概念"></a>输入的基本概念</h4><p>读入数据对应的运算符是<code>&gt;&gt;</code>。通过<code>&gt;&gt;</code>从输入流读入数据时，代码提供的变量保存接收的值。默认情况下，<code>&gt;&gt;</code>运算符根据空白字符对输入值进行标志化。<code>&gt;&gt;</code>运算符可用于不同的变量类型，就像<code>&lt;&lt;</code>运算符一样。</p>
<h4 id="处理输入错误"><a href="#处理输入错误" class="headerlink" title="处理输入错误"></a>处理输入错误</h4><p>输入流提供了一些方法用于检测异常情形。大部分和输入流有关的错误条件都发生在无数据可读时。查询输入流状态的最常见方法是在条件语句中访问输入流。例如，只要cin保持在“良好”状态，下面的循环就继续进行:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span>) ( ... )</span><br></pre></td></tr></table></figure></p>
<p>同时可以输入数据:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; ch) &#123; ... &#125;</span><br></pre></td></tr></table></figure></p>
<p>还可在输入流上调用<code>good()</code>、<code>bad()</code>和<code>fail()</code>方法，就像输出流那样。还有一个<code>eof()</code>方法，如果流到达尾部，就返回true。与输出流类似，遇到文件结束标记时，<code>good()</code>和<code>fail()</code>都会返回false。关系如下：<code>good() == (!fail() &amp;&amp; !eof())</code>。</p>
<p>下面的程序展示了从流中读取数据并处理错误的常用模式。这个程序从标准输入中读取数字，到达文件末尾时显示这些数字的总和。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">cin</span>.good()) &#123;</span><br><span class="line">    <span class="built_in">cerr</span> &lt;&lt; <span class="string">"Standard input is in a bad state!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> number;</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">cin</span>.bad()) &#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; number:</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">cin</span>.good()) &#123;</span><br><span class="line">        sum += number;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">cin</span>.eof()) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">cin</span>.fail()) &#123;</span><br><span class="line">        <span class="comment">// Failure!</span></span><br><span class="line">        <span class="built_in">cin</span>.clear();</span><br><span class="line">        <span class="comment">// Clear the failure state.</span></span><br><span class="line">        <span class="built_in">string</span> badToken;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; badToken; <span class="comment">// consume the bad input.</span></span><br><span class="line">        err &lt;&lt; <span class="string">"WARNTNG：Bad input encountered:"</span> &lt;&lt; badToken &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="输入方法"><a href="#输入方法" class="headerlink" title="输入方法"></a>输入方法</h4><p>输入流也提供了一些方法，获得相比普通<code>&gt;&gt;</code>运算符更底层的访问功能。</p>
<h5 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h5><p><code>get()</code>方法允许从流中读入原始输入数据。<code>get()</code>的最简单版本返回流中的下一个字符，其他版本一次读入多个字符。<code>get()</code>常用于避免<code>&gt;&gt;</code>运算符的自动标志化。</p>
<p>在条件环境中对一个输入流求值时，只有当这个输入流可以用于下一次读取时才会返回true。如果遇到错误或者到达文件末尾，都会使流求值为false。</p>
<h5 id="unget"><a href="#unget" class="headerlink" title="unget()"></a>unget()</h5><p>对于大多数场合来说，理解输入流的正确方式是将输入流理解为单方向的滑槽。数据被丢入滑槽，然后进入变量。<code>unget()</code>方法打破了这个模型，允许将数据塞回滑槽。调用<code>unget()</code>会导致流回退一个位置，将读入的前一个字符放回流中。调用<code>fail()</code>方法可查看<code>unget()</code>是否成功。</p>
<p>下面的代码使用了<code>unget()</code>，允许名字中出现空白字符。将这段代码逐字符读入，并检查字符是否为数字。如果字符不是数字，就将字符添加到guestName；如果字符是数字，就通过<code>unget()</code>将这个字符放回到流中，循环停止，然后通过<code>&gt;&gt;</code>运算符输入一个整数partySize。<code>noskipws</code>输入操作算子告知流不要跳过空白字符，就像读取其他任何字符一样读取空白字符。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vold <span class="title">getReservationData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> guestName;</span><br><span class="line">    <span class="keyword">int</span> partySize = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Read characters until we find a digit</span></span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; noskipws;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; ch) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            <span class="built_in">cin</span>.unget();</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">cin</span>.fail ())</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"unget() failed"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        guestName += ch;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Read partysize, if the stream is not in error state</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">cin</span>)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; partySize;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">cin</span>) &#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">"Error getting party size."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Thank you "</span> &lt;&lt; guestName &lt;&lt; <span class="string">", party of "</span> &lt;&lt; partysize &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">if</span> (partysize&gt; <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"An extra gratuity will apply."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="putback"><a href="#putback" class="headerlink" title="putback()"></a>putback()</h5><p><code>putback()</code>和<code>unget()</code>一样，允许在输入流中反向移动一个字符。区别在于<code>putback()</code>方法将放回流中的字符接收为参数:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> ch1;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; chl;</span><br><span class="line"><span class="built_in">cin</span>.putback(<span class="string">'e'</span>);</span><br><span class="line"><span class="comment">// 'e' will be the next character read oft the stream.</span></span><br></pre></td></tr></table></figure></p>
<h5 id="peek"><a href="#peek" class="headerlink" title="peek()"></a>peek()</h5><p>通过<code>peek()</code>方法可预览调用<code>get()</code>后返回的下一个值。再次以滑槽为例，可想象为查看一下滑槽，但是不把值取出来。<br><code>peek()</code>非常适合于在读取前需要预先查看一个值的场合。</p>
<h5 id="getine"><a href="#getine" class="headerlink" title="getine()"></a>getine()</h5><p><code>getline()</code>方法用一行数据填充字符缓存区，数据量最多至指定大小。指定的大小中包括\0字符。因此，下面的代码最多从cin 中读取<code>kBufferSize - 1</code>个字符，或者读到行尾为止:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> buffer[kBufferSize] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="built_in">cin</span>.getline (buffer, kBuffersize);</span><br></pre></td></tr></table></figure></p>
<p>调用<code>getline()</code>时，从输入流中读取一行，读到行尾为止。不过，行尾字符不会出现在字符串中。有个版本的<code>get()</code>函数执行的操作和<code>getline()</code>一样，区别在于<code>get()</code>把换行序列留在输入流中。</p>
<p>还有一个用于C++字符串的<code>std:getline()</code>函数。这个函数定义在<code>&lt;string&gt;</code>头文件和std名称空间中。它接收一个流引用、一个字符串引用和一个可选的分隔符作为参数。使用这个版本的<code>getine()</code>函数的优点是不需要指定缓存区的大小。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> myString;</span><br><span class="line"><span class="built_in">std</span>::getine(<span class="built_in">cin</span>, myString);</span><br></pre></td></tr></table></figure></p>
<h4 id="输入操作算子"><a href="#输入操作算子" class="headerlink" title="输入操作算子"></a>输入操作算子</h4><p>下面列出了内建的输入操作算子，它们可发送到输入流中，以自定义数据读入的方式。</p>
<ul>
<li>boolalpha和noboolalpha：如果使用了boolalpha，字符串false会被解释为布尔值false；其他任何字符串都会被解释为布尔值true。如果设置了noboolalpha，0会被解释为false，其他任何值都被解释为true。</li>
<li>hex、oct和dec：分别以十六进制、八进制和十进制读入数字。</li>
<li>skipws和noskipws：告诉输入流在标记化时跳过空白字符，或者读入空白字符作为标记。默认为skipws。</li>
<li>ws：一个简便的操作算子，表示跳过流中当前位置的一串空白字符。</li>
<li>get_money：一个参数化的操作算子，从流中读入一个格式化的货币值。</li>
<li>get_time：一个参数化的操作算子，从流中读入一个格式化的时间值。</li>
<li>quoted：一个参数化的操作算子，读取封装在引号中的字符串，并转义嵌入的引号。</li>
</ul>
<h2 id="字符串流"><a href="#字符串流" class="headerlink" title="字符串流"></a>字符串流</h2><p>可通过字符串流将流语义用于字符串。通过这种方式，可得到一个内存中的流(in memory stream)来表示文本数据。字符串流也非常适合于解析文本，因为流内建了标记化的功能。<code>std::ostringstream</code>类用于将数据写入字符串，<code>std::istringtream</code>类用于从字符串中读出数据。这两个类都定义在<code>&lt;sstream&gt;</code>头文件中。由于<code>ostringstream</code>和<code>istringstream</code>把同样的行为分别继承为<code>ostream</code>和<code>istream</code>，因此这两个类的使用也非常类似。</p>
<p>下面的程序从用户那里请求单词，然后输出到一个<code>ostringtream</code>中，通过制表符将单词分开。在程序的最后，整个流通过<code>str()</code>方法转换为字符串对象，并写入控制台。输入标记“done”，可停止标记的输入。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ostringstream</span> outstream;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span>) &#123;</span><br><span class="line">    <span class="built_in">string</span> nextToken;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Next token："</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; nextToken;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">cin</span> || nextToken == <span class="string">"done"</span>)</span><br><span class="line">        <span class="keyword">break</span>; </span><br><span class="line">    outStream &lt;&lt; nextToken &lt;&lt; <span class="string">"\t"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从字符串流中读入数据非常类似。下面的函数创建一个Muffin对象，并填充字符串输入流中的数据。流数据的格式固定，因此这个函数可轻松地将数据值转换为对Mufin类的设置方法的调用:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Muffin <span class="title">createMuffin</span><span class="params">(<span class="built_in">istringstream</span>&amp; stream)</span> </span>&#123;</span><br><span class="line">    Muffin muftin;</span><br><span class="line">    <span class="built_in">string</span> description;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">bool</span> hasChips;</span><br><span class="line">    </span><br><span class="line">    stream &gt;&gt; description &gt;&gt; size &gt;&gt; boolalpha &gt;&gt; hasChips;</span><br><span class="line">    <span class="keyword">if</span> (stream) &#123;</span><br><span class="line">        muffin.setsize(size);</span><br><span class="line">        muffin.setDescription (description);</span><br><span class="line">        muffin.setHasChocolateChips (hasChipa);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> muffin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="文件流"><a href="#文件流" class="headerlink" title="文件流"></a>文件流</h2><p>文件本身非常符合流的抽象，因为读写文件时，除数据外，还涉及读写的位置。在C++中，<code>std::ofstream</code>和<code>std::ifstream</code>类提供了文件的输入输出功能。这两个类在<code>&lt;fstream&gt;</code>头文件中定义。在处理文件系统时，错误情形的检测和处理非常重要。可以通过前面描述的标准错误处理机制检测错误情形。</p>
<p>输出文件流和其他输出流的唯一主要区别在于：文件流的构造函数可以接收文件名以及打开文件的模式作为参数。默认模式是写文件(<code>ios_base::out</code>)，这种模式从文件开头写文件，改写任何已有的数据。给文件流构造<br>函数的第二个参数指定常量<code>ios_base::app</code>，还可按追加模式打开输出文件流。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>常量</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>ios_base::app</td>
<td>打开文件，在每一次写操作之前，移到文件末尾</td>
</tr>
<tr>
<td>ios_base::ate</td>
<td>打开文件，打开之后立即移到文件末尾</td>
</tr>
<tr>
<td>ios_base::binary</td>
<td>以二进制模式执行输入输出操作(相对于文本模式)</td>
</tr>
<tr>
<td>ios_base::in</td>
<td>打开文件，从开头开始读取</td>
</tr>
<tr>
<td>ios_base::out</td>
<td>打开文件，从开头开始写入，覆盖已有的数据</td>
</tr>
<tr>
<td>ios_base::trunc</td>
<td>打开文件，并删除(截断)任何已有数据</td>
</tr>
</tbody>
</table>
</div>
<p>注意，可组合模式。例如，如果要打开文件用于输出(以二进制模式),同时截断现有数据，可采用如下方式指定打开模式:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ios_base::out | ios_base::binary | ios_base::trunc</span><br></pre></td></tr></table></figure></p>
<p><code>ifstream</code>自动包含<code>ios_base::in</code>模式，<code>ofstream</code>自动包含<code>ios_base::out</code>模式，即使不显式地将in或out指定为模式，也同样如此。</p>
<p>下面的程序打开文件ts.txt,并输出程序的参数。istram 和ofstream析构函数会自动关闭底层文件，因此不需要显式调用<code>close()</code>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc， <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">ofstream <span class="title">outFile</span><span class="params">(<span class="string">"test.txt"</span>, ios_base::trunc)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!outFile.good()) &#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">"Error while opening output file!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    outFile &lt;&lt; <span class="string">"There were "</span> &lt;&lt; argc &lt;&lt; <span class="string">"arguments to this program."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    outFile &lt;&lt; <span class="string">"They are："</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i ≤ arge; i ++)</span><br><span class="line">        outFile &lt;&lt; argv[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="文本模式与二进制模式"><a href="#文本模式与二进制模式" class="headerlink" title="文本模式与二进制模式"></a>文本模式与二进制模式</h3><p>默认情况下，文件流在文本模式中打开。如果指定<code>ios_base:binary</code>标志，将在二进制模式中打开文件。在二进制模式中，要求把流处理的字节写入文件。读取时，将完全按文件中的形式返回字节。</p>
<p>在文本模式中，会执行一些隐式转换，写入文件或从文件中读取的每一行都以\n结束。但是，行结束符在文件中的编码方式与操作系统相关。因此，如果文件以文本模式打开，而写入的行以\n结尾，在写入文件前，底层实现会自动将\n转换为\r\n。同样，从文件读取行时，从文件读取的\r\n会自动转换回\n。</p>
<h3 id="通过seek-和tell-在文件中转移"><a href="#通过seek-和tell-在文件中转移" class="headerlink" title="通过seek()和tell()在文件中转移"></a>通过seek()和tell()在文件中转移</h3><p>所有的输入流和输出流都有<code>seek()</code>和<code>tell()</code>方法。</p>
<p><code>seek()</code>方法允许在输入流或输出流中移动到任意位置。<code>seek()</code>有好几种形式。输入流中的<code>seek()</code>版本实际上称为<code>seekg()</code>，输出流中的<code>seek()</code>版本称为<code>seekp()</code>。有的流既可以输入又可以输出，例如文件流。这种情况下，流需要记住读位置和独立的写位置。这也称为<strong>双向IO</strong>。</p>
<p><code>seekg()</code>和<code>seekp()</code>有两个重载版本。其中一个重载版本接收一个参数：绝对位置。这个重载版本将定位到这个绝对位置。另一个重载版本接收一个偏移量和一个位置，这个重载版本将定位到距离给定位置一定偏移量的位置。位置的类型为<code>std::streampos</code>，偏移量的类型为<code>std::streamoff</code>，这两种类型都以字节计数。预定义的三个位置如表所示。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>位置</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>ios_base::beg</td>
<td>表示流的开头</td>
</tr>
<tr>
<td>ios_base::end</td>
<td>表示流的结尾</td>
</tr>
<tr>
<td>ios_base::cur</td>
<td>表示流的当前位置</td>
</tr>
</tbody>
</table>
</div>
<p>例如，要定位到输出流中的一个绝对位置，可使用接收一个参数的<code>seekp()</code>版本，如下所示，这个例子通过<code>ios_base::beg</code>常量定位到流的开头：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">outStream.seekp(ios_base::beg);</span><br></pre></td></tr></table></figure></p>
<p>在输入流中，定位方法完全一样， 只不过用的是<code>seekp()</code>方法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">instream.seekg(ios_base::beg);</span><br></pre></td></tr></table></figure></p>
<p>接收两个参数的版本可定位到流中的相对位置。第一个参数表示要移动的位置数，第二个参数表示起始点。要相对文件的起始位置移动，使用<code>ios_base::beg</code>常量。要相对文件的末尾位置移动，使用<code>ios_base::end</code>常量。要相对文件的当前位置移动，使用`ios_base::cur常量。例如，下面这行代码从流的起始位置移动到第二个字节。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">outStream.seekp(<span class="number">2</span>, ios_base::beg);</span><br></pre></td></tr></table></figure></p>
<p>下例转移到输入流中的倒数第3个字节:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">instream.seekg(<span class="number">-3</span>, ios_base::end);</span><br></pre></td></tr></table></figure></p>
<p>可通过<code>tell()</code>方法查询流的当前位置，这个方法返回一个表示当前位置的<code>streampos</code>值。利用这个结果，可在执行<code>seek()</code>之前记住当前标记的位置，还可查询是否在某个特定位置。和<code>seek()</code>一样，输入流和输出流也有不同版本的<code>tell()</code>。输入流使用的是<code>tellg()</code>，输出流使用的是<code>tellp()</code>。下面的代码检查输入流的当前位置，并判断是否在起始位置:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::streampos curPos = instream.tel1g();</span><br><span class="line"><span class="keyword">if</span> (ios_base::beg == curPos)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"We're at the beginning."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="将流链接在一起"><a href="#将流链接在一起" class="headerlink" title="将流链接在一起"></a>将流链接在一起</h3><p>任何输入流和输出流之间都可以建立链接，从而实现“访问时刷新”的行为。换句话说，当从输入流请求数据时，链接的输出流会自动刷新。这种行为可用于所有流，但对于可能互相依赖的文件流来说特别有用。通过<code>tie()</code>方法完成流的链接。要将输出流链接至输入流，对输入流调用<code>tie()</code>方法，并传入输出流的地址。要解除链接，传入nullptr。</p>
<p>下面的程序将一个文件的输入流链接至一个完全不同的文件的输出流。也可链接至同一个文件的输出流。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">inFile</span><span class="params">(<span class="string">"input.txt"</span>)</span></span>; <span class="comment">// Note：input.txt must exist.</span></span><br><span class="line"><span class="function">ofstream <span class="title">outFile</span> <span class="params">(<span class="string">"output.txt"</span>)</span></span>;</span><br><span class="line"><span class="comment">// Set up a link between inFile and outFile.</span></span><br><span class="line">inFile.tie (&amp;soutFile);</span><br><span class="line"></span><br><span class="line"><span class="comment">// output some text to outFile. Normally, this would</span></span><br><span class="line"><span class="comment">// not flush because std::endl is not sent.</span></span><br><span class="line">outFlle &lt;&lt; <span class="string">"Hello there!"</span>;</span><br><span class="line"><span class="comment">// outFlle has NOT been. flushed.</span></span><br><span class="line"><span class="comment">// Read some text from inF1le. This w111 trigger flush()</span></span><br><span class="line"><span class="comment">// on outFile</span></span><br><span class="line"><span class="built_in">string</span> nextToken;</span><br><span class="line">inFile &gt;&gt; nextToken;</span><br><span class="line"><span class="comment">// outFile HAS been flushed.</span></span><br></pre></td></tr></table></figure></p>
<p>这种关系意味着:每次写入一个文件时，发送给另一个文件的缓存数据会被刷新。可通过这种机制保持两个相关文件的同步。</p>
<p>这种流链接的一个例子是cout和cin之间的链接。每当从cin输入数据时，都会自动刷新cout。cerr和cout之间也存在链接，这意味着到cerr的任何输出都会导致刷新cout,而clog未链接到cout。</p>
<h2 id="双向I-O"><a href="#双向I-O" class="headerlink" title="双向I/O"></a>双向I/O</h2><p>双向流可同时以输入流和输出流的方式操作。双向流是<code>iostream</code>的子类，而<code>iostream</code>是<code>istream</code>和<code>ostream</code>的子类，因此这是一个多重继承示例。显然，双向流支持<code>&gt;&gt;</code>和<code>&lt;&lt;</code>运算符，还支持输入流和输出流的方法。<code>fstram</code>类提供了双向文件流。<code>fstream</code>特别适用于需要替换文件中数据的应用程序，因为可通过读取文件找到正确的位置，然后立即切换为写入文件。</p>
<p>双向流用不同的指针保存读位置和写位置。在读取和写入之间切换时，需要定位到正确的位置。</p>
<h1 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h1><h2 id="错误与异常"><a href="#错误与异常" class="headerlink" title="错误与异常"></a>错误与异常</h2><p>C++提供了对异常的语言支持，但不要求使用异常。然而，在C++中无法完全忽略异常，因为一些基本工具(例如内存分配例程)会用到它们。</p>
<h3 id="异常的含义"><a href="#异常的含义" class="headerlink" title="异常的含义"></a>异常的含义</h3><p>异常是这样一种机制：一段代码提醒另一段代码存在“异常”情况或错误情况，所采用的路径与正常的代码路径不同。遇到错误的代码抛出异常，处理异常的代码捕获异常。当某段代码抛出异常时，程序控制立刻停止逐步执行，并转向异常处理程序(exception handler)，异常处理程序可在任何地方，可位于同一函数中的下一行，也可在堆栈中相隔好几个函数调用。</p>
<h3 id="C-中异常的优点"><a href="#C-中异常的优点" class="headerlink" title="C++中异常的优点"></a>C++中异常的优点</h3><p>C++错误处理标准使用函数返回的整数代码和errno宏表示错误，每个线程都有自己的errno值。errno用作线程局部整数变量(thread-local integer variable)，被调用函数使用这个变量将发生的错误告诉调用函数。整数返回代码和errno的使用并不一致。有些函数可能用返回值0表示成功，用-1表示错误。这些不一致性可能会引起问题，因为程序员在遇到新函数时，会假定它的返回代码与其他类似函数相同。</p>
<p>异常具有许多优点。</p>
<ul>
<li>将返回代码作为报告错误的机制时，调用者可能会忽略返回的代码，不进行局部处理或不将错误代码向上提交。</li>
<li>返回的整数代码通常不会包含足够的信息。使用异常时，可将任何信息从发现错误的代码传递到处理错误的代码。除错误信息外，异常还可用来传递其他信息。</li>
<li>异常处理可跳过调用堆栈的层次。也就是说，某个函数可处理沿着堆栈进行数次函数调用后发生的错误，而中间函数不需要有错误处理程序。返回代码要求堆栈中每一层调用的函数都必须在前一层之后显式地执行清理。</li>
</ul>
<p>在现代编译器中，不抛出异常时几乎没有这个开销，实际抛出异常时这一开销也非常小。这并不是坏事，因为抛出异常应是例外情况。在C++中，并不强制异常处理。在C++中函数可抛出它想要抛出的任何异常，除非指定不会抛出任何异常(使用noexcept 关键字)。</p>
<h2 id="异常机制"><a href="#异常机制" class="headerlink" title="异常机制"></a>异常机制</h2><h3 id="抛出和捕获异常"><a href="#抛出和捕获异常" class="headerlink" title="抛出和捕获异常"></a>抛出和捕获异常</h3><p>为了使用异常，要在程序中包括两部分：处理异常的try/catch结构和抛出异常的throw语句。二者都必须以某种形式出现，以进行异常处理。然而在许多情况下，throw 在一些库的深处发生，程序员无法看到这一点， 但仍然不得不用try/catch结构处理抛出的异常。try/catch 结构如下所示:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// code which may result in an exception being thrown</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (exception-type1 exception-name) &#123;</span><br><span class="line">    <span class="comment">// code which responds to the exception of type 1</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (except ion-type2 exception-name) &#123;</span><br><span class="line">    <span class="comment">// code which responds to the exception of type 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>导致抛出异常的代码可能直接包含throw语句，也可能调用一个函数，这个函数可能直接抛出异常，也可能经过多层调用后调用为一个抛出异常的函数。如果没有抛出异常，catch 块中的代码不会执行；如果抛出了异常，throw 语句之后或者在抛出异常的函数后的代码不会执行，根据抛出的异常的类型，控制会立刻转移到对应的catch块。</p>
<p>如果catch块没有执行控制转移(例如返回一个值，抛出新的异常或者重新抛出异常)，那么会执行catch块最后语句之后的“剩余代码”。演示异常处理的最简单示例是避免除0。这个示例抛出一个<code>std::invalid_argument</code>类型的异常，这种异常类型需要<code>&lt;stdexcept&gt;</code>头文件。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">SafeDivide</span> <span class="params">(<span class="keyword">double</span> num, <span class="keyword">double</span> den)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (den == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> invalid_argument(<span class="string">"Divide by zero"</span>);</span><br><span class="line">    <span class="keyword">return</span> num / den;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; safeDivide(<span class="number">5</span>, <span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; safeDivide(<span class="number">10</span>, <span class="number">0</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; SafeDivide(<span class="number">3</span>, <span class="number">3</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="keyword">const</span> invalid_argument&amp; e) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Caught exception："</span>&lt;&lt; e.what() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出如下所示:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2.5</span><br><span class="line">Caught exception：Divide by zero</span><br></pre></td></tr></table></figure></p>
<p><code>throw</code>是C++中的关键字，这是抛出异常的唯一方法。<code>throw</code>行的<code>invalid_argument()</code>部分意味着构建<code>invalid_argument</code>类型的新对象并准备将其抛出。该层次结构中的每个类都支持<code>what()</code>方法，该方法返回一个描述异常的<code>const char*</code>字符串。该字符串在异常的构造函数中提供。</p>
<p>异常处理是这样一种方法：“尝试”执行一块代码，并用另一块代码响应可能发生的任何错误。在下面的<code>main()</code>函数中，catch语句响应任何被try块抛出的exception类型异常，并输出错误消息。如果try块结束时没有抛出异常，catch 块将被忽略。可将try/catch块当作if语句。如果在try块中抛出异常，就会执行catch块，否则忽略catch 块。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">string</span> fileName = <span class="string">"IntegerFile.txt"</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myInts;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        myInts = readIntegerFile(fileName);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="keyword">const</span> exception&amp; e) &#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">"Unable to open file "</span>&lt;&lt; fileName &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; element ：myInts) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; element &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>尽管默认情况下，流不会抛出异常，但是针对错误情况，仍然可以调用<code>exceptions()</code>方法通知流抛出异常。</p>
<h3 id="异常类型"><a href="#异常类型" class="headerlink" title="异常类型"></a>异常类型</h3><p>可抛出任何类型的异常。可以抛出一个<code>std:exception</code>类型的对象，但异常未必是对象。也可以抛出一个简单的int值，如下所示:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; readIntegerFile(string_view fileName) &#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">inputstream</span> <span class="params">(fileName.data())</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (inputstream.fail()) &#123;</span><br><span class="line">        <span class="comment">// We failed to open the file：throw an exception</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此后必须修改catch语句:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    myInts = readIntegerFile (fileName); </span><br><span class="line">&#125; <span class="keyword">catch</span> (<span class="keyword">int</span> e) &#123;</span><br><span class="line">    <span class="built_in">cerr</span> &lt;&lt; <span class="string">"Unable to open file "</span>&lt;&lt; fileName &lt;&lt; <span class="string">"("</span> &lt;&lt; e &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>另外，也可抛出一个C风格的<code>const char*</code>字符串。这项技术有时有用，因为字符串可包含与异常相关的信息。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; readIntegerFile(string_view fileName) &#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">inputStream</span> <span class="params">(fileName .data())</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (inputStream.fail()) &#123;</span><br><span class="line">        <span class="comment">// We failed to open the file：throw an exception</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="string">"Unable to open file"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当捕获<code>const char*</code>异常时，可输出结果:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    myInts = readIntegerFile (fileName);</span><br><span class="line">&#125; <span class="keyword">catch</span> (<span class="keyword">const</span> <span class="keyword">char</span>* e) &#123; </span><br><span class="line">    <span class="built_in">cerr</span> &lt;&lt; e &lt;&lt; end1;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>尽管前面有这样的示例，但通常应将对象作为异常抛出，原因有以下两点：</p>
<ul>
<li>对象的类名可传递信息。</li>
<li>对象可存储信息，包括描述异常的字符串。</li>
</ul>
<h3 id="按const和引用捕获异常对象"><a href="#按const和引用捕获异常对象" class="headerlink" title="按const和引用捕获异常对象"></a>按const和引用捕获异常对象</h3><p>在前面的示例中，<code>readIntegerFile()</code>抛出一个<code>exception</code>类型的对象。catch 行如下所示:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">) <span class="keyword">catch</span> (<span class="keyword">const</span> exception&amp; e) (</span><br></pre></td></tr></table></figure></p>
<p>然而，在此并没有要求按const引用捕获对象，可按值捕获对象；此外，也可按非const引用捕获对象:</p>
<h3 id="抛出并捕获多个异常"><a href="#抛出并捕获多个异常" class="headerlink" title="抛出并捕获多个异常"></a>抛出并捕获多个异常</h3><p>可让函数抛出两种不同类型的异常。<code>invalid_argument</code>和<code>runtime_error</code>都是定义在<code>&lt;stdexcept&gt;</code>头文件中的类，这个头文件是C++标准库的一部分。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; readIntegerFile(string_view fileName) &#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">inputstream</span><span class="params">(fileName.data())</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (inputStream.fail())</span><br><span class="line">        <span class="keyword">throw</span> invalid argument (<span class="string">"Unable to open the file."</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; integers;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">while</span> (inputstream &gt;&gt; temp)</span><br><span class="line">        integers.push_back(temp);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!inputstream.eof()) </span><br><span class="line">        <span class="keyword">throw</span> runtime_error(<span class="string">"Error reading the file."</span>);</span><br><span class="line">    <span class="keyword">return</span> integers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>invalid_argument</code>和<code>runtime_error</code>类没有公有的默认构造函数，只有以字符串作为参数的构造函数。现在<code>main()</code>可用两个<code>catch</code>语句捕获<code>invalid_argument</code>和<code>runtime_error</code>异常：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">catch</span> (<span class="keyword">const</span> invalid_arguments&amp; e) &#123;</span><br><span class="line">    <span class="built_in">cerr</span> &lt;&lt; e.what() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (<span class="keyword">const</span> runtime_error&amp; e) &#123;</span><br><span class="line">    <span class="built_in">cerr</span> &lt;&lt; e.what() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果异常在try块内部抛出，编译器将使用恰当的catch处理程序与异常类型匹配。因此，如果<code>readIntegerFile()</code>无法打开文件并抛出invalid_argument异常，第一个catch语句将捕获这个异常。如果<code>readntegerFile()</code>无法正确读取文件并抛出<code>runtime_error</code>异常，第二个catch语句将捕获这个异常。</p>
<h4 id="匹配和const"><a href="#匹配和const" class="headerlink" title="匹配和const"></a>匹配和const</h4><p>对于想要捕获的异常类型而言，增加const属性不会影响匹配的目的。也就是说,这一行可以与<code>runtime_error</code>类型的任何异常匹配:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">) <span class="keyword">catch</span> (<span class="keyword">const</span> runtime_errors e) (</span><br></pre></td></tr></table></figure></p>
<h4 id="匹配所有异常"><a href="#匹配所有异常" class="headerlink" title="匹配所有异常"></a>匹配所有异常</h4><p>可用特定语法编写与所有异常匹配的catch行，如下所示:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    myInts = readIntegeile (fileName) ;</span><br><span class="line">&#125; <span class="keyword">catch</span> (...) &#123;</span><br><span class="line">    <span class="built_in">cerr</span> &lt;&lt; <span class="string">"Error reading or opening file"</span> &lt;&lt; fileName &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>三个点是与所有异常类型匹配的通配符。与所有异常匹配的catch块可以用作默认的catch处理程序。当异常抛出时，会按在代码中的显示顺序查找catch处理程序。下例用catch处理程序显式地处理<code>invalid_argument</code>和<code>runtime_error</code>异常，并用默认的catch处理程序处理其他所有异常。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// Code that can throw exceptions</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (<span class="keyword">const</span> invalid argument&amp; e) &#123;</span><br><span class="line">    <span class="comment">// Handle invalid_argument exception</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (<span class="keyword">const</span> runtime_errore e) &#123;</span><br><span class="line">    <span class="comment">// Handle runtime_error exception</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (...) &#123;</span><br><span class="line">    <span class="comment">// Handle all other exceptions</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="未捕获的异常"><a href="#未捕获的异常" class="headerlink" title="未捕获的异常"></a>未捕获的异常</h3><p>如果程序抛出的异常没有捕获，程序将终止。可对<code>main()</code>函数使用trycatch结构，以捕获所有未经处理的异常，如下所示:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    main(argc, argv);</span><br><span class="line">&#125; <span class="keyword">catch</span> (...) &#123;</span><br><span class="line">    <span class="comment">// issue error message and terminate program</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然而，这一行为通常并非我们希望的。异常的作用在于给程序一个机会，以处理和修正不希望看到的或不曾预期的情况。</p>
<p>当程序遇到未捕获的异常时，会调用内建的<code>terminate()</code>函数，这个函数调用<code>&lt;stdlib&gt;</code>中的<code>abort()</code>来终止程序。可调用<code>set_terminate()</code>函数设置自己的<code>terminate_handler()</code>，这个函数采用指向回调函数(既没有参数，也没有返回值)的指针作为参数。<code>terminat()</code>、<code>set_terminate()</code>和<code>terminate_handler()</code>都在<code>&lt;exception&gt;</code>头文件中声明。下面的代码高度概括了其运行原理：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    main(argc, argv);</span><br><span class="line">) <span class="keyword">catch</span> (...) &#123;</span><br><span class="line">    <span class="keyword">if</span> (terminate_handler != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        terminate_handler();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        terminate();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>回调函数必须终止程序。错误是无法忽略的，然而可在退出之前输出一条有益的错误消息。下例中，<code>main()</code>函数没有捕获<code>readIntegerFile()</code>抛出的异常，而将<code>teminate_handler()</code>设置为自定义回调。这个回调通过调用<code>exit()</code>显示错误消息并终止进程。<code>exit()</code>函数接收返回给操作系统的一个整数，这个整数可用于确定进程的退出方式。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myTerminate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Uncaught exception!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    set_terminate (myTerminate);</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">string</span> fileName = <span class="string">"IntegerFile.txt"</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="function">myInts <span class="title">readIntegerFile</span><span class="params">(fileName)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; element ：myInts)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; element &lt;&lt; <span class="string">"  "</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当设置新的<code>terminate_handler()</code>时，<code>set_terminate()</code>会返回旧的<code>terminate_handler()</code>。<code>terminate_handler()</code>被应用于整个程序，因此当需要新<code>terminate_handler()</code>的代码结束后，最好重新设置旧的<code>terminate_handler()</code>。</p>
<blockquote>
<p>在专门编写的软件中，通常会设置<code>terminate_handler()</code>，在进程结束前创建崩溃转储。此后将崩溃转储上传给调试器，从而允许确定未捕获的异常是什么，起因是什么。</p>
</blockquote>
<h3 id="noexcept"><a href="#noexcept" class="headerlink" title="noexcept"></a>noexcept</h3><p>使用函数时，可使用noexcept关键字标记函数，指出它不抛出任何异常。</p>
<p>如果一个函数带有noexcept标记，却以某种方式抛出了异常，C++将调用<code>terminate()</code>来终止应用程序。在派生类中重写虚方法时，可将重写的虛方法标记为noexcep，即使基类中的版本不是noexcept。</p>
<h3 id="抛出列表"><a href="#抛出列表" class="headerlink" title="抛出列表"></a>抛出列表</h3><p>C++的旧版本允许指定函数或方法可抛出的异常，这种规范叫作抛出列表(throw list)或异常规范(exception specification)。</p>
<blockquote>
<p>自C++11之后，已不赞成使用异常规范；自C++17之后，已不再支持异常规范。但<code>noexcept</code>和<code>throw()</code>除外。</p>
</blockquote>
<p>自C++11之后，异常规范虽然仍受支持，但已经极少使用。下面的这个<code>readIntegerFile()</code>函数包含了异常规范:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; readIntegerFile(string_view fileName) <span class="keyword">throw</span> (invalid_argument, runtime_error) &#123; &#125;</span><br></pre></td></tr></table></figure></p>
<p>如果函数抛出的异常不在异常规范内，C++运行时<code>std:unexpected()</code>默认情况下调用<code>std:teminate()</code>来终止应用程序。</p>
<h2 id="异常与多态性"><a href="#异常与多态性" class="headerlink" title="异常与多态性"></a>异常与多态性</h2><p>类是最有用的异常类型。实际上异常类通常具有层次结构，因此在捕获异常时可使用多态性。</p>
<h3 id="标准异常体系"><a href="#标准异常体系" class="headerlink" title="标准异常体系"></a>标准异常体系</h3><p>图14-3显了完整的层次结构。<br><img src="/img/1619834310.jpg" alt></p>
<p>这个层次结构中的每个类都支持<code>what()</code>方法，这个方法返回一个描述异常的<code>const char*</code>字符串。可在错误信息中使用这个字符串。大多数异常类(基类exception是明显的例外)都要求在构造函数中设置<code>what()</code>返回的字符串。<code>readntegerFile()</code>的另一个版本在错误消息中包含文件名。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; readIntegerFile(string_view fileName) &#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">inputstream</span> <span class="params">(fileName.data())</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (inputstream.fail()) &#123;</span><br><span class="line">        <span class="comment">// We failed to open the file: throw an exception</span></span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">string</span> error = <span class="string">"Unable to open file "</span>s + fileName.data();</span><br><span class="line">        <span class="keyword">throw</span> invalid_argument (error);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Read the integers one-by-one and add them to a vector</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; integers; </span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">while</span> (inputstream &gt;&gt; temp) &#123;</span><br><span class="line">        integers.push_back(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!inputstream.eof()) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">string</span> error = <span class="string">"Unable to read file "</span>s + fileName.data();</span><br><span class="line">        <span class="keyword">throw</span> runtime_error (error);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> integers;</span><br></pre></td></tr></table></figure></p>
<h3 id="在类层次结构中捕获异常"><a href="#在类层次结构中捕获异常" class="headerlink" title="在类层次结构中捕获异常"></a>在类层次结构中捕获异常</h3><p>异常层次结构的一个特性是可利用多态性捕获异常。例如，如果观察<code>main()</code>中调用<code>readIntegerFile()</code>之后的两条catch语句，就可以发现这两条语句除了处理的异常类不同之外没有区别。<code>invalid_argument</code>和<code>runtime_error</code>都是exception的派生类，因此可使用exception类的一条catch语句替换这两条catch 语句:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    myInts = readIntegerFile (fileName);</span><br><span class="line">&#125; <span class="keyword">catch</span> (<span class="keyword">const</span> exception&amp; e) &#123;</span><br><span class="line">    <span class="built_in">cerr</span> &lt;&lt; e.what() &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>exception引用的catch语句可与exception的任何派生类匹配。</p>
<blockquote>
<p>当利用多态性捕获异常时，一定要按引用捕获。如果按值捕获异常，就可能发生截断，在此情况下将丢失对象的信息。</p>
</blockquote>
<p>当使用了多条catch子句时，会按在代码中出现的顺序匹配catch子句，第一条匹配的catch子句将被执行。如果某条catch子句比后面的catch子句范围更广，那么这条catch子句首先被匹配，而后面限制更多的catch子句根本不会被执行。因此，catch子句应按限制最多到限制最少的顺序出现。例如，假定要显式捕获<code>readIntegerFile()</code>的<code>invalid_argument</code>，就应该让一般的异常与其他类型的异常匹配。正确做法如下所示:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    myInts = readIntegerFile (fileName) ;</span><br><span class="line">&#125; <span class="keyword">catch</span> (<span class="keyword">const</span> invalid_argument&amp; e) ( <span class="comment">// List the derived class first.</span></span><br><span class="line">    <span class="comment">// Take some special action for invalid filename s</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (<span class="keyword">const</span> exception&amp; e) &#123; <span class="comment">// Now list exception</span></span><br><span class="line">    <span class="built_in">cerr</span> &lt;&lt; e.what() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第一条catch子句捕获<code>invalid_argument</code>异常，第二条catch子句捕获任何类型的其他异常。然而，如果将catch子句的顺序弄反，第一条catch子句会捕获任何派生类类型的异常，第二条catch子句永远无法执行。</p>
<h3 id="编写自己的异常类"><a href="#编写自己的异常类" class="headerlink" title="编写自己的异常类"></a>编写自己的异常类</h3><p>编写自己的异常类有两个好处：</p>
<ol>
<li>C++标准库中的异常数目有限，可在程序中为特定错误创建更有意义的类名</li>
<li>可在异常中加入自己的信息，而标准层次结构中的异常只允许设置错误字符串</li>
</ol>
<p>建议自己编写的异常类从标准的exception类直接或间接继承。例如，在<code>readIntegerFile()</code>中，<code>invalid_argument</code>和<code>runtime_error</code>不能很好地捕获文件打开和读取错误。可为文件错误定义自己的错误层次结构，从泛型类FileError开始:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileError</span> ：<span class="title">public</span> <span class="title">exception</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:.</span><br><span class="line">    FileError(string_view fileName) ：mFileName (fileName) &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">what</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mMessage.c_str();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string_view <span class="title">getFileName</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> mFileName; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setMessage</span> <span class="params">(string_view message)</span> </span>&#123; mMessage = message; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> mFileName;</span><br><span class="line">    <span class="built_in">string</span> mMessage;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>编写exception的派生类时，需要重写<code>what()</code>方法，其返回值为一个在对象销毁之前一直有效的<code>const char*</code>字符串。在<code>FileError</code>中，这个字符串来自<code>mMessage</code>数据成员。<code>FileError</code>的派生类可使用受保护的<code>setMessage()</code>方法设置消息。泛型类`FileError还包含文件名以及文件名的公共访问器。</p>
<p>在编写将其对象用作异常的类时，有一个诀窍。当某段代码抛出一个异常时，使用移动构造函数或复制构造函数，移动或复制被抛出的值或对象。因此，如果编写的类的对象将作为异常抛出，对象必须复制和或移动。这意味着如果动态分配了内存，就必须编写析构函数、复制构造函数、复制赋值运算符和或移动构造函数与移动赋值运算符。</p>
<blockquote>
<p>作为异常抛出的对象至少要复制或移动一次。异常可能被复制多次，但只有按值(而不是按引用)捕获异常才会如此。</p>
<p>按引用(最好是const 引用)捕获异常对象可避免不必要的复制。</p>
</blockquote>
<h3 id="嵌套异常"><a href="#嵌套异常" class="headerlink" title="嵌套异常"></a>嵌套异常</h3><p>当处理第一个异常时，可能触发第二个异常，从而要求抛出第二个异常。遗憾的是，当抛出第二个异常时，正在处理的第一个异常的所有信息都会丢失。C++用嵌套异常(nested exception)提供了解决这一问题的方案，嵌套异常允许将捕获的异常嵌套到新的异常环境。</p>
<p>使用<code>std::throw_with_nested()</code>抛出一个异常时，这个异常中嵌套着另一个异常。第二个异常的catch处理程序可使用<code>dynamic_cast()</code>访问代表第一个异常的<code>nested_exception</code>。下例演示了嵌套异常的用法。这个示例定义了一个从exception类派生的MyException类，其构造函数接收一个字符串。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyException</span> ：<span class="title">public</span> <span class="title">std</span>:</span>:exception &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyException(string_view message) : mMessage (message) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">what</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mMessage.c_str();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> mMessage;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>当处理第一个异常且需要抛出嵌套了第一个异常的第二个异常时，需要使用<code>std::throw_with_nested()</code>函数。下面的<code>doSomething()</code>函数抛出一个<code>runtime_error</code>异常，这个异常立即被catch处理程序捕获。catch 处理程序编写了一条消息，然后使用<code>std::throw_with_nested()</code>函数抛出第二个异常，第一个异常嵌套在其中。注意嵌套异常是自动实现的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> runtime_error(<span class="string">"Throwing a runtime_error exception"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="keyword">const</span> runtime_error&amp; e) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"caught a runtime_error"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        throw_with_nested(MyException (<span class="string">"MyException with std::throw_with_nested()"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当捕获到这类异常时，会编写一条消息，然后使用<code>dynamic_cast()</code>访问嵌套的异常。如果内部没有嵌套异常，结果为空指针。如果有嵌套异常，会调用<code>nested_exception</code>的<br><code>rethrow_nested()</code>方法。这样会再次抛出嵌套异常，这一异常可在另一个try/catch块中捕获。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        doSomething();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="keyword">const</span> MyException&amp; e) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"caught MyException："</span> &lt;&lt; e.what() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">auto</span>* pNested = <span class="keyword">dynamic_cast</span>&lt;<span class="keyword">const</span> nested_exception*&gt;(&amp;e);</span><br><span class="line">        <span class="keyword">if</span> (pNested) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                pNested-&gt;rethrow_nested();</span><br><span class="line">            &#125; <span class="keyword">catch</span>(<span class="keyword">const</span> runtime_error&amp; e) &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; e.what() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>前面的<code>main()</code>函数使用<code>dynamic_cast()</code>检测嵌套异常。如果想要检测嵌套异常，就不得不经常执行<code>dynamic_cast()</code>，因此标准库提供了一个名为<code>std::rethrow_if_nested()</code>的小型辅助函数，其用法如下所示:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125; <span class="keyword">catch</span> (<span class="keyword">const</span> MyException&amp; e) &#123;</span><br><span class="line">    rethrow_if_nested(e);</span><br><span class="line">&#125; <span class="keyword">catch</span> (<span class="keyword">const</span> runtime_error&amp; e) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Nested exception："</span>&lt;&lt; e.what() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure></p>
<h2 id="重新抛出异常"><a href="#重新抛出异常" class="headerlink" title="重新抛出异常"></a>重新抛出异常</h2><p>可使用throw关键字重新抛出当前异常，如下例所示:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123; <span class="keyword">throw</span> invalid_argument (<span class="string">"Some exception"</span>); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        g();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="keyword">const</span> invalid_argument&amp; e) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"caught in f:"</span> &lt;&lt; e.what() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">throw</span>; <span class="comment">// rethrow</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>始终使用<code>throw;</code>重新抛出异常。永远不要试图用<code>throw e;</code>重新抛出e，因为这样存在潜在的截断风险，可能丢失信息。</p>
</blockquote>
<h2 id="堆栈的释放与清理"><a href="#堆栈的释放与清理" class="headerlink" title="堆栈的释放与清理"></a>堆栈的释放与清理</h2><p>当发现catch处理程序时，堆栈会释放所有中间堆栈帧，直接跳到定义catch处理程序的堆栈层。堆栈释放(stack unwinding)意味着调用所有具有局部作用域的名称的析构函数，并忽略在当前执行点之前的每个函数中所有的代码。然而当释放堆栈时，并不释放指针变量，也不会执行其他清理。在C++中，应该用基于堆栈的内存分配或者下面将要讨论的技术处理这种情况。</p>
<h3 id="使用智能指针"><a href="#使用智能指针" class="headerlink" title="使用智能指针"></a>使用智能指针</h3><p>如果基于堆栈的内存分配不可用，就应使用智能指针。在处理异常时，智能指针可使编写的代码自动防止内存或资源的泄漏。无论什么时候销毁智能指针对象，都会释放底层资源。下 面使用了智能指针<code>unique_ptr</code>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">funcOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> strl;</span><br><span class="line">    <span class="keyword">auto</span> str2 = make_unique&lt;<span class="built_in">string</span>&gt; (<span class="string">"hello"</span>);</span><br><span class="line">    funcTwo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当从<code>funcOne()</code>返回或抛出异常时，将自动删除str2指针。</p>
<h3 id="捕获、清理并重新抛出"><a href="#捕获、清理并重新抛出" class="headerlink" title="捕获、清理并重新抛出"></a>捕获、清理并重新抛出</h3><p>避免内存和资源泄漏的另一种技术是针对每个函数，捕获可能抛出的所有异常，执行必要的清理，并重新抛出异常，供堆栈中更高层的函数处理。下面是使用这一技术修改后的<code>funcOne()</code>函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">funcOne</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str1;</span><br><span class="line">    <span class="built_in">string</span>* str2 = <span class="keyword">new</span> <span class="built_in">string</span>();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        funcTwo () ;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (...) &#123;</span><br><span class="line">        <span class="keyword">delete</span> str2;</span><br><span class="line">        <span class="keyword">throw</span>; <span class="comment">// Rethrow the exception.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> str2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个函数用异常处理程序封装对<code>funcTwo()</code>函数的调用，处理程序执行清理(在str2上调用delete)并重新抛出异常。关键字throw本身会重新抛出最近捕获的任何异常。注意catch语句使用…语法捕获所有异常。这一方法运行良好，但有点繁杂。需要特别注意，现在有两行完全相同的代码在str2上调用<code>delete</code>。</p>
<h2 id="常见的错误处理问题"><a href="#常见的错误处理问题" class="headerlink" title="常见的错误处理问题"></a>常见的错误处理问题</h2><h3 id="内存分配错误"><a href="#内存分配错误" class="headerlink" title="内存分配错误"></a>内存分配错误</h3><p>如果无法分配内存，<code>new</code>和<code>new[]</code>的默认行为是抛出<code>bad_alloc</code>类型的异常，这种异常类型在<code>&lt;new&gt;</code>头文件中定义。代码应该捕获并正确地处理这些异常。</p>
<p>不可能把对<code>new</code>和<code>new[]</code>的调用都放在try/catch块中，但至少在分配大块内存时应这么做。下例演示了如何捕获内存分配异常:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* ptr = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">size_t</span> integerCount = numeric_limits&lt;<span class="keyword">size_t</span>&gt;::max();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    ptr = <span class="keyword">new</span> <span class="keyword">int</span> [integerCount];</span><br><span class="line">&#125; <span class="keyword">catch</span> (<span class="keyword">const</span> bad_alloc&amp; e) &#123;</span><br><span class="line">    <span class="built_in">cerr</span> &lt;&lt; <span class="string">"Unable to allocate memory:"</span> &lt;&lt; e.what() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>另一个考虑是记录错误时可能尝试分配内存。如果new执行失败，可能没有记录错误消息的足够内存。</p>
<h4 id="不抛出异常的new"><a href="#不抛出异常的new" class="headerlink" title="不抛出异常的new"></a>不抛出异常的new</h4><p>旧的C模式下，如果无法分配内存，内存分配例程将返回一个空指针。C++提供了<code>new</code>和<code>new[]</code>的<code>nothrow</code>版本，如果内存分配失败，将返回<code>nullptr</code>，而不是抛出异常。使用语<br>法<code>new(nothrow)</code>而不是<code>new</code>可做到这一点，如下所示:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* ptr = <span class="keyword">new</span> (nothrow) <span class="keyword">int</span> [integerCount];</span><br><span class="line"><span class="keyword">if</span> (ptr == <span class="literal">nullptr</span>)</span><br><span class="line">    <span class="built_in">cerr</span> &lt;&lt; <span class="string">"Unable to allocate memory!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p>
<h4 id="定制内存分配失败的行为"><a href="#定制内存分配失败的行为" class="headerlink" title="定制内存分配失败的行为"></a>定制内存分配失败的行为</h4><p>C++允许指定<code>new handler</code>回调函数。默认情况下不存在<code>new handler</code>，因此<code>new</code>和<code>new[]</code>只是抛出<code>bad_alloc</code>异常。然而如果存在<code>new handler</code>，当内存分配失败时，内存分配例程会调用<code>new handler</code>而不是抛出异常。如果<code>new handler</code>返回，内存分配例程试着再次分配内存：如果失败，会再次调用<code>new handler</code>。这个循环变成无限循环，除非<code>new handler</code>用下面的3个选项之一改变这种情况。下面列出这些选项，并给出了注释:</p>
<ul>
<li><strong>提供更多的可用内存</strong> 提供空间的技巧之一是在程序启动时分配一大块内存，然后在<code>new handler</code>中释放这块内存。关键在于，在程序启动时，分配一块足以完整保存文档的内存。当触发<code>new handler</code>时，可释放这块内存、保存文档、重启应用程序并重新加载保存的文档。</li>
<li><strong>抛出异常</strong> C++标准指出，如果<code>new handler</code>抛出异常，那么必须是<code>bad_alloc</code>异常或者派生于<code>bad_alloc</code>的异常。<ul>
<li>可编写和抛出<code>document_recovery_alloc</code>异常，这种异常从<code>bad_alloc</code>继承而来。可在应用程序的某个地方捕获这种异常，然后触发文档保存操作，并重启应用程序。</li>
<li>可编写和抛出派生于<code>bad_alloc</code>的<code>please_terminate_me</code>异常。在顶层函数中可捕获这种异常，并通过从顶层函数返回来对其进行处理。</li>
</ul>
</li>
<li><strong>设置不同的<code>new handler</code></strong> 从理论上讲，可使用一系列 <code>new handler</code>，每个都试图分配内存，并在失败时设置一个不同的<code>new handler</code>。然而，这种情形通常过于复杂，并不实用。</li>
</ul>
<p>如果在<code>new handler</code>中没有这么做，任何内存分配失败都会导致无限循环。</p>
<p>如果有一些内存分配会失败，但又不想调用<code>new handler</code>，那么在调用new之前，只需要临时将新的<code>new handler</code>重新设置为默认值nullptr。</p>
<p>调用在<code>&lt;new&gt;</code>头文件中声明的<code>set_new_handler()</code>，从而设置<code>new handler</code>。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">please_terminate_me</span> ：<span class="title">public</span> <span class="title">bad_alloc</span> &#123;</span> &#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myNewHandler</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cerr</span> &lt;&lt; <span class="string">"Unable to allocate memory."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">throw</span> please_terminate_me();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>new handler</code> 不能有参数，也不能返回值。如前面列表中的第2个选项所述，<code>new handler</code> 抛出<code>please_terminate_me</code>异常。可采用以下方式设置<code>new handler</code>:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    <span class="keyword">try</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Set the new new_handler and save the old one.</span></span><br><span class="line">        new_handler oldHandler = set_new_handler (myNewHandler);</span><br><span class="line">        <span class="comment">// Generate allocation error.</span></span><br><span class="line">        <span class="keyword">size_t</span> numInts = numeric_limits&lt;<span class="keyword">size_t</span>&gt;::max();</span><br><span class="line">        <span class="keyword">int</span>* ptr = <span class="keyword">new</span> <span class="keyword">int</span> [numInts];</span><br><span class="line">        <span class="comment">// Reset the old new_handler</span></span><br><span class="line">        set_new_handler(oldHandler);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="keyword">const</span> please_terminate_me&amp;) &#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">"Terminating program."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意<code>new_handler</code>是函数指针类型的typedef，<code>set_new_handler()</code>会将其作为参数。</p>
<h3 id="构造函数中的错误"><a href="#构造函数中的错误" class="headerlink" title="构造函数中的错误"></a>构造函数中的错误</h3><p>虽然无法在构造函数中返回值，但是可以抛出异常。通过异常可很方便地告诉客户是否成功创建了对象。在异常离开构造函数前，必须在构造函数中仔细清理所有资源，并释放分配的所有内存。本节以Matix类作为示例，这个类的构造函数可正确处理异常。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Matrix</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Matrix(<span class="keyword">size_t</span> width, <span class="keyword">size_t</span> height);</span><br><span class="line">    <span class="keyword">virtual</span> ~Matrix();</span><br><span class="line"><span class="keyword">private</span> :</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cleanup</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">size_t</span> mWidth = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">size_t</span> mHeight = <span class="number">0</span>;</span><br><span class="line">    T** mMatrix = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Matrix类的实现如下所示。注意：</p>
<ul>
<li>对new的第一个调用并没有用try/catch块保护。第一个new抛出异常也没有关系，因为构造函数此时还没有分配任何需要释放的内存。如果后面的new抛出异常，构造函数必须清理所有已经分配的内存。</li>
<li>由于不知道T构造函数本身会抛出什么异常，因此用…捕获所有异常，并将捕获的异常嵌套在<code>bad_alloc</code>异常中。</li>
<li>使用{}语法，通过首次调用new分配的数组执行零初始化，即每个元素都是nullptr。这简化了<code>cleanup()</code>方法，因为允许它在nullptr上调用delete。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Matrix&lt;T&gt;::Matrix(<span class="keyword">size_t</span> width, <span class="keyword">size_t</span> height) &#123;</span><br><span class="line">    mMatrix = <span class="keyword">new</span> T* [width] &#123;&#125;; <span class="comment">// Array is zero-initialized!</span></span><br><span class="line">    mwidth = width;</span><br><span class="line">    mHeight = height;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; width; ++i) &#123;</span><br><span class="line">            mMatrix[i] = <span class="keyword">new</span> T[height];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (...) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"Exception caught in constructor, cleaning up..."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        cleanup();</span><br><span class="line">        <span class="comment">// Nest any caught exception inside a bad_alloc exception .</span></span><br><span class="line">        <span class="built_in">std</span>::throw_with_nested(<span class="built_in">std</span>::bad_alloc());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Matrix&lt;T&gt;::~Matrix() &#123;</span><br><span class="line">    cleanup();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> Matrix&lt;T&gt;::cleanup() &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mWidth; ++i) </span><br><span class="line">        <span class="keyword">delete</span>[]] mMatrix[i];</span><br><span class="line">    <span class="keyword">delete</span>[] mMatrix;</span><br><span class="line">    mMatrix = <span class="literal">nullptr</span>;</span><br><span class="line">    mWidth = mHeight = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果异常离开了构造函数，将永远不会调用对象的析构函数!</p>
</blockquote>
<h3 id="构造函数的function-try-blocks"><a href="#构造函数的function-try-blocks" class="headerlink" title="构造函数的function-try-blocks"></a>构造函数的function-try-blocks</h3><p>function-try-blocks用于普通函数和构造函数。本节重点介绍functin-try-blocks如何用于构造函数。下面的伪代码显示了构造函数的function-try-blocks的基本语法:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MyClass::MyClass()</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">    : &lt;ctor-initializer&gt;</span><br><span class="line">&#123; <span class="comment">/* constructor body ... */</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (<span class="keyword">const</span> exception&amp; e) &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看出，try关键字应该刚好在ctor itializer之前。catch 语句应该在构造函数的右花括号之后，实际上是将catch语句放在构造函数体的外部。当使用构造函数的function-try-blocks时，要记住如下限制和指导方针:</p>
<ul>
<li>catch语句将捕获任何异常，无论是构造函数体还是ctor-intializer直接或间接抛出的异常，都是如此。</li>
<li>catch语句必须重新抛出当前异常或抛出一个新异常。如果catch语句没有这么做，运行时将自动重新拋出当前异常。</li>
<li>atch语句可访问传递给构造函数的参数。</li>
<li>当catch语句捕获function-tryblocks内的异常时，构造函数已构建的所有对象都会在执行catch 语句之前销毁。</li>
<li>在catch语句中，不应访问对象成员变量，因为它们在执行catch语句前就销毁了。 但是，如果对象包含非类数据成员，例如裸指针，并且它们在抛出异常之前初始化，就可以访问它们。如果有这样的裸资源，就必须在catch语句中释放它们。</li>
<li>对于functio-try-blocks中的catch语句而言，其中包含的函数不能使用return关键字返回值。构造函数与此无关，因为构造函数没有返回值。</li>
</ul>
<p>由于有以上限制，构造函数的function-try-blocks 只在少数情况下有用:</p>
<ul>
<li>将ctor-intializer抛出的异常转换为其他异常。</li>
<li>将消息记录到日志文件。</li>
<li>释放在抛出异常之前就在ctor intializer 中分配了内存的裸资源。</li>
</ul>
<p>下例演示function-try-blocks的用法<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Subobject</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Subobject(<span class="keyword">int</span> i);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Subobject::Subobject(<span class="keyword">int</span> i) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">std</span>::runtime_error (<span class="string">"Exception by Subobject ctor"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>MyClass</code>类有一个<code>int*</code>类型的成员变量以及一个SubObject类型的成员变量:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyClass();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span>* mData = <span class="literal">nullptr</span>;</span><br><span class="line">    Subobject mSubobject;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>SubObject 类没有默认构造函数。这意味着需要在MyClass类的ctor-intializer中初始化mSubObject。MyClass类的构造函数将使用function-try-blocks 捕获ctor-intializer 中抛出的异常。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MyClass::MyClass ()</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">: mData(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">42</span>]&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;), mSubobject (<span class="number">42</span>) &#123;</span><br><span class="line">    <span class="comment">/* ... constructor body ... */</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (<span class="keyword">const</span> <span class="built_in">std</span>::exception6 e) &#123;</span><br><span class="line">    <span class="comment">// Cleanup memory.</span></span><br><span class="line">    <span class="keyword">delete</span>[] mData;</span><br><span class="line">    mData = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>记住，构造函数的function-try-blocks中的catch语句必须重新抛出当前异常，或者抛出新异常。前面的catch语句没有抛出任何异常，因此C++运行时将自动重新抛出当前异常。下面的简单函数使用了前面的类:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">try</span> </span>&#123;</span><br><span class="line">    MyClass m;</span><br><span class="line">&#125; <span class="keyword">catch</span> (<span class="keyword">const</span> <span class="built_in">std</span>::exception&amp; e) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"main() caught: "</span> &lt;&lt; e.what() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通常，仅将裸资源作为数据成员时，才有必要使用function-try-blocks. 可使用诸如<code>std::unique_ptr</code>的RAII类来避免使用裸资源。</p>
<h3 id="析构函数中的错误"><a href="#析构函数中的错误" class="headerlink" title="析构函数中的错误"></a>析构函数中的错误</h3><p>必须在析构函数内部处理析构函数引起的所有错误。不应该让析构函数抛出任何异常，原因如下:</p>
<ol>
<li>析构函数会被隐式标记为noexcept，除非添加了<code>noexcept(false)</code>标记，或者类具有子对象，而子对象的析构函数是<code>noexcept(false)</code>。如果带noexcept标记的析构函数抛出一个异常， C++运行时会调用<code>std::teminate()</code>来终止应用程序。</li>
<li>在堆栈释放过程中，如果存在另一个挂起的异常，析构函数可以运行。如果在堆栈释放期间从析构函数抛出一个异常，C++运行时会调用<code>std::terminate()</code>来终止应用程序。<code>&lt;exception&gt;</code>头文件中声明了一个函数<code>uncaught_exception()</code>，该函数可返回未捕获异常的数量；所谓未捕获异常，是指已经抛出但尚未到达匹配catch的异常。如果<code>uncaught_exceptions()</code>的结果大于0，则说明正在执行堆栈释放。</li>
<li>客户不会显式调用析构函数：客户调用delete，delete调用析构函数。如果在析构函数中抛出一个异常，客户无法在此使用对象调用delete，也不能显式地调用析构函数。</li>
<li>析构函数是释放对象使用的内存和资源的一个机会。如果因为异常而提前退出这个函数，就会浪费这个机会，将永远无法回头释放内存或资源。</li>
</ol>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/C/" rel="tag"># C++</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/05/02/cpp高级编程 笔记3/" rel="next" title="C++高级编程 第四版 笔记3">
                <i class="fa fa-chevron-left"></i> C++高级编程 第四版 笔记3
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/05/07/cpp高级编程 笔记5/" rel="prev" title="C++高级编程 第四版 笔记5">
                C++高级编程 第四版 笔记5 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/header.jpg" alt="Hao Yu">
            
              <p class="site-author-name" itemprop="name">Hao Yu</p>
              <p class="site-description motion-element" itemprop="description">Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author</p>
          </div>
          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">353</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>
        	<audio controls="controls" loop="loop" preload="auto" src="/resource/xiaomeihao.mp3">
	        </audio>
	

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yuhao0102" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:yuh18@mails.tsinghua.edu.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#C-IO揭秘"><span class="nav-number">1.</span> <span class="nav-text">C++ IO揭秘</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#使用流"><span class="nav-number">1.1.</span> <span class="nav-text">使用流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#流的含义"><span class="nav-number">1.1.1.</span> <span class="nav-text">流的含义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#流的来源和目的地"><span class="nav-number">1.1.2.</span> <span class="nav-text">流的来源和目的地</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#流式输出"><span class="nav-number">1.1.3.</span> <span class="nav-text">流式输出</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#输出的基本概念"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">输出的基本概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#输出流的方法"><span class="nav-number">1.1.3.2.</span> <span class="nav-text">输出流的方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#put-和write"><span class="nav-number">1.1.3.2.1.</span> <span class="nav-text">put()和write()</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#flush"><span class="nav-number">1.1.3.3.</span> <span class="nav-text">flush()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#处理输出错误"><span class="nav-number">1.1.3.4.</span> <span class="nav-text">处理输出错误</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#输出操作算子"><span class="nav-number">1.1.3.5.</span> <span class="nav-text">输出操作算子</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#流式输入"><span class="nav-number">1.1.4.</span> <span class="nav-text">流式输入</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#输入的基本概念"><span class="nav-number">1.1.4.1.</span> <span class="nav-text">输入的基本概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#处理输入错误"><span class="nav-number">1.1.4.2.</span> <span class="nav-text">处理输入错误</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#输入方法"><span class="nav-number">1.1.4.3.</span> <span class="nav-text">输入方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#get"><span class="nav-number">1.1.4.3.1.</span> <span class="nav-text">get()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#unget"><span class="nav-number">1.1.4.3.2.</span> <span class="nav-text">unget()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#putback"><span class="nav-number">1.1.4.3.3.</span> <span class="nav-text">putback()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#peek"><span class="nav-number">1.1.4.3.4.</span> <span class="nav-text">peek()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#getine"><span class="nav-number">1.1.4.3.5.</span> <span class="nav-text">getine()</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#输入操作算子"><span class="nav-number">1.1.4.4.</span> <span class="nav-text">输入操作算子</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字符串流"><span class="nav-number">1.2.</span> <span class="nav-text">字符串流</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件流"><span class="nav-number">1.3.</span> <span class="nav-text">文件流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#文本模式与二进制模式"><span class="nav-number">1.3.1.</span> <span class="nav-text">文本模式与二进制模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#通过seek-和tell-在文件中转移"><span class="nav-number">1.3.2.</span> <span class="nav-text">通过seek()和tell()在文件中转移</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#将流链接在一起"><span class="nav-number">1.3.3.</span> <span class="nav-text">将流链接在一起</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#双向I-O"><span class="nav-number">1.4.</span> <span class="nav-text">双向I/O</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#错误处理"><span class="nav-number">2.</span> <span class="nav-text">错误处理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#错误与异常"><span class="nav-number">2.1.</span> <span class="nav-text">错误与异常</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#异常的含义"><span class="nav-number">2.1.1.</span> <span class="nav-text">异常的含义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-中异常的优点"><span class="nav-number">2.1.2.</span> <span class="nav-text">C++中异常的优点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#异常机制"><span class="nav-number">2.2.</span> <span class="nav-text">异常机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#抛出和捕获异常"><span class="nav-number">2.2.1.</span> <span class="nav-text">抛出和捕获异常</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#异常类型"><span class="nav-number">2.2.2.</span> <span class="nav-text">异常类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#按const和引用捕获异常对象"><span class="nav-number">2.2.3.</span> <span class="nav-text">按const和引用捕获异常对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#抛出并捕获多个异常"><span class="nav-number">2.2.4.</span> <span class="nav-text">抛出并捕获多个异常</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#匹配和const"><span class="nav-number">2.2.4.1.</span> <span class="nav-text">匹配和const</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#匹配所有异常"><span class="nav-number">2.2.4.2.</span> <span class="nav-text">匹配所有异常</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#未捕获的异常"><span class="nav-number">2.2.5.</span> <span class="nav-text">未捕获的异常</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#noexcept"><span class="nav-number">2.2.6.</span> <span class="nav-text">noexcept</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#抛出列表"><span class="nav-number">2.2.7.</span> <span class="nav-text">抛出列表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#异常与多态性"><span class="nav-number">2.3.</span> <span class="nav-text">异常与多态性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#标准异常体系"><span class="nav-number">2.3.1.</span> <span class="nav-text">标准异常体系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在类层次结构中捕获异常"><span class="nav-number">2.3.2.</span> <span class="nav-text">在类层次结构中捕获异常</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#编写自己的异常类"><span class="nav-number">2.3.3.</span> <span class="nav-text">编写自己的异常类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#嵌套异常"><span class="nav-number">2.3.4.</span> <span class="nav-text">嵌套异常</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#重新抛出异常"><span class="nav-number">2.4.</span> <span class="nav-text">重新抛出异常</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#堆栈的释放与清理"><span class="nav-number">2.5.</span> <span class="nav-text">堆栈的释放与清理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用智能指针"><span class="nav-number">2.5.1.</span> <span class="nav-text">使用智能指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#捕获、清理并重新抛出"><span class="nav-number">2.5.2.</span> <span class="nav-text">捕获、清理并重新抛出</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#常见的错误处理问题"><span class="nav-number">2.6.</span> <span class="nav-text">常见的错误处理问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#内存分配错误"><span class="nav-number">2.6.1.</span> <span class="nav-text">内存分配错误</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#不抛出异常的new"><span class="nav-number">2.6.1.1.</span> <span class="nav-text">不抛出异常的new</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#定制内存分配失败的行为"><span class="nav-number">2.6.1.2.</span> <span class="nav-text">定制内存分配失败的行为</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#构造函数中的错误"><span class="nav-number">2.6.2.</span> <span class="nav-text">构造函数中的错误</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#构造函数的function-try-blocks"><span class="nav-number">2.6.3.</span> <span class="nav-text">构造函数的function-try-blocks</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#析构函数中的错误"><span class="nav-number">2.6.4.</span> <span class="nav-text">析构函数中的错误</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>
  <div id="DvelopmentTarget">     
  </div>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart" aria-hidden="false"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>

  
</div>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_uv"> 
  本站访客数<span id="busuanzi_value_site_uv"></span>人次
</span>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  


  <script type="text/javascript" src="/js/src/love.js"></script>

</body>
</html>
