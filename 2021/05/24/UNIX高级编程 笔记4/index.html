<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zn-ch">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-center-simple.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Linux,">










<meta name="description" content="信号引言信号是软件中断。很多比较重要的应用程序都需处理信号，信号提供了一种处理异步事件的方法，例如，终端用户键入中断键，会通过信号机制停止一个程序，或及早终止管道中的下一个程序。 信号概念首先，每个信号都有一个名字。这些名字都以3个字符SIG开头。例如，SIGABRT是夭折信号，当进程调用abort函数时产生这种信号。SIGALRM是闹钟信号，由alarm函数设置的定时器超时后将产生此信号。 在头">
<meta name="keywords" content="Linux">
<meta property="og:type" content="article">
<meta property="og:title" content="UNIX高级编程 笔记4">
<meta property="og:url" content="http://yoursite.com/2021/05/24/UNIX高级编程 笔记4/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="信号引言信号是软件中断。很多比较重要的应用程序都需处理信号，信号提供了一种处理异步事件的方法，例如，终端用户键入中断键，会通过信号机制停止一个程序，或及早终止管道中的下一个程序。 信号概念首先，每个信号都有一个名字。这些名字都以3个字符SIG开头。例如，SIGABRT是夭折信号，当进程调用abort函数时产生这种信号。SIGALRM是闹钟信号，由alarm函数设置的定时器超时后将产生此信号。 在头">
<meta property="og:locale" content="zn-ch">
<meta property="og:image" content="http://yoursite.com/img/1621993686.jpg">
<meta property="og:image" content="http://yoursite.com/img/1622104996.jpg">
<meta property="og:image" content="http://yoursite.com/img/1622122627.jpg">
<meta property="og:image" content="http://yoursite.com/img/1622123793.jpg">
<meta property="og:image" content="http://yoursite.com/img/20210528000140.png">
<meta property="og:updated_time" content="2021-06-01T12:59:30.053Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="UNIX高级编程 笔记4">
<meta name="twitter:description" content="信号引言信号是软件中断。很多比较重要的应用程序都需处理信号，信号提供了一种处理异步事件的方法，例如，终端用户键入中断键，会通过信号机制停止一个程序，或及早终止管道中的下一个程序。 信号概念首先，每个信号都有一个名字。这些名字都以3个字符SIG开头。例如，SIGABRT是夭折信号，当进程调用abort函数时产生这种信号。SIGALRM是闹钟信号，由alarm函数设置的定时器超时后将产生此信号。 在头">
<meta name="twitter:image" content="http://yoursite.com/img/1621993686.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2021/05/24/UNIX高级编程 笔记4/">





  <title>UNIX高级编程 笔记4 | Hao Yu's blog</title>
  








 
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zn-ch">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hao Yu's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">The program monkey was eaten by the siege lion.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/resume.pdf" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-mybetterhalf">
          <a href="/mybetterhalf/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>
            
            mybetterhalf
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/05/24/UNIX高级编程 笔记4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">UNIX高级编程 笔记4</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-05-24T16:20:00+08:00">
                2021-05-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>信号是软件中断。很多比较重要的应用程序都需处理信号，信号提供了一种处理异步事件的方法，例如，终端用户键入中断键，会通过信号机制停止一个程序，或及早终止管道中的下一个程序。</p>
<h2 id="信号概念"><a href="#信号概念" class="headerlink" title="信号概念"></a>信号概念</h2><p>首先，每个信号都有一个名字。这些名字都以3个字符SIG开头。例如，<code>SIGABRT</code>是夭折信号，当进程调用<code>abort</code>函数时产生这种信号。<code>SIGALRM</code>是闹钟信号，由<code>alarm</code>函数设置的定时器超时后将产生此信号。</p>
<p>在头文件<code>&lt;signal.h&gt;</code>中，信号名都被定义为正整数常量(信号编号)。实际上，实现将各信号定义在另一个头文件中，但是该头文件又包括在<code>&lt;signal.h&gt;</code>中。内核包括对用户级应用程序有意义的头文件，这被认为是一种不好的形式，所以如若应用程序和内核两者都需使用同一定义，那么就将有关信息放置在内核头文件中，然后用户级头文件再包括该内核头文件。</p>
<p>不存在编号为0的信号，<code>kill</code>函数对信号编号0有特殊的应用。POSIX.1将此种信号编号值称为空信号。很多条件可以产生信号。</p>
<ul>
<li>当用户按某些终端键时，引发终端产生的信号。在终端上按Delete键通常产生中断信号(SIGINT)。这是停止一个已失去控制程序的方法。</li>
<li>硬件异常产生信号：除数为0、无效的内存引用等。这些条件通常由硬件检测到，并通知内核。然后内核为该条件发生时正在运行的进程产生适当的信号。</li>
<li>进程调用<code>kill(2)</code>函数可将任意信号发送给另一个进程或进程组。自然，对此有所限制：接收信号进程和发送信号进程的所有者必须相同，或发送信号进程的所有者必须是超级用户。</li>
<li>用户可用<code>kill(1)</code>命令将信号发送给其他进程。此命令只是<code>kill</code>函数的接口。常用此命令终止一个失控的后台进程。</li>
<li>当检测到某种软件条件已经发生，并应将其通知有关进程时也产生信号。这里指的不是硬件产生条件(如除以0)，而是软件条件。例如<code>SIGURG</code>(在网络连接上传来带外的数据)、<code>SIGPIPE</code>(在管道的读进程已终止后，一个进程写此管道)以及<code>SIGALRM</code>(进程所设置的定时器已经超时)。</li>
</ul>
<p>信号是异步事件的经典实例。产生信号的事件对进程而言：是随机出现的。进程不能简单地测试一个变量(如errno)来判断是否发生了一个信号，而是必须告诉内核”在此信号发生时，请执行下列操作”。</p>
<p>在某个信号出现时，可以告诉内核按下列3种方式之一进行处理，我们称之为信号的处理或与信号相关的动作。</p>
<ol>
<li>忽略此信号。大多数信号都可使用这种方式进行处理，但有两种信号却决不能被忽略。它们是<code>SIGKILL</code>和<code>SIGSTOP</code>。这两种信号不能被忽略的原因是它们向内核和超级用户提供了使进程终止或停止的可靠方法。另外，如果忽略某些由硬件异常产生的信号(如非法内存引用或除以0)，则进程的运行行为是未定义的。</li>
<li>捕捉信号。为了做到这一点，要通知内核在某种信号发生时，调用一个用户函数。在用户函数中，可执行用户希望对这种事件进行的处理。</li>
<li>执行系统默认动作。注意，对大多数信号的系统默认动作是终止该进程</li>
</ol>
<p>图10-1列出了所有信号的名字，说明了哪些系统支持此信号以及对于这些信号的系统默认动作。在系统默认动作列，”终止+core”表示在进程当前工作目录的core文件中复制了该进程的内存映像(该文件名为core)。大多数UNIX系统调试程序都使用core文件检查进程终止时的状态。<br><img src="/img/1621993686.jpg" alt></p>
<p>在下列条件下不产生core文件：</p>
<ul>
<li>进程是设置用户ID的，而且当前用户并非程序文件的所有者；</li>
<li>进程是设置组ID的，而且当前用户并非该程序文件的组所有者；</li>
<li>用户没有写当前工作目录的权限；</li>
<li>文件已存在，而且用户对该文件设有写权限；</li>
<li>文件太大。</li>
</ul>
<p>core文件的权限(假定该文件在此之前并不存在)通常是用户读/写。</p>
<p>下面逐一说明这些信号。</p>
<ul>
<li><code>SIGABRT</code>：调用<code>abort</code>函数时产生此信号。进程异常终止。</li>
<li><code>SIGALRM</code>：当用<code>alarm</code>函数设置的定时器超时时，产生此信号。</li>
<li><code>SIGBUS</code>：指示一个实现定义的硬件故障。当出现某些类型的内存故障时，实现常常产生此种信号。</li>
<li><code>SIGCANCEL</code>：这是Solaris线程库内部使用的信号。它不适用于一般应用。</li>
<li><code>SIGCHLD</code>：在一个进程终止或停止时，<code>SIGCHLD</code>信号被送给其父进程。按系统默认，将忽略此信号。如果父进程希望被告知其子进程的这种状态改变，则应捕捉此信号。信号捕捉函数中通常要调用一种<code>wait</code>函数以取得子进程ID和其终止状态。</li>
<li><code>SIGCONT</code>：此作业控制信号发送给需要继续运行，但当前处于停止状态的进程。如果接收到此信号的进程处于停止状态，则系统默认动作是使该进程继续运行；否则默认动作是忽略此信号。</li>
<li><code>SIGEMT</code>：指示一个实现定义的硬件故障</li>
<li><code>SIGFPE</code>：此信号表示一个算术运算异常，如除以0、浮点溢出等。</li>
<li><code>SIGFREEZE</code>：此信号仅由Solaris定义。 它用于通知进程在冻结系统状态之前需要采取特定动作，例如当系统进入休眠或挂起状态时可能需要做这种处理。</li>
<li><code>SIGHUP</code>：如果终端接口检测到一个连接断开，则将此信号送给该终端相关的控制进程(会话首进程)。此信号被送给session结构中<code>s_leader</code>字段所指向的进程。仅当终端的CLOCAL标志没有设置时，在上述条件下才产生此信号。(如果所连接的终端是本地的，则设置该终端的CLOCAL标志。它告诉终端驱动程序忽略所有调制解调器的状态行。)</li>
<li><code>SIGILL</code>：此信号表示进程已执行一条非法硬件指令。</li>
<li><code>SIGINFO</code>：这是一种BSD信号，当用户按状态键(一般采用Ctrl+T)时，终端驱动程序产生此信号并发送至前台进程组中的每一个进程。此信号通常造成在终端上显示前台进程组中各进程的状态信息。</li>
<li><code>SIGINT</code>：当用户按中断键(一般采用Delete或Ctrl+C)时，终端驱动程序产生此信号并发送至前台进程组中的每一个进程。当一个进程在运行时失控，特别是它正在屏幕上产生大量不需要的输出时，常用此信号终止它。</li>
<li><code>SIGIO</code>：此信号指示一个异步I/O事件。对<code>SIGIO</code>的系统默认动作是终止或忽略。遭憾的是，这依赖于系统。</li>
<li><code>SIGIOT</code>：这指示一个实现定义的硬件故障。</li>
<li><code>SIGJVM1</code>：Solaris上为Java虚拟机预留的一个信号。</li>
<li><code>SIGJVM2</code>：Solaris上为Java虚拟机预留的另一个信号。</li>
<li><code>SIGKILL</code>：这是两个不能被捕捉或忽略信号中的一个。它向系统管理员提供了一种可以杀死任一进程的可靠方法。</li>
<li><code>SIGLOST</code>：运行在Solaris NFsv4客户系统中的进程，恢复阶段不能重新获得锁，此时将由这个信号通知该进程。</li>
<li><code>SIGLWP</code>：此信号由Solaris线程库内部使用，并不做一般使用。在FreeBSD中，SIGLMP是SIGTHR的别名。</li>
<li><code>SIGPIPE</code>：如果在管道的读进程已终止时写管道，则产生此信号。当类型为<code>SOCK_STREM</code>的套接字已不再连接时，进程写该套接字也产生此信号。</li>
<li><code>SIGPOLL</code>：这个信号在SUSv4中已被标记为弃用，将来的标准可能会将此信号移除。当在一个可轮询设备上发生一个特定事件时产生此信号。</li>
<li><code>SIGPROF</code>：这个信号在SUSw4中已被标记为弃用，将来的标准可能会将此信号移除。当<code>setitimer(2)</code>函数设置的梗概统计间隔定时器(profiling interval timer)已经超时时产生此信号。</li>
<li><code>SIGPWR</code>：这是一种依赖于系统的信号。它主要用于具有不间断电源(UPS)的系统。如果电源失效，则UPS起作用，而且通常软件会接到通知。在这种情况下，系统依靠蓄电池电源继续运行，所以无须做任何处理。但是如果蓄电池也将不能支持工作，则软件通常会再次接到通知，此时，系统必项使其各部分都停止运行。这时应当发送SIGPWR信号。</li>
<li><code>SIGQUIT</code>：当用户在终端上按退出键(一般采用Ctrl+<code>\</code>)时，中断驱动程序产生此信号，并发送给前台进程组中的所有进程。此信号不仅终止前台进程组<br>(如SIGINT所做的那样)，同时产生一个core文件。</li>
<li><code>SIGSEGV</code>：指示进程进行了一次无效的内存引用(通常说明程序有错，比如访问了一个未经初始化的指针)。</li>
<li><code>SIGSTKFLT</code>：此信号仅由Linux定义。它出现在Linux的早期版本，企图用于数学协处理器的栈故障。该信号并非由内核产生，但仍保留以向后兼容。</li>
<li><code>SIGSTOP</code>：这是一个作业控制信号，它停止一个进程。它类似于交互停止信号(<code>SIGTSTP</code>)，但是<code>SIGSTOP</code>不能被捕捉或忽略。</li>
<li><code>SIGSYS</code>：该信号指示一个无效的系统调用。由于某种未知原因，进程执行了一条机器指令，内核认为这是一条系统调用，但该指令指示系统调用类型的参数却是无效的。这种情况是可能发生的，例如，若用户编写了一道使用新系统调用的程序，然后运行该程序的二进制可执行代码，而所用的操作系统却是不支持该系统调用的较早版本，于是就出现上述情况。</li>
<li><code>SIGTERM</code>：这是由<code>kill</code>命令发送的系统默认终止信号。由于该信号是由应用程序捕获的，使用<code>SIGTERM</code>也让程序有机会在退出之前做好清理工作，从而优雅地终止(相对于<code>SIGKILL</code>而言。<code>SIGKILL</code>不能被捕捉或者忽略)。</li>
<li><code>SIGTHAW</code>：此信号仅由Solaris定义。在被挂起的系统恢复时，该信号用于通知相关进程，它们需要采取特定的动作。</li>
<li><code>SIGTHR</code>：FreeBSD线程库预留的信号，它的值定义或与<code>SIGLWP</code>相同。</li>
<li><code>SIGTRAP</code>：指示一个实现定义的硬件故障。</li>
<li><code>SIGTSTP</code>：交互停止信号，当用户在终端上按挂起键(一般采用Ctrl+Z)时，终端驱动程序产生此信号。该信号发送至前台进程组中的所有进程。速憾的是，停止具有不同的含义。当讨论作业控制和信号时，我们谈及停止和继续作业。但是，终端驱动程序一直使用术语“停止”表示用Cul+S字符终止终端输出，为了继续启动该终端输出，则用Ctrl+Q字符。为此，终端驱动程序称产生交互停止信号的字符为挂起字符，而非停止字符。</li>
<li><code>SIGTTIN</code>：当一个后台进程组进程试图读其控制终端时，终端驱动程序产生此信号。在下列例外情形下不产生此信号：<ul>
<li>读进程忽略或阻塞此信号；</li>
<li>读进程所属的进程组是孤儿进程组，此时读操作返回出错，errno设置为EIO。</li>
</ul>
</li>
<li><code>SIGTTOU</code>：当一个后台进程组进程试图写其控制终端时，终端驱动程序产生此信号。与上面所述的<code>SIGTTIN</code>信号不同，一个进程可以选择允许后台进程写控制终端。如果不允许后台进程写，则与<code>SIGTTIN</code>相似，也有两种特殊情况：<ul>
<li>写进程忽略或阻塞此信号；</li>
<li>写进程所属进程组是孤儿进程组。在第2种情况下不产生此信号，写操作返回出错，errno设置为EIO。</li>
</ul>
</li>
<li><code>SIGURG</code>：此信号通知进程已经发生一个紧急情况。在网络连接上接到带外的数据时，可选择地产生此信号。</li>
<li><code>SIGUSRI</code>：这是一个用户定义的信号，可用于应用程序，</li>
<li><code>SIGUSR2</code>：这是另一个用户定义的信号，与<code>SIGUSR1</code>相似，可用于应用程序。</li>
<li><code>SIGVTALRM</code>：当一个由<code>setitime(2)</code>函数设置的虚拟间隔时间已经超时时，产生此信号。</li>
<li><code>SIGWAITING</code>：此信号由Solaris线程库内部使用，不做他用。</li>
<li><code>SIGWINCH</code>：内核维持与每个终端或伪终端相关联窗口的大小。进程可以用<code>ioctl</code>函数得到成设置窗口的大小。如果进程用<code>ioctl</code>的设置窗口大小命令更改了窗口大小，则内核将<code>SIGWINCH</code>信号发送至前台进程组。</li>
<li><code>SIGXCPU</code>：Single UNIX Specification的XSI扩展支持资源限制的概念。如果进程超过了其软CPU时间限制，则产生此信号。</li>
<li><code>SIGXFSZ</code>：如果进程超过了其软文件长度限制，则产生此信号。</li>
<li><code>SIGXRES</code>：此信号仅由Solaris定义。可选择地使用此信号以通知进程超过了预配置的资源值。</li>
</ul>
<h2 id="函数signal"><a href="#函数signal" class="headerlink" title="函数signal"></a>函数signal</h2><p>UNIX系统信号机制最简单的接口是<code>signal</code>函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="keyword">void</span> (*signal (<span class="keyword">int</span> signo, <span class="keyword">void</span> (*func) (<span class="keyword">int</span>)))(<span class="keyword">int</span>);</span><br><span class="line"><span class="comment">// 返回值：若成功，返回以前的信号处理配置。若出错：返回SIG_ERR</span></span><br></pre></td></tr></table></figure></p>
<p><code>signal</code>函数由ISO C定义。因为ISO C不涉及多进程、进程组以及终端I/O等，所以它对信号的定义非常含糊，以致于对UNIX系统而言几乎毫无用处。</p>
<p><code>signo</code>参数是信号名。<code>func</code>的值是常量<code>SIG_IGN</code>、常量<code>SIG_DFL</code>或当接到此信号后要调用的函数的地址。如果指定<code>SIG_IGN</code>，则向内核表示忽略此信号(记住有两个信号<code>SIGKILL</code>和<code>SIGSTOP</code>不能忽略)。如果指定<code>SIG_DFL</code>，则表示接到此信号后的动作是系统默认动作。当指定函数地址时，则在信号发生时，调用该函数，我们称这种处理为捕捉该信号，称此函数为<strong>信号处理程序</strong>(signal handler) 或<strong>信号捕捉函数</strong>(signal-catching function)。</p>
<p><code>signal</code>函数原型说明此函数要求两个参数，返回-一个函数指针，而该指针所指向的函数无返回值(void)。第一个参数<code>signo</code>是一个整型数，第二个参数是函数指针，它所指向的函数需要一个整型参数，无返回值。<code>signal</code>的返回值是一个函数地址，该函数有一个整型参数(即最后的(int))。用自然语言来描述也就是要向信号处理程序传送一个整型参数，而它却无返回值。</p>
<p>当调用<code>signal</code>设置信号处理程序时，第二个参数是指向该函数(也就是信号处理程序)的指针。<code>signal</code>的返回值则是指向在此之前的信号处理程序的指针。很多系统用附加的依赖于实现的参数来调用信号处理程序。本节开头所示的signal函数原型太复杂了，如果使用下面的typedef，则可使其简单一些。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">typedet <span class="keyword">void</span> <span class="title">Sigfunc</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>然后，可将signal函数原型写成：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Sigfunc *<span class="title">signal</span> <span class="params">(<span class="keyword">int</span>, Sigfunc *)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>我们已将此<code>typedef</code>包括在<code>apue.h</code>文件中，并随本章中的函数一起使用。如果查看系统的头文件<code>&lt;signal.h&gt;</code>，则很可能会找到下列形式的声明：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIG_ERR (void (*)())-1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIG_DFL (void (*)())0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIG_IGN (void (*)())1</span></span><br></pre></td></tr></table></figure></p>
<p>这些常量可用于表示“指向函数的指针，该函数要求一个整型参数，而且无返回值”。<code>signal</code>的第二个参数及其返回值就可用它们表示。这些常量所使用的3个值不一定是-1、0和1，但它们必须是3个值而决不能是任一函数的地址。大多数UNIX系统使用上面所示的值。</p>
<p>给出了一个简单的信号处理程序，它捕捉两个用户定义的信号并打印信号编号。它使调用进程在接到一信号前挂起。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sig_usr</span><span class="params">(<span class="keyword">int</span>)</span> <span class="comment">/* one handler for both signals */</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (signal (SIGUSR1, sig_usr) == SIG_ERR)</span><br><span class="line">		err_sys(<span class="string">"can't catch SIGUSR1"</span>);</span><br><span class="line">	<span class="keyword">if</span> (signal (SIGUSR2, sig_usr) == SIG_ERR)</span><br><span class="line">		err_sys(<span class="string">"can't catch STGUSR2"</span>);</span><br><span class="line">	<span class="keyword">for</span> (; ;)</span><br><span class="line">		pause();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sig_usr</span><span class="params">(<span class="keyword">int</span> signo)</span> <span class="comment">/* arqunent is signal number */</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (signo == SIGUSR1)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"received SIGUSR1\n"</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (signo == SIGUSR2)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"received SIGUSR2\n"</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		err_dump(<span class="string">"received signal %d\n"</span>, signo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们使该程序在后台运行，并且用<code>kill(1)</code>命令将信号发送给它。注意，在UNIX系统中，杀死(<code>kill</code>)这个术语是不恰当的。<code>kill(1)</code>命令和<code>kill(2)</code>函数只是将一个信号发送给一个进程或进程组。该信号是否终止进程则取决于该信号的类型，以及进程是否安排了捕捉该信号。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$./a.out &amp;   在后台启动进程</span><br><span class="line">[1] 7216     作业控制thell打印作业编号和进程ID</span><br><span class="line">$ <span class="built_in">kill</span> -USR1 7226  向该进程发送SIGUSR1</span><br><span class="line">received SIGUSR1</span><br><span class="line">$ <span class="built_in">kill</span> -USR2 7216  向该进程发送SIGUSR2</span><br><span class="line">received SIGUSR2</span><br><span class="line">$ <span class="built_in">kill</span> 7216        向该进程发送SIGTERM</span><br><span class="line">[1]+ Terminated ./a.out</span><br></pre></td></tr></table></figure></p>
<p>因为执行程序的进程不捕捉SIGTERM信号，而对该信号的系统默认动作是终止，所以当向该进程发送SIGTERM信号后，该进程就终止.</p>
<h3 id="程序启动"><a href="#程序启动" class="headerlink" title="程序启动"></a>程序启动</h3><p>当执行一个程序时，所有信号的状态都是系统默认或忽略，通常所有信号都被设置为它们的默认动作，除非调用exec的进程忽略该信号。确切地讲， exec函数将原先设置为要捕捉的信号都更改为默认动作，其他信号的状态则不变(一个进程原先要捕捉的信号，当其执行一个新程序后，就不能再捕捉了，因为信号捕捉函数的地址很可能在所执行的新程序文件中已无意义)。</p>
<p>一个具体例子是一个交互，shell如何处理针对后台进程的中断和退出信号。对于一个非作业控制shell，当在后台执行一个进程时，例如：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cc main.cc &amp;</span><br></pre></td></tr></table></figure></p>
<p>shell自动将后台进程对中断和退出信号的处理方式设置为忽略。于是， 当按下中断字符时就不会影响到后台进程。如果没有做这样的处理，那么当按下中断字符时，它不但终止前台进程，也终止所有后台进程。</p>
<p>很多捕捉这两个信号的交互程序具有下列形式的代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void sig_int(int), sig_quit (int);</span><br><span class="line">it (signal (SIGINT, SIG_IGN) != SIGIGN)</span><br><span class="line">	signal (SIGINT, sig_int);</span><br><span class="line"><span class="keyword">if</span> (signal (SIGQUIT, SIG_IGN) != SIG_IGN)</span><br><span class="line">	signal (SIGQUIT, sig_quit);</span><br></pre></td></tr></table></figure></p>
<p>这样处理后，仅当<code>SIGINT</code>和<code>SIGQUIT</code>当前未被忽略时，进程才会捕捉它们。从<code>signal</code>的这两个调用中也可以看到这种函数的限制，不改变信号的处理方式就不能确定信号的当前处理方式。</p>
<h3 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h3><p>当一个进程调用fork时，其子进程继承父进程的信号处理方式。因为子进程在开始时复制了父进程内存映像，所以信号捕捉函数的地址在子进程中是有意义的。</p>
<h2 id="不可靠的信号"><a href="#不可靠的信号" class="headerlink" title="不可靠的信号"></a>不可靠的信号</h2><p>在早期的UNIX版本中(如V7)，信号是不可靠的。不可靠在这里指的是，信号可能会丢失：一个信号发生了，但进程却可能一直不知道这一 点。同时，进程对信号的控制能力也很差，它能捕捉信号或忽略它。有时用户希望通知内核阻塞某个信号：不要忽略该信号，在其发生时记住它，然后在进程做好了准备时再通知它。这种阻塞信号的能力当时并不具备。</p>
<p>早期版本在进程每次接到信号对其进行处理时，随即将该信号动作重置为默认值：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">sig_int</span><span class="params">()</span></span>;   <span class="comment">/*my signal handling function */</span></span><br><span class="line">...</span><br><span class="line">signal(SIGINT, sig_int) <span class="comment">/* establish handler */</span></span><br><span class="line">...</span><br><span class="line">sig_int() &#123;</span><br><span class="line">	signal (SIGINT, sig_int): <span class="comment">/* reestabliah handler for next time */</span></span><br><span class="line">							<span class="comment">/*process the signal */</span></span><br></pre></td></tr></table></figure></p>
<p>这段代码的一个问题是：在信号发生之后到信号处理程序调用<code>signal</code>函数之间有一个时间窗口。在此段时间中，可能发生另一次中断信号。第二个信号会造成执行默认动作，而对中断信号的默认动作是终止该进程。这种类型的程序段在大多数情况下会正常工作，使得我们认为它们是正确无误的，而实际上却并非如此。</p>
<p>这些早期版本的另一个问题是：在进程不希望某种信号发生时，它不能关闭该信号。进程能做的一切就是忽略该信号。有时希望通知系统“阻止下列信号发生，如果它们确实产生了，请记住它们。”能够显现这种缺陷的的一个经典实例是下列程序段，它捕捉一个信号，然后设置一个表示该信号已发生的标志：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int sig_int():</span><br><span class="line"><span class="comment">/* my signal handling function */</span></span><br><span class="line"><span class="keyword">int</span> sig_int_flags</span><br><span class="line"><span class="comment">/* set nonzero when signal oecurs */</span></span><br><span class="line">main() &#123;</span><br><span class="line">	signal (SIGINT, sig_int);</span><br><span class="line">	<span class="comment">/* establish handler */</span></span><br><span class="line">	<span class="keyword">while</span> (sig_int_flag == <span class="number">0</span>)</span><br><span class="line">		<span class="comment">/* go to sleep, waiting for signal */</span></span><br><span class="line">		pause();</span><br><span class="line">&#125;</span><br><span class="line">sig_int() &#123;</span><br><span class="line">	signal (SIGINT, sig_int);</span><br><span class="line">	<span class="comment">/* reestablish handler for next time */</span></span><br><span class="line">	sig_int_tiag = <span class="number">1</span>;</span><br><span class="line">	<span class="comment">/* set flag for main loop to examine */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中，进程调用<code>pause</code>函数使自己休眠，直到捕捉到一个信号。当捕提到信号时，信号处理程序将标志<code>sig_int_flag</code>设置为非0值。从信号处理程序返回后，内核自动将该进程唤醒，它检测到该标志为非0，然后执行它所需做的。但是这里有一个时间窗口，在此窗口中操作可能失误。如果在测试<code>sig_int_flag</code>之后、调用<code>pause</code>之前发生信号，则此进程在调用<code>pause</code>时可能将永久休眠(假定此信号不会再次产生)。于是，这次发生的信号也就丢失了。</p>
<h2 id="中断的系统调用"><a href="#中断的系统调用" class="headerlink" title="中断的系统调用"></a>中断的系统调用</h2><p>早期UNIX系统的一个特性是：如果进程在执行一个低速系统调用而阻塞期间捕捉到一个信号，则该系统调用就被中断不再继续执行。该系统调用返回出错，其errno设置为<code>EINTR</code>。这样处理是因为一个信号发生了，进程捕捉到它，这意味着已经发生了某种事情，所以是个好机会应当唤醒阻塞的系统调用。</p>
<p>为了支持这种特性，将系统调用分成两类：<strong>低速系统调用</strong>和<strong>其他系统调用</strong>。低速系统调用是可能会使进程永远阻塞的类系统调用，包括：</p>
<ul>
<li>如果某些类型文件(如读管道、终端设备和网络设备)的数据不存在，则读操作可能会使调用者永远阻塞；</li>
<li>如果这些数据不能被相同的类型文件立即接受，则写操作可能会使调用者永远阻塞；</li>
<li>在某种条件发生之前打开某些类型文件，可能会发生阻塞(例如要打开一个终端设备，需要先等待与之连接的调制解调器应答)；</li>
<li><code>pause</code>函数(按照定义，它使调用进程体眼直至捕捉到一个信号)和wait函数；</li>
<li>某些<code>ioctl</code>操作；</li>
<li>某些进程间通信函数。</li>
</ul>
<p>在这些低速系统调用中，一个值得注意的例外是与磁盘I/O有关的系统调用。虽然读、写一个磁盘文件可能暂时阻塞调用者(在磁盘驱动程序将请求排入队列，然后在适当时间执行请求期间)，但是除非发生硬件错误，I/O操作总会很快返回，并使调用者不再处于阻塞状态。</p>
<p>对于中断的<code>read</code>、<code>write</code>系统调用早期版本允许实现自行选择。如若read系统调用已接收并传送数据至应用程序缓冲区，但尚来接收到应用程序请求的全部数据，此时被中断，操作系统可以认为该系统调用失败，并将errno设置为EINTR；另一种处理方式是允许该系统调用成功返回，送回值是已接收到的数据量。与此类似，如若<code>write</code>已传输了应用程序缓冲区中的部分数据，然后被中断，操作系统可以认为该系统调用失败，并将errno设置为EINTR。另一种处理方式是允许该系统调用成功返回，返回值是已写部分的数据量。历史上，从System V派生的实现将这种系统调用视为失败，而BSD派生的实现则处理为部分成功返回。</p>
<p>与被中断的系统调用相关的问题是必须显式地处理出错返回。典型的代码序列(假定进行一个读操作，它被中断，我们希望重新启动它)如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">again:</span><br><span class="line">	<span class="keyword">if</span> ((n = read(fd, buf, BUFFSIZE)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">			<span class="keyword">goto</span> again;  <span class="comment">/* just an interrupted aystem call */</span></span><br><span class="line">		<span class="comment">/* handle other errors */</span></span><br></pre></td></tr></table></figure></p>
<p>4.2BSD引进了某些被中断系统调用的自动重启动。自动重启动的系统调用包括，<code>ioctl</code>、<code>read</code>、<code>readv</code>、<code>write</code>、<code>writev</code>、<code>wait</code>、<code>waitpid</code>。如前所述，其中前5个函数只有对低速设备进行操作时才会被信号中断。而<code>wait</code>和<code>waitpid</code>在捕捉到信号时总是被中断。4.3BSD允许进程基于每个信号禁用此功能。POSIX.1要求只有中断信号的<code>SA_RESTART</code>标志有效时，实现才重启动系统调用。</p>
<p>4.2BSD引入自动重启动功能的一个理由是：有时用户并不知道所使用的输入、输出设备是否是低速设备。如果我们编写的程序可以用交互方式运行，则它可能读、写终端低速设备。如果在程序中捕捉信号，而且系统并不提供重启动功能，则对每次读、写系统调用就要进行是否出错返回的测试，如果是被中断的，则再调用读、写系统调用。</p>
<h2 id="可重入函数"><a href="#可重入函数" class="headerlink" title="可重入函数"></a>可重入函数</h2><p>进程捕捉到信号并对其进行处理时，进程正在执行的正常指令序列就被信号处理程序临时中断，它首先执行该信号处理程序中的指令。如果从信号处理程序返回，则继续执行在捕捉到信号时进程正在执行的正常指令序列。但在信号处理程序中，不能判断捕捉到信号时进程执行到何处。Single UNIX Specification说明了在信号处理程序中保证调用安全的函数。这些函数是可重入的并被称为是<strong>异步信号安全</strong>的(async-signal safe)。除了可重入以外，在信号处理操作期间，它会阻塞任何会引起不一致的信号发送。图10-4列出了这些异步信号安全的函数。<br><img src="/img/1622104996.jpg" alt></p>
<p>其他的大多数函数是不可重入的，因为：</p>
<ul>
<li>已知它们使用静态数据结构；</li>
<li>它们调用malloc或free；</li>
<li>它们是标准I/O函数。</li>
</ul>
<h2 id="SIGCLD语义"><a href="#SIGCLD语义" class="headerlink" title="SIGCLD语义"></a>SIGCLD语义</h2><p><code>SIGCLD</code>和<code>SIGCHLD</code>这两个信号很容易被混淆。<code>SIGCLD</code>是System V的一个信号名，其语义与名为<code>SIGCHLD</code>的BSD信号不同。POSIX.1采用BSD的<code>SIGCHLD</code>信号。BSD的<code>SIGCHLD</code>信号语义与其他信号的语文相类似，子进程状态改变后产生此信号，父进程需要调用一个<code>wait</code>函数以检测发生了什么。</p>
<p>对于<code>SIGCLD</code>的早期处理方式是：</p>
<ol>
<li>如果进程明确地将该信号的配置设置为<code>SIG_IGN</code>，则调用进程的子进程将不产生僵死进程。注意，这与其默认动作(<code>SIG_DFL</code>)“忽略”不同。子进程在终止时，将其状态丢弃。如果调用进程随后调用一个<code>wait</code>函数，那么它将阻塞直到所有子进程都终止，然后该<code>wait</code>会返回-1，并将其errno设置为<code>ECHILD</code>。</li>
<li>如果将<code>SIGCLD</code>的配置设置为捕捉，则内核立即检查是否有子进程准备好被等待，如果是这样，则调用<code>SIGCLD</code>处理程序，第2种方式改变了为此信号编写处理程序的方法，这一点可在下面的实例中看到。</li>
</ol>
<p>进入信号处理程序后，首先要调用<code>signal</code>函数以重新设置此信号处理程序(在信号被重置为其默认值时，它可能会丢失，立即重新设置可以减少此窗口时间)。下边展示了这一点。程序一行行地不断重复输出“SIGCLD received”，最后进程用完其栈空间并异常终止。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>	<span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>	<span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>	<span class="title">sig_cld</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">pid_t</span>	pid;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (signal(SIGCLD, sig_cld) == SIG_ERR)</span><br><span class="line">		perror(<span class="string">"signal error"</span>);</span><br><span class="line">	<span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		perror(<span class="string">"fork error"</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;		<span class="comment">/* child */</span></span><br><span class="line">		sleep(<span class="number">2</span>);</span><br><span class="line">		_exit(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pause();	<span class="comment">/* parent */</span></span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">sig_cld(<span class="keyword">int</span> signo)	<span class="comment">/* interrupts pause() */</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">pid_t</span>	pid;</span><br><span class="line">	<span class="keyword">int</span>		status;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"SIGCLD received\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (signal(SIGCLD, sig_cld) == SIG_ERR)	<span class="comment">/* reestablish handler */</span></span><br><span class="line">		perror(<span class="string">"signal error"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((pid = wait(&amp;status)) &lt; <span class="number">0</span>)		<span class="comment">/* fetch child status */</span></span><br><span class="line">		perror(<span class="string">"wait error"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"pid = %d\n"</span>, pid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此程序的问题是，在信号处理程序的开始处调用<code>signal</code>，按照上述第2种方式，内核检查是否有需要等待的子进程(因为我们正在处理一个<code>SIGCLD</code>信号，所以确实有这种子进程)，所以它产生另一个对信号处理程序的调用。信号处理程序调用<code>signal</code>，整个过程再次重复。</p>
<p>为了解决这一问题，应当在调用<code>wait</code>取到子进程的终止状态后再调用<code>signal</code>。此时仅当其他子进程终止，内核才会再次产生此种信号。</p>
<h2 id="可靠信号术语和语义"><a href="#可靠信号术语和语义" class="headerlink" title="可靠信号术语和语义"></a>可靠信号术语和语义</h2><p>当一个信号产生时，内核通常在进程表中以某种形式设置一个标志。当对信号采取了这种动作时，我们说向进程递送了一个信号。在信号产生(generation)和递送(delivery)之间的时间间隔内，称信号是未决的(pending)。</p>
<p>进程可以选用“阻塞信号递送”。如果为进程产生了一个阻塞的信号，而且对该信号的动作是系统默认动作或捕捉该信号，则为该进程将此信号保持为未决状态，直到该进程对此信号解除了阻塞，或者将对此信号的动作更改为忽略。内核在递送一个原来被阻塞的信号给进程时(而不是在产生该信号时)，才决定对它的处理方式。于是进程在信号递送给它之前仍可改变对该信号的动作。进程调用<code>sigpending</code>函数来判定哪些信号是设置为阻塞并处于未决状态的。</p>
<p>POSIX.1允许系统递送该信号一次或多次。如果递送该信号多次，则称这些信号进行了排队。但是除非支持POSIX.1实时扩展，否则大多数UNIX并不对信号排队，而是只递送这种信号一次。</p>
<p>如果有多个信号要递送给一个进程，POSIX.1并没有规定这些信号的递送顺序。但是POSIX.1基础部分建议：在其他信号之前递送与进程当前状态有关的信号，如SIGSEGV。每个进程都有一个<strong>信号屏蔽字</strong>(signal mask)，它规定了当前要阻塞递送到该进程的信号集。对于每种可能的信号，该屏蔽字中都有一位与之对应。对于某种信号，若其对应位已设置，则它当前是被阻塞的。进程可以调用<code>sigprocmask</code>来检测和更改其当前信号屏蔽字。信号编号可能会超过一个整型所包含的二进制位数，因此POSIX.1定义了一个新数据类型<code>sigset_t</code>，它可以容纳一个信号集。例如，信号屏蔽字就存放在其中一个信号集中。</p>
<h2 id="函数kill和raise"><a href="#函数kill和raise" class="headerlink" title="函数kill和raise"></a>函数kill和raise</h2><p><code>kill</code>函数将信号发送给进程或进程组。<code>raise</code>函数则允许进程向自身发送信号。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kill</span> <span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> sigmo)</span> i</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">raise</span><span class="params">(<span class="keyword">int</span> signo)</span></span>;</span><br><span class="line"><span class="comment">// 两个函数返回值：若成功。返回0；若出错：返回-!</span></span><br></pre></td></tr></table></figure></p>
<p>调用<code>raise(signo)</code>等价于调用<code>kill(getpid(), signo);</code>。</p>
<p><code>kill</code>的<code>pid</code>参数有以下4种不同的情况</p>
<ul>
<li><code>pid&gt;0</code>：将该信号发送给进程ID为<code>pid</code>的进程。</li>
<li><code>pid==0</code>：将该信号发送给与发送进程属于同一进程组的所有进程(这些进程的进程组ID等于发送进程的进程组ID)，而且发送进程具有权限向这些进程发送信号。这里用的术语“所有进程”不包括实现定义的系统进程集。对于大多数UNIX系统，系统进程集包括内核进程和init(pid为1)。</li>
<li><code>pid&lt;0</code>：将该信号发送给其进程组ID等于pid绝对值，而且发送进程具有权限向其发送信号的所有进程。如前所述，所有进程并不包括系统进程集中的进程。</li>
<li><code>pid==-1</code>：将该信号发送给发送进程有权限向它们发送信号的所有进程。如前所述，所有进程不包括系统进程集中的进程。</li>
</ul>
<p>如前所述，进程将信号发送给其他进程需要权限。超级用户可将信号发送给任一进程。对于非超级用户，其基本规则是发送者的实际用户ID或有效用户ID必须等于接收者的实际用户ID 或有效用户ID。如果实现支持<code>_POSIX_SAVED_IDS</code>，则检查接收者的保存设置用户ID(而不是有效用户ID)。在对权限进行测试时也有一个特例：如果被发送的信号是<code>SIGCONT</code>，则进程可将它发送给属于同一会话的任一其他进程。POSIX.1将信号编号0定义为空信号。如果<code>signo</code>参数是0，则<code>kill</code>仍执行正常的错误检查，但不发送信号。这常被用来确定一个特定进程是否仍然存在。如果向一个并不存在的进程发送空信号，则<code>kill</code>返回-1，<code>errno</code>被设置为<code>ESRCH</code>。</p>
<p>还应理解的是，测试进程是否存在的操作不是原子操作。在<code>kill</code>向调用者返回测试结果时，原来已存在的被测试进程此时可能已经终止，所以这种测试并无多大价值。如果调用<code>kill</code>为调用进程产生信号，而且此信号是不被阻塞的，那么在<code>kill</code>返回之前，<code>signo</code>或者某个其他未决的、非阻塞信号被传送至该进程。</p>
<h2 id="函数alarm和pause"><a href="#函数alarm和pause" class="headerlink" title="函数alarm和pause"></a>函数alarm和pause</h2><p>使用<code>alarm</code>函数可以设置一个定时器(闹钟时间)，在将来的某个时刻该定时器会超时。当定时器超时时，产生<code>SIGALRM</code>信号。如果忽略或不捕捉此信号，则其默认动作是终止调用该<code>alarm</code>函数的进程。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">alarm</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> seconds)</span></span>;</span><br><span class="line"><span class="comment">// 返回值：0或以前设置的网钟时间的余留秒数</span></span><br></pre></td></tr></table></figure></p>
<p>参数<code>seconds</code>的值是产生信号<code>SIGALRM</code>需要经过的时钟秒数。当这一时刻到达时，信号由内核产生，由于进程调度的延迟，所以进程得到控制从而能够处理该信号还需要一个时间间隔。</p>
<p>每个进程只能有一个闹钟时间。如果在调用<code>alarm</code>时，之前已为该进程注册的闹钟时间还没有超时，则该闹钟时间的余留值作为本次<code>alarm</code>函数调用的值返回。以前注册的闹钟时间则被新值代替。如果有以前注册的尚未超过的周钟时间，而且本次调用的<code>seconds</code>值是0。则取消以前的闹钟时间，其余留值仍作为<code>alarm</code>函数的返回值。</p>
<p>虽然<code>SIGALRM</code>的默认动作是终止进程，但是大多数使用限钟的进程捕捉此信号。如果此时进程要终止，则在终止之前它可以执行所需的清理操作。如果我们想捕捉SIGALRM信号，则必须在调用<code>alarm</code>之前安装该信号的处理程序。如果我们先调用<code>alarm</code>，然后在我们能够安装<code>SIGALRM</code>处理程序之前已接到该信号，那么进程将终止。</p>
<p><code>pause</code>函数使调用进程挂起直至捕捉到一个信号。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> cunistd.h&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pause</span> <span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="comment">// 返回值：-1，errno设置为EINTR</span></span><br></pre></td></tr></table></figure></p>
<p>只有执行了一个信号处理程序并从其返回时，<code>pause</code>才返回。在这种情况下，<code>pause</code>返回-1，<code>errno</code>设置为<code>EINTR</code>。</p>
<p>使用<code>alarm</code>和<code>pause</code>，进程可使自己休眠一段指定的时间。<code>sleep1</code>函数看似提供了这种功能。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>	<span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>	<span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">sig_alrm(<span class="keyword">int</span> signo)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* nothing to do, just return to wake up the pause */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span></span><br><span class="line">sleep1(<span class="keyword">unsigned</span> <span class="keyword">int</span> seconds)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (signal(SIGALRM, sig_alrm) == SIG_ERR)</span><br><span class="line">		<span class="keyword">return</span>(seconds);</span><br><span class="line">	alarm(seconds);		<span class="comment">/* start the timer */</span></span><br><span class="line">	pause();			<span class="comment">/* next caught signal wakes us up */</span></span><br><span class="line">	<span class="keyword">return</span>(alarm(<span class="number">0</span>));	<span class="comment">/* turn off timer, return unslept time */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种简单实现有以下3个问题，</p>
<ol>
<li>如果在调用<code>sleep1</code>之前，调用者已设置了闹钟，则它被<code>sleep1</code>函数中的第一次<code>alarm</code>调用擦除。可用下列方法更正这一点检查第一次调用<code>alarm</code>的返回值，如其值小于本次调用<code>alarm</code>的参数值，则只应等到已有的阔钟超时。如果之前设置的闹钟超时时间晚于本次设置值，则在<code>sleep1</code>函数返回之前，重置此闹钟，使其在之前闹钟的设定时间再次发生超时。</li>
<li>该程序中修改了对<code>SIGALRM</code>的配置。如果编写了一个函数供其他函数调用，则在该函数被调用时先要保存原配置，在该函数返回前再恢复原配置。更正这一点的方法是：保存<code>signal</code>函数的返回值，在返回前重置原配置。</li>
<li>在第一次调用<code>alarm</code>和<code>pause</code>之间有一个竞争条件。在一个繁忙的系统中，可能<code>alarm</code>在调用<code>pause</code>之前超时，并调用了信号处理程序。如果发生了这种情况，则在调用<code>pause</code>后，如果没有捕捉到其他信号，调用者将永远被挂起。</li>
</ol>
<p>有两种方法可以更正第3个问题。第一种方法是使用<code>setjmp</code>，另一种方法是使用<code>sigprocmask</code>和<code>sigsuspend</code>。</p>
<p>SVR2中的<code>sleep</code>实现使用了<code>setjmp</code>和<code>longjmp</code>，以避免前一个实例的第3个问题中说明的竞争条件。此函数的一个简化版本称为<code>sleep2</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>	<span class="meta-string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>	<span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>	<span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> jmp_buf	env_alrm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">sig_alrm(<span class="keyword">int</span> signo)</span><br><span class="line">&#123;</span><br><span class="line">	longjmp(env_alrm, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span></span><br><span class="line">sleep2(<span class="keyword">unsigned</span> <span class="keyword">int</span> seconds)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (signal(SIGALRM, sig_alrm) == SIG_ERR)</span><br><span class="line">		<span class="keyword">return</span>(seconds);</span><br><span class="line">	<span class="keyword">if</span> (setjmp(env_alrm) == <span class="number">0</span>) &#123;</span><br><span class="line">		alarm(seconds);		<span class="comment">/* start the timer */</span></span><br><span class="line">		pause();			<span class="comment">/* next caught signal wakes us up */</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>(alarm(<span class="number">0</span>));		<span class="comment">/* turn off timer, return unslept time */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>sleep2</code>函数中却有另一个难以察觉的问题，它涉及与其他信号的交互。如果<code>SIGALRM</code>中断了某个其他信号处理程序，则调用<code>longjmp</code>会提早终止该信号处理程序。</p>
<p>除了用来实现<code>sleep</code>函数外，<code>alarm</code>还常用于对可能阻塞的操作设置时间上限值。例如，程序中有一个读低速设备的可能阻塞的操作，我们希望超过一定时间量后就停止执行该操作。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>	<span class="title">sig_alrm</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span>		n;</span><br><span class="line">	<span class="keyword">char</span>	line[MAXLINE];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (signal(SIGALRM, sig_alrm) == SIG_ERR)</span><br><span class="line">		err_sys(<span class="string">"signal(SIGALRM) error"</span>);</span><br><span class="line"></span><br><span class="line">	alarm(<span class="number">10</span>);</span><br><span class="line">	<span class="keyword">if</span> ((n = read(STDIN_FILENO, line, MAXLINE)) &lt; <span class="number">0</span>)</span><br><span class="line">		err_sys(<span class="string">"read error"</span>);</span><br><span class="line">	alarm(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	write(STDOUT_FILENO, line, n);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">sig_alrm(<span class="keyword">int</span> signo)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* nothing to do, just return to interrupt the read */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种代码序列在很多UNIX应用程序中都能见到，但是这种程序有两个问题：</p>
<ul>
<li>在第一次<code>alarm</code>调用和<code>read</code>调用之间有一个竞争条件。如果内核在这两个函数调用之间使进程阻塞，不能占用处理机运行，而其时间长度又超过闹钟时间，则<code>read</code>可能永远阻塞。大多数这种类型的操作使用较长的闹钟时间，例如1分钟或更长一点，使这种问题不会发生，但无论如何这是一个竞争条件。</li>
<li>如果系统调用是自动重启动的，则当从<code>SIGALRM</code>信号处理程序返回时，<code>read</code>并不被中断。在这种情形下，设置时间限制不起作用。</li>
</ul>
<h2 id="信号集"><a href="#信号集" class="headerlink" title="信号集"></a>信号集</h2><p>我们需要有一个能表示多个信号信号集(signalser)的数据类型。我们将在<code>sigprocmask</code>类函数中使用这种数据类型，以便告诉内核不允许发生该信号集中的信号。如前所述，不同的信号的编号可能超过一个整型量所包含的位数，所以一般而言，不能用整型量中的一位代表一种信号，也就是不能用一个整型量表示信号集。POSIX.1定义数据类型<code>sigset_t</code>以包含一个信号集，并且定义了下列5个处理信号集的函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigemptyset</span> <span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigfillset</span> <span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaddset</span> <span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signo)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigdelset</span> <span class="params">(<span class="keyword">sigset_t</span> *ser, <span class="keyword">int</span> signo)</span></span>;</span><br><span class="line"><span class="comment">// 4个函数返回值：若成功，返回0；若出错，返回-1</span></span><br><span class="line"><span class="keyword">int</span> sigismember lconst <span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> sigmo);</span><br><span class="line"><span class="comment">// 返回值：若真。返回1；若假，返回0</span></span><br></pre></td></tr></table></figure></p>
<p>函数<code>sigemptyset</code>初始化由<code>set</code>指向的信号集，清除其中所有信号。函数<code>sigfillset</code>初始化由<code>set</code>指向的信号集，使其包括所有信号。所有应用程序在使用信号集前，要对该信号集调用<code>sigemptyset</code>或<code>sigfillset</code>一次。这是因为C编译程序将不赋初值的外部变量和静态变量都初始化为0，而这是否与给定系统上信号集的实现相对应却并不清楚。一旦已经初始化了一个信号集，以后就可在该信号集中增、删特定的信号。函数<code>sigaddset</code>将一个信号添加到已有的信号集中，<code>sigdelset</code>则从信号集中删除一个信号。对所有以信号集作为参数的函数，总是以信号集地址作为向其传送的参数。</p>
<p>如果实现的信号数目少于一个整型最所包含的位数，则可用一位代表一个信号的方法实现信号集。<code>sigemptyset</code>函数将整型设置为0。<code>sigfillset</code>函数则将整型中的各位都设置为1。这两个函数可以在<code>&lt;signal.h&gt;</code>头文件中实现为宏：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sigemptyset(ptr) (*(ptz) = 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sigfillset(ptr)(*(ptr) = (sigset_t)0, 0)</span></span><br></pre></td></tr></table></figure></p>
<p>注意，除了设置信号集中各位为1外，<code>sigfillset</code>必须返回0，所以使用C语言的逗号算符，它将逗号算符后的值作为表达式的值返回。</p>
<p>使用这种实现，<code>sigaddset</code>开启一位(将该位设置为1)，<code>sigdelset</code>则关闭一位(将该位设置为0)，<code>sigismember</code>测试一个指定的位。因为没有信号编号为0，所以从信号编号中减1以得到要处理位的位编号数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>	<span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>	<span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * &lt;signal.h&gt; usually defines NSIG to include signal number 0.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	SIGBAD(signo)	((signo) <span class="meta-string">&lt;= 0 || (signo) &gt;= NSIG)</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">sigaddset(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signo)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (SIGBAD(signo)) &#123;</span><br><span class="line">		errno = EINVAL;</span><br><span class="line">		<span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	*<span class="built_in">set</span> |= <span class="number">1</span> &lt;&lt; (signo - <span class="number">1</span>);		<span class="comment">/* turn bit on */</span></span><br><span class="line">	<span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">sigdelset(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signo)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (SIGBAD(signo)) &#123;</span><br><span class="line">		errno = EINVAL;</span><br><span class="line">		<span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	*<span class="built_in">set</span> &amp;= ~(<span class="number">1</span> &lt;&lt; (signo - <span class="number">1</span>));	<span class="comment">/* turn bit off */</span></span><br><span class="line">	<span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">sigismember(<span class="keyword">const</span> <span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signo)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (SIGBAD(signo)) &#123;</span><br><span class="line">		errno = EINVAL;</span><br><span class="line">		<span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>((*<span class="built_in">set</span> &amp; (<span class="number">1</span> &lt;&lt; (signo - <span class="number">1</span>))) != <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>也可将这3个函数在<code>&lt;signal.h&gt;</code>中实现为各一行的宏，但是POSIX.1要求检查信号编号参数的有效性，如果无效则设置errno。在宏中实现这一点比函数要难。</p>
<h2 id="函数sigprocmask"><a href="#函数sigprocmask" class="headerlink" title="函数sigprocmask"></a>函数sigprocmask</h2><p>调用函数<code>sigprocmask</code>可以检测或更改，或同时进行检测和更改进程的信号屏蔽字。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigprocmask</span><span class="params">(<span class="keyword">int</span> how, <span class="keyword">const</span> <span class="keyword">sigset_t</span> *<span class="keyword">restrict</span> <span class="built_in">set</span>, <span class="keyword">sigset_t</span> *<span class="keyword">restrict</span> oset)</span></span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回0：若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>首先，若<code>oset</code>是非空指针，那么进程的当前信号屏蔽字通过<code>oset</code>返回。其次，若<code>set</code>是一个非空指针，则参数<code>how</code>指示如何修改当前信号屏蔽字。下表说明了<code>how</code>可选的值。<code>SIG_BLOCK</code>是或操作，而<code>SIG_SETMASK</code>则是赋值操作。注意，不能阻塞<code>SIGKILL</code>和<code>SIGSTOP</code>信号。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><code>how</code></th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>SIG_BLOCK</code></td>
<td>该进程新的信号屏蔽字是其当前信号屏蔽字和<code>set</code>指向信号集的井集。<code>set</code>包含了希望阻塞的附加信号</td>
</tr>
<tr>
<td><code>SIG_UNBLOCK</code></td>
<td>该进程新的信号屏蔽字是其当前信号屏蔽字和<code>set</code>所指向信号集补整的交集。<code>set</code>包含了希望解除阻塞的信号</td>
</tr>
<tr>
<td><code>SIG_SETMASK</code></td>
<td>该进程新的信号屏蔽是<code>set</code>指向的值</td>
</tr>
</tbody>
</table>
</div>
<p>如果<code>set</code>是个空指针，则不改变该进程的信号屏蔽字，<code>how</code>的值也无意义。在调用<code>sigprocmask</code>后如果有任何未决的、不再阻塞的信号，则在<code>sigprocmask</code>返回前，至少将其中之一递送给该进程。</p>
<p><code>sigprocmask</code>是仅为单线程进程定义的。处理多线程进程中信号的屏蔽使用另一个函数。</p>
<h2 id="函数sigpending"><a href="#函数sigpending" class="headerlink" title="函数sigpending"></a>函数sigpending</h2><p><code>sigpending</code>函数返回一信号集，对于调用进程而言，其中的各信号是阻塞不能递送的，因而也一定是当前未决的。该信号集通过<code>set</code>参数返回。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigpending</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回0；若出错：返回-1</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>	<span class="title">sig_quit</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">sigset_t</span>	newmask, oldmask, pendmask;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (signal(SIGQUIT, sig_quit) == SIG_ERR)</span><br><span class="line">		err_sys(<span class="string">"can't catch SIGQUIT"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Block SIGQUIT and save current signal mask.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	sigemptyset(&amp;newmask);</span><br><span class="line">	sigaddset(&amp;newmask, SIGQUIT);</span><br><span class="line">	<span class="keyword">if</span> (sigprocmask(SIG_BLOCK, &amp;newmask, &amp;oldmask) &lt; <span class="number">0</span>)</span><br><span class="line">		err_sys(<span class="string">"SIG_BLOCK error"</span>);</span><br><span class="line"></span><br><span class="line">	sleep(<span class="number">5</span>);	<span class="comment">/* SIGQUIT here will remain pending */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (sigpending(&amp;pendmask) &lt; <span class="number">0</span>)</span><br><span class="line">		err_sys(<span class="string">"sigpending error"</span>);</span><br><span class="line">	<span class="keyword">if</span> (sigismember(&amp;pendmask, SIGQUIT))</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\nSIGQUIT pending\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Restore signal mask which unblocks SIGQUIT.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (sigprocmask(SIG_SETMASK, &amp;oldmask, <span class="literal">NULL</span>) &lt; <span class="number">0</span>)</span><br><span class="line">		err_sys(<span class="string">"SIG_SETMASK error"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"SIGQUIT unblocked\n"</span>);</span><br><span class="line"></span><br><span class="line">	sleep(<span class="number">5</span>);	<span class="comment">/* SIGQUIT here will terminate with core file */</span></span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">sig_quit(<span class="keyword">int</span> signo)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"caught SIGQUIT\n"</span>);</span><br><span class="line">	<span class="keyword">if</span> (signal(SIGQUIT, SIG_DFL) == SIG_ERR)</span><br><span class="line">		err_sys(<span class="string">"can't reset SIGQUIT"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进程阻塞<code>SIGQUIT</code>信号，保存了当前信号屏蔽字(以便以后恢复)，然后休眠5秒。在此期间所产生的退出信号<code>SIGQUIT</code>都被阻塞，不递送至该进程，直到该信号不再被阻塞。在5秒休眠结束后，检查该信号是否是未决的，然后将<code>SIGQUIT</code>设置为不再阻塞。</p>
<p>注意，在设置<code>SIGQUIT</code>为阻塞时，我们保存了老的屏蔽字。为了解除对该信号的阻塞，用老的屏蔽字重新设置了进程信号屏蔽字(<code>SIG_SETMASK</code>)、另一种方法是用<code>SIG_UNBLOCK</code>使阻塞的信号不再阻塞。但是，应当了解如果编写一个可能由其他人使用的函数，而且需要在函数中阻塞一个信号，则不能用<code>SIG_UNBLOCK</code>简单地解除对此信号的阻塞，这是因为此函数的调用者在调用本函数之前可能也阻塞了此信号。在这种情况下必须使用<code>SIG_SETMASK</code>将信号屏蔽字恢复为先前的值。这样也就能继续阻塞该信号。</p>
<p>在休眠期间如果产生了退出信号，那么此时该信号是未决的，但是不再受阻塞，所以在<code>sigprocmask</code>返回之前，它被递送到调用进程，从程序的输出中可以看到这一点：<code>SIGQUIT</code>处理程序(<code>sig_quit</code>)中的<code>printf</code>语句先执行，然后再执行<code>sigprocmask</code>之后的<code>printf</code>语句。然后该进程再休眠5秒。如果在此期间再产生退出信号，那么因为在上次捕捉到该信号时，已将其处理方式设置为默认动作，所以这一次它就会使该进程终止。</p>
<h2 id="函数sigaction"><a href="#函数sigaction" class="headerlink" title="函数sigaction"></a>函数sigaction</h2><p><code>sigaction</code>函数的功能是检查或修改(或检查并修改)与指定信号相关联的处理动作。此函数取代了UNIX早期版本使用的<code>signal</code>函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaction</span><span class="params">(<span class="keyword">int</span> signo, <span class="keyword">const</span> struct sigaction *<span class="keyword">restrict</span> act, struct sigaction *<span class="keyword">restrict</span> oact)</span></span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回0，若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>其中，参数<code>signo</code>是要检测或修改其具体动作的信号编号。若<code>act</code>指针非空，则要修改其动作。如果<code>oact</code>指针非空，则系统经由<code>oact</code>指针返回该信号的上一个动作。此函数使用下列结构：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> &#123;</span></span><br><span class="line">	<span class="keyword">void</span> (*sa_handler)(<span class="keyword">int</span>); <span class="comment">/* addr of signal handler, */</span></span><br><span class="line">							<span class="comment">/* or SIG_IGN, or SIG_DFL */</span></span><br><span class="line">	<span class="keyword">sigset_t</span> sa_mask;</span><br><span class="line">							<span class="comment">/* additional signals to block */</span></span><br><span class="line">	<span class="keyword">int</span> sa_flags;           <span class="comment">/* signal options */</span></span><br><span class="line">				           <span class="comment">/* aiternate nandler */</span></span><br><span class="line">	<span class="keyword">void</span> (*sa_sigaction) (<span class="keyword">int</span>, <span class="keyword">siginfo_t</span> *, <span class="keyword">void</span> *);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>当更改信号动作时，如果<code>sa_handler</code>字段包含一个信号捕捉函数的地址(不是常量<code>SIG_IGN</code>或<code>SIG_DEL</code>)，则<code>sa_mask</code>字段说明了一个信号集，在调用该信号捕捉函数之前，这一信号集要加到进程的信号屏蔽字中。仅当从信号捕捉函数返回时再将进程的信号屏蔽字恢复为原先值。这样，在调用信号处理程序时就能用塞某些信号。在信号处理程序被调用时，操作系统建立的新信号屏蔽字包括正被递送的信号。因此保证了在处理一个给定的信号时，如果这种信号再次发生，那么它会被阻塞到对前一个信号的处理结束为止。若同一种信号多次发生，通常并不将它们加入队列，所以如果在某种信号被阻塞时，它发生了5次，那么对这种信号解除阻塞后，其信号处理函数通常只会被调用一次。一旦对给定的信号设置了一个动作，那么在调用<code>sigaction</code>显式地改变它之前，该设置就一直有效。这种处理方式与早期的不可靠信号机制不同，符合POSIX.1在这方面的要求。<code>act</code>结构的<code>sa_flags</code>字段指定对信号进行处理的各个选项。图中详细列出了这些选项的意义。若该标志已定义在基本POSIX.1标准中，那么SUS列包含“。”；若该标志定义在基本POSIX.1标准的XSI扩展中，那么该列包含“XSI”。<br><img src="/img/1622122627.jpg" alt></p>
<p><code>sa_sigaction</code>字段是一个替代的信号处理程序，在<code>sigaction</code>结构中使用<code>了SA_SIGINFO</code>标志时，使用该信号处理程序。对于<code>sa_sigaction</code>字段和<code>sa_handler</code>字段两者，实现可能使用同一存储区，所以应用只能一次使用这两个字段中的一个。</p>
<p>通常，按下列方式调用信号处理程序：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handler</span><span class="params">(<span class="keyword">int</span> signo)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>但是，如果设置了SA_SIGINFO标志，那么按下列方式调用信号处理程序：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handler</span><span class="params">(<span class="keyword">int</span> signo, <span class="keyword">siginfo_t</span> *info, <span class="keyword">void</span> *context)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p><code>siginfo</code>结构包含了信号产生原因的有关信息。该结构的大致样式如下所示。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">siginfo</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> 	si_signo;      	<span class="comment">/* signal number */</span></span><br><span class="line">	<span class="keyword">int</span> 	si_ezrno;       <span class="comment">/* if nonzero, errno value from &lt;errno.h&gt; */</span></span><br><span class="line">	<span class="keyword">int</span> 	si_code;        <span class="comment">/* additional into (depends on signal) */</span></span><br><span class="line">	<span class="keyword">pid_t</span> 	si_pid;         <span class="comment">/* sending process ID */</span></span><br><span class="line">	<span class="keyword">uid_t</span>  	si_uid;         <span class="comment">/* sending process real user ID */</span></span><br><span class="line">	<span class="keyword">void</span> 	*si_addr;       <span class="comment">/* address that caused the fault */</span></span><br><span class="line">	<span class="keyword">int</span>  	si_status;      <span class="comment">/* exit value or signal number */</span></span><br><span class="line">	<span class="keyword">union</span> sigval si_vaive; <span class="comment">/* application-specitic value */</span></span><br><span class="line">	<span class="comment">/* possibly other tields also */</span></span><br></pre></td></tr></table></figure></p>
<p><code>sigval</code>联合包含下列字段：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sival_int;</span><br><span class="line"><span class="keyword">void</span> *sival_ptr;</span><br></pre></td></tr></table></figure></p>
<p>应用程序在递送信号时，在<code>si_value.sival_int</code>中传递一个整型数或者在<code>si_value.sival_ptr</code>中传递一个指针值。</p>
<p>图10-17示出了对于各种信号的<code>si_code</code>值， 这些信号是由Single UNIX Specification定义的。注意，实现可定义附加的代码值。<br><img src="/img/1622123793.jpg" alt></p>
<p>若信号是<code>SIGCHLD</code>，则将设置<code>si_pid.si_status</code>和<code>si_uid</code>字段。若信号是<code>SIGBUS</code>、<code>SIGILL</code>、<code>SIGFPE</code>或<code>SIGSEGV</code>，则<code>si_addr</code>包含造成故障的根源地址，该地址可能并不准确。<code>si_errno</code>字段包含错误编号，它对应于造成信号产生的条件，并由实现定义。</p>
<p>信号处理程序的<code>context</code>参数是无类型指针，它可被强制类型转换为<code>ucontext_t</code>结构类型，该结构标识信号传递时进程的上下文。该结构至少包含下列字段：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ucontext_t</span> *uc_link;    <span class="comment">/* pointer to context resumed when */</span></span><br><span class="line">						<span class="comment">/*this context returns */</span></span><br><span class="line"><span class="keyword">sigset_t</span> uc_sigmask;    <span class="comment">/* signals blocked when this context */</span></span><br><span class="line">						<span class="comment">/*is active */</span></span><br><span class="line"><span class="keyword">stack_t</span> uc_stack;       <span class="comment">/* stack used by this context */</span></span><br><span class="line"><span class="keyword">mcontext_t</span> uc_mcontext;<span class="comment">/*machine-specitie representation of */</span></span><br><span class="line">						<span class="comment">/* saved context */</span></span><br></pre></td></tr></table></figure></p>
<p><code>uc_stack</code>字段描述了当前上下文使用的栈，至少包括下列成员：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *ss_sp;     <span class="comment">/* stack base or pointer */</span></span><br><span class="line"><span class="keyword">size_t</span> no_size;  <span class="comment">/*stack size */</span></span><br><span class="line"><span class="keyword">int</span> ss_flags;    <span class="comment">/* flags */</span></span><br></pre></td></tr></table></figure></p>
<p>当实现支持实时信号扩展时，用<code>SA_SIGINFO</code>标志建立的信号处理程序将造成信号可靠地排队。一些保留信号可由实时应用使用。如果信号由<code>sigqueue</code>函数产生，那么<code>siginfo</code>结构能包含应用特有的数据。</p>
<h2 id="函数sigsetjmp和sig1ongjmp"><a href="#函数sigsetjmp和sig1ongjmp" class="headerlink" title="函数sigsetjmp和sig1ongjmp"></a>函数sigsetjmp和sig1ongjmp</h2><p>在信号处理程序中经常调用<code>longjmp</code>函数以返回到程序的主循环中，而不是从该处理程序返回。但是，调用<code>longjmp</code>有一个问题。当捕捉到一 一个信号时，进入信号捕捉函数，此时当前信号被自动地加到进程的信号屏蔽字中。这阻止了后来产生的这种信号中断该信号处理程序。</p>
<p><code>setjmp</code>和<code>longjmp</code>保存和恢复信号屏蔽字。为了允许两种形式并存，POSIX.1并没有指定<code>setjmp</code>和<code>longjmp</code>对信号屏蔽字的作用，而是定义了两个新函数<code>sigsetjmp</code>和<code>siglongjmp</code>。在信号处理程序中进行非局部转移时应当使用这两个函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigsetjmp</span><span class="params">(sigjmp_buf env, <span class="keyword">int</span> savemask)</span></span>;</span><br><span class="line"><span class="comment">// 返回值：若直接调用，返回0：若从siq1ongjmp调用返回，则返回非0</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">siglongjmp</span><span class="params">(sigjmp_buf env, <span class="keyword">int</span> val)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>这两个函数和<code>setjmp</code>、<code>longjmp</code>之间的唯一区别是<code>sigsetjmp</code>增加了一个参数。如果<code>savemask</code>非0，则<code>sigsetjmp</code>在<code>env</code>中保存进程的当前信号屏蔽字。调用<code>siglongjmp</code>时，如果带非0 <code>savemask</code>的<code>sigsetjmp</code>调用已经保存了<code>env</code>，则<code>siglongjmp</code>从其中恢复保存的信号屏蔽字。</p>
<p>程序演示了在信号处理程序被调用时，系统所设置的信号屏蔽字如何自动地包括刚被捕捉到的信号。此程序也示例说明了如何使用<code>sigsetjmp</code>和<code>siglongjmp</code>函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>						<span class="title">sig_usr1</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>						<span class="title">sig_alrm</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="keyword">static</span> sigjmp_buf				jmpbuf;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">sig_atomic_t</span>	canjump;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (signal(SIGUSR1, sig_usr1) == SIG_ERR)</span><br><span class="line">		err_sys(<span class="string">"signal(SIGUSR1) error"</span>);</span><br><span class="line">	<span class="keyword">if</span> (signal(SIGALRM, sig_alrm) == SIG_ERR)</span><br><span class="line">		err_sys(<span class="string">"signal(SIGALRM) error"</span>);</span><br><span class="line"></span><br><span class="line">	pr_mask(<span class="string">"starting main: "</span>);		<span class="comment">/* &#123;Prog prmask&#125; */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (sigsetjmp(jmpbuf, <span class="number">1</span>)) &#123;</span><br><span class="line"></span><br><span class="line">		pr_mask(<span class="string">"ending main: "</span>);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	canjump = <span class="number">1</span>;	<span class="comment">/* now sigsetjmp() is OK */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> ( ; ; )</span><br><span class="line">		pause();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">sig_usr1(<span class="keyword">int</span> signo)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">time_t</span>	starttime;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (canjump == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span>;		<span class="comment">/* unexpected signal, ignore */</span></span><br><span class="line"></span><br><span class="line">	pr_mask(<span class="string">"starting sig_usr1: "</span>);</span><br><span class="line"></span><br><span class="line">	alarm(<span class="number">3</span>);				<span class="comment">/* SIGALRM in 3 seconds */</span></span><br><span class="line">	starttime = time(<span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">for</span> ( ; ; )				<span class="comment">/* busy wait for 5 seconds */</span></span><br><span class="line">		<span class="keyword">if</span> (time(<span class="literal">NULL</span>) &gt; starttime + <span class="number">5</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	pr_mask(<span class="string">"finishing sig_usr1: "</span>);</span><br><span class="line"></span><br><span class="line">	canjump = <span class="number">0</span>;</span><br><span class="line">	siglongjmp(jmpbuf, <span class="number">1</span>);	<span class="comment">/* jump back to main, don't return */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">sig_alrm(<span class="keyword">int</span> signo)</span><br><span class="line">&#123;</span><br><span class="line">	pr_mask(<span class="string">"in sig_alrm: "</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此程序演示了另一种技术，只要在信号处理程序中调用<code>siglongjmp</code>就应使用这种技术。仅在调用<code>sigsetjmp</code>之后才将变量<code>canjump</code>设置为非0值。在信号处理程序中检测此变量，仅当它为非0值时才调用<code>siglongjmp</code>。这提供了一种保护机制，使得在<code>jmpbuf</code> (跳转缓冲)尚未由<code>sigsetjmp</code>初始化时，防止调用信号处理程序。(在本程序中，<code>sigiongjmp</code>之后程序很快就结束，但是在较大的程序中，在<code>siglongjmp</code>之后的较长一段时间内，信号处理程序可能仍旧被设置)。在一般的C代码中(不是信号处理程序)，对于<code>longjmp</code>并不需要这种保护措施。但是，因为信号可能在任何时候发生，所以在信号处理程序中，需要这种保护措施。</p>
<p>在程序中使用了数据类型<code>sig_atomic_t</code>，这是由ISO C标准定义的变量类型，在写这种类型变量时不会被中断。这意味着在具有虚拟存储器的系统上，这种变量不会跨越页边界。可以用一条机器指令对其进行访问。这种类型的变量总是包括ISO类型修饰符<code>volatile</code>，其原因是：该变量将由两个不同的控制线程一<code>main</code>函数和异步执行的信号处理程序访问。</p>
<p>可将图10-21分成三部分，左面部分(对应于<code>main</code>)，中间部分(<code>sig_usr1</code>)和右面部分(<code>sig_alrm</code>)。在进程执行左面部分时，信号屏蔽字是0(没有信号是阻塞的)。而执行中间部分时，其信号屏蔽字是<code>SIGUSR1</code>。执行右面部分时，信号屏蔽字是<code>SIGUSR1 | SIGALRM</code>。<br><img src="/img/20210528000140.png" alt></p>
<p>执行程序，得到下面的输出：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$./a.out &amp; 在后台启动进程</span><br><span class="line">starting main:</span><br><span class="line">[1]  531</span><br><span class="line">$ <span class="built_in">kill</span> -USR1  531 作业控制shell打印其进程ID</span><br><span class="line">starting sig_usr1: SIGUSR1  向该进程发送SIGUSRI</span><br><span class="line"></span><br><span class="line">$ <span class="keyword">in</span> sig_alrm: SIGUSRI SIGALRM</span><br><span class="line">finishing sig_usr1 SIGUSR1</span><br><span class="line">ending main</span><br><span class="line"></span><br><span class="line">[1] +   Done     ./a.out &amp;</span><br></pre></td></tr></table></figure></p>
<p>该输出与我们所期望的相同：当调用一个信号处理程序时，被捕捉到的信号加到进程的当前信号屏蔽字中，当从信号处理程序返回时，恢复原来的屏蔽字。另外，<code>siglongjmp</code>恢复了由<code>sigsetjmp</code>所保存的信号屏蔽字。</p>
<p>如果在Limux中将图10-20程序中的<code>sigsetjmp</code>和<code>siglongjmp</code>分别替换成<code>setjmp</code>和<code>longjmp</code>，则最后一行输出变成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ending main: SIGUSRI</span><br></pre></td></tr></table></figure></p>
<p>这意味着在调用<code>setjmp</code>之后执行<code>main</code>函数时，其<code>SIGUSR1</code>是阻塞的。这多半不是我们所希望的。</p>
<h2 id="函数sigsuspend"><a href="#函数sigsuspend" class="headerlink" title="函数sigsuspend"></a>函数sigsuspend</h2><p>上面已经说明，更改进程的信号屏蔽字可以阻塞所选择的信号，或解除对它们的阻塞。使用这种技术可以保护不希望由信号中断的代码临界区。</p>
<p>如果在信号阻塞时，产生了信号，那么该信号的传递就被推迟直到对它解除了阻塞。对应用程序而言，该信号好像发生在解除对<code>SIGINT</code>的阻塞和<code>pause</code>之间(取决于内核如何实现信号)。如果发生了这种情况，或者如果在解除阻塞时刻和pause之间确实发生了信号，那么就会产生问题。因为可能不会再见到该信号，所以从这种意义上讲，在此时间窗口中发生的信号丢失了，这样就使得pause永远阻塞。这是早期的不可靠信号机制的另一个问题。</p>
<p>为了纠正此问题。需要在一个原子操作中先恢复信号屏蔽字，然后使进程休眠。这种功能是由<code>sigsuspend</code>函数所提供的。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigsuspend</span><span class="params">(<span class="keyword">const</span> <span class="keyword">sigset_t</span> *sigmask)</span></span>;</span><br><span class="line"><span class="comment">// 返回值。-1，并将errno设置为EINTR</span></span><br></pre></td></tr></table></figure></p>
<p>进程的信号屏蔽字设置为由<code>sigmask</code>指向的值。 在捕捉到一个信号或发生了一个会终止该进程的信号之前，该进程被挂起。如果捕捉到一个信号面且从该信号处理程序返回，则<code>sigsuspend</code>返回，并且该进程的信号屏蔽字设置为调用<code>sigsuspend</code>之前的值。</p>
<p>注意，此函数没有成功返回值。如果它返回到调用者，则总是返回-1，并将errno设置为EINTR(表示一个被中断的系统调用)。</p>
<p>下面的程序显示了保护代码临界区，使其不被特定信号中断的正确方法。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>	<span class="title">sig_int</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">sigset_t</span>	newmask, oldmask, waitmask;</span><br><span class="line"></span><br><span class="line">	pr_mask(<span class="string">"program start: "</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (signal(SIGINT, sig_int) == SIG_ERR)</span><br><span class="line">		err_sys(<span class="string">"signal(SIGINT) error"</span>);</span><br><span class="line">	sigemptyset(&amp;waitmask);</span><br><span class="line">	sigaddset(&amp;waitmask, SIGUSR1);</span><br><span class="line">	sigemptyset(&amp;newmask);</span><br><span class="line">	sigaddset(&amp;newmask, SIGINT);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Block SIGINT and save current signal mask.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (sigprocmask(SIG_BLOCK, &amp;newmask, &amp;oldmask) &lt; <span class="number">0</span>)</span><br><span class="line">		err_sys(<span class="string">"SIG_BLOCK error"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Critical region of code.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	pr_mask(<span class="string">"in critical region: "</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Pause, allowing all signals except SIGUSR1.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (sigsuspend(&amp;waitmask) != <span class="number">-1</span>)</span><br><span class="line">		err_sys(<span class="string">"sigsuspend error"</span>);</span><br><span class="line"></span><br><span class="line">	pr_mask(<span class="string">"after return from sigsuspend: "</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Reset signal mask which unblocks SIGINT.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (sigprocmask(SIG_SETMASK, &amp;oldmask, <span class="literal">NULL</span>) &lt; <span class="number">0</span>)</span><br><span class="line">		err_sys(<span class="string">"SIG_SETMASK error"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * And continue processing ...</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	pr_mask(<span class="string">"program exit: "</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">sig_int(<span class="keyword">int</span> signo)</span><br><span class="line">&#123;</span><br><span class="line">	pr_mask(<span class="string">"\nin sig_int: "</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意，当<code>sigsuspend</code>返回时，它将信号屏蔽字设置为调用它之前的值。在本例中，<code>SIGINT</code>信号将被阻塞。因此将信号屏蔽恢复为之前保存的值(<code>oldmask</code>)。</p>
<p><code>sigsuspend</code>的另一种应用是等待一个信号处理程序设置一个全局变量。程序用于捕捉中断信号和退出信号，但是希望仅当捕捉到退出信号时，才唤醒主例程。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">sig_atomic_t</span>	quitflag;	<span class="comment">/* set nonzero by signal handler */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">sig_int(<span class="keyword">int</span> signo)	<span class="comment">/* one signal handler for SIGINT and SIGQUIT */</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (signo == SIGINT)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\ninterrupt\n"</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (signo == SIGQUIT)</span><br><span class="line">		quitflag = <span class="number">1</span>;	<span class="comment">/* set flag for main loop */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">sigset_t</span>	newmask, oldmask, zeromask;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (signal(SIGINT, sig_int) == SIG_ERR)</span><br><span class="line">		err_sys(<span class="string">"signal(SIGINT) error"</span>);</span><br><span class="line">	<span class="keyword">if</span> (signal(SIGQUIT, sig_int) == SIG_ERR)</span><br><span class="line">		err_sys(<span class="string">"signal(SIGQUIT) error"</span>);</span><br><span class="line"></span><br><span class="line">	sigemptyset(&amp;zeromask);</span><br><span class="line">	sigemptyset(&amp;newmask);</span><br><span class="line">	sigaddset(&amp;newmask, SIGQUIT);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Block SIGQUIT and save current signal mask.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (sigprocmask(SIG_BLOCK, &amp;newmask, &amp;oldmask) &lt; <span class="number">0</span>)</span><br><span class="line">		err_sys(<span class="string">"SIG_BLOCK error"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (quitflag == <span class="number">0</span>)</span><br><span class="line">		sigsuspend(&amp;zeromask);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * SIGQUIT has been caught and is now blocked; do whatever.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	quitflag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Reset signal mask which unblocks SIGQUIT.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (sigprocmask(SIG_SETMASK, &amp;oldmask, <span class="literal">NULL</span>) &lt; <span class="number">0</span>)</span><br><span class="line">		err_sys(<span class="string">"SIG_SETMASK error"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此程序的样本输出是：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out</span><br><span class="line">^C        键入中断字符</span><br><span class="line">interrupt </span><br><span class="line">^C        再次健入中断字符</span><br><span class="line">interrupt </span><br><span class="line">^C        再一次</span><br><span class="line">interrupt</span><br><span class="line">^\$       用退出符终止</span><br></pre></td></tr></table></figure></p>
<p>可以用信号实现父、子进程之间的同步，这是信号应用的另一个实例。给出了<code>TELLWAIT</code>、<code>TELL_PARENT</code>、<code>TELL_CHILD</code>、<code>WAIT_PARENT</code>和<code>WAIT_CHILD</code>5个例程的实现。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">sig_atomic_t</span> sigflag; <span class="comment">/* set nonzero by sig handler */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">sigset_t</span> newmask, oldmask, zeromask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">sig_usr(<span class="keyword">int</span> signo)	<span class="comment">/* one signal handler for SIGUSR1 and SIGUSR2 */</span></span><br><span class="line">&#123;</span><br><span class="line">	sigflag = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">TELL_WAIT(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (signal(SIGUSR1, sig_usr) == SIG_ERR)</span><br><span class="line">		err_sys(<span class="string">"signal(SIGUSR1) error"</span>);</span><br><span class="line">	<span class="keyword">if</span> (signal(SIGUSR2, sig_usr) == SIG_ERR)</span><br><span class="line">		err_sys(<span class="string">"signal(SIGUSR2) error"</span>);</span><br><span class="line">	sigemptyset(&amp;zeromask);</span><br><span class="line">	sigemptyset(&amp;newmask);</span><br><span class="line">	sigaddset(&amp;newmask, SIGUSR1);</span><br><span class="line">	sigaddset(&amp;newmask, SIGUSR2);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Block SIGUSR1 and SIGUSR2, and save current signal mask */</span></span><br><span class="line">	<span class="keyword">if</span> (sigprocmask(SIG_BLOCK, &amp;newmask, &amp;oldmask) &lt; <span class="number">0</span>)</span><br><span class="line">		err_sys(<span class="string">"SIG_BLOCK error"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">TELL_PARENT(<span class="keyword">pid_t</span> pid)</span><br><span class="line">&#123;</span><br><span class="line">	kill(pid, SIGUSR2);		<span class="comment">/* tell parent we're done */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">WAIT_PARENT(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span> (sigflag == <span class="number">0</span>)</span><br><span class="line">		sigsuspend(&amp;zeromask);	<span class="comment">/* and wait for parent */</span></span><br><span class="line">	sigflag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Reset signal mask to original value */</span></span><br><span class="line">	<span class="keyword">if</span> (sigprocmask(SIG_SETMASK, &amp;oldmask, <span class="literal">NULL</span>) &lt; <span class="number">0</span>)</span><br><span class="line">		err_sys(<span class="string">"SIG_SETMASK error"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">TELL_CHILD(<span class="keyword">pid_t</span> pid)</span><br><span class="line">&#123;</span><br><span class="line">	kill(pid, SIGUSR1);			<span class="comment">/* tell child we're done */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">WAIT_CHILD(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span> (sigflag == <span class="number">0</span>)</span><br><span class="line">		sigsuspend(&amp;zeromask);	<span class="comment">/* and wait for child */</span></span><br><span class="line">	sigflag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Reset signal mask to original value */</span></span><br><span class="line">	<span class="keyword">if</span> (sigprocmask(SIG_SETMASK, &amp;oldmask, <span class="literal">NULL</span>) &lt; <span class="number">0</span>)</span><br><span class="line">		err_sys(<span class="string">"SIG_SETMASK error"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中使用了两个用户定义的信号：<code>SIGUSR1</code>由父进程发送给子进程，<code>SIGUSR2</code>由子进程发送给父进程。</p>
<p>如果在等待信号发生时希望去休眠，则使用<code>sigsuspend</code>函数是非常适当的。</p>
<h2 id="函数abort"><a href="#函数abort" class="headerlink" title="函数abort"></a>函数abort</h2><p>前面已提及<code>abort</code>函数的功能是使程序异常终止。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">abort</span> <span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="comment">// 此函数不返回值</span></span><br></pre></td></tr></table></figure></p>
<p>此函数将<code>SIGABRT</code>信号发送给调用进程(进程不应忽略此信号)。ISO C规定，调用<code>abort</code>将向主机环境递送一个未成功终止的通知，其方法是调用<code>raise(SIGABRT)</code>函数。ISO C要求若捕捉到此信号而且相应信号处理程序返回，<code>abort</code>仍不会返回到其调用者。如果捕捉到此信号，则信号处理程序不能返回的唯一方法是它调用<code>exit</code>、<code>_exit</code>、<code>_Exit</code>、<code>longjmp</code>、<code>siglongjmp</code>。</p>
<p>让进程捕捉<code>SIGABRT</code>的意图是：在进程终止之前由其执行所需的清理操作。如果进程并不在信号处理程序中终止自己，POSIX.1声明当信号处理程序返回时，<code>abort</code>终止该进程。POSIX.1的要求是：如果<code>abort</code>调用终止进程，则它对所有打开标准I/O流的效果应当与进程终止前对每个流调用<code>fclose</code>相同。</p>
<p><code>abort</code>函数是按POSIX.1说明实现的。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line"><span class="built_in">abort</span>(<span class="keyword">void</span>)			<span class="comment">/* POSIX-style abort() function */</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">sigset_t</span>			mask;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span>	<span class="title">action</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Caller can't ignore SIGABRT, if so reset to default */</span></span><br><span class="line">	sigaction(SIGABRT, <span class="literal">NULL</span>, &amp;action);</span><br><span class="line">	<span class="keyword">if</span> (action.sa_handler == SIG_IGN) &#123;</span><br><span class="line">		action.sa_handler = SIG_DFL;</span><br><span class="line">		sigaction(SIGABRT, &amp;action, <span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (action.sa_handler == SIG_DFL)</span><br><span class="line">		fflush(<span class="literal">NULL</span>);			<span class="comment">/* flush all open stdio streams */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Caller can't block SIGABRT; make sure it's unblocked */</span></span><br><span class="line">	sigfillset(&amp;mask);</span><br><span class="line">	sigdelset(&amp;mask, SIGABRT);	<span class="comment">/* mask has only SIGABRT turned off */</span></span><br><span class="line">	sigprocmask(SIG_SETMASK, &amp;mask, <span class="literal">NULL</span>);</span><br><span class="line">	kill(getpid(), SIGABRT);	<span class="comment">/* send the signal */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* If we're here, process caught SIGABRT and returned */</span></span><br><span class="line">	fflush(<span class="literal">NULL</span>);				<span class="comment">/* flush all open stdio streams */</span></span><br><span class="line">	action.sa_handler = SIG_DFL;</span><br><span class="line">	sigaction(SIGABRT, &amp;action, <span class="literal">NULL</span>);	<span class="comment">/* reset to default */</span></span><br><span class="line">	sigprocmask(SIG_SETMASK, &amp;mask, <span class="literal">NULL</span>);	<span class="comment">/* just in case ... */</span></span><br><span class="line">	kill(getpid(), SIGABRT);				<span class="comment">/* and one more time */</span></span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);	<span class="comment">/* this should never be executed ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先查看是否将执行默认动作，若是则冲洗所有标准I/O流。这并不等价于对所有打开的流调用<code>fclose</code>(因为只冲洗，并不关闭它们)，但是当进程终止时，系统会关闭所有打开的文件。如果进程捕捉此信号并返回，那么因为进程可能产生了更多的输出，所以再一次冲洗所有的流。不进行冲洗处理的唯一条件是如果进程捕捉此信号，然后调用<code>_exit</code>或<code>_Exit</code>。在这种情况下，任何来冲洗的内存中的标准I/O缓存都被丢弃。我们假定捕捉此信号，而且<code>_exit</code>或<code>_Exit</code>的调用者并不想要冲洗缓冲区。我们阻塞除<code>SIGABRT</code>外的所有信号，这样就可知如果对<code>kill</code>的调用返回了，则该进程一定已捕捉到该信号，并且也从该信号处理程序返回。</p>
<h2 id="函数system"><a href="#函数system" class="headerlink" title="函数system"></a>函数system</h2><p>POSIX.1要求<code>system</code>忽略<code>SIGINT</code>和<code>SIGQUIT</code>，阻塞<code>SIGCHLD</code>。在给出一个正确地处理这些信号的一个版本之前，先说明为什么要考虑信号处理。</p>
<p>程序是<code>system</code>函数的另一个实现，它进行了所要求的信号处理。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>	<span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>	<span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>	<span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>	<span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">system(<span class="keyword">const</span> <span class="keyword">char</span> *cmdstring)	<span class="comment">/* with appropriate signal handling */</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">pid_t</span>				pid;</span><br><span class="line">	<span class="keyword">int</span>					status;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span>	<span class="title">ignore</span>, <span class="title">saveintr</span>, <span class="title">savequit</span>;</span></span><br><span class="line">	<span class="keyword">sigset_t</span>			chldmask, savemask;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (cmdstring == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span>(<span class="number">1</span>);		<span class="comment">/* always a command processor with UNIX */</span></span><br><span class="line"></span><br><span class="line">	ignore.sa_handler = SIG_IGN;	<span class="comment">/* ignore SIGINT and SIGQUIT */</span></span><br><span class="line">	sigemptyset(&amp;ignore.sa_mask);</span><br><span class="line">	ignore.sa_flags = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (sigaction(SIGINT, &amp;ignore, &amp;saveintr) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">if</span> (sigaction(SIGQUIT, &amp;ignore, &amp;savequit) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line">	sigemptyset(&amp;chldmask);			<span class="comment">/* now block SIGCHLD */</span></span><br><span class="line">	sigaddset(&amp;chldmask, SIGCHLD);</span><br><span class="line">	<span class="keyword">if</span> (sigprocmask(SIG_BLOCK, &amp;chldmask, &amp;savemask) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		status = <span class="number">-1</span>;	<span class="comment">/* probably out of processes */</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;			<span class="comment">/* child */</span></span><br><span class="line">		<span class="comment">/* restore previous signal actions &amp; reset signal mask */</span></span><br><span class="line">		sigaction(SIGINT, &amp;saveintr, <span class="literal">NULL</span>);</span><br><span class="line">		sigaction(SIGQUIT, &amp;savequit, <span class="literal">NULL</span>);</span><br><span class="line">		sigprocmask(SIG_SETMASK, &amp;savemask, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">		execl(<span class="string">"/bin/sh"</span>, <span class="string">"sh"</span>, <span class="string">"-c"</span>, cmdstring, (<span class="keyword">char</span> *)<span class="number">0</span>);</span><br><span class="line">		_exit(<span class="number">127</span>);		<span class="comment">/* exec error */</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;						<span class="comment">/* parent */</span></span><br><span class="line">		<span class="keyword">while</span> (waitpid(pid, &amp;status, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">if</span> (errno != EINTR) &#123;</span><br><span class="line">				status = <span class="number">-1</span>; <span class="comment">/* error other than EINTR from waitpid() */</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* restore previous signal actions &amp; reset signal mask */</span></span><br><span class="line">	<span class="keyword">if</span> (sigaction(SIGINT, &amp;saveintr, <span class="literal">NULL</span>) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">if</span> (sigaction(SIGQUIT, &amp;savequit, <span class="literal">NULL</span>) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">if</span> (sigprocmask(SIG_SETMASK, &amp;savemask, <span class="literal">NULL</span>) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span>(status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="system的返回值"><a href="#system的返回值" class="headerlink" title="system的返回值"></a>system的返回值</h3><p>注意<code>system</code>的返回值，它是shell的终止状态，但shell的终止状态并不总是执行命令字符串进程的终止状态。如果执行一条如<code>date</code>那样的简单命令，其终止状态是0。执行shell命令<code>exit 44</code>，则得终止状态44。在信号方面又如何呢?</p>
<p>Bourne shell有一个在其文档中没有说清楚的特性，其终止状态是128加上一个信号编号，该信号终止了正在执行的命令。用交互方式使用shell可以看到这一点。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ sh       确保运行Bourneshell</span><br><span class="line">$ sh -c <span class="string">"sleep 30"</span> </span><br><span class="line">^C         键入中断符</span><br><span class="line">$ <span class="built_in">echo</span> $?  打印最后一条命令的终止状态</span><br><span class="line">130</span><br><span class="line">$ sh -c <span class="string">"sleep 30"</span> </span><br><span class="line">^\sh: 962 Quit - core dumped    键入退出符</span><br><span class="line">$ <span class="built_in">echo</span> $?   打印最后一条命令的终止状态</span><br><span class="line">131</span><br><span class="line">$ <span class="built_in">exit</span>      离开Bourne shell</span><br></pre></td></tr></table></figure></p>
<p>在所使用的系统中，<code>SIGINT</code>的值为2，<code>SIGQUIT</code>的值为3，于是给出shell终止状态130、131。</p>
<h2 id="函数sleep、nanosleep和clock-nanosleep"><a href="#函数sleep、nanosleep和clock-nanosleep" class="headerlink" title="函数sleep、nanosleep和clock_nanosleep"></a>函数sleep、nanosleep和clock_nanosleep</h2><p>两个sleep的实现都是有缺陷的。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">sleep</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> seconds)</span></span>;</span><br><span class="line"><span class="comment">// 返回值：0或未休眠完的秒数</span></span><br></pre></td></tr></table></figure></p>
<p>此函数使调用进程被挂起直到满足下面两个条件之一。</p>
<ol>
<li>已经过了seconds所指定的墙上时钟时间。</li>
<li>调用进程捕捉到一个信号并从信号处理程序返回。</li>
</ol>
<p>如同<code>alarm</code>信号一样，由于其他系统活动，实际返回时间比所要求的会迟一些。在第1种情形，返回值是0。当由于捕捉到某个信号sleep提早返回时(第2种情形)，返回值是未休眠完的秒数(所要求的时间减去实际休眠时间)。</p>
<p>尽管<code>sleep</code>可以用<code>alarm</code>函数实现，但这并不是必需的。如果使用<code>alarm</code>，则这两个函数之间可能相互影响。</p>
<p>给出的是一个POSIX.1 <code>sleep</code>函数的实现，它可靠地处理信号，避免了早期实现中的竞争条件，但是仍未处理与以前设置的闹钟的交互作用。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">include <span class="string">"apue.h"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">sig_alrm(<span class="keyword">int</span> signo)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* nothing to do, just returning wakes up sigsuspend() */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span></span><br><span class="line">sleep(<span class="keyword">unsigned</span> <span class="keyword">int</span> seconds)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span>    <span class="title">newact</span>, <span class="title">oldact</span>;</span></span><br><span class="line">    <span class="keyword">sigset_t</span>            newmask, oldmask, suspmask;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>        unslept;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* set our handler, save previous information */</span></span><br><span class="line">    newact.sa_handler = sig_alrm;</span><br><span class="line">    sigemptyset(&amp;newact.sa_mask);</span><br><span class="line">    newact.sa_flags = <span class="number">0</span>;</span><br><span class="line">    sigaction(SIGALRM, &amp;newact, &amp;oldact);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* block SIGALRM and save current signal mask */</span></span><br><span class="line">    sigemptyset(&amp;newmask);</span><br><span class="line">    sigaddset(&amp;newmask, SIGALRM);</span><br><span class="line">    sigprocmask(SIG_BLOCK, &amp;newmask, &amp;oldmask);</span><br><span class="line"></span><br><span class="line">    alarm(seconds);</span><br><span class="line">    suspmask = oldmask;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* make sure SIGALRM isn't blocked */</span></span><br><span class="line">    sigdelset(&amp;suspmask, SIGALRM);</span><br><span class="line">    <span class="comment">/* wait for any signal to be caught */</span></span><br><span class="line">    sigsuspend(&amp;suspmask);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* some signal has been caught, SIGALRM is now blocked */</span></span><br><span class="line"></span><br><span class="line">    unslept = alarm(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* reset previous action */</span></span><br><span class="line">    sigaction(SIGALRM, &amp;oldact, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* reset signal mask, which unblocks SIGALRM */</span></span><br><span class="line">    sigprocmask(SIG_SETMASK, &amp;oldmask, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span>(unslept);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>程序中没有使用任何形式的非局部转移，所以对处理<code>SIGALRM</code>信号期间可能执行的其他信号处理程序没有任何影响。<code>nanosleep</code>函数与<code>sleep</code>函数类似，但提供了纳秒级的精度。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nanosleep</span> <span class="params">(<span class="keyword">const</span> struct timespec *reqtp, struct timespec *remp)</span></span>;</span><br><span class="line"><span class="comment">// 返回值，若休眠到要求的时间，返回0，若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>这个函数挂起调用进程，直到要求的时间已经超时或者某个信号中断了该函数。<code>reqtp</code>参数用秒和纳秒指定了需要休眠的时间长度。如果某个信号中断了休眠间隔，进程并没有终止，<code>remtp</code>参数指向的<code>timespec</code>结构就会被设置为未休眠完的时间长度。如果对未休眠完的时间并不感兴趣，可以把该参数置为NULL，如果系统并不支持纳秒这一精度，要求的时间就会取整。因为<code>nanosleep</code>函数并不涉及产生任何信号，所以不需要担心与其他函数的交互。</p>
<p>随着多个系统时钟的引入，需要使用相对于特定时钟的延迟时间来挂起调用线程。<code>clock_nanosleep</code>函数提供了这种功能，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">clock_nanosleep</span> <span class="params">(<span class="keyword">clockid_t</span> clock_id, <span class="keyword">int</span> flag, <span class="keyword">const</span> struct tinespec *reqtp, struct timespec *remtp)</span></span>;</span><br><span class="line"><span class="comment">// 返回值：若休眠要求的时间，返回0；若出错，返回错误码</span></span><br></pre></td></tr></table></figure></p>
<p><code>clook_id</code>参数指定了计算延迟时间基于的时钟。<code>flags</code>参数用于控制延迟是相对的还是绝对的。<code>flags</code>为0时表示休眠时间是相对的，如果<code>flags</code>值设置为<code>TIMER_ABSTIME</code>，表示休眠时间是绝对的。其他的参数<code>reqtp</code>和<code>remtp</code>，与<code>nanosleep</code>函数中的相同。在时钟到达指定的绝对时间值以前，可以为其他的<code>clock_nanosleep</code>调用复用<code>reqtp</code>参数相同的值。</p>
<p>注意，除了出错返回，调用<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clock_nanosleep (CLOCK_REALTIME, <span class="number">0</span>, reqtp, remtp);</span><br></pre></td></tr></table></figure></p>
<p>和调用<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nanosleep (reqtp, remtp);</span><br></pre></td></tr></table></figure></p>
<p>的效果是相同的。使用相对休眠的问题是有些应用对休眠长度有精度要求，相对休眠时间会导致实际休眠时间比要求的长。例如，某个应用程序希望按固定的时间间隔执行任务，就必须获取当前时间，计算下次执行任务的时间，然后调用<code>nanosleep</code>。在获取当前时间和调用<code>nanosleep</code>之间，处理器调度和抢占可能会导致相对休眠时间超过实际需要的时间间隔。即便分时进程调度程序对休眠时间结束后是否会马上执行用户任务并没有给出保证，使用绝对时间还是改善了精度。</p>
<h2 id="函数sigqueue"><a href="#函数sigqueue" class="headerlink" title="函数sigqueue"></a>函数sigqueue</h2><p>通常一个信号带有一个位信息：信号本身。除了对信号排队以外，这些扩展允许应用程序在递交信号时传递更多的信息。这些信息嵌入在<code>siginfo</code>结构中。除了系统提供的信息，应用程序还可以向信号处理程序传递整数或者指向包含更多信息的缓冲区指针。使用排队信号必须做以下几个操作。</p>
<ol>
<li>使用<code>sigaction</code>函数安装信号处理程序时指定<code>SA_SIGINFO</code>标志，如果没有给出这个标志，信号会延迟，但信号是否进入队列要取决于具体实现。</li>
<li>在<code>sigaction</code>结构的<code>sa_sigaction</code>成员中(而不是通常的<code>sa_handler</code>字段)提供信号处理程序。实现可能允许用户使用<code>sa_handler</code>字段，但不能获取<code>sigqueue</code>函数发送出来的额外信息。</li>
<li>使用<code>sigqueue</code>函数发送信号。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;aigna1.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigqueue</span> <span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> signo, <span class="keyword">const</span> <span class="keyword">union</span> sigval value)</span></span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回0，若出错，返回-1</span></span><br></pre></td></tr></table></figure>
<p><code>sigqueue</code>函数只能把信号发送给单个进程，可以使用<code>value</code>参数向信号处理程序传递整数和指针值，除此之外，<code>sigqueue</code>函数与<code>kill</code>函数类似。</p>
<p>信号不能被无限排队。回忆<code>SIGQUEUE_MAX</code>限制。到达相应的限制以后，<code>sigqueue</code>就会失败，将errno设为EAGAIN，随着实时信号的增强，引入了用于应用程序的独立信号集。这些信号的编号在<code>SIGRTMIN</code>~<code>SIGRTMAX</code>之间，包括这两个限制值。注意，这些信号的默认行为是终止进程。</p>
<h2 id="作业控制信号"><a href="#作业控制信号" class="headerlink" title="作业控制信号"></a>作业控制信号</h2><p>POSIX.1认为有以下6个与作业控制有关。</p>
<ul>
<li><code>SIGCHLD</code>：子进程已停止或终止。</li>
<li><code>SIGCONT</code>：如果进程已停止，则使其继续运行。</li>
<li><code>SIGSTOP</code>：停止信号(不能被捕捉或忽略)。</li>
<li><code>SIGTSTP</code>：交互式停止信号。</li>
<li><code>SIGTTIN</code>：后台进程组成员读控制终端。</li>
<li><code>SIGTTOU</code>：后台进程组成员写控制终端。</li>
</ul>
<p>除<code>SIGCHLD</code>以外，大多数应用程序并不处理这些信号，交互式shell则通常会处理这些信号的所有工作。当键入挂起字符(通常是Ctrl+Z)时，<code>SIGTSTP</code>被送至前台进程组的所有进程。当我们通知shell在前台或后台恢复运行一个作业时，shell向该作业中的所有进程发送<code>SIGCONT</code>信号。与此类似。如果向一个进程递送了<code>SIGTTIN</code>或<code>SIGTTOU</code>信号，则根据系统默认的方式，停止此进程，作业控制shell了解到这一点后就通知我们。</p>
<p>一个例外是管理终端的进程，例如，<code>vi(1)</code>编辑器。当用户要挂起它时，它需要能了解到这一点。这样就能将终端状态恢复到vi启动时的情况。另外，当在前台恢复它时，它需要将终端状态设置回它所希望的状态，并需要重新绘制终端屏幕。</p>
<p>在作业控制信号间有某些交互。当对一个进程产生4种停止信号(<code>SIGTSTP</code>、<code>SIGSTOP</code>、<code>SIGTTIN</code>或<code>SIGTTOU</code>)中的任意一种时，对该进程的任一未决<code>SIGCONT</code>信号就被丢弃。与此类似，当对一个进程产生<code>SIGCONT</code>信号时，对同一进程的任一未决停止信号被丢弃。</p>
<p>注意，如果进程是停止的，则<code>SIGCONT</code>的默认动作是继续该进程：否则忽略此信号。通常，对该信号无需做任何事情。当对一个停止的进程产生一个<code>SIGCONT</code>信号时，该进程就继续，即使该信号是被阻塞或忽略的也是如此。</p>
<p>程序演示了当一个程序处理作业控制时通常所使用的规范代码序列。该程序只是将其标准输入复制到其标准输出，而在信号处理程序中以注释形式给出了管理屏幕的程序所执行的典型操作。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	BUFFSIZE	1024</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">sig_tstp(<span class="keyword">int</span> signo)	<span class="comment">/* signal handler for SIGTSTP */</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">sigset_t</span>	mask;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* ... move cursor to lower left corner, reset tty mode ... */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Unblock SIGTSTP, since it's blocked while we're handling it.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	sigemptyset(&amp;mask);</span><br><span class="line">	sigaddset(&amp;mask, SIGTSTP);</span><br><span class="line">	sigprocmask(SIG_UNBLOCK, &amp;mask, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	signal(SIGTSTP, SIG_DFL);	<span class="comment">/* reset disposition to default */</span></span><br><span class="line"></span><br><span class="line">	kill(getpid(), SIGTSTP);	<span class="comment">/* and send the signal to ourself */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* we won't return from the kill until we're continued */</span></span><br><span class="line"></span><br><span class="line">	signal(SIGTSTP, sig_tstp);	<span class="comment">/* reestablish signal handler */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* ... reset tty mode, redraw screen ... */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span>		n;</span><br><span class="line">	<span class="keyword">char</span>	buf[BUFFSIZE];</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Only catch SIGTSTP if we're running with a job-control shell.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (signal(SIGTSTP, SIG_IGN) == SIG_DFL)</span><br><span class="line">		signal(SIGTSTP, sig_tstp);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> ((n = read(STDIN_FILENO, buf, BUFFSIZE)) &gt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">if</span> (write(STDOUT_FILENO, buf, n) != n)</span><br><span class="line">			err_sys(<span class="string">"write error"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">		err_sys(<span class="string">"read error"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当程序启动时，仅当<code>SIGTSTP</code>信号的配置是<code>SIG_DFL</code>，它才安排捕捉该信号。其理由是：当此程序由不支持作业控制的shell (如<code>/bin/sh</code>)启动时，此信号的配置应当设置为<code>SIG_IGN</code>。实际上，shell并不显式地忽略此信号， 而是由<code>init</code>将这3个作业控制信号<code>SIGTSTP</code>、<code>SIGTTIN</code>和<code>SIGTTOU</code>设置为<code>SIG_IGN</code>。然后，这种配置由所有登录shell继承。只有作业控制shell才应将这3个信号重新设置为<code>SIG_DFL</code>。</p>
<p>当键入挂起字符时，进程接到<code>SIGTSTP</code>信号，然后调用该信号处理程序。此时，应当进行与终端有关的处理：将光标移到左下角、恢复终端工作方式等。在将<code>SIGTSTP</code>重置为默认值(停止该进程)，并且解除了对此信号的阻塞之后，进程向自己发送同一信号<code>SIGTSTP</code>。因为正在处理<code>SIGTSTP</code>信号，而在捕捉该信号期间系统自动地阻塞它，所以应当解除对此信号的阻塞。到达这一点时，系统停止该进程。仅当某个进程向该进程发送一个<code>SIGCONT</code>信号时，该进程才继续。我们不捕捉<code>SIGCONT</code>信号。该信号的默认配置是继续运行停止的进程，当此发生时，此程序如同从kill函数返回一样继续运行。当此程序继续运行时，将<code>SIGTSTP</code>信号重置为捕捉，并且做我们所希望做的终端处理。</p>
<h2 id="信号名和编号"><a href="#信号名和编号" class="headerlink" title="信号名和编号"></a>信号名和编号</h2><p>本节介绍如何在信号编号和信号名之间进行映射。某些系统提供数组<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> *sys_siglist[]:</span><br></pre></td></tr></table></figure></p>
<p>数组下标是信号编号，数组中的元素是指向信号名符串的指针。</p>
<p>可以使用<code>psignal</code>函数可移植地打印与信号编号对应的字符串。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line">void psignal(int signo, const char *msg):</span><br></pre></td></tr></table></figure></p>
<p>字符串<code>msg</code>(通常是程序名)输出到标准错误文件，后面跟随一个冒号和一个空格，再后面对该信号的说明，最后是一个换行符。如果<code>msg</code>为NULL，只有信号说明部分输出到标准错误文件。</p>
<p>如果在<code>sigaction</code>信号处理程序中有<code>siginfo</code>结构，可以使用<code>psiginfo</code>函数打印信号信息。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">psiginfo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">siginfo_t</span> *info, <span class="keyword">const</span> <span class="keyword">char</span> *msg)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>它的工作方式与<code>psignal</code>函数类似。虽然这个函数访问除信号编号以外的更多信息，但不同的平台输出的这些额外信息可能有所不同。</p>
<p>如果只需要信号的字符描述部分，也不需要把它写到标准错误文件中(如可以写到日志文件中)，可以使用<code>strsignal</code>函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strsignal</span><span class="params">(<span class="keyword">int</span> signo)</span></span>;</span><br><span class="line"><span class="comment">// 返回值：指向描述该信号的字符串的指针</span></span><br></pre></td></tr></table></figure></p>
<p>给出一个信号编号，<code>strsignal</code>将返回描述该信号的字符串。应用程序可用该字符串打印关于接收到信号的出错信息。</p>
<p>Solaris提供一对函数，一个函数将信号编号映射为信号名，另一个则反之。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sig2str</span><span class="params">(<span class="keyword">int</span> signo, <span class="keyword">char</span> *str)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">str2sig</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str, <span class="keyword">int</span> *signop)</span></span>;</span><br><span class="line"><span class="comment">// 两个函数的返回值：若成功，返回0；若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>在编写交互式程序，其中需接收和打印信号名和信号编号时，这两个函数是有用的。</p>
<p><code>sig2str</code>函数将给定信号编号翻译成字符串，并将结果存放在str指向的存储区。调用者必须保证该存储区足够大，可以保存最长字符串，包括终止null字节。Solaris在<code>&lt;signal.h&gt;</code>中包含了常量<code>SIG2STR_MAX</code>，它定义了最大字符串长度。该字符串包括不带“SIG”前缀的信号名。例如，SIGKILL被翻译为字符串“KILL”，并存放在str指向的存储缓冲区中。</p>
<p><code>str2sig</code>函数将给出的信号名翻译成信号编号，该信号编号存放在<code>signop</code>指向的整型中。名字要么是不带“SIG”前缀的信号名，要么是表示十进制信号编号的字符串(如“9”)。注意，<code>sig2str</code>和<code>str2sig</code>与常用的函数做法不同，当它们失败时，并不设置errno。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Linux/" rel="tag"># Linux</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/05/24/UNIX高级编程 笔记3/" rel="next" title="UNIX高级编程 笔记3">
                <i class="fa fa-chevron-left"></i> UNIX高级编程 笔记3
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/05/29/UNIX高级编程 笔记5/" rel="prev" title="UNIX高级编程 笔记5">
                UNIX高级编程 笔记5 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/header.jpg" alt="Hao Yu">
            
              <p class="site-author-name" itemprop="name">Hao Yu</p>
              <p class="site-description motion-element" itemprop="description">Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author</p>
          </div>
          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">274</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>
        	<audio controls="controls" loop="loop" preload="auto" src="/resource/xiaomeihao.mp3">
	        </audio>
	

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yuhao0102" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:yuh18@mails.tsinghua.edu.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#信号"><span class="nav-number">1.</span> <span class="nav-text">信号</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#引言"><span class="nav-number">1.1.</span> <span class="nav-text">引言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#信号概念"><span class="nav-number">1.2.</span> <span class="nav-text">信号概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数signal"><span class="nav-number">1.3.</span> <span class="nav-text">函数signal</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#程序启动"><span class="nav-number">1.3.1.</span> <span class="nav-text">程序启动</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程创建"><span class="nav-number">1.3.2.</span> <span class="nav-text">进程创建</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#不可靠的信号"><span class="nav-number">1.4.</span> <span class="nav-text">不可靠的信号</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#中断的系统调用"><span class="nav-number">1.5.</span> <span class="nav-text">中断的系统调用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#可重入函数"><span class="nav-number">1.6.</span> <span class="nav-text">可重入函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SIGCLD语义"><span class="nav-number">1.7.</span> <span class="nav-text">SIGCLD语义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#可靠信号术语和语义"><span class="nav-number">1.8.</span> <span class="nav-text">可靠信号术语和语义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数kill和raise"><span class="nav-number">1.9.</span> <span class="nav-text">函数kill和raise</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数alarm和pause"><span class="nav-number">1.10.</span> <span class="nav-text">函数alarm和pause</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#信号集"><span class="nav-number">1.11.</span> <span class="nav-text">信号集</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数sigprocmask"><span class="nav-number">1.12.</span> <span class="nav-text">函数sigprocmask</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数sigpending"><span class="nav-number">1.13.</span> <span class="nav-text">函数sigpending</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数sigaction"><span class="nav-number">1.14.</span> <span class="nav-text">函数sigaction</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数sigsetjmp和sig1ongjmp"><span class="nav-number">1.15.</span> <span class="nav-text">函数sigsetjmp和sig1ongjmp</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数sigsuspend"><span class="nav-number">1.16.</span> <span class="nav-text">函数sigsuspend</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数abort"><span class="nav-number">1.17.</span> <span class="nav-text">函数abort</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数system"><span class="nav-number">1.18.</span> <span class="nav-text">函数system</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#system的返回值"><span class="nav-number">1.18.1.</span> <span class="nav-text">system的返回值</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数sleep、nanosleep和clock-nanosleep"><span class="nav-number">1.19.</span> <span class="nav-text">函数sleep、nanosleep和clock_nanosleep</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数sigqueue"><span class="nav-number">1.20.</span> <span class="nav-text">函数sigqueue</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#作业控制信号"><span class="nav-number">1.21.</span> <span class="nav-text">作业控制信号</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#信号名和编号"><span class="nav-number">1.22.</span> <span class="nav-text">信号名和编号</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>
  <div id="DvelopmentTarget">     
  </div>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart" aria-hidden="false"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>

  
</div>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_uv"> 
  本站访客数<span id="busuanzi_value_site_uv"></span>人次
</span>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  


  

  


  <script type="text/javascript" src="/js/src/love.js"></script>

</body>
</html>
