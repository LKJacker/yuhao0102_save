<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zn-ch">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-center-simple.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Linux,">










<meta name="description" content="进程控制进程标识每个进程都有一个非负整型表示的唯一进程ID。因为进程ID标识符总是唯一的，常将其用作其他标识符的一部分以保证其唯一性。 进程ID是可复用的。当一个进程终止后，其进程ID就成为复用的候选者。大多数UNIX系统实现延迟复用算法，使得赋予新建进程的ID不同于最近终止进程所使用的ID。这防止了将新进程误认为是使用同一ID的某个已终止的先前进程。 系统中有一些专用进程，但具体细节随实现而不同">
<meta name="keywords" content="Linux">
<meta property="og:type" content="article">
<meta property="og:title" content="UNIX高级编程 笔记3">
<meta property="og:url" content="http://yoursite.com/2021/05/24/UNIX高级编程 笔记3/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="进程控制进程标识每个进程都有一个非负整型表示的唯一进程ID。因为进程ID标识符总是唯一的，常将其用作其他标识符的一部分以保证其唯一性。 进程ID是可复用的。当一个进程终止后，其进程ID就成为复用的候选者。大多数UNIX系统实现延迟复用算法，使得赋予新建进程的ID不同于最近终止进程所使用的ID。这防止了将新进程误认为是使用同一ID的某个已终止的先前进程。 系统中有一些专用进程，但具体细节随实现而不同">
<meta property="og:locale" content="zn-ch">
<meta property="og:image" content="http://yoursite.com/img/1621849003.jpg">
<meta property="og:image" content="http://yoursite.com/img/20210524233035.png">
<meta property="og:image" content="http://yoursite.com/img/20210525002706.png">
<meta property="og:image" content="http://yoursite.com/img/1621926192.jpg">
<meta property="og:image" content="http://yoursite.com/img/1621927476.jpg">
<meta property="og:image" content="http://yoursite.com/img/20210525234012.png">
<meta property="og:updated_time" content="2021-06-01T13:24:44.591Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="UNIX高级编程 笔记3">
<meta name="twitter:description" content="进程控制进程标识每个进程都有一个非负整型表示的唯一进程ID。因为进程ID标识符总是唯一的，常将其用作其他标识符的一部分以保证其唯一性。 进程ID是可复用的。当一个进程终止后，其进程ID就成为复用的候选者。大多数UNIX系统实现延迟复用算法，使得赋予新建进程的ID不同于最近终止进程所使用的ID。这防止了将新进程误认为是使用同一ID的某个已终止的先前进程。 系统中有一些专用进程，但具体细节随实现而不同">
<meta name="twitter:image" content="http://yoursite.com/img/1621849003.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2021/05/24/UNIX高级编程 笔记3/">





  <title>UNIX高级编程 笔记3 | Hao Yu's blog</title>
  








 
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zn-ch">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hao Yu's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">The program monkey was eaten by the siege lion.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/resume.pdf" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-mybetterhalf">
          <a href="/mybetterhalf/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>
            
            mybetterhalf
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/05/24/UNIX高级编程 笔记3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">UNIX高级编程 笔记3</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-05-24T16:20:00+08:00">
                2021-05-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h1><h2 id="进程标识"><a href="#进程标识" class="headerlink" title="进程标识"></a>进程标识</h2><p>每个进程都有一个非负整型表示的唯一进程ID。因为进程ID标识符总是唯一的，常将其用作其他标识符的一部分以保证其唯一性。</p>
<p>进程ID是可复用的。当一个进程终止后，其进程ID就成为复用的候选者。大多数UNIX系统实现延迟复用算法，使得赋予新建进程的ID不同于最近终止进程所使用的ID。这防止了将新进程误认为是使用同一ID的某个已终止的先前进程。</p>
<p>系统中有一些专用进程，但具体细节随实现而不同。ID为0的进程通常是调度进程，常常被称为<strong>交换进程</strong>(swapper)。该进程是内核的一部分，它并不执行任何磁盘上的程序，因此也被称为<strong>系统进程</strong>。1通常是init进程，在自举过程结束时由内核调用。该进程的程序文件在UNIX的早期版本中是<code>/etc/init</code>，在较新版本中是<code>/sbin/init</code>。此进程负责在自举内核后启动一个UNIX系统。init通常读取与系统有关的初始化文件，并将系统引导到一个状态。init进程决不会终止。它是一个普通的用户进程，但是它以超级用户特权运行。</p>
<p>除了进程ID，每个进程还有一些其他标识符。下列函数返回这些标识符。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">pid_t</span> getpid(<span class="keyword">void</span>);</span><br><span class="line"><span class="comment">// 返回值：调用进程的进程ID</span></span><br><span class="line"><span class="keyword">pid_t</span> getppid (<span class="keyword">void</span>);</span><br><span class="line"><span class="comment">// 返回值：调用进程的父进程ID</span></span><br><span class="line"><span class="keyword">uid_t</span> getuid(<span class="keyword">void</span>);</span><br><span class="line"><span class="comment">// 返回值：调用进程的实际用户ID</span></span><br><span class="line"><span class="keyword">uid_t</span> geteuid (<span class="keyword">void</span>);</span><br><span class="line"><span class="comment">// 返回值：调用进程的有效用户ID</span></span><br><span class="line"><span class="keyword">gid_t</span> getgid(<span class="keyword">void</span>);</span><br><span class="line"><span class="comment">// 返回值：调用进程的实际组ID</span></span><br><span class="line"><span class="keyword">gid_t</span> getegid (<span class="keyword">void</span>);</span><br><span class="line"><span class="comment">// 返回值，调用进程的有效组ID</span></span><br></pre></td></tr></table></figure></p>
<p>注意，这些函数都没有出错返回。</p>
<h2 id="函数fork"><a href="#函数fork" class="headerlink" title="函数fork"></a>函数fork</h2><p>现有的进程可以调用<code>fork</code>函数创建一个新进程。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">pid_t</span> fork (<span class="keyword">void</span>);</span><br><span class="line"><span class="comment">// 返回值：子进程返回0，父进程返回子进程ID；若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>由fork创建的新进程被称为子进程(child process)。fork函数被调用一次，但返回两次。两次返回的区别是<strong>子进程的返回值是0</strong>，而父进程的返回值则是新建子进程的进程ID。将子进程ID返回给父进程的理由是：因为一个进程的子进程可以有多个，并且没有一个函数使一个进程可以获得其所有子进程的进程ID。<code>fork</code>使子进程得到返回值0的理由是：一个进程只会有一个父进程，所以子进程总是可以调用<code>getppid</code>以获得其父进程的进程ID(进程ID 0总是由内核交换进程使用，所以一个子进程的进程ID不可能为0)。</p>
<p>子进程和父进程继续执行<code>fork</code>调用之后的指令。子进程获得父进程数据空间、堆和栈的副本。注意，这是子进程所拥有的副本。父进程和子进程并不共享这些存储空间部分。父进程和子进程共享正文段。由于在<code>fork</code>之后经常跟随着<code>exec</code>，所以现在的很多实现并不执行一个父进程数据段、栈和堆的完全副本。作为替代，使用了<strong>写时复制</strong>(Copy-On-Write，COW)技术。这些区域由父进程和子进程共享，而且内核将它们的访问权限改变为只读。如果父进程和子进程中的任一个试图修改这些区域，则内核只为修改区域的那块内存制作一个副本，通常是虚拟存储系统中的一“页”。</p>
<p>Linux 3.2.0提供了另一种新进程创建函数<code>clone</code>系统调用，它允许调用者控制哪些部分由父进程和子进程共享。</p>
<p>程序演示了<code>fork</code>函数，从中可以看到子进程对变量所做的改变并不影响父进程中该变量的值。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>		globvar = <span class="number">6</span>;		<span class="comment">/* external variable in initialized data */</span></span><br><span class="line"><span class="keyword">char</span>	buf[] = <span class="string">"a write to stdout\n"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span>		var;		<span class="comment">/* automatic variable on the stack */</span></span><br><span class="line">	<span class="keyword">pid_t</span>	pid;</span><br><span class="line"></span><br><span class="line">	var = <span class="number">88</span>;</span><br><span class="line">	<span class="keyword">if</span> (write(STDOUT_FILENO, buf, <span class="keyword">sizeof</span>(buf)<span class="number">-1</span>) != <span class="keyword">sizeof</span>(buf)<span class="number">-1</span>)</span><br><span class="line">		err_sys(<span class="string">"write error"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"before fork\n"</span>);	<span class="comment">/* we don't flush stdout */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		err_sys(<span class="string">"fork error"</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;		<span class="comment">/* child */</span></span><br><span class="line">		globvar++;				<span class="comment">/* modify variables */</span></span><br><span class="line">		var++;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		sleep(<span class="number">2</span>);				<span class="comment">/* parent */</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"pid = %ld, glob = %d, var = %d\n"</span>, (<span class="keyword">long</span>)getpid(), globvar,</span><br><span class="line">	  var);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果执行此程序则得到：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out</span><br><span class="line">a write to stdout</span><br><span class="line">before fork</span><br><span class="line">pid = 430, glob = 7, var = 89    <span class="comment">#子进程的变量值改变了</span></span><br><span class="line">pid = 429, glob = 6, var = 88    <span class="comment">#父进程的变量值没有改变</span></span><br><span class="line">$ a.out &gt; temp.out</span><br><span class="line">$ cat temp.out</span><br><span class="line">a write to atdout</span><br><span class="line">before fork</span><br><span class="line">pid = 432, glob = 7, var = 89</span><br><span class="line">before fork</span><br><span class="line">pid = 431, glob = 6, var = 80</span><br></pre></td></tr></table></figure></p>
<p>一般来说，在fork之后是父进程先执行还是子进程先执行是不确定的，这取决于内核所使用的调度算法。如果要求父进程和子进程之间相互同步，则要求某种形式的进程问通信。</p>
<p>当写标准输出时，我们将buf长度减去1作为输出字节数，这是为了避免将终止null字节写出。<code>strlen</code>计算不包含终止null字节的字符串长度，而<code>sizeof</code>则计算包括终止null字节的缓冲区长度。两者之间的另一个差别是，使用<code>strlen</code>需进行一次函数调用，而对于<code>sizeof</code>而言， 因为缓冲区已用已知字符串进行初始化，其长度是固定的，所以<code>sizeof</code>是在编译时计算缓冲区长度。</p>
<p>当以交互方式运行该程序时，只得到该<code>printf</code>输出的行一次，其原因是标准输出缓冲区由换行符冲洗。但是当将标准输出重定向到一个文件时，却得到<code>printf</code>输出行两次。其原因是，在<code>fork</code>之前调用了<code>printf</code>一次，但当调用<code>fork</code>时，该行数据仍在缓冲区中，然后在将父进程数据空间复制到子进程中时，该缓冲区数据也被复制到子进程中，此时父进程和子进程各自有了带该行内容的缓冲区。在<code>exit</code>之前的第二个<code>printf</code>将其数据追加到已有的缓冲区中。当每个进程终止时，其缓冲区中的内容都被写到相应文件中。</p>
<p>在重定向父进程的标准输出时，子进程的标准输出也被重定向。实际上，<code>fork</code>的一个特性是父进程的所有打开文件描述符都被复制到子进程中。我们说“复制”是因为对每个文件描述符来说，就好像执行了<code>dup</code>函数。父进程和子进程每个相同的打开描述符共享一个文件表项。考虑下述情况，一个进程具有了个不同的打开文件，它们是标准输入、标准输出和标准错误。在从<code>fork</code>返回时，我们有了如图8-2中所示的结构。</p>
<p>重要的一点是，父进程和子进程共享同一个文件偏移量。考虑下述情况：一个进程<code>fork</code>了一个子进程，然后等待子进程终止。假定，作为普通处理的一部分，父进程和子进程都向标准输出进行写操作。如果父进程的标准输出已重定向(很可能是由shell实现的)，那么子进程写到该标准输出时，它将更新与父进程共享的该文件的偏移量。在这个例子中，当父进程等待子进程时，子进程写到标准输出：而在子进程终止后，父进程也写到标准输出上，并且知道其输出会追加在子进程所写数据之后。如果父进程和子进程不共享同一文件偏移量，要实现这种形式的交互就要困难得多，可能需要父进程显式地动作。</p>
<p><img src="/img/1621849003.jpg" alt></p>
<p>如果父进程和子进程写同一描述符指向的文件，但又没有任何形式的同步(如使父进程等待子进程)，那么它们的输出就会相互混合(假定所用的描述符是在fork之前打开的)。</p>
<p>在<code>fork</code>之后处理文件搞述符有以下两种常见的情况，</p>
<ol>
<li>父进程等待子进程完成。在这种情况下，父进程无需对其描述符做任何处理。当子进程终止后，它曾进行过读、写操作的任一共享描述符的文件偏移量已做了相应更新。</li>
<li>父进程和子进程各自执行不同的程序段。在这种情况下，在fork之后，父进程和子进程各自关闭它们不需使用的文件损述符，这样就不会干扰对方使用的文件描述符。</li>
</ol>
<p>除了打开文件之外，父进程的很多其他属性也由子进程继承，包括：</p>
<ul>
<li>实际用户ID、实际组ID、有效用户ID、有效组ID</li>
<li>附属组ID</li>
<li>进程组ID</li>
<li>会话ID</li>
<li>控制终端</li>
<li>设置用户ID标志和设置组D标志</li>
<li>当前工作目录</li>
<li>根目录</li>
<li>文件模式创建屏蔽字</li>
<li>信号屏蔽和安排</li>
<li>对任一打开文件描述符的执行时关闭(close-on-exec)标志</li>
<li>环境</li>
<li>连接的共享存储段</li>
<li>存储映像</li>
<li>资源限制</li>
</ul>
<p>父进程和子进程之间的区别具体知下。</p>
<ul>
<li>fork的返回值不同。</li>
<li>进程ID不同。</li>
<li>这两个进程的父进程ID不同：子进程的父进程ID是创建它的进程的ID，而父进程的父进程ID则不变。</li>
<li>子进程的<code>tms_utime</code>、<code>tms_stime</code>、<code>tms_cutime</code>和<code>tms_ustime</code>的值设置为0。</li>
<li>子进程不继承父进程设置的文件锁。</li>
<li>子进程的未处理闹钟被清除。</li>
<li>子进程的未处理信号集设置为空集。</li>
</ul>
<p>使fork失败的两个主要原因是：</p>
<ul>
<li>系统中已经有了太多的进程。</li>
<li>该实际用户ID的进程总数超过了系统限制。</li>
</ul>
<p>fork有以下两种用法：</p>
<ul>
<li>一个父进程希望复制自己，使父进程和子进程同时执行不同的代码段。父进程等待客户端的服务请求。当这种请求到达时，父进程调用<code>fork</code>，使子进程处理此请求。父进程则继续等待下一个服务请求。</li>
<li>一个进程要执行一个不同的程序。这对shell是常见的情况。在这种情况下，子进程从<code>fork</code>返回后立即调用<code>exec</code>。</li>
</ul>
<p>某些操作系统将<code>fork</code>之后执行<code>exec</code>组合成一个操作，称为<code>spawn</code>。Single UNIX Specification在高级实时选项组中确实包括了<code>spawn</code>接口。但是该接口并不想替换<code>fork</code>和<code>exec</code>。</p>
<h2 id="函数vfork"><a href="#函数vfork" class="headerlink" title="函数vfork"></a>函数vfork</h2><p><code>vfork</code>函数的调用序列和返回值与<code>fork</code>相同，但两者的语义不同。<code>vfork</code>函数用于创建一个新进程，而该新进程的目的是<code>exec</code>一个新程序。<code>vfork</code>与<code>fork</code>一样都创建一个子进程，但是它并不将父进程的地址空间完全复制到子进程中，因为子进程会立即调用<code>exec</code>(或<code>exit</code>)，于是也就不会引用该地址空间。不过在子进程调用<code>exec</code>或<code>exit</code>之前，它在父进程的空间中运行。如果子进程修改数据(除了用于存放<code>vfork</code>返回值的变量)、进行函数调用、或者没有调用<code>exec</code>或<code>exit</code>就返回都可能会带来未知的结果。</p>
<p><code>vfork</code>和<code>fork</code>之间的另一个区别是，<code>vfork</code>保证子进程先运行，在它调用<code>exec</code>或<code>exit</code>之后父进程才可能被调度运行，当子进程调用这两个函数中的任意一个时，父进程会恢复运行。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> globvar = <span class="number">6</span>;		<span class="comment">/* external variable in initialized data */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span>		var;		<span class="comment">/* automatic variable on the stack */</span></span><br><span class="line">	<span class="keyword">pid_t</span>	pid;</span><br><span class="line"></span><br><span class="line">	var = <span class="number">88</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"before vfork\n"</span>);	<span class="comment">/* we don't flush stdio */</span></span><br><span class="line">	<span class="keyword">if</span> ((pid = vfork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		err_sys(<span class="string">"vfork error"</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;		<span class="comment">/* child */</span></span><br><span class="line">		globvar++;				<span class="comment">/* modify parent's variables */</span></span><br><span class="line">		var++;</span><br><span class="line">		_exit(<span class="number">0</span>);				<span class="comment">/* child terminates */</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* parent continues here */</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"pid = %ld, glob = %d, var = %d\n"</span>, (<span class="keyword">long</span>)getpid(), globvar,</span><br><span class="line">	  var);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行该程序得到：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out</span><br><span class="line">betore vtork</span><br><span class="line">pid = 29039, glob = 7, var = 89</span><br></pre></td></tr></table></figure></p>
<p>子进程对变量做增1的操作，结果改变了父进程中的变量值。因为子进程在父进程的地址空间中运行，所以这并不令人惊讶。但是其作用的确与<code>fork</code>不同</p>
<h2 id="函数exit"><a href="#函数exit" class="headerlink" title="函数exit"></a>函数exit</h2><p>进程有5种正常终止及3种异常终止方式。5种正常终止方式具体如下。</p>
<ol>
<li>在<code>main</code>函数内执行return语句。</li>
<li>调用exit函数。此函数由ISO C定义，其操作包括调用各终止处理程序，然后关闭所有标准I/O流等。</li>
<li>调用<code>_exit</code>或<code>_Exit</code>函数。ISO C定义<code>_Exit</code>，其目的是为进程提供一种无需运行终止处理程序或信号处理程序而终止的方法。在UNIX系统中，<code>_Exit</code>和<code>_exit</code>是同义的。<code>_exit</code>函数由<code>exit</code>调用，它处理UNIX系统特定的细节。<code>_exit</code>是由POSIX.1说明的。</li>
<li>进程的最后一个线程在其启动例程中执行return语句。但是，该线程的返回值不用作进程的返回值。当最后一个线程从其启动例程返回时，该进程以终止状态0返回。</li>
<li>进程的最后一个线程调用<code>pthread_exit</code>函数。</li>
</ol>
<p>3种异常终止具体如下。</p>
<ol>
<li>调用<code>abort</code>。它产生SIGABRT信号。</li>
<li>当进程接收到某些信号时。信号可由进程自身、其他进程成内核产生。例如，若进程引用地址空间之外的存储单元、或者除以0，内核就会为该进程产生相应的信号。</li>
<li>最后一个线程对“取消”请求作出响应。默认情况下，“取消”以延迟方式发生：一个线程要求取消另一个线程，若干时间之后，目标线程终止。</li>
</ol>
<p>不管进程如何终止，最后都会执行内核中的同一段代码。这段代码为相应进程关闭所有打开描述符，释放它所使用的存储器等。</p>
<p>对上述任意一种终止情形，我们都希望终止进程能够通知其父进程它是如何终止的。对于3个终止函数(<code>exit</code>、<code>_exit</code>和<code>_Exit</code>)，实现这一点的方法是，将其退出状态(exitstatus)作为参数传送给函数。在异常终止情况，内核产生一个指示其异常终止原因的终止状态(termination status)。在任意一种情况下，该终止进程的父进程都能用<code>wait</code>或<code>waitpid</code>函数取得其终止状态。</p>
<p>注意，这里使用了“退出状态”和“终止状态”两个术语，以表示有所区别。在最后调用<code>exit</code>时，<strong>内核将退出状态转换成终止状态</strong>。如果子进程正常终止，则父进程可以获得子进程的退出状态。子进程将其终止状态返回给父进程。但是如果父进程在子进程之前终止，该子进程的父进程都改变为<code>init</code>进程。我们称这些进程由<code>init</code>进程收养。其操作过程大致是：在一个进程终止时，内核逐个检查所有活动进程，以判断它是否是正要终止进程的子进程，如果是，则该进程的父进程ID就更改为1(<code>init</code>进程的ID)。这种处理方法保证了每个进程有一个父进程。</p>
<p>如果子进程完全消失了，父进程在最终准备好检查子进程是否终止时是无法获取它的终止状态的。内核为每个终止子进程保存了一定量的信息，所以当终止进程的父进程调用<code>wait</code>或<code>waitpid</code>时，可以得到这些信息。这些信息至少包括进程ID、该进程的终止状态以及该进程使用的CPU时间总量。内核可以释放终止进程所使用的所有存储区，关闭其所有打开文件。在UNIX术语中，一个已经终止、但是其父进程尚未对其进行善后处理(获取终止子进程的有关信息、释放它仍占用的资源)的进程被称为<strong>僵死进程</strong>(zombie), <code>ps</code>命令将僵死进程的状态打印为Z。如果编写一个长期运行的程序，它<code>fork</code>了很多子进程，那么除非父进程等待取得子进程的终止状态，不然这些子进程终止后就会变成僵死进程。</p>
<p>由init进程收养的进程终止时会发生什么?init被编写成无论何时只要有一个子进程终止，<code>init</code>就会调用一个<code>wait</code>函数取得其终止状态。这样也就防止了在系统中塞满僵死进程。当提及“一个init的子进程”时，这指的可能是<code>init</code>直接产生的进程，也可能是其父进程已终止，由<code>init</code>收养的进程。</p>
<h2 id="函数wait和waitpid"><a href="#函数wait和waitpid" class="headerlink" title="函数wait和waitpid"></a>函数wait和waitpid</h2><p>当一个进程正常或异常终止时，内核就向其父进程发送<code>SIGCHLD</code>信号。因为子进程终止是个异步事件(这可以在父进程运行的任何时候发生)，所以这种信号也是内核向父进程发的异步通知。父进程可以选择忽略该信号，或者提供一个该信号发生时即被调用执行的函数(信号处理程序)。调用<code>wait</code>或<code>waitpid</code>的进程可能会发生：</p>
<ul>
<li>如果其所有子进程都还在运行，则阻塞。</li>
<li>如果一个子进程已终止，正等待父进程获取其终止状态，则取得该子进程的终止状态立即返回。</li>
<li>如果它没有任何子进程，则立即出错返回。</li>
</ul>
<p>如果进程由于接收到SIGCHLD信号而调用<code>wait</code>，我们期望<code>wait</code>会立即返回。但是如果在随机时间点调用<code>wait</code>，则进程可能会阻塞。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="keyword">pid_t</span> wait (<span class="keyword">int</span> *statloc);</span><br><span class="line"><span class="keyword">pid_t</span> waitpid (<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> *statioc, <span class="keyword">int</span> options);</span><br><span class="line"><span class="comment">// 两个函数返回值：若成功，返回进程ID；若出错，返回0或-1</span></span><br></pre></td></tr></table></figure></p>
<p>这两个函数的区别如下。</p>
<ul>
<li>在一个子进程终止前，<code>wait</code>使其调用者阻塞，而<code>waitpid</code>有一选项，可使调用者不阻塞。</li>
<li><code>waitpid</code>并不等待在其调用之后的第一个终止子进程，它有着千个选项，可以控制它所等待的进程。</li>
</ul>
<p>如果子进程已经终止，并且是一个僵死进程，则<code>wait</code>立即返回并取得该子进程的状态；否则<code>wait</code>使其调用者阻塞，直到一个子进程终止。如调用者阻塞而且它有多个子进程，则在其某子进程终止时，<code>wait</code>就立即返回。因为<code>wait</code>返回终止子进程的进程ID，所以它总能了解是哪一个子进程终止了。</p>
<p>这两个函数的参数<code>statloc</code>是一个整型指针。如果<code>statloc</code>不是一个空指针，则终止进程的终止状态就存放在它所指向的单元内。如果不关心终止状态，则可将该参数指定为空指针。</p>
<p>依据传统，这两个函数返回的整型状态字是由实现定义的。其中某些位表示退出状态(正常返回)，其他位则指示信号编号(异常返回)，有一位指示是否产生了core文件等。POSIX.1规定，终止状态用定义在<code>&lt;sys/wait.h&gt;</code>中的各个宏来查看。有4个互斥的宏可用来取得进程终止的原因，它们的名字都以WIF开始。基于这4个宏中哪一个值为真，就可选用其他宏来取得退出状态、信号编号等。这4个互斥的宏示于图84中。</p>
<table>
<thead>
<tr>
<th>宏</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>WIFEXITED(statu)</td>
<td>若为正常终止子进程返回的状态，则为真。对于这种情况可执行<code>WEXITSTATUS(status)</code>，获取了进程传送给<code>exit</code>或<code>exit</code>参数的低8位</td>
</tr>
<tr>
<td>WIFSIGNALED (status)</td>
<td>若为异常终止子进程返回的状态，则为真(接到一个不捕捉的信号)。对于这种情况，可执行<code>WTERMSIG(status)</code>，获取使子进程终止的信号编号。另外，有些实现定义宏<code>WCOREDUMP(statu)</code>，已产生终止进程的core文件，则它返回真</td>
</tr>
<tr>
<td>WIFSTOPPED (status)</td>
<td>若为当前智停子进程的返回的状态，则为真。对于这种情况，可执行<code>WSTOPSIG(status)</code>，获取使子进程暂停的信号编号</td>
</tr>
<tr>
<td>WIFCONTINUED (status)</td>
<td>若在作业控制暂停后已经继续的子进程返回了状态，则为真</td>
</tr>
</tbody>
</table>
<p>函数<code>pr_exit</code>使用宏以打印进程终止状态的说明。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pr_exit</span><span class="params">(<span class="keyword">int</span> status)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (WIFEXITED(status))</span><br><span class="line">		<span class="built_in">printf</span> (<span class="string">"normal termination, exit status = %d\n"</span>, WEXITSTATUS (status));</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (WIFSIGNALED (status))</span><br><span class="line">		printt(<span class="string">"abnormal termination, signal number = %d%s\n"</span>, WTERMSIG(status),</span><br><span class="line">#ifdef WCOREDUMP</span><br><span class="line">	WCOREDUMP(status) ? <span class="string">"(core file generated)"</span> : <span class="string">""</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	<span class="string">""</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (WIFSTOPPED(status))</span><br><span class="line">		printe(<span class="string">"child stopped, signal number = %d\n"</span>, WSTOPSIG(status));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>程序调用<code>pr_exit</code>函数，演示终止状态的各种值。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">pid_t</span>	pid;</span><br><span class="line">	<span class="keyword">int</span>		status;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">		err_sys(<span class="string">"fork error"</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)				<span class="comment">/* child */</span></span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (wait(&amp;status) != pid)		<span class="comment">/* wait for child */</span></span><br><span class="line">		err_sys(<span class="string">"wait error"</span>);</span><br><span class="line">	pr_exit(status);				<span class="comment">/* and print its status */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">		err_sys(<span class="string">"fork error"</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)				<span class="comment">/* child */</span></span><br><span class="line">		<span class="built_in">abort</span>();					<span class="comment">/* generates SIGABRT */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (wait(&amp;status) != pid)		<span class="comment">/* wait for child */</span></span><br><span class="line">		err_sys(<span class="string">"wait error"</span>);</span><br><span class="line">	pr_exit(status);				<span class="comment">/* and print its status */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">		err_sys(<span class="string">"fork error"</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)				<span class="comment">/* child */</span></span><br><span class="line">		status /= <span class="number">0</span>;				<span class="comment">/* divide by 0 generates SIGFPE */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (wait(&amp;status) != pid)		<span class="comment">/* wait for child */</span></span><br><span class="line">		err_sys(<span class="string">"wait error"</span>);</span><br><span class="line">	pr_exit(status);				<span class="comment">/* and print its status */</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行该程序可得：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out</span><br><span class="line">normal termination, <span class="built_in">exit</span> status = 7</span><br><span class="line">abnormal termination, signal number = 6 (core file generated)</span><br><span class="line">abnormal temination, signal number = 8 (core tile generated)</span><br></pre></td></tr></table></figure></p>
<p>现在，我们可以从<code>WTERMSIG</code>中打印信号编号。可以查看<code>&lt;signal.h&gt;</code>头文件验证<code>SIGABRT</code>的值为6，<code>SIGFPE</code>的值为8。</p>
<p>如果一个进程有几个子进程。那么只要有一个子进程终止，<code>wait</code>就返回。如果我们需要的是等待一个特定进程的函数。POSIX.1定义了<code>waitpid</code>函数以提供这种功能。对于<code>waitpid</code>函数中<code>pid</code>参数的作用解释如下，</p>
<ul>
<li><code>pid== -1</code>等待任一子进程。此种情况下，<code>waitpid</code>与<code>wait</code>等效。</li>
<li><code>pid&gt;0</code>等待进程ID与<code>pid</code>相等的子进程。</li>
<li><code>pid==0</code>等待组ID等于调用进程组ID的任一子进程。</li>
<li><code>pid&lt;-1</code>等待组ID等于<code>pid</code>绝对值的任一子进程。</li>
</ul>
<p><code>waitpid</code>函数返回终止子进程的进程ID，并将该子进程的终止状态存放在由<code>statloc</code>指向的存储单元中。对于<code>wait</code>，其唯一的出错是调用进程没有子进程(函数调用被一个信号中断时，也可能返回另一种出错)。但是对于<code>waitpid</code>，如果指定的进程或进程组不存在，或者参数<code>pid</code>指定的进程不是调用进程的子进程，都可能出错。</p>
<p><code>options</code>参数使我们能进一步控制<code>waitpid</code>的操作。此参数或者是0，或者是常量按位或运算的结果。</p>
<table>
<thead>
<tr>
<th>常量</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>WCONTINUED</td>
<td>若实现支持作业控制，那么由pid指定的任一子进程在停止后已经继续，但其状态尚未报告，则返回其状态</td>
</tr>
<tr>
<td>WNOHANG</td>
<td>若由pid指定的子进程并不是立即可用的，则waitpid不阻塞，此时其返回值为0</td>
</tr>
<tr>
<td>WUNTRACED</td>
<td>若某实现支持作业控制，而由pid指定的任一子进程已处于停止状态，并且其状态自停止以来还未报告过，则返回其状态。<code>WIFSTOPPED</code>宏确定返回值是否对应于一个停止的子进程</td>
</tr>
</tbody>
</table>
<p><code>waitpid</code>函数提供了<code>wait</code>函数没有提供的3个功能。</p>
<ol>
<li><code>waitpid</code>可等待一个特定的进程，而<code>wait</code>则返回任一终止子进程的状态。</li>
<li><code>waitpid</code>提供了一个<code>wait</code>的非阻塞版本。有时希望获取一个子进程的状态，但不想阻塞。</li>
<li><code>waitpid</code>通过<code>WUNTRACED</code>和<code>WCONTINUED</code>选项支持作业控制。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">pid_t</span>	pid;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		err_sys(<span class="string">"fork error"</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;		<span class="comment">/* first child */</span></span><br><span class="line">		<span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">			err_sys(<span class="string">"fork error"</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">0</span>);	<span class="comment">/* parent from second fork == first child */</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * We're the second child; our parent becomes init as soon</span></span><br><span class="line"><span class="comment">		 * as our real parent calls exit() in the statement above.</span></span><br><span class="line"><span class="comment">		 * Here's where we'd continue executing, knowing that when</span></span><br><span class="line"><span class="comment">		 * we're done, init will reap our status.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		sleep(<span class="number">2</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"second child, parent pid = %ld\n"</span>, (<span class="keyword">long</span>)getppid());</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (waitpid(pid, <span class="literal">NULL</span>, <span class="number">0</span>) != pid)	<span class="comment">/* wait for first child */</span></span><br><span class="line">		err_sys(<span class="string">"waitpid error"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We're the parent (the original process); we continue executing,</span></span><br><span class="line"><span class="comment">	 * knowing that we're not the parent of the second child.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二个子进程调用<code>sleep</code>以保证在打印父进程ID时第一个子进程已终止。在<code>fork</code>之后，父进程和子进程都可继续执行，并且我们无法预知哪一个会先执行。在<code>fork</code>之后，如果不使第二个子进程休眠，那么它可能比其父进程先执行，于是它打印的父进程ID将是创建它的父进程， 而不是<code>init</code>进程(进程ID 1)。</p>
<p>执行图8-8程序得到：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out</span><br><span class="line">$ second child, parent pid = 1</span><br></pre></td></tr></table></figure></p>
<p>注意，当原先的进程(也就是exec本程序的进程)终止时，shell打印其提示符，这在第二个子进程打印其父进程ID之前。</p>
<h2 id="函数waitid"><a href="#函数waitid" class="headerlink" title="函数waitid"></a>函数waitid</h2><p><code>waitid</code>函数类似于<code>waitpid</code>，但提供了更多的灵活性。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">waitid</span><span class="params">(<span class="keyword">idtype_t</span> idtype, <span class="keyword">id_t</span> id, <span class="keyword">siginfo_t</span> *infop, <span class="keyword">int</span> options)</span></span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回0；若出错：返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>与<code>waitpid</code>相似，<code>waitid</code>允许一个进程指定要等待的子进程。但它使用两个单独的参数表示要等待的子进程所属的类型，而不是将此与进程ID或进程组ID组合成一个参数。<code>id</code>参数的作用与<code>idtype</code>的值相关。该函数支持的<code>idtype</code>类型列在下表中。</p>
<table>
<thead>
<tr>
<th>常量</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>P_PID</td>
<td>等待一特定进程，id包含要等待子进程的进程ID</td>
</tr>
<tr>
<td>P_PGID</td>
<td>等待一特定进程组中的任一子进程，id包含要等待子进程的进程组ID</td>
</tr>
<tr>
<td>P_ALL</td>
<td>等待任一子进程，忽略id</td>
</tr>
</tbody>
</table>
<p><code>options</code>参数是各标志的按位或运算。这些标志指示调用者关注哪些状态变化。</p>
<table>
<thead>
<tr>
<th>常量</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>WCONTINUED</td>
<td>等待一进程，它以前曾被停止，此后又已继续，但其状态尚未报告</td>
</tr>
<tr>
<td>WEXITED</td>
<td>等特已退出的进程</td>
</tr>
<tr>
<td>WNOHANG</td>
<td>如无可用的子进程退出状态，立即返回而非阻塞</td>
</tr>
<tr>
<td>WNOWAIT</td>
<td>不破坏子进程退出状态。该子进程退出状态可由后续的wait，wastid或waitpid调用取得</td>
</tr>
<tr>
<td>WSTOPPED</td>
<td>等待一进程，它已经停止，但其状态尚未报告</td>
</tr>
</tbody>
</table>
<p><code>WCONTINUED</code>、<code>WEXITED</code>或<code>WSTOPPED</code>这3个常量之一必须在<code>options</code>参数中指定。</p>
<p><code>infop</code>参数是指向<code>siginfo</code>结构的指针。该结构包含了造成子进程状态改变有关信号的详细信息。</p>
<h2 id="函数wait3和wait4"><a href="#函数wait3和wait4" class="headerlink" title="函数wait3和wait4"></a>函数wait3和wait4</h2><p><code>wait3</code>和<code>wait4</code>两个函数提供的功能比POSIX.1函数<code>wait</code>、<code>waitpid</code>和<code>waitid</code>所提供功能的要多一个，这与附加参数有关。该参数允许内核返回由终止进程及其所有子进程使用的资源概况。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"><span class="keyword">pid_t</span> wait3(<span class="keyword">int</span> *statloc, <span class="keyword">int</span> options, struct rusage *rusage);</span><br><span class="line"><span class="keyword">pid_t</span> wait4(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> *statloc, <span class="keyword">int</span> options, struct rusage *rusage);</span><br><span class="line"><span class="comment">// 两个函数返回值：若成功，返回进程ID；若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>资源统计信息包括用户CPU时间总量、系统CPU时间总量、缺页次数、接收到信号的次数等。</p>
<h2 id="竞争条件"><a href="#竞争条件" class="headerlink" title="竞争条件"></a>竞争条件</h2><p>当多个进程都企图对共享数据进行某种处理，而最后的结果又取决于进程运行的顺序时，我们认为发生了竞争条件(race condition)。如果在<code>fork</code>之后的某种逻辑显式或隐式地依赖于在<code>fork</code>之后是父进程先运行还是子进程先运行，那么<code>fork</code>函数就会是竞争条件活跃的滋生地。</p>
<p>如果一个进程希望等待一个子进程终止，则它必须调用wait函数中的一个。如果一个进程要等待其父进程终止，则可使用下列形式的循环：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (getppid()!= <span class="number">1</span>)</span><br><span class="line">sleep(<span class="number">1</span>):</span><br></pre></td></tr></table></figure></p>
<p>这种形式的循环称为轮询(polling)，它的问题是浪费了CPU时间，因为调用者每隔1s都被唤醒，然后进行条件测试。</p>
<p>在父进程和子进程的关系中，常常出现下述情况。在<code>fork</code>之后，父进程和子进程都有一些事情要做。例如，父进程可能要用子进程ID更新日志文件中的一个记录，而子进程则可能要为父进程创建一个文件。在本例中，要求每个进程在执行完它的一套初始化操作后要通知对方，并且在继续运行之前，要等待另一方完成其初始化操作。这种情况可以用代码描述如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apse.h"</span></span></span><br><span class="line">TELLWAIT(); <span class="comment">/* set things up for TELL_XXX&amp;WAIT_XXX */</span></span><br><span class="line"><span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) </span><br><span class="line">	err_sys (<span class="string">"fork error"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;   <span class="comment">/*child*/</span></span><br><span class="line">	<span class="comment">/*child does whatever io necessary ...*/</span></span><br><span class="line">	TELL_PARENT (getppid()):</span><br><span class="line">	<span class="comment">/* tell parent we're done*/</span></span><br><span class="line">	WAIT_PARENT(); <span class="comment">/* and wait fox parent*/</span></span><br><span class="line">	<span class="comment">/* and the child continues on its way */</span></span><br><span class="line">	<span class="built_in">exit</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* parent does whatever is necessary ...*/</span></span><br><span class="line">TELL_CNILD(pid);</span><br><span class="line"><span class="comment">/* tell child we're done*/</span></span><br><span class="line">WAIT_CHILD();  <span class="comment">/* and wait for child*/</span></span><br><span class="line"><span class="comment">/* and the parent continues on its way ... */</span></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure></p>
<p>假定在头文件<code>apue.h</code>中定义了需要使用的各个变量。5个例程<code>TELLWAIT</code>、<code>TELL_PARENT</code>、<code>TELL_CHILD</code>、<code>WAIT_PARENT</code>以及<code>WAIT_ CHILD</code>可以是宏，也可以是函数。</p>
<p>程序输出两个字符串：一个由子进程输出，另一个由父进程输出。因为输出依赖于内核使这两个进程运行的顺序及每个进程运行的时间长度，所以该程序包含了一个竞争条件。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">charatatime</span><span class="params">(<span class="keyword">char</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">pid_t</span> pid;</span><br><span class="line">	<span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">		err_sys(<span class="string">"fork error"</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">		charatatime(<span class="string">"output from child\n"</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		charatatime(<span class="string">"output from parent\n"</span>);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">charatatime</span> <span class="params">(<span class="keyword">char</span> *str)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> *ptr;</span><br><span class="line">	<span class="keyword">int</span> c;</span><br><span class="line">	setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>):</span><br><span class="line">	<span class="comment">/*set unbuffered */</span></span><br><span class="line">	<span class="keyword">for</span> (ptr = str; (c = *ptr++) != <span class="number">0</span>)</span><br><span class="line">		putc(c, <span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在程序中将标准输出设置为不带缓冲的，于是每个字符输出都需调用一次write。本例的目的是使内核能尽可能多次地在两个进程之间进行切换，以便演示竞争条件。下面的实际输出说明该程序的运行结果是会改变的。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out</span><br><span class="line">ooutput from child</span><br><span class="line">utput from parent</span><br><span class="line">$ ./a.out</span><br><span class="line">ooutput from child</span><br><span class="line">utput trom parent</span><br><span class="line">$ ./a.out</span><br><span class="line">output from child</span><br><span class="line">output from parent</span><br></pre></td></tr></table></figure></p>
<p>修改程序，使其使用<code>TELL</code>和<code>WAIT</code>函数，于是形成了下边的程序。行首标以+号的行是新增加的行<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">charatatine</span><span class="params">(<span class="keyword">char</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">pid_t</span> pid;</span><br><span class="line">	TELL_WAIT();</span><br><span class="line">	<span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">		err_ays(<span class="string">"fork error"</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">		WAIT_PARENT();  <span class="comment">/* parent goes first*/</span></span><br><span class="line">		charatatime (<span class="string">"output from child\n"</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		charatatime (<span class="string">"output trom parent\n"</span>) i</span><br><span class="line">		TELL_CHILD(pid);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">exit</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">charatatime</span> <span class="params">(<span class="keyword">char</span> *str)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> *ptr;</span><br><span class="line">	<span class="keyword">int</span> c;</span><br><span class="line">	setbuf (<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="comment">/*set unbuffered*/</span></span><br><span class="line">	<span class="keyword">for</span> (ptr = str; (c = *ptr++) != <span class="number">0</span>;)</span><br><span class="line">		putc(c, <span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行此程序则能得到所预期的输出——两个进程的输出不再交叉混合。上边的程序是使父进程先运行。如果将<code>fork</code>之后的行改成：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">	charatatime (<span class="string">"output from child\n"</span>);</span><br><span class="line">	TELL_PARENT (getppid());</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	WAIT_CHILD();    <span class="comment">/*child goes first */</span></span><br><span class="line">	charatatime (<span class="string">"output from parent\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>则子进程先运行。</p>
<h2 id="函数exec"><a href="#函数exec" class="headerlink" title="函数exec"></a>函数exec</h2><p>用<code>fork</code>函数创建新的子进程后，子进程往往要调用一种<code>exec</code>函数以执行另一个程序。当进程调用一种<code>exec</code>函数时，该进程执行的程序完全替换为新程序，而新程序则从其<code>main</code>函数开始执行。因为调用<code>exec</code>并不创建新进程，所以前后的进程ID并未改变。<code>exec</code>只是用磁盘上的一个新程序替换了当前进程的正文段、数据段、堆段和栈段。</p>
<p>有7种不同的<code>exec</code>函数可供使用，它们常常被统称为<code>exec</code>函数，我们可以使用这7个函数中的任一个。这些<code>exec</code>函数使得UNIX系统进程控制原语更加完善。用<code>fork</code>可以创建新进程，用<code>exec</code>可以初始执行新的程序。<code>exit</code>函数和<code>wait</code>函数处理终止和等待终止。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execl</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">const</span> <span class="keyword">char</span> *arg0, ... <span class="comment">/* (char *)0 */</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathmame, <span class="keyword">char</span> *<span class="keyword">const</span> angv[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execle</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">const</span> <span class="keyword">char</span> *arg0, ... <span class="comment">/* (char *)0, char *const envp[] */</span> )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execve</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">char</span> *<span class="keyword">const</span> argv[], <span class="keyword">char</span> *<span class="keyword">const</span> envp[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execlp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">const</span> <span class="keyword">char</span> *arg0, ... <span class="comment">/*(char *)0*/</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execvp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">char</span> *<span class="keyword">const</span> angv[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fexecve</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *<span class="keyword">const</span> angv[], <span class="keyword">char</span> *<span class="keyword">const</span> envp[])</span></span>;</span><br><span class="line"><span class="comment">// 7个函数返回值：若出错，返回-1，若成功，不返回</span></span><br></pre></td></tr></table></figure></p>
<p>这些函数之间的第一个区别是前4个函数取路径名作为参数，后两个函数则取文件名作为参数，最后一个取文件描述符作为参数。当指定<code>flename</code>作为参数时：</p>
<ul>
<li>如果<code>filename</code>中包含<code>/</code>，则就将其视为路径名；</li>
<li>否则就按PATH环境变量，在它所指定的各目录中搜寻可执行文件。</li>
</ul>
<p><code>PATH</code>变量包含了一张目录表(称为路径前缀)，目录之间用冒号(:)分隔。例如，下列name-value环境字符串指定在4个目录中进行搜索。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PATH=/bin:/ust/bin:/usr/<span class="built_in">local</span>/bin:.</span><br></pre></td></tr></table></figure></p>
<p>最后的路径前缀<code>.</code>表示当前目录。(零长前缀也表示当前目录。在value的开始处可用<code>:</code>表示，在行中间则要用<code>::</code>表示，在行尾以<code>:</code>表示。)</p>
<p>如果<code>execlp</code>或<code>execvp</code>使用路径前缀中的一个找到了一个可执行文件，但是该文件不是由连接编辑器产生的机器可执行文件，则就认为该文件是一个shell脚本，于是试着调用<code>/bin/sh</code>，并以该    <code>filename</code>作为shell的输入。</p>
<p><code>fexecve</code>函数避免了寻找正确的可执行文件。而是依赖调用进程来完成这项工作。调用进程可以使用文件描述符验证所需要的文件并且无竞争地执行该文件。否则，拥有特权的恶意用户就可以在找到文件位置并且验证之后，但在调用进程执行该文件之前替换可执行文件(或可执行文件的部分路径)。</p>
<p>第二个区别与参数表的传递有关(l表示列表list，v表示矢量vector)。函数<code>execl</code>、<code>execlp</code>和<code>execle</code>要求将新程序的每个命令行参数都说明为一个单独的参数。这种参数表以空指针结尾。对于另外4个函数(<code>execv</code>、<code>execvp</code>、<code>execve</code>和<code>fexecve</code>)，则应先构造一个指向各参数的指针数组，然后将该数组地址作为这4个函数的参数。</p>
<p>在使用ISO C原型之前，对<code>execl</code>、<code>execle</code>和<code>execlp</code>三个函数表示命令行参数的一般方法是：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char *arg0, char *arg1, ..., char *argn, (char *)0</span><br></pre></td></tr></table></figure></p>
<p>这种语法显式地说明了最后一个命令行参数之后跟了一个空指针。如果用常量0来表示一个空指针，则必须将它强制转换为一个指针：否则它将被解释为整型参数。如果一个整型数的长度与<code>char *</code>的长度不同，那么<code>exec</code>函数的实际参数将出错。</p>
<p>最后一个区别与向新程序传递环境表相关。以e结尾的3个函数(<code>execle</code>、<code>execve</code>和<code>fexecve</code>)可以传递一个指向环境字符串指针数组的指针。其他4个函数则使用调用进程中的<code>environ</code>变量为新程序复制现有的环境。通常，一个进程允许将其环境传播给其子进程，但有时也有这种情况，进程想要为子进程指定某一个确定的环境。</p>
<p>在使用ISOC原型之前，<code>execle</code>的参数是：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *pathname, <span class="keyword">char</span> *arg0, <span class="keyword">char</span> *argn, (<span class="keyword">char</span> *)<span class="number">0</span>, <span class="keyword">char</span> *envp[]</span><br></pre></td></tr></table></figure></p>
<p>从中可见，最后一个参数是指向环境字符串的各字符指针构成的数组的指针。而在ISO C原型中，所有命令行参数、空指针和<code>envp</code>指针都用省略号(…)表示。</p>
<p>这7个<code>exec</code>函数的参数很难记忆。函数名中的字符会给我们一些帮助。字母p表示该函数取<code>flename</code>作为参数，并且用PATH环境变量寻找可执行文件。字母l表示该函数取一个参数表，它与字母v互斥。v表示该函数取一个<code>arg[]</code>矢量。最后，字母e表示该函数取<code>envp[]</code>数组，而不使用当前环境。</p>
<p>每个系统对参数表和环境表的总长度都有一个限制。这种限制是由<code>ARG_MAX</code>给出的。在POSIX.1系统中，此值至少是4096字节。当使用shell的文件名扩充功能产生一个文件名列表时，可能会受到此值的限制。例如，命令<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep getrlimit /usr/share/man/*/*</span><br></pre></td></tr></table></figure></p>
<p>在某些系统上可能产生如下形式的shell错误：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Argument list too long</span><br></pre></td></tr></table></figure></p>
<p>为了摆脱对参数表长度的限制，我们可以使用<code>xargs(1)</code>命令，将长参数表断开成几部分。</p>
<p>前面曾提及，在执行<code>exec</code>后，进程ID没有改变。但新程序从调用进程继承了的下列属性：</p>
<ul>
<li>进程ID和父进程ID</li>
<li>实际用户ID和实际组ID</li>
<li>附属组ID</li>
<li>进程组ID</li>
<li>会话ID</li>
<li>控制终端</li>
<li>闹钟尚余留的时间</li>
<li>当前工作日录</li>
<li>根目录</li>
<li>文件模式创建屏蔽字</li>
<li>文件锁</li>
<li>进程信号屏蔽</li>
<li>未处理信号</li>
<li>资源限制</li>
<li>nice值</li>
<li><code>tms_utime</code>、<code>tms_stime</code>、<code>tms_cutime</code>以及<code>tms_cstime</code>值</li>
</ul>
<p>对打开文件的处理与每个描述符的执行时关闭(close-on-exec)标志值有关。进程中每个打开描述符都有一个执行时关闭标志。若设置了此标志，则在执行<code>exec</code>时关闭该描述符；否则该描述符仍打开。除非特地用<code>fcntl</code>设置了该执行时关闭标志，否则系统的默认操作是在<code>exec</code>后仍保持这种描述符打开。</p>
<p>注意，在<code>exec</code>前后实际用户ID和实际组ID保持不变，而有效ID是否改变则取决于所执行程序文件的设置用户ID位和设置组ID位是否设置。如果新程序的设置用户ID位已设置，则有效用户ID变成程序文件所有者的ID；否则有效用户ID不变。对组ID的处理方式与此相同。</p>
<p>在很多UNIX实现中，这7个函数中只有<code>execve</code>是内核的系统调用。另外6个只是库函数，它们最终都要调用该系统调用。<br><img src="/img/20210524233035.png" alt></p>
<p>在这种安排中，库函数<code>execlp</code>和<code>execvp</code>使用PATH环境变量，查找第一个包含名为<code>filename</code>的可执行文件的路径名前缀。<code>fexecve</code>库函数使用<code>/proc</code>把文件措述符参数转换成路径名，<code>execve</code>用该路径名去执行程序。</p>
<p>程序演示了exec函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>	*env_init[] = &#123; <span class="string">"USER=unknown"</span>, <span class="string">"PATH=/tmp"</span>, <span class="literal">NULL</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">pid_t</span>	pid;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		err_sys(<span class="string">"fork error"</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;	<span class="comment">/* specify pathname, specify environment */</span></span><br><span class="line">		<span class="keyword">if</span> (execle(<span class="string">"/home/sar/bin/echoall"</span>, <span class="string">"echoall"</span>, <span class="string">"myarg1"</span>,</span><br><span class="line">				<span class="string">"MY ARG2"</span>, (<span class="keyword">char</span> *)<span class="number">0</span>, env_init) &lt; <span class="number">0</span>)</span><br><span class="line">			err_sys(<span class="string">"execle error"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (waitpid(pid, <span class="literal">NULL</span>, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">		err_sys(<span class="string">"wait error"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		err_sys(<span class="string">"fork error"</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;	<span class="comment">/* specify filename, inherit environment */</span></span><br><span class="line">		<span class="keyword">if</span> (execlp(<span class="string">"echoall"</span>, <span class="string">"echoall"</span>, <span class="string">"only 1 arg"</span>, (<span class="keyword">char</span> *)<span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">			err_sys(<span class="string">"execlp error"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在该程序中先调用<code>execle</code>，它要求一个路径名和一个特定的环境。下一个调用的是<code>execlp</code>，它用一个文件名，并将调用者的环境传送给新程序。<code>execlp</code>在这里能够工作是因为目录<code>/home/sar/bin</code>是当前路径前缀之一。注意，我们将第一个参数(新程序中的<code>argv[0]</code>)设置为路径名的文件名分量。某些shell将此参数设置为完全的路径名。这只是一个惯例。我们可将<code>argv[0]</code>设置为任何字符串。当login命令执行shell时就是这样做的。在执行shell之前，login在<code>argv[0]</code>之前加一个<code>/</code>作为前缀，这向shell指明它是作为登录shell被调用的。登录shell将执行启动配置文件(start-up profile)命令，而非登录shell则不会执行这些命令。</p>
<h2 id="更改用户ID和更改组ID"><a href="#更改用户ID和更改组ID" class="headerlink" title="更改用户ID和更改组ID"></a>更改用户ID和更改组ID</h2><p>在UNIX系统中，特权(如能改变当前日期的表示法)以及访问控制(如能否读、写一个特定文件)，是基于用户ID和组ID的。当程序需要增加特权，或需要访问当前并不允许访问的资源时，我们需要更换自己的用户ID或组ID，使得新ID具有合适的特权或访问权限。与此类似，当程序需要降低其特权或阻止对某些资源的访问时，也需要更换用户ID或组ID，新ID不具有相应特权或访问这些资源的能力。</p>
<p>一般而言，在设计应用时，我们总是试图使用最小特权(least privilege)模型。依照此模型，我们的程序应当只具有为完成给定任务所需的最小特权。</p>
<p>可以用<code>setuid</code>函数设置实际用户ID和有效用户ID。与此类似，可以用<code>setgid</code>函数设置实际组ID和有效组ID。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setuid</span><span class="params">(<span class="keyword">uid_t</span> uid)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setgid</span><span class="params">(<span class="keyword">gid_t</span> gid)</span></span>;</span><br><span class="line"><span class="comment">// 两个函数返回值，若成功，返回0，若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>关于谁能更改ID有若干规则。现在先考虑更改用户ID的规则</p>
<ol>
<li>若进程具有超级用户特权，则<code>setuid</code>函数将实际用户ID、有效用户ID以及保存的设置用户ID(saved set-user-ID)设置为uid；</li>
<li>若进程没有超级用户特权，但是<code>uid</code>等于实际用户ID或保存的设置用户ID，则<code>setuid</code>只将有效用户ID设置为uid。不更改实际用户ID和保存的设置用户ID。</li>
<li>如果上面两个条件都不满足，则errno设置为EPERM，并返回-1。</li>
</ol>
<p>在此假定<code>_POSIX_SAVED_IDS</code>为真。如果没有提供这种功能。则上面所说的关于保存的设置用户ID部分都无效。</p>
<p>关于内核所维护的3个用户ID，还要注意以下几点。</p>
<ol>
<li>只有超级用户进程可以更改实际用户ID。通常，实际用户ID是在用户登录时，由<code>login(1)</code>程序设置的，而且决不会改变它。因为<code>login</code>是一个超级用户进程，当它调用<code>setuid</code>时，设置所有3个用户ID。</li>
<li>仅当对程序文件设置了设置用户ID位时，<code>exec</code>函数才设置有效用户ID。如果设置用户ID位没有设置，<code>exec</code>函数不会改变有效用户ID，而将维持其现有值。任何时候都可以调用<code>setuid</code>，将有效用户ID设置为实际用户ID或保存的设置用户ID。自然地，不能将有效用户ID设置为任一随机值。</li>
<li>保存的设置用户ID是由<code>exec</code>复制有效用户ID而得到的。如果设置了文件的设置用户ID位。则在<code>exec</code>根据文件的用户ID设置了进程的有效用户ID以后，这个副本就被保存起来了。</li>
</ol>
<h3 id="函数setreuid和sotregid"><a href="#函数setreuid和sotregid" class="headerlink" title="函数setreuid和sotregid"></a>函数setreuid和sotregid</h3><p>历史上，BSD支持<code>setreuid</code>函数，其功能是交换实际用户ID和有效用户ID的值。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setreuid</span><span class="params">(<span class="keyword">uid_t</span> ruid, <span class="keyword">uid_t</span> exid)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setregid</span><span class="params">(<span class="keyword">gid_t</span> rgid, <span class="keyword">gid_t</span> egid)</span></span>;</span><br><span class="line"><span class="comment">// 两个函数返回值，若成功，返回0；若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>如若其中任一参数的值为-1，则表示相应的ID应当保持不变。</p>
<p>规则很简单：一个非特权用户总能交换实际用户ID和有效用户ID。这就允许一个设置用户ID程序交换成用户的普通权限，以后又可再次交换回设置用户ID权限。POSIX.1引进了保存的设置用户ID特性后，允许一个非特权用户将其有效用户ID设置为保存的设置用户ID。</p>
<h3 id="函数seteuid和sotegid"><a href="#函数seteuid和sotegid" class="headerlink" title="函数seteuid和sotegid"></a>函数seteuid和sotegid</h3><p>POSIX.1包含了两个函数<code>seteuid</code>和<code>setegid</code>。它们类似于<code>setuid</code>和<code>setgid</code>，但只更改有效用户ID和有效组ID。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">seteuid</span><span class="params">(<span class="keyword">uid_t</span> uid)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setegid</span><span class="params">(<span class="keyword">gid_t</span> gid)</span></span>;</span><br><span class="line"><span class="comment">// 两个函数返回值：若成功，返回0；若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>一个非特权用户可将其有效用户ID设置为其实际用户ID或其保存的设置用户ID。对于一个特权用户则可将有效用户ID设置为uid。 </p>
<p>图中给出了本节所述的更改3个不同用户ID的各个函数。<br><img src="/img/20210525002706.png" alt></p>
<h3 id="组ID"><a href="#组ID" class="headerlink" title="组ID"></a>组ID</h3><p>本章中所说明的一切都以类似方式适用于各个组ID。附属组ID不受<code>setgid</code>、<code>setregid</code>和<code>setegid</code>函数的影响。</p>
<p>为了说明保存的设置用户ID特性的用法，先观察一个使用该特性的程序。我们所观察的是<code>at(1)</code>程序，它用于调度将来某个时刻要运行的命令。</p>
<p>为了防止被欺骗而运行不被允许的命令或读、写没有访问权限的文件，<code>at</code>命令和最终代表用户运行命令的守护进程必须在两种特权之间切换：用户特权和守护进程特权。下面列出了其工作步骤。</p>
<ul>
<li>程序文件是由root用户拥有的， 并且其设置用户ID位已设置。当我们运行此程序时，得到下列结果：<ul>
<li>实际用户ID=我们的用户ID(未改变)</li>
<li>有效用户ID=root</li>
<li>保存的设置用户ID=root</li>
</ul>
</li>
<li><code>at</code>程序做的第一件事就是降低特权，以用户特权运行。它调用<code>setuid</code>函数把有效用户D设置为实际用户ID。此时得到：<ul>
<li>实际用户ID=我们的用户ID(未改变)</li>
<li>有效用户ID=我们的用户ID</li>
<li>保存设置用户ID=root(未改变)</li>
</ul>
</li>
<li><code>at</code>程序以我们的用户特权运行，直到它需要访问控制哪些命令即将运行，这些命令需要何时运行的配置文件时，<code>at</code>程序的特权会改变，这些文件由为用户运行命令的守护进程持有。<code>at</code>命令调用<code>setuid</code>函数把有效用户ID设为root，因为<code>setuid</code>的参数等于保存的设置用户ID，所以这种调用是许可的。现在得到：<ul>
<li>实际用户ID-我们的用户ID(未改变)</li>
<li>有效用户ID=root</li>
<li>保存的设置用户ID=root(未改变)</li>
<li>因为有效用户ID是root，文件访问是允许的。</li>
</ul>
</li>
<li>修改文件从而记录了将要运行的命令以及它们的运行时间以后，<code>at</code>命令通过调用<code>seteusid</code>，把有效用户ID设置为用户ID，降低它的特权。防止对特权的误用。此时我们可以得到：<ul>
<li>实际用户ID=我们的用户ID(未改变)</li>
<li>有效用户ID=我们的用户ID</li>
<li>保存的设置用户ID=root(来改变)</li>
</ul>
</li>
<li>守护进程开始用root特权运行，代表用户运行命令，守护进程调用<code>fork</code>，子进程调用<code>setuid</code>将它的用户ID更改至我们的用户ID。因为子进程以root特权运行，更改了所有的ID，所以<ul>
<li>实际用户ID=我们的用户ID</li>
<li>有效用户ID=我们的用户ID</li>
<li>保存的设置用户ID=我们的用户ID</li>
</ul>
</li>
</ul>
<p>现在守护进程可以安全地代表我们执行命令，因为它只能访问我们通常可以访问的文件，我们没有额外的权限。</p>
<p>以这种方式使用保存的设置用户ID，只有在需要提升特权的时候，我们通过设置程序文件的设置用户ID而得到的额外权限。然而，其他时间进程在运行时只具有普通的权限。如果进程不能在其结束部分切换回保存的设置用户ID，那么就不得不在全部运行时间都保持额外的权限(这可能会造成麻烦)。</p>
<h2 id="解释器文件"><a href="#解释器文件" class="headerlink" title="解释器文件"></a>解释器文件</h2><p>所有现今的UNIX系统都支持解释器文件(interpreter file)。这种文件是文本文件，其起始行的形式是：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! pathname [ optional-argument]</span></span><br></pre></td></tr></table></figure></p>
<p>在感叹号和pathname之间的空格是可选的。最常见的解释器文件以下列行开始：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br></pre></td></tr></table></figure></p>
<p>pathname通常是绝对路径名，对它不进行什么特殊的处理(不使用PATH进行路径搜索)。对这种文件的识别是由内核作为<code>exec</code>系统调用处理的一部分来完成的。内核使调用<code>exec</code>函数的进程实际执行的并不是该解释器文件，而是在该解释器文件第一行中pathname所指定的文件。一定要将解释器文件(文本文件，它以!开头)和解释器(由该解释器文件第一行中的pathname指定)区分开来。</p>
<p>让我们观察一个实例，从中可了解当被执行的文件是个解释器文件时，内核如何处理<code>exec</code>函数的参数及该解释器文件第一行的可选参数。程序调用<code>exec</code>执行一个解释器文件。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">pid_t</span>	pid;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		err_sys(<span class="string">"fork error"</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;			<span class="comment">/* child */</span></span><br><span class="line">		<span class="keyword">if</span> (execl(<span class="string">"/home/sar/bin/testinterp"</span>,</span><br><span class="line">				  <span class="string">"testinterp"</span>, <span class="string">"myarg1"</span>, <span class="string">"MY ARG2"</span>, (<span class="keyword">char</span> *)<span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">			err_sys(<span class="string">"execl error"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (waitpid(pid, <span class="literal">NULL</span>, <span class="number">0</span>) &lt; <span class="number">0</span>)	<span class="comment">/* parent */</span></span><br><span class="line">		err_sys(<span class="string">"waitpid error"</span>);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面先显示要被执行的该解释器文件的内容(只有一行)，接着是运行程序得到的结果。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ cat /home/max/bin/teatinterp</span><br><span class="line"><span class="comment">#!/hone/sax/bin/echoarg foo</span></span><br><span class="line"></span><br><span class="line">$ ./a.out</span><br><span class="line">argv[0]: /home/sar/bin/echoarg</span><br><span class="line">argv[1]: foo</span><br><span class="line">argv[2]: /hone/sar/bin/testinterp</span><br><span class="line">argv[3]: myarg1</span><br><span class="line">argv[4]: MY ARG2</span><br></pre></td></tr></table></figure></p>
<p>程序<code>echoarg</code>(解释器)回显每一个命令行参数。注意，当内核<code>exec</code>解释器(<code>/home/sar/bin/echoarg</code>)时，<code>argv[0]</code>是该解释器的<code>pathname</code>，<code>argv[1]</code>是解释器文件中的可选参数，其余参数是<code>pathname</code>(<code>/home/sar/bin/testinterp</code>)以及所示的程序中调用<code>execl</code>的第2个和第3个参数(<code>myarg1</code>和<code>MY ARG2</code>)。调用<code>execl</code>时的<code>argv[1]</code>和<code>argv[2]</code>已右移了两个位置。注意，内核取<code>execl</code>调用中的<code>pathname</code>而非第一个参数(<code>testinterp</code>)，因为一般而言，<code>parhname</code>包含了比第一个参数更多的信息。</p>
<p>在解释器pathname后可跟随可选参数。如果一个解释器程序支持<code>-f</code>选项，那么在<code>pathname</code>后经常使用的就是<code>f</code>。例如，可以以下列方式执行<code>awk(1)</code>程序：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk -f myfile</span><br></pre></td></tr></table></figure></p>
<p>它告诉<code>awk</code>从文件<code>myfile</code>中读<code>awk</code>程序。</p>
<p>在解释器文件中使用<code>-f</code>选项，可以写成：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/awk -f</span></span><br></pre></td></tr></table></figure></p>
<p>例如，下面展示了在<code>/usr/local/bin/awkexample</code>中的一个解释器文件程序。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/awk -f</span></span><br><span class="line"><span class="comment"># Note: on Solario, use nawk instead</span></span><br><span class="line">BEGIN &#123;</span><br><span class="line">	<span class="keyword">for</span> (i = 0; i &lt; ARGC; i ++)</span><br><span class="line">		prints <span class="string">"ARGV[%d] = %s\n"</span>, i, ARGV[i]</span><br><span class="line">	<span class="built_in">exit</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果路径前缀之一是<code>/usr/local/bin</code>。则可以用下列方式执行程序<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ awkexample file1 FILENAME2 f3</span><br><span class="line">ARGV[0] = awk</span><br><span class="line">ARGV[1] = file1</span><br><span class="line">ARGV[2] = FILENAME2</span><br><span class="line">ARGV[3] = f3</span><br></pre></td></tr></table></figure></p>
<p>执行<code>/bin/awk</code>时，其命令行参数是：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin/awk -t /usr/<span class="built_in">local</span>/bin/awkexample filel FILENAME2 f3</span><br></pre></td></tr></table></figure></p>
<p>解释器文件的路径名(<code>/usr/local/bin/awkexample</code>)被传送给解释器。因为不能期望解释器(在本例中是<code>/bin/awk</code>)会使用<code>PATH</code>变量定位该解释器文件，所以只传送其路径名中的文件名是不够的，要将解释器文件完整的路径名传送给解释器。当awk读解释器文件时，因为<code>#</code>是awk的注释字符，所以它忽略第一行。</p>
<p>由于下述理由，解释器文件是有用的：</p>
<ol>
<li>有些程序是用某种语言写的脚本，解释器文件可将这一事实隐藏起来。例如，只需使用下列命令行：<code>awkexample optional-arguments</code>，并不需要知道该程序实际上是一个<code>awk</code>脚本，否则就要<code>awk -f awkexample opriomal-arguments</code></li>
<li>解释器脚本在效率方面也提供了好处。为了运行<code>awk</code>程序，它调用<code>fork</code>、<code>exec</code>和<code>wait</code>。于是，用一个shell脚本代替解释器脚本需要更多的开销。</li>
<li>解释器脚本使我们可以使用除<code>/bin/sh</code>以外的其他shell来编写shell脚本。当<code>execlp</code>找到一个非机器可执行的可执行文件时，它总是调用<code>/bin/sh</code>来解释执行该文件。但是，用解释器脚本则可简单地写成：<code>#!/bin/csh</code></li>
</ol>
<h2 id="函数system"><a href="#函数system" class="headerlink" title="函数system"></a>函数system</h2><p>ISO C定义了<code>system</code>函数，但是其操作对系统的依赖性很强。POSIX.1包括了<code>system</code>接口，它扩展了ISO C定义，描述了<code>system</code>在POSIX.1环境中的运行行为。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">system</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *cmdstring)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>如果<code>cmdstring</code>是一个空指针，则仅当命令处理程序可用时，<code>system</code>返回非0值，这一特征可以确定在一个给定的操作系统上是否支持<code>system</code>函数。在UNIX中，<code>system</code>总是可用的。因为<code>system</code>在其实现中调用了<code>fork</code>、<code>exec</code>和<code>waitpid</code>，因此有3种返回值。</p>
<ol>
<li><code>fork</code>失败或者<code>waitpid</code>返回除EINTR之外的出错，则<code>system</code>返回-1，并且设置errno以指示错误类型。</li>
<li>如果<code>exec</code>失败(表示不能执行shell), 则其返回值如同shell执行了exit(127)一样</li>
<li>否则所有3个函数(<code>fork</code>、<code>exec</code>和<code>waitpid</code>)都成功，那么<code>system</code>的返回值是shell的终止状态，其格式已在waitpid中说明。</li>
</ol>
<p>程序是<code>system</code>函数的一种实现。它对信号没有进行处理。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>	<span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>	<span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>	<span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">system(<span class="keyword">const</span> <span class="keyword">char</span> *cmdstring)	<span class="comment">/* version without signal handling */</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">pid_t</span>	pid;</span><br><span class="line">	<span class="keyword">int</span>		status;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (cmdstring == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span>(<span class="number">1</span>);		<span class="comment">/* always a command processor with UNIX */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		status = <span class="number">-1</span>;	<span class="comment">/* probably out of processes */</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;				<span class="comment">/* child */</span></span><br><span class="line">		execl(<span class="string">"/bin/sh"</span>, <span class="string">"sh"</span>, <span class="string">"-c"</span>, cmdstring, (<span class="keyword">char</span> *)<span class="number">0</span>);</span><br><span class="line">		_exit(<span class="number">127</span>);		<span class="comment">/* execl error */</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;							<span class="comment">/* parent */</span></span><br><span class="line">		<span class="keyword">while</span> (waitpid(pid, &amp;status, <span class="number">0</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (errno != EINTR) &#123;</span><br><span class="line">				status = <span class="number">-1</span>; <span class="comment">/* error other than EINTR from waitpid() */</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>(status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>shell的<code>-c</code>选项告诉shell程序取下一个命令行参数(在这里是cmdstring)作为命令输入(而不是从标准输入或从一个给定的文件中读命令)。shell对以null字节终止的命令字符串进行语法分析，将它们分成命令行参数。传递给shell的实际命令字符串可以包含任一有效的shell命令。例如，可以用&lt;和&gt;对输入和输出重定向。</p>
<p>如果不使用shell执行此命令，而是试图由我们自己去执行它，那将相当困难。首先，我们必须用<code>execlp</code>而不是<code>execl</code>。像shell那样使用PATH变量。我们必须将null字节终止的命令字符串分成各个命令行参数，以便调用<code>execlp</code>。最后，我们也不能使用任何一个shell元字符。</p>
<p>注意，我们调用<code>_exit</code>而不是<code>exit</code>。这是为了防止任一标准I/O缓冲(这些缓冲会在<code>fork</code>中由父进程复制到子进程)在子进程中被冲洗。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span>		status;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((status = system(<span class="string">"date"</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">		err_sys(<span class="string">"system() error"</span>);</span><br><span class="line"></span><br><span class="line">	pr_exit(status);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((status = system(<span class="string">"nosuchcommand"</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">		err_sys(<span class="string">"system() error"</span>);</span><br><span class="line"></span><br><span class="line">	pr_exit(status);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((status = system(<span class="string">"who; exit 44"</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">		err_sys(<span class="string">"system() error"</span>);</span><br><span class="line"></span><br><span class="line">	pr_exit(status);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序得到：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out</span><br><span class="line">Sat Feb 25 19:36:59 EST 2012</span><br><span class="line">normal termination, <span class="built_in">exit</span> status = 0</span><br><span class="line"></span><br><span class="line">sh: nosuchcomnand: <span class="built_in">command</span> not found</span><br><span class="line">normal termination, <span class="built_in">exit</span> atatus = 127</span><br><span class="line">sar console Jan 1 14:59</span><br><span class="line">sar ttys000 Feb 7 19:08</span><br><span class="line">sar ttys001 Jan 15 15:28</span><br><span class="line">sar ttys002 Jan 15 21:50</span><br><span class="line">sar ttys003 Jan 21 16:02</span><br><span class="line">nornal termination, <span class="built_in">exit</span> status = 44</span><br></pre></td></tr></table></figure></p>
<p>使用<code>system</code>而不是直接使用<code>fork</code>和<code>exec</code>的优点是：<code>system</code>进行了所需的各种出错处理以及各种信号处理。在UNIX的早期系统中没有<code>waitpid</code>函数，于是父进程用下列形式的语句等待子进程<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ((lastpid = wait(&amp;status)) != pid &amp;&amp; lastpid != <span class="number">-1</span>) ;</span><br></pre></td></tr></table></figure></p>
<p>如果调用<code>system</code>的进程在调用它之前已经生成子进程，那么将引起问题。因为上面的while语句一直循环执行。直到由<code>system</code>产生的子进程终止才停止，如果不是用pid标识的任一子进程在pid子进程之前终止，则它们的进程ID和终止状态都被while语句丢弃。实际上，由于<code>wait</code>不能等待一个指定的进程以及其他一些原因，POSIX.1才定义了<code>waitpid</code>函数。如果不提供<code>waitpid</code>函数，<code>popen</code>和<code>pclose</code>函数也会发生同样的问题。</p>
<p>如果在一个设置用户ID程序中调用<code>system</code>，那会发生什么呢?这是一个安全性方面的漏洞，决不应当这样做。程序是一个简单程序，它只是对其命令行参数调用<code>system</code>函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span>		status;</span><br><span class="line">	<span class="keyword">if</span> (argc &lt; <span class="number">2</span>)</span><br><span class="line">		err_quit(<span class="string">"command-line argument required"</span>);</span><br><span class="line">	<span class="keyword">if</span> ((status = system(argv[<span class="number">1</span>])) &lt; <span class="number">0</span>)</span><br><span class="line">		err_sys(<span class="string">"system() error"</span>);</span><br><span class="line">	pr_exit(status);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>将此程序编译成可执行目标文件<code>tsys</code>。我们给予<code>tsys</code>程序的超级用户权限在<code>system</code>中执行了<code>fork</code>和<code>exec</code>之后仍被保持下来。有些实现通过更改<code>/bin/sh</code>，当有效用户ID与实际用户ID不匹配时，将有效用户ID设置为实际用户ID，这样可以关闭上述安全漏洞。在这些系统中，上述示例的结果就不会发生。不管调用<code>system</code>的程序设置用户ID位状态如何，都会打印出相同的有效用户ID。</p>
<p>如果一个进程正以特殊的权限(设置用户ID或设置组ID)运行，它又想生成另一个进程执行另一个程序，则它应当直接使用<code>fork</code>和<code>exec</code>，而且在<code>fork</code>之后、<code>exec</code>之前要更改回普通权限。设置用户ID或设置组ID程序决不应调用system函数。</p>
<p>这种警告的一个理由是：<code>system</code>调用shell对命令字符串进行语法分析，而shell使用IFS变量作为其输入字段分隔符。早期的shell版本在被调用时不将此变量重置为普通字符集。这就允许一个恶意的用户在调用<code>system</code>之前设置IFS，造成<code>system</code>执行一个不同的程序。</p>
<h2 id="进程会计"><a href="#进程会计" class="headerlink" title="进程会计"></a>进程会计</h2><p>大多数UNIX系统提供了一个选项以进行<strong>进程会计</strong>(process accounting)处理。启用该选项后，每当进程结束时内核就写一个会计记录。典型的会计记录包含总量较小的二进制数据，一般包括命令名、所使用的CPU时间总量、用户ID和组ID、启动时间等。</p>
<p>一个至今没有说明的函数(<code>acct</code>)启用和禁用进程会计。唯一使用这一函数的是<code>accton(8)</code>命令。超级用户执行一个带路径名参数的<code>accton</code>命令启用会计处理。会计记录写到指定的文件中，在FreeBSD和MacOSX中，该文件通常是<code>/var/account/acct</code>；在Linux中，该文件是<code>/var/account/pacct</code>；在Solaris中，该文件是<code>/var/adm/pacct</code>。执行不带任何参数的<code>accton</code>命令则停止会计处理。会计记录结构定义在头文件<code>&lt;sys/acct.h&gt;</code>中，虽然每种系统的实现各不相同，但会计记录样式基本如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> u_short <span class="keyword">comp_t</span>;</span><br><span class="line"><span class="comment">/* 3-bit base 8 exponent;13-bit fraction*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">acct</span> &#123;</span></span><br><span class="line"><span class="keyword">char</span> ac_flag;   <span class="comment">/* flag (see Figuze 8.26) */</span></span><br><span class="line"><span class="keyword">char</span> ac_stat;   <span class="comment">/* ternination status (signal 6 core tlag only) */</span></span><br><span class="line">                <span class="comment">/*(Solaris only) */</span></span><br><span class="line"><span class="keyword">usd_t</span> ac_uid;   <span class="comment">/*real user ID*/</span></span><br><span class="line"><span class="keyword">gid_t</span> ac_gid;   <span class="comment">/* real group tD*/</span></span><br><span class="line"><span class="keyword">dev_t</span> ac_tty;   <span class="comment">/*controlling texminal*/</span></span><br><span class="line"><span class="keyword">time_t</span> ac_btime;<span class="comment">/*starting calendar time*/</span></span><br><span class="line"><span class="keyword">comp_t</span> ac_utime;<span class="comment">/*user cru time*/</span></span><br><span class="line"><span class="keyword">comp_t</span> ac_stime;<span class="comment">/* aystem cru time*/</span></span><br><span class="line"><span class="keyword">comp_t</span> ac_etime;<span class="comment">/*clapsed time*/</span></span><br><span class="line"><span class="keyword">comp_t</span> ac_mem;  <span class="comment">/*average memory usage*/</span></span><br><span class="line"><span class="keyword">coap_t</span> ac_io;   <span class="comment">/* bytes transferred (by read and write) */</span></span><br><span class="line">                <span class="comment">/* "blocks" on BSD systems*/</span></span><br><span class="line"><span class="keyword">comp_t</span> ac_rw;   <span class="comment">/* blocks read or written*/</span></span><br><span class="line">                <span class="comment">/* (not present on B80 systens) */</span></span><br><span class="line"><span class="keyword">char</span> ac_comm[<span class="number">8</span>];<span class="comment">/*comand name: [8] for solaris,"</span></span><br><span class="line"><span class="comment">                /* [10] for Mac OS X, [16] for FreeBSD, and*/</span></span><br><span class="line">                <span class="comment">/* [17] for Linux*/</span></span><br></pre></td></tr></table></figure></p>
<p><code>ac_flag</code>成员记录了进程执行期间的某些事件。</p>
<table>
<thead>
<tr>
<th><code>ac_flag</code></th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>AFORK</td>
<td>进程是由<code>fork</code>产生的，但从未调用<code>exec</code></td>
</tr>
<tr>
<td>ASU</td>
<td>进程使用超级用户特权</td>
</tr>
<tr>
<td>ACORE</td>
<td>进程转储core</td>
</tr>
<tr>
<td>AXSIG</td>
<td>进程由一个信号杀死</td>
</tr>
<tr>
<td>AEXPND</td>
<td>扩展的会计条目</td>
</tr>
<tr>
<td>ANVER</td>
<td>新记录格式</td>
</tr>
</tbody>
</table>
<p>会计记录所需的各个数据(各CPU时间、传输的字符数等)都由内核保存在进程表中，并在一个新进程被创建时初始化(如fork之后在子进程中)。进程终止时写一个会计记录。这产生两个后果。</p>
<ul>
<li>第一，我们不能获取永远不终止的进程的会计记录。像<code>init</code>这样的进程在系统生命周期中一直在运行，并不产生会计记录。这也同样适合于内核守护进程，它们通常不会终止。</li>
<li>第二，在会计文件中记录的顺序对应于进程终止的顺序，而不是它们启动的顺序。为了确定启动顺序，需要读全部会计文件，并按启动日历时间进行排序。这不是一种很完善的方法，因为在一个给定的秒中可能启动了多个进程。</li>
</ul>
<p>会计记录对应于进程而不是程序。在<code>fork</code>之后，内核为子进程初始化一个记录，而不是在一个新程序被执行时初始化。虽然<code>exec</code>并不创建一个新的会计记录，但相应记录中的命令名改变了，<code>AFORK</code>标志则被消除。这意味着，如果一个进程顺序执行了3个程序，只会写一个会计记录。在该记录中的命令名对应于程序C，但CPU时间是程序A、B和C之和。</p>
<p>为了得到某些会计数据以便查看，我们编写了测试程序。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">pid_t</span>	pid;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">		err_sys(<span class="string">"fork error"</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (pid != <span class="number">0</span>) &#123;		<span class="comment">/* parent */</span></span><br><span class="line">		sleep(<span class="number">2</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">2</span>);				<span class="comment">/* terminate with exit status 2 */</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">		err_sys(<span class="string">"fork error"</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (pid != <span class="number">0</span>) &#123;		<span class="comment">/* first child */</span></span><br><span class="line">		sleep(<span class="number">4</span>);</span><br><span class="line">		<span class="built_in">abort</span>();				<span class="comment">/* terminate with core dump */</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">		err_sys(<span class="string">"fork error"</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (pid != <span class="number">0</span>) &#123;		<span class="comment">/* second child */</span></span><br><span class="line">		execl(<span class="string">"/bin/dd"</span>, <span class="string">"dd"</span>, <span class="string">"if=/etc/passwd"</span>, <span class="string">"of=/dev/null"</span>, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">7</span>);				<span class="comment">/* shouldn't get here */</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">		err_sys(<span class="string">"fork error"</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (pid != <span class="number">0</span>) &#123;		<span class="comment">/* third child */</span></span><br><span class="line">		sleep(<span class="number">8</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);				<span class="comment">/* normal exit */</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	sleep(<span class="number">6</span>);					<span class="comment">/* fourth child */</span></span><br><span class="line">	kill(getpid(), SIGKILL);	<span class="comment">/* terminate w/signal, no core dump */</span></span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">6</span>);					<span class="comment">/* shouldn't get here */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行该测试程序，然后从会计记录中选择一些字段并打印出来。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/acct.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(BSD)	<span class="comment">/* different structure in FreeBSD */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> acct acctv2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ac_flag ac_trailer.ac_flag</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FMT <span class="meta-string">"%-*.*s  e = %.0f, chars = %.0f, %c %c %c %c\n"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(HAS_AC_STAT)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FMT <span class="meta-string">"%-*.*s  e = %6ld, chars = %7ld, stat = %3u: %c %c %c %c\n"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FMT <span class="meta-string">"%-*.*s  e = %6ld, chars = %7ld, %c %c %c %c\n"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(LINUX)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> acct acct_v3	<span class="comment">/* different structure in Linux */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(HAS_ACORE)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ACORE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(HAS_AXSIG)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AXSIG 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(BSD)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span></span><br><span class="line">compt2ulong(<span class="keyword">comp_t</span> comptime)	<span class="comment">/* convert comp_t to unsigned long */</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>	val;</span><br><span class="line">	<span class="keyword">int</span>				<span class="built_in">exp</span>;</span><br><span class="line"></span><br><span class="line">	val = comptime &amp; <span class="number">0x1fff</span>;	<span class="comment">/* 13-bit fraction */</span></span><br><span class="line">	<span class="built_in">exp</span> = (comptime &gt;&gt; <span class="number">13</span>) &amp; <span class="number">7</span>;	<span class="comment">/* 3-bit exponent (0-7) */</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">exp</span>-- &gt; <span class="number">0</span>)</span><br><span class="line">		val *= <span class="number">8</span>;</span><br><span class="line">	<span class="keyword">return</span>(val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">acct</span>		<span class="title">acdata</span>;</span></span><br><span class="line">	FILE			*fp;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">		err_quit(<span class="string">"usage: pracct filename"</span>);</span><br><span class="line">	<span class="keyword">if</span> ((fp = fopen(argv[<span class="number">1</span>], <span class="string">"r"</span>)) == <span class="literal">NULL</span>)</span><br><span class="line">		err_sys(<span class="string">"can't open %s"</span>, argv[<span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">while</span> (fread(&amp;acdata, <span class="keyword">sizeof</span>(acdata), <span class="number">1</span>, fp) == <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(FMT, (<span class="keyword">int</span>)<span class="keyword">sizeof</span>(acdata.ac_comm),</span><br><span class="line">			(<span class="keyword">int</span>)<span class="keyword">sizeof</span>(acdata.ac_comm), acdata.ac_comm,</span><br><span class="line">#<span class="keyword">if</span> defined(BSD)</span><br><span class="line">			acdata.ac_etime, acdata.ac_io,</span><br><span class="line">#<span class="keyword">else</span></span><br><span class="line">			compt2ulong(acdata.ac_etime), compt2ulong(acdata.ac_io),</span><br><span class="line">#endif</span><br><span class="line">#<span class="keyword">if</span> defined(HAS_AC_STAT)</span><br><span class="line">			(<span class="keyword">unsigned</span> <span class="keyword">char</span>) acdata.ac_stat,</span><br><span class="line">#endif</span><br><span class="line">			acdata.ac_flag &amp; ACORE ? <span class="string">'D'</span> : <span class="string">' '</span>,</span><br><span class="line">			acdata.ac_flag &amp; AXSIG ? <span class="string">'X'</span> : <span class="string">' '</span>,</span><br><span class="line">			acdata.ac_flag &amp; AFORK ? <span class="string">'F'</span> : <span class="string">' '</span>,</span><br><span class="line">			acdata.ac_flag &amp; ASU   ? <span class="string">'S'</span> : <span class="string">' '</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (ferror(fp))</span><br><span class="line">		err_sys(<span class="string">"read error"</span>);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>BSD派生的平台不支持<code>ac_stat</code>成员，所以我们在支持该成员的平台上定义了<code>HAS_AC_STAT</code>常量。为了进行测试，执行下列操作步骤，</p>
<ol>
<li>成为超级用户，用<code>accton</code>命令启用会计处理。注意，当此命令结束时，会计处理已经启用，因此在会计文件中的第一个记录应来自这一命令。</li>
<li>终止超级用户shell，运行程序。这会追加6个记录到会计文件中(超级用户shell一个、父进程一个、4个子进程各一个)。在第二个子进程中，<code>execl</code>并不创建一个新进程，所以对第二个进程只有一个会计记录。</li>
<li>成为超级用户，停止会计处理。因为在<code>accton</code>命令终止时已经停止会计处理，所以不会在会计文件中增加一个记录。</li>
<li>运行程序，从会计文件中选出字段并打印。</li>
</ol>
<h2 id="用户标识"><a href="#用户标识" class="headerlink" title="用户标识"></a>用户标识</h2><p>任一进程都可以得到其实际用户ID和有效用户ID及组ID。但是，我们有时希望找到运行该程序用户的登录名。我们可以调用<code>getpwuid(getuid())</code>，但是如果一个用户有多个登录名，这些登录名又对应着同一个用户ID，又将如何呢? 系统通常记录用户登录时使用的名字，用<code>getlogin</code>函数可以获取此登录名<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">getlogin</span> <span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回指向登录名字符串的指针，若出错，返回NULL</span></span><br></pre></td></tr></table></figure></p>
<p>如果调用此函数的进程没有连接到用户登录时所用的终端，则函数会失败。通常称这些进程为守护进程(daemon)。给出了登录名，就可用<code>getpwnam</code>在口令文件中查找用户的相应记录，从而确定其登录shell等。</p>
<h2 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h2><p>UNIX系统历史上对进程提供的只是基于调度优先级的粗粒度的控制。调度策略和调度优先级是由内核确定的。进程可以通过调整<code>nice</code>值选择以更低优先缓运行(通过调整<code>nice</code>值降低它对CPU的占有，因此该进程是“友好的”)。只有特权进程允许提高调度权限。POSIX实时扩展增加了在多个调度类别中选择的核口以进一步细调行为。</p>
<p>Single UNIX Specification 中<code>nice</code>值的范围在<code>0~(2*NZERO)-1</code>之间，有些实现支持<code>0~2*NZERO</code>。<code>nice</code>值越小，优先级越高。虽然这看起来有点倒退，但实际上是有道理的：你越友好，你的调度优先级就越低。<code>NZERO</code>是系统默认的<code>nice</code>值。</p>
<p>注意，定义<code>NZERO</code>的头文件因系统而异。除了头文件以外，Linux3.2.0可以通过非标准的<code>sysconf</code>参数(<code>_SC_NZERO</code>)来访问<code>NZERO</code>的值。</p>
<p>进程可以通过<code>nice</code>函数获取或更改它的<code>nice</code>值。使用这个函数，进程只能影响自己的<code>nice</code>值，不能影响任何其他进程的<code>nice</code>值。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nice</span><span class="params">(<span class="keyword">int</span> incr)</span></span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回新的nice值NZERO；若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p><code>incr</code>参数被增加到调用进程的<code>nice</code>值上。如果<code>incr</code>太大，系统直接把它降到最大合法值，不给出提示。类似地，如果<code>incr</code>太小，系统也会无声息地把它提高到最小合法值。由于-1是合法的成功返回值，在调用<code>nice</code>函数之前需要清楚<code>errno</code>，在<code>nice</code>函数返回-1时，需要检查它的值。如果<code>nice</code>调用成功，并且返回值为-1，那么<code>errno</code>仍然为0。如果<code>errno</code>不为0，说明<code>nice</code>调用失败。</p>
<p><code>getpriority</code>函数可以像<code>nice</code>函数那样用于获取进程的<code>nice</code>值，但是<code>getpriority</code>还可以获取一组相关进程的<code>nice</code>值<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getpriority</span><span class="params">(<span class="keyword">int</span> which, <span class="keyword">id_t</span> who)</span></span>;</span><br><span class="line"><span class="comment">// 返回值：若成功。返回-NZERO~NZERO-1之间的nice值；若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p><code>which</code>参数可以取以下三个值之一：<code>PRIO_PROCESS</code>表示进程，<code>PRIO_PGRP</code>表示进程组，<code>PRIO_USER</code>表示用户ID，<code>which</code>参数控制<code>who</code>参数是如何解释的，<code>who</code>参数选择感兴趣的一个或多个进程。如果<code>who</code>参数为0，表示调用进程、进程组或者用户(取决于<code>which</code>参数的值)。当<code>which</code>设为<code>PRIO_USER</code>并且<code>who</code>为0时，使用调用进程的实际用户ID。如果<code>which</code>参数作用于多个进程，则返回所有作用进程中优先级最高的(最小的<code>nice</code>值)。</p>
<p><code>setpriority</code>函数可用于为进程、进程组和属于特定用户ID的所有进程设置优先级。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setpriority</span><span class="params">(<span class="keyword">int</span> which, <span class="keyword">id_t</span> who, <span class="keyword">int</span> value)</span></span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回0；若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>参数<code>which</code>和<code>who</code>与<code>getpriority</code>函数中相同。<code>value</code>增加到<code>NZERO</code>上，然后变为新的<code>nice</code>值。</p>
<p>程序度最了调整进程<code>nice</code>值的效果。两个进程并行运行，各自增加自己的计数器。父进程使用了默认的<code>nice</code>值，子进程以可选命令参数指定的调整后的<code>nice</code>值运行。运行10s后，两个进程都打印各自的计数值并终止。通过比较不同<code>nice</code>值的进程的计数值的差异，我们可以了解<code>nice</code>值时如何影响进程调度的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(MACOS)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syslimits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(SOLARIS)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(BSD)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/param.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> count;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">end</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">checktime(<span class="keyword">char</span> *str)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timeval</span>	<span class="title">tv</span>;</span></span><br><span class="line"></span><br><span class="line">	gettimeofday(&amp;tv, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (tv.tv_sec &gt;= end.tv_sec &amp;&amp; tv.tv_usec &gt;= end.tv_usec) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%s count = %lld\n"</span>, str, count);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">pid_t</span>	pid;</span><br><span class="line">	<span class="keyword">char</span>	*s;</span><br><span class="line">	<span class="keyword">int</span>		nzero, ret;</span><br><span class="line">	<span class="keyword">int</span>		adj = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(NZERO)</span></span><br><span class="line">	nzero = NZERO;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(_SC_NZERO)</span></span><br><span class="line">	nzero = sysconf(_SC_NZERO);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">error</span> NZERO undefined</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"NZERO = %d\n"</span>, nzero);</span><br><span class="line">	<span class="keyword">if</span> (argc == <span class="number">2</span>)</span><br><span class="line">		adj = strtol(argv[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">10</span>);</span><br><span class="line">	gettimeofday(&amp;end, <span class="literal">NULL</span>);</span><br><span class="line">	end.tv_sec += <span class="number">10</span>;	<span class="comment">/* run for 10 seconds */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		err_sys(<span class="string">"fork failed"</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;	<span class="comment">/* child */</span></span><br><span class="line">		s = <span class="string">"child"</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"current nice value in child is %d, adjusting by %d\n"</span>,</span><br><span class="line">		  nice(<span class="number">0</span>)+nzero, adj);</span><br><span class="line">		errno = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> ((ret = nice(adj)) == <span class="number">-1</span> &amp;&amp; errno != <span class="number">0</span>)</span><br><span class="line">			err_sys(<span class="string">"child set scheduling priority"</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"now child nice value is %d\n"</span>, ret+nzero);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;		<span class="comment">/* parent */</span></span><br><span class="line">		s = <span class="string">"parent"</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"current nice value in parent is %d\n"</span>, nice(<span class="number">0</span>)+nzero);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(;;) &#123;</span><br><span class="line">		<span class="keyword">if</span> (++count == <span class="number">0</span>)</span><br><span class="line">			err_quit(<span class="string">"%s counter wrap"</span>, s);</span><br><span class="line">		checktime(s);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>执行该程序两次：一次用默认的<code>nice</code>值，另一次用最高有效<code>nice</code>值(最低调度优先级)。程序运行在单处理器Linux系统上，以显示调度程序如何在不同nice值的进程间进行CPU的共享。否则，对于有空闲资源的系统，如多处理器系统(或多核CPU)，两个进程可能无需共享CPU(运行在不同的处理器上)，就无法看出具有不同nice值的两个进程的差异。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out</span><br><span class="line">NZERO 20</span><br><span class="line">current nice value <span class="keyword">in</span> parent 10 20</span><br><span class="line">current nice value <span class="keyword">in</span> child is 20, adjusting by 0</span><br><span class="line">now child nice value is 20</span><br><span class="line">child count = 1859362</span><br><span class="line">parent count = 1845338</span><br><span class="line">$ ./a.out 20</span><br><span class="line">NZERO = 20</span><br><span class="line">current nice value <span class="keyword">in</span> parent is 20</span><br><span class="line">current nice vaiue <span class="keyword">in</span> child is 20, adjuating by 20</span><br><span class="line">now child nice value is 39</span><br><span class="line">parent count = 3595709</span><br><span class="line">child count = 52111</span><br></pre></td></tr></table></figure></p>
<p>当两个进程的<code>nice</code>值相同时，父进程占用50.2%的CPU，子进程占用49.8%的CPU。可以看到，两个进程被有效地进行了平等对待。相比之下，当子进程有最高可能nice值(最低优先级)时，我们看到父进程占用98.5%的CPU，而子进程只占用1.5%的CPU。这些值取决于进程调度程序如何使用nice值。因此不同的UNIX系统会产生不同的CPU占用比。</p>
<h2 id="进程时间"><a href="#进程时间" class="headerlink" title="进程时间"></a>进程时间</h2><p>我们可以度量3个时间：墙上时钟时间、用户CPU时间和系统CPU时间。任一进程都可调用<code>times</code>函数获得它自己以及已终止子进程的上述值。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/times.h&gt;</span></span></span><br><span class="line"><span class="keyword">clock_t</span> times (struct tms *buf));</span><br><span class="line"><span class="comment">// 返回值：若成功，返回流逝的墙上时钟时间，若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>此函数填写由<code>buf</code>指向的<code>tms</code>结构，该结构定义如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tms</span> &#123;</span></span><br><span class="line">	<span class="keyword">clock_t</span> tms_utime; 	<span class="comment">/* user cpu time */</span></span><br><span class="line">	<span class="keyword">clock_t</span> tms_stime;  <span class="comment">/* system CPU time */</span></span><br><span class="line">	<span class="keyword">clock_t</span> tms_cutime; <span class="comment">/* user cru time, terninated children */</span></span><br><span class="line">	<span class="keyword">clock_t</span> tms_cstime; <span class="comment">/* aystem CPU time, terminated children */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意，此结构没有包含墙上时钟时间。<code>times</code>函数返回墙上时钟时间作为其函数值。此值是相对于过去的某一时刻度量的，所以不能用其绝对值而必须使用其相对值。所有由此函数返回的<code>clock_t</code>值都用<code>_SC_CLK_TCK</code>(由sysconf函数返回的每秒时钟滴答数)转换成秒数。</p>
<p>程序将每个命令行参数作为shell命令串执行，对每个命令计时，并打印从<code>tms</code>结构取得的值。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/times.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>	<span class="title">pr_times</span><span class="params">(<span class="keyword">clock_t</span>, struct tms *, struct tms *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>	<span class="title">do_cmd</span><span class="params">(<span class="keyword">char</span> *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span>		i;</span><br><span class="line"></span><br><span class="line">	setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; argc; i++)</span><br><span class="line">		do_cmd(argv[i]);	<span class="comment">/* once for each command-line arg */</span></span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">do_cmd(<span class="keyword">char</span> *cmd)		<span class="comment">/* execute and time the "cmd" */</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tms</span>	<span class="title">tmsstart</span>, <span class="title">tmsend</span>;</span></span><br><span class="line">	<span class="keyword">clock_t</span>		start, end;</span><br><span class="line">	<span class="keyword">int</span>			status;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\ncommand: %s\n"</span>, cmd);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((start = times(&amp;tmsstart)) == <span class="number">-1</span>)	<span class="comment">/* starting values */</span></span><br><span class="line">		err_sys(<span class="string">"times error"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((status = system(cmd)) &lt; <span class="number">0</span>)			<span class="comment">/* execute command */</span></span><br><span class="line">		err_sys(<span class="string">"system() error"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((end = times(&amp;tmsend)) == <span class="number">-1</span>)		<span class="comment">/* ending values */</span></span><br><span class="line">		err_sys(<span class="string">"times error"</span>);</span><br><span class="line"></span><br><span class="line">	pr_times(end-start, &amp;tmsstart, &amp;tmsend);</span><br><span class="line">	pr_exit(status);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">pr_times(<span class="keyword">clock_t</span> real, struct tms *tmsstart, struct tms *tmsend)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">long</span>		clktck = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (clktck == <span class="number">0</span>)	<span class="comment">/* fetch clock ticks per second first time */</span></span><br><span class="line">		<span class="keyword">if</span> ((clktck = sysconf(_SC_CLK_TCK)) &lt; <span class="number">0</span>)</span><br><span class="line">			err_sys(<span class="string">"sysconf error"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"  real:  %7.2f\n"</span>, real / (<span class="keyword">double</span>) clktck);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"  user:  %7.2f\n"</span>,</span><br><span class="line">	  (tmsend-&gt;tms_utime - tmsstart-&gt;tms_utime) / (<span class="keyword">double</span>) clktck);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"  sys:   %7.2f\n"</span>,</span><br><span class="line">	  (tmsend-&gt;tms_stime - tmsstart-&gt;tms_stime) / (<span class="keyword">double</span>) clktck);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"  child user:  %7.2f\n"</span>,</span><br><span class="line">	  (tmsend-&gt;tms_cutime - tmsstart-&gt;tms_cutime) / (<span class="keyword">double</span>) clktck);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"  child sys:   %7.2f\n"</span>,</span><br><span class="line">	  (tmsend-&gt;tms_cstime - tmsstart-&gt;tms_cstime) / (<span class="keyword">double</span>) clktck);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="进程关系"><a href="#进程关系" class="headerlink" title="进程关系"></a>进程关系</h1><h2 id="终端登录"><a href="#终端登录" class="headerlink" title="终端登录"></a>终端登录</h2><p>当系统自举时，内核创建进程ID为1的进程，也就是<code>init</code>进程。<code>init</code>进程使系统进入多用户模式。<code>init</code>读取文件<code>/etc/ttys</code>，对每一个允许登录的终端设备，<code>init</code>调用一次<code>fork</code>，它所生成的子进程则<code>exec getty</code>程序。</p>
<p><code>getty</code>对终端设备调用<code>open</code>函数，以读、写方式将终端打开。<code>getty</code>输出“login:”之类的信息，并等待用户键入用户名。如果终端支持多种速度，则<code>getty</code>可以测试特殊字符以便适当地更改终端速度。当用户键入了用户名后，<code>getty</code>的工作就完成了。然后它以类似于下列的方式调用<code>login</code>程序：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execle(<span class="string">"/bin/login"</span>, <span class="string">"login"</span>, <span class="string">"-p"</span>, username, (char *)0, envp);</span><br></pre></td></tr></table></figure></p>
<p><code>init</code>以一个空环境调用<code>getty</code>，<code>getty</code>以终端名和在<code>gettytab</code>中说明的环境字符串为<code>login</code>创建一个环境(<code>envp</code>参数)。<code>-p</code>标志通知<code>login</code>保留传递给它的环境，也可将其他环境字符串加到该环境中，但是不要替换它。图9-2显示了<code>login</code>刚被调用后这些进程的状态。<br><img src="/img/1621926192.jpg" alt></p>
<p>因为最初的init进程具有超级用户特权，所以图9-2中的所有进程都有超级用户特权。图9.2中底部3个进程的进程ID相同，因为进程ID不会因执行exec而改变。并且，除了最初的<code>init</code>进程，所有进程的父进程ID均为1，<code>login</code>能处理多项工作。因为它得到了用户名，所以能调用<code>getpwnam</code>取得相应用户的口令文件登录项。然后调用<code>getpass(3)</code>以显示提示“Password:”，接着读用户键入的口令。它调用<code>crypt(3)</code>将用户键入的口令加密，并与该用户在阴影口令文件中登录项的<code>pw_passwd</code>字段相比较。</p>
<p>如果用户正确登录，login就将完成如下工作。</p>
<ul>
<li>将当前工作目录更改为该用户的起始目录(chdir)。</li>
<li>调用<code>chown</code>更改该终端的所有权，使登录用户成为它的所有者。</li>
<li>将对该终端设备的访问权限改变成“用户读和写”。</li>
<li>调用<code>setgid</code>及<code>initgroups</code>设置进程的组ID。</li>
<li>用login得到的所有信息初始化环境：起始目录(HOME)、shell(SHELL)、用户名(USER和LOGNAME)以及一个系统默认路径(PATH)。</li>
</ul>
<p><code>login</code>进程更改为登录用户的用户ID(setuid)并调用该用户的登录shell，其方式类似于：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execl(<span class="string">"/bin/sh"</span>, <span class="string">"-sh"</span>, (char *)0);</span><br></pre></td></tr></table></figure></p>
<p><code>argv[0]</code>的第一个字符负号是一个标志，表示该shell被作为登录shell调用。shell可以查看此字符，并相应地修改其启动过程。</p>
<h2 id="进程组"><a href="#进程组" class="headerlink" title="进程组"></a>进程组</h2><p>每个进程除了有一进程ID之外，还属于一个进程组。进程组是一个或多个进程的集合。通常，它们是在同一作业中结合起来的，同一进程组中的各进程接收来自同一终端的各种信号。每个进程组有一个唯一的进程组ID。进程组ID类似于进程ID一它是一个正整数，并可存放在<code>pid_t</code>数据类型中。函数<code>getpgrp</code>返回调用进程的进程组ID。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">pid_t</span> getpgrp(<span class="keyword">void</span>);</span><br><span class="line"><span class="comment">// 返回值：调用进程的进程组ID</span></span><br></pre></td></tr></table></figure></p>
<p>每个进程组有一个组长进程。组长进程的进程组ID等于其进程ID。进程组组长可以创建一个进程组、创建该组中的进程，然后终止。只要在某个进程组中有一个进程存在，则该进程组就存在，这与其组长进程是否终止无关。从进程组创建开始到其中最后一个进程离开为止的时间区间称为进程组的生命期。某个进程组中的最后一个进程可以终止，也可以转移到另一个进程组。</p>
<p>进程调用<code>setpgid</code>可以加入一个现有的进程组成者创建一个新进程组。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setpgid</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">pid_t</span> pgid)</span></span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回0；若出错：返回-1</span></span><br></pre></td></tr></table></figure></p>
<p><code>setpgid</code>函数将<code>pid</code>进程的进程组ID设置为<code>pgid</code>。如果这两个参数相等，则由<code>pid</code>指定的进程变成进程组组长。如果<code>pid</code>是0，则使用调用者的进程ID。另外，如果<code>pgid</code>是0，则由<code>pid</code>指定的进程ID用作进程组ID。</p>
<p>一个进程只能为它自己或它的子进程设置进程组ID。在它的子进程调用了<code>exec</code>后，它就不再更改该子进程的进程组ID。</p>
<p>在大多数作业控制shell中，在fork之后调用此函数，使父进程设置其子进程的进程组ID，并且也使子进程设置其自己的进程组ID。这两个调用中有一个是冗余的，但让父进程和子进程都这样做可以保证，在父进程和子进程认为子进程已进入了该进程组之前，这确实已经发生了。如果不这样做，在<code>fork</code>之后，由于父进程和子进程运行的先后次序不确定，会因为子进程的组员身份取决于哪个进程首先执行而产生竞争条件。</p>
<h2 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h2><p>会话(session)是一个或多个进程组的集合。<br><img src="/img/1621927476.jpg" alt></p>
<p>通常是由shell的管道将几个进程编成一组的。例如，图9-6中的安排可能是由下列形式的shell命令形成的：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">proc1 | proc2 &amp;</span><br><span class="line">proc3 | proc4 | proc5</span><br></pre></td></tr></table></figure></p>
<p>进程调用<code>setsid</code>函数建立一个新会话。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">pid_t</span> setsid (<span class="keyword">void</span>);</span><br><span class="line"><span class="comment">// 返回值：若成功，返回进程组ID：若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>如果调用此函数的进程不是一个进程组的组长，则此函数创建一个新会话。具体会发生以下3件事。</p>
<ol>
<li>该进程变成新会话的会话首进程(session leader，会话首进程是创建该会话的进程)。此时，该进程是新会话中的唯一进程。</li>
<li>该进程成为一个新进程组的组长进程。新进程组ID是该调用进程的进程ID。</li>
<li>该进程没有控制终端。如果在调用<code>setsid</code>之前该进程有一个控制终端，那么这种联系也被切断。</li>
</ol>
<p>如果该调用进程已经是一个进程组的组长，则此函数返回出错。为了保证不处于这种情况，通常先调用<code>fork</code>，然后使其父进程终止，而子进程则继续。因为子进程继承了父进程的进程组ID，而其进程ID则是新分配的，两者不可能相等，这就保证了子进程不是一个进程组的组长。Single UNIX Specification只说明了会话首进程，而没有类似于进程ID和进程组ID的会话ID。显然，会话首进程是具有唯一进程ID的单个进程，所以可以将会话首进程的进程ID视为会话ID。会话ID这一概念是由SVR4引入的。<code>getsid</code>函数返回会话首进程的进程组ID。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">pid_t</span> getsid (<span class="keyword">pid_t</span> pid);</span><br><span class="line"><span class="comment">// 返回值：若成功，返回会话首进程的进程组ID；若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>如若<code>pid</code>是0，<code>getsid</code>返回调用进程的会话首进程的进程组ID。出于安全方面的考虑，一些实现有如下限制：如若<code>pid</code>并不属于调用者所在的会话，那么调用进程就不能得到该会话首进程的进程组ID。</p>
<p>P245</p>
<h2 id="控制终端"><a href="#控制终端" class="headerlink" title="控制终端"></a>控制终端</h2><p>会话和进程组还有一些其他特性。</p>
<ul>
<li>一个会话可以有一个控制终端(controlling terminal)。这通常是终端设备(在终端登录情况下)或伪终端设备(在网络登录情况下)。</li>
<li>建立与控制终端连接的会话首进程被称为控制进程(controlling process)。</li>
<li>一个会话中的几个进程组可被分成一个前台进程组(foreground process group)以及一个或多个后台进程组(background process group)。</li>
<li>如果一个会话有一个控制终端，则它有一个前台进程组，其他进程组为后台进程组。</li>
<li>无论何时健入终端的中断键(常常是Delete或Ctrl+C)，都会将中断信号发送至前台进程组的所有进程。</li>
<li>无论何时键入终端的退出键(常常是Crtl+<code>\</code>)，都会将退出信号发送至前台进程组的所有进程。</li>
<li>如果终端接口检测到调制解调器(或网络)已经断开连接，则将挂断信号发送至控制进程(会话首进程)。</li>
</ul>
<p><img src="/img/20210525234012.png" alt></p>
<p>通常，我们不必担心控制终端，登录时，将自动建立控制终端。</p>
<p>有时不管标准输入、标准输出是否重定向，程序都要与控制终端交互作用。保证程序能与控制终端对话的方法是open文件<code>/dev/tty</code>。在内核中，此特殊文件是控制终端的同义语。自然地，如果程序没有控制终端，则对于此设备的open将失败。</p>
<h2 id="函数tcgetpgrp、tcsetpgrp和tcgetsid"><a href="#函数tcgetpgrp、tcsetpgrp和tcgetsid" class="headerlink" title="函数tcgetpgrp、tcsetpgrp和tcgetsid"></a>函数tcgetpgrp、tcsetpgrp和tcgetsid</h2><p>需要有一种方法来通知内核哪一个进程组是前台进程组，这样，终端设备驱动程序就能知道将终端输入和终端产生的信号发送到何处。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">pid_t</span> tcgetpgrp(<span class="keyword">int</span> fd);</span><br><span class="line"><span class="comment">// 返回值：若成功，返回前台进程组ID；若出错，返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tcsetpqrp</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">pid_t</span> psrpid)</span></span>;</span><br><span class="line"><span class="comment">// 返回值，若成功，返回0，若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>函数<code>tcgetpgrp</code>返回前台进程组ID，它与在fd上打开的终端相关联。如果进程有一个控制终端，则该进程可以调用<code>tcsetpgrp</code>将前台进程组ID设置为<code>pgrpid</code>。<code>pgrpid</code>值应当是在同一会话中的一个进程组的ID。fd必须引用该会话的控制终端。大多数应用程序并不直接调用这两个函数。它们通常由作业控制shell调用。</p>
<p>给出控制TTY的文件描述符，通过<code>tcgetsid</code>函数，应用程序就能获得会话首进程的进程组ID。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;termios.h&gt;</span></span></span><br><span class="line"><span class="keyword">pid_t</span> tcgetsid(<span class="keyword">int</span> fd);</span><br><span class="line"><span class="comment">// 返回值：若成功，返回会话首进程的进程组ID，若出错：返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>需要管理控制终端的应用程序可以调用<code>tcgetsid</code>函数识别出控制终端的会话首进程的会话ID(它等价于会话首进程的进程组ID)。</p>
<h1 id="作业控制"><a href="#作业控制" class="headerlink" title="作业控制"></a>作业控制</h1><p>作业控制允许在一个终端上启动多个作业(进程组)，它控制哪一个作业可以访问该终端以及哪些作业在后台运行。作业控制要求以下3种形式的支持。</p>
<ol>
<li>支持作业控制的shell。</li>
<li>内核中的终端驱动程序必须支持作业控制。</li>
<li>内核必须提供对某些作业控制信号的支持。</li>
</ol>
<p>从shell使用作业控制功能的角度观察，用户可以在前台或后台启动一个作业。一个作业只是几个进程的集合，通常是一个进程管道。例如：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi main.c</span><br></pre></td></tr></table></figure></p>
<p>在前台启动了只有一个进程组成的作业。下面的命令;<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pr *.c | lpr &amp;</span><br><span class="line">make all &amp;</span><br></pre></td></tr></table></figure></p>
<p>在后台启动了两个作业。这两个后台作业调用的所有进程都在后台运行。</p>
<p>当启动一个后台作业时，shell赋予它一个作业标识符，并打印一个或多个进程ID。下面的脚本显示了Kornshell是如何处理这一点的。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ make all &gt; Make.out a</span><br><span class="line">[1] 1475</span><br><span class="line">$ pr *.c | lpr &amp;</span><br><span class="line">[2] 1490</span><br><span class="line">$ 键入回车</span><br><span class="line">[2] + Done   pr *.c | lpr &amp;</span><br><span class="line">[1] + Done   make all &gt; Make.out &amp;</span><br></pre></td></tr></table></figure></p>
<p><code>make</code>是作业编号1，所启动的进程ID是1475。下一个管道是作业编号2。其第一个进程的进程ID是1490，当作业完成而且键入回车时，shell通知作业已经完成。键入回车是为了让shell打印其提示符，shell并不在任意时刻打印后台作业的状态改变——它只在打印其提示符让用户输入新的命令行之前才这样做。如果不这样处理，则当我们正输入一行时，它也可能输出，于是，就会引起混乱。</p>
<p>我们可以键入一个影响前台作业的特殊字符一挂起键(通常采用Ctrl+Z)，与终端驱动程序进行交互作用。键入此字符使终端驱动程序将信号SIGTSTP发送至前台进程组中的所有进程，后台进程组作业则不受影响。实际上有3个特殊字符可使终端驱动程序产生信号，并将它们发送至前台进程组，它们是：</p>
<ul>
<li>中断字符(一般采用Delete或Ctrl+C)产生<code>SIGINT</code>。</li>
<li>退出字符(一般采用Ctrl+<code>\</code>)产生<code>SIGQUIT</code>。</li>
<li>挂起字符(一般采用Ctrl+Z)产生<code>SIGTSTP</code>。</li>
</ul>
<p>终端驱动程序必须处理与作业控制有关的另一种情况。我们可以有一个前台作业，若干个后台作业，这些作业中哪一个接收我们在终端上键入的字符呢?只有前台作业接收终端输入。如果后台作业试图读终端，这并不是一个错误，但是终端驱动程序将检测这种情况，并且向后台作业发送信号SIGTTIN。该信号通常会停止此后台作业，而shell则向有关用户发出这种情况的通知，然后用户就可用shell命令将此作业转为前台作业运行，于是它就可读终端。</p>
<h2 id="shell执行程序"><a href="#shell执行程序" class="headerlink" title="shell执行程序"></a>shell执行程序</h2><p>让我们检验一下shell是如何执行程序的，以及这与进程组、控制终端和会话等概念的关系。为此，再次使用<code>ps</code>命令。</p>
<p>首先使用不支持作业控制的、在Solaris上运行的经典Bourne shell。如果执行：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -o pid,ppid,prid,sid,comm</span><br></pre></td></tr></table></figure></p>
<p>则其输出可能是：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PID PPID PGID BID COMMAND</span><br><span class="line">949  947  949 949 sh</span><br><span class="line">1774 949  949 949 ps</span><br></pre></td></tr></table></figure></p>
<p><code>ps</code>的父进程是shell，这正是我们所期望的，shell和<code>ps</code>命令两者位于同一会话和前台进程组(949)中。因为我们是用一个不支持作业控制的shell执行命令时得到该值的，所以称其为前台进程组。</p>
<p>如果在后台执行命令：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -o pid,ppid,paid, oid, comm &amp;</span><br></pre></td></tr></table></figure></p>
<p>则唯一改变的值是命令的进程ID;<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PID PPID PGID SID COMMAND</span><br><span class="line">949  947  949 949 sh</span><br><span class="line">1812 949  949 949 ps</span><br></pre></td></tr></table></figure></p>
<p>因为这种shell不知道作业控制，所以没有将后台作业放入自己的进程组，也没有从后台作业处取走控制终端。</p>
<p>现在看一看Bourne shell如何处理管道。执行下列命令：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -o pid,ppid,pyid,sid,comm | catl</span><br></pre></td></tr></table></figure></p>
<p>其输出是：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PID PPID PGID SID COMMAND</span><br><span class="line">949  947  949 949 sh</span><br><span class="line">1823 949  949 949 catl</span><br><span class="line">1824 1823 949 949 ps</span><br></pre></td></tr></table></figure></p>
<p>注意，管道中的最后一个进程是shell的子进程，该管道中的第一个进程则是最后一个进程的子进程。从中可以看出，shell fork一个它自身的副本，然后此副本再为管道中的每条命令各fork一个进程。</p>
<p>如果在后台执行此管道<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -o pid, ppid, paid, sid, comm | catl &amp;</span><br></pre></td></tr></table></figure></p>
<p>则只改变进程ID。因为shell并不处理作业控制，后台进程的进程组ID仍是949，如何会话的进程组ID一样。</p>
<p>如果一个后台进程试图读其控制终端，则会发生什么呢?例如，若执行：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; temp.foo &amp;</span><br></pre></td></tr></table></figure></p>
<p>在有作业控制时，后台作业被放在后台进程组，如果后台作业试图读控制终端，则会产生信号SIGTTIN。在没有作业控制时，其处理方法是： 如果该进程自己没有重定向标准输入，则shell自动将后台进程的标准输入重定向到/dev/null。读/dev/null则产生一个文件结束。这就意味着后台cat进程立即读到文件尾，并正常终止。</p>
<p>前面说明了对后台进程通过其标准输入访问控制终端的适当的处理方法，但是，如果一个后台进程打开/dev/tty并且读该控制终端，又将怎样呢?对此问题的回答是“看情况”。但是这很可能不是我们所期望的。例如：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crypt &lt; salazies | lpr &amp;</span><br></pre></td></tr></table></figure></p>
<p>就是这样的一条管道。我们在后台运行它，但是crypt程序打开/dev/tty，更改终端的特性(禁止回显)，然后从该设备读，最后重置该终端特性。当执行这条后台管道时，crypt在终端上打印提示符“Password:”，但是shell读取了我们所输入的加密口令，并试图执行以加密口令为名称的命令。我们输送给shell的下一行则被crypt进程取为口令行，于是saiaries也就不能正确地被译码，结果将一堆无用的信息送到了打印机。在这里，我们有了两个进程，它们试图同时读同一设备，其结果则依赖于系统。前面说明的作业控制以较好的方式处理一个终端在多个进程间的转接。</p>
<p>返回到Bourneshell实例，在一条管道中执行3个进程，我们可以检验Bourne shell使用的进程控制方式<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -o pid,ppid,paid, sid, comm | catl | cat2</span><br></pre></td></tr></table></figure></p>
<p>其输出为：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PID PPID PGID SID COMMAND</span><br><span class="line">949  947  949 949 sh</span><br><span class="line">1988 949  949 949 cat2</span><br><span class="line">1989 1988 949 949 ps</span><br><span class="line">1990 1988 949 949 cat1</span><br></pre></td></tr></table></figure></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Linux/" rel="tag"># Linux</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/05/24/UNIX高级编程 笔记4/" rel="next" title="UNIX高级编程 笔记4">
                <i class="fa fa-chevron-left"></i> UNIX高级编程 笔记4
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/05/29/UNIX高级编程 笔记5/" rel="prev" title="UNIX高级编程 笔记5">
                UNIX高级编程 笔记5 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/header.jpg" alt="Hao Yu">
            
              <p class="site-author-name" itemprop="name">Hao Yu</p>
              <p class="site-description motion-element" itemprop="description">Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author</p>
          </div>
          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">348</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>
        	<audio controls="controls" loop="loop" preload="auto" src="/resource/xiaomeihao.mp3">
	        </audio>
	

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yuhao0102" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:yuh18@mails.tsinghua.edu.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#进程控制"><span class="nav-number">1.</span> <span class="nav-text">进程控制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#进程标识"><span class="nav-number">1.1.</span> <span class="nav-text">进程标识</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数fork"><span class="nav-number">1.2.</span> <span class="nav-text">函数fork</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数vfork"><span class="nav-number">1.3.</span> <span class="nav-text">函数vfork</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数exit"><span class="nav-number">1.4.</span> <span class="nav-text">函数exit</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数wait和waitpid"><span class="nav-number">1.5.</span> <span class="nav-text">函数wait和waitpid</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数waitid"><span class="nav-number">1.6.</span> <span class="nav-text">函数waitid</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数wait3和wait4"><span class="nav-number">1.7.</span> <span class="nav-text">函数wait3和wait4</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#竞争条件"><span class="nav-number">1.8.</span> <span class="nav-text">竞争条件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数exec"><span class="nav-number">1.9.</span> <span class="nav-text">函数exec</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#更改用户ID和更改组ID"><span class="nav-number">1.10.</span> <span class="nav-text">更改用户ID和更改组ID</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#函数setreuid和sotregid"><span class="nav-number">1.10.1.</span> <span class="nav-text">函数setreuid和sotregid</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数seteuid和sotegid"><span class="nav-number">1.10.2.</span> <span class="nav-text">函数seteuid和sotegid</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#组ID"><span class="nav-number">1.10.3.</span> <span class="nav-text">组ID</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解释器文件"><span class="nav-number">1.11.</span> <span class="nav-text">解释器文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数system"><span class="nav-number">1.12.</span> <span class="nav-text">函数system</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程会计"><span class="nav-number">1.13.</span> <span class="nav-text">进程会计</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#用户标识"><span class="nav-number">1.14.</span> <span class="nav-text">用户标识</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程调度"><span class="nav-number">1.15.</span> <span class="nav-text">进程调度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程时间"><span class="nav-number">1.16.</span> <span class="nav-text">进程时间</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#进程关系"><span class="nav-number">2.</span> <span class="nav-text">进程关系</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#终端登录"><span class="nav-number">2.1.</span> <span class="nav-text">终端登录</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程组"><span class="nav-number">2.2.</span> <span class="nav-text">进程组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#会话"><span class="nav-number">2.3.</span> <span class="nav-text">会话</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#控制终端"><span class="nav-number">2.4.</span> <span class="nav-text">控制终端</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数tcgetpgrp、tcsetpgrp和tcgetsid"><span class="nav-number">2.5.</span> <span class="nav-text">函数tcgetpgrp、tcsetpgrp和tcgetsid</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#作业控制"><span class="nav-number">3.</span> <span class="nav-text">作业控制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#shell执行程序"><span class="nav-number">3.1.</span> <span class="nav-text">shell执行程序</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>
  <div id="DvelopmentTarget">     
  </div>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart" aria-hidden="false"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>

  
</div>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_uv"> 
  本站访客数<span id="busuanzi_value_site_uv"></span>人次
</span>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  


  <script type="text/javascript" src="/js/src/love.js"></script>

</body>
</html>
