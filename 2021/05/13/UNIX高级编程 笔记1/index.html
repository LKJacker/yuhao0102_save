<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zn-ch">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-center-simple.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Linux,">










<meta name="description" content="UNIX基础知识UNIX体系结构从严格意义上说，可将操作系统定义为一种软件，它控制计算机硬件资源，提供程序运行环境。我们通常将这种软件称为内核(kermel)，因为它相对较小，而且位于环境的核心。 内核的接口被称为系统调用(systemcall)。公用函数库构建在系统调用接口之上，应用程序既可使用公用函数库，也可使用系统调用。 文件和目录文件系统UNIX文件系统是目录和文件的一种层次结构，所有东西">
<meta name="keywords" content="Linux">
<meta property="og:type" content="article">
<meta property="og:title" content="UNIX高级编程 笔记1">
<meta property="og:url" content="http://yoursite.com/2021/05/13/UNIX高级编程 笔记1/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="UNIX基础知识UNIX体系结构从严格意义上说，可将操作系统定义为一种软件，它控制计算机硬件资源，提供程序运行环境。我们通常将这种软件称为内核(kermel)，因为它相对较小，而且位于环境的核心。 内核的接口被称为系统调用(systemcall)。公用函数库构建在系统调用接口之上，应用程序既可使用公用函数库，也可使用系统调用。 文件和目录文件系统UNIX文件系统是目录和文件的一种层次结构，所有东西">
<meta property="og:locale" content="zn-ch">
<meta property="og:image" content="http://yoursite.com/img/1620962971.jpg">
<meta property="og:image" content="http://yoursite.com/img/20210515010759.png">
<meta property="og:image" content="http://yoursite.com/img/20210515011014.png">
<meta property="og:image" content="http://yoursite.com/img/20210515094251.png">
<meta property="og:image" content="http://yoursite.com/img/20210515101810.png">
<meta property="og:image" content="http://yoursite.com/img/20210516123303.png">
<meta property="og:image" content="http://yoursite.com/img/20210516231147.png">
<meta property="og:image" content="http://yoursite.com/img/20210516231950.png">
<meta property="og:image" content="http://yoursite.com/img/20210517004519.png">
<meta property="og:image" content="http://yoursite.com/img/1621242103.jpg">
<meta property="og:image" content="http://yoursite.com/img/1621244305.jpg">
<meta property="og:updated_time" content="2021-06-01T13:26:10.722Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="UNIX高级编程 笔记1">
<meta name="twitter:description" content="UNIX基础知识UNIX体系结构从严格意义上说，可将操作系统定义为一种软件，它控制计算机硬件资源，提供程序运行环境。我们通常将这种软件称为内核(kermel)，因为它相对较小，而且位于环境的核心。 内核的接口被称为系统调用(systemcall)。公用函数库构建在系统调用接口之上，应用程序既可使用公用函数库，也可使用系统调用。 文件和目录文件系统UNIX文件系统是目录和文件的一种层次结构，所有东西">
<meta name="twitter:image" content="http://yoursite.com/img/1620962971.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2021/05/13/UNIX高级编程 笔记1/">





  <title>UNIX高级编程 笔记1 | Hao Yu's blog</title>
  








 
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zn-ch">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hao Yu's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">The program monkey was eaten by the siege lion.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/resume.pdf" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-mybetterhalf">
          <a href="/mybetterhalf/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>
            
            mybetterhalf
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/05/13/UNIX高级编程 笔记1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">UNIX高级编程 笔记1</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-05-13T21:00:00+08:00">
                2021-05-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="UNIX基础知识"><a href="#UNIX基础知识" class="headerlink" title="UNIX基础知识"></a>UNIX基础知识</h1><h2 id="UNIX体系结构"><a href="#UNIX体系结构" class="headerlink" title="UNIX体系结构"></a>UNIX体系结构</h2><p>从严格意义上说，可将操作系统定义为一种软件，它控制计算机硬件资源，提供程序运行环境。我们通常将这种软件称为内核(kermel)，因为它相对较小，而且位于环境的核心。</p>
<p>内核的接口被称为系统调用(systemcall)。公用函数库构建在系统调用接口之上，应用程序既可使用公用函数库，也可使用系统调用。</p>
<h2 id="文件和目录"><a href="#文件和目录" class="headerlink" title="文件和目录"></a>文件和目录</h2><h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><p>UNIX文件系统是目录和文件的一种层次结构，所有东西的起点是称为根(root)的目录，这个目录的名称是一个字符“/“。</p>
<p>目录(directory)是一个包含目录项的文件。在逻辑上，可以认为每个目录项都包含一个文件名，同时还包含说明该文件属性的信息。文件属性是指文件类型(是普通文件还是目录等)、文件大小、文件所有者、文件权限(其他用户能否访问该文件)以及文件最后的修改时间等。<code>stat</code>和<code>fstat</code>函数返回包含所有文件属性的一个信息结构。</p>
<h3 id="文件名"><a href="#文件名" class="headerlink" title="文件名"></a>文件名</h3><p>目录中的各个名字称为文件名(filename)。只有斜线(/)和空字符这两个字符不能出现在文件名中。斜线用来分隔构成路径名的各文件名，空字符则用来终止一个路径名。</p>
<p>创建新目录时会自动创建了两个文件名：<code>.</code>(称为点)和<code>..</code>(称为点点)。点指向当前目录，点点指向父目录。在最高层次的根目录中，点点与点相同。现今，几乎所有商业化的UNIX文件系统都支<br>持超过255个字符的文件名。</p>
<h3 id="路径名"><a href="#路径名" class="headerlink" title="路径名"></a>路径名</h3><p>由斜线分隔的一个或多个文件名组成的序列(也可以斜线开头)构成路径名(pathname)，以斜线开头的路径名称为绝对路径名(absolute pathname)，否则称为相对路径名(relative pathname)。相对路径名指向相对于当前目录的文件。文件系统根的名字(/)是一个特殊的绝对路径名，它不包含文件名。</p>
<p>不难列出一个目录中所有文件的名字，以下命令的简要实现。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> arge, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    DIR *dp;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">dirp</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">        err_quif(<span class="string">"usage: ls directory_nane"</span>) a</span><br><span class="line">    <span class="keyword">if</span> ((dp = opendir(argv[<span class="number">1</span>])) == <span class="literal">NULL</span>)</span><br><span class="line">        err_ays (<span class="string">"can't open %s"</span>, argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">while</span> ((dirp = readdir(dp)) !- <span class="literal">NULL</span>)</span><br><span class="line">        printe(<span class="string">"%s\n"</span>, dirp-&gt;d_name);</span><br><span class="line">    closedir(dp);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这个20行的程序中，有很多细节需要考虑。</p>
<ul>
<li>首先，其中包含了一个头文件<code>apue.h</code>。本书中几乎每一个程序都包含此头文件。它包含了某些标准系统头文件，定义了许多常量及函数原型。</li>
<li>接下来，我们包含了一个系统头文件dirent.h。以便使用<code>opendir</code>和<code>readdir</code>的函数原型，以及<code>dirent</code>结构的定义。在其他一些系统里，这些定义被分成多个头文件。</li>
<li><code>main</code>函数的声明使用了ISO C标准所使用的风格</li>
<li>程序获取命令行的第1个参数<code>argv[1]</code>作为要列出其各个目录项的目录名。</li>
<li>因为各种不同UNIX系统目录项的实际格式是不一样的，所以使用函数<code>opendir</code>、<code>readdir</code>和<code>closedir</code>对目录进行处理。</li>
<li><code>opendir</code>函数返回指向<code>DIR</code>结构的指针，我们将该指针传送给<code>readdir</code>函数。然后，在循环中调用<code>readdir</code>来读每个目录项。它返回一个指向<code>dirent</code>结构的指针，而当目录中已无目录项可读时则返回null指针。在<code>dirent</code>结构中取出的只是每个目录项的名字(<code>d_name</code>)。使用该名字，此后就可用<code>stat</code>函数以获得该文件的所有属性。</li>
<li>当程序将结束时，它以参数0调用函数<code>exit()</code>。函数<code>exit()</code>终止程序。按惯例，参数0的意思是正常结束，参数值1~255则表示出错。</li>
</ul>
<h3 id="工作目录"><a href="#工作目录" class="headerlink" title="工作目录"></a>工作目录</h3><p>每个进程都有一个工作目录(working directory)，有时称其为当前工作目录(current working directory)，所有相对路径名都从工作目录开始解释。进程可以用<code>chdir</code>函数更改其工作目录。</p>
<h3 id="起始目录"><a href="#起始目录" class="headerlink" title="起始目录"></a>起始目录</h3><p>登录时，工作目录设置为起始目录(home directory)，该起始目录从口令文件中相应用户的登录项中取得</p>
<h2 id="输入和输出"><a href="#输入和输出" class="headerlink" title="输入和输出"></a>输入和输出</h2><h3 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h3><p>文件描述符(flle descriptor)通常是一个小的非负整数，内核用以标识一个特定进程正在访间的文件。当内核打开一个现有文件或创建一个新文件时，它都返回一个文件描述符。在读、写文件时，可以使用这个文件描述符。</p>
<h3 id="标准输入、标准输出和标准错误"><a href="#标准输入、标准输出和标准错误" class="headerlink" title="标准输入、标准输出和标准错误"></a>标准输入、标准输出和标准错误</h3><p>按惯例，每当运行一个新程序时，所有的shell都为其打开了个文件描述符，即标准输入(standard input)、标准输出(standard output)以及标准错误(standarderror)。如果不做特殊处理，则这3个描述符都链接向终端。</p>
<h3 id="不带缓冲的I-O"><a href="#不带缓冲的I-O" class="headerlink" title="不带缓冲的I/O"></a>不带缓冲的I/O</h3><p>函数<code>open</code>、<code>read</code>，<code>write</code>、<code>lseek</code>以及<code>close</code>提供了不带缓冲的I/O。这些函数都使用文件描述符。</p>
<p>如果愿意从标准输入读，并向标准输出写，则所示的程序可用于复制任一UNIX普通文件<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFSIZE 4096</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">char</span> buf [BUFFSIZE];</span><br><span class="line">    <span class="keyword">while</span> ((n = read(STDIN_FILENO, buf, BUFFSIZE)) &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> (write(STDOUT_FILENO, buf, n) != n)</span><br><span class="line">            exc_syn(<span class="string">"write exror"</span>);</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">0</span>)</span><br><span class="line">        err_sys(<span class="string">"read error"</span>);</span><br><span class="line">    exif(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>头文件<code>&lt;unistd.h&gt;</code>(<code>apue.h</code>中包含了此头文件)及两个常量<code>STDIN_FILENO</code>和<code>STDOUT_FILENO</code>是POSIX标准的一部分，头文件<code>&lt;unistd.h&gt;</code>包含了很多UNIX系统服务的函数原型，</p>
<p>两个常量<code>STDIN_FILENO</code>和<code>STDOUT_FILENO</code>定义在<code>&lt;unistd.h&gt;</code>头文件中，它们指定了标准输入和标准输出的文件描述符。在POSIX标准中，它们的值分别是0和1，但是考虑到可读性，我们将使用这些名字来表示这些常量</p>
<p><code>read</code>函数返回读取的字节数，此值用作要写的字节数。当到达输入文件的尾时，<code>read</code>返回0，程序停止执行。如果发生了一个读错误，<code>read</code>返回-1。出错时大多数系统函数返回-1。</p>
<h3 id="标准I-O"><a href="#标准I-O" class="headerlink" title="标准I/O"></a>标准I/O</h3><p>标准I/O函数为那些不带缓冲的I/O函数提供了一个带缓冲的接口。使用标准I/O函数无需担心如何选取最佳的缓冲区大小使用标准I/O函数还简化了对输入行的处理。例如，<code>fgets</code>函数读取一个完整的行，而<code>read</code>函数读取指定字节数。</p>
<p>我们最熟悉的标准I/O函数是<code>printf</code>。在调用<code>printf</code>的程序中，总是包含<code>&lt;stdio.h&gt;</code>，该头文件包括了所有标准I/O函数的原型。</p>
<p>下面的程序的功能类似于前一个调用了<code>read</code>和<code>write</code>的程序。它将标准输入复制到标准输出，也就能复制任一UNIX普通文件。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="keyword">while</span>((c = getc(<span class="built_in">stdin</span>)) != EOF)</span><br><span class="line">        <span class="keyword">if</span> (putc(c, <span class="built_in">stdout</span>) == EOF)</span><br><span class="line">        exr_sys(<span class="string">"output exror"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ferror(<span class="built_in">stdin</span>))</span><br><span class="line">        err_sys(<span class="string">"input error"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>函数<code>getc</code>一次读取一个字符，然后函数<code>putc</code>将此字符写到标准输出。读到输入的最后一个字节时，<code>getc</code>返回常量EOF(该常量在<code>&lt;stdio.h&gt;</code>中定义)。标准I/O常量<code>stdin</code>和<code>stdout</code>也在头文件<code>&lt;stdio.h&gt;</code>中定义，它们分别表示标准输入和标准输出。</p>
<h2 id="程序和进程"><a href="#程序和进程" class="headerlink" title="程序和进程"></a>程序和进程</h2><h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><p>程序(program)是一个存储在磁盘上某个目录中的可执行文件。内核使用exec函数(7个<code>exec</code>函数之一)，将程序读入内存，并执行程序。</p>
<h3 id="进程和进程ID"><a href="#进程和进程ID" class="headerlink" title="进程和进程ID"></a>进程和进程ID</h3><p>程序的执行实例被称为进程(process)。某些操作系统用任务(task)表示正在被执行的程序，UNIX系统确保每个进程都有一个难一的数字标识符，称为进程ID(process ID)。进程ID总是一个非负整数。</p>
<p>程序用于打印进程ID<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello world from process ID sid\n"</span>, (<span class="keyword">long</span>)getpid());</span><br><span class="line">    exif(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此程序运行时，它调用函数<code>getpid</code>得到其进程ID。<code>getpid</code>返回一个<code>pid_t</code>数据类型。</p>
<h3 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h3><p>有3个用于进程控制的主要函数：<code>fork</code>、<code>exec</code>和<code>waitpid</code>。</p>
<p>该程序从标准输入读取命令，然后执行这些命令。它类似于shell程序的基本实施部分。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span>    buf[MAXLINE];   <span class="comment">/* from apue.h */</span></span><br><span class="line">    <span class="keyword">pid_t</span>   pid;</span><br><span class="line">    <span class="keyword">int</span>     status;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%% "</span>);  <span class="comment">/* print prompt (printf requires %% to print %) */</span></span><br><span class="line">    <span class="keyword">while</span> (fgets(buf, MAXLINE, <span class="built_in">stdin</span>) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (buf[<span class="built_in">strlen</span>(buf) - <span class="number">1</span>] == <span class="string">'\n'</span>)</span><br><span class="line">            buf[<span class="built_in">strlen</span>(buf) - <span class="number">1</span>] = <span class="number">0</span>; <span class="comment">/* replace newline with null */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            err_sys(<span class="string">"fork error"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;      <span class="comment">/* child */</span></span><br><span class="line">            execlp(buf, buf, (<span class="keyword">char</span> *)<span class="number">0</span>);</span><br><span class="line">            err_ret(<span class="string">"couldn't execute: %s"</span>, buf);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">127</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* parent */</span></span><br><span class="line">        <span class="keyword">if</span> ((pid = waitpid(pid, &amp;status, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">            err_sys(<span class="string">"waitpid error"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%% "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这个30行的程序中，有很多功能需要考虑，</p>
<ul>
<li>用标准I/O函数<code>fgets</code>从标准输入一次读取一行。当键入文件结束符(通常是Ctrl+D)作为行的第一个字符时，fgets返回一个null指针，于是循环停止，进程也就终止。</li>
<li>因为<code>fgets</code>返回的每一行都以换行符终止，后随一个null字节，因此用标准C函数strlen计算此字符串的长度，然后用一个null字节替换换行符。这样做是因为<code>execlp</code>函数要求的参数是以null结束的而不是以换行符结束的</li>
<li>调用fork创建一个新进程。新进程是调用进程的一个副本，我们称调用进程为父进程，新创建的进程为子进程。fork对父进程返回新的子进程的进程ID(一个非负整数)，对子进程则返回0。因为fork创建一个新进程，所以说它被调用一次(由父进程)，但返回两次(分别在父进程中和在子进程中)。</li>
<li>在子进程中，调用<code>execlp</code>以执行从标准输入读入的命令。这就用新的程序文件替换了子进程原先执行的程序文件。</li>
<li>子进程调用<code>execlp</code>执行新程序文件，而父进程希望等待子进程终止，这是通过调用<code>waitpid</code>实现的，其参数指定要等待的进程(即pid参数是子进程ID)。<code>waitpid</code>函数返回子进程的终止状态(<code>status</code>变量)。</li>
<li>该程序的最主要限制是不能向所执行的命令传递参数。例如不能指定要列出目录项的目录名，</li>
</ul>
<h3 id="线程和线程ID"><a href="#线程和线程ID" class="headerlink" title="线程和线程ID"></a>线程和线程ID</h3><p>通常，一个进程只有一个控制线程(thread)——某一时刻执行的一组机器指令。多个控制线程也可以充分利用多处理器系统的并行能力。</p>
<p>一个进程内的所有线程共享同一地址空间、文件描述符、找以及与进程相关的属性。因为它们能访问同一存储区，所以各线程在访问共享数据时需要采取同步措施以避免不一致性。与进程相同，线程也用ID标识。但是，线程ID只在它所属的进程内起作用。一个进程中的线程ID在另一个进程中没有意义。</p>
<p>控制线程的函数与控制进程的函数类似，但另有一套，线程模型是在进程模型建立很久之后才被引入到UNIX系统中的，然而这两种模型之间存在复杂的交互。</p>
<h2 id="出错处理"><a href="#出错处理" class="headerlink" title="出错处理"></a>出错处理</h2><p>当UNIX系统函数出错时，通常会返回一个负值，而且整型变量errno通常被设置为具有特定信息的值，文件<code>&lt;errno.h&gt;</code>中定义了errno以及可以赋与它的各种常量。这些常量都以字符<code>E</code>开头。</p>
<p>POSIX和ISO C将errno定义为一个符号，它扩展成为一个可修改的整形左值(Ivalue)。它可以是一个包含出错编号的整数，也可以是一个返回出错编号指针的函数。以前使用的定义是：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> errno;</span><br></pre></td></tr></table></figure></p>
<p>但是在支持线程的环境中，多个线程共享进程地址空间，每个线程都有属于它自己的局部errno以避免一个线程干扰另一个线程。例如，Linux支持多线程存取errno，将其定义为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> *_errno_location(vold),</span><br><span class="line"><span class="meta">#detine errno (*_errno_location())</span></span><br></pre></td></tr></table></figure></p>
<p>对于errno应当注意两条规则。第一条规则是：如果没有出错，其值不会被侧程清除。因此，仅当函数的返回值指明出错时，才检验其值。第二条规则是：任何函数都不会将errno值设置为0，而且在<code>&lt;errno.h&gt;</code>中定义的所有常量都不为0。</p>
<p>C标准定义了两个函数，它们用于打印出错信息。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strerror</span> <span class="params">(<span class="keyword">int</span> errnum)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p><code>strerror</code>函数将<code>errnum</code>(通常就是<code>errno</code>值)映射为一个出错消息字符串，并且返回此字符串的指针。</p>
<p><code>perror</code>函数基于<code>errno</code>的当前值，在标准错误上产生一条出错消息，然后返回。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">perror</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *msg)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>它首先输出由msg指向的字符串，然后是一个冒号，一个空格，接着是对应于errno值的出错消息，最后是一个换行符。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> cerrno.b&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"EACCES: %s\n"</span>, strerror(BACCES));</span><br><span class="line">    errno = ENOENT;</span><br><span class="line">    perror(argv[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可将在<code>&lt;errno.h&gt;</code>中定义的各种出错分成两类；致命性的和非致命性的。对于致命性的错误，无法执行恢复动作。最多能做的是在用户屏幕上打印出一条出错消息或者将一条出错消息写入日志文件中，然后退出。对于非致命性的出错，有时可以较妥善地进行处理。</p>
<p>大多数非致命性出错是暂时的(如资源短缺)，当系统中的活动较少时，这种出错很可能不会发生。与资源相关的非致命性出情包括：EAGAIN、ENFILE、ENOBUFS、ENOLCK、ENOSPC、EWOULDBLOCK，有时ENOMEM也是非致命性出错。当EBUSY指明共享资源正在使用时，也可将它作为非致命性出错处理。当EINTR中断一个慢速系统调用时，可将它作为非致命性出错处理。</p>
<p>对于资源相关的非致命性出错的典型恢复操作是延迟一段时间，然后重试。一些应用使用指数补偿算法，在每次选代中等待更长时间。</p>
<h2 id="用户标识"><a href="#用户标识" class="headerlink" title="用户标识"></a>用户标识</h2><h3 id="用户ID"><a href="#用户ID" class="headerlink" title="用户ID"></a>用户ID</h3><p>口令文件登录项中的用户ID(userID)是一个数值，它向系统标识各个不同的用户。系统管理员在确定一个用户的登录名的同时，确定其用户ID。用户不能更改其用户ID。</p>
<p>用户ID为O的用户为根用户(root)或超级用户(superuser)。在口令文件中，通常有一个登录项，其登录名为root。我们称这种用户的特权为超级用户特权。如果一个进程具有超级用户特权，则大多数文件权限检查都不再进行。某些操作系统功能只向超级用户提供。</p>
<p>口令文件登录项也包括用户的组D(group ID)，它是一个数值。组ID也是由系统管理员在指定用户登录名时分配的。组被用于将若干用户集合到项目或部门中去。这种机制允许同组的各个成员之间共享资源。组文件将组名映射为数值的组ID。组文件通常是/etc/group。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    printe (<span class="string">"uid = %d, gid = %d\n"</span>, getuid(), getgid());</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="附属组ID"><a href="#附属组ID" class="headerlink" title="附属组ID"></a>附属组ID</h3><p>除了在口令文件中对一个登录名指定一个组ID外，大多数UNIX系统版本还允许一个用户属于另外一些组。这一功能是从4.2BSD开始的，它允许一个用户属于多至16个其他的组。登录时，读文件/etc/group。寻找列有该用户作为其成员的前16个记录项就可以得到该用户的附属组ID(supplementary group ID)。</p>
<h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><p>信号(signa)用于通知进程发生了某种情况。进程有以下3种处理信号的方式。</p>
<ol>
<li>忽略信号。有些信号表示硬件异常，例如，除以0或访问进程地址空间以外的存储单元等，因为这些异常产生的后果不确定，所以不推荐使用这种处理方式。</li>
<li>按系统默认方式处理。对于除数为0。系统默认方式是终止该进程。</li>
<li>提供一个函数，信号发生时调用该函数，这被称为捕捉该信号。通过提供自编的函数，我们就能知道什么时候产生了信号，并按期望的方式处理它。</li>
</ol>
<p>很多情况都会产生信号，终端键盘上有两种产生信号的方法，分别称为<strong>中断键</strong>(通常是Delete键成<code>Ctrl+C</code>)和<strong>退出键</strong>(通常是<code>Ctrl+\</code>)，它们被用于中断当前运行的进程。</p>
<p>另一种产生信号的方法是调用kill函数。在一个进程中调用此函数就可向另一个进程发送一个信号。当然这样做也有些限制：当向一个进程发送信号时，我们必须是那个进程的所有者或者是超级用户。</p>
<p>为了能捕捉到信号，程序需要调用signal函数，其中指定了当产生SIGINT信号时要调用的函数的名字。函数名为<code>sig_int</code>，当其被调用时，只是打印一条消息，然后打印一个新提示符。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ays/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">statie <span class="keyword">void</span> <span class="title">sig_int</span><span class="params">(<span class="keyword">int</span>)</span></span>; <span class="comment">/* our signal-catching function */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE]; <span class="comment">/* trom apue.h */</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">if</span> (signal(SIGINT, sig_int) == SIG_ERR)</span><br><span class="line">        err_sys(<span class="string">"signal error"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%% "</span>);  <span class="comment">/* print prompt (printf requires %% to print %) */</span></span><br><span class="line">    <span class="keyword">while</span> (fgets(buf, MAXLINE, <span class="built_in">stdin</span>) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (buf[<span class="built_in">strlen</span>(buf) - <span class="number">1</span>] == <span class="string">'\n'</span>)</span><br><span class="line">            buf[<span class="built_in">strlen</span>(buf) - <span class="number">1</span>] = <span class="number">0</span>; <span class="comment">/* replace newline with null */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            err_sys(<span class="string">"fork error"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;      <span class="comment">/* child */</span></span><br><span class="line">            execlp(buf, buf, (<span class="keyword">char</span> *)<span class="number">0</span>);</span><br><span class="line">            err_ret(<span class="string">"couldn't execute: %s"</span>, buf);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">127</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* parent */</span></span><br><span class="line">        <span class="keyword">if</span> ((pid = waitpid(pid, &amp;status, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">            err_sys(<span class="string">"waitpid error"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%% "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sig_int</span><span class="params">(<span class="keyword">int</span> signo)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"interrupt\n %%"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="时间值"><a href="#时间值" class="headerlink" title="时间值"></a>时间值</h2><p>历史上，UNIX系统使用过两种不同的时间值。</p>
<ol>
<li>日历时间。该值是自协调世界时(Coordinated Universal Time, UTC) 1970年1月1日00:00:00这个特定时间以来所经过的秒数累计值。这<br>些时间值可用于记录文件最近一次的修改时间等，系统基本数据类型<code>time_t</code>用于保存这种时间值。</li>
<li>进程时间。也被称为CPU时间，用以度量进程使用的中央处理器资源。进程时间以时钟滴答计算。每秒钟曾经取为50、60或100个时钟滴答。系统基本数据类型<code>clock_t</code>保存这种时间值。</li>
</ol>
<p>当度量一个进程的执行时间时，UNIX系统为一个进程维护了3个进程时间值：</p>
<ul>
<li>时钟时间：时钟时间又称为墙上时钟时间，它是进程运行的时间总量，其值与系统中同时运行的进程数有关。</li>
<li>用户CPU时间：用户CPU时间是执行用户指令所用的时间量。</li>
<li>系统CPU时间：系统CPU时间是为该进程执行内核程序所经历的时间。</li>
</ul>
<p>例如，每当一个进程执行一个系统服务时，如read或write，在内核内执行该服务所花费的时间就计入该进程的系统CPU时间，用户CPU时间和系统CPU时间之和常被称为CPU时间，要取得任一进程的时钟时间、用户时间和系统时间是很容易的一只要执行命令<code>time(1)</code>，其参数是要度量其执行时间的命令，例如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ed /usr/include</span><br><span class="line">$ time -p grep _POSIX_SOURCE  */*.h &gt; /dev/null</span><br><span class="line">real 0m0.81s</span><br><span class="line">user 0m0.11s</span><br><span class="line">sys 0m0.07s</span><br></pre></td></tr></table></figure></p>
<h2 id="系统调用和库函数"><a href="#系统调用和库函数" class="headerlink" title="系统调用和库函数"></a>系统调用和库函数</h2><p>所有的操作系统都提供多种服务的入口点。这些入口点被称为系统调用。Linux3.2.0提供了380个系统调用，FreeBSD8.0提供的系统调用超过450个。</p>
<p>UNIX所使用的技术是为每个系统调用在标准C库中设置一个具有同样名字的函数。用户进程用标准C调用序列来调用这些函数，然后，函数又用系统所要求的技术调用相应的内核服务。</p>
<p>以存储空间分配函数malloc为例。UNIX系统调用中处理存储空间分配的是sbrk(2)，它不是一个通用的存储器管理器。它按指定字节数增加或减少进程地址空间。如何管理该地址空间却取决于进程。存储空间分配函数malloc(3)实现一种特定类型的分配，如果我们不喜欢其操作方式，则可以定义自己的malloc函数，它很可能将使用sbrk系统调用。两者职责不同，内核中的系统调用分配一块空间给进程，而库函数malloc则在用户层次管理这一空间。</p>
<p>系统调用和库函数之间的另一个差别是：系统调用通常提供一种最小接口，而库函数通常提供比较复杂的功能。我们从sbrk系统调用和malloc库函数之间的差别中可以看到这一点。进程控制系统调用(tork、exec和wait)通常由用户应用程序直接调用。但是为了简化某些常见的情况， UNIX系统也提供了一些库函数，如system和popen。</p>
<h1 id="文件I-O"><a href="#文件I-O" class="headerlink" title="文件I/O"></a>文件I/O</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>UNIX系统中的大多数文件I/O只需用到5个函数：<code>open</code>、<code>read</code>、<code>write</code>、<code>lseek</code>、<code>close</code>。本章描述的函数经常被称为不带缓冲的I/O (unbuffered I/O。术语不带缓冲指的是每个read和write都调用内核中的一个系统调用。</p>
<h2 id="文件描述符-1"><a href="#文件描述符-1" class="headerlink" title="文件描述符"></a>文件描述符</h2><p>对于内核而言。所有打开的文件都通过文件描述符引用。文件描述符是一个非负整数。当打开一个现有文件或创建一个新文件时，内核向进程返回一个文件描述符。当读、写一个文件时，使用<code>open</code>或<code>creat</code>返回的文件描述符标识该文件，将其作为参数传送给<code>read</code>或<code>write</code>。</p>
<p>按照惯例，UNIX系统shell把文件描述符0与进程的标准输入关联，文件描述符1与标准输出关联，文件描述符2与标准错误关联。这是各种shell以及很多应用程序使用的惯例，与UNIX内核无关。应当把它们替换成符号常量<code>STDIN_FILENO</code>、<code>STDOUT_FILENO</code>和<code>STDERR_FILENO</code>以提高可读性。这些常量都在头文件<code>&lt;unistd.h&gt;</code>中定义，文件描述符的变化范围是0~<code>OPEN_MAX-1</code>。</p>
<h2 id="函数open和openat"><a href="#函数open和openat" class="headerlink" title="函数open和openat"></a>函数open和openat</h2><p>调用open或openat函数可以打开或创建一个文件。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">int</span> oflag, .... <span class="comment">/* mode_t mode */</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">openat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">int</span> oflag, ...<span class="comment">/* mode_t mode */</span>)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>两函数的返回值：若成功，返回文件描述符；若出错，返回-1。</p>
<p>我们将最后一个参数写为<code>...</code>。ISO C用这种方法表明余下的参数的数量及其类型是可变的。对于open函数而言，仅当创建新文件时才使用最后这个参数。在函数原型中将此参数放置在注释中。</p>
<p>path参数是要打开或创建文件的名字。oflag参数可用来说明此函数的多个选项。用下列一个或多个常量进行“或”运算构成oflag参数(这些常量在头文件<code>&lt;fcntl.h&gt;</code>中定义)。</p>
<ul>
<li><code>O_RDONLY</code>：只读打开。</li>
<li><code>O_WRONLY</code>：只写打开。</li>
<li><code>O_RDWR</code>：读、写打开。</li>
<li><code>O_EXEC</code>：只执行打开。</li>
<li><code>O_SEARCH</code>：只搜索打开(应用于目录)。</li>
</ul>
<p>大多数实现将<code>O_RDONLY</code>定义为0，<code>O_WRONLY</code>定义为1，<code>O_RDWR</code>定义为2。<code>O_SEARCH</code>常量的目的在于在目录打开时验证它的搜索权限。对目录的文件描述符的后续操作就不需要再次检查对该目录的搜索权限。</p>
<p>在这5个常量中必须指定一个且只能指定一个。下列常量则是可选的。</p>
<ul>
<li><code>O_APPEND</code>：每次写时都追加到文件的尾端。</li>
<li><code>O_CLOEXEC</code>：把<code>FD_CIOEXEC</code>常量设置为文件描述符标志。</li>
<li><code>O_CREAT</code>：若此文件不存在则创建它。使用此选项时，open函数需同时说明第3个参数mode，用mode指定该新文件的访问权限位</li>
<li><code>O_DIRECTORY</code>：如果path引用的不是目录，则出错。</li>
<li><code>O_EXCL</code>：如果同时指定了<code>O_CREAT</code>，而文件已经存在，则出错。用此可以测试一个文件是否存在，如果不存在，则创建此文件，这使测试和创建两者成为一个原子操作。</li>
<li><code>O_NOCTTY</code>：如果path引用的是终端设备，则不将该设备分配作为此进程的控制终端。</li>
<li><code>O_NOFOLLOW</code>：如果path引用的是一个符号链接，则出错。</li>
<li><code>O_NONBLOCK</code>：如果path引用的是一个FIFO、一个块特殊文件或一个字符特殊文件，则此选项为文件的本次打开操作和后续的I/O操作设置非阻塞方式。</li>
<li><code>O_SYNC</code>：使每次write等待物理I／O操作完成，包括由该write操作引起的文件属性更新所需的I／O</li>
<li><code>O_TRUNC</code>：如果此文件存在，而且为只写或读-写成功打开，则将其长度截断为0</li>
<li><code>0_TTY_INIT</code>：如果打开一个还未打开的终端设备，设置非标准termios参数值，使其符合Single UNIX Specification。</li>
</ul>
<p>下面两个标志也是可选的。</p>
<ul>
<li><code>O_DSYNC</code>：使每次write要等待物理I／O操作完成，但是如果该写操作并不影响读取刚写入的数据，则不需等待文件属性被更新，<ul>
<li><code>O_DSYNC</code>和<code>O_SYNC</code>标志有微妙的区别。仅当文件属性需要更断以反映文件数据变化时，<code>O_DSYNC</code>标志才影响文件属性。而设置<code>O_SYNC</code>标志后，教据和属性总是同步更新。当文件用<code>O_DSYN</code>标志打开，在重写其现有的部分内容时，文件时间属性不会同步更新，与此相反，如果文件是用<code>O_SYNC</code>标志打开，那么对该文件的每一次write都将在write返回前更新文件时间，这与是否改写现有字节或追加写文件无关。</li>
</ul>
</li>
<li><code>O_RSYNC</code>：使每一个以文件描述符作为参数进行的read操作等待，直至所有对文件同一部分挂起的写操作都完成</li>
</ul>
<p>由open和openat函数返回的文件描述符一定是最小的未用描述符数值。这一点被某些应用程序用来在标准输入、标准输出或标准错误上打开新的文件。例如，一个应用程序可以先关闭标准输出(通常是文件描述符1)，然后打开另一个文件，执行打开操作前就能了解到该文件一定会在文件描述符1上打开。</p>
<p><code>fd</code>参数把open和openat函数区分开，共有3种可能性。</p>
<ol>
<li>path参数指定的是绝对路径名，在这种情况下，后参数被忽略，openat函数就相当于open函数。</li>
<li>path参数指定的是相对路径名，后参数指出了相对路径名在文件系统中的开始地址。fd参数是通过打开相对路径名所在的目录来获取。</li>
<li>path参数指定了相对路径名，fd参数具有特殊值<code>AT_FDCWD</code>。在这种情况下，路径名在当前工作目录中获取，openat函数在操作上与open函数类似。</li>
</ol>
<p><code>openat</code>希望解决两个问题。</p>
<ul>
<li>让线程可以使用相对路径名打开目录中的文件，而不再只能打开当前工作目录。</li>
<li>可以避免time of-check-to-time-of-use(TOCTTOU)错误。</li>
</ul>
<p>TOCTTOU错误的基本思想是：如果有两个基于文件的函数调用，其中第二个调用依赖于第一个调用的结果，那么程序是脆弱的。因为两个调用并不是原子操作，在两个函数调用之间文件可能改变了，这样也就造成了第一个调用的结果就不再有效，使得程序最终的结果是错误的。文件系统命名空间中的TOCTTOU错误通常处理的就是那些颠覆文件系统权限的小把戏，这些小把戏通过骗取特权程序降低特权文件的权限控制或者让特权文件打开一个安全漏洞等方式进行。</p>
<h3 id="文件名和路径名截断"><a href="#文件名和路径名截断" class="headerlink" title="文件名和路径名截断"></a>文件名和路径名截断</h3><p>在POSIX.1中，常量<code>_POSIX_NO_TRUNC</code>决定是要截断过长的文件名或路径名，还是返回一个出错。用<code>fpathconf</code>或<code>pathconf</code>来查询目录具体支持何种行为，到底是截断过长的文件名还是返回出错。若<code>_POSIX_NO_TRUNC</code>有效，则在整个路径名超过<code>PATH_MAX</code>，或路径名中的任一文件名超过<code>NAME_MAX</code>时，出错返回，并将errno设置为<code>ENAMETOOLONG</code>。</p>
<h2 id="函数creat"><a href="#函数creat" class="headerlink" title="函数creat"></a>函数creat</h2><p>也可调用creat函数创建一个新文件，<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">creat</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> path, <span class="keyword">mode_t</span> mode)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>返回值：若成功，返回为只写打开的文件描述符；若出错，返回-1。<br>注意，此函数等效于：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open(ptsh, O_WRONLY | O_CREAT | O_TRUNC, mode);</span><br></pre></td></tr></table></figure></p>
<p>creat的一个不足之处是它以只写方式打开所创建的文件。在提供open的新版本之前，如果要创建一个临时文件，并要先写该文件，然后又读该文件，则必须先调用<code>creat</code>、<code>close</code>，然后再调用<code>open</code>。现在则可用下列方式调用open实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open (path, O_RDWR | O_CREAT | O_TRUNC, mode);</span><br></pre></td></tr></table></figure></p>
<p>63</p>
<h2 id="函数close"><a href="#函数close" class="headerlink" title="函数close"></a>函数close</h2><p>可调用close函数关闭一个打开文件。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span> <span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>返回值：若成功，返回0；若出错，返回-1。</p>
<p>关闭一个文件时还会释放该进程加在该文件上的所有记录锁。当一个进程终止时，内核自动关闭它所有的打开文件。很多程序都利用了这一功能而不显式地用close关闭打开文件。</p>
<h2 id="函数lseek"><a href="#函数lseek" class="headerlink" title="函数lseek"></a>函数lseek</h2><p>每个打开文件都有一个与其相关联的“当前文件偏移量”(current file offset)。它通常是一个非负整数，用以度量从文件开始处计算的字节数。通常，读、写操作都从当前文件偏移量处开始，并使偏移量增加所读写的字节数。按系统默认的情况，当打开一个文件时，除非指定<code>O_APPEND</code>选项，否则该偏移量被设置为0。可以调用<code>lseek</code>显式地为一个打开文件设置偏移量。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">off_t</span> lseek(<span class="keyword">int</span> fd, <span class="keyword">off_t</span> offuet, <span class="keyword">int</span> whence);</span><br></pre></td></tr></table></figure></p>
<p>返回值：若成功，返回新的文件偏移量；若出错，返回为-1。</p>
<p>对参数<code>offset</code>的解释与参数<code>whence</code>的值有关</p>
<ul>
<li>若<code>whence</code>是<code>SEEK_SET</code>，则将该文件的偏移量设置为距文件开始处<code>offset</code>个字节。</li>
<li>若<code>whence</code>是<code>SEEK CUR</code>，则将该文件的偏移量设置为其当前值加<code>offset</code>，<code>offset</code>可为正或负。</li>
<li>若<code>whence</code>是<code>SEEK_END</code>，则将该文件的偏移量设置为文件长度加<code>offset</code>，<code>offset</code>可正可负。</li>
</ul>
<p>若<code>lseek</code>成功执行，则返回新的文件偏移量，为此可以用下列方式确定打开文件的当前偏移量：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">off_t</span> currpos;</span><br><span class="line">currpos = lseek(fd, <span class="number">0</span>, SEEK_CUR);</span><br></pre></td></tr></table></figure></p>
<p>这种方法也可用来确定所涉及的文件是否可以设置偏移量。如果文件描述符指向的是一个管道、FIFO或网络套接字，则<code>lseek</code>返回-1，并将<code>errno</code>设置为<code>ESPIPE</code>。</p>
<p>3个符号常量<code>SEEK_SET</code>、<code>SEBK_CUR</code>和<code>SEEK_END</code>是在System V中引入的。在System V之前，<code>whence</code>被指定为0(绝对偏移量)、1(相对于当前位置的偏移量)或2(相对文件尾端的偏移量)。</p>
<p>在<code>lseek</code>中的字符l表示长整型。在引入<code>off_t</code>教据类型之前，<code>offset</code>参数和返回值是长整型的。</p>
<p>所示的程序用于测试对其标准输入能否设置偏移量。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lseek(STDIN_FILENO, <span class="number">0</span>, SEEK_CUR) == <span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"cannot seek\n"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"seek OK\n"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通常，文件的当前偏移量应当是一个非负整数，但是，某些设备也可能允许负的偏移量。但对于普通文件，其偏移量必须是非负值。因为偏移量可能是负值，所以在比较lseek的返回值时应当谨慎，不要测试它是否小于0，而要测试它是否等于-1。</p>
<p>文件偏移量可以大于文件的当前长度，在这种情况下，对该文件的下一次写将加长该文件，并在文件中构成一个空洞，这一点是允许的。位于文件中但没有写过的字节都被读为0。文件中的空洞并不要求在磁盘上占用存储区。具体处理方式与文件系统的实现有关，当定位到超出文件尾端之后写时，对于新写的数据需要分配磁盘块，但是对于原文件尾端和新开始写位置之间的部分则不需要分配磁盘块。</p>
<p>所示的程序用于创建一个具有空洞的文件。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="keyword">char</span> buf1[] = <span class="string">"abcdefghij"</span>;</span><br><span class="line"><span class="keyword">char</span> buf2[] = <span class="string">"ABCDEFGHIJ"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">if</span>((fd = creat(<span class="string">"File.hole"</span>, FILE_MODE)) &lt; <span class="number">0</span>)</span><br><span class="line">       err_sys (<span class="string">"creat error"</span>);</span><br><span class="line">    <span class="keyword">if</span>(write(fd, buf1, <span class="number">10</span>) != <span class="number">10</span>)</span><br><span class="line">        err_sys(<span class="string">"buti write error"</span>);</span><br><span class="line">    <span class="comment">/*oftset now = 10 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(lseek(fd, <span class="number">16384</span>, SEEK_SET) == <span class="number">-1</span>)</span><br><span class="line">        err_sys(<span class="string">"lseek exroz"</span>);</span><br><span class="line">    <span class="comment">/*offset now = 16384 */</span></span><br><span class="line">    <span class="keyword">if</span>(write(fd, buf2, <span class="number">10</span>) != <span class="number">10</span>)</span><br><span class="line">        exr_sys(<span class="string">"buf2 write excor"</span>),</span><br><span class="line">    <span class="comment">/*oftset now = 16394 */</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行该程序得到：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out</span><br><span class="line">$ ls -l file.hoel</span><br><span class="line">-rw-r--r-- 1 sar    16394 Nov 25 01:01 file.hole</span><br><span class="line">$ od -c file.hole</span><br><span class="line">0000000 a b c d e f g h i j \0 \0 \0 \0 \0 \0</span><br><span class="line">0000020 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0</span><br><span class="line">*</span><br><span class="line">0040000 A B C D E F G H I J</span><br><span class="line">0040012</span><br></pre></td></tr></table></figure></p>
<p>使用od(1)命令观察该文件的实际内容。命令行中的<code>-c</code>标志表示以字符方式打印文件内容。从中可以看到，文件中间的30个未写入字节都被读成0。每一行开始的一个7位数是以八进制形式表示的字节偏移量。</p>
<p>因为<code>lseek</code>使用的偏移量是用<code>off_t</code>类型表示的，所以允许具体实现根据各自特定的平台自行选择大小合适的数据类型。现今大多数平台提供两组接口以处理文件偏移量。一组使用32位文件偏移量，另一组则使用64位文件偏移量。</p>
<p>Single UNIX Specification向应用程序提供了一种方法，使其通过sysconf函数确定支持何种环境。图总结了定义的sysconf常量。</p>
<table>
<thead>
<tr>
<th>选项名称</th>
<th>说明</th>
<th>mame参数</th>
</tr>
</thead>
<tbody>
<tr>
<td>_POSIX_V7_ILP32_OFF32</td>
<td>int、long、指针和ott_t类型是32位</td>
<td>_SC_V7_ILP32_OFF32</td>
</tr>
<tr>
<td>_POSIX_V7_ILP32_OFFBIG</td>
<td>int、long、指针类型是32位。off_t类型至少是64位</td>
<td>_SC_V7_ILP32_OFFBIG</td>
</tr>
<tr>
<td>_POSIX_V7_LP64_OFF64</td>
<td>int类型是32位,long、指针和off_t是64位</td>
<td>_SC_V7_LP64_OFF64</td>
</tr>
<tr>
<td>_POSIX_V7_LP64_OFFBIG</td>
<td>int类型是32位，long、指针和off_t类型至少是64位</td>
<td>_SC_V7_LP64_OFFBIG</td>
</tr>
</tbody>
</table>
<p>C99编译器要求使用<code>getconf(1)</code>命令将所期望的数据大小模型映射为编译和链接程序所需的标志。根据每个平台支持环境的不同，可能需要不同的标志和库。</p>
<h2 id="函数read"><a href="#函数read" class="headerlink" title="函数read"></a>函数read</h2><p>调用read函数从打开文件中读数据，<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">ssize_t</span> read(<span class="keyword">int</span> fd, vold *buf, <span class="keyword">size_t</span> nbytes);</span><br></pre></td></tr></table></figure></p>
<p>如read成功，则返回读到的字节数。如已到达文件的尾端，则返回0。有多种情况可使实际读到的字节数少于要求读的字节数：</p>
<ul>
<li>读普通文件时，在读到要求字节数之前已到达了文件尾端。例如，若在到达文件尾端之前有30个字节，而要求读100个字节，则read返回30。下一次再调用read时，它将返回0(文件尾端)。</li>
<li>当从终端设备读时，通常一次最多读一行</li>
<li>当从网络读时，网络中的缓冲机制可能造成返回值小于所要求读的字节数。</li>
<li>当从管道或FIFO读时，如着管道包含的字节少于所需的数量，那么read将只返回实际可用的字节数。</li>
<li>当从某些面向记录的设备读时，一次最多返回一个记录。</li>
<li>当一信号造成中断，而已经读了部分数据量时。</li>
</ul>
<p>读操作从文件的当前偏移量处开始，在成功返回之前，该偏移量将增加实际读到的字节数。POSIX.1从几个方面对read函数的原型做了更改。经典的原型定义是：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *buf, <span class="keyword">unsigned</span> nbytes)</span></span>;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>首先，为了与ISO C一致，第2个参数由<code>char*</code>改为<code>void*</code>。在ISO C中，类型<code>void*</code>用于表示通用指针。</li>
<li>其次，返回值必须是一个带符号整型(<code>ssize_t</code>)，以保证能够返回正整数字节数、0(表示文件尾端)或-1(出错)。</li>
<li>最后，第3个参数在历史上是一个无符号整型，这允许一个16位的实现一次读或写的数据可以多达65534个字节。</li>
</ul>
<h2 id="函数write"><a href="#函数write" class="headerlink" title="函数write"></a>函数write</h2><p>调用write函数向打开文件写数据<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">ssize_t</span> write(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes);</span><br></pre></td></tr></table></figure></p>
<p>其返回值通常与参数nbytes的值相同，否则表示出错。write出错的一个常见原因是磁盘已写满，或者超过了一个给定进程的文件长度限制。</p>
<p>对于普通文件，写操作从文件的当前偏移量处开始。如果在打开该文件时，指定了<code>O_APPEND</code>选项，则在每次写操作之前，将文件偏移量设置在文件的当前结尾处。在一次成功写之后，该文件偏移量增加实际写的字节数。</p>
<h2 id="I-O的效率"><a href="#I-O的效率" class="headerlink" title="I/O的效率"></a>I/O的效率</h2><p>图3-5程序只使用read和write函数复制一个文件。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFSIZE 4096</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">char</span> buf[BUFFSIZE];</span><br><span class="line">    <span class="keyword">while</span>((n = read(STDIN_FILENO, buf, BUFFSIZE)) &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span>(write(STDOUT_FILENO, buf, n) != n)</span><br><span class="line">            err_sys(<span class="string">"write error"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">0</span>)</span><br><span class="line">        err_ays (<span class="string">"read error"</span>);</span><br><span class="line">    exif(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>关于该程序应注意以下几点。</p>
<ul>
<li>它从标准输入读，写至标准输出，这就假定在执行本程序之前，这些标准输入、输出已由shell安排好。</li>
<li>考虑到进程终止时，UNIX系统内核会关闭进程的所有打开的文件描述符，所以此程序并不关闭输入和输出文件。</li>
<li>对UNIX系统内核而言，文本文件和二进制代码文件并无区别，所以本程序对这两种文件都有效。</li>
</ul>
<p>让我们先用各种不同的BUFFSIZE值来运行此程序。图显示了用20种不同的缓冲区长度，读516581760字节的文件所得到的结果。<br><img src="/img/1620962971.jpg" alt></p>
<p>读文件的标准输出被重新定向到<code>/dev/null</code>上。此测试所用的文件系统是Linux ext4文件系统，其磁盘块长度为4096字节。这也证明了系统CPU时间的几个最小值差不多出现在<code>BUFFSIZE</code>为4096及以后的位置，继续增加缓冲区长度对此时间几乎没有影响。</p>
<p>大多数文件系统为改善性能都采用某种预读(read ahcad)技术。当检测到正进行顺序读取时，系统就试图读入比应用所要求的更多数据。并假想应用很快就会读这些数据。预读的效果可以从图中看出，缓冲区长度小至32字节时的时钟时间与拥有较大缓冲区长度时的时钟时间几乎一样。</p>
<h2 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h2><p>内核使用3种数据结构表示打开文件，它们之间的关系决定了在文件共享方面一个进程对另一个进程可能产生的影响。</p>
<ul>
<li>每个进程在进程表中都有一个记录项，记录项中包含一张打开文件描述符表，可将其视为一个矢量，每个描述符占用一项。与每个文件描述符相关联的是：<ul>
<li>文件描述符标志(<code>close_on_exec</code>)</li>
<li>指向一个文件表项的指针</li>
</ul>
</li>
<li>内核为所有打开文件维持一张文件表。每个文件表项包含：<ul>
<li>文件状态标志(读、写、添写、同步和非阻塞等)</li>
<li>当前文件偏移量</li>
<li>指向该文件v节点表项的指针</li>
</ul>
</li>
<li>每个打开文件(或设备)都有一个v节点(v-node)结构。v节点包含了文件类型和对此文件进行各种操作函数的指针。对于大多数文件，v节点还包含了该文件的i节点(i-node，索引节点)。这些信息是在打开文件时从磁盘上读入内存的。</li>
</ul>
<p>图显示了一个进程对应的3张表之间的关系。该进程有两个不同的打开文件，一个文件从标准输入打开(文件描述符0)，另一个从标准输出打开(文件描述符为1)。<br><img src="/img/20210515010759.png" alt></p>
<p>创建v节点结构的目的是对在一个计算机系统上的多文体系统类型提供支持。Sun把这种文件系统称为虚拟文件系统(Virtual File System)，把与文件系统无关的i节点部分称为V节点。</p>
<p>Linux没有将相关数据结构分为i节点和v节点，而是采用了一个与文件系统相关的i节点和一个与文件系统无关的i节点。</p>
<p>如果两个独立进程各自打开了同一文件，则有图中所示的关系。<br><img src="/img/20210515011014.png" alt></p>
<p>我们假定第一个进程在文件描述符3上打开该文件，而另一个进程在文件描述符4上打开该文件。打开该文件的每个进程都获得各自的一个文件表项，但对一个给定的文件只有一个v节点表项。之所以每个进程都获得自己的文件表项，是因为这可以使每个进程都有它自己的对该文件的当前偏移量。</p>
<ul>
<li>在完成每个write后，在文件表项中的当前文件偏移量即增加所写入的字节数。如果这导致当前文件偏移量超出了当前文件长度，则将i节点表项中的当前文件长度设置为当前文件偏移量。</li>
<li>如果用<code>O_APPEND</code>标志打开一个文件，则相应标志也被设置到文件表项的文件状态标志中。每次对这种具有追加写标志的文件执行写操作时，文件表项中的当前文件偏移量首先会被设置为i节点表项中的文件长度。这就使得每次写入的数据都追加到文件的当前尾端处。</li>
<li>若一个文件用<code>lseek</code>定位到文件当前的尾端，则文件表项中的当前文件偏移量被设置为i节点表项中的当前文件长度。</li>
<li>lseek函数只修改文件表项中的当前文件偏移量，不进行任何I／O操作。</li>
</ul>
<p>可能有多个文件描述符项指向同一文件表项。在fork后也发生同样的情况，此时父进程、子进程各自的每一个打开文件描述符共享同一个文件表项。</p>
<p>注意，文件描述符标志和文件状态标志在作用范围方面的区别，前者只用于一个进程的一个描述符，而后者则应用于指向该给定文件表项的任何进程中的所有描述符。</p>
<h2 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h2><h3 id="追加到一个文件"><a href="#追加到一个文件" class="headerlink" title="追加到一个文件"></a>追加到一个文件</h3><p>考虑一个进程，它要将数据追加到一个文件尾端。早期的UNIX系统版本并不支持open的<code>O_APPEND</code>选项，所以程序被编写成下列形式：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(lseek(fd, OL, <span class="number">2</span>) &lt; <span class="number">0</span>) <span class="comment">/*position to EOF */</span></span><br><span class="line">    err_sys(<span class="string">"lseek error"</span>);</span><br><span class="line"><span class="keyword">if</span>(write(fd, buf, <span class="number">100</span>) != <span class="number">100</span>) <span class="comment">/* and write */</span></span><br><span class="line">    err_sys(<span class="string">"write error"</span>);</span><br></pre></td></tr></table></figure></p>
<p>对单个进程而言，这段程序能正常工作，但若有多个进程同时使用这种方法将数据追加写到同一文件，则会产生问题。</p>
<p>假定有两个独立的进程A和B都对同一文件进行追加写操作。每个进程都已打开了该文件，但未使用<code>O_APPEND</code>标志，此时，每个进程都有它自己的文件表项，但是共享一个v节点表项。假定进程A调用了<code>lseek</code>，它修改了当前偏移量，然后内核切换进程，进程B执行<code>lseek</code>也修改了当前偏移量设置为1500字节。这样造成了两个进程写入数据的重叠。</p>
<p>解决方法是使这<code>lseek</code>和<code>write</code>两个操作对于其他进程而言成为一个原子操作。UNIX系统为这样的操作提供了一种原子操作方法，即在打开文件时设置<code>O_APPEND</code>标志，这样做使得内核在每次写操作之前，都将进程的当前偏移量设置到该文件的尾漏处，于是在每次写之前就不再需要调用<code>lseek</code>。</p>
<h3 id="函数pread和pwrite"><a href="#函数pread和pwrite" class="headerlink" title="函数pread和pwrite"></a>函数pread和pwrite</h3><p>Single UNIX Specification包括了XSI扩展，该扩展允许原子性地定位并执行I/O。<code>pread</code>和<code>pwrite</code>就是这种扩展。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;uniatd.h&gt;</span></span></span><br><span class="line"><span class="keyword">ssize_t</span> pread(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes, <span class="keyword">off_t</span> offset);</span><br><span class="line"><span class="comment">// 返回值，读到的字节数，若已到文件尾，返回0；若出错，返回-1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> pwrite(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes, <span class="keyword">off_t</span> offset);</span><br><span class="line"><span class="comment">// 返回值，若成功，返回已写的字节数， 若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>调用<code>pread</code>相当于调用<code>lseek</code>后调用<code>read</code>，但是<code>pread</code>又与这种顺序调用有下列重要区别。</p>
<ul>
<li>调用pread时，无法中断其定位和读操作。</li>
<li>不更新当前文件偏移量。</li>
</ul>
<p>调用pwrite相当于调用<code>lseek</code>后调用<code>write</code>，但也与它们有类似的区别。</p>
<h3 id="创建一个文件"><a href="#创建一个文件" class="headerlink" title="创建一个文件"></a>创建一个文件</h3><p>对open函数的<code>O_CREAT</code>和<code>O_EXCL</code>选项，当同时指定这两个选项，而该文件又已经存在时，open将失败。我们曾提及检查文件是否存在和创建文件这两个操作是作为一个原子操作执行的。如果没有这样一个原子操作，那么可能会编写下列程序段：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>((fd = open(pathname, O_WRONLY)) &lt; O) &#123;</span><br><span class="line">    <span class="keyword">if</span>(errno = ENOENT) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((fd = creat(path, mode)) &lt; <span class="number">0</span>)</span><br><span class="line">            err_sys (<span class="string">"creat ecror"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        err_sys(<span class="string">"open error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果在open和creat之间，另一个进程创建了该文件，就会出现问题。若在这两个函数调用之间，另一个进程创建了该文件，并且写入了一些数据。然后，原先进程执行这段程序中的creat，这时，刚由另一进程写入的数据就会被擦去。</p>
<p>一般而言，原子操作(atomic operation)指的是由多步组成的一个操作。如果该操作原子地执行，则要么执行完所有步骤，要么一步也不执行，不可能只执行所有步骤的一个子集。</p>
<h2 id="函数dup和dup2"><a href="#函数dup和dup2" class="headerlink" title="函数dup和dup2"></a>函数dup和dup2</h2><p>下面两个函数都可用来复制一个现有的文件描述符。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup</span> <span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup2</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> fd2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两函数的返回值。若成功，返回新的文件描述符，若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>由dup返回的新文件描述符一定是当前可用文件描述符中的最小数值。对于dup2，可以用<code>fd2</code>参数指定新描述符的值。如果<code>fd2</code>已经打开，则先将其关闭。如若<code>fd</code>等于<code>fd2</code>，则dup2返回<code>fd2</code>，而不关闭它。否则，<code>fd2</code>的<code>FD_CLOEXEC</code>文件描述符标志就被清除，这样fd2在进程调用exec时是打开状态。</p>
<p>这些函数返回的新文件描述符与参数fd共享同一个文件表项，如图所示。<br><img src="/img/20210515094251.png" alt></p>
<p>在此图中，我们假定进程启动时执行了：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newfd = dup(<span class="number">1</span>);</span><br></pre></td></tr></table></figure></p>
<p>当此函数开始执行时，假定下一个可用的描述符是3(这是非常可能的，因为0, 1和2都由shell打开)。因为两个描述符指向同一文件表项，所以它们共享同一文件状态标志(读、写、追加等)以及同一当前文件偏移量。</p>
<p>复制一个描述符的另一种方法是使用<code>fcntl</code>函数。实际上，调用<code>dup(fd);</code>等效于<code>fcntl(fd, F_DUPFD, 0);</code>，而调用<code>dup2(fd, fd2);</code>等效于<code>close(fd2); fcntl(fd, E_DUPFD, fd2);</code>。在后一种情况下，<code>dup2</code>并不完全等同于<code>close</code>加上<code>fcnt1</code>。它们之间的区别具体如下。</p>
<ol>
<li><code>dup2</code>是一个原子操作，而<code>close</code>和<code>fcnt1</code>包括两个函数调用。有可能在<code>close</code>和<code>fcnt1</code>之间调用了信号捕获函数，它可能修改文件描述符。如果不同的线程改变了文件描述符的话也会出现相同的问题。</li>
<li><code>dup2</code>和<code>fcntl</code>有一些不同的errno。</li>
</ol>
<h2 id="函数sync、fsync和fdatasync"><a href="#函数sync、fsync和fdatasync" class="headerlink" title="函数sync、fsync和fdatasync"></a>函数sync、fsync和fdatasync</h2><p>传统的UNIX系统实现在内核中设有缓冲区高速缓存或页高速缓存，大多数磁盘I/O都通过缓冲区进行。当我们向文件写入数据时，内核通常先将数据复制到缓冲区中，然后排入队列，晚些时候再写入磁盘。这种方式被称为延迟写(delayed write)。</p>
<p>通常，当内核需要重用缓冲区来存放其他磁盘块数据时，它会把所有延迟写数据块写入磁盘。为了保证磁盘上实际文件系统与缓冲区中内容的一致性，UNIX系统提供了<code>sync</code>、<code>fsync</code>和<code>fdatasync</code>三个函数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fsync</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fdatasync</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回0；若出错，返回-1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sync</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p><code>sync</code>只是将所有修改过的块缓冲区排入写队列，然后就返回，它并不等待实际写磁盘操作结束，通常，称为<code>update</code>的系统守护进程周期性地调用(一般每隔30秒)<code>sync</code>函数。这就保证了定期冲洗(flush)内核的块缓冲区。命令<code>sync(1)</code>也调用<code>sync</code>函数。</p>
<p><code>fsync</code>函数只对由文件描述符<code>fd</code>指定的一个文件起作用，并且等待写磁盘操作结束才返回。<code>fsync</code>可用于数据库这样的应用程序，这种应用程序需要确保修改过的块立即写到磁盘上。</p>
<p><code>fdatasync</code>函数类似于<code>fsync</code>，但它只影响文件的数据部分。而除数据外，<code>fsync</code>还会同步更新文件的属性。</p>
<h2 id="函数fcntl"><a href="#函数fcntl" class="headerlink" title="函数fcntl"></a>函数fcntl</h2><p>fcntl函数可以改变已经打开文件的属性，<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcnti.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> cmd, <span class="comment">/* int arg */</span>)</span></span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，则依赖于cmd(见下)，若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>第3个参数总是一个整数，与上面所示函数原型中的注释部分对应。<code>fcntl</code>函数有以下5种功能</p>
<ol>
<li>复制一个已有的描述符(cmd=<code>F_DUPFD</code>或<code>F_DUPFD_CLOEXEC</code>).</li>
<li>获取/设置文件描述符标志(cmd=<code>F_GETFD</code>或<code>F_SETFD</code>).</li>
<li>获取/设置文件状态标志(cmd=<code>F_GETFL</code>或<code>F_SETFL</code>).</li>
<li>获取/设置异步I/O所有权(cmd=<code>F_GETOWN</code>或<code>F_SETOWN</code>)。</li>
<li>获取/设置记录锁(cmd=<code>F_GETLK</code>、<code>F_SETLK</code>或<code>F_SETLKW</code>).</li>
</ol>
<ul>
<li><code>F_DUPFD</code>：复制文件描述符fd。新文件描述符作为函数值返回。它是尚未打开的各描述符中大于或等于第3个参数值(取为整型值)中各值的最小值。新描述符与后共享同一文件表项。但是，新描述符有它自己的一套文件描述符标志，其<code>FD_CLOEXEC</code>文件描述符标志被清除</li>
<li><code>F_DUPFD_CLOEXEC</code>：复制文件描述符，设置与新描述符关联的FD_CLOEXEC文件描述符标志的值，返回新文件描述符</li>
<li><code>F_GETFD</code>：对应于fd的文件描述符标志作为函数值返回。当前只定义了一个文件描述符标志<code>FD_CLOEXEC</code></li>
<li><code>F_SETFD</code>：对于fd设置文件描述符标志。新标志值按第3个参数(取为整型值)设置</li>
<li><code>F_GETFL</code>：对应于fd的文件状态标志作为函数值返回。我们在说明open函数时，已描述了文件状态标志。</li>
</ul>
<p><img src="/img/20210515101810.png" alt></p>
<p>遗憾的是，5个访问方式标志(<code>O_RDONLY</code>、<code>O_WRONLY</code>、<code>O_RDWR</code>、<code>O_EXEC</code>、<code>O_SEARCH</code>)并不各占1位。这5个值互斥，一个文件的访问方式只能取这5个值之一。因此首先必须用屏蔽字<code>O_ACCMODE</code>取得访问方式位，然后将结果与这5个值中的每一个相比较</p>
<ul>
<li><code>F_SETFL</code>：将文件状态标志设置为第3个参数的值(取为整型值)。可以更改的几个标志是：<code>O_APPEND</code>、<code>O_NONBLOCK</code>、<code>O_SYNC</code>、<code>O_DSYNC</code>、<code>O_RSYNC</code>、<code>O_FSYNC</code>、<code>O_ASYNC</code>。</li>
<li><code>F_GETOWN</code>：获取当前接收SIGIO和SIGURG信号的进程ID或进程组ID</li>
<li><code>F_SETOWN</code>：设置接收SIGIO和SIGURG信号的进程ID或进程组ID。正的arg指定一个进程ID，负的arg表示等于arg绝对值的一个进程组ID</li>
</ul>
<p><code>fcntl</code>的返回值与命令有关。如果出错，所有命令都返回-1，如果成功则返回某个其他值。下列4个命令有特定返回值：<code>F_DUPFD</code>、<code>F_GETFD</code>、<code>F_GETFL</code>、<code>F_GETOWN</code>。第1个命令返回新的文件描述符，第2个和第3个命令返回相应的标志，最后一个命令返回一个正的进程ID或负的进程组ID</p>
<p>所示程序的第1个参数指定文件描述符，并对于该描述符打印其所选择的文件标志说明<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">2</span>)</span><br><span class="line">        err_quit(<span class="string">"usage; a.out &lt;descriptort&gt;"</span>);</span><br><span class="line">    <span class="keyword">if</span>((val = fcntl(atoi(argv[<span class="number">1</span>]), F_GETFL, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">        err_sys(<span class="string">"fcntl error for id io"</span>, atoi(argv[<span class="number">1</span>]));</span><br><span class="line">    <span class="keyword">switch</span> (val &amp; O_ACCMODE) &#123;</span><br><span class="line">    <span class="keyword">case</span> O_RDONLY:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"read only"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> O_WRONLY:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"write only"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> O_RDWR:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"read write"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        err_dump(<span class="string">"unknown access mode"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(val &amp; O_APPEND)</span><br><span class="line">        printt(<span class="string">", append"</span>);</span><br><span class="line">    <span class="keyword">if</span> (val &amp; O_NONBLOCK)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">", nonblocking"</span>);</span><br><span class="line">    <span class="keyword">if</span>(val &amp; O_SYNC)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">", synchronous writes"</span>);</span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> !defined(_POSIX_C_SOURCE) &amp;&amp; defined (O_FSYNC) &amp;&amp; (O_FSYNC != 0_SYNC)</span></span><br><span class="line">    <span class="keyword">if</span> (val &amp; O_FSYNC)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">", synchronous writes"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">    exif(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意，我们使用了功能测试宏<code>_POSIX_C_SOURCE</code>，并且条件编译了POSIX.1中没有定义的文件访问标志。</p>
<p>在修改文件描述符标志或文件状态标志时必须谨慎，先要获得现在的标志值，然后按照期望修改它，最后设置新标志值。不能只是执行<code>F_SETFD</code>或<code>F_SETFL</code>命令，这样会关闭以前设置的标志位。下程序对于一个文件描述符设置一个或多个文件状态标志的函数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_fl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> flags)</span> </span>&#123;<span class="comment">/* flags are tile status flags to turn on */</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">if</span>((val = fcntl(fd, F_GETFL, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">        err_sys(<span class="string">"fcntl F_GETFL error"</span>);</span><br><span class="line">    val |= flags;    <span class="comment">/*turn on flags */</span></span><br><span class="line">    <span class="keyword">if</span>(fcntl(fd, F_SETFL, val) &lt; <span class="number">0</span>)</span><br><span class="line">        err_sys(<span class="string">"fcntl F_SETTL error"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果将中间的一条语句改为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val &amp;= ~flags;</span><br><span class="line"><span class="comment">/*turn flags off */</span></span><br></pre></td></tr></table></figure></p>
<p>就构成另一个函数，我们称为<code>clr_fl</code>，并将在后面某些例子中用到它。此语句使当前文件状态标志值val与flags的反码进行逻辑”与”运算。</p>
<p>在UNIX系统中，通常write只是将数据排入队列，而实际的写磁盘操作则可能在以后的某个时刻进行。而数据库系统则需要使用<code>O_SYNC</code>，这样一来，当它从write返回时就知道数据已确实写到了磁盘上，以免在系统异常时产生数据丢失程序运行时，设置<code>O_SYNC</code>标志会增加系统时间和时钟时间。</p>
<p>比较<code>fsync</code>和<code>fdatasync</code>，两者都更新文件内容，用了<code>O_SYNC</code>标志，每次写入文件时都更新文件内容。每一种调用的性能依赖很多因素，包括底层的操作系统实现、磁盘驱动器的速度以及文件系统的类型。</p>
<p>我们的程序在一个描述符(标准输出)上进行操作，但是根本不知道由shell打开的相应文件的文件名。因为这是shell打开的，因此不能在打开时按我们的要求设置<code>O_SYNC</code>标志。使用<code>fcntl</code>，我们只需要知道打开文件的描述符，就可以修改描述符的属性。在讲解非阻塞管道时还会用到<code>fcntl</code>，因为对于管道，我们所知的只有其描述符。</p>
<h2 id="函数ioctl"><a href="#函数ioctl" class="headerlink" title="函数ioctl"></a>函数ioctl</h2><p><code>ioctl</code>函数一直是I/O操作的杂物箱。终端I/O是使用<code>ioctl</code>最多的地方<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt; /* asp and Linux */</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ioctl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> request, ...)</span></span>;</span><br><span class="line"><span class="comment">//返回值，若出错，返回-1，若成功，返回其他值</span></span><br></pre></td></tr></table></figure></p>
<p><code>ioctl</code>函数是Single UNIX Specification标准的一个扩展部分。UNIX系统实现用它进行很多杂项设备操作。有些实现甚至将它扩展到用于普通文件。</p>
<p>对于ISO C原型，它用省略号表示其余参数。但是，通常只有另外一个参数，它常常是指向一个变量或结构的指针。通常，还要求另外的设备专用头文件。例如，除POSIX.1所说明的基本操作之外，终端I/O的<code>ioctl</code>命令都需要头文件<code>&lt;termios.h&gt;</code>。</p>
<p>每个设备驱动程序可以定义它自己专用的一组<code>ioctl</code>命令，系统则为不同种类的设备提供通用的<code>ioctl</code>命令。图中总结了FreeBSD支持的通用<code>ioctl</code>命令的一些类别。</p>
<table>
<thead>
<tr>
<th>类别</th>
<th>常量名</th>
<th>头文件</th>
<th>ioctl数</th>
</tr>
</thead>
<tbody>
<tr>
<td>盘标号</td>
<td>DIOxxx</td>
<td><code>&lt;sys/disklabel.h&gt;</code></td>
<td>4</td>
</tr>
<tr>
<td>文件I/O</td>
<td>FIOxxx</td>
<td><code>&lt;sys/filio.h&gt;</code></td>
<td>14</td>
</tr>
<tr>
<td>磁带I/O</td>
<td>MTIOxxx</td>
<td><code>&lt;sys/mtio.h&gt;</code></td>
<td>11</td>
</tr>
<tr>
<td>套接字I/O</td>
<td>SIOxxx</td>
<td><code>&lt;sys/sockio.k&gt;</code></td>
<td>73</td>
</tr>
<tr>
<td>终端I/O</td>
<td>TIOxxx</td>
<td><code>&lt;aya/ttycom.h&gt;</code></td>
<td>43</td>
</tr>
</tbody>
</table>
<p>磁带操作使我们可以在磁带上写一个文件结束标志、倒带、越过指定个数的文件或记录等，对这些设备进行操作最容易的方法就是使用<code>ioctl</code>。</p>
<h2 id="dev-fd"><a href="#dev-fd" class="headerlink" title="/dev/fd"></a>/dev/fd</h2><p>较新的系统都提供名为<code>/dev/fd</code>的目录，其目录项是名为0、1、2等的文件。打开文件<code>/dev/fd/n</code>等效于复制操述符n(假定描述符n是打开的)。</p>
<p>在下列函数调用中；<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fd = open(<span class="string">"/dev/fd/0"</span>, node);</span><br></pre></td></tr></table></figure></p>
<p>大多数系统忽略它所指定的mode，而另外一些系统则要求mode必须是所引用的文件(在这里是标准输入)初始打开时所使用的打开模式的一个子集。因为上面的打开等效于<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fd = dup(<span class="number">0</span>);</span><br></pre></td></tr></table></figure></p>
<p>所以描述符<code>0</code>和<code>fd</code>共享同一文件表项。例如，若描述符0先前被打开为只读，那么我们也只能对fd进行读操作。即使系统忽略打开模式，而且下列调用是成功的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fd = open(<span class="string">"/dev/fd/0"</span>, O_RDWR);</span><br></pre></td></tr></table></figure></p>
<p>我们仍然不能对fd进行写操作。</p>
<p>Linux实现中的/dev/fd是个例外。它把文件描述符映射成指向底层物理文件的符号链接。例如，当打开<code>/dev/fd/0</code>时，事实，上正在打开与标准输入关联的文件，因此返回的新文件描述符的模式与<code>/dev/fd</code>文件描述符的模式其实并不相关。</p>
<p>我们也可以用<code>/dev/fd</code>作为路径名参数调用<code>creat</code>，这与调用<code>open</code>时用<code>O_CREAT</code>作为第2个参数作用相同。例如，若一个程序调用<code>creat</code>，并且路径名参数是<code>/dev/fd/1</code>，那么该程序仍能工作。</p>
<p>某些系统提供路径名<code>/dev/stdin</code>、<code>/dev/stdout</code>和<code>/dev/stderr</code>，这些等效于<code>/dev/fd/0</code>、<code>/dev/fd/1</code>和<code>/dev/fd/2</code>。<code>/dev/fd</code>文件主要由shell使用，它允许使用路径名作为调用参数的程序，能用处理其他路径名的相同方式处理标准输入和输出。例如，<code>cat(1)</code>命令对其命令行参数采取了一种特殊处理，它将单独的一个字符“-”解释为标准输入。例如：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filter file2 | cat file1 - file3 | lpr</span><br></pre></td></tr></table></figure></p>
<p>首先<code>cat</code>读<code>file1</code>，按着读其标准输入(也就是<code>filter file2</code>命令的输出)，然后读<code>file3</code>，如果支持<code>/dev/fd</code>，则可以删除cat对“-”的特殊处理，于是我们就可键入下列命令行；<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filter file2 | cat file1 /dev/fd/0 file3 | lpr</span><br></pre></td></tr></table></figure></p>
<p>作为命令行参数的“-”特指标准输入或标准输出，这已由很多程序采用。但是这会带来一些问题，例如，如果用”-”指定第一个文件，那么看来就像指定了命令行的一个选项。<code>/dev/fd</code>则提高了文件名参数的一致性，也更加清晰。</p>
<h1 id="文件和目录-1"><a href="#文件和目录-1" class="headerlink" title="文件和目录"></a>文件和目录</h1><h2 id="函数stat、fstat、fstatat和lstat"><a href="#函数stat、fstat、fstatat和lstat" class="headerlink" title="函数stat、fstat、fstatat和lstat"></a>函数stat、fstat、fstatat和lstat</h2><p>本章主要讨论4个stat函数以及它们的返回信息。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> pathmame, struct stat *<span class="keyword">restrict</span> buf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fstat</span><span class="params">(<span class="keyword">int</span> fd, struct stat *buf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lstat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> pathmame, struct stat *<span class="keyword">restrict</span> buf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fatatat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> pathname, struct stat *<span class="keyword">restrict</span> buf, <span class="keyword">int</span> flag)</span></span>;</span><br><span class="line">所有<span class="number">4</span>个函数的返回值，若成功，返回<span class="number">0</span>；若出错，返回<span class="number">-2</span></span><br></pre></td></tr></table></figure></p>
<p>一旦给出pathname，<code>stat</code>函数将返回与此命名文件有关的信息结构。<code>fstat</code>函数获得已在描述符<code>fd</code>上打开文件的有关信息。<code>lstat</code>函数类似于<code>stat</code>，但是当命名的文件是一个符号链接时，<code>lstat</code>返回该符号链接的有关信息，而不是由该符号链接引用的文件的信息。</p>
<p><code>fstatat</code>函数为一个相对于当前打开目录(由<code>fd</code>参数指向)的路径名返回文件统计信息。<code>flag</code>参数控制着是否跟随着一个符号链接。当<code>AT_SYMLINK_NOFOLLOW</code>标志被设置时，<code>fstatat</code>不会跟随符号链接，而是返回符号链接本身的信息。否则，在默认情况下，返同的是符号链接所指向的实际文件的信息。如果<code>fd</code>参数的值是<code>AT_FDCWD</code>，并且<code>pathname</code>参数是一个相对路径名，<code>fstatat</code>会计算相对于当前目录的pathname参数。如果pathname是一个绝对路径，后参数就会被忽略。这两种情况下，根据<code>flag</code>的取值，<code>fstatat</code>的作用就跟<code>stat</code>或<code>lstat</code>一样。</p>
<p>第2个参数<code>buf</code>是一个指针，它指向一个我们必须提供的结构。函数来填充由<code>buf</code>指向的结构。结构的实际定义可能随具体实现有所不同，但其基本形式是：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span></span><br><span class="line"><span class="keyword">mode_t</span>  st_mode;     <span class="comment">/* file type &amp; mode (permiosions) */</span></span><br><span class="line"><span class="keyword">ino_t</span>   st_ino;      <span class="comment">/* i-node number (serial number) */</span></span><br><span class="line"><span class="keyword">dev_t</span>   st_dev;      <span class="comment">/* device number (file system) */</span></span><br><span class="line"><span class="keyword">dev_t</span>   st_rdev;     <span class="comment">/* device nunber for special files */</span></span><br><span class="line"><span class="keyword">nlink_t</span> st_nlink;    <span class="comment">/* number of links */</span></span><br><span class="line"><span class="keyword">uid_t</span>   st_uid;      <span class="comment">/* user ID of owner */</span></span><br><span class="line"><span class="keyword">gid_t</span>   st_gid;      <span class="comment">/* group ID of owner */</span></span><br><span class="line"><span class="keyword">off_t</span>   st_sizes</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tinespec</span> <span class="title">st_atime</span>;</span> <span class="comment">/* time of last access */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st_mtime</span>;</span> <span class="comment">/* time of last modification */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tinespec</span> <span class="title">st_ctime</span>;</span> <span class="comment">/* time of last tille status change */</span></span><br><span class="line"><span class="keyword">blksize_t</span> st_blksizes     <span class="comment">/* best I/O block size */</span></span><br><span class="line"><span class="keyword">blkcnt_t</span>  st_blocks;      <span class="comment">/* number of disk blocks allocated */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>timespec</code>结构类型按照秒和纳秒定义了时间，至少包括下面两个字段：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">time_t</span> tv_sec;</span><br><span class="line"><span class="keyword">long</span>   tv_nsec;</span><br></pre></td></tr></table></figure></p>
<p>使用<code>stat</code>函数最多的地方可能就是<code>ls -l</code>命令，用其可以获得有关一个文件的所有信息。</p>
<h2 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h2><p>至此我们已经介绍了两种不同的文件类型：普通文件和目录。UNIX系统的大多数文件是普通文件或目录，但是也有另外一些文件类型。文件类型包括如下几种，</p>
<ul>
<li><strong>普通文件</strong>(regular file)。这是最常用的文件类型，这种文件包含了某种形式的数据。至于这种数据是文本还是二进制数据，对于UNIX内核而言并无区别。对普通文件内容的解释由处理该文件的应用程序进行。<ul>
<li>一个值得注意的例外是二进制可执行文件。为了执行程序，内被必须理解其格式。</li>
</ul>
</li>
<li><strong>目录文件</strong>(directory file)。这种文件包含了其他文件的名字以及指向与这些文件有关信息的指针。对一个目录文件具有读权限的任进程都可以读该目录的内容，但只有内核可以直接写目录文件。</li>
<li><strong>块特殊文件</strong>(block special file)。这种类型的文件提供对设备(如磁盘)带缓冲的访问，每次访问以固定长度为单位进行。</li>
<li><strong>字符特殊文件</strong>(character special fle)，这种类型的文件提供对设备不带缓冲的访问，每次访问长度可变。系统中的所有设备要么是字符特殊文件，要么是块特殊文件。</li>
<li><strong>FIFO</strong>。这种类型的文件用于进程间通信，有时也称为命名管道(named pipe)。</li>
<li><strong>套接字</strong>(socket)。这种类型的文件用于进程间的网络通信。套接字也可用于在一台宿主机上进程之间的非网络通信。</li>
<li><strong>符号链接</strong>(symbolic link)。这种类型的文件指向另一个文件。</li>
</ul>
<p>文件类型信息包含在<code>stat</code>结构的<code>st_mode</code>成员中。可以用表中的宏确定文件类型。这些宏的参数都是<code>stat</code>结构中的<code>st_mode</code>成员。</p>
<table>
<thead>
<tr>
<th>宏</th>
<th>文件类型</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>S_ISREG()</code></td>
<td>管通文件</td>
</tr>
<tr>
<td><code>S_ISDIR()</code></td>
<td>目录文件</td>
</tr>
<tr>
<td><code>S_ISCHR()</code></td>
<td>字符特殊文件</td>
</tr>
<tr>
<td><code>S_ISBLK()</code></td>
<td>块特殊文件</td>
</tr>
<tr>
<td><code>S_ISFIFO()</code></td>
<td>管道或FIFO</td>
</tr>
<tr>
<td><code>S_ISLNK()</code></td>
<td>符号链接</td>
</tr>
<tr>
<td><code>S_ISSOCK()</code></td>
<td>套楼字</td>
</tr>
</tbody>
</table>
<p>POSIX.1允许实现将进程间通信(IPC)对象(如消息队列和信号量等)说明为文件。表中的宏可用来从<code>stat</code>结构中确定IPC对象的类型。这些宏与上表中的不同，它们的参数并非<code>st_mode</code>，而是指向<code>stat</code>结构的指针。</p>
<table>
<thead>
<tr>
<th>宏</th>
<th>对象的类型</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>S_TYPEISMQ()</code></td>
<td>消息队列</td>
</tr>
<tr>
<td><code>S_TYPEISSEM()</code></td>
<td>信号量</td>
</tr>
<tr>
<td><code>S_TYPEISSHM()</code></td>
<td>共享存储对象</td>
</tr>
</tbody>
</table>
<p>程序取其命令行参数，然后针对每一个命令行参数打印其文件类型。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">buf</span>;</span></span><br><span class="line">    <span class="keyword">char</span> *ptr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; argc; i ++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s: "</span>, argv[i]);</span><br><span class="line">    <span class="keyword">if</span>(lstat(argv[i], &amp;buf) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        err.ret(<span class="string">"lstat error"</span>);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(S_ISREG(buf.st_mode))</span><br><span class="line">        ptr = <span class="string">"regular"</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(S_ISDIR(buf.st_mode))</span><br><span class="line">        ptr = <span class="string">"directory"</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (S_ISCHR(buf.st_mode))</span><br><span class="line">        ptr = <span class="string">"chacacter special"</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(S_ISBLK(buf.st_mode))</span><br><span class="line">        ptr = <span class="string">"block special"</span>,</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(S_ISFIFO(buf.st_mode))</span><br><span class="line">        ptr = <span class="string">"fifo"</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (S_ISLNK(buf.st_mode))</span><br><span class="line">        ptr = <span class="string">"symbolic link"</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(S_ISSOCK(buf.st_mode))</span><br><span class="line">        ptr = <span class="string">"Socket"</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    ptz = <span class="string">"*** unknown mode ***"</span>;</span><br><span class="line">    printl(<span class="string">"%s\n"</span>, ptr);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>早期的UNIX版本并不提供<code>S_ISxxx</code>宏，于是就需要将<code>st_mode</code>与屏蔽字<code>S_IFMT</code>进行逻辑“与”运算，然后与名为<code>S_IFxxx</code>的常量相比较。大多数系统在文件<code>&lt;sys/stat.h&gt;</code>中定义了此屏蔽字和相关的常量。如若查看此文件，则可找到<code>S_ISDIR</code>宏定义为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_ISDIR (mode) (((mode) &amp; S_IFMT) == S_IFDIR)</span></span><br></pre></td></tr></table></figure></p>
<h2 id="设置用户ID和设置组ID"><a href="#设置用户ID和设置组ID" class="headerlink" title="设置用户ID和设置组ID"></a>设置用户ID和设置组ID</h2><p>与一个进程相关联的ID有6个或更多</p>
<ul>
<li>我们实际上是谁<ul>
<li>实际用户ID</li>
<li>实际组ID</li>
</ul>
</li>
<li>用于文件访问权限检查<ul>
<li>有效用户ID</li>
<li>有效组ID</li>
<li>附属组ID</li>
</ul>
</li>
<li><p>由exec通数保存</p>
<ul>
<li>保存的设置用户ID</li>
<li>保存的设置组ID</li>
</ul>
</li>
<li><p>实际用户ID和实际组ID标识我们究竟是谁。这两个字段在登录时取自口令文件中的登录项。通常，在一个登录会话期间这些值并不改变，但是超级用户进程有方法改变它们。</p>
</li>
<li>有效用户ID、有效组ID以及附属组ID决定了我们的文件访问权限。</li>
<li>保存的设置用户ID和保存的设置组ID在执行一个程序时包含了有效用户ID和有效组ID的副本。</li>
</ul>
<p>通常，有效用户ID等于实际用户ID，有效组ID等于实际组ID。每个文件有一个所有者和组所有者，所有者由<code>stat</code>结构中的<code>st_uid</code>指定，组所有者则由<code>st_gid</code>指定。</p>
<p>当执行一个程序文件时，进程的有效用户ID通常就是实际用户ID，有效组ID通常是实际组ID。但是可以在文件模式字(<code>st_mode</code>)中设置一个特殊标志，其含义是“当执行此文件时，将进程的有效用户ID设置为文件所有者的用户ID(<code>st_uid</code>)”。与此相类似，在文件模式字中可以设置另一位。它将执行此文件的进程的有效组ID设置为文件的组所有者ID(<code>st_gid</code>)。在文件模式字中的这两位被称为设置用户ID(set-user-ID)位和设置组ID(set-group-ID)位。</p>
<h2 id="文件访问权限"><a href="#文件访问权限" class="headerlink" title="文件访问权限"></a>文件访问权限</h2><p><code>st_mode</code>值也包含了对文件的访问权限位。当提及文件时，指的是前面所提到的任何类型的文件。所有文件类型(目录、字符特别文件等)都有访问权限(access permission)。每个文件有9个访问权限位，可将它们分成3类：</p>
<table>
<thead>
<tr>
<th>st_mode屏蔽</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>S_IRUSR</td>
<td>用户读</td>
</tr>
<tr>
<td>S_IWUSR</td>
<td>用户写</td>
</tr>
<tr>
<td>S_IXUSR</td>
<td>用户执行</td>
</tr>
<tr>
<td>S_IRGRP</td>
<td>组读</td>
</tr>
<tr>
<td>S_IWGRP</td>
<td>组写</td>
</tr>
<tr>
<td>S_IXGRP</td>
<td>组执行</td>
</tr>
<tr>
<td>S_IROTH</td>
<td>其他读</td>
</tr>
<tr>
<td>S_IWOTH</td>
<td>其他写</td>
</tr>
<tr>
<td>S_IXOTH</td>
<td>其他执行</td>
</tr>
</tbody>
</table>
<p>在前3行中，术语用户指的是文件所有者(owner)。<code>chmod(1)</code>命令用于修改这9个权限位。该命令允许我们用u表示用户(所有者)，用g表示组，用o表示其他。</p>
<p>3类访问权限(即读、写及执行)以各种方式由不同的函数使用。我们将这些不同的使用方式汇总在下面。</p>
<ul>
<li>第一个规则是，我们用名字打开任一类型的文件时，对该名字中包含的每一个目录，包括它可能隐含的当前工作目录都应具有执行权限。这就是为什么对于目录其执行权限位常被称为搜索位的原因。<ul>
<li>例如，为了打开文件<code>/usr/include/stdio.h</code>，需要对目录<code>/</code>、<code>/usr</code>和<code>/usr/inciude</code>具有执行权限。然后，需要具有对文件本身的适当权限，这取决于以何种模式打开它。</li>
<li>如果当前目录是<code>/usr/include</code>，那么为了打开文件<code>stdio.h</code>，需要对当前目录有执行权限。这是隐含当前目录的一个示例，打开<code>stdio.h</code>文件与打开<code>./stdio.h</code>作用相同。</li>
<li>注意，对于目录的读权限和执行权限的意义是不相同的。读权限允许我们读目录，获得在该目录中所有文件名的列表。当一个目录是我们要访问文件的路径名的一个组成部分时，对该目录的执行权限使我们可通过该目录(也就是搜索该目录)，寻找一个特定的文件名</li>
</ul>
</li>
<li>对于一个文件的读权限决定了我们是否能够打开现有文件进行读操作。</li>
<li>对于一个文件的写权限决定了我们是否能够打开现有文件进行写操作。</li>
<li>为了在open函数中对一个文件指定<code>O_TRUNC</code>标志，必须对该文件具有写权限。</li>
<li>为了在一个目录中创建一个新文件，必须对该目录具有写权限和执行权限。</li>
<li>为了删除一个现有文件，必须对包含该文件的目录具有写权限和执行权限。对该文件本身则不需要有读、写权限。</li>
<li>如果用7个<code>exec</code>函数中的任何一个执行某个文件，都必须对该文件具有执行权限。该文件还必须是一个普通文件。</li>
</ul>
<p>进程每次打开、创建或删除一个文件时，内核就进行文件访问权限测试，而这种测试可能涉及文件的所有者(<code>st_uid</code>和<code>st_gid</code>)、进程的有效ID(有效用户ID和有效组ID)以及进程的附属组ID(若支持的话)。两个所有者ID是文件的性质，而两个有效ID和附属组ID则是进程的性质。内核进行的测试具体如下。</p>
<ol>
<li>若进程的有效用户D是0(超级用户)，则允许访问。这给予了超级用户对整个文件系统进行处理的最充分的自由。</li>
<li>若进程的有效用户ID等于文件的所有者ID(也就是进程拥有此文件)，那么如果所有者适当的访问权限位被设置，则允许访问；否则拒绝访问。适当的访问权限位指的是，若进程为读而打开该文件，则用户读位应为1；若进程为写而打开该文件，则用户写位应为1；若进程将执行该文件，则用户执行位应为1.</li>
<li>若进程的有效组ID或进程的附属组ID之一等于文件的组D，那么如果组适当的访问权限位被设置，则允许访问：否则拒绝访问，</li>
<li>若其他用户适当的访问权限位被设置，则允许访问：否则拒绝访问。</li>
</ol>
<p>按顺序执行这4步。注意，如果进程拥有此文件(第2步)，则按用户访问权限批准或拒绝该进程对文件的访问——不查看组访问权限。类似地，若进程并不拥有该文件。但进程属于某个适当的组，则按组访问权限批准或拒绝该进程对文件的访问——不查看其他用户的访问权限。</p>
<h2 id="新文件和目录的所有权"><a href="#新文件和目录的所有权" class="headerlink" title="新文件和目录的所有权"></a>新文件和目录的所有权</h2><p>新文件的用户ID设置为进程的有效用户ID。关于组ID，POSIX.1允许实现选择下列之一作为新文件的组ID。</p>
<ol>
<li>新文件的组D可以是进程的有效组ID.</li>
<li>新文件的组ID可以是它所在目录的组ID.</li>
</ol>
<p>使用POSIX.I所允许的第二个选项(继承目录的组ID)使得在某个目录下创建的文件和目录都具有该目录的组ID。于是文件和目录的组所有权从该点向下传递。</p>
<h2 id="函数access和faccessat"><a href="#函数access和faccessat" class="headerlink" title="函数access和faccessat"></a>函数access和faccessat</h2><p>当用open函数打开一个文件时，内核以进程的有效用户ID和有效组ID为基础执行其访问权限测试。有时，进程也希望按其实际用户ID和实际组ID来测试其访问能力。即使一个进程可能已经通过设置用户ID以超级用户权限运行，它仍可能想验证其实际用户能否访问一个给定的文件。<code>access</code>和<code>faccessat</code>函数是按实际用户ID和实际组ID进行访问权限测试的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line">int access(const char *pathmame, int mode):</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">faccessat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> mode, <span class="keyword">int</span> flag)</span></span>;</span><br><span class="line"><span class="comment">// 两个函数的返回值，若成功，返回0，若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>其中，如果测试文件是否已经存在，<code>mode</code>就为<code>F_OK</code>；否则<code>mode</code>是表中所列常量的按位或。</p>
<table>
<thead>
<tr>
<th>mode</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>R_OK</td>
<td>测试读权限</td>
</tr>
<tr>
<td>W_OK</td>
<td>测试写权限</td>
</tr>
<tr>
<td>X_OK</td>
<td>测试执行权限</td>
</tr>
</tbody>
</table>
<p><code>faccessat</code>函数与<code>access</code>函数在下面两种情况下是相同的：一种是<code>pathname</code>参数为绝对路径，另一种是<code>fd</code>参数取值为<code>AT_FDCWD</code>而<code>pathname</code>参数为相对路径。否则，<code>faccessat</code>计算相对于打开目录(由fd参数指向)的<code>pathname</code>。</p>
<p><code>flag</code>参数可以用于改变<code>faccessat</code>的行为，如果<code>flag</code>设置为<code>AT_EACCESS</code>，访问检查用的是调用进程的有效用户ID和有效组ID，而不是实际用户ID和实际组ID。</p>
<p>下文显示了<code>access</code>函数的使用方法。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">        err_quit(<span class="string">"usage: a.out &lt;pathname&gt;"</span>);</span><br><span class="line">    <span class="keyword">if</span>(access(argv[<span class="number">1</span>], R_OK) &lt; <span class="number">0</span>)</span><br><span class="line">        err_ret (<span class="string">"access error for %s"</span>, argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"read access OK\n"</span>);</span><br><span class="line">    <span class="keyword">if</span>(open(argv[<span class="number">1</span>], O_RDONLY) &lt; <span class="number">0</span>)</span><br><span class="line">        err_ret(<span class="string">"open error for %s"</span>, argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"open for reading OK\n"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在本例中，尽管open函数能打开文件，但通过设置用户ID程序可以确定实际用户不能正常读指定的文件。</p>
<h2 id="函数umask"><a href="#函数umask" class="headerlink" title="函数umask"></a>函数umask</h2><p><code>umask</code>函数为进程设置文件模式创建屏蔽字，并返回之前的值。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="keyword">mode_t</span> umask (<span class="keyword">mode_t</span> cmask);</span><br><span class="line"><span class="comment">// 返回值。之前的文件模式创建屏蔽字</span></span><br></pre></td></tr></table></figure></p>
<p>其中，参数<code>cmask</code>是之前列出的9个常量(<code>S_IRUSR</code>、<code>S_IWUSR</code>等)中的若干个按位“或”构成的。</p>
<p>在进程创建一个新文件或新目录时，就一定会使用文件模式创建屏蔽字。在文件模式创建屏蔽字中为1的位，在文件mode中的相应位一定被关闭。</p>
<p>程序创建了两个文件，创建第一个时，umask值为0，创建第二个时，umask值禁止所有组和其他用户的访问权限<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fenti.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RWRWRW(S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    umask (<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(creat(<span class="string">"foo"</span>, RWRWRW) &lt; <span class="number">0</span>)</span><br><span class="line">        err_sys(<span class="string">"creat error for foo"</span>);</span><br><span class="line">    umask(S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH);</span><br><span class="line">    <span class="keyword">if</span> (creat(<span class="string">"bar"</span>, RWRWRW) &lt; <span class="number">0</span>)</span><br><span class="line">        err_ays(<span class="string">"creat error for bar"</span>);</span><br><span class="line">    exif(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>若运行此程序可得如下结果，从中可见访问权限位是如何设置的。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">umask</span>         ;先打印当前文件模式创建屏蔽字</span><br><span class="line">002</span><br><span class="line">$ ./a.out</span><br><span class="line">$ ls -l foo bar</span><br><span class="line">-rw------- 1 sar 0 Dec 7 21:20 bar</span><br><span class="line">-rw-rw-rw- 1 sar 0 Dec 7 21:20 foo</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">umask</span>     ;观察文件模式创建屏蔽字是否更改</span><br><span class="line">002</span><br></pre></td></tr></table></figure></p>
<p>UNIX系统的大多数用户从不处理他们的umask值。通常在登录时，由shell的启动文件设置一次，然后，再不改变。尽管如此，当编写创建新文件的程序时，如果我们想确保指定的访问权限位已经激活，那么必须在进程运行时修改umask值。例如，如果我们想确保任何用户都能读文件，则应将umask设置为0。否则，当我们的进程运行时，有效的umask值可能关闭该权限位。</p>
<p>用户可以设置umask值以控制他们所创建文件的默认权限。该值表示成八进制数，一位代表一种要屏蔽的权限。设置了相应位后，它所对应的权限就会被拒绝。常用的几种umask值是002、022和027。002阻止其他用户写入你的文件，022阻止同组成员和其他用户写入你的文件，027阻止同组成员写你的文件以及其他用户读、写或执行你的文件。</p>
<table>
<thead>
<tr>
<th>屏蔽位</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>0400</td>
<td>用户读</td>
</tr>
<tr>
<td>0200</td>
<td>用户写</td>
</tr>
<tr>
<td>0100</td>
<td>用户执行</td>
</tr>
<tr>
<td>0040</td>
<td>组读</td>
</tr>
<tr>
<td>0020</td>
<td>组写</td>
</tr>
<tr>
<td>0010</td>
<td>组执行</td>
</tr>
<tr>
<td>0004</td>
<td>其他读</td>
</tr>
<tr>
<td>0002</td>
<td>其他写</td>
</tr>
<tr>
<td>0001</td>
<td>其他执行</td>
</tr>
</tbody>
</table>
<h2 id="函数chmod、fchmod和fchmodat"><a href="#函数chmod、fchmod和fchmodat" class="headerlink" title="函数chmod、fchmod和fchmodat"></a>函数chmod、fchmod和fchmodat</h2><p><code>chmod</code>、<code>fchmod</code>和<code>fchmodat</code>这3个函数使我们可以更改现有文件的访问权限。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ays/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chmod</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchmod</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchmodat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode, <span class="keyword">int</span> flag)</span></span>;</span><br><span class="line"><span class="comment">// 3个函数返回值：若成功，返回0；若出错。返回-1</span></span><br></pre></td></tr></table></figure></p>
<p><code>chmod</code>函数在指定的文件上进行操作，而<code>fchmod</code>函数则对已打开的文件进行操作。<code>fchmodat</code>函数与<code>chmod</code>函数在下面两种情况下是相同的：一种是<code>pathname</code>参数为绝对路径，另一种是<code>fd</code>参数取值为<code>AT_FDCWD</code>而<code>pathname</code>参数为相对路径。否则，<code>fchmodat</code>计算相对于打开目录(由<code>fd</code>参数指向)的<code>pathname</code>。<code>flag</code>参数可以用于改变<code>fchmodat</code>的行为，当设置了<code>AT_SYMLINK_NOFOLLOW</code>标志时，<code>fchmodat</code>并不会跟随符号链接。</p>
<p>为了改变一个文件的权限位，进程的有效用户D必须等于文件的所有者ID，或者该进程必须具有超级用户权限。参数mode是常量的按位或。</p>
<table>
<thead>
<tr>
<th>mode</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>S_ISUID</td>
<td>执行时设置用户D</td>
</tr>
<tr>
<td>S_ISGID</td>
<td>执行时设置组D</td>
</tr>
<tr>
<td>S_ISVTX</td>
<td>保存正文(粘着位)</td>
</tr>
<tr>
<td>S_IRWXU</td>
<td>用户(所有者)读、写和执行</td>
</tr>
<tr>
<td>S_IRUSR</td>
<td>用户(所有者)读</td>
</tr>
<tr>
<td>S_IWUSR</td>
<td>用户(所有者)写</td>
</tr>
<tr>
<td>S_IXUSR</td>
<td>用户(所有者)执行</td>
</tr>
<tr>
<td>S_IRWXG</td>
<td>组读、写和执行</td>
</tr>
<tr>
<td>S_IRGRP</td>
<td>组读</td>
</tr>
<tr>
<td>S_IWGRP</td>
<td>组写</td>
</tr>
<tr>
<td>S_IXGRP</td>
<td>组执行</td>
</tr>
<tr>
<td>S_IRWXO</td>
<td>其他读、写和执行</td>
</tr>
<tr>
<td>S_IROTH</td>
<td>其他读</td>
</tr>
<tr>
<td>S_IWOTH</td>
<td>其他写</td>
</tr>
<tr>
<td>S_IXOTH</td>
<td>其他执行</td>
</tr>
</tbody>
</table>
<p>注意，有9项是取自之前的9个文件访问权限位。我们另外加了6个，它们是两个设置ID常量(<code>S_ISUID</code>和<code>S_ISGID</code>)、保存正文常量(<code>S_ISVTX</code>)以及3个组合常量(<code>S_IRWXU</code>、<code>S_IRWXG</code>和<code>S_IRWXO</code>)。</p>
<p>程序修改了这两个文件的模式，<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">statbuf</span>;</span></span><br><span class="line">    <span class="comment">/* turn on set-group-ID and turn off group-execute */</span></span><br><span class="line">    <span class="keyword">if</span>(stat(<span class="string">"foo"</span>, &amp;statbuf) &lt; <span class="number">0</span>)</span><br><span class="line">        err_ays(<span class="string">"stat error for foo"</span>);</span><br><span class="line">    <span class="keyword">if</span>(chmod(<span class="string">"foo"</span>, (statbuf.st_mode &amp; ~S_IXGRP) | S_ISGID) &lt; <span class="number">0</span>)</span><br><span class="line">        err_sys (<span class="string">"chmod error for foo"</span>);</span><br><span class="line">    <span class="comment">/* set absolute mode to "rw-r--r--" */</span> </span><br><span class="line">    <span class="keyword">if</span>(chmod(<span class="string">"bar"</span>, S_IRUSR | S_IWUSR I S_IRGRP | S_IROTH) &lt; <span class="number">0</span>)</span><br><span class="line">        exr_sys(<span class="string">"chmod error for bar"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure></p>
<p>在运行程序后，这两个文件的最后状态是：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l foo bax</span><br><span class="line">-rw-r--r-- 1 sar    0 Dec 7 21:20  bar</span><br><span class="line">-rw-rwSrw- 1 sar    0 Dec 7 21:20  foo</span><br></pre></td></tr></table></figure></p>
<p>在本例中，不管文件bar的当前权限位如何，我们都将其权限设置为一个绝对值。对文件foo，我们相对于其当前状态设置权限。为此，先调用<code>stat</code>获得其当前权限，然后修改它。我们显式地打开了设置组ID位、关闭了组执行位。</p>
<p><code>chmod</code>函数在下列条件下自动清除两个权限位。</p>
<ul>
<li>Solaris等系统对用于普通文件的粘着位赋予了特殊含义，在这些系统上如果我们试图设置普通文件的粘着位(<code>S_ISVTX</code>)，且又没有超级用户权限，那么<code>mode</code>中的粘着位自动被关闭。这意味着只有超级用户才能设置普通文件的粘着位。这样做的理由是防止恶意用户设置粘着位，由此影响系统性能。</li>
<li>新创建文件的组ID可能不是谓用进程所属的组。特别地，如果新文件的组ID不等于进程的有效组ID或者进程附属组ID中的一个，而且进程没有超级用户权限，那么设置组ID位会被自动被关闭。这就防止了用户创建一个设置组ID文件，而该文件是由并非该用户所属的组拥有的。</li>
</ul>
<h2 id="粘着位"><a href="#粘着位" class="headerlink" title="粘着位"></a>粘着位</h2><p><code>S_ISVTX</code>如果一个可执行程序文件的这一位被设置了，那么当该程序第一次被执行，在其终止时，程序正文部分的一个副本仍被保存在交换区(程序的正文部分是机器指令)。</p>
<p>这使得下次执行该程序时能较快地将其装载入内存。其原因是：通常的UNIX文件系统中，文件的各数据块很可能是随机存放的，相比较而言，交换区是被作为一个连续文件来处理的。对于在交换区中可以同时存放的设置了粘着位的文件数是有限制的，以免过多占用交换区空间，但无论如何这是一个有用的技术。因为在系统再次自举前，文件的正文部分总是在交换区中，这正是名字中“粘着”的由来。后来的UNIX版本称它为<strong>保存正文位</strong>(saved-textbit)，因此也就有了常量<code>S_ISVTX</code>。</p>
<p>如果对一个目录设置了粘着位，只有对该目录具有写权限的用户并且满足下列条件之一，才能删除或重命名该目录下的文件：</p>
<ul>
<li>拥有此文件；</li>
<li>拥有此目录：</li>
<li>是超级用户。</li>
</ul>
<p>目录<code>/tmp</code>和<code>/var/tmp</code>是设置粘着位的典型候选者，任何用户都可在这两个目录中创建文件。任一用户(用户、组和其他)对这两个目录的权限通常都是读、写和执行。但是用户不应能删除或重命名属于其他人的文件，为此在这两个目录的文件模式中都设置了粘着位。</p>
<h2 id="函数chown、fchown、fchownat和1chown"><a href="#函数chown、fchown、fchownat和1chown" class="headerlink" title="函数chown、fchown、fchownat和1chown"></a>函数chown、fchown、fchownat和1chown</h2><p>下面几个<code>chown</code>函数可用于更改文件的用户ID和组ID。如果两个参数<code>owner</code>或<code>group</code>中的任意一个是-1，则对应的ID不变。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chown</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathnome, <span class="keyword">uid_t</span> owner, <span class="keyword">gid_t</span> group)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchown</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">uid_t</span> owner, <span class="keyword">gid_t</span> group)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchownat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *pathrame, <span class="keyword">uid_t</span> owner, <span class="keyword">gid_t</span> group, <span class="keyword">int</span> flag)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lchown</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pariname, <span class="keyword">uid_t</span> owner, <span class="keyword">gid_t</span> group)</span></span>;</span><br><span class="line"><span class="comment">// 4个函数的返回值，若成功，返回0；若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>除了所引用的文件是符号链接以外，这4个函数的操作类似。在符号链接情况下，<code>lchown</code>和<code>fchownat</code>(设置了<code>AT_SYMLINK_NOFOLLOW</code>标志)更改符号链接本身的所有者，而不是该符号链接所指向的文件的所有者。</p>
<p><code>fchown</code>函数改变<code>fd</code>参数指向的打开文件的所有者，既然它在一个已打开的文件上操作，就不能用于改变符号链接的所有者，<code>fchownat</code>函数与<code>chown</code>或者<code>lchown</code>函数在下面两种情况下是相同的；一种是<code>pathname</code>参数为绝对路径，另一种是<code>fd</code>参数取值为<code>AT_PDCND</code>而<code>pathname</code>参数为相对路径。在这两种情况下，如果<code>flag</code>参数中设置了<code>AT_SYMLINK_NOFOLLOW</code>标志，<code>fchownat</code>与<code>lchown</code>行为相同，如果flag参数中清除了<code>AT_SYMLINK_NOFOLLOW</code>标志，则<code>fchownat</code>与<code>chown</code>行为相同。如果<code>fd</code>参数设置为打开目录的文件描述符，并且<code>pathname</code>参数是一个相对路径名，<code>fchownat</code>函数计算相对于打开目录的pathname。</p>
<p><code>_POSIX_CHOWN_RESTRICTED</code>常量可选地定义在头文件<code>&lt;unistd.h&gt;</code>中，而且总是可以用<code>pathconf</code>或<code>fpathconf</code>函数进行查询。此选项还与所引用的文件有关一可在每个文件系统基础上，使该选项起作用或不起作用。在下文中，如提及“若<code>_POSIX_CHOWN_RESTRICTED</code>生效”，则表示“这适用于我们正在淡及的文件”，而不管该实际常量是否在头文件中定义。</p>
<p>若<code>_POSIX_CHOWN_RESTRICTED</code>对指定的文件生效，则</p>
<ol>
<li>只有超级用户进程能更改该文件的用户ID:</li>
<li>如果进程拥有此文件(其有效用户ID等于该文件的用户ID)，参数owner等于-1或文件的用户ID，并且参数group等于进程的有效组ID成进程的附属组ID之一，那么一个非超级用户进程可以更改该文件的组ID</li>
</ol>
<p>这意味着，当<code>_POSIX_CHOWN_RESTRICTED</code>有效时，不能更改其他用户文件的用户ID。你可以更改你所拥用的文件的组ID，但只能改到你所属的组。如果这些函数由非超级用户进程调用，则在成功返回时，该文件的设置用户ID位和设置组ID位都被清除。</p>
<h2 id="文件长度"><a href="#文件长度" class="headerlink" title="文件长度"></a>文件长度</h2><p><code>stat</code>结构成员<code>st_size</code>表示以字节为单位的文件的长度。此字段只对普通文件、目录文件和符号链接有意义。</p>
<p>对于普通文件，其文件长度可以是0，在开始读这种文件时，将得到文件结束(end-of-file)指示。对于目录，文件长度通常是一个数(如16或512)的整倍数。</p>
<p>对于符号链接，文件长度是在文件名中的实际字节数。例如，在下面的例子中，文件长度7就是路径名<code>usr/lib</code>的长度：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lrwxrwxrwx 1 root  7 Sep 25 07:14 lib -&gt; usr/1ib</span><br></pre></td></tr></table></figure></p>
<p>(注意，因为符号链接文件长度总是由<code>st_size</code>指示，所以它并不包含通常C语言用作名字结尾的null字节。)</p>
<p>现今，大多数现代的UNIX系统提供字段<code>st_blksize</code>和<code>st_blocks</code>。其中，第一个是对文件I/O较合适的块长度，第二个是所分配的实际512字节块块数。为了提高效率，标准I/O库也试图一次读、写<code>st_blksize</code>个字节。</p>
<h3 id="文件中的空洞"><a href="#文件中的空洞" class="headerlink" title="文件中的空洞"></a>文件中的空洞</h3><p>我们提及普通文件可以包含空洞。空洞是由所设置的偏移量超过文件尾端，并写入了某些数据后造成的。作为一个例子，考虑下列情况：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l core</span><br><span class="line">-rw-r--r-- 8483248 Nov 18 12:18 core</span><br><span class="line">$ du -s core </span><br><span class="line">272 core</span><br></pre></td></tr></table></figure></p>
<p>文件core的长度稍稍超过8MB，可是du命令报告该文件所使用的磁盘空间总量是272个512字节块(即139264字节)。很明显，此文件中有很多空洞。</p>
<p>对于没有写过的字节位置，read函数读到的字节是0。如果执行下面的命令，可以看出正常的I/O操作读整个文件长度：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ wc -c core</span><br><span class="line">8483248 core</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>带-c选项的wc(l)命令计算文件中的字符数(字节)。</p>
</blockquote>
<p>如果使用实用程序(如cat(1)复制这个文件，那么所有这些空洞都会被填满，其中所有实际数据字节皆填写为0。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ cat core &gt; core.copy</span><br><span class="line">$ ls -l oore*</span><br><span class="line">-rw-r--r-- 1 sar 8483248 Nov 18 12:18 core</span><br><span class="line">-rw-rw-r-- 1 sar 8483248 Nov 18 12:27 core.copy</span><br><span class="line">$ du -s core*</span><br><span class="line">272     core</span><br><span class="line">16592   core.copy</span><br></pre></td></tr></table></figure></p>
<p>从中可见，新文件所用的实际字节数是8495 104(512 x 16592)。此长度与<code>ls</code>命令报告的长度不同，其原因是，文件系统使用了若干块以存放指向实际数据块的各个指针。</p>
<h2 id="文件截断"><a href="#文件截断" class="headerlink" title="文件截断"></a>文件截断</h2><p>有时我们需要在文件尾端处截去一些数据以缩短文件。将一个文件的长度截断为0是一个特例，在打开文件时使用<code>O_TRUNC</code>标志可以做到这一点。为了截断文件可以调用函数<code>truncate</code>和<code>ftruncate</code>。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">truncate</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *puthoume, <span class="keyword">ott_t</span> lempth)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ftruncate</span><span class="params">(<span class="keyword">int</span> fd, off_c length)</span> i</span></span><br><span class="line">两个函数的返回值，若成功，返回0；若出错。返回-1</span><br></pre></td></tr></table></figure></p>
<p>这两个函数将一个现有文件长度裁断为length。如果该文件以前的长度大于length，则超过length以外的数据就不再能访问。如果以前的长度小于length，文件长度将增加，在以前的文件尾端和新的文件尾端之间的数据将读作0(也就是可能在文件中创建了一个空洞)。</p>
<h2 id="文件系统-1"><a href="#文件系统-1" class="headerlink" title="文件系统"></a>文件系统</h2><p>目前，正在使用的UNIX文件系统有多种实现。例如. Solaris支持多种不同类型的磁盘文件系统：传统的基于BSD的UNIX文件系统(称为UFS)，读、写DOS格式软盘的文件系统(称为PCFS)，以及读CD的文件系统(称为HSFS)。UFS是以Berkeiey快速文件系统为基础的。</p>
<p>我们可以把一个磁盘分成一个或多个分区。每个分区可以包含一个文件系统，i节点是固定长度的记录项，它包含有关文件的大部分信息。<br><img src="/img/20210516123303.png" alt></p>
<p>如果更仔细地观察一个柱面组的i节点和数据块部分，则可以看到下图中所示的情况。</p>
<p>在图中有两个目录项指向同一个i节点。每个i节点中都有一个链接计数，其值是指向该i节点的目录项数。只有当链接计数减少至0时，才可删除该文件。这也是为什么删除一个目录项的函数被称之为unlink而不是delete的原因。在<code>stat</code>结构中，链接计数包含在<code>st_nlink</code>成员中，其基本系统数据类型是<code>nlink_t</code>。这种链接类型称为硬链接。<br><img src="/img/20210516231147.png" alt></p>
<p>另外一种链接类型称为符号链接(symbolic link)。符号链接文件的实际内容(在数据块中)包含了该符号链接所指向的文件的名字。在下面的例子中，目录项中的文件名是3个字符的字符串lib，而在该文件中包含了7个字节的数据<code>usr/lib</code>:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lrwxrwxrwx l root      7 sep 25 07:14 lib -&gt; /urs/lib</span><br></pre></td></tr></table></figure></p>
<p>该i节点中的文件类型是<code>S_IFLNK</code>，于是系统知道这是一个符号链接。</p>
<p>i节点包含了文件有关的所有信息，文件类型、文件访问权限位、文件长度和指向文件数据块的指针等。<code>stat</code>结构中的大多数信息都取自1节点。只有两项重要数据存放在目录项中：文件名和i节点编号。i节点编号的数据类型是<code>ino_t</code>。</p>
<p>因为目录项中的节点编号指向同一文件系统中的相应节点，一个目录项不能指向另一个文件系统的i节点。</p>
<p>当在不更换文件系统的情况下为一个文件重命名时，该文件的实际内容并未移动，只需构造一个指向现有i节点的新目录项，并删除老的目录项。链接计数不会改变。例如，为将文件<code>/usr/lib/foo</code>重命名为<code>/usr/foo</code>，如果目录<code>/usr/lib</code>和<code>/usr</code>在同一文件系统中，则文件foo的内容无需移动。</p>
<p>假定我们在工作目录中构造了一个新目录：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir testdir</span><br></pre></td></tr></table></figure></p>
<p>下图显示了其结果。注意，该图显式地显示了<code>.</code>和<code>..</code>目录项。编号为2549的i节点，其类型字段表示它是一个目录，链接计数为2。任何一个叶目录(不包含任何其他目录的目录)的链接计数总是2。数值2来自于命名该目录(testdir)的目录项以及在该目录中的<code>.</code>项。</p>
<p>编号为1267的i节点，其类型字段表示它是一个目录，链接计数大于或等于3。它大于或等于3的原因是，至少有3个目录项指向它一个是命名它的目录项，第二个是在该目录中的<code>.</code>项，第三个是在其子目录testdir中的<code>..</code>项。注意，在父目录中的每一个子目录都使该父目录的链接计数增加1。<br><img src="/img/20210516231950.png" alt></p>
<h2 id="函数1ink、linkat、unlink、unlinkat和remove"><a href="#函数1ink、linkat、unlink、unlinkat和remove" class="headerlink" title="函数1ink、linkat、unlink、unlinkat和remove"></a>函数1ink、linkat、unlink、unlinkat和remove</h2><p>如上节所述。任何一个文件可以有多个目录项指向其i节点。创建一个指向现有文件的链接的方法是使用<code>link</code>函数或<code>linkat</code>函数<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">link</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *existingpath, <span class="keyword">const</span> chaz *newpath)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">linkat</span><span class="params">(<span class="keyword">int</span> efd, <span class="keyword">const</span> <span class="keyword">char</span> *existingpash, <span class="keyword">int</span> nfd, <span class="keyword">const</span> <span class="keyword">char</span> *newpath, <span class="keyword">int</span> flag)</span></span>;</span><br><span class="line"><span class="comment">// 两个函数的返回值。若成功，返回0，若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>这两个函数创建一个新目录项newpath，它引用现有文件existingpath。如果newpath已经存在，则返回出错。只创建newpath中的最后一个分量，路径中的其他部分应当已经存在。</p>
<p>对于<code>linkat</code>函数，现有文件是通过efd和existingpath参数指定的，新的路径名是通过nfd和newpath参数指定的。默认情况下，如果两个路径名中的任一个是相对路径，那么它需要通过相对于对应的文件描述符进行计算。如果两个文件描述符中的任一个设置为<code>AT_FDCWD</code>，那么相应的路径名(如果它是相对路径)就通过相对于当前目录进行计算。如果任一路径名是绝对路径，相应的文件描述符参数就会被忽略</p>
<p>当现有文件是符号链接时，由flag参数来控制<code>linkat</code>函数是创建指向现有符号链接的链接还是创建指向现有符号链接所指向的文件的链接。如果在flag参数中设置了<code>AT_SYMLINK_FOLLOW</code>标志，就创建指向符号链接目标的链接。如果这个标志被清除了，则创建一个指向符号链接本身的链接。</p>
<p>创建新目录项和增加链接计数应当是一个原子操作。虽然POSIX.1允许实现支持跨越文件系统的链接，但是大多数实现要求现有的和新建的两个路径名在同一个文件系统中。如果实现支持创建指向一个目录的硬链接，那么也仅限于超级用户才可以这样做。其理由是这样做可能在文件系统中形成循环，大多数处理文件系统的实用程序都不能处理这种情况。因此，很多文件系统实现不允许对于目录的硬链接</p>
<p>为了剩除一个现有的目录项，可以调用unlink函数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">unlink</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">unlinkat</span> <span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *pathnome, <span class="keyword">int</span> flag)</span></span>;</span><br><span class="line"><span class="comment">// 两个函数的返回值。若成功。返回0，若出错。返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>这两个函数删除目录项，并将由pathname所引用文件的链接计数减1。如果对该文件还有其他链接，则仍可通过其他链接访问该文件的数据。如果出错，则不对该文件做任何更改。我们在前面已经提及，为了解除对文件的链接，必须对包含该目录项的目录具有写和执行权限。如果对该目录设置了粘着位，则对该目录必须具有写权限，并且具备下面三个条件之一：</p>
<ul>
<li>拥有该文件：</li>
<li>拥有该目录：</li>
<li>具有超级用户权限。</li>
</ul>
<p>只有当链接计数达到0时，该文件的内容才可被删除。另一个条件也会阻止删除文件的内容——只要有进程打开了该文件，其内容也不能剩除。关闭一个文件时，内核首先检查打开该文件的进程个数：如果这个计数达到0，内核再去检查其链接计数：如果计数也是0，那么就删除该文件的内容。</p>
<p>如果pathname参数是相对路径名，那么unlinkat函数计算相对于由fd文件描述符参数代表的目录的路径名。如果fd参数设置为<code>AT_FDCWD</code>，那么通过相对于调用进程的当前工作目录来计算路径名。如果pathname参数是绝对路径名，那么fd参数被忽略。</p>
<p>flag参数给出了一种方法，使调用进程可以改变<code>unlinkat</code>函数的默认行为，当<code>AT_REMOVEDIR</code>标志被设置时，<code>unlinkat</code>函数可以类似于rmdir一样删除目录。如果这个标志被清除，<code>unlinkat</code>与<code>unlink</code>执行同样的操作。</p>
<p>程序打开一个文件，然后解除它的链接。执行该程序的进程然后睡眠15秒，接着就终止<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcnt1.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (open(<span class="string">"tempfile"</span>, O_RDWR) &lt; <span class="number">0</span>)</span><br><span class="line">        err_sys(<span class="string">"open error"</span>);</span><br><span class="line">    <span class="keyword">if</span> (unlink(<span class="string">"tempfile"</span>) &lt; <span class="number">0</span>)</span><br><span class="line">            err_sys (<span class="string">"unlink error"</span>);</span><br><span class="line">    printt(<span class="string">"flle unlinked\n"</span>);</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">15</span>);</span><br><span class="line">    printt(<span class="string">"done\n"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure></p>
<p>运行该程序，其结果是：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l tempfile   <span class="comment">#查看文件大小</span></span><br><span class="line">-rw-r-----  1 sar  413265408 Jan 21 07:14 tempfile</span><br><span class="line">$ df / home        <span class="comment">#检查可用磁盘空间</span></span><br><span class="line">Filesystem lK-blocks    Used Avallable Use% Mounted on</span><br><span class="line">/dev/hda4   11021440 1956332   9065108 18%  /home</span><br><span class="line">$ ./a.out &amp;        <span class="comment">#在后台运行程序</span></span><br><span class="line">1364               <span class="comment">#shell打印其进程ID</span></span><br><span class="line">$ file unlinked    <span class="comment">#解除文件链接</span></span><br><span class="line">ls -l tempfile     <span class="comment">#观察文件是否仍然存在</span></span><br><span class="line">ls: tempfile: No such tile or directory    <span class="comment">#目录项已剩除</span></span><br><span class="line">$ df /home         <span class="comment">#检查可用磁盘空间有无变化</span></span><br><span class="line">Filesystem lK-blocks    Used Available Use% Mounted on</span><br><span class="line">/dev/hda4   11021440 1956332  9065108 18%    /home</span><br><span class="line">$ <span class="keyword">done</span>             <span class="comment">#程序执行结束，关闭所有打开文件</span></span><br><span class="line">df /home           <span class="comment">#现在，应当有更多可用磁盘空间</span></span><br><span class="line">Filesysten lK-blocks    Used Available Use% mounted on</span><br><span class="line">/dev/hda4   11021440 1552352   9469088 15% /home</span><br><span class="line"><span class="comment">#现在，394.1MB磁盘空间可用</span></span><br></pre></td></tr></table></figure></p>
<p>unlink的这种特性经常被程序用来确保即使是在程序崩溃时，它所创建的临时文件也不会遭留下来。进程用open或creat创建一个文件，然后立即调用unlink，因为该文件仍旧是打开的，所以不会将其内容删除，只有当进程关闭该文件或终止时(在这种情况下，内核关闭该进程所打开的全部文件)，该文件的内容才被剥除，如果pathname是符号链接，那么uniink删除该符号链接，而不是删除由该链接所引用的文件。给出符号链接名的情况下，没有一个函数能剩除由该链接所引用的文件。</p>
<p>如果文件系统支持的话，超级用户可以调用<code>unlink</code>，其参数pathname指定一个目录，但是通常应当使用rmdir函数，而不使用unlink这种方式。</p>
<p>我们也可以用<code>remove</code>函数解除对一个文件或目录的链接。对于文件，<code>remove</code>的功能与<code>unlink</code>相同。对于目录，<code>remove</code>的功能与<code>rmdir</code>相同。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">remove</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span>;</span><br><span class="line"><span class="comment">// 返回值，若成功，返回0，若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>ISO C指定<code>remove</code>函数删除一个文件，这更改了UNIX历来使用的名字<code>unlink</code>，其原因是实现C标准的大多数察UNIX系统并不支持文件链接；</p>
<h2 id="函数rename和renameat"><a href="#函数rename和renameat" class="headerlink" title="函数rename和renameat"></a>函数rename和renameat</h2><p>文件或目录可以用rename函数或者renameat函数进行重命名。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rename</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *oldname, <span class="keyword">const</span> <span class="keyword">char</span> *newname)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">renameat</span> <span class="params">(<span class="keyword">int</span> oldfd, <span class="keyword">const</span> <span class="keyword">char</span> *oldname, <span class="keyword">int</span> newfd, <span class="keyword">const</span> <span class="keyword">char</span> *newname)</span></span>;</span><br><span class="line"><span class="comment">// 两个函数的返回值。若成功，返回0，若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>根据oldname是指文件、目录还是符号链接，有几种情况需要加以说明。我们也必须说明如果newname已经存在时将会发生什么。</p>
<ol>
<li>如果oldname指的是一个文件而不是目录，那么为该文件或符号链接重命名。在这种情况下，如果newname已存在，则它不能引用一个目录。如果newname已存在，而且不是一个目录，则先将该目录项删除然后将oldname重命名为newname。对包含oldname的目录以及包含newname的目录，调用进程必须具有写权限，因为将更改这两个目录。</li>
<li>如若oldname指的是一个目录，那么为该目录重命名。如果newname已存在，则它必须引用一个目录，而且该目录应当是空目录。如果newname存在(而且是一个空目录)，则先将其剩除，然后将oldname重命名为newname。另外，当为一个目录重命名时，newname不能包含oldname作为其路径前缀。例如，不能将<code>/usr/foo</code>重命名为<code>/usr/foo/testdir</code>，因为旧名字(<code>/usr/foo</code>)是新名字的路径前缀，因而不能将其删除。</li>
<li>如着oldname成newname引用符号链接，则处理的是符号链接本身，而不是它所引用的文件。</li>
<li>不能对<code>.</code>和<code>..</code>重命名。更确切地说， <code>.</code>和<code>..</code>都不能出现在oldname和newname的最后部分。</li>
<li>作为一个特例，如果oldname和newname引用同一文件，则函数不做任何更改而成功返回。</li>
</ol>
<p>如若newname已经存在，则调用进程对它需要有写权限(如同剧除情况一样)。另外，调用进程将删除oldname目录项，并可能要创建newname目录项，所以它需要对包含oldname及包含newname的目录具有写和执行权限。</p>
<p>除了当oldname或newname指向相对路径名时，其他情况下<code>renameat</code>函数与<code>rename</code>函数功能相同，如果oldhame参数指定了相对路径，就相对于<code>oldfd</code>参数引用的目录来计算oldname。类似地，如果newname指定了相对路径，就相对于<code>newfd</code>引用的目录来计算newname。<code>oldfd</code>或<code>newfd</code>参数(或两者)都能设置成<code>AT_FDCWD</code>，此时相对于当前目录来计算相应的路径名。</p>
<h2 id="符号链接"><a href="#符号链接" class="headerlink" title="符号链接"></a>符号链接</h2><p>符号链接是对一个文件的间接指针，硬链接直接指向文件的i节点。引入符号链接的原因是为了避开硬链接的限制：</p>
<ul>
<li>硬链接通常要求链接和文件位于同一文件系统中，</li>
<li>只有超级用户才能创建指向目录的硬链接(在底层文件系统支持的情况下)。</li>
</ul>
<p>对符号链接以及它指向何种对象并无任何文件系统限制，任何用户都可以创建指向目录的符号链接。符号链接一般用于将一个文件或整个目录结构移到系统中另一个位置。当使用以名字引用文件的函数时，应当了解该函数是否处理符号链接。也就是该函数是否跟随符号链接到达它所链接的文件。如若该函数具有处理符号链接的功能，则其路径名参数引用由符号链接指向的文件。否则，一个路径名参数引用链接本身，而不是由该链接指向的文件。</p>
<p>下表列出了本章中所说明的各个函数是否处理符号链接。在表中没有列出<code>mkdir</code>、<code>mkinfo</code>、<code>mknod</code>和<code>rmdir</code>这些函数，其原因是，当路径名是符号链接时，它们都出错返回。以文件描述符作为参数的一些函数(如<code>fstat</code>、<code>fchmod</code>等)也未在该表中列出，其原因是，对符号链接的处理是由返回文件描述符的函数(通常是<code>open</code>)进行的。<code>chown</code>是否跟随符号链接取决于实现。</p>
<p><img src="/img/20210517004519.png" alt></p>
<p>上表的一个例外是，同时用<code>O_CREAT</code>和<code>O_EXCL</code>两者调用<code>open</code>函数。在此情况下，若路径名引用符号链接，<code>open</code>将出错返回，errno设置为<code>EEXIST</code>，这种处理方式的意图是堵寨一个安全性漏洞，以防止具有特权的进程被诱骗写错误的文件。</p>
<p>使用符号链接可能在文件系统中引入循环。大多数查找路径名的函数在这种情况发生时都将出错返回，errno值为<code>ELOOP</code>。</p>
<p>用<code>open</code>打开文件时，如果传递给<code>open</code>函数的路径名指定了一个符号链接，那么<code>open</code>跟随此链接到达所指定的文件。若此符号链接所指向的文件并不存在，则<code>open</code>返回出错，表示它不能打开该文件。这可能会使不熟悉符号链接的用户感到迷惑，例如：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ ln -s /no/such/file myfile    <span class="comment">#创建一个符号链接</span></span><br><span class="line">$ ls myfile</span><br><span class="line">myfile</span><br><span class="line"></span><br><span class="line">$ cat myfile    <span class="comment">#试图查看该文件</span></span><br><span class="line">cat: myfile: No such tile or directory</span><br><span class="line">$ ls -l myfile  <span class="comment"># 尝试-l选项</span></span><br><span class="line">lrwxrwxrwx 1 sar 13 Jan 22 00:26 myfile -&gt; /no/such/file</span><br></pre></td></tr></table></figure></p>
<p>文件myfile存在，但cat却称没有这一文件。其原因是myfile是个符号链接，由该符号链接所指向的文件并不存在。ls命令的<code>-l</code>选项给我们两个提示：第一个字符是<code>l</code>，它表示这是一个符号链接，而<code>-&gt;</code>也表明这是一个符号链接。<code>ls</code>命令还有另一个选项<code>-F</code>，它会在符号链接的文件名后加一个<code>@</code>符号，在未使用<code>-l</code>选项时，这可以帮助我们识别出符号链接。</p>
<h2 id="创建和读取符号链接"><a href="#创建和读取符号链接" class="headerlink" title="创建和读取符号链接"></a>创建和读取符号链接</h2><p>可以用<code>symlink</code>或<code>symlinkat</code>函数创建一个符号链接。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">symlink</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *actualpath, <span class="keyword">const</span> <span class="keyword">char</span> *sympath)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">symlinkat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *actualpath, <span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *sympath)</span></span>;</span><br><span class="line"><span class="comment">// 两个函数的返回值。若成功，返回0，若出错。返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>函数创建了一个指向<code>actualpath</code>的新目录项<code>sympath</code>。在创建此符号链接时，并不要求<code>actualpath</code>已经存在。并且，<code>actualpath</code>和<code>sympath</code>并<br>不需要位于同一文件系统中。</p>
<p><code>symlinkat</code>函数与<code>symlink</code>函数类似，但<code>sympath</code>参数根据相对于打开文件描述符引用的目录(由<code>fd</code>参数指定)进行计算。如果<code>sympath</code>参数指定的是绝对路径或者<code>fd</code>参数设置了<code>AT_FDCWD</code>值，那么<code>symlinkat</code>就等同于<code>symlink</code>函数。</p>
<p>因为<code>open</code>函数跟随符号链接，所以需要有一种方法打开该链接本身，并读该链接中的名字。<code>readlink</code>和<code>readlinkat</code>函数提供了这种功能。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.b&gt;</span></span></span><br><span class="line"><span class="keyword">ssize_t</span> readlink (<span class="keyword">const</span> <span class="keyword">char</span> *restriet parhname, <span class="keyword">char</span> *<span class="keyword">restrict</span> buf, <span class="keyword">size_t</span> bufsize);</span><br><span class="line"><span class="keyword">ssize_t</span> readlinkat (<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">restrict</span> pathrame, <span class="keyword">char</span> *<span class="keyword">restrict</span> buf, <span class="keyword">size_t</span> bufsize);</span><br><span class="line"><span class="comment">// 两个函数的返回值，若成功，返回读取的字节数，若出错。返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>两个函数组合了<code>open</code>、<code>read</code>和<code>close</code>的所有操作。如果函数成功执行，则返回读入buf的字节数。在buf中返回的符号链接的内容不以null字节终止。当<code>pathname</code>参数指定的是绝对路径名或者<code>fd</code>参数的值为<code>AT_FDCWD</code>，<code>readlinkat</code>函数的行为与<code>readlink</code>相同。但是，如果<code>fd</code>参数是一个打开目录的有效文件描述符并且<code>pathname</code>参数是相对路径名，则<code>readlinkat</code>计算相对于由<code>fd</code>代表的打开目录的路径名。</p>
<h2 id="文件的时间"><a href="#文件的时间" class="headerlink" title="文件的时间"></a>文件的时间</h2><p>每个文件属性所保存的实际精度依赖于文件系统的实现。对于把时间戳记录在秒级的文件系统来说，纳秒这个字段就会被填充为0。对于时间戳的记录精度高于秒级的文件系统来说，不足秒的值被转换成纳秒并记录在纳秒这个字段中。对每个文件维护3个时间字段，它们的意义示于表。</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
<th>例子</th>
<th>ls(l)选项</th>
</tr>
</thead>
<tbody>
<tr>
<td>st_atim</td>
<td>文件数据的最后访问时间</td>
<td>read</td>
<td>-u</td>
</tr>
<tr>
<td>st_ntim</td>
<td>文件教据的最后修改时间</td>
<td>write</td>
<td>默认</td>
</tr>
<tr>
<td>st_ctim</td>
<td>节点状态的最后更改时间</td>
<td>chmod、chown</td>
<td>-c</td>
</tr>
</tbody>
</table>
<p>注意，修改时间(<code>st_mtim</code>)和状态更改时间(<code>st_ctim</code>)之间的区别。修改时间是文件内容最后一次被修改的时间。状态更改时间是该文件的i节点最后一次被修改的时间。因为i节点中的所有信息都是与文件的实际内容分开存放的，所以，要记录文件数据修改时间和更改i节点中信息的时间。</p>
<p>图列出了我们已说明过的各种函数对这3个时间的作用。增加、删除或修改目录项会影响到它所在目录相关的3个时间。这就是在图中包含两列的原因，其中一列是与该文件(或目录)相关的3个时间，另一列是与所引用的文件(或目录)的父目录相关的3个时间。例如，创建一个新文件影响到包含此新文件的目录，也影响该新文件的i节点。但是，读或写一个文件只影响该文件的i节点，而对目录则无影响。<br><img src="/img/1621242103.jpg" alt></p>
<h2 id="函数futimens、utimensat和utimes"><a href="#函数futimens、utimensat和utimes" class="headerlink" title="函数futimens、utimensat和utimes"></a>函数futimens、utimensat和utimes</h2><p>一个文件的访问和修改时间可以用以下几个函数更改。<code>futimens</code>和<code>utimensat</code>函数可以指定纳秒级精度的时间戳。用到的数据结构是与<code>stat</code>函数族相同的<code>timespec</code>结构。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">futimens</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct timespec times[<span class="number">2</span>])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">utimensat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> struct timespec times[<span class="number">2</span>], <span class="keyword">int</span> flag)</span></span>;</span><br><span class="line"><span class="comment">// 两个函数返回值，若成功，返回0，若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>这两个函数的<code>times</code>数组参数的第一个元素包含访问时间，第二元素包含修改时间。这两个时间值是日历时间。不足秒的部分用纳秒表示，时间戳可以按下列4种方式之一进行指定：</p>
<ol>
<li>如果<code>times</code>参数是一个空指针，则访问时间和修改时间两者都设置为当前时间。</li>
<li>如果<code>times</code>参数指向两个<code>timespec</code>结构的数组，任一数组元素的<code>tv_nsec</code>字段的值为<code>UTIME_NOW</code>，相应的时间戳就设置为当前时间，忽略相应的<code>tv_sec</code>字段。</li>
<li>如果<code>times</code>参数指向两个<code>timespec</code>结构的数组，任一数组元素的<code>tv_nsec</code>字段的值为<code>UTIME_OMIT</code>，相应的时间戳保持不变，忽略相应的<code>tv_sec</code>字段。</li>
<li>如果<code>rimes</code>参数指向两个<code>timespec</code>结构的数组，且<code>tv_nsec</code>字段的值为既不是<code>UTIME_NOW</code>也不是<code>UTIME_OMIT</code>，在这种情况下，相应的时间戳设置为相应的<code>tv_sec</code>和<code>tv_nsec</code>字段的值。</li>
</ol>
<p>执行这些函数所要求的优先权取决于times参数的值。</p>
<ul>
<li>如果<code>times</code>是一个空指针，或者任一<code>tv_nsec</code>字段设为<code>UTIME_NOW</code>，则进程的有效用户ID必须等于该文件的所有者ID进程对该文件必须具有写权限，或者进程是一个超级用户进程。</li>
<li>如果<code>times</code>是非空指针，并且任一<code>tv_nsec</code>字段的值既不是<code>UTIME_NOW</code>也不是<code>UTIME_OMIT</code>，则进程的有效用户ID必须等于该文件的所有者ID，或者进程必须是一个超级用户进程。对文件只具有写权限是不够的</li>
<li>如果<code>times</code>是非空指针，并且两个<code>tv_nec</code>字段的值都为<code>UTIME_OMIT</code>，就不执行任何的权限检查</li>
</ul>
<p><code>futimens</code>函数需要打开文件来更改它的时间，<code>utimensat</code>函数提供了一种使用文件名更改文件时间的方法。<code>pathname</code>参数是相对于<code>fd</code>参数进行计算的，<code>fd</code>要么是打开目录的文件描述符，要么设置为特殊值<code>AT_FDCWD</code>。如果<code>pathname</code>指定了绝对路径，那么<code>fd</code>参数被忽略，<code>utimensat</code>的<code>flag</code>参数可用于进一步修改默认行为，如果设置了<code>AT_SYMLINK_NOFOLLOW</code>标志，则符号链接本身的时间就会被修改。默认的行为是跟随符号链接，并把文件的时间改成符号链接的时间。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">utimes</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">const</span> struct timeval times[<span class="number">2</span>])</span></span>;</span><br><span class="line"><span class="comment">// 函数返回值。若成功，返回0，若出错，返回-1</span></span><br></pre></td></tr></table></figure>
<p><code>utimes</code>函数对路径名进行操作。<code>times</code>参数是指向包含两个时间戳(访问时间和修改时间)元素的数组的指针，两个时间戳是用秒和微妙表示的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line"><span class="keyword">time_t</span> tv_sec; <span class="comment">/* seconds */</span></span><br><span class="line"><span class="keyword">long</span> tv_usec; <span class="comment">/* microseconds */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>注意，我们不能对状态更改时间<code>st_ctim</code>(i节点最近被修改的时间)指定一个值，因为调用<code>utimes</code>函数时，此字段会被自动更新。</p>
<p>程序使用带<code>O_TRUNC</code>选项的<code>open</code>函数将文件长度截断为0，但并不更改其访问时间及修改时间。为了做到这一点，首先用<code>stat</code>函数得到这些时间，然后截断文件，最后再用<code>futimens</code>函数重置这两个时间。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">statbuf</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">times</span>[2];</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; argc; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(stat(argv[i], &amp;statbuf) &lt; <span class="number">0</span>) &#123; <span class="comment">/* fetch current times */</span></span><br><span class="line">            err_ret(<span class="string">"%s: stat error"</span>, argv[i]);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((fd = open(argv[i], O_RDWR | O_TRUNC)) &lt; <span class="number">0</span>) &#123; <span class="comment">/*truncate */</span></span><br><span class="line">            err_ret(<span class="string">"%s: open error"</span>, argv[i]);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        times[<span class="number">0</span>] = statbuf.st_atin;</span><br><span class="line">        times[<span class="number">1</span>] = statbuf.st_mtim;</span><br><span class="line">        <span class="keyword">if</span>(futimens(fd, times) &lt; <span class="number">0</span>) <span class="comment">/* reset times */</span></span><br><span class="line">            err_ret (<span class="string">"%s: futinens error"</span>, argv[i]);</span><br><span class="line">        close (fd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="函数mkdir-mkdirat和rmdir"><a href="#函数mkdir-mkdirat和rmdir" class="headerlink" title="函数mkdir, mkdirat和rmdir"></a>函数mkdir, mkdirat和rmdir</h2><p>用<code>mkdir</code>和<code>mkdirat</code>函数创建目录，用<code>rmdir</code>函数删除目录。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ays/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkdirat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line"><span class="comment">// 两个函数返回值。若成功，返回0;若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>这两个函数创建一个新的空目录。其中<code>.</code>和<code>..</code>目录项是自动创建的。所指定的文件访问权限<code>mode</code>由进程的文件模式创建屏蔽字修改。常见的错误是指定与文件相同的<code>mode</code>(只指定读、写权限)。但是，对于目录通常至少要设置一个执行权限位，以允许访问该目录中的文件名。</p>
<p><code>mkdirat</code>函数与<code>mkdir</code>函数类似。当<code>fd</code>参数具有特殊值<code>AT_FDCWD</code>或者<code>pathname</code>参数指定了绝对路径名时，<code>mkdirat</code>与<code>mkdir</code>完全一样。否则，<code>fd</code>参数是一个打开目录，相对路径名根据此打开目录进行计算。</p>
<p>用<code>rmdir</code>函数可以删除一个空目录。空目录是只包含<code>.</code>和<code>..</code>这两项的目录。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rmdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回0；若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>如果调用此函数使目录的链接计数成为0，并且也没有其他进程打开此目录，则释放由此目录占用的空间。如果在链接计数达到0时，有一个或多个进程打开此目录，则在此函数返回前删除最后一个链接及<code>.</code>和<code>..</code>项。另外，在此目录中不能再创建新文件。但是在最后一个进程关闭它之前并不释放此目录。</p>
<h2 id="读目录"><a href="#读目录" class="headerlink" title="读目录"></a>读目录</h2><p>对某个目录具有访问权限的任一用户都可以读该目录，但是，为了防止文件系统产生混乱，只有内核才能写目录。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="function">DIR *<span class="title">opendir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span>;</span><br><span class="line"><span class="function">DIR *<span class="title">fdopendir</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"><span class="comment">// 两个函数返回值：若成功，返回指针，若出错，返回NULL</span></span><br><span class="line"><span class="function">struct dirent *<span class="title">readdir</span><span class="params">(DIR *dp)</span></span>;</span><br><span class="line"><span class="comment">// 返回值。若成功，返回指针；若在目录尾或出错，返回NULL</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rewinddir</span><span class="params">(DIR *dp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">closedir</span><span class="params">(DIR *dp)</span></span>;</span><br><span class="line"><span class="comment">// 返回值：若成功。返回0；若出错，返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">telldir</span><span class="params">(DIR* dp)</span></span>;</span><br><span class="line"><span class="comment">// 返回值，与中关联的目录中的当前位置</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">seekdir</span> <span class="params">(DIR* dp, <span class="keyword">long</span> loc)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p><code>fdopendir</code>函数提供了一种方法，可以把打开文件描述符转换成目录处理函数需要的<code>DIR</code>结构。定义在头文件<code>&lt;dirent.h&gt;</code>中的<code>dirent</code>结构与实现有关。实现对此结构所做的定义至少包含下列两个成员：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ino_t</span> d_ino;   <span class="comment">/* i-node number */</span></span><br><span class="line"><span class="keyword">char</span> d_name[]; <span class="comment">/* null-terninated tilename */</span></span><br></pre></td></tr></table></figure></p>
<p>注意，<code>d_name</code>项的大小并没有指定，但必须保证它能包含至少<code>NAME_MAX</code>个字节(不包含终止null字节)。因为文件名是以null字节结束的，所以在头文件中如何定义数组<code>d_name</code>并无多大关系，数组大小并不表示文件名的长度。</p>
<p><code>DIR</code>结构是一个内部结构，上述7个函数用这个内部结构保存当前正在被读的目录的有关信息。其作用类似于<code>FILE</code>结构。<code>FILE</code>结构由标准I/O库维护。</p>
<p><code>opendir</code>执行初始化操作，使第一个<code>readdir</code>返回目录中的第一个目录项。<code>DIR</code>结构由<code>fdopendir</code>创建时，<code>readdir</code>返回的第一项取决于传给<code>fdopendir</code>函数的文件描述符相关联的文件偏移量。注意，目录中各目录项的顺序与实现有关。它们通常并不按字母顾序排列。</p>
<p>我们将使用这些对目录进行操作的例程编写一个遍历文件层次结构的程序，其目的是得到各种类型的文件计数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* function type that is called for each filename */</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span>	<span class="keyword">int</span>	<span class="title">Myfunc</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">const</span> struct stat *, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> Myfunc	myfunc;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span>		<span class="title">myftw</span><span class="params">(<span class="keyword">char</span> *, Myfunc *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span>		<span class="title">dopath</span><span class="params">(Myfunc *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">long</span>	nreg, ndir, nblk, nchr, nfifo, nslink, nsock, ntot;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span>		ret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">		err_quit(<span class="string">"usage:  ftw  &lt;starting-pathname&gt;"</span>);</span><br><span class="line"></span><br><span class="line">	ret = myftw(argv[<span class="number">1</span>], myfunc);		<span class="comment">/* does it all */</span></span><br><span class="line"></span><br><span class="line">	ntot = nreg + ndir + nblk + nchr + nfifo + nslink + nsock;</span><br><span class="line">	<span class="keyword">if</span> (ntot == <span class="number">0</span>)</span><br><span class="line">		ntot = <span class="number">1</span>;		<span class="comment">/* avoid divide by 0; print 0 for all counts */</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"regular files  = %7ld, %5.2f %%\n"</span>, nreg,</span><br><span class="line">	  nreg*<span class="number">100.0</span>/ntot);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"directories    = %7ld, %5.2f %%\n"</span>, ndir,</span><br><span class="line">	  ndir*<span class="number">100.0</span>/ntot);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"block special  = %7ld, %5.2f %%\n"</span>, nblk,</span><br><span class="line">	  nblk*<span class="number">100.0</span>/ntot);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"char special   = %7ld, %5.2f %%\n"</span>, nchr,</span><br><span class="line">	  nchr*<span class="number">100.0</span>/ntot);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"FIFOs          = %7ld, %5.2f %%\n"</span>, nfifo,</span><br><span class="line">	  nfifo*<span class="number">100.0</span>/ntot);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"symbolic links = %7ld, %5.2f %%\n"</span>, nslink,</span><br><span class="line">	  nslink*<span class="number">100.0</span>/ntot);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"sockets        = %7ld, %5.2f %%\n"</span>, nsock,</span><br><span class="line">	  nsock*<span class="number">100.0</span>/ntot);</span><br><span class="line">	<span class="built_in">exit</span>(ret);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Descend through the hierarchy, starting at "pathname".</span></span><br><span class="line"><span class="comment"> * The caller's func() is called for every file.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	FTW_F	1		<span class="comment">/* file other than directory */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	FTW_D	2		<span class="comment">/* directory */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	FTW_DNR	3		<span class="comment">/* directory that can't be read */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	FTW_NS	4		<span class="comment">/* file that we can't stat */</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span>	*fullpath;		<span class="comment">/* contains full pathname for every file */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">size_t</span> pathlen;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span>					<span class="comment">/* we return whatever func() returns */</span></span><br><span class="line">myftw(<span class="keyword">char</span> *pathname, Myfunc *func)</span><br><span class="line">&#123;</span><br><span class="line">	fullpath = path_alloc(&amp;pathlen);	<span class="comment">/* malloc PATH_MAX+1 bytes */</span></span><br><span class="line">										<span class="comment">/* (&#123;Prog pathalloc&#125;) */</span></span><br><span class="line">	<span class="keyword">if</span> (pathlen &lt;= <span class="built_in">strlen</span>(pathname)) &#123;</span><br><span class="line">		pathlen = <span class="built_in">strlen</span>(pathname) * <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span> ((fullpath = <span class="built_in">realloc</span>(fullpath, pathlen)) == <span class="literal">NULL</span>)</span><br><span class="line">			err_sys(<span class="string">"realloc failed"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">strcpy</span>(fullpath, pathname);</span><br><span class="line">	<span class="keyword">return</span>(dopath(func));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Descend through the hierarchy, starting at "fullpath".</span></span><br><span class="line"><span class="comment"> * If "fullpath" is anything other than a directory, we lstat() it,</span></span><br><span class="line"><span class="comment"> * call func(), and return.  For a directory, we call ourself</span></span><br><span class="line"><span class="comment"> * recursively for each name in the directory.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span>					<span class="comment">/* we return whatever func() returns */</span></span><br><span class="line">dopath(Myfunc* func)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">stat</span>		<span class="title">statbuf</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dirent</span>	*<span class="title">dirp</span>;</span></span><br><span class="line">	DIR				*dp;</span><br><span class="line">	<span class="keyword">int</span>				ret, n;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (lstat(fullpath, &amp;statbuf) &lt; <span class="number">0</span>)	<span class="comment">/* stat error */</span></span><br><span class="line">		<span class="keyword">return</span>(func(fullpath, &amp;statbuf, FTW_NS));</span><br><span class="line">	<span class="keyword">if</span> (S_ISDIR(statbuf.st_mode) == <span class="number">0</span>)	<span class="comment">/* not a directory */</span></span><br><span class="line">		<span class="keyword">return</span>(func(fullpath, &amp;statbuf, FTW_F));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * It's a directory.  First call func() for the directory,</span></span><br><span class="line"><span class="comment">	 * then process each filename in the directory.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> ((ret = func(fullpath, &amp;statbuf, FTW_D)) != <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span>(ret);</span><br><span class="line"></span><br><span class="line">	n = <span class="built_in">strlen</span>(fullpath);</span><br><span class="line">	<span class="keyword">if</span> (n + NAME_MAX + <span class="number">2</span> &gt; pathlen) &#123;	<span class="comment">/* expand path buffer */</span></span><br><span class="line">		pathlen *= <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span> ((fullpath = <span class="built_in">realloc</span>(fullpath, pathlen)) == <span class="literal">NULL</span>)</span><br><span class="line">			err_sys(<span class="string">"realloc failed"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	fullpath[n++] = <span class="string">'/'</span>;</span><br><span class="line">	fullpath[n] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((dp = opendir(fullpath)) == <span class="literal">NULL</span>)	<span class="comment">/* can't read directory */</span></span><br><span class="line">		<span class="keyword">return</span>(func(fullpath, &amp;statbuf, FTW_DNR));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> ((dirp = readdir(dp)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">strcmp</span>(dirp-&gt;d_name, <span class="string">"."</span>) == <span class="number">0</span>  ||</span><br><span class="line">		    <span class="built_in">strcmp</span>(dirp-&gt;d_name, <span class="string">".."</span>) == <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">continue</span>;		<span class="comment">/* ignore dot and dot-dot */</span></span><br><span class="line">		<span class="built_in">strcpy</span>(&amp;fullpath[n], dirp-&gt;d_name);	<span class="comment">/* append name after "/" */</span></span><br><span class="line">		<span class="keyword">if</span> ((ret = dopath(func)) != <span class="number">0</span>)		<span class="comment">/* recursive */</span></span><br><span class="line">			<span class="keyword">break</span>;	<span class="comment">/* time to leave */</span></span><br><span class="line">	&#125;</span><br><span class="line">	fullpath[n<span class="number">-1</span>] = <span class="number">0</span>;	<span class="comment">/* erase everything from slash onward */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (closedir(dp) &lt; <span class="number">0</span>)</span><br><span class="line">		err_ret(<span class="string">"can't close directory %s"</span>, fullpath);</span><br><span class="line">	<span class="keyword">return</span>(ret);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">myfunc(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">const</span> struct stat *statptr, <span class="keyword">int</span> type)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">switch</span> (type) &#123;</span><br><span class="line">	<span class="keyword">case</span> FTW_F:</span><br><span class="line">		<span class="keyword">switch</span> (statptr-&gt;st_mode &amp; S_IFMT) &#123;</span><br><span class="line">		<span class="keyword">case</span> S_IFREG:	nreg++;		<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> S_IFBLK:	nblk++;		<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> S_IFCHR:	nchr++;		<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> S_IFIFO:	nfifo++;	<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> S_IFLNK:	nslink++;	<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> S_IFSOCK:	nsock++;	<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> S_IFDIR:	<span class="comment">/* directories should have type = FTW_D */</span></span><br><span class="line">			err_dump(<span class="string">"for S_IFDIR for %s"</span>, pathname);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> FTW_D:</span><br><span class="line">		ndir++;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> FTW_DNR:</span><br><span class="line">		err_ret(<span class="string">"can't read directory %s"</span>, pathname);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> FTW_NS:</span><br><span class="line">		err_ret(<span class="string">"stat error for %s"</span>, pathname);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		err_dump(<span class="string">"unknown type %d for pathname %s"</span>, type, pathname);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="函数chdir、fchdir和getcwd"><a href="#函数chdir、fchdir和getcwd" class="headerlink" title="函数chdir、fchdir和getcwd"></a>函数chdir、fchdir和getcwd</h2><p>每个进程都有一个当前工作目录，此目录是搜索所有相对路径名的起点。当用户登录到UNIX系统时，其当前工作目录通常是口令文件(<code>/etc/passwd</code>)中该用户登录项的第6个字段一用户的起始目录(home directory)。当前工作目录是进程的一个属性，起始目录则是登录名的一个属性。进程调用<code>chdir</code>或<code>fchdir</code>函数可以更改当前工作目录。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathame)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchdir</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"><span class="comment">// 两个函数的返回值，若成功，返回0；若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>在这两个函数中，分别用<code>pathname</code>或打开文件描述符来指定新的当前工作目录。</p>
<p>因为当前工作目录是进程的一个属性，所以它只影响调用<code>chdir</code>的进程本身，而不影响其他进程。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (chdir(<span class="string">"/tmp"</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        err_sys(<span class="string">"chdir failed"</span>);</span><br><span class="line">    printe(<span class="string">"chdir to /tmp succeeded\n"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果编译图4-23程序，并且调用其可执行目标代码文件mycd，则可以得到下列结果：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">pwd</span></span><br><span class="line">/usr/lib</span><br><span class="line">$ mycd</span><br><span class="line"><span class="built_in">chdir</span> to /tmp succeeded</span><br><span class="line">$ <span class="built_in">pwd</span></span><br><span class="line">/usr/lib</span><br></pre></td></tr></table></figure></p>
<p>从中可以看出，执行mycd命令的shell的当前工作目录并没有改变，这是shell执行程序工作方式的一个副作用。每个程序运行在独立的进程中，shell的当前工作目录并不会随着程序调用<code>chdir</code>而改变。</p>
<p>为了改变shell进程自己的工作目录，shell应当直接调用chdir函数，为此，cd命令内建在shell中，因为内核必须维护当前工作目录的信息，所以我们应能获取其当前值。遗憾的是，内核为每个进程只保存指向该目录v节点的指针等目录本身的信息，并不保存该目录的完整路径名。</p>
<p>函数<code>getcwd</code>从当前工作目录(<code>.</code>)开始，用<code>..</code>找到其上一级目录，然后读其目录项，直到该目录项中的i节点编号与工作目录i节点编号相同，这样地就找到了其对应的文件名，逐层上移，直到遇到根，这样就得到了当前工作目录完整的绝对路径名。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">getcwd</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="comment">// 返回值，若成功，返回buf，若出错，返回NULL</span></span><br></pre></td></tr></table></figure></p>
<p>必须向此函数传递两个参数，一个是缓冲区地址<code>buf</code>，另一个是缓冲区的长度<code>size</code>(以字节为单位)。该缓冲区必须有足够的长度以容纳绝对路径名再加上一个终止null字节，否则返回出错。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">char</span>	*ptr;</span><br><span class="line">	<span class="keyword">size_t</span>		size;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (chdir(<span class="string">"/usr/spool/uucppublic"</span>) &lt; <span class="number">0</span>)</span><br><span class="line">		err_sys(<span class="string">"chdir failed"</span>);</span><br><span class="line"></span><br><span class="line">	ptr = path_alloc(&amp;size);	<span class="comment">/* our own function */</span></span><br><span class="line">	<span class="keyword">if</span> (getcwd(ptr, size) == <span class="literal">NULL</span>)</span><br><span class="line">		err_sys(<span class="string">"getcwd failed"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"cwd = %s\n"</span>, ptr);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在更换工作目录之前，我们可以调用<code>getcwd</code>函数先将其保存起来。在完成了处理后，就可将所保存的原工作目录路径名作为调用参数传送给<code>chdir</code>。<code>fchdir</code>函数向我们提供了一种完成此任务的便捷方法。</p>
<p>在更换到文件系统中的不同位置前，无需调用<code>getcwd</code>函数，而是使用<code>open</code>打开当前工作目录，然后保存其返回的文件描述符。当希望回到原工作目录时，只要简单地将该文件描述符传送给<code>fchdir</code>。</p>
<h2 id="设备特殊文件"><a href="#设备特殊文件" class="headerlink" title="设备特殊文件"></a>设备特殊文件</h2><p><code>st_dev</code>和<code>st_rdev</code>这两个字段经常引起混淆</p>
<ul>
<li>每个文件系统所在的存储设备都由其主、次设备号表示。设备号所用的数据类型是基本系统数据类型<code>dev_t</code>。主设备号标识设备驱动程序；次设备号标识特定的子设备。</li>
<li>我们通常可以使用两个宏；<code>major</code>和<code>minor</code>来访问主、次设备号，大多数实现都定义这两个宏。这就意味着我们无需关心这两个数是如何存放在<code>dev_t</code>对象中的。</li>
<li>系统中与每个文件名关联的<code>st_dev</code>值是文件系统的设备号，该文件系统包含了这一文件名以及与其对应的i节点。</li>
<li>只有字符特殊文件和块特殊文件才有<code>st_rdev</code>值。此值包含实际设备的设备号。</li>
</ul>
<p>程序为每个命令行参数打印设备号，另外，若此参数引用的是字符特殊文件或块特殊文件，则还打印该特殊文件的<code>st_rdev</code>值。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span>			i;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">stat</span>	<span class="title">buf</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; argc; i++) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%s: "</span>, argv[i]);</span><br><span class="line">		<span class="keyword">if</span> (stat(argv[i], &amp;buf) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			err_ret(<span class="string">"stat error"</span>);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"dev = %d/%d"</span>, major(buf.st_dev),  minor(buf.st_dev));</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (S_ISCHR(buf.st_mode) || S_ISBLK(buf.st_mode)) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">" (%s) rdev = %d/%d"</span>,</span><br><span class="line">					(S_ISCHR(buf.st_mode)) ? <span class="string">"character"</span> : <span class="string">"block"</span>,</span><br><span class="line">					major(buf.st_rdev), minor(buf.st_rdev));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="文件访问权限位小结"><a href="#文件访问权限位小结" class="headerlink" title="文件访问权限位小结"></a>文件访问权限位小结</h2><p>我们已经说明了所有文件访问权限位，其中某些位有多种用途。列出了所有这些权限位，以及它们对普通文件和目录文件的作用。最后9个常量还可以分成如下3组：</p>
<ul>
<li><code>S_IRWXU</code> = <code>S_IRUSR</code> | <code>S_IWUSR</code> | <code>S_IXUSR</code></li>
<li><code>S_IRWXG</code> = <code>S_IRGRP</code> | <code>S_IWGRP</code> | <code>S_IXGRP</code></li>
<li><code>S_IRWXO</code> = <code>S_IROTH</code> | <code>S_IWOTH</code> | <code>S_IXOTH</code></li>
</ul>
<p><img src="/img/1621244305.jpg" alt></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Linux/" rel="tag"># Linux</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/05/09/cpp高级编程 笔记8/" rel="next" title="C++高级编程 第四版 笔记8">
                <i class="fa fa-chevron-left"></i> C++高级编程 第四版 笔记8
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/05/17/UNIX高级编程 笔记2/" rel="prev" title="UNIX高级编程 笔记2">
                UNIX高级编程 笔记2 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/header.jpg" alt="Hao Yu">
            
              <p class="site-author-name" itemprop="name">Hao Yu</p>
              <p class="site-description motion-element" itemprop="description">Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author</p>
          </div>
          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">351</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>
        	<audio controls="controls" loop="loop" preload="auto" src="/resource/xiaomeihao.mp3">
	        </audio>
	

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yuhao0102" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:yuh18@mails.tsinghua.edu.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#UNIX基础知识"><span class="nav-number">1.</span> <span class="nav-text">UNIX基础知识</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#UNIX体系结构"><span class="nav-number">1.1.</span> <span class="nav-text">UNIX体系结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件和目录"><span class="nav-number">1.2.</span> <span class="nav-text">文件和目录</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#文件系统"><span class="nav-number">1.2.1.</span> <span class="nav-text">文件系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#文件名"><span class="nav-number">1.2.2.</span> <span class="nav-text">文件名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#路径名"><span class="nav-number">1.2.3.</span> <span class="nav-text">路径名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#工作目录"><span class="nav-number">1.2.4.</span> <span class="nav-text">工作目录</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#起始目录"><span class="nav-number">1.2.5.</span> <span class="nav-text">起始目录</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#输入和输出"><span class="nav-number">1.3.</span> <span class="nav-text">输入和输出</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#文件描述符"><span class="nav-number">1.3.1.</span> <span class="nav-text">文件描述符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#标准输入、标准输出和标准错误"><span class="nav-number">1.3.2.</span> <span class="nav-text">标准输入、标准输出和标准错误</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#不带缓冲的I-O"><span class="nav-number">1.3.3.</span> <span class="nav-text">不带缓冲的I/O</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#标准I-O"><span class="nav-number">1.3.4.</span> <span class="nav-text">标准I/O</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#程序和进程"><span class="nav-number">1.4.</span> <span class="nav-text">程序和进程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#程序"><span class="nav-number">1.4.1.</span> <span class="nav-text">程序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程和进程ID"><span class="nav-number">1.4.2.</span> <span class="nav-text">进程和进程ID</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程控制"><span class="nav-number">1.4.3.</span> <span class="nav-text">进程控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程和线程ID"><span class="nav-number">1.4.4.</span> <span class="nav-text">线程和线程ID</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#出错处理"><span class="nav-number">1.5.</span> <span class="nav-text">出错处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#用户标识"><span class="nav-number">1.6.</span> <span class="nav-text">用户标识</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#用户ID"><span class="nav-number">1.6.1.</span> <span class="nav-text">用户ID</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#附属组ID"><span class="nav-number">1.6.2.</span> <span class="nav-text">附属组ID</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#信号"><span class="nav-number">1.7.</span> <span class="nav-text">信号</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#时间值"><span class="nav-number">1.8.</span> <span class="nav-text">时间值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#系统调用和库函数"><span class="nav-number">1.9.</span> <span class="nav-text">系统调用和库函数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#文件I-O"><span class="nav-number">2.</span> <span class="nav-text">文件I/O</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#引言"><span class="nav-number">2.1.</span> <span class="nav-text">引言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件描述符-1"><span class="nav-number">2.2.</span> <span class="nav-text">文件描述符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数open和openat"><span class="nav-number">2.3.</span> <span class="nav-text">函数open和openat</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#文件名和路径名截断"><span class="nav-number">2.3.1.</span> <span class="nav-text">文件名和路径名截断</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数creat"><span class="nav-number">2.4.</span> <span class="nav-text">函数creat</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数close"><span class="nav-number">2.5.</span> <span class="nav-text">函数close</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数lseek"><span class="nav-number">2.6.</span> <span class="nav-text">函数lseek</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数read"><span class="nav-number">2.7.</span> <span class="nav-text">函数read</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数write"><span class="nav-number">2.8.</span> <span class="nav-text">函数write</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#I-O的效率"><span class="nav-number">2.9.</span> <span class="nav-text">I/O的效率</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件共享"><span class="nav-number">2.10.</span> <span class="nav-text">文件共享</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#原子操作"><span class="nav-number">2.11.</span> <span class="nav-text">原子操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#追加到一个文件"><span class="nav-number">2.11.1.</span> <span class="nav-text">追加到一个文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数pread和pwrite"><span class="nav-number">2.11.2.</span> <span class="nav-text">函数pread和pwrite</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建一个文件"><span class="nav-number">2.11.3.</span> <span class="nav-text">创建一个文件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数dup和dup2"><span class="nav-number">2.12.</span> <span class="nav-text">函数dup和dup2</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数sync、fsync和fdatasync"><span class="nav-number">2.13.</span> <span class="nav-text">函数sync、fsync和fdatasync</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数fcntl"><span class="nav-number">2.14.</span> <span class="nav-text">函数fcntl</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数ioctl"><span class="nav-number">2.15.</span> <span class="nav-text">函数ioctl</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#dev-fd"><span class="nav-number">2.16.</span> <span class="nav-text">/dev/fd</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#文件和目录-1"><span class="nav-number">3.</span> <span class="nav-text">文件和目录</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#函数stat、fstat、fstatat和lstat"><span class="nav-number">3.1.</span> <span class="nav-text">函数stat、fstat、fstatat和lstat</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件类型"><span class="nav-number">3.2.</span> <span class="nav-text">文件类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#设置用户ID和设置组ID"><span class="nav-number">3.3.</span> <span class="nav-text">设置用户ID和设置组ID</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件访问权限"><span class="nav-number">3.4.</span> <span class="nav-text">文件访问权限</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#新文件和目录的所有权"><span class="nav-number">3.5.</span> <span class="nav-text">新文件和目录的所有权</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数access和faccessat"><span class="nav-number">3.6.</span> <span class="nav-text">函数access和faccessat</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数umask"><span class="nav-number">3.7.</span> <span class="nav-text">函数umask</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数chmod、fchmod和fchmodat"><span class="nav-number">3.8.</span> <span class="nav-text">函数chmod、fchmod和fchmodat</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#粘着位"><span class="nav-number">3.9.</span> <span class="nav-text">粘着位</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数chown、fchown、fchownat和1chown"><span class="nav-number">3.10.</span> <span class="nav-text">函数chown、fchown、fchownat和1chown</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件长度"><span class="nav-number">3.11.</span> <span class="nav-text">文件长度</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#文件中的空洞"><span class="nav-number">3.11.1.</span> <span class="nav-text">文件中的空洞</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件截断"><span class="nav-number">3.12.</span> <span class="nav-text">文件截断</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件系统-1"><span class="nav-number">3.13.</span> <span class="nav-text">文件系统</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数1ink、linkat、unlink、unlinkat和remove"><span class="nav-number">3.14.</span> <span class="nav-text">函数1ink、linkat、unlink、unlinkat和remove</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数rename和renameat"><span class="nav-number">3.15.</span> <span class="nav-text">函数rename和renameat</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#符号链接"><span class="nav-number">3.16.</span> <span class="nav-text">符号链接</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#创建和读取符号链接"><span class="nav-number">3.17.</span> <span class="nav-text">创建和读取符号链接</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件的时间"><span class="nav-number">3.18.</span> <span class="nav-text">文件的时间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数futimens、utimensat和utimes"><span class="nav-number">3.19.</span> <span class="nav-text">函数futimens、utimensat和utimes</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数mkdir-mkdirat和rmdir"><span class="nav-number">3.20.</span> <span class="nav-text">函数mkdir, mkdirat和rmdir</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#读目录"><span class="nav-number">3.21.</span> <span class="nav-text">读目录</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数chdir、fchdir和getcwd"><span class="nav-number">3.22.</span> <span class="nav-text">函数chdir、fchdir和getcwd</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#设备特殊文件"><span class="nav-number">3.23.</span> <span class="nav-text">设备特殊文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件访问权限位小结"><span class="nav-number">3.24.</span> <span class="nav-text">文件访问权限位小结</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>
  <div id="DvelopmentTarget">     
  </div>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart" aria-hidden="false"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>

  
</div>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_uv"> 
  本站访客数<span id="busuanzi_value_site_uv"></span>人次
</span>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  


  <script type="text/javascript" src="/js/src/love.js"></script>

</body>
</html>
