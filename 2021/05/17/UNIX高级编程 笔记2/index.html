<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zn-ch">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-center-simple.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Linux,">










<meta name="description" content="标准I/O库流和FILE对象对于标准I/O库，它们的操作是围绕流(stream)进行的。当用标准I/O库打开或创建一个文件时，我们已使一个流与一个文件相关联。对于ASCII字符集，一个字符用一个字节表示。标准I/O文件流可用于单字节或多字节字符集。流的定向(stream’s orientation)决定了所读、写的字符是单字节还是多字节的。当一个流最初被创建时，它并没有定向。如若在未定向的流上使用">
<meta name="keywords" content="Linux">
<meta property="og:type" content="article">
<meta property="og:title" content="UNIX高级编程 笔记2">
<meta property="og:url" content="http://yoursite.com/2021/05/17/UNIX高级编程 笔记2/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="标准I/O库流和FILE对象对于标准I/O库，它们的操作是围绕流(stream)进行的。当用标准I/O库打开或创建一个文件时，我们已使一个流与一个文件相关联。对于ASCII字符集，一个字符用一个字节表示。标准I/O文件流可用于单字节或多字节字符集。流的定向(stream’s orientation)决定了所读、写的字符是单字节还是多字节的。当一个流最初被创建时，它并没有定向。如若在未定向的流上使用">
<meta property="og:locale" content="zn-ch">
<meta property="og:image" content="http://yoursite.com/img/20210517115638.png">
<meta property="og:image" content="http://yoursite.com/img/20210518121754.png">
<meta property="og:image" content="http://yoursite.com/img/20210518122502.png">
<meta property="og:image" content="http://yoursite.com/img/20210522143654.png">
<meta property="og:image" content="http://yoursite.com/img/20210522150750.png">
<meta property="og:image" content="http://yoursite.com/img/20210522151557.png">
<meta property="og:image" content="http://yoursite.com/img/20210522152120.png">
<meta property="og:image" content="http://yoursite.com/img/20210522173047.png">
<meta property="og:image" content="http://yoursite.com/img/20210522173933.png">
<meta property="og:image" content="http://yoursite.com/img/20210522174418.png">
<meta property="og:image" content="http://yoursite.com/img/20210522200334.png">
<meta property="og:updated_time" content="2021-06-01T13:25:50.968Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="UNIX高级编程 笔记2">
<meta name="twitter:description" content="标准I/O库流和FILE对象对于标准I/O库，它们的操作是围绕流(stream)进行的。当用标准I/O库打开或创建一个文件时，我们已使一个流与一个文件相关联。对于ASCII字符集，一个字符用一个字节表示。标准I/O文件流可用于单字节或多字节字符集。流的定向(stream’s orientation)决定了所读、写的字符是单字节还是多字节的。当一个流最初被创建时，它并没有定向。如若在未定向的流上使用">
<meta name="twitter:image" content="http://yoursite.com/img/20210517115638.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2021/05/17/UNIX高级编程 笔记2/">





  <title>UNIX高级编程 笔记2 | Hao Yu's blog</title>
  








 
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zn-ch">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hao Yu's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">The program monkey was eaten by the siege lion.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/resume.pdf" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-mybetterhalf">
          <a href="/mybetterhalf/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>
            
            mybetterhalf
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/05/17/UNIX高级编程 笔记2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">UNIX高级编程 笔记2</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-05-17T16:20:00+08:00">
                2021-05-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="标准I-O库"><a href="#标准I-O库" class="headerlink" title="标准I/O库"></a>标准I/O库</h1><h2 id="流和FILE对象"><a href="#流和FILE对象" class="headerlink" title="流和FILE对象"></a>流和FILE对象</h2><p>对于标准I/O库，它们的操作是围绕流(stream)进行的。当用标准I/O库打开或创建一个文件时，我们已使一个流与一个文件相关联。对于ASCII字符集，一个字符用一个字节表示。标准I/O文件流可用于单字节或多字节字符集。流的定向(stream’s orientation)决定了所读、写的字符是单字节还是多字节的。当一个流最初被创建时，它并没有定向。如若在未定向的流上使用一个多字节I/O函数(见<code>&lt;wchar.h&gt;</code>)，则将该流的定向设置为宽定向的。若在未定向的流上使用一个单字节I/O函数，则将该流的定向设为字节定向的。只有两个函数可改变流的定向。<code>freopen</code>函数清除一个流的定向；<code>fwide</code>函数可用于设置流的定向。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;wchar.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fwide</span> <span class="params">(FILE *fp， <span class="keyword">int</span> mode)</span></span>;</span><br><span class="line"><span class="comment">// 返回值。若流是宽定向的，返回正值：若流是字节定向的，返回负值，若流是未定向的，返回0</span></span><br></pre></td></tr></table></figure></p>
<p>根据<code>mode</code>参数的不同值，<code>fwide</code>函数执行不同的工作。</p>
<ul>
<li>如若<code>mode</code>参数值为负，<code>fwide</code>将试图使指定的流是字节定向的。</li>
<li>如若<code>mode</code>参数值为正，<code>fwide</code>将试图使指定的流是宽定向的。</li>
<li>如若<code>mode</code>参数值为0，<code>fwide</code>将不试图设置流的定向，但返回标识该流定向的值。</li>
</ul>
<p>注意，<code>fwide</code>并不改变已定向流的定向。还应注意的是，<code>fwide</code>无出错返回。</p>
<p>当打开一个流时，标准I/O函数<code>fopen</code>返回一个指向<code>FILE</code>对象的指针。该对象通常是一个结构，它包含了标准I/O库为管理该流需要的所有信息，包括用于实际I/O的文件描述符、指向用于该流缓冲区的指针、缓冲区的长度、当前在缓冲区中的字符数以及出错标志等。应用程序没有必要检验<code>FILE</code>对象。为了引用一个流，需将<code>FILE</code>指针作为参数传递给每个标准I/O函数。在本书中，我们称指向<code>FILE</code>对象的指针(类型为<code>FILE*</code>)为文件指针。</p>
<h2 id="标准输入、标准输出和标准错误"><a href="#标准输入、标准输出和标准错误" class="headerlink" title="标准输入、标准输出和标准错误"></a>标准输入、标准输出和标准错误</h2><p>对一个进程预定义了3个流，并且这3个流可以自动地被进程使用，它们是：<strong>标准输入</strong>、<strong>标准输出</strong>和<strong>标准错误</strong>。这些流引用的文件与文件描述符<code>STDIN_FILENO</code>，<code>STDOUT_FILENO</code>和<code>STDERR_FILENO</code>所引用的相同。这3个标准I/O流通过预定义文件指针<code>stdin</code>、<code>stdout</code>和<code>stderr</code>加以引用。这3个文件<br>指针定义在头文件<code>&lt;stdio.h&gt;</code>中。</p>
<h2 id="缓冲"><a href="#缓冲" class="headerlink" title="缓冲"></a>缓冲</h2><p>标准I/O库提供缓冲的目的是尽可能减少使用<code>read</code>和<code>write</code>调用的次数。它也对每个I/O流自动地进行缓冲管理。标准I/O提供了以下3种类型的缓冲：</p>
<ul>
<li>全缓冲。在这种情况下，在填满标准I/O缓冲区后才进行实际操作。对于驻留在磁盘上的文件通常是由标准I/O库实施全缓冲的。在一个流上执行第一次I/O操作时，相关标准I/O函数通常调用<code>malloc</code>获得需使用的缓冲区，<code>flush</code>说明标准I/O缓冲区的写操作。缓冲区可由标准I/O例程自动flush，或者可以调用函数<code>fflush</code>冲洗一个流。</li>
<li>行缓冲。在这种情况下，当在输入和输出中遇到换行符时，标准I/O库执行I/O操作。这允许我们一次输出一个字符，但只有在写了一行之后才进行实际I/O操作。当流涉及一个终端时(如标准输入和标准输出)，通常使用行缓冲。<ul>
<li>对于行缓冲有两个限制。第一，因为标准I/O库用来收集每一行的缓冲区的长度是固定的，所以只要填满了缓冲区，那么即使还没有写一个换行符，也进行I/O操作。</li>
<li>第二，任何时候只要通过标准I/O库要求从(a)一个不带缓冲的流，或者(b)一个行缓冲的流得到输入数据，那么就会flush所有行缓冲输出流。很明显，从一个不带缓冲的流中输入需要从内核获得数据。</li>
</ul>
</li>
<li>不带缓冲。标准I/O库不对字符进行缓冲存储。例如，用标准I/O函数<code>fputs</code>写15个字符到不带缓冲的流中，我们就期望这15个字符能立即输出。</li>
</ul>
<p>标准错误流stderr通常是不带缓冲的，这就使得出错信息可以尽快显示出来，而不管它们是否含有一个换行符。</p>
<p>ISOC要求下列缓冲特征。</p>
<ul>
<li>当且仅当标准输入和标准输出并不指向交互式设备时，它们才是全缓冲的。</li>
<li>标准错误决不会是全缓冲的。</li>
</ul>
<p>但是，这并没有告诉我们如果标准输入和标准输出指向交互式设备时，它们是不带缓冲的还是行缓冲的；以及标准错误是不带缓冲的还是行缓冲的。很多系统默认使用下列类型的缓冲：</p>
<ul>
<li>标准错误是不带缓冲的</li>
<li>若是指向终端设备的流，则是行缓冲的；否则是全缓冲的。</li>
</ul>
<p>对任何一个给定的流，如果我们并不喜欢这些系统默认，则可调用下列两个函数中的一个更改缓冲类型<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setbuf</span><span class="params">(FILE *<span class="keyword">restrict</span> fp， <span class="keyword">char</span> *<span class="keyword">restrict</span> buf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setvbuf</span><span class="params">(FILE *<span class="keyword">restrict</span> fp， <span class="keyword">char</span> *<span class="keyword">restrict</span> buf， <span class="keyword">int</span> mode， <span class="keyword">size_t</span> site)</span></span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回0；若出错，返回非0</span></span><br></pre></td></tr></table></figure></p>
<p>这些函数一定要在流已被打开后调用，因为每个函数都要求一个有效的文件指针作为它们的第一个参数，而且也应在对该流执行任何一个其他操作之前调用。</p>
<p>可以使用<code>setbuf</code>函数打开或关闭缓冲机制。为了带缓冲进行I/O，参数<code>buf</code>必须指向一个长度为<code>BUFSIZ</code>的缓冲区(该常量定义在<code>&lt;stdio.h&gt;</code>中)。通常在此之后该流就是全缓冲的，但是如果该流与一个终端设备相关，那么某些系统也可将其设置为行缓冲的。为了关闭缓冲，将<code>buf</code>没置为NULL。</p>
<p>使用<code>setvbuf</code>，我们可以精确地说明所需的缓冲类型。这是用<code>mode</code>参数实现的：</p>
<ul>
<li><code>_IOFBF</code>：全缓冲</li>
<li><code>_IOLBF</code>：行缓冲</li>
<li><code>_IONBF</code>：不带缓冲</li>
</ul>
<p>如果指定一个不带缓冲的流，则忽略<code>buf</code>和<code>size</code>参数。如果指定全缓冲或行缓冲，则<code>buf</code>和<code>size</code>可选择地指定一个缓冲区及其长度。如果该流是带缓冲的，而buf是NULL，则标准I/O库将自动地为该流分配适当长度的缓冲区。适当长度指的是由常量<code>BUFSIZ</code>所指定的值。</p>
<p>图5-1列出了这两个函数的动作，以及它们的各个选项。<br><img src="/img/20210517115638.png" alt></p>
<p>要了解，如果在一个函数内分配一个自动变量类的标准I/O缓冲区。则从该函数返回之前，必须关闭该流。另外，其些实现将缓冲区的一部分用于存放它自己的<br>管理操作信息，所以可以存放在缓冲区中的实际数据字节数少于size。一般而言，应由系统选择缓冲区的长度，并自动分配缓冲区。</p>
<p>任何时候，我们都可强制冲洗一个流<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fflush</span> <span class="params">(FILE *fp)</span></span>;</span><br><span class="line"><span class="comment">// 返回值，若成功，返回0，若出错，返回EOF</span></span><br></pre></td></tr></table></figure></p>
<p>此函数使该流所有未写的数据都被传送至内核。作为一种特殊情形，如若<code>fp</code>是NULL，则此函数将导致所有输出流被冲洗。</p>
<h2 id="打开流"><a href="#打开流" class="headerlink" title="打开流"></a>打开流</h2><p>下列3个函数打开一个标准I/O流。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function">FILE *<span class="title">fopen</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> pathname， <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> type)</span></span>;</span><br><span class="line"><span class="function">FILE *<span class="title">freopen</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> pathname， <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> type， FILE *<span class="keyword">restrict</span> fp)</span></span>;</span><br><span class="line"><span class="function">FILE *<span class="title">fdopen</span><span class="params">(<span class="keyword">int</span> fd， <span class="keyword">const</span> <span class="keyword">char</span> *type)</span></span>;</span><br><span class="line"><span class="comment">// 3个函数的返回值：若成功，返回文件指针；若出错，返回NULL</span></span><br></pre></td></tr></table></figure></p>
<p>这3个函数的区别如下。</p>
<ol>
<li><code>fopen</code>函数打开路径名为pathname的一个指定的文件。</li>
<li><code>freopen</code>函数在一个指定的流上打开一个指定的文件，如果该流已经打开，则先关闭该流。若该流已经定向，则使用<code>freopen</code>清除该定向。此函数一般用于将一个指定的文件打开为一个预定义的流：标准输入、标准输出或标准错误。</li>
<li><code>fdopen</code>函数取一个已有的文件描述符(我们可能从<code>open</code>、<code>dup</code>、<code>dup2</code>、<code>fcntl</code>、<code>pipe</code>、<code>socket</code>、<code>socketpair</code>、<code>accept</code>函数得到此文件描述符)，并使一个标准的I/O流与该描述符相结合。此函数常用于由创建管道和网络通信通道函数返回的描述符，因为这些特殊类型的文件不能用标准I/O函数<code>fopen</code>打开，所以我们必须先调用设备专用函数以获得一个文件描述符，然后用<code>fdopen</code>使一个标准I/O流与该描述符相结合。</li>
</ol>
<p><code>fopen</code>和<code>freopen</code>是ISO C的所属部分。而ISO C并不涉及文件描述符，所以仅有POSIX.1具有<code>fdopen</code>。</p>
<p><code>type</code>参数指定对该I/O流的读、写方式，ISO C规定<code>type</code>参数可以有15种不同的值，如表所示。</p>
<p><img src="/img/20210518121754.png" alt></p>
<p>使用字符b作为<code>type</code>的一部分，这使得标准I/O系统可以区分文本文件和二进制文件。因为UNIX内核并不对这两种文件进行区分，所以在UNIX系统环境下指定字符b作为<code>type</code>的一部分实际上并无作用。</p>
<p>对于<code>fdopen</code>，<code>type</code>参数的意义稍有区别。因为该描述符已被打开，所以<code>fdopen</code>为写而打开并不截断该文件。另外，标准I/O追加写方式也不能用于创建该文件，当用追加写类型打开一个文件后，每次写都将数据写到文件的当前尾端处。如果有多个进程用标准I/O追加写方式打开同一文件，那么来自每个进程的数据都将正确地写到文件中。</p>
<p>在涉及多个进程时，为了正确地支持追加写方式，该文件必须用<code>O_APPEND</code>标志打开。在每次写前，做一次<code>lseek</code>操作同样也不能正确工作。</p>
<p>当以读和写类型打开一个文件时(type中+号)，具有下列限制。</p>
<ul>
<li>如果中间没有<code>fflush</code>、<code>fseek</code>、<code>fsetpos</code>或<code>rewind</code>，则在输出的后面不能直接跟随输入。</li>
<li>如果中间没有<code>fseek</code>、<code>fsetpos</code>或<code>rewind</code>，或者一个输入操作没有到达文件尾端，则在输入操作之后不能直接跟随输出。</li>
</ul>
<p>图中列出了打开一个流的6种不同的方式。<br><img src="/img/20210518122502.png" alt></p>
<p>注意，在指定<code>w</code>或<code>a</code>类型创建一个新文件时，我们无法说明该文件的访问权限位。POSIX.I要求实现使用如下的权限位集来创建文件。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH</span><br></pre></td></tr></table></figure></p>
<p>除非流引用终端设备，否则按系统默认，流被打开时是全缓冲的。若流引用终端设备，则该流是行缓冲的。一旦打开了流，那么在对该流执行任何操作之前，如果希望，则可使用前节所述的<code>setbuf</code>和<code>setvbuf</code>改变缓冲的类型。</p>
<p>调用<code>fclose</code>关闭一个打开的流<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fclose</span><span class="params">(FILE *fp)</span></span>;</span><br><span class="line"><span class="comment">// 返回值：若成功。返回0；若出错，返回EOF</span></span><br></pre></td></tr></table></figure></p>
<p>在该文件被关闭之前，冲洗缓冲中的输出数据。缓冲区中的任何输入数据被丢弃。如果标准I/O库已经为该流自动分配了一个缓冲区，则释放此缓冲区。当一个进程正常终止时，则所有带未写缓冲数据的标准I/O流都被冲洗，所有打开的标准I/O流都被关闭。</p>
<h2 id="读和写流"><a href="#读和写流" class="headerlink" title="读和写流"></a>读和写流</h2><p>一旦打开了流，则可在3种不同类型的非格式化I/O中进行选择，对其进行读、写操作。</p>
<ol>
<li>每次一个字符的I/O，一次读或写一个字符，如果流是带缓冲的，则标准I/O函数处理所有缓冲。</li>
<li>每次一行的I/O。如果想要一次读或写一行，则使用<code>fgets</code>和<code>fputs</code>。每行都以一个换行符终止。当调用<code>fgets</code>时，应说明能处理的最大行长。</li>
<li>直接I/O。<code>fread</code>和<code>fwrite</code>函数支持这种类型的I/O。每次I/O操作读或写某种数量的对象，而每个对象具有指定的长度。这两个函数常用于从二进制文件中每次读或写一个结构。</li>
</ol>
<p>直接I/O也被称为：二进制I/O、一次一个对象I/O、面向记录的I/O或面向结构的I/O。</p>
<h3 id="输入函数"><a href="#输入函数" class="headerlink" title="输入函数"></a>输入函数</h3><p>以下3个函数可用于一次读一个字符。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getc</span><span class="params">(FILE *fp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fgetc</span><span class="params">(FILE *fp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getchar</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="comment">// 3个函数的返回值，若成功，返回下一个字符；若已到达文件尾或出错，返回EOF</span></span><br></pre></td></tr></table></figure></p>
<p>函数<code>getchar</code>等同于<code>getc(stdin)</code>。前两个函数的区别是，<code>getc</code>可被实现为宏，而<code>fgetc</code>不能实现为宏。这意味着以下几点。</p>
<ol>
<li><code>getc</code>的参数不应当是具有副作用的表达式，因为它可能会被计算多次。</li>
<li>因为<code>fgetc</code>一定是个函数，所以可以得到其地址。这就允许将<code>fgetc</code>的地址作为一个参数传送给另一个函数。</li>
<li>调用<code>fgetc</code>所需时间很可能比调用<code>getc</code>要长，因为调用函数所需的时间通常长于调用宏。</li>
</ol>
<p>这3个函数在返回下一个字符时，将其unsigned char类型转换为int类型。说明为无符号的理由是，如果最高位为1也不会使返回值为负。要求整型返回值的理由是，这样就可以返回所有可能的字符值再加。上一个已出错或已到达文件尾端的指示值。在<code>&lt;stdio.h&gt;</code>中的常量<code>EOF</code>被要求是一个负值，其值经常是-1。这就意味着不能将这3个函数的返回值存放在一个字符变量中，以后还要将这些函数的返回值与常量<code>EOF</code>比较。</p>
<p>注意，不管是出错还是到达文件尾端，这3个函数都返回同样的值。为了区分这两种不同的情况，必须调用<code>ferror</code>或<code>feof</code>。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ferror</span> <span class="params">(FILE *fp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">feof</span><span class="params">(FILE *fp)</span></span>;</span><br><span class="line"><span class="comment">// 两个函数返回值：若条件为真，返回非0(真)；否则。返回0(假)</span></span><br><span class="line">void clearerr(FILE *fp):</span><br></pre></td></tr></table></figure></p>
<p>在大多数实现中，为每个流在FILE对象中维护了两个标志；</p>
<ul>
<li>出错标志：</li>
<li>文件结束标志</li>
</ul>
<p>调用<code>clearerr</code>可以清除这两个标志。从流中读取数据以后，可以调用<code>ungetc</code>将字符再压送回流中。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ungete</span><span class="params">(<span class="keyword">int</span> c， FILE *fp)</span></span>;</span><br><span class="line"><span class="comment">// 返回值，若成功，返回c。若出错，返回EOF</span></span><br></pre></td></tr></table></figure></p>
<p>压送回到流中的字符以后又可从流中读出，但读出字符的顺序与压送回的顺序相反。不能回送EOF。但是当已经到达文件尾端时，仍可以回送一个字符。下次读将返回该字符，再读则返回EOF。之所以能这样做的原因是，一次成功的<code>ungetc</code>调用会清除该流的文件结束标志。</p>
<p>当正在读一个输入流，并进行某种形式的切词或记号切分操作时，会经常用到回送字符操作。如果标准I/O库不提供回送能力，就需将该字符存放到一个我们自己的变量中，并设置一个标志以便判别在下一次需要一个字符时是调用<code>getc</code>，还是从我们自己的变量中取用这个字符，用<code>ungetc</code>压送回字符时，并没有将它们写到底层文件或设备中，而是将它们写回标准I/O库的波缓冲区中。</p>
<h3 id="输出函数"><a href="#输出函数" class="headerlink" title="输出函数"></a>输出函数</h3><p>对应于上面所述的每个输入函数都有一个输出函数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">putc</span><span class="params">(<span class="keyword">int</span> c， FILE *fp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputc</span><span class="params">(<span class="keyword">int</span> c， FILE *fp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">putchar</span><span class="params">(<span class="keyword">int</span> c)</span></span>;</span><br><span class="line"><span class="comment">// 3个函数返回值。若成功，返回c；若出错，返回EOF</span></span><br></pre></td></tr></table></figure></p>
<p>与输入函数一样，<code>putchar(c)</code>等同于<code>putc(c， stdout)</code>，<code>putc</code>可被实现为宏，而<code>fputc</code>不能实现为宏。</p>
<h2 id="每次一行I-O"><a href="#每次一行I-O" class="headerlink" title="每次一行I/O"></a>每次一行I/O</h2><p>下面两个函数提供每次输入一行的功能。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">char *fgets(char *restrict buf， int n， FILE *restrict fp):</span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">gets</span><span class="params">(<span class="keyword">char</span> *buf)</span></span>;</span><br><span class="line"><span class="comment">// 两个函数返回值，若成功，返回byf，着已到达文件尾端或出错，返回NULL</span></span><br></pre></td></tr></table></figure></p>
<p>这两个函数都指定了缓冲区的地址，读入的行将送入其中。<code>gets</code>从标准输入读，而<code>fgets</code>则从指定的流读。对于<code>fgets</code>，必须指定缓冲的长度<code>n</code>。此函数一直读到下一个换行符为止，但是不超过<code>n-1</code>个字符，读入的字符被送入缓冲区。该缓冲区以null字节结尾。如若该行包括最后一个换行符的字符数超过<code>n-1</code>。则<code>fgets</code>只返回一个不完整的行，但是，缓冲区总是以null字节结尾，对fgets的下一次调用会继续读该行。</p>
<p><code>gets</code>是一个不推荐使用的函数。其问题是调用者在使用<code>gets</code>时不能指定缓冲区的长度。这样就可能造成缓冲区溢出(如若该行长于缓冲区长度)，写到缓冲区之后的存储空间中，从而产生不可预料的后果。<code>gets</code>与<code>fgets</code>的另一个区别是，<code>gets</code>并不将换行符存入缓冲区中。</p>
<p>虽然ISO C要求提供<code>gets</code>，但请使用<code>fgets</code>，而不要使用<code>gets</code>。</p>
<p><code>fputs</code>和<code>puts</code>提供每次输出一行的功能<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> str， FILE *<span class="keyword">restrict</span> fp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">puts</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span>;</span><br><span class="line"><span class="comment">// 两个函数返回值，若成功，返回非负值；若出错，返回EOF</span></span><br></pre></td></tr></table></figure></p>
<p>函数<code>puts</code>将一个以null字节终止的字符串写到指定的流，尾端的终止符null不写出。注意，这并不一定是每次输出一行，因为字符串不需要换行符作为最后一个非null字节。通常，在null字节之前是一个换行符，但并不要求总是如此。</p>
<p><code>puts</code>将一个以null字节终止的字符串写到标准输出，终止符不写出。但是，<code>puts</code>随后又将一个换行符写到标准输出。</p>
<h2 id="标准I-O的效率"><a href="#标准I-O的效率" class="headerlink" title="标准I/O的效率"></a>标准I/O的效率</h2><p>下面的程序使用<code>getc</code>和<code>putc</code>将标准输入复制到标准输出。这两个例程可以实现为宏。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> c;</span><br><span class="line">	<span class="keyword">while</span> ((c = getc(<span class="built_in">stdin</span>)) != EOF)</span><br><span class="line">	<span class="keyword">if</span> (putc(c， <span class="built_in">stdout</span>) == EOF)</span><br><span class="line">		err_sys (<span class="string">"output error"</span>);</span><br><span class="line">	<span class="keyword">if</span>(ferror (<span class="built_in">stdin</span>))</span><br><span class="line">		err_sys(<span class="string">"input error"</span>);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="二进制I-O"><a href="#二进制I-O" class="headerlink" title="二进制I/O"></a>二进制I/O</h2><p>提供了下列两个函数以执行二进制I/O操作。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">size_t</span> fread(<span class="keyword">void</span> *<span class="keyword">restrict</span> ptr， <span class="keyword">size_t</span> size， <span class="keyword">size_t</span> nobj， FILE *<span class="keyword">restrict</span> fp);</span><br><span class="line"><span class="keyword">size_t</span> fwrite(<span class="keyword">const</span> <span class="keyword">void</span> *<span class="keyword">restrict</span> ptr， <span class="keyword">size_t</span> size， <span class="keyword">size_t</span> nobj， FILE *<span class="keyword">restrict</span> fp);</span><br><span class="line"><span class="comment">// 两个函数的返回值：读或写的对象数</span></span><br></pre></td></tr></table></figure></p>
<p>这些函数有以下两种常见的用法。</p>
<p>读或写一个二进制数组。例如，为了将一个浮点数组的第2~5个元素写至一文件上，可以编写如下程序：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> data[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">if</span>(fwrite(&amp;data[<span class="number">2</span>]， aizeof(<span class="keyword">float</span>), <span class="number">4</span>， fp) != <span class="number">4</span>)</span><br><span class="line">	err_sys(<span class="string">"fwrite error"</span>);</span><br></pre></td></tr></table></figure></p>
<p>其中，指定<code>size</code>为每个数组元素的长度，<code>nobj</code>为欲写的元素个数。</p>
<p>读或写一个结构。例如，可以编写如下程序；<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">short</span> count;</span><br><span class="line">	<span class="keyword">long</span> total;</span><br><span class="line">	<span class="keyword">char</span> name[NAMESIZE];</span><br><span class="line">&#125; item;</span><br><span class="line"><span class="keyword">if</span> (fwrite(&amp;item， <span class="keyword">sizeof</span>(item), <span class="number">1</span>， fp) != <span class="number">1</span>)</span><br><span class="line">	err_sys(<span class="string">"fwrite error"</span>);</span><br></pre></td></tr></table></figure></p>
<p>其中，指定<code>size</code>为结构的长度，<code>nobj</code>为1 (要写的对象个数)，将这两个例子结合起来就可读或写一个结构数组。为了做到这一点，<code>size</code>应当是该结构的<code>sizeof</code>，<code>noby</code>应是该数组中的元素个数。</p>
<p><code>fread</code>和<code>fwrite</code>返回读或写的对象数。对于读，如果出错或到达文件尾端，则此数字可以少于<code>nobj</code>。在这种情况，应调用<code>ferror</code>或<code>feof</code>以判断究竟是那一种情况。对于写，如果返回值少于所要求的<code>nobj</code>，则出错，使用二进制I/O的基本问题是，它只能用于读在同一系统上已写的数据。</p>
<p>当在一个系统上写的数据，要在另一个系统上进行处理时，这两个函数可能就不能正常工作，其原因是：</p>
<ul>
<li>在一个结构中，同一成员的偏移最可能随编译程序和系统的不同而不同(由于不同的对齐要求)。<ul>
<li>某些编译程序使结构中的各成员紧密包装(这可以节省存储空间，而运行性能则可能有所下降)；</li>
<li>或者准确对齐(以便在运行时易于存取结构中的各成员)。</li>
<li>这意味着即使在同一个系统上，一个结构的二进制存放方式也可能因编译程序选项的不同而不同。</li>
</ul>
</li>
<li>用来存储多字节整数和浮点值的二进制格式在不同的系统结构间也可能不同。</li>
</ul>
<h2 id="定位流"><a href="#定位流" class="headerlink" title="定位流"></a>定位流</h2><p>有3种方法定位标准I/O流。</p>
<ul>
<li><code>ftell</code>和<code>fseek</code>函数。这两个函数都假定文件的位置可以存放在一个长整型中。</li>
<li><code>ftello</code>和<code>fseeko</code>函数。这两个函数使文件偏移量可以不必一定使用长整型。它们使用<code>off_t</code>数据类型代替了长整型。</li>
<li><code>fgetpos</code>和<code>fsetpos</code>函数。这两个函数使用一个抽象数据类型<code>fpos_t</code>记录文件的位置。这种数据类型可以根据需要定义为一个足够大的数，用以记录文件位置。</li>
</ul>
<p>需要移植到非UNIX系统上运行的应用程序应当使用<code>fgetpos</code>和<code>fsetpos</code><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">ftell</span><span class="params">(FILE *fp)</span></span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回当前文件位置指示；若出错，返回-1L</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fseek</span><span class="params">(FILE *fp， <span class="keyword">long</span> offset， <span class="keyword">int</span> whence)</span></span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回0；若出错，返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rewind</span><span class="params">(FILE *fp)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>对于一个二进制文件，其文件位置指示器是从文件起始位置开始度量，并以字节为度量单位的。<code>ftell</code>用于二进制文件时，其返回值就是这种字节位置。为了用<code>fseek</code>定位一个二进制文件，必须指定一个字节<code>offset</code>，以及解释这种偏移量的方式。<code>whence</code>的值与<code>lseek</code>函数的相同：<code>SEEK_SET</code>表示从文件的起始位置开始，<code>SEEK_CUR</code>表示从当前文件位置开始，<code>SEEK_END</code>表示从文件的尾端开始。</p>
<p>对于文本文件，它们的文件当前位置可能不以简单的字节偏移量来度量。这主要也是在非UNIX系统中，它们可能以不同的格式存放文本文件。为了定位一个文本文件，<code>whence</code>一定要是<code>SEEK_SET</code>。而且<code>offset</code>只能有两种值，0(后退到文件的起始位置)，或是对该文件的<code>ftell</code>所返回的值。使用<code>rewind</code>函数也可将一个流设置到文件的起始位置。</p>
<p>除了偏移量的类型是<code>off_t</code>而非<code>long</code>以外，<code>ftello</code>函数与<code>ftell</code>相同，<code>fseeko</code>函数与<code>fseek</code>相同。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">off_t</span> ftello(FILE *fp);</span><br><span class="line"><span class="comment">// 返回值：若成功，返回当前文件位置，若出错，返回(off_t)-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fseeko</span><span class="params">(FILE *fp， <span class="keyword">off_t</span> offset， <span class="keyword">int</span> whence)</span></span>;</span><br><span class="line"><span class="comment">// 返回值，若成功，返回0，若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>实现可将<code>off_t</code>类型定义为长于32位。</p>
<p><code>fgetpos</code>和<code>fsetpos</code>两个函数是ISO C标准引入的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fgetpos</span><span class="params">(FILE *<span class="keyword">restrict</span> fp， fpos_e *<span class="keyword">restrict</span> pos)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fsetpos</span><span class="params">(FILE *fp， <span class="keyword">const</span> <span class="keyword">fpos_t</span> *pos)</span></span>;</span><br><span class="line"><span class="comment">// 两个函数返回值。若成功。返回0:若出错，返回非0</span></span><br></pre></td></tr></table></figure></p>
<p><code>fgetpos</code>将文件位置指示器的当前值存入由<code>pos</code>指向的对象中。在以后调用<code>fsetpos</code>时，可以使用此值将流重新定位至该位置</p>
<h2 id="格式化I-O"><a href="#格式化I-O" class="headerlink" title="格式化I/O"></a>格式化I/O</h2><h3 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h3><p>格式化输出是由5个printf函数来处理的<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">printf</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format， ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fprintf</span><span class="params">(FILE *restzict fp， <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format， ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dprintf</span><span class="params">(<span class="keyword">int</span> fd， <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format， ...)</span></span>;</span><br><span class="line"><span class="comment">// 3个函数返回值：若成功，返回输出字符数：若输出出错，返回负值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sprintf</span><span class="params">(<span class="keyword">char</span> *<span class="keyword">restrict</span> buf， <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format， ...)</span></span>;</span><br><span class="line"><span class="comment">// 返回值，若成功，返回存入数组的字符数；若编码出错，返回负值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">snprintr</span><span class="params">(<span class="keyword">char</span> *<span class="keyword">restrict</span> buf， <span class="keyword">size_t</span> m， <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format， ...)</span></span>;</span><br><span class="line"><span class="comment">// 返回值，若缓冲区足够大，返回将要存入数组的字符数；若编码出错，返回负值</span></span><br></pre></td></tr></table></figure></p>
<p><code>printf</code>将格式化数据写到标准输出，<code>fprintf</code>写至指定的流，<code>dprintf</code>写至指定的文件描述符，<code>sprintf</code>将格式化的字符送入数组<code>buf</code>中。<code>sprintf</code>在该数组的尾端自动加一个null字节，但该字符不包括在返回值中。</p>
<p>注意，<code>sprintf</code>函数可能会造成由<code>buf</code>指向的缓冲区的溢出。为了解决这种缓冲区溢出问题，引入了<code>snprintf</code>函数。在该函数中，缓冲区长度是一个显式参数，超过缓冲区尾的所有字符都被丢弃。如果缓冲区足够大，<code>snprintf</code>函数就会返回写入缓冲区的字符数。与<code>sprintf</code>相同，该返回值不包括结尾的null字节。若<code>snprintf</code>函数返回小于缓冲区长度n的正值，那么没有截断输出。若发生了一个编码的错误，<code>snprintf</code>返回负值。</p>
<p>虽然<code>dprintf</code>不处理文件指针，但我们仍然把它包括在处理格式化输出的函数中。注意，使用<code>dprintf</code>不需要调用<code>fdopen</code>将文件描述符转换为文件指针。</p>
<p>格式说明控制其余参数如何编写，以后又如何显示。每个参数按照转换说明编写，转换说明以百分号<code>%</code>开始，除转换说明外，格式字符串中的其他字符将按原样，不经任何修改被复制输出。转换说明有4个可选择的部分，下面将它们都示于方括号中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%[flags] [fldwidth] [precision] [lenmodifier]convtype</span><br></pre></td></tr></table></figure></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>标志</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>‘</code></td>
<td>(撇号)将整数按千位分组字符</td>
</tr>
<tr>
<td><code>-</code></td>
<td>在字段内左对齐输出</td>
</tr>
<tr>
<td><code>+</code></td>
<td>总是显示带符号转换的正负号</td>
</tr>
<tr>
<td><code>(空格)</code></td>
<td>如果第一个字符不是正负号，则在其前面加上一个空格</td>
</tr>
<tr>
<td><code>#</code></td>
<td>指定另一种转换形式(例如。对于十六进制格式，加0x前缀</td>
</tr>
<tr>
<td><code>0</code></td>
<td>添加前号0(而非空格)进行填充</td>
</tr>
</tbody>
</table>
</div>
<p><code>fldwidth</code>说明最小字段宽度。转换后参数字符数若小于宽度，则多余字符位置用空格填充。字段宽度是一个非负十进制数，或是一个星号<code>*</code>。<code>precision</code>说明整型转换后最少输出数字位数、浮点数转换后小数点后的最少位数、 字符串转换后最大字节数。精度是一个点<code>.</code>，其后跟随一个可选的非负十进制数或一个星号<code>*</code>。</p>
<p>宽度和精度字段两者皆可为<code>*</code>。此时，一个整型参数指定宽度或精度的值。该整型参数正好位于被转换的参数之前。<code>lenmodifier</code>说明参数长度。其可能的值示于表中。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>长度修饰符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>hh</td>
<td>将相应的参数按signed或unsigned char类型输出</td>
</tr>
<tr>
<td>h</td>
<td>将相应的参数按signed成unelgned short类型输出</td>
</tr>
<tr>
<td>l</td>
<td>将相应的参数按signed或unsigned long或宽字符类型输出</td>
</tr>
<tr>
<td>ll</td>
<td>将相应的参数按signed或unsigned long long类型输出</td>
</tr>
<tr>
<td>j</td>
<td>intmax_t或uintmax_t</td>
</tr>
<tr>
<td>z</td>
<td>size_t</td>
</tr>
<tr>
<td>t</td>
<td>ptrdiff_t</td>
</tr>
<tr>
<td>L</td>
<td>long double</td>
</tr>
</tbody>
</table>
</div>
<p><code>convtype</code>不是可选的。它控制如何解释参数。下表中列出了各种转换类型字符。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>转换类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>d、i</td>
<td>有符号十进制</td>
</tr>
<tr>
<td>o</td>
<td>无符号八进制</td>
</tr>
<tr>
<td>u</td>
<td>无符号十进制</td>
</tr>
<tr>
<td>x、X</td>
<td>无符号十六进制</td>
</tr>
<tr>
<td>f、F</td>
<td>双精度浮点数</td>
</tr>
<tr>
<td>e、E</td>
<td>指数格式双精度浮点数</td>
</tr>
<tr>
<td>g、G</td>
<td>根据转换后的值解释为f、F、e或E</td>
</tr>
<tr>
<td>a、A</td>
<td>十六进制指数格式双精度浮点数</td>
</tr>
<tr>
<td>c</td>
<td>字符(若带长度修饰符l，为宽字符)</td>
</tr>
<tr>
<td>s</td>
<td>字符串(若带长度修饰符l，为宽字符)</td>
</tr>
<tr>
<td>p</td>
<td>指向void的指针</td>
</tr>
<tr>
<td>n</td>
<td>到目前为止，此printf调用输出的字符的数目将被写入到指针所指向的带符号整型中</td>
</tr>
<tr>
<td>%</td>
<td>一个%字符</td>
</tr>
<tr>
<td>C</td>
<td>宽字符(XSI扩展，等效于lc)</td>
</tr>
<tr>
<td>S</td>
<td>宽字符串(XSI扩展，等效于ls)</td>
</tr>
</tbody>
</table>
</div>
<p>下列5种<code>printf</code>族的变体类似于上面的5种，但是可变参数表(…)替换成了arg。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vprintf</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format， va_list arg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfprintf</span> <span class="params">(FILE *<span class="keyword">restrict</span> fp， <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format， va_list arg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vdprintf</span><span class="params">(<span class="keyword">int</span> fd， <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format， va_list arg)</span></span>;</span><br><span class="line"><span class="comment">// 所有3个函数返回值，若成功，返回输出字符数；若输出出错，返回负值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vsprintf</span><span class="params">(<span class="keyword">char</span> *<span class="keyword">restrict</span> buf， <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format， va_list arg)</span></span>;</span><br><span class="line"><span class="comment">// 函数返回值。若成功，返回存入数组的字符数，若编码出错，返回负值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vsnprintf</span> <span class="params">(<span class="keyword">char</span> *<span class="keyword">restrict</span> buf， <span class="keyword">size_t</span> m， <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format， va_list arg)</span></span>;</span><br><span class="line"><span class="comment">// 函数返回值。若缓冲区足够大，返回存入数组的字特数：若编码出错，返回负值</span></span><br></pre></td></tr></table></figure></p>
<h3 id="格式化输入"><a href="#格式化输入" class="headerlink" title="格式化输入"></a>格式化输入</h3><p>执行格式化输入处理的是3个<code>scanf</code>函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">scanf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format， ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fscanf</span><span class="params">(FILE *<span class="keyword">restrict</span> fp， <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format， ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sscanf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> buf， <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format， ...)</span></span>;</span><br><span class="line"><span class="comment">// 3个函数返回值，赋值的输入项数：若输入出错或在任一转换前已到达文件尾墙，返回EOF</span></span><br></pre></td></tr></table></figure></p>
<p>scanf族用于分析输入字符串，并将字符序列转换成指定类型的变量。在格式之后的各参数包含了变量的地址，用转换结果对这些变量赋值。</p>
<p>格式说明控制如何转换参数，以便对它们赋值。转换说明以<code>*</code>字符开始。除转换说明和空白字符外，格式字符串中的其他字符必须与输入匹配。若有一个字符不匹配，则停止后续处理，不再读输入的其余部分。</p>
<p>一个转换说明有3个可选择的部分，下面将它们都示于方括号中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%[*| [fldwidth] [m] [lenmodifier)convtype</span><br></pre></td></tr></table></figure></p>
<p>可选择的星号<code>*</code>用于抑制转换。按照转换说明的其余部分对输入进行转换，但转换结果并不存放在参数中。</p>
<p><code>fldwidth</code>说明最大宽度(即最大字符数)。<code>lenmodifier</code>说明要用转换结果赋值的参数大小。由<code>printf</code>函数族支持的长度修饰符同样得到scanf族函数的支持。</p>
<p><code>convtype</code>字段类似于<code>printf</code>族的转换类型字段，但两者之间还有些差别。一个差别是，作为一种选项，输入中带符号的可赋予无符号类型。例如，输入流中的-1可被转换成4294967295赋予无符号整型变量。</p>
<p>在字段宽度和长度修饰符之间的可选项<code>m</code>是赋值分配符。它可以用于<code>%c</code>、<code>%s</code>以及<code>%[</code>转换符，迫使内存缓冲区分配空间以接纳转换字符串。在这种情况下，相关的参数必须是指针地址，分配的缓冲区地址必须复制给该指针。如果调用成功，该缓冲区不再使用时，由调用者负责通过调用<code>free</code>函数来释放该缓冲区。</p>
<p>与<code>printf</code>族相同，<code>scanf</code>族也使用由<code>&lt;stdarg.h&gt;</code>说明的可变长度参数表。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vscanf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format， va_list arg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfscant</span><span class="params">(FILE *<span class="keyword">restrict</span> fp， <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format， va_list arg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vsscanf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> buf， <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format， va_list arg)</span></span>;</span><br><span class="line"><span class="comment">// 3个函数返回值，指定的输入项目数；若输入出错或在任一转换前文件结束。返回EOF</span></span><br></pre></td></tr></table></figure></p>
<h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><p>在UNIX中，标准I/O库最终都要调用第3章中说明的I/O例程，每个标准I/O流都有一个与其相关联的文件描述符，可以对一个流调用<code>fileno</code>函数以获得其描述符。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fileno</span><span class="params">(FILE *fp)</span></span>;</span><br><span class="line"><span class="comment">// 返回值：与该流相关联的文件描述符</span></span><br></pre></td></tr></table></figure></p>
<p>如果要调用<code>dup</code>或<code>fcntl</code>等函数，则需要此函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>	<span class="title">pr_stdio</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *, FILE *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span>		<span class="title">is_unbuffered</span><span class="params">(FILE *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span>		<span class="title">is_linebuffered</span><span class="params">(FILE *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span>		<span class="title">buffer_size</span><span class="params">(FILE *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	FILE	*fp;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fputs</span>(<span class="string">"enter any character\n"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">	<span class="keyword">if</span> (getchar() == EOF)</span><br><span class="line">		err_sys(<span class="string">"getchar error"</span>);</span><br><span class="line">	<span class="built_in">fputs</span>(<span class="string">"one line to standard error\n"</span>, <span class="built_in">stderr</span>);</span><br><span class="line"></span><br><span class="line">	pr_stdio(<span class="string">"stdin"</span>,  <span class="built_in">stdin</span>);</span><br><span class="line">	pr_stdio(<span class="string">"stdout"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">	pr_stdio(<span class="string">"stderr"</span>, <span class="built_in">stderr</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((fp = fopen(<span class="string">"/etc/passwd"</span>, <span class="string">"r"</span>)) == <span class="literal">NULL</span>)</span><br><span class="line">		err_sys(<span class="string">"fopen error"</span>);</span><br><span class="line">	<span class="keyword">if</span> (getc(fp) == EOF)</span><br><span class="line">		err_sys(<span class="string">"getc error"</span>);</span><br><span class="line">	pr_stdio(<span class="string">"/etc/passwd"</span>, fp);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">pr_stdio(<span class="keyword">const</span> <span class="keyword">char</span> *name， FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"stream = %s， "</span>, name);</span><br><span class="line">	<span class="keyword">if</span> (is_unbuffered(fp))</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"unbuffered"</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (is_linebuffered(fp))</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"line buffered"</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="comment">/* if neither of above */</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"fully buffered"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">", buffer size = %d\n"</span>, buffer_size(fp));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The following is nonportable.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(_IO_UNBUFFERED)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">is_unbuffered(FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span>(fp-&gt;_flags &amp; _IO_UNBUFFERED);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">is_linebuffered(FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span>(fp-&gt;_flags &amp; _IO_LINE_BUF);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">buffer_size(FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span>(fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(__SNBF)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">is_unbuffered(FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span>(fp-&gt;_flags &amp; __SNBF);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">is_linebuffered(FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span>(fp-&gt;_flags &amp; __SLBF);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">buffer_size(FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span>(fp-&gt;_bf._size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(_IONBF)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _LP64</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _flag __pad[4]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _ptr __pad[1]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _base __pad[2]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">is_unbuffered(FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span>(fp-&gt;_flag &amp; _IONBF);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">is_linebuffered(FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span>(fp-&gt;_flag &amp; _IOLBF);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">buffer_size(FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _LP64</span></span><br><span class="line">	<span class="keyword">return</span>(fp-&gt;_base - fp-&gt;_ptr);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	<span class="keyword">return</span>(BUFSIZ);	<span class="comment">/* just a guess */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">error</span> unknown stdio implementation!</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>注意，在打印缓冲状态信息之前，先对每个流执行I/O操作，第一个I/O操作通常就造成为该流分配缓冲区。</p>
<p>如果运行程序两次，一次使3个标准流与终端相连接，另一次使它们重定向到普通文件，则所得结果是：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out   <span class="comment"># stdin， atdout和stderr都连至终端</span></span><br><span class="line">enter any character</span><br><span class="line"></span><br><span class="line">one line to standard error</span><br><span class="line">stream = stdin， line buffered， buffer size = 1024</span><br><span class="line">stream = atdout， line buffered， butter size = 1024</span><br><span class="line">stream = stderr， unbuffered， buffer size = 1</span><br><span class="line">stream = /etc/passwd， fully butfered， buffer 8120 = 4096</span><br><span class="line">$ ./a.out &lt; /etc/group &gt; std.out 2&gt; atd.ext</span><br><span class="line"><span class="comment"># 3个流都重定向，再次运行该程序</span></span><br><span class="line">$ cat std.err</span><br><span class="line">one line to standard error</span><br><span class="line">$ cat std.out</span><br><span class="line">enter any character</span><br><span class="line">stream = stdin， fully buffered， buffer size = 4096</span><br><span class="line">stream = stdout， fully buffered， buffer size = 4096</span><br><span class="line">strean = stderr， unbuffered， buffer size = 1</span><br><span class="line">stream = /etc/passwd， fully buffered， buffer size = 4096</span><br></pre></td></tr></table></figure></p>
<p>从中可见，该系统的默认是：当标准输入、输出连至终端时，它们是行缓冲的。行缓冲的长度是1024字节。注意，这并没有将输入、输出的行长限制为1024字节，这只是缓冲区的长度。如果要将2048字节的行写到标准输出，则要进行两次write系统调用。当将这两个流重新定向到普通文件时，它们就变成是全缓冲的，其缓冲区长度是该文件系统优先选用的I/O长度(从<code>stat</code>结构中得到的<code>st_blksize</code>值)。从中也可看到，标准错误如它所应该的那样是不带缓冲的，而普通文件按系统默认是全缓冲的。</p>
<h2 id="临时文件"><a href="#临时文件" class="headerlink" title="临时文件"></a>临时文件</h2><p>ISO C标准I/O库提供了两个函数以帮助创建临时文件。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">tmpnam</span><span class="params">(<span class="keyword">char</span> *ptr)</span></span>;</span><br><span class="line"><span class="comment">// 返回值，指向唯一路径名的指针</span></span><br><span class="line"><span class="function">FILE *<span class="title">tmptile</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回文件指针；若出错，返回NULL</span></span><br></pre></td></tr></table></figure></p>
<p><code>tmpnam</code>函数产生一个与现有文件名不同的一个有效路径名字符串。每次调用它时，都产生一个不同的路径名，最多调用次数是<code>TMP_MAX</code>。<code>TMP_MAX</code>定义在<code>&lt;stdio.h&gt;</code>中。虽然ISO C定义了<code>TMP_MAX</code>，但该标准只要求其值至少应为25。</p>
<p>若<code>ptr</code>是NULL，则所产生的路径名存放在一个静态区中，指向该静态区的指针作为函数值返回。后续调用<code>tmpnam</code>时，会重写该静态区(这意味着，如果我们调用此函数多次，而且想保存路径名，则我们应当保存该路径名的副本，而不是指针的副本)。如若<code>ptr</code>不是NULL，则认为它应该是指向长度至少是<code>L_tmpnam</code>个字符的数组(常量<code>L_tmpnam</code>定义在头文件<code>&lt;stdio.h&gt;</code>中)。所产生的路径名存放在该数组中，pr也作为函数值返回。</p>
<p><code>tmpfile</code>创建一个临时二进制文件(类型<code>wb+</code>)，在关闭该文件或程序结束时将自动删除这种文件。注意，UNIX对二进制文件不进行特殊区分。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> name[L_tmpnam]， line[MAX_LINE];</span><br><span class="line">	FILE *fp;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, tmpnam(<span class="literal">NULL</span>) );</span><br><span class="line">	<span class="comment">/* tiret temp nane */</span></span><br><span class="line">	tmpnam(name);</span><br><span class="line">	<span class="comment">/*second temp name */</span></span><br><span class="line">	<span class="built_in">printf</span> (<span class="string">"%s\n"</span>, name);</span><br><span class="line">	<span class="keyword">if</span> ((fp = tmpfile()) == <span class="literal">NULL</span>)</span><br><span class="line">	<span class="comment">/*create temp file */</span></span><br><span class="line">	err_sys(<span class="string">"tmpfile error"</span>);</span><br><span class="line">	<span class="built_in">fputs</span>(<span class="string">"one line of outputin"</span>, fp);<span class="comment">/*write to temp file */</span></span><br><span class="line">	rewind(tp);</span><br><span class="line">	<span class="keyword">if</span> (fgets(line， <span class="keyword">sizeof</span>(line), fp) == <span class="literal">NULL</span>)</span><br><span class="line">	<span class="comment">/* then read it back */</span></span><br><span class="line">	err_sys (<span class="string">"fgets error"</span>);</span><br><span class="line">	<span class="built_in">fputs</span>(line， <span class="built_in">stdout</span>);</span><br><span class="line">	<span class="comment">/* print the line we wrote */</span></span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>tmpfile</code>函数经常使用的标准UNIX技术是先调用<code>tmpnam</code>产生一个唯一的路径名，然后，用该路径名创建一个文件，并立即<code>unlink</code>它。对一个文件解除链接并不删除其内容，关闭该文件时才删除其内容。而关闭文件可以是显式的，也可以在程序终止时自动进行。</p>
<p>Single UNIX Specification为处理临时文件定义了另外两个函数： <code>mkdtemp</code>和<code>mkstemp</code>，它们是XSI的扩展部分。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atd11b.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">mkdtemp</span><span class="params">(<span class="keyword">char</span> *<span class="keyword">template</span>)</span></span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回指向目录名的指针；若出错，返回NULL</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkstemp</span><span class="params">(<span class="keyword">char</span> *<span class="keyword">template</span>)</span></span>;</span><br><span class="line"><span class="comment">// 返回值，若成功，返回文件描述符，若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p><code>mkdtemp</code>函数创建了一个目录，该目录有一个唯一的名字；<code>mkstemp</code>函数创建了一个文件，该文件有一个唯一的名字。名字是通过template字符串进行选择的。这个字符串是后6位设置为xxxxxx的路径名。函数将这些占位符替换成不同的字符来构建一个唯一的路径名。如果成功的话，这两个函数将修改<code>template</code>字符串反映临时文件的名字。</p>
<p>由<code>mkdtemp</code>函数创建的目录使用下列访问权限位集：<code>S_IRUSR | S_IWUSR | S_IXUSR</code>。注意，调用进程的文件模式创建屏蔽字可以进一步限制这些权限。如果目录创建成功，<code>mkdtemp</code>返回新目录的名字。</p>
<p><code>mkstemp</code>函数以唯一的名字创建一个普通文件并，且打开该文件，该函数返回的文件描述符以读写方式打开。由<code>mkstemp</code>创建的文件使用访问权限位<code>S_IRUSR | S_IWUSR</code>。与<code>temptile</code>不同，<code>mkstemp</code>创建的临时文件并不会自动删除。如果希望从文件系统命名空间中删除该文件，必须自己对它解除链接。</p>
<p>使用<code>tmpnam</code>和<code>tempnam</code>至少有一个缺点：在返回唯一的路径名和用该名字创建文件之间存在一个时间窗口，在这个时间窗口中，另一进程可以用相间的名字创建文件。因此应该使用<code>tmpfile</code>和<code>mkstemp</code>函数，因为它们不存在这个问题。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">make_temp</span><span class="params">(<span class="keyword">char</span> *<span class="keyword">template</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">char</span>	good_template[] = <span class="string">"/tmp/dirXXXXXX"</span>;	<span class="comment">/* right way */</span></span><br><span class="line">	<span class="keyword">char</span>	*bad_template = <span class="string">"/tmp/dirXXXXXX"</span>;	<span class="comment">/* wrong way*/</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"trying to create first temp file...\n"</span>);</span><br><span class="line">	make_temp(good_template);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"trying to create second temp file...\n"</span>);</span><br><span class="line">	make_temp(bad_template);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">make_temp(<span class="keyword">char</span> *<span class="keyword">template</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span>			fd;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">stat</span>	<span class="title">sbuf</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((fd = mkstemp(<span class="keyword">template</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">		err_sys(<span class="string">"can't create temp file"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"temp name = %s\n"</span>, <span class="keyword">template</span>);</span><br><span class="line">	close(fd);</span><br><span class="line">	<span class="keyword">if</span> (stat(<span class="keyword">template</span>， &amp;sbuf) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (errno == ENOENT)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"file doesn't exist\n"</span>);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			err_sys(<span class="string">"stat failed"</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"file exists\n"</span>);</span><br><span class="line">		unlink(<span class="keyword">template</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，得到：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out</span><br><span class="line">trying to create tirmt temp file...</span><br><span class="line">temp name = /tmp/dirUmBT7h</span><br><span class="line">file exists</span><br><span class="line">trying to create second temp file..</span><br><span class="line">Segmentation fault</span><br></pre></td></tr></table></figure></p>
<p>两个模板字符串声明方式的不同带来了不同的运行结果。对于第一个模板，因为使用了数组，名字是在栈上分配的。但第二种情况使用的是指针，在这种情况下，只有指针自身驻留在栈上。编译器把字符串存放在可执行文件的只读段，当<code>mkstemp</code>函数试图修改字符申时，出现了段错误。</p>
<h2 id="内存流"><a href="#内存流" class="headerlink" title="内存流"></a>内存流</h2><p>我们已经看到，标准I/O库把数据缓存在内存中，因此每次一字符和每次一行的I/O更有效。我们也可以通过调用<code>setbuf</code>或<code>setvbuf</code>函数让I/O库使用我们自己的缓冲区。在SUSv4中支持了内存流。这就是标准I/O流，虽然仍使用FILE指针进行访问，但其实并没有底层文件。所有的I/O都是通过在缓冲区与主存之间来回传送字节来完成的。即便这些流看起来像文件流，它们的某些特征使其更适用于字符串操作。</p>
<p>有3个函数可用于内存流的创建，第一个是<code>fmemopen</code>函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function">FILE *<span class="title">fmemopen</span> <span class="params">(<span class="keyword">void</span> *<span class="keyword">restrict</span> buf， <span class="keyword">size_t</span> size， <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> type)</span></span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回流指针，若错误，返回NULL</span></span><br></pre></td></tr></table></figure></p>
<p><code>fmemopen</code>函数允许调用者提供缓冲区用于内存流：<code>buf</code>参数指向缓冲区的开始位置，<code>size</code>参数指定了缓冲区大小的字节数。如果<code>buf</code>参数为空， <code>fmemopen</code>函数分配<code>size</code>字节数的缓冲区。在这种情况下，当流关闭时缓冲区会被释放。</p>
<p><code>type</code>参数控制如何使用流。type可能的取值如表。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>type</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>r或rb</td>
<td>为读而打开</td>
</tr>
<tr>
<td>w或wb</td>
<td>为写而打开</td>
</tr>
<tr>
<td>a或ab</td>
<td>追加：为在第一个null字节处写而打开</td>
</tr>
<tr>
<td>r+或r+b或rb+</td>
<td>为读和写打开</td>
</tr>
<tr>
<td>w+或w+b或wb+</td>
<td>把文件截断至0长，为读和写而打开</td>
</tr>
<tr>
<td>a+或a+b或ab+</td>
<td>追加：为在第一个null字节处读和写打开</td>
</tr>
</tbody>
</table>
</div>
<p>注意，这些取值对应于基于文件的标准I/O流的type参数取值，但其中有些微小差别。第一，无论何时以追加写方式打开内存流时，当前文件位置设为缓冲区中的第一个null字节。如果缓冲区中不存在null字节，则当前位置就设为缓冲区结尾的后一个字节。当流并不是以追加写方式打开时，当前位置设为缓冲区的开始位置。因为追加写模式通过第一个null字节确定数据的尾端，内存流并不适合存储二进制数据(二进制数据在数据尾端之前就可能包含多个null字节)。</p>
<p>第二，如果buf参数是一个null指针，打开流进行读或者写都没有任何意义。因为在这种情况下缓冲区是通过<code>fmemopen</code>进行分配的，没有办法找到缓冲区的地址，只写方式打开流意味着无法读取已写入的数据，同样，以读方式打开流意味着只能读取那些我们无法写入的缓冲区中的数据。</p>
<p>第三，任何时候需要增加流缓冲区中数据量以及调用<code>fclose</code>、<code>fflush</code>、<code>fseek</code>、<code>fseeko</code>以及<code>fsetpos</code>时都会在当前位置写入一个null字节。</p>
<p>看一下对内存流的写入是如何在我们自己提供的缓冲区上进行操作的<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BSZ 48</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">	FILE *fp;</span><br><span class="line">	<span class="keyword">char</span> buf[BSZ];</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(buf， <span class="string">'a'</span>, BSZ<span class="number">-2</span>);</span><br><span class="line">	buf[BSZ<span class="number">-2</span>] = <span class="string">'\0'</span>;</span><br><span class="line">	buf[BSZ<span class="number">-1</span>] = <span class="string">'X'</span>;</span><br><span class="line">	<span class="keyword">if</span> ((fp = fmemopen(buf， BSZ， <span class="string">"w+"</span>)) == <span class="literal">NULL</span>)</span><br><span class="line">		err_sys(<span class="string">"fmemopen failed"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"initial buffer contents: %s\n"</span>, buf);</span><br><span class="line">	<span class="built_in">fprintf</span>(fp， <span class="string">"hello， world"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"before flush: %s\n"</span>, buf);</span><br><span class="line">	fflush(fp);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"after fflush: %s\n"</span>, buf);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"len of string in buf = %ld\n"</span>, (<span class="keyword">long</span>)<span class="built_in">strlen</span>(buf));</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(buf， <span class="string">'b'</span>, BSZ<span class="number">-2</span>);</span><br><span class="line">	buf[BSZ<span class="number">-2</span>] = <span class="string">'\0'</span>;</span><br><span class="line">	buf[BSZ<span class="number">-1</span>] = <span class="string">'X'</span>;</span><br><span class="line">	<span class="built_in">fprintf</span>(fp， <span class="string">"hello， world"</span>);</span><br><span class="line">	fseek(fp， <span class="number">0</span>， SEEK_SET);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"after  fseek: %s\n"</span>, buf);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"len of string in buf = %ld\n"</span>, (<span class="keyword">long</span>)<span class="built_in">strlen</span>(buf));</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(buf， <span class="string">'c'</span>, BSZ<span class="number">-2</span>);</span><br><span class="line">	buf[BSZ<span class="number">-2</span>] = <span class="string">'\0'</span>;</span><br><span class="line">	buf[BSZ<span class="number">-1</span>] = <span class="string">'X'</span>;</span><br><span class="line">	<span class="built_in">fprintf</span>(fp， <span class="string">"hello， world"</span>);</span><br><span class="line">	fclose(fp);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"after fclose: %s\n"</span>, buf);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"len of string in buf = %ld\n"</span>, (<span class="keyword">long</span>)<span class="built_in">strlen</span>(buf));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>用于创建内存流的其他两个函数分别是<code>open_memstream</code>和<code>open_wmemstream</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function">FILE *<span class="title">open_memstream</span><span class="params">(<span class="keyword">char</span> **bufp， <span class="keyword">size_t</span> *sizep)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;wchar.h&gt;</span></span></span><br><span class="line"><span class="function">FILE *<span class="title">open_wmemstream</span><span class="params">(<span class="keyword">wchar_t</span> **bufp， <span class="keyword">size_t</span> *sizep)</span></span>;</span><br><span class="line"><span class="comment">// 两个函数的返回值：若成功，返回流指针；若出错，返回NULL。</span></span><br></pre></td></tr></table></figure></p>
<p><code>open_memstream</code>函数创建的流是面向字节的，<code>open_wmemstream</code>函数创建的流是面向宽子节的。这两个函数与<code>fmemopen</code>的不同在于：</p>
<ul>
<li>创建的流只能打开；</li>
<li>不能指定自己的缓冲区，但可以分别通过<code>bufp</code>和<code>sizep</code>参数访问缓冲区地址和大小；</li>
<li>关闭流后需要自行释放缓冲区；</li>
<li>对流添加子节会增加缓冲区大小。</li>
</ul>
<p>但是在对缓冲区地址和大小使用必须遵循：</p>
<ul>
<li>缓冲区地址和长度只有在调用<code>fclose</code>或<code>fflush</code>后才有用；</li>
<li>这些值只有在下一次流写入或调用<code>fclose</code>前才有用。</li>
</ul>
<p>因为缓冲区可以增长，可能需要重新分配，所以缓冲区的内存地址在下一次调用<code>fclose</code>或<code>fflush</code>时会改变。</p>
<h1 id="系统数据文件和信息"><a href="#系统数据文件和信息" class="headerlink" title="系统数据文件和信息"></a>系统数据文件和信息</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>UNIX系统的正常运作需要使用大量与系统有关的数据文件，例如，口令文件<code>/etc/passwd</code>和组文件<code>/etc/group</code>就是经常被多个程序频繁使用的两个文件。由于历史原因，这些数据文件都是ASCII文本文件，并且使用标准I/O库读这些文件。但是，对于较大的系统，顺序扫描口令文件很花费时间，我们需要能够以非ASCII文本格式存放这些文件，但仍向使用其他文件格式的应用程序提供接口。</p>
<h2 id="口令文件"><a href="#口令文件" class="headerlink" title="口令文件"></a>口令文件</h2><p>UNIX系统口令文件包含了表中所示的各字段，这些字段包含在<code>&lt;pwd.h&gt;</code>中定义的<code>passwd</code>结构中。注意，POSIX.1只指定<code>passwd</code>结构包含的10个字段中的5个。大多数平台至少支持其中7个字段。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>说明</th>
<th><code>struct passwd</code>成员</th>
</tr>
</thead>
<tbody>
<tr>
<td>用户名</td>
<td><code>char *pw_name</code></td>
</tr>
<tr>
<td>加密口令</td>
<td><code>char *pw_passed</code></td>
</tr>
<tr>
<td>数值用户ID</td>
<td><code>uid_t pw_uid</code></td>
</tr>
<tr>
<td>数值组ID</td>
<td><code>gid_t pw_gid</code></td>
</tr>
<tr>
<td>注释字段</td>
<td><code>char *pw_gecos</code></td>
</tr>
<tr>
<td>初始工作日录</td>
<td><code>char *pw_dir</code></td>
</tr>
<tr>
<td>初始shell</td>
<td><code>char *pw_shell</code></td>
</tr>
<tr>
<td>用户访问类</td>
<td><code>char *pw_class</code></td>
</tr>
<tr>
<td>下次更改口令时间</td>
<td><code>time_t pw_change</code></td>
</tr>
<tr>
<td>账户有效期时间</td>
<td><code>time_t pw_expire</code></td>
</tr>
</tbody>
</table>
</div>
<p>口令文件是<code>/etc/passwd</code>，而且是一个ASCII文件。每一行包含各字段，字段之间用冒号分隔。例如，在Linux中，该文件中可能有下列4行:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">squid:x:23:23::/vax/spool/squid:/dev/null</span><br><span class="line">nobody:x:65534:65534:Nobody:/home:/bin/sh</span><br><span class="line">sar:x:205:105:Stephen Rago:/home/sar:/bin/bash</span><br></pre></td></tr></table></figure></p>
<p>关于这些登录项，请注意下列各点:</p>
<ul>
<li>通常有一个用户名为root的登录项，其用户ID是0(超级用户)。</li>
<li>加密口令字段包含了一个占位符。较早期的UNIX系统版本中，该字段存放加密口令字。将加密口令字存放在一个人人可读的文件中是一 个安全性漏洞，所以现在将加密口令字存放在另一个文件中。</li>
<li>口令文件项中的某些字段可能是空。如果加密口令字段为空，这通常就意味着该用户没有口令。<code>squid</code>登录项有一空白字段:注释字段。空白注释字段不产生任何影响。</li>
<li>shell字段包含了一个可执行程序名，它被用作该用户的登录shell。若该字段为空，则取系统默认值，通常是<code>/bin/sh</code>。注意，squid登录项的该字段为/dev/nu11。显然，这是一个设备，不是可执行文件，将其用于此处的目的是，阻止任何人以用户squid的名义登录到该系统。</li>
<li>为了阻止一个特定用户登录系统，替代方法是，将<code>/bin/false</code>用作登录shell。它简单地以不成功(非0)状态终止，该shell将此种终止状态判断为假。另一种常见方法是，用<code>/bin/true</code>禁止一个账户。它所做的一切是以成功(0)状态终止。某些系统提供<code>nologin</code>命令，它打印可定制的出错信息，然后以非0状态终止</li>
<li>使用<code>nobody</code>用户名的一个目的是，使任何人都可登录至系统，但其用户ID(65534)和组ID(65534)不提供任何特权。该用户ID和组ID只能访问人人皆可读、写的文件。</li>
<li>提供<code>finger()</code>命令的某些UNIX系统支持注释字段中的附加信息。其中，各部分之间都用逗号分隔：用户姓名、办公室地点、办公室电话号码以及家庭电话号码等。另外，如果注释字段中的用户姓名是一个<code>&amp;</code>，则它被替换为登录名。例如，可以有下列记录:</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sar:x:205:105:Steve Rago, SF 5-121, 555-1111, 555-2222:/home/sar:/bin/sh</span><br></pre></td></tr></table></figure>
<p>使用<code>finger</code>命令就可打印Steve Rago的有关信息。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ finger -p sar</span><br><span class="line">Login: sar</span><br><span class="line">Name: Steve Rago</span><br><span class="line">Directory: /home/sar</span><br><span class="line">shell: /bin/sh</span><br><span class="line">Office: SF 5-121， 555-1111</span><br></pre></td></tr></table></figure></p>
<p>某些系统提供了<code>vipw</code>命令，允许管理员使用该命令编辑口令文件。<code>vipw</code>命令串行化地更改口令文件，并且确保它所做的更改与其他相关文件保持一致。</p>
<p>POSIX.1定义了两个获取口令文件项的函数。在给出用户登录名或数值用户ID后，这两个函数就能查看相关项：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pwd.h&gt;</span></span></span><br><span class="line"><span class="function">struct passwd *<span class="title">getpwuid</span><span class="params">(<span class="keyword">uid_t</span> uid)</span></span>;</span><br><span class="line"><span class="function">struct passwd *<span class="title">getpwnam</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br><span class="line"><span class="comment">// 两个函数返回值。若成功。返回指针，若出错，返回NULL</span></span><br></pre></td></tr></table></figure></p>
<p><code>getpwuid</code>函数由ls(1)程序使用，它将inode节点中的数字用户ID映射为用户登录名。在键入登录名时，<code>getpwnam</code>函数由login(1)程序使用。</p>
<p>这两个函数都返回一个指向<code>passwd</code>结构的指针，该结构已由这两个函数在执行时填入信息。<code>passwd</code>结构通常是函数内部的静态变量，只要调用任一相关函数，其内容就会被重写。</p>
<p>如果要查看的只是登录名或用户ID，那么这两个POSIX.1函数能满足要求，但是也有些程序要查看整个口令文件。下列3个函数则可用于此种目的。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pwd.h&gt;</span></span></span><br><span class="line"><span class="function">struct passwd *<span class="title">getpwent</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setpwent</span> <span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="comment">// 返回值，着成功，返回指针，着出错或到达文件尾端，返回NULL</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">endpwent</span> <span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>调用<code>getpwent</code>时，它返回口令文件中的下一个记录项。它返回一个由它填写好的<code>passwd</code>结构的指针。每次调用此函数时都重写该结构。在第一次调用该函数时，它打开它所使用的各个文件。在使用本函数时，对口令文件中各个记录项的安排顺序并无要求。</p>
<p>函数<code>setpwent</code>反绕它所使用的文件，<code>endpwent</code>则关闭这些文件。在使用<code>getpwent</code>查看完口令文件后，一定要调用<code>endpwent</code>关闭这些文件。<code>getpwent</code>知道什么时间应当打开它所使用的文件(第一次被调用时)，但是它并不知道何时关闭这些文件。</p>
<p>程序给出了<code>getpwnam</code>函数的一个实现<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pwd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">passwd</span> *</span></span><br><span class="line"><span class="class"><span class="title">getpwnam</span> (<span class="title">const</span> <span class="title">char</span> *<span class="title">name</span>) &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">passed</span> *<span class="title">ptr</span>;</span></span><br><span class="line">	setpwent();</span><br><span class="line">	<span class="keyword">while</span> ((ptr = getpwent()) != <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">strcmp</span>(name, ptr-&gt;pw_name)  == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	<span class="comment">/* found a match */</span></span><br><span class="line">	endpwent ();</span><br><span class="line">	<span class="keyword">return</span>(ptr);</span><br><span class="line">	<span class="comment">/* ptr is NULL if no natch found */</span></span><br></pre></td></tr></table></figure></p>
<p>在函数开始处调用<code>setpwent</code>是自我保护性的措施，以便确保如果调用者在此之前已经调用<code>getpwent</code>打开了有关文件情况下，反绕有关文件使它们定位到文件开始处。<code>getpwnam</code>和<code>getpwuid</code>完成后不应使有关文件仍处于打开状态，所以应调用<code>endpwent</code>关闭它们。</p>
<h2 id="阴影口令"><a href="#阴影口令" class="headerlink" title="阴影口令"></a>阴影口令</h2><p>加密口令是经单向加密算法处理过的用户口令副本。因为此算法是单向的，所以不能从加密口令猜测到原来的口令。对于一个加密口令，找不到一种算法可以将其反变换到明文口令。但是可以对口令进行猜测，将猜测的口令经单向算法变换成加密形式，然后将其与用户的加密口令相比较。</p>
<p>某些系统将加密口令存放在另一个通常称为<strong>阴影口令</strong>(shadow password)的文件中。该文件至少要包含用户名和加密口令，与该口令相关的其他信息也可存放在该文件中。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>说明</th>
<th><code>struct spwd</code>成员</th>
</tr>
</thead>
<tbody>
<tr>
<td>用户登录名</td>
<td><code>char *op_namp</code></td>
</tr>
<tr>
<td>加密口令</td>
<td><code>char *sp_pwdp</code></td>
</tr>
<tr>
<td>上次更改口令以来经过的时间</td>
<td><code>int sp_lstchg</code></td>
</tr>
<tr>
<td>经多少天后允许更改</td>
<td><code>int sp_min</code></td>
</tr>
<tr>
<td>要求更改尚余天数</td>
<td><code>int sp_max</code></td>
</tr>
<tr>
<td>超期警告天数</td>
<td><code>int sp_warn</code></td>
</tr>
<tr>
<td>账户不活动之前尚余天数</td>
<td><code>int sp_inact</code></td>
</tr>
<tr>
<td>账户超期天数</td>
<td><code>int sp_expire</code></td>
</tr>
<tr>
<td>保留</td>
<td><code>unsigned int sp_flag</code></td>
</tr>
</tbody>
</table>
</div>
<p>只有用户登录名和加密口令这两个字段是必须的。其他的字段控制口令更改的频率，或者说口令的衰老以及账户仍然处于活动状态的时间。</p>
<p>阴影口令文件不应是一 般用户可以读取的。仅有少数几个程序需要访问加密口令，如<code>login(1)</code>和<code>passwd(1)</code>，这些程序常常是设置用户ID为root的程序。有了阴影口令后，普通口令文件<code>/etc/passwd</code>可由各用户自由读取。</p>
<p>有另一组函数可用于访问阴影口令文件。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;shadow.h&gt;</span></span></span><br><span class="line"><span class="function">struct sped *<span class="title">getspnan</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br><span class="line"><span class="function">struct spwd *<span class="title">getspent</span> <span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="comment">// 两个函数返回值，若成功，返回指针；若出错，返回NULL</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setspent</span> <span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">endspent</span> <span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h2 id="组文件"><a href="#组文件" class="headerlink" title="组文件"></a>组文件</h2><p>UNIX组文件包含了所示字段。这些字段包含在<code>&lt;grp.h&gt;</code>中所定义的group结构中。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>说明</th>
<th><code>struct group</code>成员</th>
</tr>
</thead>
<tbody>
<tr>
<td>组名</td>
<td><code>char *gr_name</code></td>
</tr>
<tr>
<td>加密口令</td>
<td><code>char *qr_passwd</code></td>
</tr>
<tr>
<td>数值组ID</td>
<td><code>int qr_gid</code></td>
</tr>
<tr>
<td>指向各用户名指针的数组</td>
<td><code>char **gr_mem</code></td>
</tr>
</tbody>
</table>
</div>
<p>字段<code>gr_mem</code>是一个指针数组，其中每个指针指向一个属于该组的用户名。该数组以null指针结尾。</p>
<p>可以用下列两个由POSIX.1定义的函数来查看组名或数值组ID.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;grp.h&gt;</span></span></span><br><span class="line"><span class="function">struct group *<span class="title">getgrgid</span><span class="params">(<span class="keyword">gid_t</span> gid)</span></span>;</span><br><span class="line"><span class="function">struct group *<span class="title">getgrnam</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br><span class="line"><span class="comment">// 两个函数返回值，若成功，返回指针，若出错，返回NULL</span></span><br></pre></td></tr></table></figure></p>
<p>如同对口令文件进行操作的函数一样，这两个函数通常也返回指向一个静态变量的指针，在每次调用时都重写该静态变量。</p>
<p>如果需要搜索整个组文件，则须使用另外几个函数。下列3个函数类似于针对口令文件的3个函数。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;grp.h&gt;</span></span></span><br><span class="line"><span class="function">struct group *<span class="title">getgrent</span> <span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回指针；若出错或到达文件尾，返回NULL</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setgrent</span> <span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">void endgrent (void),</span><br></pre></td></tr></table></figure></p>
<p><code>setgrent</code>函数打开组文件(如若它尚末被打开)并反绕它。<code>getgrent</code>函数从组文件中读下一个记录，如若该文件尚未打开，则先打开它。<code>endgrent</code>函数关闭组文件。</p>
<h2 id="附属组ID"><a href="#附属组ID" class="headerlink" title="附属组ID"></a>附属组ID</h2><p>每个用户任何时候都只属于一个组。当用户登录时，系统就按口令文件记录项中的数值组ID，赋给他实际组ID，可以在任何时候执行<code>newgrp(1)</code>以更改组ID，如果<code>newgrp</code>命令执行成功，则实际组ID就更改为新的组ID，它将被用于后续的文件访问权限检查。执行不带任何参数的<code>newgrp</code>，则可返回到原来的组。</p>
<p>BSD引入了附属组ID(supplementary group ID)的概念。我们不仅可以属于口令文件记录项中组ID所对应的组，也可属于多至16个另外的组。文件访问权限检查相应被修改为：不仅将进程的有效组ID与文件的组D相比较，而且也将所有附属组ID与文件的组ID进行比较。</p>
<p>附属组ID是POSIX.1要求的特性。常量<code>NGROUPS_MAX</code>规定了附属组ID的数量，常用值是16。</p>
<p>使用附属组ID的优点是不必再显式地经常更改组。一个用户会参与多个项目，因此也就要同时属于多个组，此类情况是常有的。为了获取和设置附属组ID，提供了下列3个函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getgroups</span> <span class="params">(<span class="keyword">int</span> gidsetize, <span class="keyword">gid_t</span> grouplist[])</span></span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回附属组ID数量；若出错，返回-1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;grp.h&gt; /* on Linux */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; /* on FreeBSD， Mac os x， and Solaris */</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setgroups</span> <span class="params">(<span class="keyword">int</span> ngroups, <span class="keyword">const</span> <span class="keyword">gid_t</span> grouplist[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">initgroups</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *weemame， <span class="keyword">gid_t</span> bassgid)</span></span>;</span><br><span class="line"><span class="comment">// 两个函数的返回值：若成功。返回0；若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p><code>getgroups</code>将进程所属用户的各附属组ID填写到数组<code>grouplist</code>中，填写入该数组的附属组ID数最多为<code>gidsetsize</code>个。实际填写到数组中的附属组ID数由函数返回。作为一种特殊情况，如若<code>gidsetsize</code>为0，则函数只返回附属组ID数，而对数组<code>grouplist</code>则不做修改。</p>
<p><code>setgroups</code>可由超级用户调用以便为调用进程设置附属组ID表。<code>grouplist</code>是组ID数组，而<code>ngroups</code>说明了数组中的元素数。<code>ngroups</code>的值不能大于<code>NGROUPS_MAX</code>。通常，只有<code>initgroups</code>函数调用<code>setgroups</code>，<code>initgroups</code>读整个组文件，然后对<code>username</code>确定其组的成员关系。然后，它调用<code>setgroups</code>，以便为该用户初始化附属组ID表。因为<code>initgroups</code>要调用<code>setgroups</code>，所以只有超级用户才能调用<code>initgroups</code>。除了在组文件中找到username是成员的所有组，<code>initgroups</code>也在附属组ID表中包括了<code>basegid</code>。<code>basegid</code>是<code>username</code>在口令文件中的组ID。</p>
<h2 id="其他数据文件"><a href="#其他数据文件" class="headerlink" title="其他数据文件"></a>其他数据文件</h2><p>至此仅讨论了两个系统数据文件——口令文件和组文件。在日常操作中，UNIX系统还使用很多其他文件。记录各网络服务器所提供服务的数据文件(<code>/etc/services</code>)，记录协议信息的数据文件(<code>/etc/protocols</code>)，记录网络信息的数据文件(<code>/etc/networks</code>)。</p>
<p>对于每个数据文件至少有3个函数：</p>
<ul>
<li><code>get</code>函数：读下一个记录，如果需要，还会打开该文件。此种函数通常返回指向一个结构的指针。当已达到文件尾端时返回空指针。大多数<code>get</code>函数返回指向一个静态存储类结构的指针，如果要保存其内容，则需复制它</li>
<li><code>set</code>函数：打开相应数据文件(如果尚末打开)，然后反绕该文件。如果希望在相应文件起始处开始处理，则调用此函数</li>
<li><code>end</code>函数：关闭相应数据文件。如前所述，在结束了对相应数据文件的读、写操作后，总应调用此函数以关闭所有相关文件</li>
</ul>
<p>另外，如果数据文件支持某种形式的键搜索，则也提供搜索具有指定键的记录的例程。例如，对于口令文件，提供了两个按键进行搜索的程序：<code>getpwnam</code>寻找具有指定用户名的记录；<code>getpwuid</code>寻找具有指定用户ID的记录。</p>
<p>下表中列出了一些这样的例程，这些都是UNIX常用的。在表中列出了针对口令文件和组文件的函数。表中也列出了一些与网络有关的函数。对于表中列出的所有<br>数据文件都有get、set和end函数<br><img src="/img/20210522143654.png" alt></p>
<h2 id="登录账户记录"><a href="#登录账户记录" class="headerlink" title="登录账户记录"></a>登录账户记录</h2><p>大多数UNIX系统都提供下列两个数据文件：<code>utmp</code>文件记录当前登录到系统的各个用户；<code>wtmp</code>文件跟踪各个登录和注销事件。在V7中，每次写入这两个文件中的是包含下列结构的一个二进制记录：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">utmp</span> &#123;</span></span><br><span class="line">	<span class="keyword">char</span> ut_line[<span class="number">8</span>]， <span class="comment">/* tty line: "ttyho", "ttydo", "ttypo", ... */</span></span><br><span class="line">	<span class="keyword">char</span> ut_name[<span class="number">8</span>]: <span class="comment">/* login nane */</span></span><br><span class="line">	<span class="keyword">long</span> ut_time;</span><br><span class="line">	<span class="comment">/* seconds since Epoch */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>登录时，login程序填写此类型结构， 然后将其写入到<code>utmp</code>文件中，同时也将其添写到<code>wtmp</code>文件中。注销时，<code>init</code>进程将<code>utmp</code>文件中相应的记录擦除(每个字节都填以null字节)，并将一个新记录添写到<code>wtmp</code>文件中。在<code>wtmp</code>文件的注销记录中，<code>ut_name</code>字段清除为0。在系统再启动时，以及更改系统时间和日期的前后，都在<code>wtmp</code>文件中追加写特殊的记录项。<code>who(1)</code>程序读取<code>utmp</code>文件，并以可读格式打印其内容，</p>
<h2 id="系统标识"><a href="#系统标识" class="headerlink" title="系统标识"></a>系统标识</h2><p>POSIX.1定义了<code>uname</code>函数，它返回与主机和操作系统有关的信息。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/utsname.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uname</span><span class="params">(struct utsname *name)</span></span>;</span><br><span class="line"><span class="comment">// 返回值。着成功，返回非负值。着出错，返回一</span></span><br></pre></td></tr></table></figure></p>
<p>通过该函数的参数向其传递一个<code>utsname</code>结构的地址，然后该函数填写此结构。POSIX.1只定义了该结构中最少需提供的字段(它们都是字符数组)，而每个数组的长度则由实现确定。某些实现在该结构中提供了另外一些字段。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">utsname</span> &#123;</span></span><br><span class="line">	<span class="keyword">char</span> sysname[];  <span class="comment">/* name of the operating system */</span></span><br><span class="line">	<span class="keyword">char</span> nodename[];  <span class="comment">/* name of this node */</span></span><br><span class="line">	<span class="keyword">char</span> release[];   <span class="comment">/* current release of operating system */</span></span><br><span class="line">	<span class="keyword">char</span> version[];   <span class="comment">/* current version of this release */</span></span><br><span class="line">	<span class="keyword">char</span> machine[];  <span class="comment">/* name of hardware type */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="时间和日期例程"><a href="#时间和日期例程" class="headerlink" title="时间和日期例程"></a>时间和日期例程</h2><p>由UNIX内核提供的基本时间服务是计算自协调世界时(Coordinated Universal Time，UCT)公元1970年1月1日00:00:00这一 特定时间以来经过的秒数。这种秒数是以数据类型<code>time_t</code>表示的，我们称它们为日历时间。日历时间包括时间和日期。UNIX在这方面与其他操作系统的区别是：</p>
<ol>
<li>以协调统一时间而非本地时间计时；</li>
<li>可自动进行转换，如变换到夏令时；</li>
<li>将时间和日期作为一个量值保存。</li>
</ol>
<p><code>time</code>函数返回当前时间和日期。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tine.h&gt;</span></span></span><br><span class="line"><span class="keyword">time_t</span> time(<span class="keyword">time_t</span> *calptr);</span><br><span class="line"><span class="comment">// 返回值。若成功，返回时间值，若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>时间值作为函数值返回。如果参数非空，则时间值也存放在由<code>calptr</code>指向的单元内。</p>
<p>POSXI.1的实时扩展增加了对多个系统时钟的支持。时钟通过<code>clockid_t</code>类型进行标识。下表给出了标准值。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>标识符</th>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>CLOCK_REALTIME</code></td>
<td></td>
<td>实时系统时间</td>
</tr>
<tr>
<td><code>CLOCK_MONOTONIC</code></td>
<td><code>_POSIX_MONOTONIC_CLOCK</code></td>
<td>不带负跳数的实时系统时间</td>
</tr>
<tr>
<td><code>CLOCK_PROCESS_CPUTIMB_ID</code></td>
<td><code>_POSIX_CPUTIME</code></td>
<td>调用进程的CPU时间</td>
</tr>
<tr>
<td><code>CLOCK_THREAD_CPUTIME_ID</code></td>
<td><code>_POSIX_THREAD_CPUTIME</code></td>
<td>调用线程的CPU时间</td>
</tr>
</tbody>
</table>
</div>
<p><code>clock_gettime</code>函数可用于获取指定时钟的时间，返回的时间在<code>timespec</code>结构中，它把时间表示为秒和纳秒。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">clock_gettime</span><span class="params">(<span class="keyword">clockid_t</span> clock_id, struct timespec *tsp)</span></span>;</span><br><span class="line"><span class="comment">// 返回值，若成功，返回0；若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>当时钟ID设置为<code>CLOCK_REALTIME</code>时，<code>clock_gettime</code>函数提供了与<code>time</code>函数类似的功能，不过在系统支持高精度时间值的情况下，<code>clock_ gettime</code>可能比<code>time</code>函数得到更高精度的时间值。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">clock_getres</span> <span class="params">(<span class="keyword">clockid_t</span> clock_id, struct timespec *tsp)</span></span>;</span><br><span class="line"><span class="comment">// 返回值。若成功，返回0；若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p><code>clock_getres</code>函数把参数<code>tsp</code>指向的<code>timespec</code>结构初始化为与<code>clock_id</code>参数对应的时钟精度。例如，如果精度为1毫秒，则<code>tv_sec</code>字段就是0，<code>tv_nsec</code>字段就是1000000。</p>
<p>要对特定的时钟设置时间，可以调用<code>clock_settime</code>函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">clock_settime</span><span class="params">(<span class="keyword">clockid_t</span> clock_id， <span class="keyword">const</span> struct timespec *ap)</span></span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回0；若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>SUSv4指定<code>gettimeofday</code>函数现在已弃用。然而，一些程序仍然使用这个函数，因为与<code>time</code>函数相比，<code>gettimeofday</code>提供了更高的精度(可到微秒级)。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gettimeofday</span><span class="params">(struct timeval *<span class="keyword">restrict</span> tp, <span class="keyword">void</span> *<span class="keyword">restrict</span> tzp)</span></span>;</span><br><span class="line"><span class="comment">// 返回值。总是返回0</span></span><br></pre></td></tr></table></figure></p>
<p><code>tzp</code>的唯一合法值是NULL，其他值将产生不确定的结果。某些平台支持用<code>tzp</code>说明时区，但这完全依实现而定。</p>
<p><code>gettimeofday</code>函数以距特定时间(1970年1月1日00:00:00)的秒数的方式将当前时间存放在<code>tp</code>指向的<code>timeval</code>结构中，而该结构将当前时间表示为秒和微秒。一旦取得这种从上述特定时间经过的秒数的整型时间值后，通常要调用函数将其转换为分解的时间结构，然后调用另一个函数生成人们可读的时间和日期。图6-9说明了各种时间函数之间的关系。(图中以虚线表示的3个函数<code>localtime</code>、<code>mktime</code>和<code>strftime</code>都受到环境变量<code>TZ</code>的影响)</p>
<p>两个函数<code>localtime</code>和<code>gmtime</code>将日历时间转换成分解的时间，并将这些存放在一个<code>tm</code>结构中。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tm</span> &#123;</span>     <span class="comment">/* a broken-down time */</span></span><br><span class="line">	<span class="keyword">int</span> tm_sec; <span class="comment">/* seconds after the minute: [0 - 60] */</span></span><br><span class="line">	<span class="keyword">int</span> tm_min; <span class="comment">/* minutes after the hour: [0 - 59] */</span></span><br><span class="line">	<span class="keyword">int</span> tm_hour;<span class="comment">/* hours after midnight: [0 - 23] */</span></span><br><span class="line">	<span class="keyword">int</span> tm_mday;<span class="comment">/* day of the month: [1 - 31] */</span></span><br><span class="line">	<span class="keyword">int</span> tm_mon; <span class="comment">/* months since January: [0 - 11] */</span></span><br><span class="line">	<span class="keyword">int</span> tm_year;<span class="comment">/* years since 1900 */</span></span><br><span class="line">	<span class="keyword">int</span> tm_wday;<span class="comment">/* days since Sunday: [0 - 6] */</span></span><br><span class="line">	<span class="keyword">int</span> tm_yday;<span class="comment">/* days since January 1: [0 - 365]  */</span></span><br><span class="line">	<span class="keyword">int</span> tm_isdst;<span class="comment">/* daylight saving time tiag: &lt;0， 0， &gt;0 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>秒可以超过59的理由是可以表示润秒。注意，除了月日字段，其他字段的值都以0开始。如果夏令时生效，则夏令时标志值为正。如果为非夏令时时间，则该标志值为0；如果此信息不可用，则其值为负。</p>
<p><img src="/img/20210522150750.png" alt></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="function">struct tm *<span class="title">gmtime</span><span class="params">(<span class="keyword">const</span> <span class="keyword">time_t</span> *calptr)</span></span>;</span><br><span class="line"><span class="function">struct tm *<span class="title">localtime</span><span class="params">(<span class="keyword">const</span> <span class="keyword">time_t</span> *calper)</span></span>;</span><br><span class="line"><span class="comment">// 两个函数的返回值：指向分解的tm结构的指针，若出错，返回NULL</span></span><br></pre></td></tr></table></figure>
<p><code>localtime</code>和<code>gmtime</code>之间的区别是：<code>localtime</code>将日历时间转换成本地时间，而<code>gmtime</code>则将日历时间转换成协调统一时间的年、月、日、时、分、<br>秒、周日分解结构。</p>
<p>函数<code>mktime</code>以本地时间的年、月、日等作为参数，将其变换成<code>time_t</code>值。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="keyword">time_t</span> mktime(struct tm *tmptr);</span><br><span class="line"><span class="comment">// 返回值。若成功，返回日历时间，若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>函数<code>strftime</code>是一个类似于<code>printf</code>的时间值函数。它非常复杂，可以通过可用的多个参数来定制产生的字符串。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="keyword">size_t</span> strftime(<span class="keyword">char</span> *<span class="keyword">restrict</span> buf, <span class="keyword">size_t</span> maxsize,</span><br><span class="line">				<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format,</span><br><span class="line">				<span class="keyword">const</span> struct tm *<span class="keyword">restrict</span> tmptr);</span><br><span class="line"><span class="keyword">size_t</span> strftime_l(<span class="keyword">char</span> *<span class="keyword">restrict</span> buf, <span class="keyword">size_t</span> maxsize,</span><br><span class="line">				<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format,</span><br><span class="line">				<span class="keyword">const</span> struct tm *<span class="keyword">restrict</span> tmptr, <span class="keyword">locale_t</span> locale);</span><br><span class="line"><span class="comment">// 两个函数的返回值。若有空间。返回存入数组的字符数。否则，返回0</span></span><br></pre></td></tr></table></figure></p>
<p><code>strftime_l</code>允许调用者将区域指定为参数，除此之外，<code>strftime</code>和<code>strftime_l</code>函数是相同的。<code>strftime</code>使用通过<code>TZ</code>环境变量指定的区域。</p>
<p><code>tmptr</code>参数是要格式化的时间值，由一个指向分解时间值<code>tm</code>结构的指针说明。格式化结果存放在一个长度为<code>maxsize</code>个字符的<code>buf</code>数组中，如果<code>buf</code>长度足以存放格式化结果及一个null终止符，则该函数返回在<code>buf</code>中存放的字符数(不包括null终止符)；否则该函数返回0。</p>
<p><code>format</code>参数控制时间值的格式。如同<code>printf</code>函数一样，转换说明的形式是百分号之后跟一个特定字符。<code>format</code>中的其他字符则按原样输出。两个连续的百分号在输出中产生一个百分号。</p>
<p>与printf函数的不同之处是，每个转换说明产生一个不同的定长输出字符串，在<code>format</code>字符串中没有字段宽度修饰符。图中列出了37种ISO C规定的转换说明。<br><img src="/img/20210522151557.png" alt></p>
<p>程序演示了如何使用本章中讨论的多个时间函数。特别演示了如何使用<code>strftime</code>打印包含当前日期和时间的字符串。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">time_t</span> t;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tm</span> *<span class="title">tmp</span>;</span></span><br><span class="line">	<span class="keyword">char</span> buf1[<span class="number">16</span>];</span><br><span class="line">	<span class="keyword">char</span> buf2[<span class="number">64</span>];</span><br><span class="line"></span><br><span class="line">	time(&amp;t);</span><br><span class="line">	tmp = localtime(&amp;t);</span><br><span class="line">	<span class="keyword">if</span> (strftime(buf1, <span class="number">16</span>, <span class="string">"time and date: %r, %a %b %d, %Y"</span>, tmp) == <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"buffer length 16 is too small\n"</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, buf1);</span><br><span class="line">	<span class="keyword">if</span> (strftime(buf2, <span class="number">64</span>, <span class="string">"time and date: %r, %a %b %d, %Y"</span>, tmp) == <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"buffer length 64 is too small\n"</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, buf2);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>程序的输出如下:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out</span><br><span class="line">buffer length 16 is too small</span><br><span class="line">time and date: 12:12:35 M, Thu Jan 19, 2012</span><br></pre></td></tr></table></figure></p>
<p><code>strptime</code>函数是<code>strftime</code>的反过来版本，把字符串时间转换成分解时间。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strptime</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> buf, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format, struct tm *<span class="keyword">restrict</span> tmptr)</span></span>;</span><br><span class="line"><span class="comment">// 返回值。指向上次解析的字符的下一个字符的指针；否则，返回NULL</span></span><br></pre></td></tr></table></figure></p>
<p><code>format</code>参数给出了<code>buf</code>参数指向的缓冲区内的字符串的格式。虽然与<code>strftime</code>函数的说明稍有不同，但格式说明是类似的。<code>strptime</code>函数转换说明符列在图6-12中。<br><img src="/img/20210522152120.png" alt></p>
<p>我们曾在前面提及，图6-9中以虚线表示的3个函数受到环境变量<code>TZ</code>的影响。这3个函数是<code>localtime</code>，<code>mktime</code>和<code>strftime</code>。如果定义了<code>TZ</code>，则这些函数将使用其值代替系统默认时区。如果<code>TZ</code>定义为空(即<code>TZ=&quot;&quot;</code>)，则使用协调统一时间UTC。</p>
<h1 id="迸程环境"><a href="#迸程环境" class="headerlink" title="迸程环境"></a>迸程环境</h1><h2 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h2><p>C程序总是从main函数开始执行。main函数的原型是:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> angc, <span class="keyword">char</span> *argv[])</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>其中，<code>argc</code>是命令行参数的数目，<code>argv</code>是指向参数的各个指针所构成的数组。</p>
<p>当内核执行C程序时(使用一个exec函数)，在调用main前先调用一个特殊的启动例程。可执行程序文件将此启动例程指定为程序的起始地址一这是由连接<br>编辑器设置的，而连接编辑器则由C编译器调用。启动例程从内核取得命令行参数和环境变量值，然后为按上述方式调用main函数做好安排。</p>
<h2 id="进程终止"><a href="#进程终止" class="headerlink" title="进程终止"></a>进程终止</h2><p>有8种方式使进程终止(termination)，其中5种为正常终止，它们是:</p>
<ol>
<li>从main返回;</li>
<li>调用<code>exit</code>;</li>
<li>调用<code>_exit</code>或<code>_Exit</code>;</li>
<li>最后一个线程从其启动例程返回;</li>
<li>从最后一个线程调用<code>pthread_exit</code>;。</li>
</ol>
<p>异常终止有3种方式，它们是</p>
<ol>
<li>调用<code>abort</code>;</li>
<li>接到一个信号;</li>
<li>最后一个线程对取消请求做出响应。</li>
</ol>
<p>上节提及的启动例程是这样编写的，使得从<code>main</code>返回后立即调用<code>exit</code>函数。如果将启动例程以C代码形式表示(实际上该例程常常用汇编语言编写)，则它调用main函数的形式可能是:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exit</span> (main (argc, argv));</span><br></pre></td></tr></table></figure></p>
<h3 id="退出函数"><a href="#退出函数" class="headerlink" title="退出函数"></a>退出函数</h3><p>3个函数用于正常终止一个程序：<code>_exit</code>和<code>_Exit</code>立即进入内核，<code>exit</code>则先执行一些清理处理，然后返回内核。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exit</span><span class="params">(<span class="keyword">int</span> status)</span></span>;</span><br><span class="line"><span class="keyword">void</span> _Exit(<span class="keyword">int</span> stane);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">void</span> _exit (<span class="keyword">int</span> status);</span><br></pre></td></tr></table></figure></p>
<p>exit函数总是执行一个标准I/O库的清理关闭操作：对于所有打开流调用<code>fclose</code>函数。</p>
<p>3个退出函数都带一个整型参数，称为终止状态(或退出状态，exit status)。大多数UNIX系统shell都提供检查进程终止状态的方法。如果：</p>
<ul>
<li>调用这些函数时不带终止状态；</li>
<li>main执行了一个无返回值的return语句；</li>
<li>main没有声明返回类型为整型</li>
</ul>
<p>则该进程的终止状态是未定义的。但是，若main的返回类型是整型，并且main执行到最后一条语句时返回(隐式返回)，那么该进程的终止状态是0。</p>
<p>main函数返回一个整型值与用该值调用exit是等价的。于是在main函数中<code>exit(0);</code>等价于<code>return(0);</code>。</p>
<p>图中的程序是经典的“hello，world”实例。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">main () &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"hello, world\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对该程序进行编译，然后运行，则可见到其终止码是随机的。如果在不同的系统上编译该程序，我们很可能得到不同的终止码，这取决于main函数返回时栈和寄存器的内容:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ gcc hello.c</span><br><span class="line">$ ./a.out</span><br><span class="line">hello, world</span><br><span class="line">$ <span class="built_in">echo</span> $?     <span class="comment">#打印终止状态</span></span><br><span class="line">13</span><br></pre></td></tr></table></figure></p>
<p>现在，我们启用1999 ISO C编译器扩展，则可见到终止码改变了：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ gcc-std=c99 hello.c   <span class="comment">#启用gcc的1999 ISO C扩展</span></span><br><span class="line">hello.c: 4: warning: <span class="built_in">return</span> <span class="built_in">type</span> defaults to <span class="string">'int'</span></span><br><span class="line">$ ./a.out</span><br><span class="line">hello, world</span><br><span class="line">$ <span class="built_in">echo</span> $?                <span class="comment">#打印终止状态</span></span><br><span class="line">0</span><br></pre></td></tr></table></figure></p>
<p>注意，当我们启用1999 ISO C扩展时，编译器发出警告消息。打印该警告消息的原因是：main函数的类型没有显式地声明为整型。如果我们增加了这一声明，那么此警告消息就不会出现。但是，如果我们使编译器所推荐的警告消息都起作用(使用<code>-wall</code>标志)，则可能见到类似于“control reaches end of nowoid function.”(控制到达非void函数的尾端)这样的警告消息。</p>
<p>将<code>main</code>声明为返回整型，但在<code>main</code>函数体内用<code>exit</code>代替<code>return</code>，对某些C编译器而言会产生不必要的警告信息，因为这些编译器并不了解<code>main</code>中的<code>exit</code>与<code>return</code>语句的作用相同。避开这种警告信息的一种方法是在<code>main</code>中使用<code>return</code>语句而不是<code>exit</code>。</p>
<h3 id="函数atexit"><a href="#函数atexit" class="headerlink" title="函数atexit"></a>函数atexit</h3><p>按照ISO C的规定，一个进程可以登记多至32个函数，这些函数将由<code>exit</code>自动调用。我们称这些函数为终止处理程序(exit  handler)，并调用<code>atexit</code>函数来登记这些函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">atexit</span> <span class="params">(<span class="keyword">void</span> (*func) (<span class="keyword">void</span>))</span></span>;</span><br><span class="line"><span class="comment">// 返回值，若成功，返回0；若出错，返回非0</span></span><br></pre></td></tr></table></figure></p>
<p>其中，<code>atexit</code>的参数是一个函数地址，当调用此函数时无需向它传递任何参数，也不期望它返回一个值。<code>exit</code>调用这些函数的顺序与它们登记时候的顺序相反。同一函数如若登记多次，也会被调用多次。</p>
<p>ISOC要求，系统至少应支持32个终止处理程序，但实现经常会提供更多的支持。为了确定一个给定的平台支持的最大终止处理程序数，可以使用<code>sysconf</code>函数。</p>
<p><code>exit</code>首先调用各终止处理程序，然后关闭(通过<code>fclose</code>)所有打开流。POSIX.1扩展了ISO C标准，它说明，如若程序调用<code>exec</code>函数族中的任一函数，则将清除所有已安装的终止处理程序。图7-2显示了一个C程序是如何启动的，以及它终止的各种方式。<br><img src="/img/20210522173047.png" alt></p>
<p>注意，内核使程序执行的唯一方法是调用一个<code>exec</code>函数。进程自愿终止的唯一方法是显式或隐式地(通过调用<code>exit</code>)调用<code>_exit</code>或<code>_Exit</code>。进程也可非自愿地由一个信号使其终止。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">my_exit1</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">my_exit2</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (atexit (my_exit2) != <span class="number">0</span>)</span><br><span class="line">		err_sys (<span class="string">"can't register my_exit2"</span>);</span><br><span class="line">	<span class="keyword">if</span> (atexit (my_exit1) != <span class="number">0</span>)</span><br><span class="line">		err_sys (<span class="string">"can't register my_exit1"</span>);</span><br><span class="line">	<span class="keyword">if</span> (atexit (my_exit1) != <span class="number">0</span>)</span><br><span class="line">		err_ays(<span class="string">"can't register my_exiti"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"main is done\n"</span>);</span><br><span class="line">	<span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">my_exit1</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	printt(<span class="string">"tirat exit handler\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">my_exit2</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	printt(<span class="string">"second exit handier\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行该程序产生<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out</span><br><span class="line">main is <span class="keyword">done</span></span><br><span class="line">first <span class="built_in">exit</span> handler</span><br><span class="line">first <span class="built_in">exit</span> handler</span><br><span class="line">second <span class="built_in">exit</span> handler</span><br></pre></td></tr></table></figure></p>
<p>终止处理程序每登记一次，就会被调用一次。在程序中，第一个终止处理程序被登记两次，所以也会被调用两次。注意，在<code>main</code>中没有调用<code>exit</code>，而是用了return语句。</p>
<h2 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h2><p>当执行一个程序时，调用exec的进程可将命令行参数传递给该新程序。这是UNIX shell的一部分常规操作。</p>
<p>程序将其所有命令行参数都回显到标准输出上。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc， <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; argc; i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"argv[%d]: %s\n"</span>, i, argv[i]);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="环境表"><a href="#环境表" class="headerlink" title="环境表"></a>环境表</h2><p>每个程序都接收到一张环境表。与参数表一样，环境表也是一个字符指针数组，其中每个指针包含一个以null结束的C字符串的地址。全局变量<code>environ</code>则包含了该指针数组的地址:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> **environ;</span><br></pre></td></tr></table></figure></p>
<p>例如，如果该环境包含5个字符串，那么它看起来如图中所示。其中，每个字符串的结尾处都显式地有一个null字节。我们称<code>environ</code>为环境指针(environment pointer)，指针数组为环境表，其中各指针指向的字符串为环境字符串。<br><img src="/img/20210522173933.png" alt></p>
<p>按照惯例，环境由<code>name = value</code>这样的字符串组成，大多数预定义名完全由大写字母组成，但这只是一个惯例。</p>
<p>在历史上，大多数UNIX系统支持main函数带3个参数，其中第3个参数就是环境表地址:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[], <span class="keyword">char</span> *envp[])</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>因为ISO C规定main函数只有两个参数，而且第3个参数与全局变量<code>environ</code>相比也没有带来更多益处，所以POSIX.1也规定应使用<code>environ</code>而不使用第3个参数。通常用<code>getenv</code>和<code>putenv</code>函数来访问特定的环境变量，而不是用<code>environ</code>变量。但是，如果要查看整个环境，则必须使用<code>environ</code>指针。</p>
<h2 id="C程序的存储空间布局"><a href="#C程序的存储空间布局" class="headerlink" title="C程序的存储空间布局"></a>C程序的存储空间布局</h2><p>历史沿袭至今，C程序一直由下列几部分组成:</p>
<ul>
<li>正文段。这是由CPU执行的机器指令部分。通常，正文段是可共享的，所以即使是频繁执行的程序在存储器中也只需有一个副本，另外，正文段常常是只读的，以防止程序由于意外面修改其指令。</li>
<li>初始化数据段。通常将此段称为数据段，它包含了程序中需明确地赋初值的变量。例如，C程序中任何函数之外的声明使此变量以其初值存放在初始化数据段中。</li>
<li>未初始化数据段。通常将此段称为bss段，这一名称来源于早期汇编程序一个操作符，意思是“由符号开始的块”(block started by symbol)，在程序开始执行之前，内核将此段中的数据初始化为0或空指针。函数外的声明使此变量存放在非初始化数据段中。</li>
<li>栈。自动变量以及每次函数调用时所需保存的信息都存放在此段中。每次函数调用时，其返回地址以及调用者的环境信息都存放在栈中。然后，最近被调用的函数在栈上为其自动和临时变量分配存储空间。通过以这种方式使用栈，C递归函数可以工作。递归函数每次调用自身时，就用一个新的栈帧，因此一次函数调用实例中的变量集不会影响另一次函数调用实例中的变量。</li>
<li>堆。通常在堆中进行动态存储分配。由于历史上形成的惯例，堆位于未初始化数据段和栈之间</li>
</ul>
<p><img src="/img/20210522174418.png" alt></p>
<p>图7-6显示了这些段的一种典型安排方式。这是程序的逻辑布局，虽然并不要求一个具体实现一定以这种方式安排其存储空间，但这是一种我们便于说明的典型安排。堆顶和栈项之间未用的虚地址空间很大。</p>
<blockquote>
<p>a.out中还有若干其他类型的段，如包含符号表的段、包含调试信息的授以及包含动态共享库链接表的段等。这些部分并不装载到进程执行的程序映像中。</p>
</blockquote>
<p>从图7-6还可注意到，未初始化数据段的内容并不存放在磁盘程序文件中。其原因是，内核在程序开始运行前将它们都设置为0.需要存放在磁盘程序文件中的段只有正文段和初始化数据段。</p>
<p><code>size()</code>命令报告正文段、数据段和bss段的长度(以字节为单位)。例如:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ size /usr/bin/cc</span><br><span class="line">text    data    bss     dec     hex   filename</span><br><span class="line">346919  3576    6680   357175  57337  /usz/bin/cc</span><br></pre></td></tr></table></figure></p>
<p>第4列和第5列是分别以十进制和十六进制表示的3段总长度。</p>
<h2 id="共享库"><a href="#共享库" class="headerlink" title="共享库"></a>共享库</h2><p>共享库使得可执行文件中不再需要包含公用的库函数，而只需在所有进程都可引用的存储区中保存这种库例程的一个副本。程序第一次执行或者第一次调用某个库函数时，用动态链接方法将程序与共享库函数相链接。这减少了每个可执行文件的长度，但增加了一些运行时间开销。这种时间开销发生在该程序第一次被执行时，或者每个共享库函数第一次被调用时。共享库的另一个优点是可以用库函数的新版本代替老版本而无需对使用该库的程序重新连接编辑。</p>
<p>在不同的系统中，程序可能使用不同的方法说明是否要使用共享库，比较典型的有cc(1)和ld(1)命令的选项。作为长度方面发生变化的例子，先用无共享库方式创建下列可执行文件(典型的hello.c程序):<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -static hello.o.       <span class="comment">#阻止gcc使用共享库</span></span><br><span class="line">$ ls -l a.out</span><br><span class="line">-rwxrwxr-x 1 sar 	879443 Sep 2 10:39 a.out</span><br><span class="line">$ size a.out</span><br><span class="line">text 	data 	bss 	dec 	hex 	filename</span><br><span class="line">787775	6128 	11272  805175  c4937 	  a.out</span><br></pre></td></tr></table></figure></p>
<p>如果再使用共享库编译此程序，则可执行文件的正文和数据段的长度都显著减小:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ gcc hello.c 		<span class="comment">#gcc默认使用共享库</span></span><br><span class="line">$ ls -l a.out</span><br><span class="line">-rwxrwxr-x 1 sar 	8378 Sep 2 10:39 a.out</span><br><span class="line">$ size a.out</span><br><span class="line">text 	data 	bss 	dec 	hex 	filename</span><br><span class="line">1176	504 	16  	1696  	6a0 	  a.out</span><br></pre></td></tr></table></figure></p>
<h2 id="存储空间分配"><a href="#存储空间分配" class="headerlink" title="存储空间分配"></a>存储空间分配</h2><p>ISO C说明了3个用于存储空间动态分配的函数。</p>
<ul>
<li><code>malloc</code>，分配指定字节数的存储区。此存储区中的初始值不确定。</li>
<li><code>calloc</code>，为指定数量指定长度的对象分配存储空间。该空间中的每一位(bit)都初始化为0。</li>
<li><code>realloc</code>，增加或减少以前分配区的长度。当增加长度时，可能需将以前分配区的内容移到另一个足够大的区域，以便在尾端提供增加的存储区，而新增区域内的初始值则不确定。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">calloc</span><span class="params">(<span class="keyword">size_t</span> nobj, <span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">realloc</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> newsize)</span></span>;</span><br><span class="line"><span class="comment">// 3个函数返回值：若成功，返回非空指针；若出错，返回NULL</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span> <span class="params">(<span class="keyword">void</span> *pr)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这3个分配函数所返回的指针一定是适当对齐的，使其可用于任何数据对象。例如，在一个特定的系统上，如果最苛刻的对齐要求是，double必须在8的倍数地址单元处开始，那么这3个函数返回的指针都应这样对齐。</p>
<p>因为这3个alloc函数都返回通用指针<code>void*</code>，所以如果在程序中包括了<code>&lt;stdlib.h&gt;</code>(以获得函数原型)，那么当我们将这些函数返回的指针赋予一个不同类型的指针时，就不需要显式地执行强制类型转换。未声明函数的默认返回值为int，所以使用没有正确函数声明的强制类型转换可能会隐藏系统错误，因为int类型的长度与函数返回类型值的长度不同(本例中是指针)。</p>
<p>函数free释放pr指向的存储空间，被释放的空间通常被送入可用存储区池，以后，可在调用上述3个分配函数时再分配。</p>
<p><code>realloc</code>函数使我们可以增、减以前分配的存储区的长度(最常见的用法是增加该区)。例如，如果先为一个数组分配存储空间，该数组长度为512，然后在运行时填充它，但运行一段时间后发现该数组原先的长度不够用，此时就可调用<code>realloc</code>扩充相应存储空间。如果在该存储区后有足够的空间可供扩充，则可在原存储区位置上向高地址方向扩充，无需移动任何原先的内容，并返回与传给它相同的指针值。如果在原存储区后没有足够的空间，则<code>realloc</code>分配另一个足够大的存储区，将现存的512个元素数组的内容复制到新分配的存储区。然后，释放原存储区，返回新分配区的指针。因为这种存储区可能会移动位置，所以不应当使任何指针指在该区中。</p>
<p>这些分配例程通常用<code>sbrk(2)</code>系统调用实现，该系统调用扩充(或缩小)进程的堆。虽然<code>sbrk</code>可以扩充成缩小进程的存储空间，但是大多数<code>malloc</code>和<code>free</code>的实现都不减小进程的存储空间。释放的空间可供以后再分配，但将它们保持在<code>malloc</code>池中而不返回给内核。大多数实现所分配的存储空间比所要求的要稍大一 些，额外的空间用来记录管理信息一分配块的长度、指向下一个分配块的指针等。这就意味着，如果超过一个已分配区的尾端或者在已分配区起始位置之前进行写操作，则会改写另一块的管理记录信息。这种类型的错误是灾难性的，但是因为这种错误不会很快就暴露出来，所以也就很难发现。</p>
<p>在动态分配的缓冲区前或后进行写操作，破坏的可能不仅仅是该区的管理记录信息。在动态分配的缓冲区前后的存储空间很可能用于其他动态分配的对象。这些对象与破坏它们的代码可能无关，这造成寻求信息破坏的源头更加困难。</p>
<p>其他可能产生的致命性的错误是：释放一个已经释放了的块；调用free时所用的指针不是3个alloc函数的返回值等。如若一个进程调用<code>malloc</code>函数，但却忘记调用<code>free</code>函数，那么该进程占用的存储空间就会连续增加，这被称为<strong>泄漏</strong>(leakage)。如果不调用<code>free</code>函数释放不再使用的空间，那么进程地址空间长度就会慢慢增加，直至不再有空闲空间。此时，由于过度的换页开销，会造成性能下降。</p>
<h3 id="替代的存储空间分配程序"><a href="#替代的存储空间分配程序" class="headerlink" title="替代的存储空间分配程序"></a>替代的存储空间分配程序</h3><p>有很多可替代<code>malloc</code>和<code>free</code>的函数。某些系统已经提供替代存储空间分配函数的库。</p>
<h4 id="libmalloc"><a href="#libmalloc" class="headerlink" title="libmalloc"></a>libmalloc</h4><p>它提供了一套与ISO C存储空间分配函数相匹配的接口。libmalloc库包括<code>mallopt</code>函数，它使进程可以设置一些变量，并用它们来控制存储空间分配程序的操作。还可使用另一个名为<code>mallinfo</code>的函数，以对存储空间分配程序的操作进行统计。</p>
<h4 id="vmalloc"><a href="#vmalloc" class="headerlink" title="vmalloc"></a>vmalloc</h4><p>它允许进程对于不同的存储区使用不同的技术。除了一些<code>vmalloc</code>特有的函数外，该库也提供了ISO C存储空间分配函数的伤真器。</p>
<h4 id="quick-fit"><a href="#quick-fit" class="headerlink" title="quick-fit"></a>quick-fit</h4><p>历史上所使用的标准malloc算法是最佳适配或首次适配存储分配策略。quick-fit(快速适配)算法比上述两种算法快，但可能使用较多存储空间。该算法基于将存储空间分裂成各种长度的缓冲区，并将未使用的缓冲区按其长度组成不同的空闲区列表。现在许多分配程序都基于快速适配</p>
<h4 id="jemalloc"><a href="#jemalloc" class="headerlink" title="jemalloc"></a>jemalloc</h4><p><code>jemalloc</code>函数实现是FreeBSD 8.0中的默认存储空间分配程序，它是库函数malloc族在FreeBSD中的实现。它的设计具有良好的可扩展性， 可用于多处理器系统中使用多线程的应用程序。</p>
<h4 id="TCMalloc"><a href="#TCMalloc" class="headerlink" title="TCMalloc"></a>TCMalloc</h4><p>TCMalloc函数用于替代malloc函数族以提供高性能、高扩展性和高存储效率。从高速缓存中分配缓冲区以及释放缓冲区到高速缓存中时，它使用线程本地高速缓存来避免锁开销。它还有内置的堆检查程序和维分析程序帮助调试和分析动态存储的使用。</p>
<h4 id="函数alloca"><a href="#函数alloca" class="headerlink" title="函数alloca"></a>函数alloca</h4><p><code>alloca</code>的调用序列与malloc相同，但是它是在当前函数的栈帧上分配存储空间，而不是在堆中。其优点是，当函数返回时，自动释放它所使用的栈帧，所以不必再为释放空间而费心。其缺点是alloca函数增加了栈帧的长度，而某些系统在函数已被调用后不能增加栈帧长度，于是也就不能支持alloca函数。</p>
<h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>环境字符串的形式是：<code>name=value</code></p>
<p>ISO C定义了一个函数<code>getenv</code>，可以用其取环境变量值，但是该标准又称环境的内容是由实现定义的。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line">char *getenv (const char *name):</span><br><span class="line"><span class="comment">// 返回值，指向与name关联的value的指针; 若未找到，返回NULL</span></span><br></pre></td></tr></table></figure></p>
<p>注意，此函数返回一个指针，它指向name-value字符串中的value。我们应当使用<code>getenv</code>从环境中取一个指定环境变量的值，而不是直接访问environ。</p>
<p>POSIX.1定义了某些环境变量。<br><img src="/img/20210522200334.png" alt></p>
<p>除了获取环境变量值，有时也需要设置环境变量。我们可能希望改变现有变量的值，或者是增加新的环境变量。遗憾的是，并不是所有系统都支持这种能力。</p>
<p>3个函数的原型是:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">putenv</span><span class="params">(<span class="keyword">char</span> *str)</span></span>;</span><br><span class="line"><span class="comment">// 函数返回值，若成功，返回0，若出错，返回非0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setenv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> <span class="keyword">char</span> *value, <span class="keyword">int</span> rewrite)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">unsetenv</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br><span class="line"><span class="comment">// 两个函数返回值，若成功，返回0:若出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>这3个函数的操作如下。</p>
<ul>
<li><code>putenv</code>取形式为name=value的字符串，将其放到环境表中。如果name已经存在，则先删除其原来的定义。</li>
<li><code>setenv</code>将name设置为value，如果在环境中name已经存在，那么<ul>
<li>若<code>rewrite</code>非0，则首先剩除其现有的定义;</li>
<li>若<code>rewrite</code>为0，则不删除其现有定义(name不设置为新的value，而且也不出错)。</li>
</ul>
</li>
<li><code>unsetenv</code>删除name的定义。 即使不存在这种定义也不算出错。</li>
</ul>
<p>注意，<code>putenv</code>和<code>setenv</code>之间的差别。<code>setenv</code>必须分配存储空间，以便依据其参数创建name-value字符串。<code>putenv</code>可以自由地将传递给它的参数字符串直接救到环境中。确实，许多实现就是这么做的，因此，将存放在栈中的字符串作为参数传递给<code>putenv</code>就会发生错误，其原因是，从当前函数返回时，其栈帧占用的存储区可能将被重用。</p>
<p>环境表(指向实际name-value字符串的指针数组)和环境字符串通常存放在进程存储空间的顶部(栈之上)。删除一个字符串很简单——只要先在环境表中找到该指针，然后将所有后续指针都向环境表首部顺次移动一个位置。但是增加一个字符串或修改一个现有的字符串就困难得多。环境表和环境字符串通常占用的是进程地址空间的顶部，所以它不能再向高地址方向扩展。同时也不能移动在它之下的各栈帧，所以它也不能向低地址方向扩展。两者组合使得该空间的长度不能再增加。</p>
<ul>
<li>如果修改一个现有的name:<ul>
<li>如果新value的长度少于或等于现有value的长度， 则只要将新字符串复制到原字符串所用的空间中；</li>
<li>如果新value的长度大于原长度，则必须调用malloc为新字符串分配空间，然后将新字符串复制到该空间中，接着使环境表中针对name的指针指向新分配区。</li>
</ul>
</li>
<li>如果要增加一个新的name，则操作就更加复杂。首先，必须调用malloc为name-value字符串分配空间，然后将该字符串复制到此空间中，<ul>
<li>如果这是第一次增加一个新name，则必须调用malloc为新的指针表分配空间。接着，将原来的环境表复制到新分配区，并将指向新name-value字符串的指针存放在该指针表的表尾，然后又将一个空指针存放在其后。最后使environ指向新指针表。</li>
<li>如果这不是第一次增加一个新name，则可知以前已调用ma11oc在堆中为环境表分配了空间，所以只要调用realloc，以分配比原空间多存放一个指针的空间。然后将指向新name-value字符串的指针存放在该表表尾，后面跟着一个空指针。</li>
</ul>
</li>
</ul>
<h2 id="函数setjmp和1ongjmp"><a href="#函数setjmp和1ongjmp" class="headerlink" title="函数setjmp和1ongjmp"></a>函数setjmp和1ongjmp</h2><p>在C中，goto语句是不能跨越函数的，而执行这种类型跳转功能的是函数<code>setjmp</code>和<code>longjmp</code>。这两个函数对于处理发生在很深层嵌套函数调用中的出错情况是非常有用的。</p>
<p>考虑程序。其主循环是从标准输入读一行，然后调用<code>do_line</code>处理该输入行。<code>do_line</code>函数调用<code>get_token</code>从该输入行中取下一个标记。一行中的第一个标记假定是一条某种形式的命令，switch语句就实现命令选择。对程序中示例的命令调用<code>cmd_add</code>函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TOK_ADD 5</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_line</span><span class="params">(<span class="keyword">char</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cmd_add</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_token</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> line[MAXLINE];</span><br><span class="line">	<span class="keyword">while</span> (fgets(line, MAXLINE, <span class="built_in">stdin</span>) != <span class="literal">NULL</span>)</span><br><span class="line">		do_line(line);	</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *tok_ptr;   <span class="comment">/* global pointer for get_token() */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_line</span> <span class="params">(<span class="keyword">char</span> *ptr)</span> </span>&#123;    <span class="comment">/* process one line of input */</span></span><br><span class="line">	<span class="keyword">int</span> cmd;</span><br><span class="line">	tok_ptz = ptr;</span><br><span class="line">	<span class="keyword">while</span> ((cmd = get_token()) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">switch</span>(cmd) &#123; 	<span class="comment">/* one case for each command */</span></span><br><span class="line">		<span class="keyword">case</span> TOK_ADD:</span><br><span class="line">			cand_add();</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cmd_add</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> token;</span><br><span class="line">	token = get_token();   <span class="comment">/* rest of processing for this command */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_token</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="comment">/* fetch next token from line pointed to by tok_ptr */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>程序的骨架部分在读命令、确定命令的类型，然后调用相应函数处理每一条命令这类程序中是非常典型的。</p>
<p>自动变量的存储单元在每个函数的栈桢中。数组line在main的栈帧中，整型cmd在do_line的栈帧中，整型token在cmd_add的栈帧中。</p>
<p>如上所述，这种形式的栈安排是非常典型的，但并不要求非如此不可。栈并不一定要向低地址方向扩充。某些系统对栈并没有提供特殊的硬件支持，此时一个C<br>的实现可能要用链表实现栈帧。</p>
<p>解决这深层跳转的方法就是使用非局部goto一<code>setjmp</code>和<code>longjmp</code>函数。非局部指的是，这不是由普通的C语言goto语句在一个函数内实施的跳转，而是在栈上跳过若干调用帧，返回到当前函数调用路径上的某一个函数中。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setjup</span><span class="params">(jmp_but env)</span></span>;</span><br><span class="line"><span class="comment">// 返回值，若直接调用，返回0；若从longjmp返回，则为非0</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">longjmp</span><span class="params">(jmp_buf env， <span class="keyword">int</span> val)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>在希望返回到的位置调用setjmp，在本例中，此位置在main函数中。因为我们直接调用该函数，所以其返回值为0。<code>setjmp</code>参数<code>env</code>的类型是一 个特殊类型<code>jmp_buf</code>。这一数据类型是某种形式的数组，其中存放在调用<code>longjmp</code>时能用来恢复栈状态的所有信息。因为需在另一个函数中引用<code>env</code>变量，所以通常将<code>env</code>变量定义为全局变量。</p>
<p>当检查到一个错误时，则以两个参数调用<code>longjmp</code>函数。第一个就是在调用<code>setjmp</code>时所用的<code>env</code>第二个参数是具非0值的<code>val</code>，它将成为从<code>setjmp</code>处返回的值。使用第二个参数的原因是对于一个<code>setjmp</code>可以有多个<code>longjmp</code>。例如，可以在<code>cmd_add</code>中以<code>val</code>为1调用<code>longjmp</code>，也可在<code>get_token</code>中以<code>val</code>为2调用<code>longjmp</code>。在main函数中，<code>setjmp</code>的返回值就会是1或2，通过测试返回值就可判断造成返回的<code>longjmp</code>是在<code>cmd_add</code>还是在<code>get_token</code>中。</p>
<p>程序中给出了经修改过后的main和cmd_add函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TOK_ADD 5</span></span><br><span class="line">jmp_buf jupbuffer;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> line[MAXLINE];</span><br><span class="line">	<span class="keyword">if</span> (setjmp(jmpbuffer) != <span class="number">0</span>)</span><br><span class="line">	<span class="built_in">printf</span> (<span class="string">"error"</span>);</span><br><span class="line">	<span class="keyword">while</span> (fgets (line, MAXLINE, <span class="built_in">stdin</span>) != <span class="literal">NULL</span>)</span><br><span class="line">		do_line(line);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">end_edd</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> token;</span><br><span class="line">	token = get_token();</span><br><span class="line">	<span class="keyword">if</span> (token &lt; <span class="number">0</span>) <span class="comment">/* an error has occurred */</span></span><br><span class="line">		longjmp(jmpbuffer, <span class="number">1</span>);</span><br><span class="line">	<span class="comment">/* rest of processing for this command */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>执行main时，调用<code>setjmp</code>，它将所需的信息记入变量<code>jmpbuffer</code>中并返回0。然后调用<code>do_line</code>，它又调用<code>cmd_add</code>，假定在其中检测到一个错误。<code>longjmp</code>使栈反绕到执行main函数时的情况，也就是抛弃了<code>cmd_add</code>和<code>do_line</code>的栈帧。调用<code>longjmp</code>造成main中<code>setjmp</code>的返回，但是，这一次的返回值是1(longjmp的第二个参数)。</p>
<h2 id="函数getrlimit和setrlimit"><a href="#函数getrlimit和setrlimit" class="headerlink" title="函数getrlimit和setrlimit"></a>函数getrlimit和setrlimit</h2><p>每个进程都有一组资源限制，其中一些可以用<code>getrlimit</code>和<code>setrlimit</code>函数查询和更改。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getrlimit</span> <span class="params">(<span class="keyword">int</span> resource, struct rlimit *rlptr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setrlimit</span><span class="params">(<span class="keyword">int</span> resource, <span class="keyword">const</span> struct rlimit *rlpr)</span></span>;</span><br><span class="line"><span class="comment">// 两个函数返回值，若成功，返回0，若出错，返回非0</span></span><br></pre></td></tr></table></figure></p>
<p>对这两个函数的每一次调用都指定一个资源以及一个指向下列结构的指针。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> &#123;</span></span><br><span class="line">	<span class="keyword">rlim_t</span> elim_cur; <span class="comment">/* soft limit: current limit */</span></span><br><span class="line">	<span class="keyword">rlim_t</span> rlim_max; <span class="comment">/* hard limit: maximum velue for rlim_cur */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在更改资源限制时，须遵循下列3条规则。</p>
<ol>
<li>任何一个进程都可将一个软限制值更改为小于或等于其硬限制值。</li>
<li>任何一个进程都可降低其硬限制值，但它必须大于或等于其软限制值。这种降低，对普通用户而言是不可逆的。</li>
<li>只有超级用户进程可以提高硬限制值。</li>
</ol>
<p>常量<code>RLIM_INFINITY</code>指定了一个无限量的限制。这两个函数的resource参数取下列值之一。</p>
<ul>
<li>RLIMIT_AS：进程总的可用存储空间的最大长度(字节)。这影响到sbrk函数和map函数。</li>
<li>RLIMIT_CORE：core文件的最大字节数，若其值为0则阻止创建core文件。</li>
<li>RLIMIT_CPU：CPU时间的最大量值(秒)，当超过此软限制时，向该进程发送SIGXCPU信号。</li>
<li>RLIMIT_DATA：数据段的最大字节长度。这是初始化数据、非初始以及堆的总和。</li>
<li>RLIMIT_FSIZE：可以创建的文件的最大字节长度。当超过此软限制时，则向该进程发送SIGXFSZ信号。</li>
<li>RLIMIT_MEMLOCK：一个进程使用mlock(2)能够锁定在存储空间中的最大字节长度。</li>
<li>RLIMIT_MSGQUEUE：进程为POSIX消息队列可分配的最大存储字节数。</li>
<li>RLIMIT_NICE：为了影响进程的调度优先级，nice值可设置的最大限制。</li>
<li>RLIMIT_NOFTLE：每个进程能打开的最多文件数。更改此限制将影响到syscont函数在参数<code>_SC_OPEN_MAX</code>中返回的值</li>
<li>RLIMIT_NPROC：每个实际用户ID可拥有的最大子进程数。更改此限制将影响到<code>sysconf</code>函数在参数<code>_SC_CHILD_MAX</code>中返回的值。</li>
<li>RLIMIT_NPTS：用户可同时打开的伪终端的最大数量。</li>
<li>RLIMIT_RSS：最大驻内存集字节长度(resident set size in bytes，RSS)、如果可用的物理存储器非常少，则内核将从进程处取回超过RSS的部分。</li>
<li>RLIMIT_SBSIZE：在任一给定时刻，一个用户可以占用的套接字缓冲区的最大长度。</li>
<li>RLIMIT_SIGPENDING：一个进程可排队的信号最大数量。这个限制是sigqueue函数实施的。</li>
<li>RLIMIT_STACK：栈的最大字节长度。</li>
<li>RLIMIT_SWAP：用户可消耗的交换空间的最大字节数。</li>
<li>RLIMIT_VMEM：这是RLIMIT_AS的同义词。</li>
</ul>
<p>资源限制影响到调用进程并由其子进程继承。这就意味着，为了影响一个用户的所有后续进程，需将资源限制的设置构造在shell之中。</p>
<p>程序打印由系统支持的所有资源当前的软限制和硬限制。为了在各种实现上编译该程序，我们已经条件地包括了各种不同的资源名。<code>rlim_t</code>类型必须足够大才能表示文件大小限制。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	doit(name)	pr_limits(#name, name)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>	<span class="title">pr_limits</span><span class="params">(<span class="keyword">char</span> *, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span>	RLIMIT_AS</span></span><br><span class="line">	doit(RLIMIT_AS);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	doit(RLIMIT_CORE);</span><br><span class="line">	doit(RLIMIT_CPU);</span><br><span class="line">	doit(RLIMIT_DATA);</span><br><span class="line">	doit(RLIMIT_FSIZE);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span>	RLIMIT_MEMLOCK</span></span><br><span class="line">	doit(RLIMIT_MEMLOCK);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RLIMIT_MSGQUEUE</span></span><br><span class="line">	doit(RLIMIT_MSGQUEUE);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RLIMIT_NICE</span></span><br><span class="line">	doit(RLIMIT_NICE);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	doit(RLIMIT_NOFILE);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span>	RLIMIT_NPROC</span></span><br><span class="line">	doit(RLIMIT_NPROC);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RLIMIT_NPTS</span></span><br><span class="line">	doit(RLIMIT_NPTS);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span>	RLIMIT_RSS</span></span><br><span class="line">	doit(RLIMIT_RSS);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span>	RLIMIT_SBSIZE</span></span><br><span class="line">	doit(RLIMIT_SBSIZE);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RLIMIT_SIGPENDING</span></span><br><span class="line">	doit(RLIMIT_SIGPENDING);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	doit(RLIMIT_STACK);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RLIMIT_SWAP</span></span><br><span class="line">	doit(RLIMIT_SWAP);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span>	RLIMIT_VMEM</span></span><br><span class="line">	doit(RLIMIT_VMEM);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">pr_limits(<span class="keyword">char</span> *name, <span class="keyword">int</span> resource)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span>		<span class="title">limit</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>	lim;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (getrlimit(resource, &amp;limit) &lt; <span class="number">0</span>)</span><br><span class="line">		err_sys(<span class="string">"getrlimit error for %s"</span>, name);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%-14s  "</span>, name);</span><br><span class="line">	<span class="keyword">if</span> (limit.rlim_cur == RLIM_INFINITY) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"(infinite)  "</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		lim = limit.rlim_cur;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%10lld  "</span>, lim);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (limit.rlim_max == RLIM_INFINITY) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"(infinite)"</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		lim = limit.rlim_max;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%10lld"</span>, lim);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">putchar</span>((<span class="keyword">int</span>)<span class="string">'\n'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意，在<code>doit</code>宏中使用了ISO C的字符串创建算符(#)，以便为每个资源名产生字符串值。例如：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">doit (RLIMIT_CORE);</span><br></pre></td></tr></table></figure></p>
<p>这将由C预处理程序扩展为:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pr_limits(<span class="string">"RLIMIT_CORE"</span>, RLIMIT_CORE);</span><br></pre></td></tr></table></figure></p>
<p>在FreeBSD下运行此程序，得到:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out</span><br><span class="line">RLIMIT_AS      (infinite) (infinite)</span><br><span class="line">RLIMIT_CORE    (infinite) (infinite)</span><br><span class="line">RLIMIT_CPU     (infinite) (infinite)</span><br><span class="line">RLIMIT_DATA     536870912 536870912</span><br><span class="line">RLIMIT_FSIZE   (infinite) (infinite)</span><br><span class="line">RLIMIT_MEMLOCK (infinite) (infinite)</span><br><span class="line">RLIMIT_NOFILE   3520      3520</span><br><span class="line">RLIMIT_NPROC    1760      1760</span><br><span class="line">RLIMIT_NPTS    (infinite) (infinite)</span><br><span class="line">RLIMIT_RSS     (infinite) (infinite)</span><br><span class="line">RLIMIT_SBSIZE  (infinite) (infinite)</span><br><span class="line">RLIMIT_STACK    67108864 67108864</span><br><span class="line">RLIMIT_SWAP    (infinite) (infinite)</span><br><span class="line">RLIMIT_VMEM    (infinite) (infinite)</span><br></pre></td></tr></table></figure></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Linux/" rel="tag"># Linux</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/05/13/UNIX高级编程 笔记1/" rel="next" title="UNIX高级编程 笔记1">
                <i class="fa fa-chevron-left"></i> UNIX高级编程 笔记1
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/05/24/UNIX高级编程 笔记3/" rel="prev" title="UNIX高级编程 笔记3">
                UNIX高级编程 笔记3 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/header.jpg" alt="Hao Yu">
            
              <p class="site-author-name" itemprop="name">Hao Yu</p>
              <p class="site-description motion-element" itemprop="description">Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author</p>
          </div>
          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">249</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>
        	<audio controls="controls" loop="loop" preload="auto" src="/resource/xiaomeihao.mp3">
	        </audio>
	

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yuhao0102" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:yuh18@mails.tsinghua.edu.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#标准I-O库"><span class="nav-number">1.</span> <span class="nav-text">标准I/O库</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#流和FILE对象"><span class="nav-number">1.1.</span> <span class="nav-text">流和FILE对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#标准输入、标准输出和标准错误"><span class="nav-number">1.2.</span> <span class="nav-text">标准输入、标准输出和标准错误</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#缓冲"><span class="nav-number">1.3.</span> <span class="nav-text">缓冲</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#打开流"><span class="nav-number">1.4.</span> <span class="nav-text">打开流</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#读和写流"><span class="nav-number">1.5.</span> <span class="nav-text">读和写流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#输入函数"><span class="nav-number">1.5.1.</span> <span class="nav-text">输入函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#输出函数"><span class="nav-number">1.5.2.</span> <span class="nav-text">输出函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#每次一行I-O"><span class="nav-number">1.6.</span> <span class="nav-text">每次一行I/O</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#标准I-O的效率"><span class="nav-number">1.7.</span> <span class="nav-text">标准I/O的效率</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二进制I-O"><span class="nav-number">1.8.</span> <span class="nav-text">二进制I/O</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#定位流"><span class="nav-number">1.9.</span> <span class="nav-text">定位流</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#格式化I-O"><span class="nav-number">1.10.</span> <span class="nav-text">格式化I/O</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#格式化输出"><span class="nav-number">1.10.1.</span> <span class="nav-text">格式化输出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#格式化输入"><span class="nav-number">1.10.2.</span> <span class="nav-text">格式化输入</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实现细节"><span class="nav-number">1.11.</span> <span class="nav-text">实现细节</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#临时文件"><span class="nav-number">1.12.</span> <span class="nav-text">临时文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内存流"><span class="nav-number">1.13.</span> <span class="nav-text">内存流</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#系统数据文件和信息"><span class="nav-number">2.</span> <span class="nav-text">系统数据文件和信息</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#引言"><span class="nav-number">2.1.</span> <span class="nav-text">引言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#口令文件"><span class="nav-number">2.2.</span> <span class="nav-text">口令文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#阴影口令"><span class="nav-number">2.3.</span> <span class="nav-text">阴影口令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#组文件"><span class="nav-number">2.4.</span> <span class="nav-text">组文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#附属组ID"><span class="nav-number">2.5.</span> <span class="nav-text">附属组ID</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#其他数据文件"><span class="nav-number">2.6.</span> <span class="nav-text">其他数据文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#登录账户记录"><span class="nav-number">2.7.</span> <span class="nav-text">登录账户记录</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#系统标识"><span class="nav-number">2.8.</span> <span class="nav-text">系统标识</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#时间和日期例程"><span class="nav-number">2.9.</span> <span class="nav-text">时间和日期例程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#迸程环境"><span class="nav-number">3.</span> <span class="nav-text">迸程环境</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#main函数"><span class="nav-number">3.1.</span> <span class="nav-text">main函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程终止"><span class="nav-number">3.2.</span> <span class="nav-text">进程终止</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#退出函数"><span class="nav-number">3.2.1.</span> <span class="nav-text">退出函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数atexit"><span class="nav-number">3.2.2.</span> <span class="nav-text">函数atexit</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#命令行参数"><span class="nav-number">3.3.</span> <span class="nav-text">命令行参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#环境表"><span class="nav-number">3.4.</span> <span class="nav-text">环境表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C程序的存储空间布局"><span class="nav-number">3.5.</span> <span class="nav-text">C程序的存储空间布局</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#共享库"><span class="nav-number">3.6.</span> <span class="nav-text">共享库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#存储空间分配"><span class="nav-number">3.7.</span> <span class="nav-text">存储空间分配</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#替代的存储空间分配程序"><span class="nav-number">3.7.1.</span> <span class="nav-text">替代的存储空间分配程序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#libmalloc"><span class="nav-number">3.7.1.1.</span> <span class="nav-text">libmalloc</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#vmalloc"><span class="nav-number">3.7.1.2.</span> <span class="nav-text">vmalloc</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#quick-fit"><span class="nav-number">3.7.1.3.</span> <span class="nav-text">quick-fit</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#jemalloc"><span class="nav-number">3.7.1.4.</span> <span class="nav-text">jemalloc</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCMalloc"><span class="nav-number">3.7.1.5.</span> <span class="nav-text">TCMalloc</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#函数alloca"><span class="nav-number">3.7.1.6.</span> <span class="nav-text">函数alloca</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#环境变量"><span class="nav-number">3.8.</span> <span class="nav-text">环境变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数setjmp和1ongjmp"><span class="nav-number">3.9.</span> <span class="nav-text">函数setjmp和1ongjmp</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数getrlimit和setrlimit"><span class="nav-number">3.10.</span> <span class="nav-text">函数getrlimit和setrlimit</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>
  <div id="DvelopmentTarget">     
  </div>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart" aria-hidden="false"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>

  
</div>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_uv"> 
  本站访客数<span id="busuanzi_value_site_uv"></span>人次
</span>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  


  

  


  <script type="text/javascript" src="/js/src/love.js"></script>

</body>
</html>
