<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zn-ch">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-center-simple.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="C++,">










<meta name="description" content="其他库工具ratio库可通过ratio库精确地表示任何可在编译时使用的有限有理数。ratio对象在std::chrono:duration类中使用。与有理数相关的所有内容都在&amp;lt;ratio&amp;gt;头文件中定义，并且都在std名称空间中。有理数的分子和分母通过类型为std:intmax_t的编译时常量表示，这是一种有符号的整数类型，其最大宽度由编译器指定。ratio对象的定义方式和普通对象的定义">
<meta name="keywords" content="C++">
<meta property="og:type" content="article">
<meta property="og:title" content="C++高级编程 第四版 笔记7">
<meta property="og:url" content="http://yoursite.com/2021/05/09/cpp高级编程 笔记7/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="其他库工具ratio库可通过ratio库精确地表示任何可在编译时使用的有限有理数。ratio对象在std::chrono:duration类中使用。与有理数相关的所有内容都在&amp;lt;ratio&amp;gt;头文件中定义，并且都在std名称空间中。有理数的分子和分母通过类型为std:intmax_t的编译时常量表示，这是一种有符号的整数类型，其最大宽度由编译器指定。ratio对象的定义方式和普通对象的定义">
<meta property="og:locale" content="zn-ch">
<meta property="og:image" content="http://yoursite.com/img/20210509152400.png">
<meta property="og:updated_time" content="2021-05-10T01:45:41.378Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="C++高级编程 第四版 笔记7">
<meta name="twitter:description" content="其他库工具ratio库可通过ratio库精确地表示任何可在编译时使用的有限有理数。ratio对象在std::chrono:duration类中使用。与有理数相关的所有内容都在&amp;lt;ratio&amp;gt;头文件中定义，并且都在std名称空间中。有理数的分子和分母通过类型为std:intmax_t的编译时常量表示，这是一种有符号的整数类型，其最大宽度由编译器指定。ratio对象的定义方式和普通对象的定义">
<meta name="twitter:image" content="http://yoursite.com/img/20210509152400.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2021/05/09/cpp高级编程 笔记7/">





  <title>C++高级编程 第四版 笔记7 | Hao Yu's blog</title>
  








 
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zn-ch">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hao Yu's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">The program monkey was eaten by the siege lion.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/resume.pdf" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-mybetterhalf">
          <a href="/mybetterhalf/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>
            
            mybetterhalf
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/05/09/cpp高级编程 笔记7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">C++高级编程 第四版 笔记7</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-05-09T00:39:40+08:00">
                2021-05-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="其他库工具"><a href="#其他库工具" class="headerlink" title="其他库工具"></a>其他库工具</h1><h2 id="ratio库"><a href="#ratio库" class="headerlink" title="ratio库"></a>ratio库</h2><p>可通过ratio库精确地表示任何可在编译时使用的有限有理数。ratio对象在<code>std::chrono:duration</code>类中使用。与有理数相关的所有内容都在<code>&lt;ratio&gt;</code>头文件中定义，并且都在std名称空间中。有理数的分子和分母通过类型为<code>std:intmax_t</code>的编译时常量表示，这是一种有符号的整数类型，其最大宽度由编译器指定。ratio对象的定义方式和普通对象的定义方式不同，而且不能调用ratio对象的方法。需要使用类型别名。例如，下面这行代码定义了一个表示1/60的有理数编译时常量：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> r1 = ratio&lt;<span class="number">1</span>,<span class="number">60</span>&gt;;</span><br></pre></td></tr></table></figure></p>
<p>r1有理数的分子和分母是编译时常量，可通过以下方式访问：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">intmax_t</span> num = r1::num;</span><br><span class="line"><span class="keyword">intmax_t</span> den = r1::den;</span><br></pre></td></tr></table></figure></p>
<p>记住ratio是一个编译时常量，也就是说，分子和分母需要在编译时确定。下面的代码会产生编译错误：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">intmax_t</span> n = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">intmax_t</span> d = <span class="number">60</span>;</span><br><span class="line"><span class="keyword">using</span> r1 = ratio&lt;n, d&gt;;</span><br></pre></td></tr></table></figure></p>
<p>将n和d定义为常量就不会有编译错误了。</p>
<p>有理数总是化简的。对于有理数<code>ratio&lt;n,d&gt;</code>，计算最大公约数gcd、分子num和分母den的定义如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">num = sign(n)*sign(d)*<span class="built_in">abs</span>(n)/gcd</span><br><span class="line">den = <span class="built_in">abs</span>(d)/gcd</span><br></pre></td></tr></table></figure></p>
<p>ratio库支持有理数的加法、减法、乘法和除法运算。由于所有这些操作都是在编译时进行的，因此不能使用标准的算术运算符，而应使用特定的模板和类型别名组合。可用的算术ratio模板包括<code>ratio_add</code>、<code>ratio_subtract</code>、<code>ratio_multiply</code>、<code>ratio_divide</code>。这些模板将结果计算为新的ratio类型。这种类型可通过名为<code>type</code>的内嵌类型别名访问。</p>
<p>例如，下面的代码首先定义了两个ratio对象，一个表示1/60，另一个表示1/30。<code>ratio_add</code>模板将两个有理数相加，得到的result有理数应该是化简之后的1/20。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> r1 = ratio&lt;<span class="number">1</span>, <span class="number">60</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> r2 = ratio&lt;<span class="number">1</span>, <span class="number">30</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> result = ratio_add&lt;r1, r2&gt;::type;</span><br></pre></td></tr></table></figure></p>
<p>C++标准还定义了一些ratio比较模板：<code>ratio_equal</code>、<code>ratio_not_equal</code>、<code>ratio_less</code>、<code>ratio_less_equal</code>、<code>ratio_greater</code>、<code>ratio_greater_equal</code>。与算术ratio模板一样，ratio比较模板也是在编译时求值的。这些比较模板创建了一种新类型<code>std::bool_constant</code>来表示结果。<code>bool_constant</code>也是<code>std::integral_constant</code>，即struct模板，里面保存了一种类型和一个编译时常量值。</p>
<p>例如，<code>integral constant&lt;int, 15&gt;</code>保存了一个值为15的整型值。<code>bool_constant</code>还是布尔类型的<code>integral_constant</code>。例如，<code>bool_constant&lt;true&gt;</code>是<code>integral_constant&lt;bool,true&gt;</code>，存储值为true的布尔值。<code>ratio</code>比较模板的结果要么是<code>bool_constant&lt;bool,true&gt;</code>，要么是<code>bool_constant&lt;bool, false&gt;</code>。与<code>bool_constant</code>或<code>integral_constant</code>关联的值可通过value数据成员访问。</p>
<p>下面的代码演示了ratio_less的使用。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> r1 = ratio&lt;<span class="number">1</span>,<span class="number">60</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> r2 = ratio&lt;<span class="number">1</span>,<span class="number">30</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> res = ratio_less&lt;r2, r1&gt;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; res::value &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p>
<h2 id="chrono库"><a href="#chrono库" class="headerlink" title="chrono库"></a>chrono库</h2><p>chrono库是一组操作时间的库。这个库包含以下组件：</p>
<ul>
<li>持续时间</li>
<li>时钟</li>
<li>时点</li>
</ul>
<p>所有组件都在<code>std::chrono</code>名称空间中定义，而且需要包含<code>&lt;chrono&gt;</code>头文件。 下面讲解每个组件。</p>
<h3 id="持续时间"><a href="#持续时间" class="headerlink" title="持续时间"></a>持续时间</h3><p>持续时间(duration)表示的是两个时间点之间的间隔时间，通过模板化的duration类来表示。duration类保存了滴答数和滴答周期(tick period)。滴答周期指的是两个滴答之间的秒数，是一个编译时ratio常量，也就是说可以是1秒的分数。duration模板接收两个模板参数，定义如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Rep</span>, <span class="title">class</span> <span class="title">Period</span> = <span class="title">ratio</span>&lt;1&gt;&gt; <span class="title">class</span> <span class="title">duration</span> &#123;</span>...&#125;</span><br></pre></td></tr></table></figure></p>
<p>第一个模板参数Rep表示保存滴答数的变量类型，应该是一种算术类型，例如long和double等。第二个模板参数Period是表示滴答周期的有理数常量。如果不指定滴答周期，那么会使用默认值<code>ratio&lt;1&gt;</code>，也就是说默认滴答周期为1秒。</p>
<p>duration类提供了3个构造函数：一个是默认构造函数；另一个构造函数接收一个表示滴答数的值作为参数；第三个构造函数接收另一个duration作为参数。后者可用于将一个duration转换为另一个duration，例如将分钟转换为秒。</p>
<p>duration支持算术运算，还支持比较运算符。duration类包含多个方法，如表所示。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Rep count() const</td>
<td>以滴答数返回duration值，返回类型是duration模板中指定的类型参数</td>
</tr>
<tr>
<td>static duration zero()</td>
<td>返回持续时间值等于0的duration</td>
</tr>
<tr>
<td>static duration min()</td>
<td>返回duration模板指定的类型参数表示的最小值/最大值持续时间的duration值</td>
</tr>
<tr>
<td>static duration max()</td>
<td>返回duration模板指定的类型参数表示的最小值/最大值持续时间的duration值</td>
</tr>
</tbody>
</table>
</div>
<p>C++17添加了用于持续时间的<code>floor()</code>、<code>ceil()</code>、<code>round()</code>和<code>abs()</code>操作，行为与用于数值数据时类似。</p>
<p>下面看一下如何在实际代码中使用duration。 每一个滴答周期为1秒的duration定义如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">duration&lt;<span class="keyword">long</span>&gt; d1;</span><br></pre></td></tr></table></figure></p>
<p>由于<code>ratio&lt;1&gt;</code>是默认的滴答周期，因此这行代码等同于：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">duration&lt;<span class="keyword">long</span>, ratio&lt;<span class="number">1</span>&gt;&gt; d1;</span><br></pre></td></tr></table></figure></p>
<p>下面的代码指定了滴答周期为1分钟的duration(滴答周期为60秒):<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">duration&lt;<span class="keyword">long</span>, ratio&lt;<span class="number">60</span>&gt;&gt; d2;</span><br></pre></td></tr></table></figure></p>
<p>下面的代码定义了每个滴答周期为1/60秒的duration:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">duration&lt;<span class="keyword">double</span>, ratio&lt;<span class="number">1</span>, <span class="number">60</span>&gt;&gt; d3;</span><br></pre></td></tr></table></figure></p>
<p>下面的例子展示了duration的几个方面。它展示了如何定义duration，如何对duration执行算术操作，以及如何将一个duration转换为另一个滴答周期不同的duration:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">duration&lt;<span class="keyword">long</span>, ratio&lt;<span class="number">60</span>&gt;&gt; d1(<span class="number">123</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; d1.count() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">duration&lt;<span class="keyword">double</span>&gt; d2;</span><br><span class="line">d2 = d2.max();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; d2.count () &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">duration&lt;<span class="keyword">long</span>, ratio&lt;<span class="number">60</span>&gt;&gt; d3(<span class="number">10</span>); <span class="comment">// = 10 minutes</span></span><br><span class="line">duration&lt;<span class="keyword">long</span>, ratio&lt;<span class="number">1</span>&gt;&gt; d4(<span class="number">14</span>);  <span class="comment">// = 14 seconds</span></span><br></pre></td></tr></table></figure></p>
<p>特别注意下面两行：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">duration&lt;<span class="keyword">double</span>, ratio&lt;<span class="number">60</span>&gt;&gt;d5 = d3+d4;</span><br><span class="line">duration&lt;<span class="keyword">long</span>, ratio&lt;<span class="number">1</span>&gt;&gt;d6 = d3+d4;</span><br></pre></td></tr></table></figure></p>
<p>这两行都计算了d3+d4，但第一行将结果保存在表示分钟的浮点值中，第二行将结果保存在表示秒的整数中。分钟到秒的转换(或秒到分钟的转换)自动进行。</p>
<p>chrono库还提供了以下标准的duration类型，它们位于<code>std::chrono</code>名称空间中：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> nanoseconds = duration&lt;X <span class="number">64</span> bits, nano&gt;;</span><br><span class="line"><span class="keyword">using</span> microseconds = duration&lt;X <span class="number">55</span> bits, micro&gt;;</span><br><span class="line"><span class="keyword">using</span> milliseconds = duration&lt;X <span class="number">45</span> bits, milli&gt;;</span><br><span class="line"><span class="keyword">using</span> seconds = duration&lt;X <span class="number">35</span> bits&gt;;</span><br><span class="line"><span class="keyword">using</span> minutes = duration&lt;X <span class="number">29</span> bits, ratio&lt;<span class="number">60</span>&gt;&gt;;</span><br><span class="line"><span class="keyword">using</span> hours = duration&lt;X <span class="number">23</span> bits, ratio&lt;<span class="number">3600</span>&gt;&gt;;</span><br></pre></td></tr></table></figure></p>
<p>X的具体类型取决于编译器，但C++标准要求X的类型为至少指定大小的整数类型。使用这些预定义的类型，不是编写：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">duration&lt;<span class="keyword">long</span>, ratio&lt;<span class="number">60</span>&gt;&gt; d9(<span class="number">10</span>); <span class="comment">// minutes</span></span><br></pre></td></tr></table></figure></p>
<p>而是编写：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">minutes <span class="title">d9</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="时钟"><a href="#时钟" class="headerlink" title="时钟"></a>时钟</h3><p>clock类由<code>time_point</code>和<code>duration</code>组成。C++标准定义了3个<code>clock</code>。第一个称为<code>system_clock</code>，表示来自系统实时时钟的真实时间。第二个称为<code>steady_clock</code>，是一个能保证其time_point绝不递减的时钟。<code>system_clock</code>无法做出这种保证，因为系统时钟可以随时调整。第三个称为<code>high_resolution_clock</code>，这个时钟的滴答周期达到了最小值。<code>high_resolution_clock</code>可能就是<code>stead_clock</code>或<code>system_clock</code>的别名，具体取决于编译器。</p>
<p>每个clock都有一个静态的<code>now()</code>方法，用于把当前时间用作<code>time_point</code>。<code>system_clock</code>定义了两个静态辅助函数，用于<code>time_point</code>和C风格的时间表示方法<code>time_t</code>之间的相互转换。第一个辅助函数为<code>to_time_t()</code>，它将给定time_point转换为<code>time_t</code>；第二个辅助函数为<code>from_time_t()</code>，它返回用给定time_t初始化的<code>time_point</code>。<code>time_t</code>类型在<code>&lt;ctime.h&gt;</code>头文件中定义。下例展示了一个完整程序，它从系统获得当前时间，然后将这个时间以可供用户读取的格式输出到控制台。<code>localtime()</code>函数将<code>time_t</code>转换为用<code>tm</code>表示的本地时间，定义在<code>&lt;ctime&gt;</code>头文件中。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">system_clock::time_point tpoint = system_clock::now();</span><br><span class="line"><span class="keyword">time_t</span> tt = system_clock::<span class="keyword">to_time_t</span>(tpoint);</span><br><span class="line"></span><br><span class="line"><span class="function">tm* t m <span class="title">localtime</span><span class="params">(&amp;tt)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>如果想要将时间转换为字符串，可使用<code>std::stringstream</code>，定义在<code>&lt;ctime&gt;</code>中。使用<code>strftime()</code>函数时，要求提供一个足够大的缓冲区，以容纳用户可读格式的给定时间。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">system_clock::time_point tpoint = system_clock::now();</span><br><span class="line"><span class="keyword">time_t</span> tt = system_clock::<span class="keyword">to_time_t</span>(tpoint);</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buffer[<span class="number">80</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">strftime(buffer, <span class="keyword">sizeof</span>(buffer), <span class="string">"%H:%M:%S"</span>, t);</span><br></pre></td></tr></table></figure></p>
<p>通过chrono库还可计算一段代码执行所消耗的时间。下例展示了这个过程。变量start和end的实际类型为<code>system_clock::time_point</code>，<code>diff</code>的实际类型为duration：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> start = high_resolution_clock::now();</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> d = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; ++i)</span><br><span class="line">    d += <span class="built_in">sqrt</span>(<span class="built_in">sin</span>(i) * <span class="built_in">cos</span>(i));</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> end = high_resolution_clock::now();</span><br><span class="line"><span class="keyword">auto</span> diff = end - start;</span><br></pre></td></tr></table></figure></p>
<h3 id="时点"><a href="#时点" class="headerlink" title="时点"></a>时点</h3><p><code>time_point</code>类表示的是时间中的某个时点，存储为相对于纪元(epoch)的duration。<code>time_point</code>总是和特定的clock关联，纪元就是所关联clock的原点。例如，经典UNIX/Linux的时间纪元是1970年1月1日。</p>
<p><code>time_point</code>类包含<code>time_since_epoch()</code>函数，它返回的duration表示所关联clock的纪元和保存的时间点之间的时间，C++支持合理的<code>time_point</code>和<code>duration</code>算术运算。C++支持使用比较运算符来比较两个时间点，提供了两个静态方法：<code>min()</code>返回最小的时间点，而<code>max()</code>返回最大的时间点。</p>
<p>time_point类有3个构造函数</p>
<ul>
<li><code>time_point()</code>：构造一个<code>time_point</code>，通过<code>duration::zero()</code>进行初始化。得到的<code>time_point</code>表示所关联clock的纪元</li>
<li><code>time_point(const duration&amp; d)</code>：构造一个<code>time_point</code>，通过给定的duration进行初始化。得到的<code>time_point</code>表示纪元+d</li>
<li><code>template &lt;class Duration2&gt; time_point(const time_point&lt;clock, Duration2&gt;&amp;t)</code>：构造一个<code>time_point</code>，通过<code>t.time_since_epoch()</code>进行初始化</li>
</ul>
<p>每个<code>time_point</code>都关联一个clock。创建<code>time_point</code>时，指定clock作为模板参数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">time_point&lt;steady_clock&gt; tp1;</span><br></pre></td></tr></table></figure></p>
<p>每个clock都知道各自的<code>time_point</code>类型，因此可编写以下代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">steady_clock::time_point tpl;</span><br></pre></td></tr></table></figure></p>
<p>下面的示例演示了<code>time_point</code>类：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">time_point&lt;steady_clock&gt; tp1;</span><br><span class="line">tp1 += minutes(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> d1 = tp1.time_since_epoch();</span><br><span class="line">duration&lt;<span class="keyword">double</span>&gt; d2(dl);</span><br></pre></td></tr></table></figure></p>
<h2 id="生成随机数"><a href="#生成随机数" class="headerlink" title="生成随机数"></a>生成随机数</h2><p>在C++11之前，生成随机数的唯一方法是使用C风格的<code>srand()</code>和<code>rand()</code>函数。<code>srand()</code>函数需要在应用程序中调用一次，这个函数初始化随机数生成器，也称为设置种子(sccding)。通常应该使用当前系统时间作为种子。初始化随机数生成器后，通过<code>rand()</code>生成随机数。下例展示了如何使用<code>srand()</code>和<code>rand()</code>。<code>time(nullptr)</code>调用返回系统时间，这个函数在<code>&lt;ctime&gt;</code>头文件中定义：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">srand(<span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt; (time(<span class="literal">nullptr</span>)));</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; rand() &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p>
<p>可通过以下函数生成特定范围内的随机数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getRandom</span><span class="params">(<span class="keyword">int</span> min, <span class="keyword">int</span> max)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (rand() % <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(max + <span class="number">1</span> - min)) + min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>C++11的库能根据不同的算法和分布生成随机数。这个库定义在<code>&lt;random&gt;</code>头文件中。这个库有3个主要组件：随机数引擎(engine)、随机数引擎适配器(engine adapter)和分布(distribution)。 随机数引擎负责生成实际的随机数，并将生成后续随机数需要的状态保存起来。分布判断生成随机数的范围以及随机数在这个范围内的数学分布情况。随机数引擎适配器修改相关联的随机数引擎生成的结果。</p>
<h3 id="随机数引擎"><a href="#随机数引擎" class="headerlink" title="随机数引擎"></a>随机数引擎</h3><p>以下随机数引擎可供使用：</p>
<ul>
<li>random_device</li>
<li>linear_congruential_engine</li>
<li>mersenne_twister_engine</li>
<li>subtract_with_carry_engine</li>
</ul>
<p>random_device引擎不是基于软件的随机数生成器；这是一种特殊引擎，要求计算机连接能真正生成不确定随机数的硬件。随机数生成器的质量由随机数的熵(entropy)决定。如果random_device类使用的是基于软件的伪随机数生成器，那么这个类的<code>entropy()</code>方法返回的值为0.0。random_device的速度通常比伪随机数引擎更慢。因此，如果需要生成大量的随机数，建议使用伪随机数引擎，使用random_device为随机数引擎生成种子，除了random_device随机数引擎之外，还有3个伪随机数引擎：</p>
<ul>
<li><strong>线性同余引擎</strong>(linear congruential engine)保存状态所需的内存量最少。状态是一个包含上一次生成的随机数的整数，如果尚未生成随机数，则保存的是初始种子。</li>
<li>在这3个伪随机数引擎中，<strong>梅森旋转算法</strong>生成的随机数质量最高。梅森旋转算法的周期取决于算法参数，但比线性同余引擎的周期要长得多。梅森旋转算法保存状态所需的内存量也取决于算法参数，但是比线性同余引擎的整数状态高得多。例如，预定义的梅森旋转算法mt9937的周期为2^19937-1，状态包含625个整数，约为2.5KB。它是最快的随机数引擎之一</li>
<li>带进位减法(subtract withcarry)引擎要求保存大约100字节的状态。不过，这个随机数引擎生成的随机数质量不如梅森旋转算法。</li>
</ul>
<h2 id="optional"><a href="#optional" class="headerlink" title="optional"></a>optional</h2><p><code>std::optional</code>在<code>&lt;optional&gt;</code>中定义，用于保存特定类型的值，或什么都不保存。如果希望值是可选的，可将其用作函数的参数。如果函数可以返回一些值，或什么都不返回，通常也可将其用作函数的返回类型。这样，就不必从函数返回特殊值，如nullptr、-1和EOF等。在下面的示例中，函数返回optional：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">optional&lt;<span class="keyword">int</span>&gt; getData(<span class="keyword">bool</span> givelt) &#123;</span><br><span class="line">    <span class="keyword">if</span> (giveIt) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">    <span class="keyword">return</span> nullopt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可采用如下方式调用该函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> data1 = getData(<span class="literal">true</span>);</span><br><span class="line"><span class="keyword">auto</span> data2 = getData(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure></p>
<p>要确定optional是否具有值，可使用<code>has_value()</code>方法，或在证语句中使用optional：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"datal.has_value = "</span>&lt;&lt; datal.has_value() &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">if</span>(data2) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"data2 has a value."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果optional具有值，可使用<code>value()</code>接收它，或使用以下反引用运算符：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"data1.value = "</span> &lt;&lt; data1.value() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"data1.value = "</span> &lt;&lt; *data1 &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p>
<p>如果在空的optional上调用<code>value()</code>，将抛出<code>bad_optional_access</code>异常。可使用<code>value_or()</code>返回optional值，或在optional为空时返回另一个值：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"data2.value"</span> &lt;&lt; data2.value_or(<span class="number">0</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p>
<p>注意，不能在optional中存储引用，因此<code>optional&lt;T&amp;&gt;</code>不可行。相反，应当使用<code>&lt;optionakT*&gt;</code>、<code>optional&lt;reference_wrapper&lt;T&gt;&gt;</code>或<code>optional&lt;reference_wrapper&lt;const T&gt;&gt;</code>。</p>
<h2 id="variant"><a href="#variant" class="headerlink" title="variant"></a>variant</h2><p><code>std::variant</code>在<code>&lt;variant&gt;</code>中定义，可用于保存给定类型集合的一个值。定义variant时，必须指定它可能包含的类型。例如，以下代码定义variant一次可以包含整数、字符串或浮点值：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">variant&lt;<span class="keyword">int</span>, <span class="built_in">string</span>, <span class="keyword">float</span>&gt; v;</span><br></pre></td></tr></table></figure></p>
<p>这里，这个默认构造的variant包含第一个类型(此处是int)的默认构造值。要默认构造variant，务必确保variant的第一个类型是默认可构造的。例如，下面的代码无法编译，因为Foo不是默认可构造的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span> <span class="keyword">public</span>: Foo() = <span class="keyword">delete</span>; Foo(<span class="keyword">int</span>) &#123; &#125; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> &#123;</span> <span class="keyword">public</span>: Bar() = <span class="keyword">delete</span>; Bar(<span class="keyword">int</span>) &#123; &#125; &#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    variant&lt;Foo, Bar&gt; v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>事实上，Foo和Bar都不是默认可构造的。如果仍需要默认构造variant，可使用<code>std:monostate</code>(一个空的替代)作为variant的第一个类型：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">variant&lt;monostate, Foo, Bar&gt; v;</span><br></pre></td></tr></table></figure></p>
<p>可使用赋值运算符，在variant中存储内容：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">variant&lt;<span class="keyword">int</span>, <span class="built_in">string</span>, <span class="keyword">float</span>&gt; v;</span><br><span class="line">v = <span class="number">12</span>;</span><br><span class="line">v = <span class="number">2.5f</span>;</span><br><span class="line">v = <span class="string">"An std::string"</span>s;</span><br></pre></td></tr></table></figure></p>
<p>variant在任何给定时间只能包含一个值。因此，对于这三行代码，首先将整数12存储在variant中，然后将variant改为包含浮点值，最后将variant改为包含字符串。</p>
<p>可使用<code>index()</code>方法来查询当前存储在variant中的值类型的索引。<code>std:holds_alternative()</code>函数模板可用于确定variant当前是否包含特定类型的值：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt;<span class="string">"Type index: "</span>&lt;&lt; v.index() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;<span class="string">"Contains an int:"</span> &lt;&lt; holds_alternative&lt;<span class="keyword">int</span>&gt;(V) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p>
<p>使用<code>std::get&lt;index&gt;()</code>或<code>std::get&lt;T&gt;()</code>从variant检索值。如果使用类型的索引，或使用与variant的当前值不匹配的类型，这些函数抛出<code>bad_variant_access</code>异常：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::get&lt;<span class="built_in">string</span>&gt;(v) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::get&lt;<span class="number">0</span>&gt;(v)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (<span class="keyword">const</span> bad_variant_access&amp; ex) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="string">"Exception: "</span> &lt;&lt; ex.what()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为避免异常，可使用<code>std::get_if&lt;index&gt;()</code>或<code>std::get_if&lt;T&gt;()</code>辅助函数。这些函数接收指向variant的指针，返回指向请求值的指针；如果遇到错误，则返回nullptr。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span>* theString = <span class="built_in">std</span>::get_if&lt;<span class="built_in">string</span>&gt;(&amp;v);</span><br><span class="line"><span class="keyword">int</span>* theint = <span class="built_in">std</span>::get_if&lt;<span class="keyword">int</span>&gt;(&amp;v);</span><br></pre></td></tr></table></figure></p>
<p>可使用<code>std::visit()</code>辅助函数，将visitor模式应用于variant。假设以下类定义了多个重载的函数调用运算符，variant中的每个可能类型对应一个：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyVisitor</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span> <span class="params">()</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"int "</span> &lt;&lt; i&lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span> <span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s)</span> </span>&#123; <span class="built_in">cout</span>&lt;&lt; <span class="string">"string"</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span> <span class="params">()</span><span class="params">(<span class="keyword">float</span> t)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt;<span class="string">"float"</span> &lt;&lt; f &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>可将其与<code>std::visit()</code>一起使用，如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">visit(MyVisitor(), v);</span><br></pre></td></tr></table></figure></p>
<p>这样就会根据variant中当前存储的值，调用适当的重载的函数调用运算符。</p>
<h2 id="any"><a href="#any" class="headerlink" title="any"></a>any</h2><p><code>std::any</code>在<code>&lt;any&gt;</code>中定义，是一个可包含任意类型值的类。一旦构建，可确认any实例中是否包含值，以及所包含值的类型。要访问包含的值，需要使用<code>any_cast()</code>，如果失败，会抛出<code>bad_any_cast</code>类型的异常。下面是一个示例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">any empty;</span><br><span class="line"><span class="function">any <span class="title">anint</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="function">any <span class="title">aString</span><span class="params">(<span class="string">"An std::string."</span>s)</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"empty.has_value = "</span> &lt;&lt; empty.has_value() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"anint.has_value = "</span> &lt;&lt; anint.has_value() &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;<span class="string">"anint wrapped type = "</span> &lt;&lt; anint.type().name() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;<span class="string">"aString wrapped type = "</span> &lt;&lt; aString.type().name() &lt;&lt; <span class="built_in">endl</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> theInt = any_cast&lt;<span class="keyword">int</span>&gt;(anInt);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; theInt &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> test = any_cast&lt;<span class="keyword">int</span>&gt;(aString);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; test &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (<span class="keyword">const</span> bad_any_cast&amp; ex) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Exception: "</span> &lt;&lt; ex.what() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出如下所示。注意，aString的包装类型与编译器相关。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">empty.has_value = <span class="number">0</span></span><br><span class="line">anint.has_value = <span class="number">1</span></span><br><span class="line">anInt wrapped type = <span class="keyword">int</span></span><br><span class="line">astring wrapped type = class <span class="built_in">std</span>: :basic_string&lt;<span class="keyword">char</span>, struct <span class="built_in">std</span>::char_traits&lt;<span class="keyword">char</span>&gt;,class <span class="built_in">std</span>::allocator&lt;<span class="keyword">char</span>&gt; &gt;</span><br><span class="line"><span class="number">3</span></span><br><span class="line">Exception: Bad any_cast</span><br></pre></td></tr></table></figure></p>
<p>可将新值赋给any实例，甚至是不同类型的新值：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">any <span class="title">something</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="comment">// Now it contains an integer.</span></span><br><span class="line">something = <span class="string">"An std::string"</span>s; <span class="comment">//Now the same instance contains a string.</span></span><br></pre></td></tr></table></figure></p>
<p>any的实例可存储在标准库容器中。这样就可在单个容器中存放异构数据。这么做的唯一缺点在于，只能通过显式执行any_cast来检索特定值，如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;any&gt; v;</span><br><span class="line">v.push_back(any(<span class="number">42</span>));</span><br><span class="line">v.push_back(any(<span class="string">"An std::string"</span>s));</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; any_cast&lt;<span class="built_in">string</span>&gt;(v[<span class="number">1</span>]) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p>
<p>与optional和variant一样，无法存储any实例的引用。可存储指针，也可存储<code>reference_wrapper&lt;const T&gt;</code>或<code>reference_wrapper&lt;T&gt;</code>的实例。</p>
<h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><p>在<code>&lt;utility&gt;</code>中定义的<code>std::pair</code>类可保存两个值，每个值都有特定的类型。每个值的类型都应该在编译时确定。下面是一个简单的例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; p1(<span class="number">16</span>, <span class="string">"Hello World"</span>);</span><br><span class="line">pair&lt;<span class="keyword">bool</span>, <span class="keyword">float</span>&gt; p2(<span class="literal">true</span>, <span class="number">0.123f</span>);</span><br></pre></td></tr></table></figure></p>
<p>还有<code>std::tuple</code>类，这个类定义在<code>&lt;tuple&gt;</code>头文件中。tuple(元组)是pair的泛化，允许存储任意数量的值，每个值都有自己特定的类型。和pair一样，tuple的大小和值类型都是编译时确定的，都是固定的。tuple可通过tuple构造函数创建，需要指定模板类型和实际值。例如，下面的代码创建了一个tuple，其第一个元素是一个整数，第二个元素是一个字符串，最后一个元素是一个布尔值：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> MyTuple = tuple&lt;<span class="keyword">int</span>, <span class="built_in">string</span>, <span class="keyword">bool</span>&gt;;</span><br><span class="line"><span class="function">MyTuple <span class="title">t1</span><span class="params">(<span class="number">16</span>, <span class="string">"Test"</span>, <span class="literal">true</span>)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p><code>std::get&lt;i&gt;()</code>从tuple中获得第i个元素，i是从0开始的索引；因此<code>&lt;0&gt;</code>表示tuple的第一个元素，<code>&lt;1&gt;</code>表示tuple的第二个元素，依此类推。返回值的类型是tuple中那个索引位置的正确类型：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"t1 = ("</span> &lt;&lt; get&lt;<span class="number">0</span>&gt;(t1) &lt;&lt; <span class="string">","</span> &lt;&lt; get&lt;<span class="number">1</span>&gt;(t1) &lt;&lt; <span class="string">","</span> &lt;&lt; get&lt;<span class="number">2</span>&gt;(t1) &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p>
<p>可通过<code>&lt;typeinfo&gt;</code>头文件中的<code>typeid()</code>检查<code>get&lt;i&gt;()</code>是否返回了正确的类型。下面这段代码的输出表明，<code>get&lt;I&gt;(t1)</code>返回的值确实是<code>std::string</code>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Type of get&lt;1&gt;(t1) = "</span> &lt;&lt; <span class="keyword">typeid</span>(get&lt;<span class="number">1</span>&gt;(t1)).name() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">// Outputs: Type of get&lt;1&gt;(t1) = class std::basic_string&lt;char, struct std::char_traits&lt;char&gt;, class std::allocator&lt;char&gt;&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>也可根据类型使用<code>std::get&lt;T&gt;()</code>从tuple中提取元素，其中T是要提取的元素(而不是索引)的类型。如果tuple有几个所需类型的元素，编译器会生成错误。例如，可从tl中提取字符串元素：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"String = "</span>&lt;&lt; get&lt;<span class="built_in">string</span>&gt;(t1) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p>
<p>遗憾的是，迭代tuple的值并不简单。无法编写简单循环或调用<code>get&lt;i&gt;(mytuple)</code>等，因为i的值在编译时必须是已知的。</p>
<p>可通过<code>std:tuple_size</code>模板来查询tuple的大小。 注意，<code>tuple_size</code>要求指定tuple的类型，而不是实际的tuple实例，例如t1：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Tuple Size "</span> &lt;&lt; tuple_size&lt;MyTuple&gt;::value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">// Outputs: Tuple Size 3</span></span><br></pre></td></tr></table></figure></p>
<p>如果不知道准确的tuple类型，始终可以使用<code>decltype()</code>，如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Tuple Size - "</span> &lt;&lt; tuple_size&lt;<span class="keyword">decltype</span>(t1)&gt;::value &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p>
<p>在C++17中，提供了构造函数的模板参数推导规则。在构造tuple时，可忽略模板类型形参，让编译器根据传递给构造函数的实参类型，自动进行推导。例如，下面定义同样的t1元组，它包含一个整数、一个字符串和一个布尔值。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="function">tuple <span class="title">t1</span><span class="params">(<span class="number">16</span>, <span class="string">"Test"</span>s, <span class="literal">true</span>)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>缘于类型的自动推导，不能通过&amp;来指定引用。如果需要通过构造函数的模板参数推导方式，生成一个包含引用或常量引用的tuple，那么需要分别使用<code>ref()</code>和<code>cref()</code>。<code>ref()</code>和<code>cref()</code>辅助函数在<code>&lt;functional&gt;</code>头文件中定义。例如，下面的构造会生成一个类型为<code>tuple&lt;int, double&amp;, const double&amp;, string&amp;&gt;</code>的tuple:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> d = <span class="number">3.14</span>;</span><br><span class="line"><span class="built_in">string</span> str1 = <span class="string">"Test"</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="function">tuple <span class="title">t2</span><span class="params">(<span class="number">16</span>, ref(d), cref(d), ref(str1))</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>为测试元组t2中的double引用，下面的代码首先将double变量的值写入控制台。然后调用<code>get&lt;1&gt;(t2)</code>，这个函数实际上返回的是对d的引用，因为第二个tuple(索引1)元素使用了<code>ref(d)</code>。第二行修改引用的变量的值，最后一行展示了d的值的确通过保存在tuple中的引用修改了。注意，第三行未能编译，因为<code>cref(d)</code>用于第三个tuple元素，也就是说，它是d的常量引用。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"d = "</span>&lt;&lt; d &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">get&lt;<span class="number">1</span>&gt;(t2) *= <span class="number">21</span></span><br><span class="line"><span class="comment">// get&lt;2&gt;(t2) *= 2;</span></span><br><span class="line"><span class="comment">// ERROR because of cref()</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;<span class="string">"d = "</span> &lt;&lt; d &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p>
<p>如果不使用构造函数的模板参数推导方法，可以使用<code>std::make_tuple()</code>工具函数创建一个tuple。利用这个辅助函数模板，只需要指定实际值，即可创建一个tuple。在编译时自动推导类型，例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> t2 = <span class="built_in">std</span>::make_tuple(<span class="number">16</span>, ref(d), cref(d), ref(str1));</span><br></pre></td></tr></table></figure></p>
<h3 id="分解元组"><a href="#分解元组" class="headerlink" title="分解元组"></a>分解元组</h3><p>可采用两种方法，将一个元组分解为单独的元素：结构化绑定(C++17)以及<code>std::tie()</code>。</p>
<h4 id="结构化绑定"><a href="#结构化绑定" class="headerlink" title="结构化绑定"></a>结构化绑定</h4><p>C++17引入了结构化绑定，允许方便地将一个元组分解为多个变量。例如，下面的代码定义了一个tuple，这个tuple包括一个整数、一个字符串和一个布尔值；此后，使用结构化绑定，将这个tuple分解为三个独立的变量：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">tuple <span class="title">t1</span><span class="params">(<span class="number">16</span>, <span class="string">"Test"</span>s, <span class="literal">true</span>)</span></span>;</span><br><span class="line"><span class="keyword">auto</span>[i, str, b] = t1;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; <span class="string">"Decomposed: i = "</span> &lt;&lt; i &lt;&lt; <span class="string">", str = "</span> &lt;&lt; str &lt;&lt; <span class="string">", b = "</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p>
<p>使用结构化绑定，无法在分解时忽略特定元素。如果tuple包含三个元素，则结构化绑定需要三个变量。如果想忽略元素，则必须使用<code>tie()</code>。</p>
<h4 id="tie"><a href="#tie" class="headerlink" title="tie()"></a>tie()</h4><p>如果在分解元组时不使用结构化绑定，可使用<code>std:tie()</code>工具函数，它生成一个引用tuple。下例首先创建一个tuple，这个tuple包含一个整数、一个字符串和一个布尔值；然后创建三个变量，即整型变量、字符串变量和布尔变量，将这些变量的值写入控制台。<code>tie(i, str, b)</code>调用会创建一个tuple，其中包含对i的引用、对str的引用以及对b的引用。使用赋值运算符，将t1赋给<code>tie()</code>的结果。由于<code>tie()</code>的结果是一个引用tuple，赋值实际上更改了三个独立变量中的值。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tuple&lt;<span class="keyword">int</span>, <span class="built_in">string</span>, <span class="keyword">bool</span>&gt;t1(<span class="number">16</span>, <span class="string">"Test"</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"><span class="keyword">bool</span> b = <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Betore: i = "</span> &lt;&lt; i &lt;&lt; <span class="string">", str = "</span> &lt;&lt; str &lt;&lt; <span class="string">", b = "</span>&lt;&lt; b &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">tie(I, str, b) = t1;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;  <span class="string">"After: i = "</span> &lt;&lt; i &lt;&lt; <span class="string">", str = "</span> &lt;&lt; str &lt;&lt; <span class="string">", b = "</span>&lt;&lt; b &lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="串联"><a href="#串联" class="headerlink" title="串联"></a>串联</h3><p>通过<code>std::tuple_cat()</code>可将两个tuple串联为一个tuple。在下面的例子中，t3的类型为<code>tuple&lt;int, string, bool, double, string&gt;</code>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tuple&lt;<span class="keyword">int</span>, <span class="built_in">string</span>, <span class="keyword">bool</span>&gt; t1(<span class="number">16</span>, <span class="string">"Test"</span>, <span class="literal">true</span>);</span><br><span class="line">tuple&lt;<span class="keyword">double</span>, <span class="built_in">string</span>&gt; t2(<span class="number">3.14</span>, <span class="string">"string 2"</span>);</span><br><span class="line"><span class="keyword">auto</span> t3 = tuple_cat(t1, t2);</span><br></pre></td></tr></table></figure></p>
<h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p>tuple还支持以下比较运算符：==、!=、&lt;、&gt;、&lt;=和&gt;=。为了能使用这些运算符，tuple中存储的元素类型也应该支持这些操作。例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tuple&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; t1(<span class="number">123</span>, <span class="string">"def"</span>);</span><br><span class="line">tuple&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; t2(<span class="number">123</span>, <span class="string">"abc"</span>);</span><br><span class="line"><span class="keyword">if</span>(t1&lt;t2)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"tl &lt; t2"</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"t1 &gt;= t2"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="make-from-tuple"><a href="#make-from-tuple" class="headerlink" title="make_from_tuple()"></a>make_from_tuple()</h3><p>使用<code>std:make_from_tuple()</code>可构建一个T类型的对象，将给定tuple的元素作为参数传递给T的构造函数。例如，假设具有以下类：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Class Foo &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Foo(<span class="built_in">string</span> str, <span class="keyword">int</span> i):mStr(str), mInt(i) &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> mStr;</span><br><span class="line">    <span class="keyword">int</span> mint;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>可按如下方式使用<code>make_from_tuple()</code>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> myTuple = make_tuple(<span class="string">"Hello world."</span>, <span class="number">42</span>);</span><br><span class="line"><span class="keyword">auto</span> foo = make_from_tuple&lt;Foo&gt;(myTuple);</span><br></pre></td></tr></table></figure></p>
<p>提供给<code>make_from_tuple()</code>的实参未必是一个tuple，但必须支持<code>std:get&lt;&gt;()</code>和<code>std::tuple_size</code>。<code>std::array</code>和<code>std::pair</code>也满足这些要求。</p>
<h3 id="apply"><a href="#apply" class="headerlink" title="apply()"></a>apply()</h3><p><code>std::apply()</code>调用给定的函数、lambda表达式和函数对象等，将给定tuple的元素作为实参传递。下面是一个例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; apply(add, <span class="built_in">std</span>::make_tuple(<span class="number">39</span>, <span class="number">3</span>)) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p>
<p>与<code>make_from_tuple()</code>一样，在日常工作中，该函数并不实用；不过，如果要编写使用模板的泛型代码，或进行模板元编程，那么这个函数可提供便利。</p>
<h2 id="文件系统支持库"><a href="#文件系统支持库" class="headerlink" title="文件系统支持库"></a>文件系统支持库</h2><p>C++17引入了文件系统支持库，它们全部定义在<code>&lt;filesystem&gt;</code>头文件中，位于<code>std::filesystem</code>名称空间。它允许你编写可移植的用于文件系统的代码。使用它，可以区分是目录还是文件，迭代目录的内容，操纵路径，检索文件信息(如大小、扩展名和创建时间等)。下面介绍这个库最重要的两个方面：path(路径)和directory_entry(目录项)。</p>
<h3 id="path"><a href="#path" class="headerlink" title="path"></a>path</h3><p>这个库的基本组件是path。path可以是绝对路径，也可以是相对路径，可包含文件名，也可不包含文件名。例如，以下代码定义了一些路径，注意使用了原始字符串字面量来避免对反斜线进行转义。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">path <span class="title">p1</span><span class="params">(<span class="string">LR"(D:\Foo\Bar)"</span>)</span></span>;</span><br><span class="line"><span class="function">path <span class="title">p2</span><span class="params">(<span class="string">L"D:/Foo/Bar"</span>)</span></span>;</span><br><span class="line"><span class="function">path <span class="title">p3</span><span class="params">(<span class="string">L"D:/Foo/Bar/MyFile.txt"</span>)</span></span>;</span><br><span class="line"><span class="function">path <span class="title">P4</span><span class="params">(<span class="string">LR"(..\SomeFolder)"</span>)</span></span>;</span><br><span class="line"><span class="function">path <span class="title">p5</span><span class="params">(<span class="string">L"/usr/lib/X11"</span>)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>将path转换为字符串(如使用<code>c_str()</code>方法)或插入流时，会将其转换为运行代码的系统中的本地格式。例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">path <span class="title">p1</span><span class="params">(<span class="string">LR"(D:\Foo\Bar)"</span>)</span></span>;</span><br><span class="line"><span class="function">path <span class="title">p2</span><span class="params">(<span class="string">L"D:/Foo/Bar"</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; p1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; p2 &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p>
<p>可使用<code>append()</code>方法或operator/=，将组件追加到路径。路径会自动添加分隔符。例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">path <span class="title">p</span><span class="params">(<span class="string">L"D:\\Foo"</span>)</span></span>;</span><br><span class="line">p.append(<span class="string">"Bar"</span>);</span><br><span class="line">P /= <span class="string">"Bar"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; p &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p>
<p>输出是<code>D:\Foo\Bar\Bar</code>。</p>
<p>可使用<code>concat()</code>方法或<code>operator+=</code>，将字符串与现有路径相连。此时路径不会添加分隔符。<code>append()</code>和<code>operator/=</code>自动添加路径分隔符，而<code>concat()</code>和<code>operator+=</code>不会自动添加。</p>
<p>path接口支持<code>remove_filename</code>、<code>replace_filename()</code>、<code>replace_extension()</code>、<code>root_name()</code>、<code>parent_path()</code>、<code>extension()</code>、<code>has_extension()</code>、<code>is_absolute()</code>、<code>is_relative()</code>等操作。</p>
<h3 id="directory-entry"><a href="#directory-entry" class="headerlink" title="directory_entry"></a>directory_entry</h3><p>path只表示文件系统的目录或文件。path可能指不存在的目录或文件。如果想要查询文件系统中的实际目录或文件，需要从path构建一个directory_entry。 如果给定目录或文件不存在，该结构会失败。directory_entry接口支持<code>is_directory()</code>、<code>is_regular_file()</code>、<code>is_socket()</code>、<code>is_symlink()</code>、<code>file_size()</code>、<code>last_write_time()</code>等操作。</p>
<h3 id="辅助函数"><a href="#辅助函数" class="headerlink" title="辅助函数"></a>辅助函数</h3><p>有一组完整的辅助函数可供使用。例如，可使用<code>copy()</code>复制文件或目录，使用<code>create_directory()</code>在文件系统中创建新目录，使用<code>exists()</code>查询给定目录或文件是否存在，使用<code>file_size()</code>获取文件大小，使用<code>last_write_time()</code>获取文件最近一次的修改时间，使用<code>remove()</code>删除文件，使用<code>temp_directory_path()</code>获取适于保存临时文件的目录，使用<code>space()</code>查询文件系统中的可用空间，等等。</p>
<h3 id="目录迭代"><a href="#目录迭代" class="headerlink" title="目录迭代"></a>目录迭代</h3><p>如果想要递归地迭代给定目录中的所有文件和子目录，可使用如下<code>recursive_directory_iterator</code>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processPath</span> <span class="params">(<span class="keyword">const</span> path&amp; p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!exists(p))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> begin = recursive_directory_iterator(p);</span><br><span class="line"><span class="keyword">auto</span> end = recursive_directory_iterator();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> iter = begin; iter != end; ++ iter) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="built_in">string</span> <span class="title">spacer</span><span class="params">(iter.depth()*<span class="number">2</span>, <span class="string">' '</span>)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span>&amp; entry = *iter;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (is_regular_file(entry))</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; spacer &lt;&lt; <span class="string">"File: "</span> &lt;&lt; entry &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (is_directory(entry))</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; spacer &lt;&lt; <span class="string">"Dir: "</span>&lt;&lt; entry &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p>
<h1 id="自定义和扩展标准库"><a href="#自定义和扩展标准库" class="headerlink" title="自定义和扩展标准库"></a>自定义和扩展标准库</h1><h2 id="分配器"><a href="#分配器" class="headerlink" title="分配器"></a>分配器</h2><p>每个标准库容器都接收<code>Allocator</code>类型作为模板参数，大部分情况下默认值就足够了。例如，vector模板的定义如下所示<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Allocator</span> = <span class="title">allocator</span>&lt;T&gt;&gt;<span class="title">class</span> <span class="title">vector</span>;</span></span><br></pre></td></tr></table></figure></p>
<p>容器构造函数还允许指定Allocator类型的对象。通过这些额外参数可自定义容器分配内存的方式。容器执行的每一次内存分配都是通过调用Allocator对象的<code>allocate()</code>方法进行的，每一次内存释放都是通过调用Allocator对象的<code>deallocate()</code>方法进行的。</p>
<p>有几种原因需要使用自定义的分配器。例如：</p>
<ul>
<li>如果底层分配器的性能无法接受，但可构建替换的分配器</li>
<li>如果内存碎片问题(大量不同的分配和释放操作导致内存中出现很多不可用的小空洞)严重</li>
<li>如果必须给操作系统特定的功能分配空间，</li>
</ul>
<p>C++17引入了<strong>多态内存分配器</strong>的概念。对于指定为模板类型参数的容器的分配器，问题在于两个十分相似但具有不同分配器类型的容器区别很大。例如,具有不同分配器模板类型参数的两个vector<int>容器是不同的。<code>std::pmr</code>名称空间的<code>&lt;memory_resource&gt;</code>中定义的多态内存分配器有助于解决这个问题。<code>std::pmr::polymorphic_allocator</code>是适当的分配器类，因为它满足各种要求，如具有<code>allocate()</code>和<code>deallocate()</code>方法。polymorphic allocator的分配行为取决于构建期间的memory_resource，而非取决于模板类型参数。因此，在分配和释放内存时，虽然具有相同的类型，但不同polymorphic_allocator的行为迥异。</int></p>
<h2 id="流适配器"><a href="#流适配器" class="headerlink" title="流适配器"></a>流适配器</h2><p>标准库提供了4个流适配器(stream iterator)。它们是类似于迭代器的类模板，允许将输入流和输出流视为输入迭代器和输出迭代器。通过这些迭代器可对输入流和输出流进行适配，将它们在不同的标准库算法中分别当成来源和目标。下面列出可用的流迭代器:</p>
<ul>
<li><code>ostream_iterator</code>是一个输出流迭代器</li>
<li><code>istream_iterator</code>是一个输入流迭代器</li>
</ul>
<h3 id="输出流迭代器"><a href="#输出流迭代器" class="headerlink" title="输出流迭代器"></a>输出流迭代器</h3><p><code>ostream_iterator</code>是一个输出流迭代器，是一个类模板，接收元素类型作为类型参数。这个类的构造函数接收的参数包括一个输出流以及要在写入每个元素之后写入流的分隔符字符串。<code>ostream_iterator</code>通过<code>operator&lt;&lt;</code>运算符写入元素。可以用ostream_iterator一行代码打印出容器中的元素。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myVector(<span class="number">10</span>);</span><br><span class="line">iota(begin (myVector), end (myVector), <span class="number">1</span>); <span class="comment">// Fill vector with 1,2,3...10</span></span><br><span class="line">copy (cbegin (myVector), cend (myVector), ostream_iterator&lt;<span class="keyword">int</span>&gt;(<span class="built_in">cout</span>, <span class="string">" "</span>));</span><br></pre></td></tr></table></figure></p>
<h3 id="输入流迭代器"><a href="#输入流迭代器" class="headerlink" title="输入流迭代器"></a>输入流迭代器</h3><p>还可使用输入流迭代器<code>istream_iterator</code>通过迭代器抽象从输入流中读取值。这是类模板，将元素类型作为类型参数，通过<code>operator&gt;&gt;</code>运算符读取元素。<code>istream_iterator</code>可用作算法和容器方法的来源。</p>
<h2 id="迭代器适配器"><a href="#迭代器适配器" class="headerlink" title="迭代器适配器"></a>迭代器适配器</h2><p>标准库提供了3个迭代器适配器(iterator adapter), 它们是基于其他迭代器构建的特殊迭代器。这3个迭代器适配器都在<code>&lt;iterator&gt;</code>头文件中定义。</p>
<h3 id="反向迭代器"><a href="#反向迭代器" class="headerlink" title="反向迭代器"></a>反向迭代器</h3><p>标准库提供了<code>std::reverse_iterator</code>类模板，以反向遍历双向迭代器或随机访问迭代器。标准库中所有可反向迭代的容器都提供了类型别名<code>reverse_iterator</code>以及<code>rbegin()</code>和<code>rend()</code>方法。这些<code>reverse_iterator</code>类型别名的类型是<code>std::reverse_iterator&lt;T&gt;</code>，T等于容器的iterator类型别名。<code>rbegin()</code>方法返回指向容器中最后一个元素的<code>reverse_iterator</code>，<code>rend()</code>方法也返回一个<code>reverse_iterator</code>，这个迭代器指向容器中第一个元素之前的元素。对<code>reverse_iterator</code>应用<code>operator++</code>运算符，会对底层容器迭代器调用<code>operator--</code>运算符，反之亦然。例如，可通过以下方式从头到尾遍历一个集合:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> iter = begin(collection); iter != end (collection); ++iter)</span><br></pre></td></tr></table></figure></p>
<p>要从尾到头遍历这个集合的元素，可调用<code>rbegin()</code>和<code>rend()</code>来使用<code>reverse_iterator</code>。注意，这里仍使用<code>++iter</code>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> iter = rbegin(collection); iter != rend(collection); ++iter)</span><br></pre></td></tr></table></figure></p>
<p><code>std::reverse_iterator</code>主要用在标准库中没有等价算法能够反向运行的情况。</p>
<h3 id="插入迭代器"><a href="#插入迭代器" class="headerlink" title="插入迭代器"></a>插入迭代器</h3><p>为了让<code>copy()</code>这类算法的用途更广泛，标准库提供了3个插入迭代器以真正将元素插入容器：<code>insert_iterator</code>、<code>back_insert_iterator</code>和<code>front_insert_iterator</code>。插入迭代器根据容器类型模板化，在构造函数中接收实际的容器引用。通过提供必要的迭代器接口，这些适配器可用作<code>copy()</code>这类算法的目标迭代器。这些适配器不会替换容器中的元素，而通过调用容器真正插入新元素。</p>
<p>基本的<code>insert_iterator</code>调用容器的<code>insert(position, element)</code>方法，<code>back_insert_iterator</code>调用<code>push_back(element)</code>方法，<code>front insert_iterator</code>调用<code>push_front(element)</code>方法，例如，结合<code>back_insert_iterator</code>和<code>copy_if()</code>算法能为vectorTwo填充来自vectorOne的不等于100的所有元素:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vectorone, vectorTwo;</span><br><span class="line">back_insert_iterator&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; inserter(vectorTwo);</span><br><span class="line">copy_if(cbegin (vectorOne), cend (vectorone), inserter, [](<span class="keyword">int</span> i)&#123;<span class="keyword">return</span> i != <span class="number">100</span>;&#125;);</span><br><span class="line">copy (cbegin (vectorTwo), cend (vectorTwo), ostream_iterator&lt;<span class="keyword">int</span>&gt;(<span class="built_in">cout</span>, <span class="string">""</span>));</span><br></pre></td></tr></table></figure></p>
<p>从这段代码可看出，在使用插入迭代器时，不需要事先调整目标容器的大小。</p>
<p>也可通过<code>std::back_inserter()</code>工具函数创建一个<code>back_insert_iterator</code>。例如，在前一个例子中，可删除定义inserter变量的那一行代码，然后将<code>copy_if()</code>调用改写为以下代码。结果和之前的实现完全相同:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">copy_if(cbegin (vectorOne), cend (vectorOne), back_inserter (vectorTwo), [](<span class="keyword">int</span> i)&#123;<span class="keyword">return</span> i!=<span class="number">100</span>;&#125;);</span><br></pre></td></tr></table></figure></p>
<p><code>front_insert_iterator</code>和<code>insert_iterator</code>的工作方式类似，区别在于<code>insert_iterator</code>在构造函数中还接收初始的迭代器位置作为参数，并将这个位置传入第一次<code>insert(position, element)</code>调用。后续的迭代器位置提示通过每一次<code>insert()</code>调用的返回值生成。</p>
<p>使用<code>insert_iterator</code>的一个巨大好处是可将关联容器用作修改类算法的目标。关联容器实际上支持将接收迭代器位置作为参数的<code>insert()</code>，并将这个位置用作“提示”，但这个位置可忽略。在关联容器上使用<code>insert_iterator</code>时，可传入容器的<code>begin()</code>或<code>end()</code>迭代器用作提示。<code>insert_iterator</code>在每次调用<code>insert()</code>后修改传输给<code>insert()</code>的迭代器提示，使其成为刚插入元素之后的那个位置。</p>
<h3 id="移动迭代器"><a href="#移动迭代器" class="headerlink" title="移动迭代器"></a>移动迭代器</h3><p>迭代适配器<code>std:move_iterator</code>的解除引用运算符会自动将值转换为rvalue引用，也就是说，这个值可移动到新的目的地，而不会有复制开销。在使用移动语义前，需要保证对象支持移动语义。</p>
<h2 id="扩展标准库"><a href="#扩展标准库" class="headerlink" title="扩展标准库"></a>扩展标准库</h2><h3 id="编写标准库算法"><a href="#编写标准库算法" class="headerlink" title="编写标准库算法"></a>编写标准库算法</h3><h4 id="find-all"><a href="#find-all" class="headerlink" title="find_all()"></a>find_all()</h4><p>假设需要在指定范围内找到满足某个谓词的所有元素。<code>find()</code>和<code>find_if()</code>是最符合条件的备选算法，但这些算法返回的都是仅引用一个元素的迭代器。可使用<code>copy_if()</code>找出所有满足谓词的元素, 但会用所找到元素的副本填充输出。如果想要避免复制，可使用<code>copy_in()</code>和<code>back_insert_iterator()</code>在<code>vector&lt;reference_wrapper&lt;T&gt;&gt;</code>中)，但这不能给出所找到元素的位置。可自行编写能提供这个功能的版本，称为<code>find_all()</code>。</p>
<p>与<code>copy_if()</code>一样， 该算法给输出序列返回一个迭代器，指向输出序列中存储的最后一个元素后面的那个元素。下面是算法原型:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIterator, <span class="keyword">typename</span> OutputIterator, <span class="keyword">typename</span> Predicate&gt;</span><br><span class="line"><span class="function">OutputIterator <span class="title">find_all</span><span class="params">(InputIterator first, InputIterator last, OutputIterator dest, Predicate pred)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>另一种可选方案是忽略输出迭代器，给输入序列返回一个迭代器，遍历输入序列中所有匹配的元素，但是这种方案要求编写自定义的迭代器类。</p>
<p>下一项任务是编写算法的实现。<code>find_all()</code>算法遍历输入序列中的所有元素，给每个元素调用谓词，把匹配元素的迭代器存储在输出序列中。下面是算法的实现:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIterator, <span class="keyword">typename</span> OutputIterator, <span class="keyword">typename</span> Predicate&gt;</span><br><span class="line"><span class="function">OutputIterator <span class="title">find_all</span><span class="params">(InputIterator first, Inputiterator last,OutputIterator dest, Predicate pred)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (first != last) &#123;</span><br><span class="line">        <span class="keyword">if</span>(pred(*first)) &#123;</span><br><span class="line">            *dest = first;</span><br><span class="line">            ++dest;</span><br><span class="line">        &#125;</span><br><span class="line">        ++first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="iterator-traits"><a href="#iterator-traits" class="headerlink" title="iterator_traits"></a>iterator_traits</h4><p>一些算法的实现需要迭代器的额外信息。例如，为保存临时值，算法可能需要知道迭代器引用的元素的类型，还可能需要知道迭代器是双向访问的还是随机访问的。C++提供了一个名为<code>iterator_traits</code>的类模板，以找到这些信息。通过要使用的迭代器类型实例化<code>iterator_traits</code>类模板，然后可访问以下5个类型别名：<code>value_type</code>、<code>difference_type</code>、<code>iterator_category</code>、<code>pointer</code>、<code>reference</code>。例如，下面的模板函数声明了一个临时变量，其类型是<code>iteratorType</code>类型的迭代器引用的类型。注意，在<code>iterator_traits</code>这行前面要使用<code>typename</code>关键字。访问基于一个或多个模板参数的类型时，必须显式地指定<code>typename</code>。在这个例子中，模板参数<code>IteratorType</code>用于访问value_type类型：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> IteratorType&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">iteratortraitsTest</span><span class="params">(IteratorType it)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;IteratorType&gt;::value_type temp;</span><br><span class="line">    temp = *it;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; temp &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p>
<p>可通过以下代码测试这个函数:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123; <span class="number">5</span> &#125;;</span><br><span class="line">iteratorTraitsTest(cbegin(v));</span><br></pre></td></tr></table></figure></p>
<p>在这段代码中，<code>iteratorTraitsTest()</code>函数中temp变量的类型为int。输出是5。</p>
<h1 id="高级模板"><a href="#高级模板" class="headerlink" title="高级模板"></a>高级模板</h1><h2 id="深入了解模板参数"><a href="#深入了解模板参数" class="headerlink" title="深入了解模板参数"></a>深入了解模板参数</h2><p>实际上有3种模板参数：类型参数、非类型参数和template template参数。</p>
<h3 id="深入了解模板类型参数"><a href="#深入了解模板类型参数" class="headerlink" title="深入了解模板类型参数"></a>深入了解模板类型参数</h3><p>模板的类型参数是模板的精髓。可声明任意数目的类型参数。标准库定义了几个模板化的容器类，包括vector和deque。下面是带有额外模板参数的类定义：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Container&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grid</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>：</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Grid</span><span class="params">(<span class="keyword">size_t</span> width = kDefaultwidth, <span class="keyword">size_t</span> height = kDefaultHeight)</span></span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~Grid() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    Grid(<span class="keyword">const</span> Grid&amp; src) = <span class="keyword">default</span>;</span><br><span class="line">    Grid&lt;T, Container&gt;&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Grid&amp; rhs) = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    Grid(Grids&amp; src) = <span class="keyword">default</span>;</span><br><span class="line">    Grid&lt;T, Container&gt;&amp; <span class="keyword">operator</span>= (Gride&amp;&amp; rhs) = <span class="keyword">default</span>;</span><br><span class="line">    <span class="keyword">typename</span> Container::<span class="function">value_type&amp; <span class="title">at</span><span class="params">(<span class="keyword">size_t</span> x, <span class="keyword">size_t</span> y)</span></span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">typename</span> Container::<span class="function">value_types <span class="title">at</span><span class="params">(<span class="keyword">size_t</span> x, <span class="keyword">size_t</span> y)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="keyword">size_t</span> getHeight()<span class="keyword">const</span> &#123; <span class="keyword">return</span> mHeight; &#125;</span><br><span class="line">    <span class="keyword">size_t</span> getwidth()<span class="keyword">const</span> &#123; <span class="keyword">return</span> mwidth; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">size_t</span> kDefaultwidth = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">size_t</span> kDefaultHeight = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">verifyCoordinate</span><span class="params">(<span class="keyword">size_t</span> x, <span class="keyword">size_t</span> y)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Container&gt; mCells;</span><br><span class="line">    <span class="keyword">size_t</span> midth = <span class="number">0</span>, mHeight = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>现在这个模板有两个参数：T和Container。因此，所有引用了<code>Grid&lt;T&gt;</code>的地方现在都必须指定<code>Grid&lt;T, Container&gt;</code>以表示两个模板参数。其他仅有的变化是，mCells现在是Container的vector，而不是vector的vector。下面是构造函数的定义：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Container&gt;</span><br><span class="line">Grid&lt;T, Container&gt;::Grid(<span class="keyword">size_t</span> width, <span class="keyword">size_t</span> height) : mwidth(width), mheight(height) &#123;</span><br><span class="line">    mCells.resize(mWidth);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; column : mCells)</span><br><span class="line">        column.resize(mHeight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个构造函数假设Container类型具有<code>resize()</code>方法。如果尝试通过指定没有<code>resize()</code>方法的类型来实例化这个模板，编译器将生成错误。<code>at()</code>方法的返回类型是存储在给定类型容器中的元素类型。可以使用<code>typename Container:value_type</code>访问该类型。下面是其余方法的实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Container&gt;</span><br><span class="line"><span class="keyword">void</span> Grid&lt;T, Container&gt;::verifyCoordinate(<span class="keyword">size_t</span> x, <span class="keyword">size_t</span> y) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(x &gt;= mWidth || y &gt;= mHeight)</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">std</span>::out_of_range(<span class="string">""</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在，可按以下方式实例化和使用Grid对象:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Grid&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;optional&lt;<span class="keyword">int</span>&gt;&gt;&gt; myIntVectorGrid;</span><br><span class="line">Grid&lt;<span class="keyword">int</span>, <span class="built_in">deque</span>&lt;optional&lt;<span class="keyword">int</span>&gt;&gt;&gt; myIntDequeGrid;</span><br></pre></td></tr></table></figure></p>
<p>给参数名称使用Container并不意味着类型必须是容器。可尝试用int实例化Grid类:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Grid&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; test; <span class="comment">// WILL NOT COMPILE</span></span><br></pre></td></tr></table></figure></p>
<p>此行代码无法成功编译，在尝试处理类模板定义的这一行之前，一切都正常<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typename</span> Container::<span class="function">value_types <span class="title">at</span><span class="params">(<span class="keyword">size_t</span> x, <span class="keyword">size_t</span> y)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>在这一行，编译器意识到column是int类型，没有嵌入的value_type类型别名。</p>
<p>与函数参数一样，可给模板参数指定默认值。例如，可能想表示Grid的默认容器是vector。这个模板类定义如下所示:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Container = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::optional&lt;T&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></p>
<p>可以使用第一个模板参数中的类型T作为第二个模板参数的默认值中optional模板的参数。C++语法要求不能在方法定义的模板标题行中重复默认值。现在有了这个默认参数后，实例化网格时，客户可指定或不指定底层容器:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Grid&lt;<span class="keyword">int</span>, <span class="built_in">deque</span>&lt;optional&lt;<span class="keyword">int</span>&gt;&gt;&gt; myDequeGrid;</span><br><span class="line">Grid&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;optional&lt;<span class="keyword">int</span>&gt;&gt;&gt; myVectorGrid;</span><br><span class="line">Grid&lt;<span class="keyword">int</span>&gt; myVectorGrid2 (myVectorGrid);</span><br></pre></td></tr></table></figure></p>
<h3 id="template-template参数介绍"><a href="#template-template参数介绍" class="headerlink" title="template template参数介绍"></a>template template参数介绍</h3><p>如果能编写以下代码就好了：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Grid&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&gt; myIntGrid;</span><br></pre></td></tr></table></figure></p>
<p>Grid类应该能够判断出需要一个元素类型为int的optional vector。不过编译器不会允许传递这样的参数给普通的类型参数，因为vector本身并不是类型，而是模板。如果想要接收模板作为模板参数,那么必须使用一种特殊参数，称为<strong>template template参数</strong>。指定template template参数时，template template参数的完整规范包括该模板的参数。例如，vector和deque等容器有一个模板参数列表，如下所示。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E, <span class="keyword">typename</span> Allocator = <span class="built_in">std</span>::allocator&lt;E&gt;&gt;</span><br><span class="line">class <span class="built_in">vector</span> &#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>要把这样的容器传递为template template参数， 只能复制并粘贴类模板的声明(在本例中是<code>template &lt;typename E, typename Allocator = allocator&lt;E&gt;&gt; class vector</code>)，用参数名(Container)替代类名(vector)，并把它用作另一个模板声明的template template参数，而不是简单的类型名。有了前面的模板规范，下面是接收一个容器模板作为第二个模板参数的Grid类的类模板定义：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> E, <span class="keyword">typename</span> Allocator = <span class="built_in">std</span>::allocator&lt;E&gt;&gt; class Container = <span class="built_in">std</span>::<span class="built_in">vector</span>&gt;</span><br><span class="line">class Grid &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">std</span>::optional&lt;T&gt;&amp; at(<span class="keyword">size_t</span> x, <span class="keyword">size_t</span> y);</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::optional&lt;T&gt;&amp; at(<span class="keyword">size_t</span> x, <span class="keyword">size_t</span> y) <span class="keyword">const</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">verifyCoordinate</span><span class="params">(<span class="keyword">size_t</span> x, <span class="keyword">size_t</span> y)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Container&lt;<span class="built_in">std</span>::optional&lt;T&gt;&gt;&gt;mCells;</span><br><span class="line">    <span class="keyword">size_t</span> mWidth = <span class="number">0</span>, mHeight = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>第一个模板参数与以前一样：元素类型T。第二个模板参数现在本身就是容器的模板，如vector或dcque。如前所述， 这种“模板类型”必须接收两个参数：元素类型E和分配器类型。</p>
<p>注意嵌套模板参数列表后面重复的单词class。这个参数在Grid模板中的名称是Container。默认值现为<code>vector</code>而不是<code>vector&lt;T&gt;</code>，因为Container是模板而不是实际类型。</p>
<p>template template参数更通用的语法规则是：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;..., <span class="keyword">template</span> &lt;TemplateTypeParams&gt; <span class="class"><span class="keyword">class</span> <span class="title">ParameterName</span>, ...&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>从C++17开始，也可以用typename关键字替代class，如下所示:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;..., <span class="keyword">template</span> &lt;TemplateTypeParams&gt; <span class="keyword">typename</span> ParameterName, ...&gt;</span><br></pre></td></tr></table></figure></p>
<p>在代码中不要使用Container本身，而必须把<code>Container&lt;std::optiona&lt;T&gt;&gt;</code>指定为容器类型。例如，现在mCells的声明如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Container&lt;<span class="built_in">std</span>::optional&lt;T&gt;&gt;&gt; mCells;</span><br></pre></td></tr></table></figure></p>
<p>不需要更改方法定义，但必须更改模板行，例如:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> E, <span class="keyword">typename</span> Allocator = <span class="built_in">std</span>::allocator&lt;E&gt;&gt; class Container&gt;</span><br><span class="line"><span class="keyword">void</span> Grid&lt;T, Container&gt;::verifyCoordinate(<span class="keyword">size_t</span> x, <span class="keyword">size_t</span> y) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= mWidth || y &gt;= mHeight)</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">std</span>::out_of_range(<span class="string">""</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以这样使用Grid模板:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Grid&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&gt;myGrid;</span><br><span class="line">myGrid.at(<span class="number">1</span>, <span class="number">2</span>) = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; myGrid.at(<span class="number">1</span>,<span class="number">2</span>).value_or(<span class="number">0</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">Grid&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&gt; myGrid2(myGrid);</span><br></pre></td></tr></table></figure></p>
<p>上述C++语法有点令人费解，因为它试图获得最大的灵活性。尽量不要在这里陷入语法困境，记住主要概念：可向其他模板传入模板作为参数</p>
<h3 id="深入了解非类型模板参数"><a href="#深入了解非类型模板参数" class="headerlink" title="深入了解非类型模板参数"></a>深入了解非类型模板参数</h3><p>有时可能想让用户指定一个默认元素，用来初始化网格中的每个单元格。下面是实现这个目标的一种完全合理的方法，它使用<code>T()</code>作为第二个模板参数的默认值：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">const</span> T DEFAULT = T()&gt;</span><br><span class="line">class Grid &#123; &#125;;</span><br></pre></td></tr></table></figure></p>
<p>这个定义是合法的。可使用第一个参数中的类型T作为第二个参数的类型，非类型参数可为const，就像函数参数一样。可使用T的初始值来初始化网格中的每个单元格：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">const</span> T DEFAULT&gt;</span><br><span class="line">Grid&lt;T, DEFAULT&gt;::Grid(<span class="keyword">size_t</span> width, <span class="keyword">size_t</span> height) : mWidth(width), mHeight(height) &#123;</span><br><span class="line">    mCells.resize(mWidth);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; column : mcells) &#123;</span><br><span class="line">        column.resize(mHeight);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; element : column) &#123;</span><br><span class="line">            element = DEFAULT;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其他的方法定义保持不变,只是必须向模板行添加第二个模板参数，所有<code>Grid&lt;T&gt;</code>实例要变为<code>Grid&lt;T,DEFAULT&gt;</code>。完成这些修改后，可实例化一个int网格，并为所有元素设置初始值：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Grid&lt;<span class="keyword">int</span>&gt; myIntGrid;</span><br><span class="line">Grid&lt;<span class="keyword">int</span>, <span class="number">10</span>&gt; myIntGrid2;</span><br></pre></td></tr></table></figure></p>
<p>非类型参数不能是对象，甚至不能是double和float值。非类型参数被限定为整型、 枚举、指针和引用。</p>
<p>允许用户指定网格初始元素值的一种更详尽方式是使用T引用作为非类型模板参数。下面是新的类定义:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">const</span> T&amp; DEFAULT&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grid</span> &#123;</span>&#125;;</span><br></pre></td></tr></table></figure></p>
<p>现在可为任何类型实例化这个模板类。C++17标准指定，作为第二个模板参数传入的引用必须是转换的常量表达式(模板参数类型)，不允许引用子对象、临时对象、字符串字面量、typeid表达式的结果或预定义的<code>__func__</code>变量。下例声明了带有初始值的int网格和SpreadsheetCell网格。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> defaultint = <span class="number">11</span>;</span><br><span class="line">    Grid&lt;<span class="keyword">int</span>, defaultint&gt; myIntGrid;</span><br><span class="line">    <span class="function">SpreadsheetCell <span class="title">defaultCe11</span><span class="params">(<span class="number">1.2</span>)</span></span>;</span><br><span class="line">    Grid&lt;Spreadsheetcell, defaultcell&gt; mySpreadsheet;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但这些是C++17的规则，大多数编译器尚未实施这些规则。在C++17之前，传给引用非类型模板参数的实参不能是临时的，不能是无链接(外部或内部)的命名左值。因此，对于上面的示例，下面使用C++17之前的规则。使用内部链接定义初始值:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> defaultInt = <span class="number">11</span>;</span><br><span class="line">    <span class="function">spreadsheetcell <span class="title">defaultCell</span><span class="params">(<span class="number">1.2</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    Grid&lt;<span class="keyword">int</span>, defaultint&gt; myIntGrid;</span><br><span class="line">    Grid&lt;Spreadsheetcell, defaultcell&gt; mySpreadsheet;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="模板类部分特例化"><a href="#模板类部分特例化" class="headerlink" title="模板类部分特例化"></a>模板类部分特例化</h2><p>可编写部分特例化的类，这个类允许特例化部分模板参数，而不处理其他参数。例如，基本版本的Grid模板带有宽度和高度的非类型参数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">size_t</span> WIDTH, <span class="keyword">size_t</span> HEIGHT&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grid</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Grid() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~Grid() = <span class="keyword">default</span>;</span><br><span class="line">    Grid(<span class="keyword">const</span> Grid&amp; src) = <span class="keyword">default</span>;</span><br><span class="line">    Grid&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Grid&amp; rhs) = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">std</span>::optional&lt;T&gt;&amp; at(<span class="keyword">size_t</span> x, <span class="keyword">size_t</span> y);</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::optional&lt;T&gt;&amp; at(<span class="keyword">size_t</span> x, <span class="keyword">size_t</span> y) <span class="keyword">const</span>;</span><br><span class="line">    <span class="keyword">size_t</span> getHeight() <span class="keyword">const</span> &#123; <span class="keyword">return</span> HEIGHT; &#125;</span><br><span class="line">    <span class="keyword">size_t</span> getWidth() <span class="keyword">const</span> &#123; <span class="keyword">return</span> WIDTH; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">verifyCoordinate</span><span class="params">(<span class="keyword">size_t</span> x, <span class="keyword">size_t</span> y)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::optional&lt;T&gt; mCells[WIDTH][HEIGHT];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>可采用这种方式为<code>char*</code>C风格字符串特例化这个模板类：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">size_t</span> WIDTH, <span class="keyword">size_t</span> HEIGHT&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grid</span>&lt;const char*, WIDTH, WEIGHT&gt; &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Grid() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~Grid() = <span class="keyword">default</span>;</span><br><span class="line">    Grid(<span class="keyword">const</span> Grid&amp; src) = <span class="keyword">default</span>;</span><br><span class="line">    Gride <span class="keyword">operator</span>-(<span class="keyword">const</span> Grid&amp; rhs) = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">std</span>::optional&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;&amp; at(<span class="keyword">size_t</span> x, <span class="keyword">size_t</span> y);</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::optional&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;&amp; at(<span class="keyword">size_t</span> x, <span class="keyword">size_t</span> y) <span class="keyword">const</span>;</span><br><span class="line">    <span class="keyword">size_t</span> getHeight()<span class="keyword">const</span> &#123; <span class="keyword">return</span> HEIGHT; &#125;</span><br><span class="line">    <span class="keyword">size_t</span> getWidth() <span class="keyword">const</span> &#123; <span class="keyword">return</span> WIDTH; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">verifyCoordinate</span><span class="params">(<span class="keyword">size_t</span> x, <span class="keyword">size_t</span> y)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::optional&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; mCells [WIDTH][HEIGHT];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在这个例子中，没有特例化所有模板参数。因此，模板代码行如下所示:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">size_t</span> WIDTH, <span class="keyword">size_t</span> HEIGHT&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grid</span>&lt;const char*, WIDTH, HEIGHT&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>注意，这个模板只有两个参数：WIDTH和HEIGHT。然而，这个Grid类带有3个参数：T、WIDTH和HEIGHT。因此，模板参数列表包含两个参数，而显式的<code>Grid&lt;const char*, WIDTH, HEIGHT&gt;</code>包含3个参数。实例化模板时仍然必须指定3个参数。不能只通过高度和宽度实例化模板：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Grid&lt;<span class="keyword">int</span>, <span class="number">2</span>, <span class="number">2</span>&gt; myIntGrid;</span><br><span class="line">Grid&lt;<span class="keyword">const</span> <span class="keyword">char</span>*, <span class="number">2</span>, <span class="number">2</span>&gt; myStringGrid;</span><br><span class="line">Grid&lt;<span class="number">2</span>, <span class="number">3</span>&gt; test;</span><br></pre></td></tr></table></figure></p>
<p>上述语法的确很乱。更糟糕的是，在部分特例化中，与完整特例化不同，在每个方法定义的前面要包含模板代码行，如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">size_t</span> WIDTH, <span class="keyword">size_t</span> HEIGHT&gt;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::optional&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;&amp;</span><br><span class="line">    Grid&lt;<span class="keyword">const</span> <span class="keyword">char</span>*, WIDTH, HEIGHT&gt;::at(<span class="keyword">size_t</span> x, <span class="keyword">size_t</span> y) <span class="keyword">const</span> &#123;</span><br><span class="line">    verifyCoordinate(x, y);</span><br><span class="line">    <span class="keyword">return</span> mCells[x][y];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>需要这一带有两个参数的模板行，以表示这个方法针对这两个参数做了参数化处理。注意，需要表示完整类名时，都要使用<code>Grid&lt;const char*, WIDTH, HEIGHT&gt;</code>。</p>
<p>前面的例子并没有表现出部分特例化的真正威力。可为可能的类型子集编写特例化的实现，而不需要为每种类型特例化。下面是类的定义，假设只用一个参数特例化最早版本的Grid。在这个实现中,Grid成为所提供指针的拥有者，所以它在需要时自动释放内存:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grid</span>&lt;T*&gt; &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Grid</span><span class="params">(<span class="keyword">size_t</span> width = kDefaultWidth, <span class="keyword">size_t</span> height = kDefaultHeight)</span></span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~Grid() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    Grid(<span class="keyword">const</span> Grid&amp; src);</span><br><span class="line">    Grid&lt;T*&gt;&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Grids rhs);</span><br><span class="line"></span><br><span class="line">    Grid(Grid&amp;&amp; src) = <span class="keyword">default</span>;</span><br><span class="line">    Grid&lt;T*&gt;&amp; <span class="keyword">operator</span>=(Grid&amp;&amp; rhs) = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Gride other)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;T&gt;&amp; at(<span class="keyword">size_t</span> x, <span class="keyword">size_t</span> y);</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;T&gt;&amp; at(<span class="keyword">size_t</span> x, <span class="keyword">size_t</span> y) <span class="keyword">const</span>;</span><br><span class="line">    <span class="keyword">size_t</span> getHeight() <span class="keyword">const</span> &#123; <span class="keyword">return</span> mHeight; &#125;</span><br><span class="line">    <span class="keyword">size_t</span> getwidth()<span class="keyword">const</span> &#123; <span class="keyword">return</span> mWidth; &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">size_t</span> kDefaultwidth = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">size_t</span> kDefaultHeight = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">verlfyCoordinate</span><span class="params">(<span class="keyword">size_t</span> x, <span class="keyword">size_t</span> y)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;T&gt;&gt;&gt;mCells;</span><br><span class="line">    <span class="keyword">size_t</span> mwidth = <span class="number">0</span>, mileight = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></p>
<p>像往常一样，下面这两行代码是关键所在:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grid</span>&lt;T*&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>上述语法表明这个类是Grid模板对所有指针类型的特例化。只有T是指针类型的情况下才提供实现。请注意，如果像下面这样实例化网格：<code>Grid&lt;int*&gt; myIntGrid</code>，那么T实际上是int而非<code>int*</code>。这不够直观，但遗憾的是，这种语法就是这样使用的。下面是一个示例:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Grid&lt;<span class="keyword">int</span>&gt; myIntGrid; <span class="comment">// Uses the non-specialized grid</span></span><br><span class="line">Grid&lt;<span class="keyword">int</span>*&gt; psGrid(<span class="number">2</span>, <span class="number">2</span>); <span class="comment">// Uses the partial specialization for pointer types</span></span><br><span class="line">psGrid.at(<span class="number">0</span>, <span class="number">0</span>) = make_unique&lt;<span class="keyword">int</span>&gt;(<span class="number">1</span>);</span><br><span class="line">psGrid.at(<span class="number">0</span>, <span class="number">1</span>) = make_unique&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>);</span><br><span class="line">psGrid.at(<span class="number">1</span>, <span class="number">0</span>) = make_unique&lt;<span class="keyword">int</span>&gt;(<span class="number">3</span>);</span><br><span class="line">Grid&lt;<span class="keyword">int</span>*&gt; psGrid2(psGrid);</span><br><span class="line">Grid&lt;<span class="keyword">int</span>*&gt; psGrid3;</span><br><span class="line">psGrid3 = psGrid2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span>&amp; element = psGrid2.at(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (element) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *element &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    *element = <span class="number">6</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="通过重载模拟函数部分特例化"><a href="#通过重载模拟函数部分特例化" class="headerlink" title="通过重载模拟函数部分特例化"></a>通过重载模拟函数部分特例化</h2><p>C++标准不允许函数的模板部分特例化。相反，可用另一个模板重载函数。区别十分微妙。假设要编写一个特例化的<code>Find()</code>函数模板，这个特例化对指针解除引用，对指向的对象直接调用<code>operator--</code>。根据类模板部分特例化的语法，可能会编写下面的代码:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">size_t</span> Find&lt;T*&gt;(T* <span class="keyword">const</span>&amp; value, T* <span class="keyword">const</span>* arr, <span class="keyword">size_t</span> size) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; size; i ++) </span><br><span class="line">        <span class="keyword">if</span> (*arr[i] == *value) </span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">return</span> NOT_FOUND;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然而，这种声明函数模板部分特例化的语法是C++标准所不允许的。实现所需行为的正确方法是为<code>Find()</code>编写一个新模板，区别看似微不足道且不切合实际，但不这样就无法编译:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">size_t</span> Find(T* <span class="keyword">const</span>&amp; value, T* <span class="keyword">const</span>* arr, <span class="keyword">size_t</span> size) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; size; i ++)</span><br><span class="line">        <span class="keyword">if</span> (*arr[i] == *value)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">return</span> NOT_FOUND;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个<code>Find()</code>版本的第一个参数是<code>T* const&amp;</code>，这是为了与原来的<code>Find()</code>函数模板(它把<code>const T&amp;</code>作为第一个参数)保持一致，但这里将<code>T*</code>(而不是<code>T* const&amp;</code>)用作<code>Find()</code>部分特例化的第一个参数，这也是可行的。</p>
<h2 id="模板递归"><a href="#模板递归" class="headerlink" title="模板递归"></a>模板递归</h2><h3 id="N维网格-初次尝试"><a href="#N维网格-初次尝试" class="headerlink" title="N维网格:初次尝试"></a>N维网格:初次尝试</h3><p>前面的Grid模板示例到现在为止只支持两个维度，这限制了它的实用性。一种方法是只编写一个一维网格。然后，利用另一个网格作为元素类型实例化Grid，可创建任意维度的网格。这种Grid元素类型本身可以用网格作为元素类型进行实例化，依此类推。下面是OneDGrid类模板的实现。这只是前面例子中Grid模板的一维版本，添加了<code>resize()</code>方法,并用<code>operator[]</code>替换了<code>at()</code>。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OneDGrid</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">OneDGrid</span><span class="params">(<span class="keyword">size_t</span> size = kDefaultsize)</span></span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~OneDGrid() = <span class="keyword">default</span>;</span><br><span class="line">    T&amp; <span class="keyword">operator</span>[](<span class="keyword">size_t</span> x);</span><br><span class="line">    <span class="keyword">const</span> T&amp; <span class="keyword">operator</span>[](<span class="keyword">size_t</span> x) <span class="keyword">const</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">size_t</span> newSize)</span></span>;</span><br><span class="line">    <span class="keyword">size_t</span> getsize() <span class="keyword">const</span> &#123; <span class="keyword">return</span> mElements.size();&#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">size_t</span> kDefaultsize = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt; mElements;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">OneDGrid&lt;T&gt;::OneDGrid(<span class="keyword">size_t</span> size) &#123;</span><br><span class="line">    resize(size);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> OneDGtid&lt;T&gt;::resize(size t newSize) &#123;</span><br><span class="line">    mElements.resize(newSize);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T&amp; OneDGrid&lt;T&gt;::<span class="keyword">operator</span> [] (<span class="keyword">size_t</span> x) &#123;</span><br><span class="line">    <span class="keyword">return</span> mElements[x];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>有了OneDGrid的这个实现，就可通过如下方式创建多维网格:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">OneDGrid&lt;<span class="keyword">int</span>&gt; singleDGrid;</span><br><span class="line">OneDGrid&lt;OneDGrid&lt;<span class="keyword">int</span>&gt;&gt; twoDGrid;</span><br><span class="line">OneDGrid&lt;OneDGrid&lt;OneDGrid&lt;<span class="keyword">int</span>&gt;&gt;&gt; threeDGrid;</span><br><span class="line">singleDGrid[<span class="number">3</span>] = <span class="number">5</span>;</span><br><span class="line">twoDGrid[<span class="number">3</span>][<span class="number">3</span>] = <span class="number">5</span>;</span><br><span class="line">threeDGrid[<span class="number">3</span>][<span class="number">3</span>][<span class="number">3</span>] = <span class="number">5</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="真正的N维网格"><a href="#真正的N维网格" class="headerlink" title="真正的N维网格"></a>真正的N维网格</h3><p>可以编写一个类模板来自动进行递归。然后，可创建如下N维网格:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NDGrid&lt;<span class="keyword">int</span>, <span class="number">1</span>&gt; singleDGrid;</span><br><span class="line">NDGrid&lt;<span class="keyword">int</span>, <span class="number">2</span>&gt; twoDGrid;</span><br><span class="line">NDGrid&lt;<span class="keyword">int</span>, <span class="number">3</span>&gt; threeDGrid;</span><br></pre></td></tr></table></figure></p>
<p>NDGrid类模板需要元素类型和表示维度的整数作为参数。这里的关键问题在于，NDGrid的元素类型不是模板参数列表中指定的元素类型，而是上一层递归的维度中指定的另一个NDGrid。换句话说，三维网格是二维网格的矢量，二维网格是一维网格的各个矢量。</p>
<p>使用递归时，需要处理基本情形(base case)。 可编写维度为1的部分特例化的NDGrid，其中元素类型不是另一个NDGrid，而是模板参数指定的元素类型。下面是NDGrid模板定义的一般形式,突出显示了与前面OneDGrid的不同之处：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">size_t</span> N&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NDGrid</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">NDGrid</span><span class="params">(<span class="keyword">size_t</span> size = kDefaultSize)</span></span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~NDGrid() = <span class="keyword">default</span>;</span><br><span class="line">    NDGrid&lt;T, N<span class="number">-1</span>&gt;&amp; <span class="keyword">operator</span>[](<span class="keyword">size_t</span> x);</span><br><span class="line">    <span class="keyword">const</span> NDGrid&lt;T, N<span class="number">-1</span>&gt;&amp; <span class="keyword">operator</span> [] (<span class="keyword">size_t</span> x) <span class="keyword">const</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">size_t</span> newSize)</span></span>;</span><br><span class="line">    <span class="keyword">size_t</span> getsize() <span class="keyword">const</span> &#123; <span class="keyword">return</span> mElements.size();&#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">size_t</span> kDefaultsize =<span class="number">10</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;NDGrid&lt;T, N-1&gt;&gt; mElements;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>注意，mElements是<code>NDGrid&lt;T, N-1&gt;</code>的矢量:这是递归步骤。此外，<code>operator[]</code>返回一个指向元素类型的引用，依然是<code>NDGrid&lt;T, N-1&gt;</code>而非T。基本情形的模板定义是维度为1的部分特例化:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NDGrid</span>&lt;T, 1&gt; &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">NDGrid</span><span class="params">(<span class="keyword">size_t</span> size = kDefaultSize)</span></span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~NDGrid() = <span class="keyword">default</span>;</span><br><span class="line">    T&amp; <span class="keyword">operator</span>[](<span class="keyword">size_t</span> x);</span><br><span class="line">    <span class="keyword">const</span> T&amp; <span class="keyword">operator</span>[](<span class="keyword">size_t</span> x) <span class="keyword">const</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">size_t</span> newSize)</span></span>;</span><br><span class="line">    <span class="keyword">size_t</span> getSize() <span class="keyword">const</span> &#123; <span class="keyword">return</span> mElements.size();&#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">size_t</span> kDefaultsize = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt; mElements;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>模板递归实现最棘手的部分不是模板递归本身，而是网格中每个维度的正确大小。这个实现创建了N维网格，每个维度都是一样大的。为每个维度指定不同的大小要困难得多。</p>
<p>下面是NDGrid主模板的实现，这里突出显示了与OneDGrid之间的差异:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">size_t</span> N&gt;</span><br><span class="line">NDGrid&lt;T, N&gt;::NDGrid(<span class="keyword">size_t</span> size) &#123;</span><br><span class="line">    resize(size);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">void</span> NDGrid&lt;T, N&gt;::resize(<span class="keyword">size_t</span> newSize) &#123;</span><br><span class="line">    mElements.resize(newSize);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; element : mElements) </span><br><span class="line">        element.resize(newSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">size_t</span> N&gt;</span><br><span class="line">NDGrid&lt;T, N<span class="number">-1</span>&gt;&amp; NDGrid&lt;T, N&gt;::<span class="keyword">operator</span>[](<span class="keyword">size_t</span> x) &#123;</span><br><span class="line">    <span class="keyword">return</span> mElements[x];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面是部分特例化的实现(基本情形)。请注意，必须重写很多代码，因为不能在特例化中继承任何实现。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">NDGrid&lt;T, <span class="number">1</span>&gt;::NDGrid(<span class="keyword">size_t</span> size) &#123;</span><br><span class="line">    resize(size);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> NDGrid&lt;T, <span class="number">1</span>&gt;::resize(<span class="keyword">size_t</span> newSize) &#123;</span><br><span class="line">    mElements.resize (newSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T&amp; NDGrid&lt;T, <span class="number">1</span>&gt;::<span class="keyword">operator</span>[](<span class="keyword">size_t</span> x) &#123;</span><br><span class="line">    <span class="keyword">return</span> mElements[x];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在，可编写下面这样的代码:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NDGrid&lt;<span class="keyword">int</span>, <span class="number">3</span>&gt; my3DGrid;</span><br><span class="line">my3DGrid[<span class="number">2</span>][<span class="number">1</span>][<span class="number">2</span>] = <span class="number">5</span>;</span><br><span class="line">my3DGrid[<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>] = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; my3DGrid[<span class="number">2</span>][<span class="number">1</span>](<span class="number">2</span>]&lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p>
<h2 id="可变参数模板"><a href="#可变参数模板" class="headerlink" title="可变参数模板"></a>可变参数模板</h2><p>普通模板只可采取固定数量的模板参数。可变参数模板(variadic template)可接收可变数目的模板参数。例如，下面的代码定义了一个模板，它可以接收任何数目的模板参数，使用称为Types的参数包(parameter pack)：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Types&gt;</span><br><span class="line">Class MyVarladicTemplate &#123; &#125;;</span><br></pre></td></tr></table></figure></p>
<p>可用任何数量的类型实例化MyVariadicTemplate，例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyVariadicTemplate&lt;<span class="keyword">int</span>&gt; instancel;</span><br><span class="line">MyVariadicTemplate&lt;<span class="built_in">string</span>, <span class="keyword">double</span>, <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;&gt;instance2;</span><br></pre></td></tr></table></figure></p>
<p>甚至可用零个模板参数实例化:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyVariadicTemplate&lt;&gt; instance3;</span><br></pre></td></tr></table></figure></p>
<p>为避免用零个模板参数实例化可变参数模板，可以像下面这样编写模板:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span>... Types&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyVariadicTemplate</span> &#123;</span> &#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="类型安全的变长参数列表"><a href="#类型安全的变长参数列表" class="headerlink" title="类型安全的变长参数列表"></a>类型安全的变长参数列表</h3><p>可变参数模板允许创建类型安全的变长参数列表。下面的例子定义了一个可变参数模板<code>processValues()</code>，它允许以类型安全的方式接收不同类型的可变数目的参数。函数<code>processValues()</code>会处理变长参数列表中的每个值，对每个参数执行<code>handleValue()</code>函数。 这意味着必须对每种要处理的类型编写<code>handleValue()</code>函数，例如下例中的int、double和string:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handleValue</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt;<span class="string">"Integer: "</span> &lt;&lt; value &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handleValue</span><span class="params">(<span class="keyword">double</span> value)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Double: "</span> &lt;&lt; value &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handleValue</span><span class="params">(string_view value)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; value &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processValues</span><span class="params">()</span> </span>&#123; <span class="comment">/* Nothing to do in this base case.*/</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span>... Tn&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processValues</span><span class="params">(T1 arg1, Tn... args)</span> </span>&#123;</span><br><span class="line">    handleValue(arg1);</span><br><span class="line">    processValues(args...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在前面的例子中，三点运算符“…”用了两次。这个运算符出现在3个地方，有两个不同的含义。首先，用在模板参数列表中typename的后面以及函数参数列表中类型Tn的后面。在这两种情况下，它都表示参数包。参数包可接收可变数目的参数。</p>
<p>“…”运算符的第二种用法是在函数体中参数名args的后面。这种情况下，它表示参数包扩展。这个运算符会解包/展开参数包，得到各个参数。它基本上提取出运算符左边的内容，为包中的每个模板参数重复该内容，并用逗号隔开。从前面的例子中取出以下行:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">processValues (args...);</span><br></pre></td></tr></table></figure></p>
<p>这一行将args参数包解包(或扩展)为不同的参数，通过逗号分隔参数，然后用这些展开的参数调用<code>processValues()</code>函数。模板总是需要至少一个模板参数: T1。通过<code>args...</code>递归调用<code>processValues()</code>的结果是: 每次调用都会少一个模板参数。</p>
<p>由于<code>processValues()</code>函数的实现是递归的,因此需要采用一种方法来停止递归。为此,实现一个<code>processValues()</code>函数，要求它接收零个参数。可通过下面的代码来测试<code>processValues()</code>可变参数模板:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">processValues(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3.56</span>, <span class="string">"test"</span>, <span class="number">1.1f</span>);</span><br></pre></td></tr></table></figure></p>
<p>这个例子生成的递归调用是:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">processValues(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3.56</span>, <span class="string">"test"</span>, <span class="number">1.1f</span>);</span><br><span class="line">    handleValue(<span class="number">1</span>);</span><br><span class="line">    processValues(<span class="number">2</span>, <span class="number">3.56</span>, <span class="string">"test"</span>, <span class="number">1.1f</span>);</span><br><span class="line">        handleValue(<span class="number">2</span>);</span><br><span class="line">        processValues(<span class="number">3.56</span>, <span class="string">"test"</span>, <span class="number">1.1f</span>);</span><br><span class="line">    handleValue(<span class="number">3.56</span>);</span><br><span class="line">    processValues(<span class="string">"test"</span>, <span class="number">1.1f</span>);</span><br><span class="line">        handleValue(<span class="string">"test"</span>);</span><br><span class="line">        processValues(<span class="number">1.1f</span>);</span><br><span class="line">            handleValue(<span class="number">1.1f</span>);</span><br><span class="line">            processValues();</span><br></pre></td></tr></table></figure></p>
<p>重要的是要记住,这种变长参数列表是完全类型安全的。<code>processValues()</code>函数会根据实际类型自动调用正确的<code>handleValue()</code>重载版本。C++中也会像通常那样自动执行类型转换。然而，如果调用<code>processValues()</code>时带有某种类型的参数，而这种类型没有对应的<code>handleValue()</code>函数，编译器会产生错误。</p>
<p>为了在使用非const引用的同时也能使用字面量值，可使用转发引用(forwarding references)。以下实现使用了转发引用<code>T&amp;&amp;</code>，还使用<code>std::forward()</code>完美转发所有参数。“完美转发”意味着，如果把rvalue传递给<code>processValues()</code>，就将它作为ralue引用转发：如果把lvalue或lvalue引用传递给<code>processValues()</code>，就将它作为lvalue引用转发。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processValues</span><span class="params">()</span> </span>&#123;<span class="comment">/* Nothing to do in this base case.*/</span>&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span>... Tn&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processValues</span><span class="params">(T1&amp;&amp; arg1, Tn&amp;&amp;... args)</span> </span>&#123;</span><br><span class="line">    handleValue(<span class="built_in">std</span>::forward&lt;T1&gt; (arg1));</span><br><span class="line">    processValues(<span class="built_in">std</span>::forward&lt;Tn&gt;(args)...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>有一行代码需要做进一步解释:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">processValues(<span class="built_in">std</span>::forward&lt;Tn&gt; (args)...);</span><br></pre></td></tr></table></figure></p>
<p>“…”运算符用于解开参数包,它在参数包中的每个参数上使用<code>std::forward()</code>，用逗号把它们隔开。例如，假设args是一个参数包，有三个参数(al、a2和a3)，分别对应三种类型(A1、A2和A3)。扩展后的调用如下:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">processValues(<span class="built_in">std</span>::forward&lt;A1&gt;(a1), <span class="built_in">std</span>::forward&lt;A2&gt;(a2), <span class="built_in">std</span>::forward&lt;A3&gt;(a3));</span><br></pre></td></tr></table></figure></p>
<p>在使用了参数包的函数体中，可通过以下方法获得参数包中参数的个数:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> numOfArgs = <span class="keyword">sizeof</span>...(args);</span><br></pre></td></tr></table></figure></p>
<h3 id="折叠表达式"><a href="#折叠表达式" class="headerlink" title="折叠表达式"></a>折叠表达式</h3><p>C++17增加了对折叠表达式(folding expression)的支持。这样一来，将可更容易地在可变参数模板中处理参数包。下面分析一些示例。以递归方式定义前面的<code>processValues()</code>函数模板，如下所示:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processValues</span><span class="params">()</span></span>&#123;<span class="comment">/* Nothing to do in this base case.*/</span>&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span>... Tn&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ProcessValues</span><span class="params">(T1 arg1, Tn...args)</span> </span>&#123;</span><br><span class="line">    handleValue(arg1);</span><br><span class="line">    processValues(args...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由于以递归方式定义，因此需要基本情形来停止递归。使用折叠表达式，利用一元右折叠，通过单个函数模板来实现。此时，不需要基本情形：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Tn&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processvalues</span> <span class="params">(<span class="keyword">const</span> Tn&amp;... args)</span> </span>&#123;</span><br><span class="line">    (handleValue(args), ...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>基本上，函数体中的三个点触发折叠。扩展这一行，针对参数包中的每个参数调用<code>handleValue()</code>，对<code>handleValue()</code>的每个调用用逗号分隔。例如，假设args是包含三个参数(a1、a2和a3)的参数包。一元右折叠扩展后的形式如下:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(handleValue(a1), (handleValue(a2), handleValue(a3)));</span><br></pre></td></tr></table></figure></p>
<p>下面是另一个示例。<code>printValues()</code>函数模板将所有实参写入控制台，实参之间用换行符分开。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Values&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printValues</span> <span class="params">(<span class="keyword">const</span> Values&amp;... values)</span> </span>&#123;</span><br><span class="line">    ((<span class="built_in">cout</span> &lt;&lt; values &lt;&lt; <span class="built_in">endl</span>), ...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>假设values是包含三个参数(v1、v2和v3)的参数包。一元右折叠扩展后的形式如下:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((<span class="built_in">cout</span> &lt;&lt; v1 &lt;&lt; <span class="built_in">endl</span>), ((<span class="built_in">cout</span> &lt;&lt; v2 &lt;&lt; <span class="built_in">endl</span>), (<span class="built_in">cout</span> &lt;&lt; v3 &lt;&lt; <span class="built_in">endl</span>)));</span><br></pre></td></tr></table></figure></p>
<p>调用<code>printValues()</code>时可使用任意数量的实参，如下所示:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printValues(<span class="number">1</span>, <span class="string">"test"</span>, <span class="number">2.34</span>);</span><br></pre></td></tr></table></figure></p>
<h2 id="模板元编程"><a href="#模板元编程" class="headerlink" title="模板元编程"></a>模板元编程</h2><p>模板元编程的目标是在编译时而不是运行时执行一些计算。模板元编程基本上是基于C++的一种小型编程语言。下面首先讨论一个简单示例，这个例子在编译时计算一个数的阶乘，并在运行时能将计算结果用作简单的常数。</p>
<h3 id="编译时阶乘"><a href="#编译时阶乘" class="headerlink" title="编译时阶乘"></a>编译时阶乘</h3><p>下面的代码演示了在编译时如何计算一个数的阶乘。代码使用了本章前面介绍的模板递归，我们需要一个递归模板和用于停止递归的基本模板。根据数学定义，0的阶乘是1，所以用作基本情形:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span> f&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factorial</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> val = (f * Factorial&lt;f - <span class="number">1</span>&gt;::val);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factorial</span>&lt;0&gt; &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> val = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; Factorial&lt;<span class="number">6</span>&gt;::val &lt;&lt; enal;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这将计算6的阶乘，数学表达为6!，值为1x2x3x4x5x6或720。</p>
<p>上面这个具体示例在编译时计算一个数的阶乘，但未必需要使用模板元编程。由于引入了constexpr，可不使用模板，写成如下形式。不过，模板实现仍然是实现递归模板的优秀示例。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">factorial</span> <span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(f == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> f * factorial(f<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果调用如下版本，则在编译时计算值:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> f1 = factorial(<span class="number">6</span>);</span><br></pre></td></tr></table></figure></p>
<p>不过，在这条语句中，切勿忘掉constexpr。 如果编写如下代码，将在运行时完成计算!<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f1 = factorial(<span class="number">6</span>);</span><br></pre></td></tr></table></figure></p>
<p>在模板元编程版本中，不能犯此类错误。始终使计算在编译时完成。</p>
<h3 id="循环展开"><a href="#循环展开" class="headerlink" title="循环展开"></a>循环展开</h3><p>模板元编程的第二个例子是在编译时展开循环，而不是在运行时执行循环。注意循环展开(loop unrolling)应仅在需要时使用，因为编译器通常足够智能，会自动展开可以展开的循环。</p>
<p>这个例子再次使用了模板递归,因为需要在编译时在循环中完成一些事情。在每次递归中，Loop模板都会通过i-1实例化自身。当到达0时，停止递归。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> i&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Loop</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> FuncType&gt;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Do</span><span class="params">(FuncType func)</span> </span>&#123;</span><br><span class="line">        Loop&lt;i - <span class="number">1</span>&gt;::Do(func);</span><br><span class="line">        func(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Loop</span>&lt;0&gt; &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> FuncType&gt;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Do</span><span class="params">(FuncType <span class="comment">/* func*/</span>)</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>可以像下面这样使用Loop模板:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DoWork</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"DoWork("</span>&lt;&lt; i&lt;&lt;<span class="string">")"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Loop&lt;<span class="number">3</span>&gt;::Do(DoWork);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这段代码将导致编译器展开循环，并连续3次调用<code>DoWork()</code>函数。这个程序的输出如下所示:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DoWork(<span class="number">1</span>)</span><br><span class="line">DoWork(<span class="number">2</span>)</span><br><span class="line">DoWork(<span class="number">3</span>)</span><br></pre></td></tr></table></figure></p>
<p>使用lambda表达式，可使用接收多个参数的DoWork20版本:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DoWork2</span><span class="params">(<span class="built_in">string</span> str, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"DoWork2("</span>&lt;&lt; str &lt;&lt; <span class="string">", "</span> &lt;&lt; i &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Loop&lt;<span class="number">2</span>&gt;::Do([](<span class="keyword">int</span> i) &#123; DoWork2(<span class="string">"TestStr"</span>, i); &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述代码首先实现了一个函数，这个函数接收一个字符串和一个int值。<code>main()</code>函数使用lambda表达式，在每个迭代上将一个固定的字符串TestStr作为第一个参数调用DoWork20。编译并运行上述代码，输出应该如下所示:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DoWork2(TestStr, <span class="number">1</span>)</span><br><span class="line">DoWork2(TestStr, <span class="number">2</span>)</span><br></pre></td></tr></table></figure></p>
<h3 id="打印元组"><a href="#打印元组" class="headerlink" title="打印元组"></a>打印元组</h3><p>这个例子通过模板元编程来打印<code>std::tuple</code>中的各个元素。与模板元编程中的大部分情况一样，这个例子也使用了模板递归。<code>tuple_print</code>类模板接收两个模板参数：tuple类型和初始化为元组大小的整数。然后在构造函数中递归地实例化自身，每一次调用都将大小减小。当大小变成0时，<code>tuple_print</code>的一个部分特例化停止递归。<code>main()</code>函数演示了如何使用这个<code>tuple_print</code>类模板。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> TupleType, <span class="keyword">int</span> n&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">tuple_print</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    tuple_print (<span class="keyword">const</span> TupleType&amp; t) &#123;</span><br><span class="line">        tuple_print&lt;TupleType, n - <span class="number">1</span>&gt; tp(t);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; get&lt;n - <span class="number">1</span>&gt;(t) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> TupleType&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">tuple_print</span>&lt;TupleType, 0&gt; &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    tuple_print(<span class="keyword">const</span> TupleType&amp;) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> MyTuple = tuple&lt;<span class="keyword">int</span>, <span class="built_in">string</span>, <span class="keyword">bool</span>&gt;;</span><br><span class="line">    <span class="function">MyTuple <span class="title">t1</span><span class="params">(<span class="number">16</span>, <span class="string">"Test"</span>, <span class="literal">true</span>)</span></span>;</span><br><span class="line">    tuple_print&lt;MyTuple, tuple_size&lt;MyTuple&gt;::value&gt; tp(t1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="constexpr-if"><a href="#constexpr-if" class="headerlink" title="constexpr if"></a>constexpr if</h4><p>C++17引入了constexpr if。这些是在编译时(而非运行时)执行的if语句。如果constexpr if语句的分支从未到达，就不会进行编译。这可用于简化大量的模板元编程技术，也可用于本章后面讨论的SFINAE。</p>
<p>例如，可按如下方式使用constexpr if，简化前面的打印元组元素的代码。注意，不再需要模板递归基本情形，原因在于可通过constexpr if语句停止递归。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> TupleType, <span class="keyword">int</span> n&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">tuple_print_helper</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    tuple_print_helper (<span class="keyword">const</span> TupleTypes t) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span><span class="params">(n&gt;<span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">            tuple_print_helper&lt;TupleType, n - <span class="number">1</span>&gt;tp(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; get&lt;n - <span class="number">1</span>&gt;(t) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tuple_print</span><span class="params">(<span class="keyword">const</span> T&amp; t)</span> </span>&#123;</span><br><span class="line">    tuple_print_helper&lt;T, tuple_size&lt;T&gt;::value&gt;tph(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在，甚至可丢弃类模板本身，替换为简单的函数模板<code>tuple_print_helper</code>:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> TupleType, <span class="keyword">int</span> n&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tuple_print_helper</span> <span class="params">(<span class="keyword">const</span> TupleType&amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span><span class="params">(n&gt;<span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">        tuple_print_helper&lt;TupleType, n - <span class="number">1</span>&gt;(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; get&lt;n - <span class="number">1</span>&gt;(t) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tuple_print</span> <span class="params">(<span class="keyword">const</span> T&amp; t)</span> </span>&#123;</span><br><span class="line">    tuple_print_helper&lt;T, tuple_size&lt;T&gt;::value&gt;(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可对其进一步简化。将两个方法合为一个，如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> TupleType, <span class="keyword">int</span> n = tuple_size&lt;TupleType&gt;::value&gt;</span><br><span class="line"><span class="keyword">void</span> tuple_print(<span class="keyword">const</span> TupleType&amp; t) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">constexpr</span>(n &gt; <span class="number">1</span>)</span><br><span class="line">        tuple_print&lt;TupleType, n - <span class="number">1</span>&gt;(t);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; get&lt;n - <span class="number">1</span>&gt;(t) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>仍然像前面那样进行调用:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> t1 = make_tuple(<span class="number">167</span>, <span class="string">"Testing"</span>, <span class="literal">false</span>, <span class="number">2.3</span>);</span><br><span class="line">tuple_print(t1);</span><br></pre></td></tr></table></figure></p>
<h4 id="使用编译时整数序列和折叠"><a href="#使用编译时整数序列和折叠" class="headerlink" title="使用编译时整数序列和折叠"></a>使用编译时整数序列和折叠</h4><p>C++使用<code>std::integer_sequence</code>(在<code>&lt;utility&gt;</code>中定义)支持编译时整数序列。模板元编程的一个常见用例是生成编译时索引序列，即<code>size_t</code>类型的整数序列。此处，可使用辅助用的<code>std::index_sequence</code>。可使用<code>std::index_sequence_for</code>生成与给定的参数包等长的索引序列。</p>
<p>下面使用可变参数模板、编译时索引序列和C++17折叠表达式，实现元组打印程序:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Tuple, <span class="keyword">size_t</span>... Indices&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tuple_print_helper</span><span class="params">(<span class="keyword">const</span> Tuple&amp; t, index_sequence&lt;Indices...&gt;)</span> </span>&#123;</span><br><span class="line">    ((<span class="built_in">cout</span> &lt;&lt; get&lt;Indices&gt;(t) &lt;&lt; <span class="built_in">endl</span>), ...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tuple_print</span> <span class="params">(<span class="keyword">const</span> tuple&lt;Args...&gt;&amp; t)</span> </span>&#123;</span><br><span class="line">    tuple_print_helper(t, index_sequence_for&lt;Args...&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可按与前面相同的方式调用:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> t1 = make_tuple(<span class="number">167</span>, <span class="string">"Testing"</span>, <span class="literal">false</span>, <span class="number">2.3</span>);</span><br><span class="line">tuple_print(t1);</span><br></pre></td></tr></table></figure></p>
<p>调用时，<code>tuple_print_helper()</code>函数模板中的一元右折叠表达式扩展为如下形式:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(((<span class="built_in">cout</span> &lt;&lt; get&lt;<span class="number">0</span>&gt;(t) &lt;&lt; <span class="built_in">endl</span>),</span><br><span class="line"> ((<span class="built_in">cout</span> &lt;&lt; get&lt;<span class="number">1</span>&gt;(t) &lt;&lt; <span class="built_in">endl</span>),</span><br><span class="line"> ((<span class="built_in">cout</span> &lt;&lt; get&lt;<span class="number">2</span>&gt;(t) &lt;&lt; <span class="built_in">endl</span>),</span><br><span class="line">  (<span class="built_in">cout</span> &lt;&lt; get&lt;<span class="number">3</span>&gt;(t) &lt;&lt; <span class="built_in">endl</span>)))));</span><br></pre></td></tr></table></figure></p>
<h3 id="类型trait"><a href="#类型trait" class="headerlink" title="类型trait"></a>类型trait</h3><p>通过类型trait可在编译时根据类型做出决策。例如，可编写一个模板，这个模板要求从某种特定类型派生的类型，或者要求可转换为某种特定类型的类型，或者要求整数类型，等等。C++标准为此定义了一些辅助类。所有与类型trait相关的功能都定义在<code>&lt;type_traits&gt;</code>头文件中。类型trait分为几个不同类别。下面列出了每个类别的可用类型trait的一些例子。<br><img src="/img/20210509152400.png" alt></p>
<h4 id="使用类型类别"><a href="#使用类型类别" class="headerlink" title="使用类型类别"></a>使用类型类别</h4><p>在给出使用类型trait的模板示例前，首先要了解一下诸如<code>is_integral</code>的类的工作方式。C++标准对<code>integral_constant</code>类的定义如下所示:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">T</span> <span class="title">v</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">integral_constant</span> &#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> T value = v;</span><br><span class="line">    <span class="keyword">using</span> value_type = T;</span><br><span class="line">    <span class="keyword">using</span> type = integral_constant&lt;T,v&gt;;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="keyword">operator</span> <span class="title">value_type</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> value_type <span class="title">operator</span><span class="params">()</span> <span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这也定义了<code>bool_constant</code>、<code>true_type</code>和<code>false_type</code>类型别名:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> B&gt;</span><br><span class="line"><span class="keyword">using</span> bool_constant = integral_constant&lt;<span class="keyword">bool</span>,B&gt;;</span><br><span class="line"><span class="keyword">using</span> true_type = bool_constant&lt;<span class="literal">true</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> false_type = bool_constant&lt;<span class="literal">false</span>&gt;;</span><br></pre></td></tr></table></figure></p>
<p>这定义了两种类型：<code>true_type</code>和<code>false_type</code>。当调用<code>true_type::value</code>时，得到的值是true；调用<code>false_type::value</code>时，得到的值是false。还可调用<code>true_type::type</code>。这将返回<code>true_type</code>类型。这同样适用于<code>false_type</code>。诸如<code>is_integral</code>和<code>is_class</code>的类继承了<code>true_type</code>或<code>false_type</code>。例如，<code>is_integral</code>为类型bool特例化，如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="class"><span class="keyword">struct</span> <span class="title">is_integral</span>&lt;bool&gt; :</span> <span class="keyword">public</span> true_type &#123; &#125;;</span><br></pre></td></tr></table></figure></p>
<p>这样就可编写<code>is_integral&lt;bool&gt;::value</code>，并返回true。注意，不需要自己编写这些特例化，这些是标准库的部分。下面的代码演示了使用类型类别的最简单例子:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (is_integral&lt;<span class="keyword">int</span>&gt;::value)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="string">"int is integral"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"int is not integral"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">if</span> (is_class&lt;<span class="built_in">string</span>&gt;::value)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"string is a class"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"string is not a class"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p>
<p>这个例子通过<code>is_integral</code>来检查int是否为整数类型，并通过<code>is_class</code>来检查string是否为类。输出如下:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> is integral</span><br><span class="line"><span class="built_in">string</span> is a <span class="class"><span class="keyword">class</span></span></span><br></pre></td></tr></table></figure></p>
<p>对于每一个具有value成员的trait，C++17添加了一个变量模板，它与trait同名，后跟<code>_v</code>。不是编写<code>some_trait&lt;T&gt;::value</code>，而是编写<code>some_trait_v&lt;T&gt;</code>，例如<code>is_integral_v&lt;T&gt;</code>和<code>is_const_v&lt;T&gt;</code>等。 下面用变量模板重写了前面的例子:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (is_integral_v&lt;<span class="keyword">int</span>&gt;)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="string">"int is integral"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="string">"int is not integral"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">if</span>(is_class_v&lt;<span class="built_in">string</span>&gt;)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="string">"string is a class"</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="string">"string is not a class"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p>
<p>只有结合模板根据类型的某些属性生成代码时，类型trait才更有用。下面的模板示例演示了这一点。代码定义了函数模板<code>process_helper()</code>两个重载版本，这个函数模板接收一种类型作为模板参数。第一个参数是一个值，第二个参数是<code>true_type</code>或<code>false_type</code>的实例。<code>process()</code>函数模板接收一个参数，并调用<code>process_helper()</code>函数:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process_helper</span><span class="params">(<span class="keyword">const</span> T&amp; t, true_type)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; t &lt;&lt;<span class="string">" is an integral type."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process_helper</span> <span class="params">(<span class="keyword">const</span> T&amp; t, talse_type)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; t &lt;&lt;<span class="string">"is a non-integral type."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process</span> <span class="params">(<span class="keyword">const</span> T&amp; t)</span> </span>&#123;</span><br><span class="line">    process_helper(t, <span class="keyword">typename</span> is_integral&lt;T&gt;::type());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>process_helper()</code>函数调用的第二个参数定义如下:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typename</span> is_integral&lt;T&gt;::type()</span><br></pre></td></tr></table></figure></p>
<p>该参数使用<code>is_integral</code>判断T是否为整数类型。使用<code>::type</code>访问结果<code>integral_constant</code>类型，可以是<code>true_type</code>或<code>false_type</code>。<code>process_helper()</code>函数需要<code>true_type</code>或<code>false_type</code>的一个实例作为第二个参数，这也是为什么<code>::type</code>后面有两个空括号的原因。注意，<code>process_helper()</code>函数的两个重载版本使用了类型为<code>true_type</code>或<code>false_type</code>的无名参数。因为在函数体的内部没有使用这些参数，所以这些参数是无名的。这些参数仅用于函数重载解析。</p>
<p>这些代码的测试如下:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">process(<span class="number">123</span>);</span><br><span class="line">process(<span class="number">2.2</span>);</span><br><span class="line">process(<span class="string">"Test"</span>s);</span><br></pre></td></tr></table></figure></p>
<p>这个例子的输出如下:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">123</span> is an integral type,</span><br><span class="line"><span class="number">2.2</span> is a non-integral type.</span><br><span class="line">Test is a non-integral type</span><br></pre></td></tr></table></figure></p>
<p>前面的例子只使用单个函数模板来编写，但没有说明如何使用类型trait，以基于类型选择不同的重载。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process</span> <span class="params">(<span class="keyword">const</span> T&amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(is_integral_v&lt;T&gt;)</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;it &lt;&lt;<span class="string">" is an integral type."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt;t &lt;&lt;<span class="string">"is a non-integral type."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="使用类型关系"><a href="#使用类型关系" class="headerlink" title="使用类型关系"></a>使用类型关系</h4><p>有三种类型关系：<code>is_same</code>，<code>is_base_of</code>和<code>is_convertible</code>。下面将给出一个例子来展示如何使用<code>is_same</code>。其余类型关系的工作原理类似。下面的<code>same()</code>函数模板通过<code>is_same</code>类型trait特性判断两个给定参数是否类型相同，然后输出相应的信息。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">same</span> <span class="params">(<span class="keyword">const</span> T1&amp; t1, <span class="keyword">const</span> T2&amp; t2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> areTypesTheSame = is_same_v&lt;T1,T2&gt;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"'"</span> &lt;&lt; t1 &lt;&lt; <span class="string">"' and '"</span> &lt;&lt; t2 &lt;&lt; <span class="string">"' are '"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (areTypesTheSame ? <span class="string">"the same types."</span> : <span class="string">"different types."</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    same(<span class="number">1</span>, <span class="number">32</span>);</span><br><span class="line">    same(<span class="number">1</span>, <span class="number">3.01</span>);</span><br><span class="line">    same(<span class="number">3.01</span>, <span class="string">"Test"</span>s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出如下所示:<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">'1' and '32' are the same types.</span><br><span class="line">'1’ and '3.01' are different types</span><br><span class="line">'3.01' and 'Test' are different types</span><br></pre></td></tr></table></figure></p>
<h4 id="使用enable-if"><a href="#使用enable-if" class="headerlink" title="使用enable_if"></a>使用enable_if</h4><p>使用<code>enable_if</code>需要了解“替换失败不是错误”SFINAE特性，这是C++中一个复杂晦涩的特性。下面仅讲解SFINAE的基础知识。</p>
<p>如果有一组重载函数，就可以使用<code>enable_if</code>根据某些类型特性有选择地禁用某些重载。<code>enable_if</code>通常用于重载函数组的返回类型。<code>enable_if</code>接收两个模板类型参数。第一个参数是布尔值，第二个参数是默认为void的类型。如果布尔值是true，<code>enable_if</code>类就有一种可使用<code>::type</code>访问的嵌套类型，这种嵌套类型由第二个模板类型参数给定。如果布尔值是false，就没有嵌套类型。</p>
<p>C++标准为具有type成员的trait(如<code>enable_if</code>)定义别名模板，这些与trait同名，但附加了<code>_t</code>。例如，不编写如下代码:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typename</span> enable_if&lt;...,<span class="keyword">bool</span>&gt;::type</span><br></pre></td></tr></table></figure></p>
<p>而编写如下更简短的版本:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enable_if_t</span>&lt;..., <span class="keyword">bool</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>通过<code>enable_if</code>，可将前面使用<code>same()</code>函数模板的例子重写为一个重载的<code>check_type()</code>函数模板。在这个版本中，<code>check_type()</code>函数根据给定值的类型是否相同， 返回true或false。如果不希望<code>check_type()</code>返回任何内容，可删除return语句，可删除<code>enable_if</code>的第二个模板类型参数，或用void替换。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="keyword">enable_if_t</span>&lt;is_same_v&lt;T1, T2&gt;, <span class="keyword">bool</span>&gt;</span><br><span class="line">check_type (<span class="keyword">const</span> T1&amp; t1, <span class="keyword">const</span> T2&amp; t2) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"'"</span> &lt;&lt; t1 &lt;&lt; <span class="string">"' and '"</span> &lt;&lt; t2 &lt;&lt; <span class="string">"' "</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"are the same types."</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="keyword">enable_if_t</span>&lt;!is_same_v&lt;T1，T2&gt;， <span class="keyword">bool</span>&gt;</span><br><span class="line">check_type (<span class="keyword">const</span> T1&amp; t1, <span class="keyword">const</span> T2&amp; t2) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"'"</span> &lt;&lt; t1 &lt;&lt; <span class="string">"' and '"</span> &lt;&lt; t2 &lt;&lt;<span class="string">"' "</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"are different types."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    check_type(<span class="number">1</span>, <span class="number">32</span>);</span><br><span class="line">    check_type(<span class="number">1</span>, <span class="number">3.01</span>);</span><br><span class="line">    check_type(<span class="number">3.01</span>, <span class="string">"Test"</span>s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出与前面的相同。</p>
<p>上述代码定义了两个版本的<code>check_type()</code>，它们的返回类型都是<code>enable_if</code>的嵌套类型bool。首先，通过<code>is_same_v</code>检查两种类型是否相同，然后通过<code>enable_if_t获得结果。当enable_if_t</code>的第一个参数为true时，<code>enable_if_t</code>的类型就是bool；当第一个参数为false时， 将不会有返回类型。这就是SFINAE发挥作用的地方。</p>
<p>当编译器开始编译<code>main()</code>函数的第一行时，它试图找到接收两个整型值的<code>check_type()</code>函数。编译器会在源代码中找到第一个重载的<code>check_type()</code>函数模板，并将T1和T2都设置为整数，以推断可使用这个模板的实例。然后，编译器会尝试确定返回类型。由于这两个参数是整数，因此是相同的类型，<code>is_same_v&lt;T1,T2&gt;</code>将返回true，这导致<code>enable_if_t&lt;true, bool&gt;</code>返回类型bool。这样实例化时一切都很好，编译器可使用该版本的<code>check_type()</code>。</p>
<p>然而，当编译器尝试编译<code>main()</code>函数的第二行时，编译器会再次尝试找到合适的<code>check_type()</code>函数。编译器从第一个<code>check_type()</code>开始， 判断出可将T1设置为int类型，将T2设置为double类型。然后，编译器会尝试确定返回类型。这一次，T1和T2是不同的类型，这意味着<code>is_same_v&lt;T1,T2&gt;</code>将返回false。因此<code>enable_if_t&lt;false,bool&gt;</code>不表示类型，<code>check_type()</code>函数不会有返回类型。编译器会注意到这个错误，但由于SFINAE，还不会产生真正的编译错误。编译器将正常回溯，并试图找到另一个<code>check_type()</code>函数。这种情况下，第二个<code>check_type()</code>可以正常工作，因为<code>!is_same_v&lt;T1,T2&gt;</code>为true，此时<code>enable_if_t&lt;true,bool&gt;</code>返回类型bool。</p>
<p>如果希望在一组构造函数上使用<code>enable_if</code>，就不能将它用于返回类型，因为构造函数没有返回类型。此时可在带默认值的额外构造函数参数上使用<code>enable_if</code>。</p>
<h4 id="使用constexpr-if简化enable-if结构"><a href="#使用constexpr-if简化enable-if结构" class="headerlink" title="使用constexpr if简化enable_if结构"></a>使用constexpr if简化enable_if结构</h4><p>从前面的示例可以看到，使用enable_if将十分复杂。某些情况下，C++17引入的constexpr if特性有助于极大地简化enable_if。例如，假设有以下两个类：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IsDoable</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doit</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"IsDoable::doit()"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> IsDoable &#123; &#125;;</span><br></pre></td></tr></table></figure></p>
<p>可创建一个函数模板<code>call_doit()</code>。如果方法可用，它调用<code>doit()</code>方法；否则在控制台上打印错误消息。为此，可使用<code>enable_if</code>，检查给定类型是否从IsDoable派生:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">enable_if_t</span>&lt;is_base_of_v&lt;IsDoable, T&gt;,<span class="keyword">void</span>&gt;</span><br><span class="line">call_doit (<span class="keyword">const</span> T&amp; T) &#123;</span><br><span class="line">    t.doit();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T:</span><br><span class="line"><span class="keyword">enable_if_t</span>&lt;!is_base_of_v&lt;IsDoable, T&gt;, <span class="keyword">void</span>&gt;</span><br><span class="line">call_doit (<span class="keyword">const</span> T&amp;) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Cannot call doit()!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面的代码对该实现进行测试:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Derived d;</span><br><span class="line">call_doit(d);</span><br><span class="line">call_doit(<span class="number">123</span>);</span><br></pre></td></tr></table></figure></p>
<p>输出如下:<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IsDoable::doit()</span><br><span class="line">Cannot call doit()!</span><br></pre></td></tr></table></figure></p>
<p>使用C++17的constexpr if可极大地简化enable_if实现:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">call_doit</span><span class="params">(<span class="keyword">const</span> T&amp;  [[maybe_unused]] t)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span><span class="params">(is_base_of_v&lt;IsDoable, T&gt;)</span></span>&#123;</span><br><span class="line">        t.doit();</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Cannot call doit()!"</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>无法使用普通if语句做到这一点!使用普通if语句，两个分支都需要编译，而如果指定并非从IsDoable派生的类型T，这将失败。此时，<code>t.doit()</code>一行无法编译。但是，使用constexpr if语句，如果提供了并非从IsDoable派生的类型，<code>t.doit()</code>一行甚至不会编译!</p>
<p>不使用<code>is_base_of</code>类型trait，也可使用C++17新引入的<code>is_invocable</code>trait，这个trait可用于确定在调用给定函数时是否可以使用一组给定的参数。下面是使用<code>is_invocable</code> trait的<code>call_doit()</code>实现:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">call_doit</span> <span class="params">(<span class="keyword">const</span> T&amp; [[maybe_unused]] t)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(is_invocable_v&lt;<span class="keyword">decltype</span> (<span class="number">6</span>IsDoable::doit)，T&gt;)</span></span>&#123;</span><br><span class="line">        t.doit();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Cannot call doit()!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="逻辑运算符trait"><a href="#逻辑运算符trait" class="headerlink" title="逻辑运算符trait"></a>逻辑运算符trait</h4><p>在三种逻辑运算符trait：串联(conjunction)、分离(disjunction)与否定(negation)。以<code>_v</code>结尾的可变模板也可供使用。这些trait接收可变数量的模板类型参数，可用于在类型trait上执行逻辑操作，如下所示:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; conjunction_v&lt;is_integral&lt;<span class="keyword">int</span>&gt;, is_integral&lt;<span class="keyword">short</span>&gt;&gt; &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; conjunction_v&lt;is_integral&lt;<span class="keyword">int</span>&gt;, is_integra1&lt;<span class="keyword">double</span>&gt;&gt; &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; disjunction_v&lt;is_integral&lt;<span class="keyword">int</span>&gt;, is_integral&lt;<span class="keyword">double</span>&gt;, is_integral&lt;<span class="keyword">short</span>&gt;&gt; &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; negation_v&lt;is_integral&lt;<span class="keyword">int</span>&gt;&gt; &lt;&lt; <span class="string">" "</span>;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/C/" rel="tag"># C++</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/05/07/cpp高级编程 笔记5/" rel="next" title="C++高级编程 第四版 笔记5">
                <i class="fa fa-chevron-left"></i> C++高级编程 第四版 笔记5
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/05/09/cpp高级编程 笔记8/" rel="prev" title="C++高级编程 第四版 笔记8">
                C++高级编程 第四版 笔记8 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/header.jpg" alt="Hao Yu">
            
              <p class="site-author-name" itemprop="name">Hao Yu</p>
              <p class="site-description motion-element" itemprop="description">Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author</p>
          </div>
          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">300</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>
        	<audio controls="controls" loop="loop" preload="auto" src="/resource/xiaomeihao.mp3">
	        </audio>
	

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yuhao0102" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:yuh18@mails.tsinghua.edu.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#其他库工具"><span class="nav-number">1.</span> <span class="nav-text">其他库工具</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#ratio库"><span class="nav-number">1.1.</span> <span class="nav-text">ratio库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#chrono库"><span class="nav-number">1.2.</span> <span class="nav-text">chrono库</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#持续时间"><span class="nav-number">1.2.1.</span> <span class="nav-text">持续时间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#时钟"><span class="nav-number">1.2.2.</span> <span class="nav-text">时钟</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#时点"><span class="nav-number">1.2.3.</span> <span class="nav-text">时点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#生成随机数"><span class="nav-number">1.3.</span> <span class="nav-text">生成随机数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#随机数引擎"><span class="nav-number">1.3.1.</span> <span class="nav-text">随机数引擎</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#optional"><span class="nav-number">1.4.</span> <span class="nav-text">optional</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#variant"><span class="nav-number">1.5.</span> <span class="nav-text">variant</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#any"><span class="nav-number">1.6.</span> <span class="nav-text">any</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#元组"><span class="nav-number">1.7.</span> <span class="nav-text">元组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#分解元组"><span class="nav-number">1.7.1.</span> <span class="nav-text">分解元组</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#结构化绑定"><span class="nav-number">1.7.1.1.</span> <span class="nav-text">结构化绑定</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#tie"><span class="nav-number">1.7.1.2.</span> <span class="nav-text">tie()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#串联"><span class="nav-number">1.7.2.</span> <span class="nav-text">串联</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#比较"><span class="nav-number">1.7.3.</span> <span class="nav-text">比较</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#make-from-tuple"><span class="nav-number">1.7.4.</span> <span class="nav-text">make_from_tuple()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#apply"><span class="nav-number">1.7.5.</span> <span class="nav-text">apply()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件系统支持库"><span class="nav-number">1.8.</span> <span class="nav-text">文件系统支持库</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#path"><span class="nav-number">1.8.1.</span> <span class="nav-text">path</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#directory-entry"><span class="nav-number">1.8.2.</span> <span class="nav-text">directory_entry</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#辅助函数"><span class="nav-number">1.8.3.</span> <span class="nav-text">辅助函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#目录迭代"><span class="nav-number">1.8.4.</span> <span class="nav-text">目录迭代</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#自定义和扩展标准库"><span class="nav-number">2.</span> <span class="nav-text">自定义和扩展标准库</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#分配器"><span class="nav-number">2.1.</span> <span class="nav-text">分配器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#流适配器"><span class="nav-number">2.2.</span> <span class="nav-text">流适配器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#输出流迭代器"><span class="nav-number">2.2.1.</span> <span class="nav-text">输出流迭代器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#输入流迭代器"><span class="nav-number">2.2.2.</span> <span class="nav-text">输入流迭代器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#迭代器适配器"><span class="nav-number">2.3.</span> <span class="nav-text">迭代器适配器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#反向迭代器"><span class="nav-number">2.3.1.</span> <span class="nav-text">反向迭代器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#插入迭代器"><span class="nav-number">2.3.2.</span> <span class="nav-text">插入迭代器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#移动迭代器"><span class="nav-number">2.3.3.</span> <span class="nav-text">移动迭代器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#扩展标准库"><span class="nav-number">2.4.</span> <span class="nav-text">扩展标准库</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#编写标准库算法"><span class="nav-number">2.4.1.</span> <span class="nav-text">编写标准库算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#find-all"><span class="nav-number">2.4.1.1.</span> <span class="nav-text">find_all()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#iterator-traits"><span class="nav-number">2.4.1.2.</span> <span class="nav-text">iterator_traits</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#高级模板"><span class="nav-number">3.</span> <span class="nav-text">高级模板</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#深入了解模板参数"><span class="nav-number">3.1.</span> <span class="nav-text">深入了解模板参数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#深入了解模板类型参数"><span class="nav-number">3.1.1.</span> <span class="nav-text">深入了解模板类型参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#template-template参数介绍"><span class="nav-number">3.1.2.</span> <span class="nav-text">template template参数介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#深入了解非类型模板参数"><span class="nav-number">3.1.3.</span> <span class="nav-text">深入了解非类型模板参数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#模板类部分特例化"><span class="nav-number">3.2.</span> <span class="nav-text">模板类部分特例化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#通过重载模拟函数部分特例化"><span class="nav-number">3.3.</span> <span class="nav-text">通过重载模拟函数部分特例化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#模板递归"><span class="nav-number">3.4.</span> <span class="nav-text">模板递归</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#N维网格-初次尝试"><span class="nav-number">3.4.1.</span> <span class="nav-text">N维网格:初次尝试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#真正的N维网格"><span class="nav-number">3.4.2.</span> <span class="nav-text">真正的N维网格</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#可变参数模板"><span class="nav-number">3.5.</span> <span class="nav-text">可变参数模板</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#类型安全的变长参数列表"><span class="nav-number">3.5.1.</span> <span class="nav-text">类型安全的变长参数列表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#折叠表达式"><span class="nav-number">3.5.2.</span> <span class="nav-text">折叠表达式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#模板元编程"><span class="nav-number">3.6.</span> <span class="nav-text">模板元编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#编译时阶乘"><span class="nav-number">3.6.1.</span> <span class="nav-text">编译时阶乘</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#循环展开"><span class="nav-number">3.6.2.</span> <span class="nav-text">循环展开</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#打印元组"><span class="nav-number">3.6.3.</span> <span class="nav-text">打印元组</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#constexpr-if"><span class="nav-number">3.6.3.1.</span> <span class="nav-text">constexpr if</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用编译时整数序列和折叠"><span class="nav-number">3.6.3.2.</span> <span class="nav-text">使用编译时整数序列和折叠</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类型trait"><span class="nav-number">3.6.4.</span> <span class="nav-text">类型trait</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#使用类型类别"><span class="nav-number">3.6.4.1.</span> <span class="nav-text">使用类型类别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用类型关系"><span class="nav-number">3.6.4.2.</span> <span class="nav-text">使用类型关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用enable-if"><span class="nav-number">3.6.4.3.</span> <span class="nav-text">使用enable_if</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用constexpr-if简化enable-if结构"><span class="nav-number">3.6.4.4.</span> <span class="nav-text">使用constexpr if简化enable_if结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#逻辑运算符trait"><span class="nav-number">3.6.4.5.</span> <span class="nav-text">逻辑运算符trait</span></a></li></ol></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>
  <div id="DvelopmentTarget">     
  </div>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart" aria-hidden="false"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>

  
</div>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_uv"> 
  本站访客数<span id="busuanzi_value_site_uv"></span>人次
</span>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  


  

  


  <script type="text/javascript" src="/js/src/love.js"></script>

</body>
</html>
