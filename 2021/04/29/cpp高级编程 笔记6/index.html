<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zn-ch">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-center-simple.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="C++,">










<meta name="description" content="掌握标准库算法算法概述算法把迭代器作为中介操作容器，而不直接操作容器本身。这样，算法没有绑定至特定的容器实现。所有标准库算法都实现为函数模板的形式，其中模板类型参数一般都是迭代器类型。将迭代器本身指定为函数的参数。大部分算法都定义在&amp;lt;algorithm&amp;gt;头文件中，一些数值算法定义在&amp;lt;numeric&amp;gt;头文件中。它们都在std名称空间中 find()和find_if()算法fi">
<meta name="keywords" content="C++">
<meta property="og:type" content="article">
<meta property="og:title" content="C++高级编程 第四版 笔记6">
<meta property="og:url" content="http://yoursite.com/2021/04/29/cpp高级编程 笔记6/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="掌握标准库算法算法概述算法把迭代器作为中介操作容器，而不直接操作容器本身。这样，算法没有绑定至特定的容器实现。所有标准库算法都实现为函数模板的形式，其中模板类型参数一般都是迭代器类型。将迭代器本身指定为函数的参数。大部分算法都定义在&amp;lt;algorithm&amp;gt;头文件中，一些数值算法定义在&amp;lt;numeric&amp;gt;头文件中。它们都在std名称空间中 find()和find_if()算法fi">
<meta property="og:locale" content="zn-ch">
<meta property="og:image" content="http://yoursite.com/img/1620376467.jpg">
<meta property="og:updated_time" content="2021-05-13T03:07:12.243Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="C++高级编程 第四版 笔记6">
<meta name="twitter:description" content="掌握标准库算法算法概述算法把迭代器作为中介操作容器，而不直接操作容器本身。这样，算法没有绑定至特定的容器实现。所有标准库算法都实现为函数模板的形式，其中模板类型参数一般都是迭代器类型。将迭代器本身指定为函数的参数。大部分算法都定义在&amp;lt;algorithm&amp;gt;头文件中，一些数值算法定义在&amp;lt;numeric&amp;gt;头文件中。它们都在std名称空间中 find()和find_if()算法fi">
<meta name="twitter:image" content="http://yoursite.com/img/1620376467.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2021/04/29/cpp高级编程 笔记6/">





  <title>C++高级编程 第四版 笔记6 | Hao Yu's blog</title>
  








 
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zn-ch">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hao Yu's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">The program monkey was eaten by the siege lion.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/resume.pdf" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-mybetterhalf">
          <a href="/mybetterhalf/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>
            
            mybetterhalf
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/04/29/cpp高级编程 笔记6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">C++高级编程 第四版 笔记6</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-04-29T15:39:40+08:00">
                2021-04-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="掌握标准库算法"><a href="#掌握标准库算法" class="headerlink" title="掌握标准库算法"></a>掌握标准库算法</h1><h2 id="算法概述"><a href="#算法概述" class="headerlink" title="算法概述"></a>算法概述</h2><p>算法把迭代器作为中介操作容器，而不直接操作容器本身。这样，算法没有绑定至特定的容器实现。所有标准库算法都实现为函数模板的形式，其中模板类型参数一般都是迭代器类型。将迭代器本身指定为函数的参数。大部分算法都定义在<code>&lt;algorithm&gt;</code>头文件中，一些数值算法定义在<code>&lt;numeric&gt;</code>头文件中。它们都在std名称空间中</p>
<h3 id="find-和find-if-算法"><a href="#find-和find-if-算法" class="headerlink" title="find()和find_if()算法"></a>find()和find_if()算法</h3><p><code>find()</code>在某个迭代器范围内查找特定元素。可将其用于任意容器类型的元素。这个算法返回引用所找到元素的迭代器；如果没有找到元素，则返回迭代器范围的尾迭代器。注意调用<code>find()</code>时指定的范围不要求是容器中元素的完整范围，还可以是元素的子集。</p>
<blockquote>
<p>如果<code>find()</code>没有找到元素，那么返回的迭代器等于函数调用中指定的尾迭代器，而不是底层容器的尾迭代器</p>
</blockquote>
<p>下面是一个<code>std::find()</code>示例。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="string">"Enter a number to lookup (0 to stop):"</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; num;</span><br><span class="line">    <span class="keyword">if</span> (num -- <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">auto</span> endit = cend (myVector);</span><br><span class="line">    <span class="keyword">auto</span> it = find(cbegin(myVector), endIt, num);</span><br><span class="line">    <span class="keyword">if</span> (it == endit)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt;<span class="string">"Could not find "</span>&lt;&lt; num &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p>
<p>调用<code>find()</code>时将<code>cbegin(myVector)</code>和<code>endIt</code>作为参数，其中，<code>endIt</code>定义为<code>cend(myVector)</code>，因此搜索的是vector的所有元素。如果需要搜索一个子范围，可修改这两个迭代器。</p>
<p>使用if语句的初始化器(C++17)，可使用如下加粗语句来调用<code>find()</code>并查找结果：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">auto</span> it = find(cbegin(myVector), endIt, num); it == endIt) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Found "</span> &lt;&lt; *it &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p>
<p>如果容器提供的方法具有与泛型算法同样的功能，那么应该使用相应的方法，那样速度更快。比如，泛型算法<code>find()</code>的复杂度为线性时间，用于map迭代器时也是如此；而map中<code>find()</code>方法的复杂度是对数时间。</p>
<p><code>find_if()</code>和<code>find()</code>类似，区别在于<code>find_if()</code>接收谓词函数回调作为参数，而不是简单的匹配元素。谓词返回true或false。<code>find_if()</code>算法对范围内的每个元素调用谓词，直到谓词返回true；如果返回了true，<code>find_if()</code>返回引用这个元素的迭代器。</p>
<h3 id="accumulate-算法"><a href="#accumulate-算法" class="headerlink" title="accumulate()算法"></a>accumulate()算法</h3><p>我们经常需要计算容器中所有元素的总和或其他算术值。<code>accumulate()</code>函数就提供了这种功能，该函数在<code>&lt;numeric&gt;</code>中定义。通过这个函数的最基本形式可计算指定范围内元素的总和。例如，下面的函数计算vector中整数序列的算术平均值。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">arithmeticMean</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> sum = accumulate(cbegin(nums), cend(nums), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> sum / nums.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>accumulate()</code>算法接收的第三个参数是总和的初始值，在这个例子中为0(加法计算的恒等值)，表示从0开始累加总和。<code>accumulate()</code>的第二种形式允许调用者指定要执行的操作，而不是执行默认的加法操作。这个操作的形式是二元回调。假设需要计算几何平均数。如果一个序列中有m个数字，那么几何平均数就是m个数字连乘的m次方根。在这个例子中，调用<code>accumulate()</code>计算乘积而不是总和。因此这个程序可以这样写：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">product</span> <span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 * num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">geometricMean</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> mult = accumulate (cbegin(nums), cend(nums), <span class="number">1</span>, product);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pow</span> (mult, <span class="number">1.0</span> / nums.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意，将<code>product()</code>函数作为回调传递给<code>accumulate()</code>，而把累计的初始值设置为1(乘法计算的恒等值)而不是0。</p>
<h3 id="在算法中使用移动语义"><a href="#在算法中使用移动语义" class="headerlink" title="在算法中使用移动语义"></a>在算法中使用移动语义</h3><p>与标准库容器一样，标准库算法也做了优化，以便在合适时使用移动语义。这可极大地加速特定的算法，例如<code>remove()</code>。因此，强烈建议在需要保存到容器中的自定义元素类中实现移动语义。通过实现移动构造函数和移动赋值运算符，任何类都可添加移动语义。它们都被标记为noexcept，因为它们不应抛出异常。</p>
<h2 id="std-function"><a href="#std-function" class="headerlink" title="std::function"></a>std::function</h2><p><code>std::function</code>在<code>&lt;functional&gt;</code>头文件中定义，可用来创建指向函数、函数对象或lambda表达式的类型：从根本上说可以指向任何可调用的对象。它被称为多态函数包装器，可以当成函数指针使用，还可用作实现回调的函数的参数。<code>std::function</code>模板的模板参数看上去和大多数模板参数都有所不同。语法如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::function&lt;R(ArgTypes...)&gt;</span><br></pre></td></tr></table></figure></p>
<p>R是函数返回值的类型，ArgTypes是一个以逗号分隔的函数参数类型的列表。</p>
<p>下例演示如何使用<code>std::function</code>实现一个函数指针。这段代码创建了一个函数指针<code>f1</code>，它指向函数<code>func()</code>。定义<code>f1</code>后，可通过函数名<code>func</code>或<code>f1</code>调用<code>func()</code>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">const</span> <span class="built_in">string</span>&amp; str)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"func("</span> &lt;&lt; num &lt;&lt;<span class="string">", "</span>&lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>, <span class="keyword">const</span> <span class="built_in">string</span>&amp;)&gt; f1 = func;</span><br><span class="line">    f1(<span class="number">1</span>, <span class="string">"test"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面的<code>f1</code>定义实现了同样的功能，而且简短得多，但f1的编译器推断类型是函数指针(即<code>void(*f1)(int, const string&amp;))</code>而不是<code>std::function</code>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f1 = func;</span><br></pre></td></tr></table></figure></p>
<p>由于<code>std::function</code>类型的行为和函数指针一致，因此可传递给标准库算法，如下面这个使用了<code>find_if()</code>算法的例子所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isEven</span><span class="params">(<span class="keyword">int</span> num1)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    function&lt;<span class="keyword">bool</span> (<span class="keyword">int</span>)&gt; fcn = isEven;</span><br><span class="line">    <span class="keyword">auto</span> result = find_if(cbegin(vec), cend(vec), fcn);</span><br><span class="line">    <span class="keyword">if</span> (result != cend(vec))</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt;<span class="string">"First even number:"</span>&lt;&lt; *result &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>std::function</code>真正有用的场合是将回调作为类的成员变量。在接收函数指针作为自定义函数的参数时，也可以使用<code>std::function</code>。下例定义了<code>process()</code>函数，这个函数接收一个对vector的引用和<code>std::function</code>。<code>process()</code>函数迭代给定vector中的所有元素，然后对每个元素调用指定的函数f。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec, function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>)&gt; f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i : vec)</span><br><span class="line">        f(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span> <span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; num &lt;&lt;<span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;vec&#123; <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span> &#125;;</span><br><span class="line">    process(vec, print);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    process (vec, [&amp;sum](<span class="keyword">int</span> num) &#123;sum += num;&#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h2><p>使用lambda表达式可编写内嵌的匿名函数，而不必编写独立函数或函数对象，使代码更容易阅读和理解。</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>下面定义一个lambda表达式，它仅把一个字符串写入控制台。</p>
<p>lambda表达式以方括号<code>[]</code>开始(这称为lambda引入符)，其后是花括号<code>{}</code>，其中包含lambda表达式体。lambda表达式被赋予自动类型变量basicLambda。第二行使用普通的函数调用语法执行lambda表达式。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> basicLambda = [] &#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello from Lambda"</span>&lt;&lt; <span class="built_in">endl</span>; &#125;;</span><br><span class="line">basicLambda();</span><br></pre></td></tr></table></figure></p>
<p>lambda表达式可以接收参数。参数在圆括号中指定，用逗号分隔开，与普通函数相同。下面是使用参数的示例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> parametersLambda = [](<span class="keyword">int</span> value)&#123; <span class="built_in">cout</span> &lt;&lt;<span class="string">"The value is "</span>&lt;&lt;value &lt;&lt; <span class="built_in">endl</span>; &#125;;</span><br><span class="line">parametersLambda(<span class="number">42</span>);</span><br></pre></td></tr></table></figure></p>
<p>如果lambda表达式不接收参数，就可指定空圆括号或忽略它们。</p>
<p>lambda表达式可返回值。返回类型在箭头后面指定，称为拖尾返回类型。下例定义的lambda表达式接收两个参数，返回它们的和：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> returningLambda = [] (<span class="keyword">int</span> a, <span class="keyword">int</span> b) -&gt; <span class="keyword">int</span> &#123; <span class="keyword">return</span> a + b; &#125;;</span><br><span class="line"><span class="keyword">int</span> sum = returningLambda(<span class="number">11</span>, <span class="number">22</span>);</span><br></pre></td></tr></table></figure></p>
<p>可以忽略返回类型。如果忽略了返回类型，编译器就根据函数返回类型推断规则来推断lambda表达式的返回类型，如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> returningLambda = [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123; <span class="keyword">return</span> a + b; &#125;;</span><br><span class="line"><span class="keyword">int</span> sum = returningLambda(<span class="number">11</span>, <span class="number">22</span>);</span><br></pre></td></tr></table></figure></p>
<p>lambda表达式可以在其封装的作用域内捕捉变量。例如，下面的lambda表达式捕捉变量data，将它用于lambda表达式体：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> data = <span class="number">1.23</span>;</span><br><span class="line"><span class="keyword">auto</span> capturingLambda = [data] &#123; <span class="built_in">cout</span> &lt;&lt;<span class="string">"Data "</span>&lt;&lt; data &lt;&lt; <span class="built_in">endl</span>; &#125;;</span><br></pre></td></tr></table></figure></p>
<p>lambda表达式的方括号部分称为<strong>lambda捕捉块</strong>(capture block)。捕捉变量的意思是可在lambda表达式体中使用这个变量。指定空白的捕捉块<code>[]</code>表示不从所在作用域内捕捉变量。如上例所示，在捕捉块中只写出变量名，将按值捕捉该变量。</p>
<p>编译器将lambda表达式转换为某种未命名的仿函数(即函数对象)，捕捉的变量变成这个仿函数的数据成员。将按值捕捉的变量复制到仿函数的数据成员中。这些数据成员与捕捉的变量具有相同的const性质。在前面的capturingLambda示例中，仿函数得到非const数据成员data，因为捕捉的变量data不是const。但在下例中，仿函数得到const数据成员data, 因为捕捉的变量是const。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> data = <span class="number">1.23</span>;</span><br><span class="line"><span class="keyword">auto</span> capturingLambda = [data]&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Data "</span> &lt;&lt; data &lt;&lt; <span class="built_in">endl</span>; &#125;;</span><br></pre></td></tr></table></figure></p>
<p>仿函数总是实现函数调用运算符<code>operator()</code>。对于lambda表达式，这个函数调用运算符被默认标记为const，这表示即使在lambda表达式中按值捕捉了非const变量，lambda表达式也不能修改其副本。把lambda表达式指定为mutable，就可以把函数调用运算符标记为非const:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> data = <span class="number">1.23</span>;</span><br><span class="line"><span class="keyword">auto</span> capturinglambda = [data] () <span class="keyword">mutable</span> &#123; data *= <span class="number">2</span>; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Data - "</span> &lt;&lt; data &lt;&lt; <span class="built_in">endl</span>; &#125;;</span><br></pre></td></tr></table></figure></p>
<p>在这个示例中，非const变量data是按值捕捉的，因此仿函数得到了一个非const数据成员，它是data的副本。因为使用了mutable关键字，函数调用运算符被标记为非const，所以lambda表达式体可以修改data的副本。注意如果指定了mutable，就必须给参数指定圆括号，即使圆括号为空，也是如此。</p>
<p>在变量名前面加上<code>&amp;</code>，就可按引用捕捉它。按引用捕捉变量时，必须确保执行lambda表达式时，该引用仍然是有效的。可采用两种方式来捕捉所在作用域内的所有变量。</p>
<ul>
<li><code>[=]</code>：通过值捕捉所有变量，</li>
<li><code>[&amp;]</code>：通过引用捕捉所有变量</li>
</ul>
<p>还可以酌情决定捕捉哪些变量以及这些变量的捕捉方法，方法是指定一个捕捉列表，其中带有可选的默认捕捉选项。前缀为<code>&amp;</code>的变量通过引用捕捉。不带前缀的变量通过值捕捉。默认捕捉应该是捕捉列表中的第一个元素，可以是<code>=</code>或<code>&amp;</code>。例如</p>
<ul>
<li><code>[&amp;x]</code>：只通过引用捕捉x，不捕捉其他变量</li>
<li><code>[x]</code>：只通过值捕捉x,不捕捉其他变量，</li>
<li><code>[=,&amp;x,&amp;y]</code>：默认通过值捕捉，变量x和y是例外，这两个变量通过引用捕捉。</li>
<li><code>[&amp;,x]</code>：默认通过引用捕捉，变量x是例外，这个变量通过值捕捉。</li>
<li><code>[&amp;x,&amp;x]</code>：非法，因为标识符不允许重复。</li>
<li><code>[this]</code>：捕捉周围的对象。即使没有使用<code>this-&gt;</code>，也可在lambda表达式体中访问这个对象。</li>
<li><code>[*this]</code>：捕捉当前对象的副本。如果在执行lambda表达式时对象不再存在，这将十分有用。</li>
</ul>
<blockquote>
<p>使用默认捕捉时，只有在lambda表达式体中真正使用的变量才会被捕捉，使用值(=)或引用(&amp;)捕捉。未使用的变量不捕捉，</p>
</blockquote>
<blockquote>
<p>不建议使用默认捕捉，即使只捕捉在lambda表达式体中真正使用的变量，也同样如此。使用=默认捕捉可能在无意中引发昂贵的复制。使用&amp;默认捕捉可能在无意间修改所在作用域内的变量，建议显式指定要捕捉的变量。</p>
</blockquote>
<p>lambda表达式的完整语法如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[capture_block] (parameters) <span class="keyword">mutable</span> <span class="keyword">constexpr</span></span><br><span class="line">noexcept_specifier attributes -&gt;</span><br><span class="line">return_type &#123; body &#125;</span><br></pre></td></tr></table></figure></p>
<p>lambda表达式包含以下部分</p>
<ul>
<li>捕捉块(capture block)：指定如何捕捉所在作用域内的变量，并供lambda主体部分使用。</li>
<li>参数(parameter，可选)：lambda表达式使用的参数列表。只有在不需要任何参数并且没有指定mutable、constexpr、noexcep说明符、属性和返回类型的情况下才能忽略参数列表。该参数列表和普通函数的参数列表类似，</li>
<li>mutable(可选)：把lambda表达式标记为mutable</li>
<li>constexpr(可选)：将lambda表达式标记为constexpr，从而可在编译时计算。如果满足某些限制条件，即使忽略，也可能为lambda表达式隐式使用constexpr。</li>
<li>noexcept说明符(可选)：用于指定noexcept子句，与普通函数的noexcept子句类似。</li>
<li>特性(attribute，可选)：用于指定lambda表达式的特性。</li>
<li>返回类型(可选)：返回值的类型。如果忽略，编译器会根据函数返回类型推断原则判断返回类型。</li>
</ul>
<h3 id="泛型lambda表达式"><a href="#泛型lambda表达式" class="headerlink" title="泛型lambda表达式"></a>泛型lambda表达式</h3><p>可以给lambda表达式的参数使用自动推断类型功能，而无须显式指定它们的具体类型。要为参数使用自动推断类型功能，只需要将类型指定为auto，类型推断规则与模板参数推断规则相同。</p>
<p>下例定义了一个泛型lambda表达式isGreaterThan100。这个lambda表达式与<code>find_if()</code>算法一起使用，一次用于整数vector，另一次用于双精度vector。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> isGreaterThan100 = [](<span class="keyword">auto</span> i)( <span class="keyword">return</span> i &gt; <span class="number">100</span>; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ints(<span class="number">11</span>, <span class="number">55</span>, <span class="number">101</span>, <span class="number">200</span>);</span><br><span class="line"><span class="keyword">auto</span> it1 = find_if(cbegin(ints), cend(ints), isGreaterThan100);</span><br><span class="line"><span class="keyword">if</span> (it1 != cend(ints)) </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Found a value &gt; 100: "</span> &lt;&lt; *it1 &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; doubles &#123; <span class="number">11.1</span>, <span class="number">55.5</span>, <span class="number">200.2</span> &#125;;</span><br><span class="line"><span class="keyword">auto</span> it2 = find_if(cbegin(doubles), cend(doubles), isGreaterThan100);</span><br><span class="line"><span class="keyword">if</span> (it2 != cend(doubles))</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Found a value &gt; 100: "</span>&lt;&lt; *it2 &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="lambda捕捉表达式"><a href="#lambda捕捉表达式" class="headerlink" title="lambda捕捉表达式"></a>lambda捕捉表达式</h3><p>lambda捕捉表达式允许用任何类型的表达式初始化捕捉变量。这可用于在lambda表达式中引入根本不在其内部的作用域内捕捉的变量，例如，下面的代码创建一个lambda表达式，其中有两个变量：myCapture使用lambda捕捉表达式初始化为字符串<code>Pi:</code>，pi在内部的作用域内按值捕捉。注意，用捕捉初始化器初始化的非引用捕捉变量，如myCapture，是通过复制来构建的，这表示省略了const限定符：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> pi = <span class="number">3.1415</span>;</span><br><span class="line"><span class="keyword">auto</span> myLambda = [myCapture = <span class="string">"Pi: "</span>, pi] &#123; <span class="built_in">cout</span> &lt;&lt; myCapture &lt;&lt; pi; &#125;;</span><br></pre></td></tr></table></figure></p>
<p>lambda捕捉变量可用任何类型的表达式初始化，也可用<code>std:move()</code>初始化。这对于不能复制、只能移动的对象而言很重要，例如<code>unique_ptr</code>。默认情况下，按值捕捉要使用复制语义，所以不可能在lambda表达式中按值捕捉<code>unique_ptr</code>。使用lambda捕捉表达式，可通过移动来捕捉它，例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> myPtr = <span class="built_in">std</span>::make_unique&lt;<span class="keyword">double</span>&gt;(<span class="number">3.1415</span>);</span><br><span class="line"><span class="keyword">auto</span> mylambda = [ p = <span class="built_in">std</span>::move(myPtr)] &#123; <span class="built_in">cout</span> &lt;&lt; *p; &#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="将lambda表达式用作返回类型"><a href="#将lambda表达式用作返回类型" class="headerlink" title="将lambda表达式用作返回类型"></a>将lambda表达式用作返回类型</h3><p>使用前面讨论的<code>std::function</code>，可从函数返回lambda表达式，分析以下定义：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function&lt;<span class="keyword">int</span>(vold)&gt; multiplyBy2Lambda(<span class="keyword">int</span> x) &#123;</span><br><span class="line">    <span class="keyword">return</span> [x]&#123; <span class="keyword">return</span> <span class="number">2</span> * x; &#125;;</span><br></pre></td></tr></table></figure></p>
<p>这个函数的主体部分创建一个lambda表达式，通过值捕捉所在作用域的变量x，并返回一个整数，这个整数是传给<code>multiplyBy2Lambda()</code>的值的两倍。<code>multiplyBy2Lambda()</code>函数的返回类型为<code>function&lt;int(void)&gt;</code>，即一个不接收参数并返回一个整数的函数。函数体中定义的lambda表达式正好匹配这个原型。变量x通过值捕捉，因此，<br>在lambda表达式从函数返回之前，x值的副本被绑定至lambda表达式中的x。可按如下方式调用该函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function&lt;<span class="keyword">int</span>(<span class="keyword">void</span>)&gt; fn = multiplyBy2Lambda(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; fn() &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="标准库算法示例"><a href="#标准库算法示例" class="headerlink" title="标准库算法示例"></a>标准库算法示例</h3><h4 id="count-if"><a href="#count-if" class="headerlink" title="count_if()"></a>count_if()</h4><p>下例通过<code>count_if()</code>算法计算给定vector中满足特定条件的元素个数。通过lambda表达式的形式给出条件，这个lambda表达式通过值捕捉所在作用域内的value变量。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> value = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> cnt = count_if(cbegin(vec), cend(vec), [value] (<span class="keyword">int</span> i) &#123; <span class="keyword">return</span> i &gt; value;&#125;);</span><br></pre></td></tr></table></figure></p>
<p>可对上面的这个例子进行扩展，以演示通过引用捕捉变量的方式。下面的lambda表达式通过递增所在作用域内按引用捕捉的一个变量，来计算调用次数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> value = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> cntlambdaCalled = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> cnt = count_if(cbegin(vec), cend(vec), [value, &amp;cntLambdaCalled] (<span class="keyword">int</span> i) &#123;++cntLambdaCalled; <span class="keyword">return</span> i &gt; value;&#125;);</span><br></pre></td></tr></table></figure></p>
<h4 id="generate"><a href="#generate" class="headerlink" title="generate()"></a>generate()</h4><p><code>generate()</code>算法需要一个迭代器范围，它把该迭代器范围内的值替换为从函数返回的值，并作为第三个参数。下例结合<code>generate()</code>算法和一个lambda表达式将2、4、8、16等值填充到vector。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">int</span> value = <span class="number">1</span>;</span><br><span class="line">generate(begin(vec), end(vec), [&amp;value]&#123; value *= <span class="number">2</span>; <span class="keyword">return</span> value; &#125;);</span><br></pre></td></tr></table></figure></p>
<h2 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h2><p>在类中，可重载函数调用运算符，使类的对象可取代函数指针。将这些对象称为函数对象(finction object)，或称为仿函数(functor)。</p>
<p>很多标准库算法，例如<code>find_if()</code>以及<code>accumulate()</code>，可接收函数指针、lambda表达式和仿函数作为参数，以更改函数行为。</p>
<p>建议尽可能使用lambda表达式，而不是小型函数对象，因为lambda表达式更便于使用、读取和理解。</p>
<h3 id="算术函数对象"><a href="#算术函数对象" class="headerlink" title="算术函数对象"></a>算术函数对象</h3><p>C++提供了5类二元算术运算符的仿函数类模板：plus，minus，multiplies，divides和modulus。此外提供了一元的取反操作。这些类对操作数的类型模板化，是对实际运算符的包装。它们接收一个或两个模板类型的参数，执行操作并返回结果。下面是一个使用plus类模板的示例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plus&lt;<span class="keyword">int</span>&gt; myPlus;</span><br><span class="line"><span class="keyword">int</span> res = myPlus(<span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; res &lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p>
<p>算术函数对象的好处在于可将它们以回调形式传递给算法，而使用算术运算符时却不能直接这样做。</p>
<blockquote>
<p>算术函数对象只不过是对算术运算符的简单包装。如果在算法中使用函数对象作为回调，务必保证容器中的对象实现了恰当的操作。</p>
</blockquote>
<h4 id="透明运算符仿函数"><a href="#透明运算符仿函数" class="headerlink" title="透明运算符仿函数"></a>透明运算符仿函数</h4><p>C++支持透明运算符仿函数，允许忽略模板类型参数。例如，可只指定<code>multiplies&lt;&gt;</code>(而非<code>multiplies&lt;int&gt;()</code>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">geometricMeanTransparent</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"><span class="keyword">double</span> mult </span>= accumulate(cbegin (nums), cend(nums), <span class="number">1</span>, multiplies&lt;&gt;());</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">pow</span> (mult, <span class="number">1.0</span> / nums.size());</span><br></pre></td></tr></table></figure></p>
<p>这些透明运算符仿函数的一个重要特性是，它们是异构的，即它们不仅比非透明运算符仿函数更简明，而且具有真正的函数性优势。例如，下面的代码使用透明运算符仿函数和双精度数1.1作为初始值，而vector包<br>含整数。<code>accumulate()</code>会把结果计算为double值，result是6.6:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;;</span><br><span class="line"><span class="keyword">double</span> result = accumulate(cbegin(nums), cend(nums), <span class="number">1.1</span>, mu1tip1ies&lt;&gt;());</span><br></pre></td></tr></table></figure></p>
<p>如果这些代码使用非透明运算符仿函数，<code>accumulate()</code>会把结果计算为整数，result就是6。编译这些代码时，编译器会给出可能丢失数据的警告：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;;</span><br><span class="line"><span class="keyword">double</span> result - accumulate (cbegin (nums), cend(nums), <span class="number">1.1</span>, multiplies&lt;<span class="keyword">int</span>&gt;());</span><br></pre></td></tr></table></figure></p>
<h3 id="比较函数对象"><a href="#比较函数对象" class="headerlink" title="比较函数对象"></a>比较函数对象</h3><p>除算术函数对象类外，C++语言还提供了所有标准的比较：<code>equal_to</code>、<code>not_equal_to</code>、<code>less</code>、<code>greater</code>、<code>less_equal</code>和<code>greater_equal</code>。可将priority_queue的比较模板修改为greater。priority_queue模板定义如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Container</span> = <span class="title">vector</span>&lt;T&gt;, <span class="title">class</span> <span class="title">Compare</span> = <span class="title">less</span>&lt;T&gt;&gt;;</span></span><br></pre></td></tr></table></figure></p>
<p>遗憾的是，Compare类型参数是最后一个参数，这意味着要指定比较操作，还必须指定容器类型。如果希望priority_queue通过greater按升序对元素排序，需要把上例中的priority_queue定义改为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;&gt;&gt;myQueue;</span><br></pre></td></tr></table></figure></p>
<p>注意，使用透明运算符<code>greater&lt;&gt;</code>定义了myQueue。与使用非透明运算符相比，使用透明比较回调的性能稍好一些。</p>
<h3 id="逻辑函数对象"><a href="#逻辑函数对象" class="headerlink" title="逻辑函数对象"></a>逻辑函数对象</h3><p>C++为3个逻辑操作提供了函数对象类，它们分别是：<code>logical_not(operator!)</code>、<code>logical_and(operator&amp;&amp;)</code>和<code>logical_or(operator||)</code>。逻辑操作只操作true和false值。</p>
<p>例如，可使用逻辑仿函数来实现<code>allTrue()</code>函数，这个函数检查容器中的所有布尔标志是否都为true:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">allTrue</span> <span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&amp; flags)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> accumulate(begin(flags), end(flags), <span class="literal">true</span>, logical_and&lt;&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>类似地，可使用<code>logical_or</code>仿函数实现<code>anyTrue()</code>函数，如果容器中至少有一个布尔标志为true，那么这个函数返回true:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">anyTrue</span> <span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&amp; flags)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> accumulate(begin(flags)，end(flags), <span class="literal">false</span>, logical_or&lt;&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="按位函数对象"><a href="#按位函数对象" class="headerlink" title="按位函数对象"></a>按位函数对象</h3><p>C++为所有按位操作添加了函数对象，它们分别是：<code>bit_and</code>(<code>operator&amp;</code>)、<code>bit_or</code>(<code>operator|</code>)、<code>bit_xor</code>(<code>operator^</code>)和<code>bit_not</code>(<code>operator!</code>)。</p>
<h3 id="函数对象适配器"><a href="#函数对象适配器" class="headerlink" title="函数对象适配器"></a>函数对象适配器</h3><p>函数适配器对函数组合(functional composition)提供了一些支持，也就是能将函数组合在一起，以精确提供所需的行为。</p>
<h4 id="绑定器"><a href="#绑定器" class="headerlink" title="绑定器"></a>绑定器</h4><p>绑定器(binder)可用于将函数的参数绑定至特定的值。为此要使用<code>&lt;functional&gt;</code>头文件中定义的<code>std::bind()</code>，它允许采用灵活的方式绑定可调用的参数。既可将函数的参数绑定至固定值，甚至还能重新安排函数参数的顺序。下面通过一个例子进行解释，假定有一个<code>func()</code>函数，它接收两个参数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> num, string_view str)</span></span></span><br></pre></td></tr></table></figure></p>
<p>下面的代码演示如何通过<code>bind()</code>将<code>func()</code>函数的第二个参数绑定至固定值myString。结果保存在<code>f1()</code>中。使用auto关键字是因为C++标准未指定<code>bind()</code>的返回类型，因而是特定于实现的。没有绑定至指定值的参数应该标记为<code>_1</code>、<code>_2</code>和<code>_3</code>等。这些都定义在<code>std::placeholders</code>名称空间中。</p>
<p>在<code>f1()</code>的定义中，<code>_1</code>指定了调用<code>func()</code>时，<code>f1()</code>的第一个参数应该出现的位置。之后，就可以用一个整型参数调用<code>f1()</code>。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> mystring = <span class="string">"abc"</span>;</span><br><span class="line"><span class="keyword">auto</span> f1 = bind(func, placeholders::_1, myString);</span><br><span class="line">f1(<span class="number">16</span>);</span><br></pre></td></tr></table></figure></p>
<p><code>bind()</code>还可用于重新排列参数的顺序，如下列代码所示。<code>_2</code>指定了调用<code>func()</code>时，20的第二个参数应该出<br>现的位置。换句话说，12(绑定的意义是：<code>f2()</code>的第一个参数将成为函数<code>func()</code>的第二个参数，<code>f2()</code>的第二个参数将成为函数<code>func()</code>的第一个参数<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f2 = bind(func, placeholders::_2, placeholders::_1);</span><br><span class="line">f2(<span class="string">"Test"</span>，<span class="number">32</span>);</span><br></pre></td></tr></table></figure></p>
<p><code>&lt;functional&gt;</code>头文件定义了<code>std::ref()</code>和<code>cref()</code>辅助模板函数。它们可分别用于绑定引用或const引用。如果使用<code>bind()</code>调用函数，引用变量的值就不递增，因为建立了变量的一个副本。使用<code>std::ref()</code>正确传递对应的引用后会递增。</p>
<p>结合重载函数使用时，绑定参数会出现一个小问题。如果要对这些重载的函数使用<code>bind()</code>，那么必须显式地指定绑定这两个重载中的哪一个。如果需要绑定接收浮点数参数的重载函数的参数，需要使用以下语法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f4 = bind((<span class="keyword">void</span>(*)(<span class="keyword">float</span>))overloaded, placeholders::_1);</span><br></pre></td></tr></table></figure></p>
<h4 id="取反器"><a href="#取反器" class="headerlink" title="取反器"></a>取反器</h4><h5 id="not-fn"><a href="#not-fn" class="headerlink" title="not_fn"></a>not_fn</h5><p>取反器(negator)类似于绑定器(binder)，但对调用结果取反。例如，如果想要找到测试分数序列中第一个小于100的元素，那么可以对<code>perfectScore()</code>的结果应用<code>notl()</code>取反器适配器，如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> enditer = end(myVector);</span><br><span class="line"><span class="keyword">auto</span> it = find_if(begin(myVector), endIter, not_fn(perfectScore));</span><br><span class="line"><span class="keyword">if</span> (it == enditer)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"All perfect scores"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p>
<p><code>not_fn()</code>仿函数对作为参数传入的每个调用结果取反。注意在这个示例中，也可以使用<code>find_if_not()</code>算法。</p>
<p>前面使用<code>not_fn()</code>取反器的<code>find_if()</code>调用可以用lambda表达式更简洁地表达：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> it = find_if(begin(myVector), endIter, [](<span class="keyword">int</span> i)&#123;<span class="keyword">return</span> i &lt; <span class="number">100</span>; &#125;);</span><br></pre></td></tr></table></figure></p>
<h5 id="not1和not2"><a href="#not1和not2" class="headerlink" title="not1和not2"></a>not1和not2</h5><p>C++17引入了<code>std::not_fn()</code>适配器。在C++17之前，可使用<code>std:not1()</code>和<code>not2()</code>适配器。<code>not1</code>中的“1”是指：它的操作数必须是一个一元函数(只接收一个参数)。如果操作数是二元函数(接收两个参数)，则必须改用<code>not2()</code>。下面是一个示例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> enditer = end(myVector);</span><br><span class="line">function&lt;<span class="keyword">bool</span>(<span class="keyword">int</span>)&gt; f = perfectscore;</span><br><span class="line"><span class="keyword">auto</span> it = find_if(begin(myVector), endIter, not1(f));</span><br></pre></td></tr></table></figure></p>
<p>如果想将<code>not1()</code>用于自己的仿函数类，则必须确保仿函数类的定义包含两个typedef：<code>argument_type</code>和<code>result_type</code>。如果想要使用<code>not2()</code>，则仿函数类的定义必须提供3个typedef：<code>first_argument_type</code>、<code>second_argument_type</code>和<code>result_type</code>。为此，最简便的方式是从<code>unary_function</code>或<code>binary_function</code>派生自己的函数对象类，具体取决于使用的是一个参数还是两个参数。在<code>&lt;functional&gt;</code>中定义的两个类在所提供函数的参数和返回类型上模板化。例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Perfectscore</span> :</span> <span class="keyword">public</span> <span class="built_in">std</span>::unary_function&lt;<span class="keyword">int</span>, <span class="keyword">bool</span>&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">result_type <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> argument_type&amp; score)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> score &gt;= <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>可采用如下方式使用这个仿函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> it = find_if(begin(myVector), endIter, not1(PerfectScore()));</span><br></pre></td></tr></table></figure></p>
<h5 id="调用成员函数"><a href="#调用成员函数" class="headerlink" title="调用成员函数"></a>调用成员函数</h5><p>假设有一个对象容器，有时需要传递一个指向类方法的指针作为算法的回调。调用方法指针的代码和调用普通函数指针的代码是不一样的，因为前者必须在对象的上下文中调用。C++提供了<code>mem_fn()</code>转换函数，在传递给算法之前可以对函数指针调用这个函数。必须将string中的<code>empty()</code>方法指针指定为<code>&amp;string::empty</code>。<code>&amp;string::</code>部分不是可选的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findEmptyString</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strings)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> enditer = end(strings);</span><br><span class="line">    <span class="keyword">auto</span> it = find_if(begin(strings), endIter, mem_fn(&amp;<span class="built_in">string</span>::empty));</span><br><span class="line">    <span class="keyword">if</span> (it == enditer)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt;<span class="string">"No empty strings!"</span>&lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p>
<p><code>mem_fn()</code>生成一个用作<code>find_if()</code>回调的函数对象。每次调用它时，都会对参数调用<code>empty()</code>方法。</p>
<p>即使容器内保存的不是对象本身，而是对象指针，<code>mem_fn()</code>的使用方法也完全一样，例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findEmptystring</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>*&gt;&amp; strings)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> enditer = end(strings);</span><br><span class="line">    <span class="keyword">auto</span> it = find_if(begin(strings), enditer, mem_fn(&amp;<span class="built_in">string</span>::empty));</span><br></pre></td></tr></table></figure></p>
<h3 id="std-invoke"><a href="#std-invoke" class="headerlink" title="std::invoke()"></a>std::invoke()</h3><p>C++17引入了<code>std::invoke()</code>，<code>std::invoke()</code>在<code>&lt;functional&gt;</code>中定义，可用于通过一组参数调用任何可调用对象。下例使用了三次<code>invoke()</code>：一次调用普通函数，另一次调用lambda表达式，还有一次调用string实例的成员函数<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printMessage</span><span class="params">(string_view message)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; message &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    invoke(printMessage, <span class="string">"Hello invoke."</span>);</span><br><span class="line">    invoke([](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; msg) &#123; <span class="built_in">cout</span> &lt;&lt; msg &lt;&lt; <span class="built_in">endl</span>; &#125;, <span class="string">"Hello invoke."</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> msg = <span class="string">"Hello invoke."</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; invoke(&amp;<span class="built_in">string</span>::size, msg) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>invoke()</code>本身的作用并不大，因为可以直接调用函数或lambda表达式。但在模板代码中，如果需要调用任意可调用对象，<code>invoke()</code>的作用会发挥出来。</p>
<h2 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h2><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>迭代器有5类：输入、输出、正向、双向和随机访问迭代器。确切地讲，每个随机访问迭代器也是双向的，每个双向迭代器也是正向的，每个正向迭代器也是输入迭代器。满足输出迭代器要求的迭代器称为<strong>可变迭代器</strong>(mutable iterator)，否则称为<strong>不可变迭代器</strong>(constant iterator)。</p>
<p>算法指定要使用的迭代器类型的标准方法是，在迭代器模板类型参数中使用以下名称：<code>InputIterator</code>、<code>OutputIterator</code>、<code>ForwardIterator</code>、<code>BidirectionalIterator</code>、<code>RandomAccessIterator</code>。这些只是名称，没有提供绑定类型的检查。因此，可在调用需要<code>RandomAccessIterator</code>的算法时，传入双向迭代器。模板不会进行类型检查，因此允许这样的实例化。然而，函数中使用随机访问迭代器功能的代码，在使用双向迭代器时将无法成功编译。</p>
<h3 id="非修改序列算法"><a href="#非修改序列算法" class="headerlink" title="非修改序列算法"></a>非修改序列算法</h3><p>非修改序列算法包括在某个范围内搜索元素的函数、比较两个范围的函数以及许多工具算法。</p>
<h4 id="搜索算法"><a href="#搜索算法" class="headerlink" title="搜索算法"></a>搜索算法</h4><p>标准库提供了基本<code>find()</code>算法的一些其他变种，这些算法对元素序列执行操作。所有算法都使用默认的比较运算符<code>operator==</code>和<code>operator&lt;</code>，还提供了重载版本，以允许指定比较回调。下面是一些搜索算法的示例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myVector = &#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">9.</span> <span class="number">8</span>, <span class="number">8</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> beginiter = cbegin (myVector);</span><br><span class="line"><span class="keyword">auto</span> enditer = cend(myVector);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> it = find_if_not(beginiter, enditer, [](<span class="keyword">int</span> i)&#123; <span class="keyword">return</span> i&lt;<span class="number">8</span>;&#125;);</span><br><span class="line"><span class="keyword">if</span> (it != enditer)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="string">"First element not &lt; 8 is "</span>&lt;&lt; *it &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p>
<h4 id="专用的搜索算法"><a href="#专用的搜索算法" class="headerlink" title="专用的搜索算法"></a>专用的搜索算法</h4><p>C++17给<code>search()</code>算法增加了额外的可选参数，允许指定要使用的搜索算法。有三个选项：<code>default_searcher</code>、<code>boyer_moore_searcher</code>或<code>boyer_moore_horspool_searcher</code>，它们都在<code>&lt;functional&gt;</code>中定义。后两个选项实现了知名的Boyer-Moore和Boyer-Moore-Horspool搜索算法。它们十分高效，可用于在一大块文本中查找子字符串。Boyer-Moore搜索算法的复杂度如下，N是在其中搜索的序列的大小，M是要查找的模式的大小。如果未找到模式，最坏情况下的复杂度为O(N+M)，如果找到模式，最坏情况下的复杂度为O(NM)。Boyer-Moore和 Boyer-Moore-Horspool算法的区别在于，在初始化以及算法的每个循环迭代中，后者的固定开销较少；但是，后者在最坏情况下的复杂度明显高于前者算法。</p>
<h4 id="比较算法"><a href="#比较算法" class="headerlink" title="比较算法"></a>比较算法</h4><p>可通过3种不同的方法比较整个范围内的元素：<code>equal()</code>、<code>mismatch()和</code>lexicographical_compare()`。这些算法的好处是可比较不同容器内的范围。例如，可比较vector和list的内容。一般情况下，这些算法最适用于顺序容器。这些算法的工作方法是<strong>比较两个集合中对应位置的值</strong>。下面列出每个算法的工作方式。</p>
<ul>
<li><code>equal()</code>：如果所有对应元素都相等，则返回true。最初，<code>equal()</code>接收三个迭代器，分别是第一个范围的首尾迭代器，以及第二个范围的首迭代器。该版本要求两个范围的元素数目相同。</li>
<li><code>mismatch()</code>：返回多个迭代器，每个范围对应一个迭代器，表示范围内不匹配的对应元素。与<code>equal()</code>一样，存在三迭代器版本和四迭代器版本。</li>
<li><code>lexicographical_compare()</code>：如果第一个范围内的第一个不相等元素小于第二个范围内的对应元素，或如果第一个范围内的元素个数少于第二个范围，且第一个范围内的所有元素都等于第二个范围内对应的初始子序列，那么返回true。</li>
</ul>
<p>如果要比较两个同类型容器的元素，可使用运算符<code>operator==</code>和<code>operator&lt;</code>，而不是<code>equal()</code>和<code>lexicographical_compare()</code>。</p>
<h4 id="计数算法"><a href="#计数算法" class="headerlink" title="计数算法"></a>计数算法</h4><p>非修改计数算法有<code>all_of()</code>、<code>any_of()</code>、<code>none_of()</code>、<code>count()</code>和<code>count_if()</code>。下面是一个算法的示例。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//all_of()</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec2 = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">if</span>(all_of(cbegin(vec2), cend(vec2), [](<span class="keyword">int</span> i)&#123; <span class="keyword">return</span> i== <span class="number">1</span>;)))</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; “All elements are == <span class="number">1</span><span class="string">"&lt;&lt;endl;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="修改序列算法"><a href="#修改序列算法" class="headerlink" title="修改序列算法"></a>修改序列算法</h3><p>标准库提供了多种修改序列算法，这些算法执行的任务包括：从一个范围向另一个范围复制元素、删除元素以及反转某个范围内元素的顺序。</p>
<p>修改算法不能将元素插入目标范围中，仅可重写/修改目标范围中已经存在的元素。</p>
<p>map和multimap的范围不能用作修改算法的目标范围。这些算法改写全部元素，而在map中，元素是键值对。map和multimap将键标记为const，因此不能为其赋值。set和multiset也是如此。 替换方案是使用插入迭代器。</p>
<h4 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h4><p><code>transform()</code>算法对范围内的每个元素应用回调，期望回调生成一个新元素，并保存在指定的目标范围中。如果希望<code>transform()</code>将范围内的每个元素替换为调用回调产生的结果，那么源范围和目标范围可以是同一范围。其参数是源序列的首尾迭代器、目标序列的首迭代器以及回调。例如，可按如下方式将vector中的每个元素增加100：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transform(begin(myVector), end(myVector), begin(myVector), [](<span class="keyword">int</span> i)&#123; <span class="keyword">return</span> it <span class="number">100</span>;&#125;&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>transform()</code>的另一种形式对范围内的元素对调用二元函数，需要将第一个范围的首尾迭代器、第二个范围的首迭代器以及目标范围的首迭代器作为参数。 下例创建两个vector,然后通过<code>transform()</code>计算元素对的和，并将结果保存回第一个vector：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transform(begin(vec1), end(vec1), begin(vec2), begin(vec1), [](<span class="keyword">int</span> a, <span class="keyword">int</span> b)&#123;<span class="keyword">return</span> a + b;&#125;);</span><br></pre></td></tr></table></figure></p>
<p><code>transform()</code>和其他修改算法通常返回一个引用目标范围内最后一个值后面那个位置(past-the-end)的迭代器。</p>
<h4 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h4><p><code>copy()</code>算法可将一个范围内的元素复制到另一个范围，从这个范围内的第一个元素开始直到最后一个元素。源范围和目标范围必须不同，但在一定限制条件下可以重叠。限制条件如下：对于<code>copy(b,e,d)</code>，如果d在b之前，则可以重叠；但如果d处于[b,e]范围，则行为不确定。与所有修改算法类似，<code>copy()</code>不会向目标范围插入元素，只改写已有的元素。</p>
<p>下面举一个使用<code>copy()</code>的简单例子，这个例子对vector应用<code>resize()</code>方法，以确保目标容器中有足够空间。这个例子将vec1中的所有元素复制到vec2:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vecl, vec2;</span><br><span class="line"></span><br><span class="line">vec2.resize(size(vec1));</span><br><span class="line">copy(cbegin(vec1), cend(vec1), begin(vec2));</span><br></pre></td></tr></table></figure></p>
<p>还有一个<code>copy_backward()</code>算法，这个算法将源范围内的元素反向复制到目标范围。换句话说，这个算法从源范围的最后一个元素开始，将这个元素放在目标范围的最后一个位置，然后在每一次复制之后反向移动。分析<code>copy_backward()</code>，源范围和目标范围必须是不同的，但在一定限制条件下可以重叠。限制条件如下：对于<code>copy_backward(b,e,d)</code>，如果d在e之后，则能正确重叠；但如果d处于(b,e]范围，则行为不确定。前面的例子可按如下代码修改为使用<code>copy_backward()</code>而不是<code>copy()</code>。注意第三个参数应该指定<code>end(vec2)</code>而不是<code>begin(vec2)</code>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">copy_backward (cbegin (vec1)，cend(vec1), end(vec2));</span><br></pre></td></tr></table></figure></p>
<p>得到的输出完全一致。</p>
<p>在使用<code>copy_if()</code>算法时，需要提供由两个迭代器指定的输入范围、由一个迭代器指定的输出范围以及一个谓词(函数或lambda表达式)。该算法将满足给定谓词的所有元素复制到目标范围。记住，复制不会创建或扩大容器，只是替换现有元素。因此，目标范围应当足够大，从而保存要复制的所有元素。当然，复制元素后，最好删除超出最后一个元素复制位置的空间。为便于达到这个目的，<code>copy_if()</code>返回了目标范围内最后一个复制的元素后面那个位置的迭代器，以便确定需要从目标容器中删除的元素个数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec1, vec2;</span><br><span class="line"></span><br><span class="line">vec2.resize(size(vec1));</span><br><span class="line"><span class="keyword">auto</span> enditerator = copy_if(cbegin(vec1), cend(vec1), begin(vec2), [](<span class="keyword">int</span> i)&#123; <span class="keyword">return</span> i % <span class="number">2</span> == <span class="number">0</span>;&#125;);</span><br><span class="line">vec2.erase(enditerator, end(vec2));</span><br></pre></td></tr></table></figure></p>
<p><code>copy_n()</code>从源范围复制n个元素到目标范围。<code>copy_n()</code>的第一个参数是起始迭代器，第二个参数是指定要复制的元素个数，第三个参数是目标迭代器。<code>copy_n()</code>算法不执行任何边界检查，因此一定要确保起始迭代器递增n个要复制的元素后，不会超过集合的<code>end()</code>，否则程序会产生未定义的行为。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec1, vec2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> cnt = <span class="number">0</span>;</span><br><span class="line">cnt = min(cnt, size(vec1));</span><br><span class="line">vec2.resize(cnt);</span><br><span class="line">copy_n(cbegin(vec1), cnt, begin(vec2));</span><br></pre></td></tr></table></figure></p>
<h4 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h4><p>有两个和移动相关的算法：<code>move()</code>和<code>move_backward()</code>。如果要在自定义类型元素的容器中使用这两个算法，那么需要在元素类中提供移动赋值运算符。main()函数创建了一个带有3个MyClass对象的vector，然后将这些元素从vecSrc移到vecDst。注意这段代码包含两种不同的<code>move()</code>用法。一种是，<code>move()</code>函数接收一个参数，将Ivalue转换为rvalue；而另一种是，接收3个参数的<code>move()</code>是标准库的<code>move()</code>算法，这个算法在容器之间移动元素。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Class MyClass &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;MyClass&gt; vecSrc&#123;MyClass(<span class="string">"a"</span>), MyClass(<span class="string">"b"</span>), MyClass(<span class="string">"c"</span>)&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;MyClass&gt; vecDst(vecSrc.size());</span><br><span class="line">    move(begin(vecSrc), end(vecSrc)，begin(vecDst));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h4><p><code>replace()</code>和<code>replace_if()</code>算法将一个范围内匹配某个值或满足某个谓词的元素替换为新的值。比如<code>replace_if()</code>算法的第一个和第二个参数指定了容器中元素的范围。第三个参数是一个返回true或false的函数或lambda表达式，如果它返回true，那么容器中的对应值被替换为第四个参数指定的值；如果它返回false，则保留原始值。例如，假定要将容器中的所有奇数值替换为0:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">replace_if(begin(vec)，end(vec), [](<span class="keyword">int</span> i) &#123; <span class="keyword">return</span> i%<span class="number">2</span> != <span class="number">0</span>;&#125;, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></p>
<p><code>replace()</code>和<code>replace_if()</code>也有名为<code>replace_copy()</code>和<code>replace_copy_if()</code>的变体，这些变体将结果复制到不同的目标范围。它们类似于<code>copy()</code>，因为目标范围必须足够大，以容纳新元素。</p>
<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>如果对vector容器应用<code>erase()</code>，这个解决方案的效率非常低下，因为要保持vector在内存中的连续性，会涉及很多内存操作，因而得到：二次(平方)复杂度；所谓二次复杂度，是指运行时间是输入大小的平方的函数。这个问题的正确解决方案是“删除擦除法”，</p>
<p>算法只能访问迭代器抽象，不能访问容器。因此删除算法不能真正地从底层容器中删除元素，而是将匹配给定值或谓词的元素替换为下一个不匹配给定值或渭词的元素。为此使用移动赋值。结果是将范围分为两个集合：一个用于保存要保留的元素，另一个用于保存要删除的元素。返回的迭代器指向要删除的元素范围内的第一个元素。如果真的需要从容器中删除这些元素，必须先使用<code>remove()</code>算法，然后调用容器的<code>erase()</code>方法，将从返回的迭代器开始到范围尾部的所有元素删除。这就是删除擦除法。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> it = remove_if(begin(strings), end(strings), [](<span class="keyword">const</span> <span class="built_in">string</span>&amp; str) &#123; <span class="keyword">return</span> str.empty(); &#125;);</span><br><span class="line"></span><br><span class="line">strings.erase(it, end(strings));</span><br></pre></td></tr></table></figure></p>
<p>使用“删除擦除法”时，切勿忘记<code>erase()</code>的第二个参数!如果忘掉第二个参数，<code>erase()</code>将仅从容器中删除一个元素，即作为第一个参数传递的迭代器指向的元素。</p>
<p><code>remove()</code>和<code>remove_if()</code>的<code>remove_copy()</code>和<code>remove_copy_if()</code>变体不会改变源范围，而将所有未删除的元素复制到另一个目标范围。这些算法和<code>copy()</code>类似，要求目标范围必须足够大，以便保存新元素。</p>
<h4 id="唯一化"><a href="#唯一化" class="headerlink" title="唯一化"></a>唯一化</h4><p><code>unique()</code>算法是特殊的<code>remove()</code>，<code>remove()</code>能将所有重复的连续元素删除。list容器提供了自己的具有同样语义的<code>unique()</code>方法。</p>
<h4 id="抽样"><a href="#抽样" class="headerlink" title="抽样"></a>抽样</h4><p><code>sample()</code>算法从给定的源范围返回n个随机选择的元素，并存储在目标范围。它需要5个参数：</p>
<ul>
<li>要从中抽样的范围的首尾迭代器</li>
<li>目标范围的首迭代器，将随机选择的元素存储在目标范围</li>
<li>要选择的元素数量</li>
<li>随机数生成引擎</li>
</ul>
<h4 id="反转"><a href="#反转" class="headerlink" title="反转"></a>反转</h4><p><code>reverse()</code>算法反转某个范围内元素的顺序。将范围内的第一个元素和最后一个元素交换，将第二个元素和倒数第二个元素交换，依此类推。<code>reverse()</code>最基本的形式是就地运行，要求两个参数：范围的首尾迭代器。还有一个名为<code>reverse_copy()</code>的版本，这个版本将结果复制到新的目标范围，它需要3个参数：源范围的首尾迭代器以及目标范围的起始迭代器。<br>目标范围必须足够大，以便保存新元素。</p>
<p><code>shuffle()</code>以随机顺序重新安排某个范围内的元素，其复杂度为线性时间。它可用于实现洗牌等任务。<code>shuffle()</code>的参数是要乱序的范围的首尾迭代器，以及一个统一的随机数生成器对象，它指定如何生成随机数。</p>
<h3 id="操作算法"><a href="#操作算法" class="headerlink" title="操作算法"></a>操作算法</h3><p>此类算法只有两个：<code>for_each()</code>和<code>for_each_n()</code>，后者是在C++17中引入的。它们对范围内的每个元素执行回调，或对范围内的前n个元素执行回调。</p>
<h4 id="for-each"><a href="#for-each" class="headerlink" title="for_each()"></a>for_each()</h4><p>下例说明如何使用<code>for_each()</code>算法和lambda表达式，计算范围内元素的和与积。注意，lambda表达式只显式捕捉需要的变量，它按引用捕捉变量，否则lambda表达式内对sum和product的修改无法在lambda表达式外可见：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myVector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sum = O;</span><br><span class="line"><span class="keyword">int</span> product = <span class="number">1</span>;</span><br><span class="line">for_each(cbegin(myVector), cend(myVector), [&amp;sum, &amp;product](<span class="keyword">int</span> i)&#123; sum += i; product *= i;&#125;);</span><br></pre></td></tr></table></figure></p>
<h4 id="for-each-n"><a href="#for-each-n" class="headerlink" title="for_each_n()"></a>for_each_n()</h4><p><code>for_each_n()</code>算法需要范围的起始迭代器、要迭代的元素数量以及函数回调。它返回的迭代器等于<code>begin+n</code>。它通常不执行任何边界检查。下例只迭代map的前两个元素：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for_each_n(cbegin(myMap),<span class="number">2</span>, [] (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; p) &#123;<span class="built_in">cout</span> &lt;&lt; p.first &lt;&lt; p.second &lt;&lt; <span class="built_in">endl</span>; &#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="交换算法"><a href="#交换算法" class="headerlink" title="交换算法"></a>交换算法</h3><p>C++标准库提供了以下交换算法</p>
<h4 id="swap"><a href="#swap" class="headerlink" title="swap()"></a>swap()</h4><p><code>std::swap()</code>用于有效地交换两个值，并使用移动语义(如果可用的话)。它的使用十分简单：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">11</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">22</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Before swap(): a = "</span>&lt;&lt; a &lt;&lt; <span class="string">", b = "</span>&lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">swap(a, b);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"After swap(): a ="</span> &lt;&lt; a &lt;&lt; <span class="string">", b = "</span>&lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p>
<h4 id="exchange"><a href="#exchange" class="headerlink" title="exchange()"></a>exchange()</h4><p><code>std::exchange()</code>在<code>&lt;utility&gt;</code>中定义，用新值替换旧值，并返回旧值，如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">11</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">22</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Before exchange(): a = "</span>&lt;&lt; a &lt;&lt; <span class="string">", b = "</span>&lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">int</span> returnedValue = exchange(a, b);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"After exchange(): a = "</span> &lt;&lt; a &lt;&lt; <span class="string">", b = "</span>&lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p>
<p><code>exchange()</code>用于实现移动赋值运算符。移动赋值运算符需要将数据从源对象移到目标对象。通常，源对象中的数据会变为null。</p>
<h3 id="分区算法"><a href="#分区算法" class="headerlink" title="分区算法"></a>分区算法</h3><p><code>partition_copy()</code>算法将来自某个来源的元素复制到两个不同的目标。为每个元素选择特定目标的依据是谓词的结果：true或false。<code>partition_copy()</code>的返回值是一对迭代器：一个迭代器引用第一个目标范围内最后复制的那个元素的后一个位置，另一个迭代器引用第二个目标范围内最后复制的那个元素的后一个位置。将这些返回的迭代器与<code>erase()</code>结合使用，可删除两个目标范围内多余的元素。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec1, vecodd, veceven;</span><br><span class="line">vecodd.resize(size(vec1));</span><br><span class="line">vecEven.resize(size(vec1));</span><br><span class="line"><span class="keyword">auto</span> pairIters = partition_copy(cbegin(vec1), cend(vec1), begin (veceven), begin (vecodd), [](<span class="keyword">int</span> i)&#123;<span class="keyword">return</span> i%<span class="number">2</span> == <span class="number">0</span>;&#125;);</span><br><span class="line">vecEven.erase(pairIters.first, end(veceven));</span><br><span class="line">vecodd.erase (pairIters.second, end(vecodd));</span><br></pre></td></tr></table></figure></p>
<p><code>partition()</code>算法对序列排序，使谓词返回true的所有元素放在前面，使谓词返回false的所有元素放在后面，在每个分区中不保留元素最初的顺序。下例演示了如何把vector分为偶数在前、奇数在后的分区：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">partition(begin(vec), end(vec), [] (<span class="keyword">int</span> i) &#123;<span class="keyword">return</span> i%<span class="number">2</span>==<span class="number">0</span>;&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3><p>“排序算法”重新排列容器中元素的顺序，使集合中的元素保持连续顺序。因此，<strong>排序算法只能应用于顺序集合</strong>。通用的排序算法最适用于vector、deque、array和C风格数组。<code>sort()</code>函数一般情况下在<code>O(NlogN)</code>时间内对某个范围内的元素排序。将<code>sort()</code>应用于一个范围之后，根据运算符<code>operator&lt;</code>，这个范围内的元素以非递减顺序排列(最低到最高)。如果不希望使用这个顺序，可以指定一个不同的比较回调，例如greater。<code>sort()</code>函数的一个名为<code>stable_sort()</code>的变体能保持范围内相等元素的相对顺序。然而，由于这个算法需要维护范围内相等元素的相对顺序，因此这个算法比<code>sort()</code>算法低效。</p>
<h3 id="二叉树搜索算法"><a href="#二叉树搜索算法" class="headerlink" title="二叉树搜索算法"></a>二叉树搜索算法</h3><p>有几个搜索算法只用于有序序列或至少已分区的元素序列。这些算法有<code>binary_search()</code>、<code>lower_bound()</code>、<code>upper_bound()</code>和<code>equal_range()</code>。<code>lower_bound()</code>、<code>upper_bound()</code>和<code>equal_range()</code>算法类似于map和set容器中的对应方法。</p>
<p><code>lower_bound()</code>算法在有序范围内查找不小于(即大于或等于)给定值的第一个元素，经常用于发现在有序的vector中应将新值插入哪个位置，使vector依然有序。下面是一个示例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> iter = lower_bound(begin (vec), end(vec), num);</span><br><span class="line">vec.insert(iter, num);</span><br></pre></td></tr></table></figure></p>
<p><code>binary_search()</code>算法以对数时间而不是线性时间搜索元素，需要指定范围的首尾迭代器、要搜索的值以及可选的比较回调。如果在指定范围内找到这个值，这个算法返回true，否则返回false。 下面的例子演示了这个算法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (binary_search(cbegin (vec), cend(vec)，num))</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"That number is in the vector."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="集合算法"><a href="#集合算法" class="headerlink" title="集合算法"></a>集合算法</h3><p>集合算法可用于任意有序范围。<code>includes()</code>算法实现了标准的子集判断功能，检查某个有序范围内的所有元素是否包含在另一个有序范围内，顺序任意。</p>
<p><code>set_union()</code>、<code>set_intersection()</code>、<code>set_difference()</code>、<code>set_symmetric_difference()</code>算法实现了这些操作的标准语义。在集合论中，并集得到的结果是两个集合中的所有元素。交集得到的结果是所有同时存在于两个集合中的元素。差集得到的结果是所有存在于第一个集合中，但是不存在于第二个集合中的元素。对称差集得到的结果是两个集合的“异或”：所有存在于其中一个集合中，但不同时存在于两个集合中的元素。</p>
<p>务必确保结果范围足够大，以保存操作的结果。对于<code>set_union()</code>和<code>set_symmetric_difference()</code>，结果大小的上限是两个输入范围的总和。对于<code>set_intersection()</code>，结果大小的上限是两个输入范围的最小大小。对于<code>set_difference()</code>结果大小的上限是第一个输入范围的大小。</p>
<p>不能使用关联容器(包括set)中的迭代器范围来保存结果，因为这些容器不允许修改键。下面是这些算法的使用示例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (includes(cbegin(vec1), cend(vec1), cbegin (vec2), cend(vec2)))</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"The second set is a subset of the first."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> newEnd = set_union(cbegin (vec1), cend(vecl), cbegin (vec2), cend (vec2), begin(result));</span><br></pre></td></tr></table></figure></p>
<p><code>merge()</code>算法可将两个排好序的范围归并在一起，并保持排好的顺序。结果是一个包含两个源范围内所有元素的有序范围。这个算法的复杂度为线性时间。这个算法需要以下参数：</p>
<ul>
<li>第一个源范围的首尾迭代器</li>
<li>第二个源范围的首尾迭代器</li>
<li>目标范围的起始迭代器</li>
<li>(可选)比较回调</li>
</ul>
<p>如果没有<code>merge()</code>，还可通过串联两个范围，然后对串联的结果应用<code>sort()</code>，以达到同样的目的，但这样做的效率更低，复杂度为<code>O(NlogN)</code>而不是<code>merge()</code>的线性复杂度。</p>
<h3 id="最大-最小算法"><a href="#最大-最小算法" class="headerlink" title="最大/最小算法"></a>最大/最小算法</h3><p><code>min()</code>和<code>max()</code>算法通过运算符<code>operator&lt;</code>或用户提供的二元谓词比较两个或多个任意类型的元素，分别返回一个引用较小或较大元素的const引用。<code>minmax()</code>算法返回一个包含两个或多个元素中最小值和最大值的pair。这些算法不接收迭代器参数。还有使用迭代器范围的<code>min_element()</code>、<code>max_element()</code>和<code>minmax_element()</code>。下面的程序给出了一些示例：</p>
<h3 id="并行算法"><a href="#并行算法" class="headerlink" title="并行算法"></a>并行算法</h3><p>对于60多种标准库算法，C++17支持并行执行它们以提高性能，示例包括<code>for_each()</code>、<code>all_of()</code>、<code>copy()</code>、<code>count_if()</code>、<code>find()</code>、<code>replace()</code>、<code>search()</code>、<code>sort()</code>和<code>transform(}</code>等。支持并行执行的算法包含选项，接收所谓的执行策略作为第一个参数。</p>
<p>执行策略允许指定是否允许算法以并行方式或矢量方式执行。有三类标准执行策略，以及这些类型的三个全局实例，它们全部定义在<code>std::execution</code>名称空间的<code>&lt;execution&gt;</code>头文件中。如表所示。</p>
<table>
<thead>
<tr>
<th>执行策略类型</th>
<th>全局实例</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>sequenced_policy|seq|不允许算法并行执行|<br>parallel_policy|par|允许算法并行执行|<br>parallel_unscquenced_policy|par_unscq|允许算法并行执行和矢量化执行，还允许在线程之间迁移执行|</p>
<p>注意，使算法使用parallel_unsequenced_policy执行策略，以允许对回调进行交错函数调用，即不按顺序执行，这意味着会对函数回调施加诸多限制。例如，不能分配释放内存、获取互斥以及使用非锁<code>std::atomics</code>等。对于其他标准策略，函数调用按顺序执行，但顺序无法确定。此类策略不会对函数调用操作施加限制。</p>
<p>下例使用并行策略，对vector的内容进行排序：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort(<span class="built_in">std</span>::execution::par, begin (myVector), end(myVector));</span><br></pre></td></tr></table></figure></p>
<h3 id="数值处理算法"><a href="#数值处理算法" class="headerlink" title="数值处理算法"></a>数值处理算法</h3><h4 id="inner-product"><a href="#inner-product" class="headerlink" title="inner_product()"></a>inner_product()</h4><p><code>&lt;numeric&gt;</code>中定义的<code>inner_product()</code>算法计算两个序列的内积，例如，下面程序中的内积计算为<code>(1*9)+(2*8)+(3*7)+(4*6)</code>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2&#123;<span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>&#125;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; inner_product(cbegin(v1)，cend(v1), cbegin(v2), <span class="number">0</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p>
<h4 id="iota"><a href="#iota" class="headerlink" title="iota()"></a>iota()</h4><p><code>&lt;numeric&gt;</code>头文件中定义的<code>iota()</code>算法会生成指定范围内的序列值，从给定的值开始，并应用<code>operator++</code>来生成每个后续值。下面的例子展示了如何将这个新算法用于整数的vector，不过要注意这个算法可用于任意实现了<code>operator++</code>的元素类型：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec(<span class="number">10</span>);</span><br><span class="line">iota(begin (vec), end(vec), <span class="number">5</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i : vec) </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p>
<h4 id="gcd-和lcm"><a href="#gcd-和lcm" class="headerlink" title="gcd()和lcm()"></a>gcd()和lcm()</h4><p><code>gcd()</code>算法返回两个整数的最大公约数，而<code>lcm()</code>算法返回两个整数的最小公倍数。它们都定义在<code>&lt;numeric&gt;</code>中。下面是一个示例：</p>
<h4 id="reduce"><a href="#reduce" class="headerlink" title="reduce()"></a>reduce()</h4><p>需要使用新引入的<code>std:reduce()</code>算法，通过并行执行选项，计算广义和。例如，以下两行同样是求和，但是<code>reduce()</code>以并行和矢量化方式运行，因此速度更快，对于大型输入范围尤其如此：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> result1 = <span class="built_in">std</span>::accumulate(cbegin(vec), cend(vec)，<span class="number">0.0</span>);</span><br><span class="line"><span class="keyword">double</span> result2 = <span class="built_in">std</span>::reduce(<span class="built_in">std</span>::execution::par_unseq, cbegin(vec), cend(vec));</span><br></pre></td></tr></table></figure></p>
<h4 id="transform-reduce"><a href="#transform-reduce" class="headerlink" title="transform_reduce()"></a>transform_reduce()</h4><p><code>std::inner_product()</code>是另一个不支持并行执行的算法。 相反，需要使用广义的<code>transform_reduce()</code>算法，它具有并行执行选项，可用于计算内积等。</p>
<h1 id="字符串的本地化与正则表达式"><a href="#字符串的本地化与正则表达式" class="headerlink" title="字符串的本地化与正则表达式"></a>字符串的本地化与正则表达式</h1><h2 id="本地化"><a href="#本地化" class="headerlink" title="本地化"></a>本地化</h2><h3 id="本地化字符串字面量"><a href="#本地化字符串字面量" class="headerlink" title="本地化字符串字面量"></a>本地化字符串字面量</h3><p>为能正确地本地化字符串，可采用下面的方式来实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; Format (IDS_TRANSFERRED, n) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p>
<p><code>IDS_TRANSFERRED</code>是字符串资源表中一个条目的名称。对于英文版，<code>IDS_TRANSFERRED</code>可定义为<code>&quot;Read $1 bytes&quot;</code>；对于荷兰语版，这条资源可以定义为<code>&quot;$1 bytes gelezen&quot;</code>。<code>Format()</code>函数加载字符串资源，并将<code>$1</code>替换为n的值。</p>
<h3 id="宽字符"><a href="#宽字符" class="headerlink" title="宽字符"></a>宽字符</h3><p>用字节表示字符的问题在于，并不是所有的语言(或字符集)都可以用8位(即1个字节)来表示。C++有一种内建类型<code>wchar_t</code>，可以保存宽字符(wide character)。带有非ASCII字符的语言，例如日语和阿拉伯语，在C++中可以用<code>wchar_t</code>表示。然而，C++标准并没有定义<code>wchar_t</code>的大小。一些编译器使用16位，而另一些编译器使用32位。</p>
<p>在使用<code>wchar_t</code>时，需要在字符串和字符字面量的前面加上字母L，以表示应该使用宽字符编码。例如，要将<code>wchar_t</code>字符初始化为字母m，应该编写以下代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wchar_t</span> myWideCharacter = <span class="string">L"m"</span>;</span><br></pre></td></tr></table></figure></p>
<p>大部分常用类型和类都有宽字符版本。宽字符版本的string类为wstring。“前缀字母w”模式也可以应用于流。wofstrcam处理宽字符文件输出流，wifstream处理宽字符文件输入流。cout、cin、cerr和clog也有宽字节版本：wcout、wcin、wcerr和wclog。这些版本的使用和非宽字节版本的使用没有区别：</p>
<h3 id="非西方字符集"><a href="#非西方字符集" class="headerlink" title="非西方字符集"></a>非西方字符集</h3><p>宽字符是很大的进步，因为宽字符增加了定义一个字符可用的空间。在宽字符集中，和ASCII一样，字符用编号表示，现在称为码点。唯一的区别在于编号不能放在8个位中。下面的列表总结了支持的所有字符类型。</p>
<ul>
<li>char：存储8个位。可用于保存ASCII字符，还可用作保存UTF-8编码的Unicode字符的基本构建块。使用UTF-8时，一个Unicode字符编码为1到4个char。</li>
<li>char16_t：存储16个位。可用作保存UTF-16编码的Unicode字符的基本构建块。其中，一个Unicode字符编码为一个或两个charl6_t。</li>
<li>char32_t：存储至少32个位。可用于保存UTF-32编码的Unicode字符，每个字符编码为一个char32_t。</li>
<li>wchar_t：保存一个宽字符，宽字符的大小和编码取决于编译器。</li>
</ul>
<p>使用char16_t和char32_t而不是wchar_t的好处在于：char16_t的大小至少16位，char32_t的大小至少32位，它们的大小和编译器无关，而wchar_t不能保证最小的大小。</p>
<p>C++标准还定义了以下两个宏。</p>
<ul>
<li><code>__STDC_UTF_32__</code>：如果编译器定义了这个宏，那么类型char32_t使用UTF-32编码。如果没有定义这个宏，那么类型char32_t使用与编译器相关的编码。</li>
<li><code>__STDC_UTF_16__</code>：如果编译器定义了这个宏，那么类型char16_I使用UTF-16编码。如果没有定义这个宏，那么类型char16_t使用与编译器相关的编码。</li>
</ul>
<p>使用字符串前缀可将字符串字面量转换为特定类型。下面列出所有支持的字符串前缀。</p>
<ul>
<li>u8：采用UTF-8编码的char字符串字面量</li>
<li>u：表示char16_t字符串字面量，如果编译器定义了<code>__STDC_UTF_16__</code>宏，则表示UTF-16编码。</li>
<li>U：表示char32_t字符串字面量，如果编译器定义了<code>__STDC_UTF_32__</code>宏，则表示UTF-32编码。</li>
<li>L：采用编译器相关编码的wchar_t字符串字面量。</li>
</ul>
<p>所有这些字符串字面量都可与第2章介绍的原始字符串字面量前缀R结合使用。例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* s1 = <span class="string">u8R"(Raw UTF-8 encoded string literal)"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">wchar_t</span>* s2 = <span class="string">LR"(Raw wide string literal)"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char16_t</span>* s3 = <span class="string">uR"(Raw char16_t string literal)"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char32_t</span>* s4 = <span class="string">UR"(Raw char32_t string literal)"</span>;</span><br></pre></td></tr></table></figure></p>
<p>如果通过u8 UTF-8字符串字面量使用了Unicode编码，或者编译器定义了<code>__STDC_UTF_16__</code>或<code>__STDC_UTF_32__</code>宏，那么在非原始字符串字面量中可通过<code>\uABCD</code>符号插入指定的Unicode码点。例如，<code>\u03C0</code>表示pi字符。</p>
<p>除<code>std::string</code>类外，目前还支持wstring、u16string和u32string。它们的定义如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="built_in">string</span> = basic_string&lt;<span class="keyword">char</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> wstring = basic_string&lt;<span class="keyword">wchar_t</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> u16string = basic_string&lt;<span class="keyword">char16_t</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> u32string = basic_string&lt;<span class="keyword">char32_t</span>&gt;;</span><br></pre></td></tr></table></figure></p>
<p>多字节字符由一个或多个依赖编译器编码的字节组成，类似于Unicode通过UTF-8用1到4个字节表示，或者通过UTF-16用一个或两个16位值表示。</p>
<h3 id="转换-1"><a href="#转换-1" class="headerlink" title="转换"></a>转换</h3><p>C++标准提供codecvt类模板，以帮助在不同编码之间转换。<code>&lt;locale&gt;</code>头文件定义了如表19-1所示的4个编码转换类。<br><img src="/img/1620376467.jpg" alt></p>
<p>在C++17之前，<code>&lt;codecvt&gt;</code>中定义了以下三种代码转换：<code>codecvt_utf8</code>、<code>codecvt_utf16</code>和<code>codecvt_utf8_utf16</code>。可通过两种简便的转换接口使用它们：<code>wstring_convert</code>和<code>wbuffer_convert</code>。</p>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>正则表达式在<code>&lt;regex&gt;</code>头文件中定义，是标准库中的一个强大工具。C++包含对以下几种语法的支持。</p>
<ul>
<li>ECMAScript：基于ECMAScript标准的语法。 ECMAScript是符合ECMA-262标准的脚本语言。</li>
<li>JavaScript：ActionScript和Jscript等语言的核心都使用ECMAScript语言标准。</li>
<li>basic：基本的POSIX语法</li>
<li>extended：扩展的POSIX语法</li>
<li>awk：POSIX awk实用工具使用的语法。</li>
<li>grep：POSIX grep实用工具使用的语法。</li>
<li>egrep：POSIX grep实用工具使用的语法，包含E参数，</li>
</ul>
<h3 id="ECMAScript语法"><a href="#ECMAScript语法" class="headerlink" title="ECMAScript语法"></a>ECMAScript语法</h3><p>正则表达式模式是一个字符序列，这种模式表达了要匹配的内容。正则表达式中的任何字符都表示匹配自己，但以下特殊字符除外：<code>^ $ \ . * ? () [] {} |</code>下面将逐一讲解这些特殊字符。如果需要匹配这些特殊字符，那么需要通过\字符将其转义</p>
<h4 id="锚点"><a href="#锚点" class="headerlink" title="锚点"></a>锚点</h4><p>特殊字符<code>^</code>和<code>$</code>称为锚点(anchor)。<code>^</code>字符匹配行终止符前面的位置，<code>$</code>字符匹配行终止符所在的位置。<code>^</code>和<code>$</code>默认还分别匹配字符串的开头和结尾位置，但可以禁用这种行为。</p>
<p>例如，<code>^test$</code>只匹配字符串<code>test</code>，不匹配包含<code>test</code>和其他任何字符的字符串，例如<code>Itest</code>、<code>test2</code>和<code>testabc</code>等。</p>
<h4 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h4><p>通配符(wildcard)可用于匹配除换行符外的任意字符。例如，正则表达式<code>a.c</code>可以匹配<code>abc</code>和<code>aSc</code>，但不匹配<code>ab5c</code>和<code>ac</code>。</p>
<h4 id="替代"><a href="#替代" class="headerlink" title="替代"></a>替代</h4><p><code>|</code>字符表示“或”的关系。例如，<code>a|b</code>表示匹配<code>a</code>或<code>b</code>。</p>
<h4 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h4><p>圆括号<code>()</code>用于标记子表达式，子表达式也称为捕捉组(capture group)。捕捉组有以下用途：</p>
<ul>
<li>捕捉组可用于识别源字符串中单独的子序列，在结果中会返回每一个标记的子表达式(捕捉组)。以如下正则表达式为例：<code>(.)(ab|cd)(.)</code>。 其中有3个标记的子表达式。对字符串<code>1cd4</code>运行<code>regex_search()</code>，执行这个正则表达式会得到含有4个条目的匹配结果。第一个条目是完整匹配<code>1cd4</code>，接下来的3个条目是3个标记的子表达式。这3个条目为：<code>1</code>、<code>cd</code>和<code>4</code>。</li>
<li>捕捉组可在匹配的过程中用于后向引用(back reference)的目的。</li>
<li>捕捉组可在替换操作的过程中用于识别组件。</li>
</ul>
<h4 id="重复"><a href="#重复" class="headerlink" title="重复"></a>重复</h4><p>使用以下4个重复字符可重复匹配正则：表达式中的部分模式：</p>
<ul>
<li><code>*</code>匹配零次或多次之前的部分。例如：<code>a*b</code>可匹配<code>b</code>、<code>ab</code>、<code>aab</code>和<code>aaaab</code>等字符串。</li>
<li><code>+</code>匹配一次或多次之前的部分。例如：<code>a+b</code>可匹配<code>ab</code>、<code>aab</code>和<code>aaaab</code>等字符串，但不能匹配<code>b</code>。</li>
<li><code>?</code>匹配零次或一次之前的部分。例如：<code>a?b</code>匹配<code>b</code>和<code>ab</code>，不能匹配其他任何字符串。</li>
<li><code>{...}</code>表示区间重复。<code>a{n}</code>重复匹配<code>a</code>正好n次；<code>a{n,}</code>重复将a匹配n次或更多次；<code>a{n,m}</code>重复将<code>a</code>匹配n到m次，包含n次和m次。例如，<code>^a{3,4}$</code>可以匹配<code>aaa</code>和<code>aaaa</code>，但不能匹配<code>a</code>、<code>aa</code>和<code>aaaaa</code>等字符串。</li>
</ul>
<p>以上列表中列出的重复匹配字符称为贪婪匹配，因为这些字符可以找出最长匹配，但仍匹配正则表达式的其余部分。为进行非贪婪匹配，可在重复字符的后面加上一个<code>?</code>，例如<code>*?</code>、<code>+?</code>、<code>??</code>和<code>{...}?</code>。非贪婪匹配将其模式重复尽可能少的次数，但仍匹配正则表达式的其余部分。</p>
<h4 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h4><p>与数学公式一样，正则表达式中元素的优先级也很重要。正则表达式的优先级如下。</p>
<ul>
<li>元素：例如a，是正则表达式最基本的构建块.</li>
<li>量词：例如<code>+</code>、<code>*</code>、<code>?</code>和<code>{...}</code>，紧密绑定至左侧的元素，例如<code>b+</code>。</li>
<li>串联：例如<code>ab+c</code>，在量词之后绑定，</li>
<li>替代符：例如，最后绑定。</li>
</ul>
<p>例如正则表达式<code>ab+c|d</code>，它匹配<code>abc</code>、<code>abbc</code>和<code>abbbc</code>等字符串，还能匹配<code>d</code>。圆括号可以改变优先级顺序。例如，<code>ab+(c|d)</code>可以匹配abc、abbc、abbbc、 …abd、abbd和abbbd等字符串。不过，如果使用了圆括号，也意味着将圆括号内的内容标记为子表达式或捕捉组。</p>
<h4 id="字符集合匹配"><a href="#字符集合匹配" class="headerlink" title="字符集合匹配"></a>字符集合匹配</h4><p><code>(a|b|c|...|z)</code>这种表达式既冗长，又会引入捕捉组，为了避免这种正则表达式，可以使用一种特殊的语法，指定一组字符或字符的范围。此外，还可以使用“否定”形式的匹配。在方括号之间指定字符集合，<code>[c1c2...cn]</code>可以匹配字符c1、c2、…、cn中的任意字符。例如，<code>[abc]</code>可以匹配a、b和c中的任意字符。如果第一 一个字符是<code>^</code>表示“除了这些字符之外的任意字符”:</p>
<ul>
<li><code>ab[cde]</code>匹配<code>abc</code>、<code>abd</code>和<code>abe</code></li>
<li><code>ab[^cde]</code>匹配<code>abf</code>和<code>abp</code>等字符串，但不匹配<code>abc</code>、<code>abd</code>和<code>abe</code></li>
</ul>
<p>如果想要指定所有字母，可编写下面这样的字符集合：</p>
<ul>
<li>使用方括号内的范围描述，这允许使用<code>[a-zA-Z]</code>这样的表达方式，这种表达方式能识别a到z和A到Z范围内的所有字母。如果需要匹配连字符，则需要转义这个字符，例如<code>[a-zA-Z\-]+</code>匹配任意单词，包括带连字符的单词。</li>
</ul>
<h4 id="词边界"><a href="#词边界" class="headerlink" title="词边界"></a>词边界</h4><p>词边界(word boundary的意思可能是：</p>
<ul>
<li>如果源字符串的第一个字符在单词字符(即字母、数字或下划线)之后，则表示源字符串的开头位置。匹配源字符串的开头位置默认为启用，但也可以禁用。</li>
<li>如果源字符串的最后一个字符是单词字符之一，则表示源字符串的结束位置。匹配源字符串的结束位置默认为启用，但也可以禁用。</li>
<li>单词的第一个字符，这个字符是单词字符之一，而且之前的字符不是单词字符。</li>
<li>单词的结尾字符，这是单词字符之后的非单词字符，之前的字符是单词字符。</li>
</ul>
<p>通过\b可匹配单词边界，通过\B匹配除单词边界外的任何内容。</p>
<h4 id="后向引用"><a href="#后向引用" class="headerlink" title="后向引用"></a>后向引用</h4><p>通过后向引用可引用正则：表达式本身的捕捉组：<code>\n</code>表示第n个捕捉组，且n&gt;0。例如，正则表达式<code>(d+)-.*-\1</code>匹配以下格式的字符串：</p>
<ul>
<li>在一个捕捉组中<code>(d+)</code>捕捉的一个或多个数字</li>
<li>接下来是一个连字符<code>-</code></li>
<li>接下来是0个或多个字符<code>.*</code></li>
<li>接下来是另一个连字符<code>-</code></li>
<li>接下来是第一个捕捉组捕捉到的相同数字<code>\1</code></li>
</ul>
<p>这个正则表达式能匹配<code>123-abc-123</code>和<code>1234-a-1234</code>等字符串，但不能匹配<code>123-abc-1234</code>和<code>123-abc-321</code>等字符串。</p>
<h3 id="regex库"><a href="#regex库" class="headerlink" title="regex库"></a>regex库</h3><p>正则表达式库的所有内容都在<code>&lt;regex&gt;</code>头文件和std名称空间中。正则表达式库中定义的基本模板类型包括如下几种</p>
<ul>
<li>basic_regex：表示某个特定正则表达式的对象。</li>
<li>match_results：匹配正则表达式的子字符串，包括所有的捕捉组。它是sub_match的集合。</li>
<li>sub_match：包含输入序列中一个迭代器对的对象，这些迭代器表示匹配的特定捕捉组。迭代器对中的一个迭代器指向匹配的捕捉组中的第一个字符，另一个迭代器指向匹配的捕捉组中最后一个字符后面的那个字符。它的<code>str()</code>方法把匹配的捕捉组返回为字符串</li>
</ul>
<p>regex库提供了3个关键算法：<code>regex_match()</code>、<code>regex_search()</code>和<code>regex_replace()</code>。所有这些算法都有不同的版本，不同的版本允许将源字符串指定为STL字符串、字符数组或表示开始和结束的迭代器对。迭代器可以具有以下类型：</p>
<ul>
<li><code>const char*</code></li>
<li><code>const wchar_t*</code></li>
<li><code>string::const_iterator</code></li>
<li><code>wstring::const_iterator</code></li>
</ul>
<p>regex库还定义了以下两类正则表达式迭代器，这两类正则表达式迭代器非常适合于查找源字符串中的所有模式</p>
<ul>
<li><code>regex_iterator</code>：遍历一个模式在源字符串中出现的所有位置。</li>
<li><code>regex_token_iterator</code>：遍历一个模式在源字符串中出现的所有捕捉组。</li>
</ul>
<p>为方便regex库的使用，C++标准定义了很多属于以上模板的类型别名，如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> regex = basic_regex&lt;<span class="keyword">char</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> wregex = basic_regex&lt;<span class="keyword">wchar_t</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> csub_match = sub_match&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt;;</span><br><span class="line"><span class="keyword">using</span> wcsub_match = sub_match&lt;<span class="keyword">const</span> <span class="keyword">wchar_t</span>*&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> ssub_match = sub_match&lt;<span class="built_in">string</span>::const_iterator&gt;;</span><br><span class="line"><span class="keyword">using</span> wssub_match = sub_match&lt;wstring::const_iterator&gt;;</span><br><span class="line"><span class="keyword">using</span> cmatch = match_results&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt;;</span><br><span class="line"><span class="keyword">using</span> wcmatch = match_results&lt;<span class="keyword">const</span> <span class="keyword">wchar_t</span>*&gt;;</span><br><span class="line"><span class="keyword">using</span> smatch = match_results&lt;<span class="built_in">string</span>::const_iterator&gt;;</span><br><span class="line"><span class="keyword">using</span> wsmatch = match_results&lt;wstring::const_iterator&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> cregex_iterator = regex_iterator&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt;;</span><br><span class="line"><span class="keyword">using</span> wcregex_iterator = regex_iterator&lt;<span class="keyword">const</span> <span class="keyword">wchar_t</span>*&gt;;</span><br><span class="line"><span class="keyword">using</span> sregex_iterator = regex_iterator&lt;<span class="built_in">string</span>::const_iterator&gt;;</span><br><span class="line"><span class="keyword">using</span> wsregex_iterator = regex_iterator&lt;wstring::const_iterator&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> cregex_token_iterator = regex_token_iterator&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt;;</span><br><span class="line"><span class="keyword">using</span> wcregex_token_iterator = regex_token_iterator&lt;<span class="keyword">const</span> <span class="keyword">wchar_t</span>*&gt;;</span><br><span class="line"><span class="keyword">using</span> sregex_token_iterator = regex_token_iterator&lt;<span class="built_in">string</span>::const_iterator&gt;;</span><br><span class="line"><span class="keyword">using</span> wsregex_token_iterator = regex_token_iterator&lt;wstring::const_iterator&gt;;</span><br></pre></td></tr></table></figure></p>
<h3 id="regex-match"><a href="#regex-match" class="headerlink" title="regex_match()"></a>regex_match()</h3><p><code>regex_match()</code>算法可用于比较给定的源字符串和正则表达式模式。如果正则表达式模式匹配整个源字符串，则返回true，否则返回false。这个算法很容易使用。<code>regex_match()</code>算法有6个版本，这些版本接收不同类型的参数。它们都使用如下形式：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;...&gt;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">regex_match</span> <span class="params">(InputSequence[, MatchResults], RegEx[, Flags])</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>InputSequence可以表示为：</p>
<ul>
<li>源字符串的首尾迭代器</li>
<li>std::string</li>
<li>C风格的字符串</li>
</ul>
<p>可选的MatchResults参数是对<code>match_results</code>的引用，它接收匹配。如果<code>regex_match()</code>返回false，就只能调用<code>match_results::empty()</code>或<code>match_results::size()</code>，其余内容都未定义。如果<code>regex_match()</code>，返回true表示找到匹配，可以通过<code>match_results</code>对象查看匹配的具体内容。</p>
<p><code>RegEx</code>参数是需要匹配的正则表达式。可选的Flags参数指定匹配算法的选项。大多数情况下，可使用默认选项。</p>
<h3 id="regex-search"><a href="#regex-search" class="headerlink" title="regex_search()"></a>regex_search()</h3><p>如果整个源字符串匹配正则表达式，那么前面介绍的<code>regex_match()</code>算法返回true，否则返回false。这个算法不能用于查找源字符串中匹配的子字符串，但通过<code>regex_search()</code>算法可以在源字符串中搜索匹配特定模式的子字符串。<code>regex_search()</code>算法有6个不同版本。 它们都具有如下形式：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;...&gt;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">regex_search</span><span class="params">(InputSequence[, MatchResults], RegEx[,Flags])</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>在输入字符串中找到匹配时，所有变体返回true，否则返回false；参数类似于<code>regex_match()</code>的参数。有两个版本的<code>regex_search()</code>算法接收要处理的字符串的首尾迭代器。你可能想在循环中使用<code>regex_search()</code>的这个版本，通过操作每个<code>regex_search()</code>调用的首尾迭代器，找到源字符串中某个模式的所有实例。千万不要这样做!如果正则表达式中使用了锚点(<code>^</code>或<code>$</code>)和单词边界等，这样的程序会出问题。由于空匹配，这样会产生无限循环。</p>
<h3 id="regex-iterator"><a href="#regex-iterator" class="headerlink" title="regex_iterator"></a>regex_iterator</h3><p>根据前面的解释，绝对不要在循环中通过<code>regex_search()</code>获得模式在源字符串中的所有实例。应改用<code>regex_iterator</code>或<code>regex_token_iterator</code>。这两个迭代器和标准库容器的迭代器类似。</p>
<h4 id="regex-iterator示例"><a href="#regex-iterator示例" class="headerlink" title="regex_iterator示例"></a>regex_iterator示例</h4><p>这个例子中的正则表达式为<code>[\\w]+</code>，以搜索一个或多个单词字母。这个例子使用<code>std::string</code>作为来源，所以使用<code>sregex_iterator</code>作为迭代器。 这里使用了标准的迭代器循环，但是在这个例子中，尾迭代器的处理和普通标准库容器的尾迭代器稍有不同。一般情况下，需要为某个特定的容器指定尾迭代器，但对于<code>regex_iterator</code>，只有一个end迭代器。只需要通过默认的构造函数声明<code>regex_iterator</code>类型，就可获得这个尾迭代器。</p>
<p>for循环创建了一个首迭代器iter，它接收源字符串的首尾迭代器以及正则表达式作为参数。每次找到匹配时调用循环体，在这个例子中是每个单词。<code>sregex_iterator</code>遍历所有的匹配。通过解引用<code>sregex_iterator</code>，可得到一个smatch对象。访问这个smatch对象的第一个元素[0]可得到匹配的子字符串：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">regex <span class="title">reg</span><span class="params">(<span class="string">"[\\w]+"</span>)</span></span>;</span><br><span class="line"><span class="keyword">const</span> sregex_iterator end;</span><br><span class="line"><span class="keyword">for</span> (sregex_iterator iter(cbegin(str), cend(str), reg);</span><br><span class="line">    iter != end; ++iter)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (*iter)[<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p>
<p>从这个例子中可以看出，即使是简单的正则表达式，也能执行强大的字符串操作。</p>
<p>注意，<code>regex_iterator</code>和<code>regex_token_iterator</code>在内部都包含一个指向给定正则表达式的指针。它们都显式删除接收右值正则表达式的构造函数，因此无法使用临时regex对象构建它们。例如，下面的代码无法编译：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (sregex_iterator iter (cbegin(stc), cend(str), regex(<span class="string">"[\\w]+"</span>)); iter != end; ++iter)</span><br></pre></td></tr></table></figure></p>
<h3 id="regex-token-iterator"><a href="#regex-token-iterator" class="headerlink" title="regex_token_iterator"></a>regex_token_iterator</h3><p><code>regex_token_iterator</code>可用于在所有匹配的模式中自动遍历所有的或选中的捕捉组。<code>regex_token_iterator</code>有4个构造函数，格式如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">regex_token_iterator (BidirectionalIterator a,</span><br><span class="line">Bidirectionaliterator b,</span><br><span class="line"><span class="keyword">const</span> regex_type&amp; re</span><br><span class="line">[, SubMatches</span><br><span class="line">[, Flags1]]);</span><br></pre></td></tr></table></figure></p>
<p>所有构造函数都需要把首尾迭代器作为输入序列，还需要一个正则表达式。可选的SubMatches参数用于指定应迭代哪个捕捉组。可以用4种方式指定SubMatches:</p>
<ul>
<li>一个整数，表示要迭代的捕捉组的索引。</li>
<li>一个vector，其中的整数表示要迭代的捕捉组的索引。</li>
<li>带有捕捉组索引的initializer_list.</li>
<li>带有捕捉组索引的C风格数组</li>
</ul>
<p>忽略SubMatches或把它指定为0时，获得的迭代器将遍历索引为0的所有捕捉组，这些捕捉组是匹配整个正则表达式的子字符串。可选的Flags参数指定匹配算法的选项。大多数情况下，可以使用默认选项。</p>
<h4 id="regex-token-iterator示例"><a href="#regex-token-iterator示例" class="headerlink" title="regex_token_iterator示例"></a>regex_token_iterator示例</h4><p>可用<code>regex_token_iterator</code>重写前面的<code>regex_iterator</code>示例，如下所示。注意，与<code>regex_iterator</code>示例一样，在循环体中使用<code>*iter</code>而非<code>(*iter)[0]</code>，因为使用submatch的默认值0时，记号迭代器会自动遍历索引为0的所有捕捉组。这段代码的输出和<code>regex_iterator</code>示例完全一致：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">regex <span class="title">reg</span><span class="params">(<span class="string">"[\\w]+"</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (sregex_token_iterator iter(cbegin(str), cend(str), reg); iter != end; ++iter)</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; <span class="string">"\""</span> &lt;&lt; *iter &lt;&lt; <span class="string">"\""</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="regex-replace"><a href="#regex-replace" class="headerlink" title="regex_replace()"></a>regex_replace()</h3><p><code>regex_replace()</code>算法要求输入一个正则表达式，以及一个用于替换匹配子字符串的格式化字符串。这个格式化字符串可通过表中的转义序列，引用匹配子字符串中的部分内容。</p>
<table>
<thead>
<tr>
<th>转义序列</th>
<th>替换为</th>
</tr>
</thead>
<tbody>
<tr>
<td>$n</td>
<td>匹配第n个捕捉组的字符串，例如$1表示第一个捕捉组，$2表示第二个捕捉组，依此类推；n必须大于0</td>
</tr>
<tr>
<td>$&amp;</td>
<td>匹配整个正则表达式的字符串</td>
</tr>
<tr>
<td>$`</td>
<td>在输入序列中，在匹配正则表达式的子字符串左侧的部分</td>
</tr>
<tr>
<td>$’</td>
<td>在输入序列中，在匹配正则表达式的子字符串右侧的部分</td>
</tr>
<tr>
<td>$$</td>
<td>单个美元符号</td>
</tr>
</tbody>
</table>
<p><code>regex_replace()</code>算法有6个不同版本。这些版本之间的区别在于参数的类型。其中的4个版本使用如下格式：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">regex_replace</span> <span class="params">(InputSequence, RegEx, FormatString[, Flags])</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>这4个版本都在执行替换操作，后返回得到的字符串。InputSequence和 FormatString可以是<code>std::string</code>或C风格的字符串。RegEx参数是需要匹配的正则表达式。可选的Flags参数指定替换算法的选项。</p>
<p><code>regex_replace()</code>算法的另外两个版本采用如下形式：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">OutputIterator <span class="title">regex_replace</span> <span class="params">(OutputIterator,</span></span></span><br><span class="line"><span class="function"><span class="params">Bidirectionaliterator first,</span></span></span><br><span class="line"><span class="function"><span class="params">BidirectionalIterator last,</span></span></span><br><span class="line"><span class="function"><span class="params">RegEx, FormatString[, Flags])</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>这两个版本把得到的字符串写入给定的输出迭代器，并返回这个输出迭代器。输入序列给定为首尾迭代器。其他参数与<code>regex_replace()</code>的另外4个版本相同。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/C/" rel="tag"># C++</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/04/22/cpp中的运算符重载/" rel="next" title="C++中的运算符重载">
                <i class="fa fa-chevron-left"></i> C++中的运算符重载
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/05/02/cpp高级编程 笔记1/" rel="prev" title="C++高级编程 第四版 笔记1">
                C++高级编程 第四版 笔记1 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/header.jpg" alt="Hao Yu">
            
              <p class="site-author-name" itemprop="name">Hao Yu</p>
              <p class="site-description motion-element" itemprop="description">Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author</p>
          </div>
          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">351</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>
        	<audio controls="controls" loop="loop" preload="auto" src="/resource/xiaomeihao.mp3">
	        </audio>
	

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yuhao0102" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:yuh18@mails.tsinghua.edu.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#掌握标准库算法"><span class="nav-number">1.</span> <span class="nav-text">掌握标准库算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#算法概述"><span class="nav-number">1.1.</span> <span class="nav-text">算法概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#find-和find-if-算法"><span class="nav-number">1.1.1.</span> <span class="nav-text">find()和find_if()算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#accumulate-算法"><span class="nav-number">1.1.2.</span> <span class="nav-text">accumulate()算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在算法中使用移动语义"><span class="nav-number">1.1.3.</span> <span class="nav-text">在算法中使用移动语义</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#std-function"><span class="nav-number">1.2.</span> <span class="nav-text">std::function</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lambda表达式"><span class="nav-number">1.3.</span> <span class="nav-text">lambda表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#语法"><span class="nav-number">1.3.1.</span> <span class="nav-text">语法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#泛型lambda表达式"><span class="nav-number">1.3.2.</span> <span class="nav-text">泛型lambda表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lambda捕捉表达式"><span class="nav-number">1.3.3.</span> <span class="nav-text">lambda捕捉表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#将lambda表达式用作返回类型"><span class="nav-number">1.3.4.</span> <span class="nav-text">将lambda表达式用作返回类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#标准库算法示例"><span class="nav-number">1.3.5.</span> <span class="nav-text">标准库算法示例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#count-if"><span class="nav-number">1.3.5.1.</span> <span class="nav-text">count_if()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#generate"><span class="nav-number">1.3.5.2.</span> <span class="nav-text">generate()</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数对象"><span class="nav-number">1.4.</span> <span class="nav-text">函数对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#算术函数对象"><span class="nav-number">1.4.1.</span> <span class="nav-text">算术函数对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#透明运算符仿函数"><span class="nav-number">1.4.1.1.</span> <span class="nav-text">透明运算符仿函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#比较函数对象"><span class="nav-number">1.4.2.</span> <span class="nav-text">比较函数对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#逻辑函数对象"><span class="nav-number">1.4.3.</span> <span class="nav-text">逻辑函数对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#按位函数对象"><span class="nav-number">1.4.4.</span> <span class="nav-text">按位函数对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数对象适配器"><span class="nav-number">1.4.5.</span> <span class="nav-text">函数对象适配器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#绑定器"><span class="nav-number">1.4.5.1.</span> <span class="nav-text">绑定器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#取反器"><span class="nav-number">1.4.5.2.</span> <span class="nav-text">取反器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#not-fn"><span class="nav-number">1.4.5.2.1.</span> <span class="nav-text">not_fn</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#not1和not2"><span class="nav-number">1.4.5.2.2.</span> <span class="nav-text">not1和not2</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#调用成员函数"><span class="nav-number">1.4.5.2.3.</span> <span class="nav-text">调用成员函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#std-invoke"><span class="nav-number">1.4.6.</span> <span class="nav-text">std::invoke()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算法详解"><span class="nav-number">1.5.</span> <span class="nav-text">算法详解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#迭代器"><span class="nav-number">1.5.1.</span> <span class="nav-text">迭代器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#非修改序列算法"><span class="nav-number">1.5.2.</span> <span class="nav-text">非修改序列算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#搜索算法"><span class="nav-number">1.5.2.1.</span> <span class="nav-text">搜索算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#专用的搜索算法"><span class="nav-number">1.5.2.2.</span> <span class="nav-text">专用的搜索算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#比较算法"><span class="nav-number">1.5.2.3.</span> <span class="nav-text">比较算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#计数算法"><span class="nav-number">1.5.2.4.</span> <span class="nav-text">计数算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#修改序列算法"><span class="nav-number">1.5.3.</span> <span class="nav-text">修改序列算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#转换"><span class="nav-number">1.5.3.1.</span> <span class="nav-text">转换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#复制"><span class="nav-number">1.5.3.2.</span> <span class="nav-text">复制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#移动"><span class="nav-number">1.5.3.3.</span> <span class="nav-text">移动</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#替换"><span class="nav-number">1.5.3.4.</span> <span class="nav-text">替换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#删除"><span class="nav-number">1.5.3.5.</span> <span class="nav-text">删除</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#唯一化"><span class="nav-number">1.5.3.6.</span> <span class="nav-text">唯一化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#抽样"><span class="nav-number">1.5.3.7.</span> <span class="nav-text">抽样</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#反转"><span class="nav-number">1.5.3.8.</span> <span class="nav-text">反转</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#操作算法"><span class="nav-number">1.5.4.</span> <span class="nav-text">操作算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#for-each"><span class="nav-number">1.5.4.1.</span> <span class="nav-text">for_each()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#for-each-n"><span class="nav-number">1.5.4.2.</span> <span class="nav-text">for_each_n()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#交换算法"><span class="nav-number">1.5.5.</span> <span class="nav-text">交换算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#swap"><span class="nav-number">1.5.5.1.</span> <span class="nav-text">swap()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#exchange"><span class="nav-number">1.5.5.2.</span> <span class="nav-text">exchange()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分区算法"><span class="nav-number">1.5.6.</span> <span class="nav-text">分区算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#排序算法"><span class="nav-number">1.5.7.</span> <span class="nav-text">排序算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二叉树搜索算法"><span class="nav-number">1.5.8.</span> <span class="nav-text">二叉树搜索算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#集合算法"><span class="nav-number">1.5.9.</span> <span class="nav-text">集合算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#最大-最小算法"><span class="nav-number">1.5.10.</span> <span class="nav-text">最大/最小算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#并行算法"><span class="nav-number">1.5.11.</span> <span class="nav-text">并行算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数值处理算法"><span class="nav-number">1.5.12.</span> <span class="nav-text">数值处理算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#inner-product"><span class="nav-number">1.5.12.1.</span> <span class="nav-text">inner_product()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#iota"><span class="nav-number">1.5.12.2.</span> <span class="nav-text">iota()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#gcd-和lcm"><span class="nav-number">1.5.12.3.</span> <span class="nav-text">gcd()和lcm()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#reduce"><span class="nav-number">1.5.12.4.</span> <span class="nav-text">reduce()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#transform-reduce"><span class="nav-number">1.5.12.5.</span> <span class="nav-text">transform_reduce()</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#字符串的本地化与正则表达式"><span class="nav-number">2.</span> <span class="nav-text">字符串的本地化与正则表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#本地化"><span class="nav-number">2.1.</span> <span class="nav-text">本地化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#本地化字符串字面量"><span class="nav-number">2.1.1.</span> <span class="nav-text">本地化字符串字面量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#宽字符"><span class="nav-number">2.1.2.</span> <span class="nav-text">宽字符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#非西方字符集"><span class="nav-number">2.1.3.</span> <span class="nav-text">非西方字符集</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#转换-1"><span class="nav-number">2.1.4.</span> <span class="nav-text">转换</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#正则表达式"><span class="nav-number">2.2.</span> <span class="nav-text">正则表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ECMAScript语法"><span class="nav-number">2.2.1.</span> <span class="nav-text">ECMAScript语法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#锚点"><span class="nav-number">2.2.1.1.</span> <span class="nav-text">锚点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#通配符"><span class="nav-number">2.2.1.2.</span> <span class="nav-text">通配符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#替代"><span class="nav-number">2.2.1.3.</span> <span class="nav-text">替代</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分组"><span class="nav-number">2.2.1.4.</span> <span class="nav-text">分组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#重复"><span class="nav-number">2.2.1.5.</span> <span class="nav-text">重复</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#优先级"><span class="nav-number">2.2.1.6.</span> <span class="nav-text">优先级</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#字符集合匹配"><span class="nav-number">2.2.1.7.</span> <span class="nav-text">字符集合匹配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#词边界"><span class="nav-number">2.2.1.8.</span> <span class="nav-text">词边界</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#后向引用"><span class="nav-number">2.2.1.9.</span> <span class="nav-text">后向引用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#regex库"><span class="nav-number">2.2.2.</span> <span class="nav-text">regex库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#regex-match"><span class="nav-number">2.2.3.</span> <span class="nav-text">regex_match()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#regex-search"><span class="nav-number">2.2.4.</span> <span class="nav-text">regex_search()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#regex-iterator"><span class="nav-number">2.2.5.</span> <span class="nav-text">regex_iterator</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#regex-iterator示例"><span class="nav-number">2.2.5.1.</span> <span class="nav-text">regex_iterator示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#regex-token-iterator"><span class="nav-number">2.2.6.</span> <span class="nav-text">regex_token_iterator</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#regex-token-iterator示例"><span class="nav-number">2.2.6.1.</span> <span class="nav-text">regex_token_iterator示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#regex-replace"><span class="nav-number">2.2.7.</span> <span class="nav-text">regex_replace()</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>
  <div id="DvelopmentTarget">     
  </div>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart" aria-hidden="false"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>

  
</div>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_uv"> 
  本站访客数<span id="busuanzi_value_site_uv"></span>人次
</span>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  


  <script type="text/javascript" src="/js/src/love.js"></script>

</body>
</html>
