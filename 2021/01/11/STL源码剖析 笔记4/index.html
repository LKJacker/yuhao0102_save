<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zn-ch">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-center-simple.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="C++,">










<meta name="description" content="算法算法概观算法，问题之解法也。以有限的步骤，解决逻辑或数学上的问题，这一专门科目称为算法。STL 正是将极具复用价值的算法进行封装，包含sort,find,copy等函数。 STL算法总览表格中凡是不在STL标准规格之列的SGI专属算法，都以*加以标识。 所有的STL算法都作用在迭代器 [first,last) 所标出来的区间上。根据是否改变操作对象的值，可以分为 质变算法（mutating a">
<meta name="keywords" content="C++">
<meta property="og:type" content="article">
<meta property="og:title" content="STL 源码剖析 笔记4">
<meta property="og:url" content="http://yoursite.com/2021/01/11/STL源码剖析 笔记4/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="算法算法概观算法，问题之解法也。以有限的步骤，解决逻辑或数学上的问题，这一专门科目称为算法。STL 正是将极具复用价值的算法进行封装，包含sort,find,copy等函数。 STL算法总览表格中凡是不在STL标准规格之列的SGI专属算法，都以*加以标识。 所有的STL算法都作用在迭代器 [first,last) 所标出来的区间上。根据是否改变操作对象的值，可以分为 质变算法（mutating a">
<meta property="og:locale" content="zn-ch">
<meta property="og:image" content="http://yoursite.com/img/1610357891.jpg">
<meta property="og:image" content="http://yoursite.com/img/1610358110.jpg">
<meta property="og:image" content="http://yoursite.com/img/1610358139.jpg">
<meta property="og:image" content="http://yoursite.com/img/1610358159.jpg">
<meta property="og:image" content="http://yoursite.com/img/1610542684.jpg">
<meta property="og:image" content="http://yoursite.com/img/1610542923.jpg">
<meta property="og:image" content="http://yoursite.com/img/1610543021.jpg">
<meta property="og:image" content="http://yoursite.com/img/1610543888.jpg">
<meta property="og:image" content="http://yoursite.com/img/1610544166.jpg">
<meta property="og:image" content="http://yoursite.com/img/1610544209.jpg">
<meta property="og:image" content="http://yoursite.com/img/1610544261.jpg">
<meta property="og:image" content="http://yoursite.com/img/1610544307.jpg">
<meta property="og:image" content="http://yoursite.com/img/1610593476.jpg">
<meta property="og:image" content="http://yoursite.com/img/1610593588.jpg">
<meta property="og:image" content="http://yoursite.com/img/1610593775.jpg">
<meta property="og:image" content="http://yoursite.com/img/1610593860.jpg">
<meta property="og:image" content="http://yoursite.com/img/1610594128.jpg">
<meta property="og:image" content="http://yoursite.com/img/1610595244.jpg">
<meta property="og:image" content="http://yoursite.com/img/1610595463.jpg">
<meta property="og:image" content="http://yoursite.com/img/1610595681.jpg">
<meta property="og:image" content="http://yoursite.com/img/1610595745.jpg">
<meta property="og:image" content="http://yoursite.com/img/1610595857.jpg">
<meta property="og:image" content="http://yoursite.com/img/1610604585.jpg">
<meta property="og:image" content="http://yoursite.com/img/1610605328.jpg">
<meta property="og:image" content="http://yoursite.com/img/1610605767.jpg">
<meta property="og:image" content="http://yoursite.com/img/1610692930.jpg">
<meta property="og:image" content="http://yoursite.com/img/1610693433.jpg">
<meta property="og:image" content="http://yoursite.com/img/1610693726.jpg">
<meta property="og:image" content="http://yoursite.com/img/1610695096.jpg">
<meta property="og:image" content="http://yoursite.com/img/1610695460.jpg">
<meta property="og:image" content="http://yoursite.com/img/1610695483.jpg">
<meta property="og:image" content="http://yoursite.com/img/1610695566.jpg">
<meta property="og:image" content="http://yoursite.com/img/1610696018.jpg">
<meta property="og:updated_time" content="2021-01-16T05:48:41.007Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="STL 源码剖析 笔记4">
<meta name="twitter:description" content="算法算法概观算法，问题之解法也。以有限的步骤，解决逻辑或数学上的问题，这一专门科目称为算法。STL 正是将极具复用价值的算法进行封装，包含sort,find,copy等函数。 STL算法总览表格中凡是不在STL标准规格之列的SGI专属算法，都以*加以标识。 所有的STL算法都作用在迭代器 [first,last) 所标出来的区间上。根据是否改变操作对象的值，可以分为 质变算法（mutating a">
<meta name="twitter:image" content="http://yoursite.com/img/1610357891.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2021/01/11/STL源码剖析 笔记4/">





  <title>STL 源码剖析 笔记4 | Hao Yu's blog</title>
  








 
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zn-ch">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hao Yu's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">The program monkey was eaten by the siege lion.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/resume.pdf" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-mybetterhalf">
          <a href="/mybetterhalf/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>
            
            mybetterhalf
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/11/STL源码剖析 笔记4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">STL 源码剖析 笔记4</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-01-11T09:13:00+08:00">
                2021-01-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="算法概观"><a href="#算法概观" class="headerlink" title="算法概观"></a>算法概观</h2><p>算法，问题之解法也。以有限的步骤，解决逻辑或数学上的问题，这一专门科目称为算法。STL 正是将极具复用价值的算法进行封装，包含sort,find,copy等函数。</p>
<h3 id="STL算法总览"><a href="#STL算法总览" class="headerlink" title="STL算法总览"></a>STL算法总览</h3><p>表格中凡是不在STL标准规格之列的SGI专属算法，都以*加以标识。<br><img src="/img/1610357891.jpg" alt><br><img src="/img/1610358110.jpg" alt><br><img src="/img/1610358139.jpg" alt><br><img src="/img/1610358159.jpg" alt></p>
<p>所有的STL算法都作用在迭代器 [first,last) 所标出来的区间上。根据是否改变操作对象的值，可以分为 <strong>质变算法</strong>（mutating algorithms）和 <strong>非质变算法</strong> （nomutating algorithms）。</p>
<p>质变算法，是指运算过程中会更改区间内元素的内容的算法。比如，拷贝（copy），互换（swap），替换（replace），填写（fill），删除（remove），排列组合（permutation），分割（partition），随机重排（random shuffling），排序（sort）等。</p>
<p>非质变算法，是指运算过程中不会更改区间内元素的内容的算法。比如，查找（find），匹配（search），计数（count），巡访（for_each），比较（equal,mismatch），寻找极值（max,min）等。但是在for_each算法上应用一个会改变元素内容的仿函数，所在元素必然会改变：</p>
<h3 id="算法的泛化过程"><a href="#算法的泛化过程" class="headerlink" title="算法的泛化过程"></a>算法的泛化过程</h3><p>如何将算法独立于其所处理的数据结构之外，不受数据结构的约束？关键在于，要把操作对象的型别加以抽象化，把操作对象的标示法和区间目标的移动行为抽象化，整个算法也就在一个抽象层面上工作了。整个过程称为算法的泛型化（generalized），简称泛化。</p>
<p>以简单的循序查找为例，编写find()函数，在array中寻找特定值。面对整数array，写出如下程序：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">find</span><span class="params">(<span class="keyword">int</span>* arrayHead, <span class="keyword">int</span> arraySize, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i&lt;arraySize; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (arrayHead[i] == value)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> &amp;(arrayHead[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述find()函数写法暴露了太多的实现细节（例如arraySize），为了让find()适用于所有类型的容器，其操作应该更抽象化些。让find()接受两个指针作为参数，标示一个操作区间：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">find</span><span class="params">(<span class="keyword">int</span>* begin, <span class="keyword">int</span>*end, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(begin !=end &amp;&amp; *begin != value)</span><br><span class="line">        ++begin;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> begin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由于find()函数之内并无任何操作是针对特定整数array而发的，所以我们可以把它改成一个template：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T* <span class="title">find</span><span class="params">(T* begin, T* end, <span class="keyword">const</span> T&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 注意，以下用到了operator!=, operator*, operator++</span></span><br><span class="line">    <span class="keyword">while</span> (begin != end &amp;&amp; *begin != value)</span><br><span class="line">        ++begin;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 注意，以下返回操作用会引发copy行为</span></span><br><span class="line">    <span class="keyword">return</span> begin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在上述代码中，传入的指针必须支持以下四种操作行为：</p>
<ul>
<li>inequality 判断不相等</li>
<li>dereferencelm 提领</li>
<li>prefix increment 前置式递增</li>
<li>copy 复制</li>
</ul>
<p>上述操作符可以被重载（overload），find()函数就可以从原生（native）指针的思想框框中跳脱出来。我们可以设计一个class，拥有原生指针的行为，这就是迭代器（iterator）：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">Iterator <span class="title">find</span><span class="params">(Iterator begin, Iterator end, <span class="keyword">const</span> T&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(begin != end &amp;&amp; *begin != value)</span><br><span class="line">        ++begin;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> begin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>至此，便是完全泛型化的find()函数。</p>
<h2 id="数值算法"><a href="#数值算法" class="headerlink" title="数值算法"></a>数值算法</h2><p>C++ STL 的数值算法(Numeric algorithms)是一组对容器元素进行数值计算的模板函数，包括容器元素求和 accumulate 、两序列元素的内积 inner_product 、容器元素的一系列部分元素和 partial_sum 、容器每对相邻元素的差adjacent_difference。其头文件为<code>&lt;numeric&gt;</code>，测试实例如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file: 6numeric.cpp</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt; // minus&lt;int&gt;()</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;   // ostream_iterator</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ia[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; iv(ia, ia + <span class="number">5</span>);</span><br><span class="line">    <span class="comment">// 0+1+2+3...</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; accumulate(iv.begin(), iv.end(), <span class="number">0</span>) &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    <span class="comment">//0是初值，T accumulate(InputIterator first, InputIterator last, T init)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 0-1-2-3</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; accumulate(iv.begin(), iv.end(), <span class="number">0</span>, minus&lt;<span class="keyword">int</span>&gt;()) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 10 + 1*1 + 2*2 + ...</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; inner_product(iv.begin(), iv.end(), iv.begin(), <span class="number">10</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 10 - 1+1 - 2+2 - ...</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; inner_product(iv.begin(), iv.end(), iv.begin(), <span class="number">10</span>,</span><br><span class="line">        minus&lt;<span class="keyword">int</span>&gt;(), plus&lt;<span class="keyword">int</span>&gt;()) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 将迭代器绑定到cout，作为输出用</span></span><br><span class="line">    ostream_iterator&lt;<span class="keyword">int</span>&gt; oite(<span class="built_in">cout</span>, <span class="string">" "</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 1 3 6 10 15 累计和</span></span><br><span class="line">    partial_sum(iv.begin(), iv.end(), oite);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 1 -1 -4 -8 -13 累计差</span></span><br><span class="line">    partial_sum(iv.begin(), iv.end(), oite, minus&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 1 1 1 1 1     new #n = #n - #n-1</span></span><br><span class="line">    adjacent_difference(iv.begin(), iv.end(), oite);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 1 3 5 7 9      new #n = op(#n, #n-1)</span></span><br><span class="line">    adjacent_difference(iv.begin(), iv.end(), oite, plus&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// mingw c++ 中stl没有power实现</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; power(10, 3) &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; power(10, 3, plus&lt;int&gt;()) &lt;&lt; endl;</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">3</span>;</span><br><span class="line">    iota(iv.begin(), iv.end(), n); <span class="comment">// 填入n, n+1, n+2</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; iv.size(); ++i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; iv[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@192 6_STL_algorithms] ./6_3_1_numeric</span><br><span class="line">15</span><br><span class="line">-15</span><br><span class="line">65</span><br><span class="line">-20</span><br><span class="line">1 3 6 10 15</span><br><span class="line">1 -1 -4 -8 -13</span><br><span class="line">1 1 1 1 1</span><br><span class="line">1 3 5 7 9</span><br><span class="line">3 4 5 6 7 [</span><br></pre></td></tr></table></figure></p>
<h3 id="accumlate"><a href="#accumlate" class="headerlink" title="accumlate"></a>accumlate</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*	函数名：accumulate</span></span><br><span class="line"><span class="comment">*	功能：  将指定区间内的元素累加</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 版本1，算法缺省行为</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>,<span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span> <span class="title">accumulate</span>(<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>, <span class="title">T</span> <span class="title">init</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">for</span> (; first != last; first++)</span><br><span class="line">	&#123;</span><br><span class="line">		init = init + *first;	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> init;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 版本2，接收外界传入一个仿函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>,<span class="title">class</span> <span class="title">T</span>,<span class="title">class</span> <span class="title">BinaryOperation</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span> <span class="title">accumulate</span>(<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>, <span class="title">T</span> <span class="title">init</span>, <span class="title">BinaryOperation</span> <span class="title">binary_op</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">for</span> (; first != last; first++)</span><br><span class="line">	&#123;</span><br><span class="line">		init = binary_op(init, *first);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> init;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="adjacent-differencee"><a href="#adjacent-differencee" class="headerlink" title="adjacent_differencee"></a>adjacent_differencee</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*	函数名：	adjacent_differencee</span></span><br><span class="line"><span class="comment">*	功能：	计算[first,last)中相邻元素的差额，首元素内容不变</span></span><br><span class="line"><span class="comment">*	说明：	与partial_sum互为逆运算</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 版本1，算法缺省行为</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">OutputIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">OutputIterator</span> <span class="title">adjacent_difference</span>(<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>, <span class="title">OutputIterator</span> <span class="title">result</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">if</span> (first == last)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> result;	<span class="comment">// 区间内容为空直接返回result</span></span><br><span class="line">	&#125;</span><br><span class="line">	*result = *first;	<span class="comment">// 首先记录第一个元素(即原容器中第一个元素内容不变)</span></span><br><span class="line">	iterator_traits&lt;InputIterator&gt;::value_type value = *first;</span><br><span class="line">	<span class="keyword">while</span> (++first != last)	<span class="comment">// 之后的元素为本位置-前一个位置的值</span></span><br><span class="line">	&#123;</span><br><span class="line">		T tmp = *first;</span><br><span class="line">		*++first = tmp - value;</span><br><span class="line">		value = tmp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ++result;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 版本2，接收外界传入一个仿函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">OutputIterator</span>, <span class="title">class</span> <span class="title">BinaryOperation</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">OutputIterator</span> <span class="title">adjacent_difference</span>(<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>, </span></span><br><span class="line"><span class="class">									<span class="title">OutputIterator</span> <span class="title">result</span>, <span class="title">BinaryOperation</span> <span class="title">binary_op</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">if</span> (first == last)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> result;	<span class="comment">// 区间内容为空直接返回result</span></span><br><span class="line">	&#125;</span><br><span class="line">	*result = *first;	<span class="comment">// 首先记录第一个元素(即原容器中第一个元素内容不变)</span></span><br><span class="line">	iterator_traits&lt;InputIterator&gt;::value_type value = *first;</span><br><span class="line">	<span class="keyword">while</span> (++first != last)	</span><br><span class="line">	&#123;</span><br><span class="line">		T tmp = *first;</span><br><span class="line">		*++first = binary_op(tmp, value);</span><br><span class="line">		value = tmp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ++result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="partial-sum"><a href="#partial-sum" class="headerlink" title="partial_sum"></a>partial_sum</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*	函数名：	partial_sum</span></span><br><span class="line"><span class="comment">*	功能：	计算[first,last)中相邻元素的差额，首元素内容不变</span></span><br><span class="line"><span class="comment">*	说明：	与adjacent_difference互为逆运算</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 版本1，算法缺省行为</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">OutputIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">OutputIterator</span> <span class="title">partial_sum</span>(<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>, <span class="title">OutputIterator</span> <span class="title">result</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">if</span> (first == last)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> result;	<span class="comment">// 区间内容为空直接返回result</span></span><br><span class="line">	&#125;</span><br><span class="line">	*result = *first;	<span class="comment">// 首先记录第一个元素(即原容器中第一个元素内容不变)</span></span><br><span class="line">	iterator_traits&lt;InputIterator&gt;::value_type value = *first;</span><br><span class="line">	<span class="keyword">while</span> (++first != last)	<span class="comment">// 之后的元素为本位置+前一个位置的值</span></span><br><span class="line">	&#123;</span><br><span class="line">		value = value + *first;</span><br><span class="line">		*++result = value;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ++result;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 版本2，接收外界传入一个仿函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">OutputIterator</span>, <span class="title">class</span> <span class="title">BinaryOperation</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">OutputIterator</span> <span class="title">partial_sum</span>(<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>, </span></span><br><span class="line"><span class="class">							<span class="title">OutputIterator</span> <span class="title">result</span>, <span class="title">BinaryOperation</span> <span class="title">binary_op</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">if</span> (first == last)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> result;	<span class="comment">// 区间内容为空直接返回result</span></span><br><span class="line">	&#125;</span><br><span class="line">	*result = *first;	<span class="comment">// 首先记录第一个元素(即原容器中第一个元素内容不变)</span></span><br><span class="line">	iterator_traits&lt;InputIterator&gt;::value_type value = *first;</span><br><span class="line">	<span class="keyword">while</span> (++first != last)	</span><br><span class="line">	&#123;</span><br><span class="line">		value = binary_op(value, *first);</span><br><span class="line">		*++result = value;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ++result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="power"><a href="#power" class="headerlink" title="power"></a>power</h3><p>考虑x^23，可以先从x -&gt;x^2 -&gt; x^4 -&gt; x^8 -&gt; x^16 取result1 = x^16，然后23-16=7。<br>我们只要计算x^7再与result1相乘就可以得到x^23。对于x^7也可以采用这种方法</p>
<p>取result2 = x^4，然后7-4=3，只要计算x^3再与result2相乘就可以得到x^7。由此可以将x^23写成x^16 <em> x^4</em> x^2 <em> x，即23=16+4+2+1，而23 = 10111(二进制)，所以只要将n化为二进制并由低位到高位依次判断如果第i位为1，则result </em>=x^(2^i)。</p>
<p>此函数可以在相乘O(logN)次内计算x的n次幂，且避免了重复计算。但还可以作进一步的优化，如像48=110000(二进制)这种低位有很多0的数，可以先过滤掉低位的0再进行计算，这样也会提高一些效率。程序如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*	函数名：	power</span></span><br><span class="line"><span class="comment">*	功能：	对自己进行某种运算n次，缺省值是乘方</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 版本1，算法缺省行为</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Integer</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">T</span> <span class="title">power</span>(<span class="title">T</span> <span class="title">x</span>, <span class="title">Integer</span> <span class="title">n</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">return</span> power(x,n,multiplies&lt;T&gt;());	<span class="comment">// multiplies&lt;T&gt;()是一个仿函数的临时对象，意为相乘</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 版本2，如果指定为乘方运算，则当n &gt;= 0时返回x^n</span></span><br><span class="line"><span class="comment">// MonoidOperation必须满足结合律，可不满足交换律</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Integer</span>, <span class="title">class</span> <span class="title">MonoidOperation</span> <span class="title">op</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span> <span class="title">power</span>(<span class="title">T</span> <span class="title">x</span>, <span class="title">Integer</span> <span class="title">n</span>, <span class="title">MonoidOperation</span> <span class="title">op</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">0</span>)	<span class="comment">// 直接返回1也行</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> identity_element(op);	<span class="comment">// 取出证同元素</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>	<span class="comment">// 过滤低位的0</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> ((n &amp; <span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			n &gt;&gt;= <span class="number">1</span>;	<span class="comment">// n右移一位</span></span><br><span class="line">			x = op(x, x);	<span class="comment">// x = x op x;</span></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	T result = x;</span><br><span class="line">	n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (n != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		x = op(x, x);</span><br><span class="line">		<span class="keyword">if</span> ((n &amp; <span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			result = op(result, x);</span><br><span class="line">		&#125;</span><br><span class="line">		n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="inner-product"><a href="#inner-product" class="headerlink" title="inner_product"></a>inner_product</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*	函数名：	inner_product</span></span><br><span class="line"><span class="comment">*	功能：	计算[first1,last1)和[first2,first2+(last1 - first1))的一般内积</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 版本1，算法缺省行为</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator1</span>, <span class="title">class</span> <span class="title">InputIterator2</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span> <span class="title">inner_product</span>(<span class="title">InputIterator1</span> <span class="title">first1</span>, <span class="title">InputIterator1</span> <span class="title">last1</span>,</span></span><br><span class="line"><span class="class">				<span class="title">InputIterator2</span> <span class="title">first2</span>, <span class="title">T</span> <span class="title">init</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="comment">// 以第一序列为依据，将两个序列都走一遍</span></span><br><span class="line">	<span class="keyword">for</span> (; first1 != last1; ++first1, ++first2)</span><br><span class="line">	&#123;</span><br><span class="line">		init = init + (*first1 * *first2);	<span class="comment">//执行两个序列的一般内积</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> init;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator1</span>, <span class="title">class</span> <span class="title">InputIterator2</span>, </span></span><br><span class="line"><span class="class">		<span class="title">class</span> <span class="title">BinaryOperation1</span>, <span class="title">class</span> <span class="title">BinaryOperation2</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span> <span class="title">inner_product</span>(<span class="title">InputIterator1</span> <span class="title">first1</span>, <span class="title">InputIterator1</span> <span class="title">last1</span>,</span></span><br><span class="line"><span class="class">				<span class="title">InputIterator2</span> <span class="title">first2</span>, <span class="title">T</span> <span class="title">init</span>, </span></span><br><span class="line"><span class="class">				<span class="title">BinaryOperation1</span> <span class="title">binary_op1</span>, <span class="title">BinaryOperation2</span> <span class="title">binary_op2</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="comment">// 以第一序列为依据，将两个序列都走一遍</span></span><br><span class="line">	<span class="keyword">for</span> (; first1 != last1; ++first1, ++first2)</span><br><span class="line">	&#123;</span><br><span class="line">		init = binary_op1(init, binary_op2(*first1, *first2));	<span class="comment">//执行两个序列的一般内积</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> init;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="iota"><a href="#iota" class="headerlink" title="iota"></a>iota</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*	函数名：	iota</span></span><br><span class="line"><span class="comment">*	功能：	在区间[first,last)填入value,value+1,value+2,value+3</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">iota</span>(<span class="title">ForwardIterator</span> <span class="title">first</span>, <span class="title">ForwardIterator</span> <span class="title">last</span>, <span class="title">T</span> <span class="title">value</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">while</span> (first != last)</span><br><span class="line">	&#123;</span><br><span class="line">		*first = value++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="基本算法"><a href="#基本算法" class="headerlink" title="基本算法"></a>基本算法<stl_algobase.h></stl_algobase.h></h2><p>STL标准中没有区分基本算法或复杂算法，单SGI把常用的一些算法（equal，fill，fill_n，iter_swap，lexicographical_compare，max，min，mismatch，swap，copy，copy_backward，copy_n）定义在<code>&lt;stl_algobase.h&gt;</code>只中，其他算法定义在<code>&lt;stl_algo.h&gt;</code>中。</p>
<p>equal作用：判断[first,last)区间两个元素是否相同，第二个迭代器多出来的元素不予考虑。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIter1</span>, <span class="title">class</span> _<span class="title">InputIter2</span>&gt;//版本1</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">bool</span> <span class="title">equal</span>(_<span class="title">InputIter1</span> __<span class="title">first1</span>, _<span class="title">InputIter1</span> __<span class="title">last1</span>,</span></span><br><span class="line"><span class="class">                  _<span class="title">InputIter2</span> __<span class="title">first2</span>) &#123;</span></span><br><span class="line">  <span class="keyword">for</span> ( ; __first1 != __last1; ++__first1, ++__first2)<span class="comment">//遍历区间[first，last)元素</span></span><br><span class="line">    <span class="keyword">if</span> (*__first1 != *__first2)<span class="comment">//只有有一个不相等返回false</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIter1</span>, <span class="title">class</span> _<span class="title">InputIter2</span>, <span class="title">class</span> _<span class="title">BinaryPredicate</span>&gt;//版本2</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">bool</span> <span class="title">equal</span>(_<span class="title">InputIter1</span> __<span class="title">first1</span>, _<span class="title">InputIter1</span> __<span class="title">last1</span>,</span></span><br><span class="line"><span class="class">                  _<span class="title">InputIter2</span> __<span class="title">first2</span>, _<span class="title">BinaryPredicate</span> __<span class="title">binary_pred</span>) &#123;</span></span><br><span class="line">  <span class="keyword">for</span> ( ; __first1 != __last1; ++__first1, ++__first2)</span><br><span class="line">    <span class="keyword">if</span> (!__binary_pred(*__first1, *__first2))<span class="comment">//两个元素执行二元操作符</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>fill作用：将指定区间元素改为新值。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">fill</span>(_<span class="title">ForwardIter</span> __<span class="title">first</span>, _<span class="title">ForwardIter</span> __<span class="title">last</span>, <span class="title">const</span> _<span class="title">Tp</span>&amp; __<span class="title">value</span>) &#123;</span></span><br><span class="line">  <span class="keyword">for</span> ( ; __first != __last; ++__first)<span class="comment">//遍历整个区间</span></span><br><span class="line">    *__first = __value;<span class="comment">//指定新值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>fill_n作用：将指定区间前n个元素改为新值。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">OutputIter</span>, <span class="title">class</span> _<span class="title">Size</span>, <span class="title">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">OutputIter</span> <span class="title">fill_n</span>(_<span class="title">OutputIter</span> __<span class="title">first</span>, _<span class="title">Size</span> __<span class="title">n</span>, <span class="title">const</span> _<span class="title">Tp</span>&amp; __<span class="title">value</span>) &#123;</span></span><br><span class="line">  <span class="keyword">for</span> ( ; __n &gt; <span class="number">0</span>; --__n, ++__first)</span><br><span class="line">    *__first = __value;</span><br><span class="line">  <span class="keyword">return</span> __first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>iter_swap作用：将两个迭代器所指对象调换。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter1</span>, <span class="title">class</span> _<span class="title">ForwardIter2</span>, <span class="title">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> __<span class="title">iter_swap</span>(_<span class="title">ForwardIter1</span> __<span class="title">a</span>, _<span class="title">ForwardIter2</span> __<span class="title">b</span>, _<span class="title">Tp</span>*) &#123;</span></span><br><span class="line">  _Tp __tmp = *__a;</span><br><span class="line">  *__a = *__b;</span><br><span class="line">  *__b = __tmp;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter1</span>, <span class="title">class</span> _<span class="title">ForwardIter2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">iter_swap</span>(_<span class="title">ForwardIter1</span> __<span class="title">a</span>, _<span class="title">ForwardIter2</span> __<span class="title">b</span>) &#123;</span></span><br><span class="line">  __iter_swap(__a, __b, __VALUE_TYPE(__a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>iter_swap()</code>是“迭代器之value type派上用场的一个好例子。是的，该函数必须知道迭代器的value type，才能够据此声明一个对象，用来暂时存放迭代器所指对象。为此，上述源代码特别设计了一个双层构造，第一层调用第二层：并多出一个额外的参数<code>value_type(a)</code>。这么一来，第二层就有value type可以用了。乍见之下你可能会对这个额外参数在调用端和接受端的型别感到讶异，调用端是<code>value_type(a)</code>，接受端却是<code>T*</code>。只要找出<code>value_type()</code>的定义瞧瞧，就一点也不奇怪了：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Iterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">typename</span> <span class="title">iterator_traits</span>&lt;Iterator&gt;:</span>:<span class="function">value_type* <span class="title">value_type</span><span class="params">(<span class="keyword">const</span> Iterator&amp;)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::value_type*&gt;(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种双层构造在SGI STL源代码中十分普遍。其实这并非必要，直接这么写就行：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator1</span>, <span class="title">class</span> <span class="title">ForwardIterator2</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">iter_swap</span>(<span class="title">ForwardIterator1</span> <span class="title">a</span>, <span class="title">ForwardIterator2</span> <span class="title">b</span>) &#123;</span></span><br><span class="line">	<span class="keyword">typename</span> iterator_traits&lt;ForwardIterator1&gt;::value_type tmp = *a;</span><br><span class="line">	*a = *b;</span><br><span class="line">	*b = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>lexicographical_compare作用：以“字典排列方式”对两个序列[first1, last1)和[first2, last2)进行比较。比较操作针对两序列中的对应位置上的元素进行，并持续直到：</p>
<ul>
<li>某组对应元素彼此不相等；</li>
<li>同时到达last1和last2（当两序列的大小相同）；</li>
<li>到达last1或last2（当两序列的大小不同）</li>
</ul>
<p>当这个函数在对应位置上发现第一组不相等的元素时，有下列几种可能：</p>
<ul>
<li>如果第一序列的元素较小，返回true，否则返回false；</li>
<li>如果到达last1而尚未到达last2，返回true；</li>
<li>如果到达llast2而尚未到达last1，返回false；</li>
<li>如果同时到达last1和last2（换句话说所有元素都匹配），返回false。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字典序比较, 非常类似字符串的比较</span></span><br><span class="line"><span class="comment">// 具体比较方式参见STL文档, 另外strcmp()也可以参考</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator1</span>, <span class="title">class</span> <span class="title">InputIterator2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">lexicographical_compare</span>(<span class="title">InputIterator1</span> <span class="title">first1</span>, <span class="title">InputIterator1</span> <span class="title">last1</span>,</span></span><br><span class="line"><span class="class">			     <span class="title">InputIterator2</span> <span class="title">first2</span>, <span class="title">InputIterator2</span> <span class="title">last2</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">for</span> ( ; first1 != last1 &amp;&amp; first2 != last2; ++first1, ++first2) &#123;</span><br><span class="line">    <span class="keyword">if</span> (*first1 &lt; *first2)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (*first2 &lt; *first1)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> first1 == last1 &amp;&amp; first2 != last2;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 二元判别式自己指定, 其余同上</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator1</span>, <span class="title">class</span> <span class="title">InputIterator2</span>, <span class="title">class</span> <span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">lexicographical_compare</span>(<span class="title">InputIterator1</span> <span class="title">first1</span>, <span class="title">InputIterator1</span> <span class="title">last1</span>,</span></span><br><span class="line"><span class="class">			     <span class="title">InputIterator2</span> <span class="title">first2</span>, <span class="title">InputIterator2</span> <span class="title">last2</span>,</span></span><br><span class="line"><span class="class">			     <span class="title">Compare</span> <span class="title">comp</span>) &#123;</span></span><br><span class="line">  <span class="keyword">for</span> ( ; first1 != last1 &amp;&amp; first2 != last2; ++first1, ++first2)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (comp(*first1, *first2))</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (comp(*first2, *first1))</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> first1 == last1 &amp;&amp; first2 != last2;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 针对字符串的特化, 针对原生指针const unsigned char*，效率至上</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span></span><br><span class="line">lexicographical_compare(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>* first1,</span><br><span class="line">                        <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>* last1,</span><br><span class="line">                        <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>* first2,</span><br><span class="line">                        <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>* last2)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">size_t</span> len1 = last1 - first1;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">size_t</span> len2 = last2 - first2;</span><br><span class="line">  <span class="comment">//memcmp标准C函数</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> result = <span class="built_in">memcmp</span>(first1, first2, min(len1, len2));</span><br><span class="line">  <span class="keyword">return</span> result != <span class="number">0</span> ? result &lt; <span class="number">0</span> : len1 &lt; len2;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 针对字符串的特化, 针对原生指针const char*，效率至上</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">lexicographical_compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* first1, <span class="keyword">const</span> <span class="keyword">char</span>* last1,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">const</span> <span class="keyword">char</span>* first2, <span class="keyword">const</span> <span class="keyword">char</span>* last2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> CHAR_MAX == SCHAR_MAX</span></span><br><span class="line">  <span class="keyword">return</span> lexicographical_compare((<span class="keyword">const</span> <span class="keyword">signed</span> <span class="keyword">char</span>*) first1,</span><br><span class="line">                                 (<span class="keyword">const</span> <span class="keyword">signed</span> <span class="keyword">char</span>*) last1,</span><br><span class="line">                                 (<span class="keyword">const</span> <span class="keyword">signed</span> <span class="keyword">char</span>*) first2,</span><br><span class="line">                                 (<span class="keyword">const</span> <span class="keyword">signed</span> <span class="keyword">char</span>*) last2);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="keyword">return</span> lexicographical_compare((<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>*) first1,</span><br><span class="line">                                 (<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>*) last1,</span><br><span class="line">                                 (<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>*) first2,</span><br><span class="line">                                 (<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>*) last2);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 一句话概括, 这个是strcmp()的泛化版本</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator1</span>, <span class="title">class</span> <span class="title">InputIterator2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">int</span> <span class="title">lexicographical_compare_3way</span>(<span class="title">InputIterator1</span> <span class="title">first1</span>, <span class="title">InputIterator1</span> <span class="title">last1</span>,</span></span><br><span class="line"><span class="class">                                 <span class="title">InputIterator2</span> <span class="title">first2</span>, <span class="title">InputIterator2</span> <span class="title">last2</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">while</span> (first1 != last1 &amp;&amp; first2 != last2) &#123;</span><br><span class="line">    <span class="keyword">if</span> (*first1 &lt; *first2) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (*first2 &lt; *first1) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    ++first1; ++first2;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (first2 == last2) &#123;</span><br><span class="line">    <span class="keyword">return</span> !(first1 == last1);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 特换版本, 效率决定一切</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">int</span></span><br><span class="line">lexicographical_compare_3way(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>* first1,</span><br><span class="line">                             <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>* last1,</span><br><span class="line">                             <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>* first2,</span><br><span class="line">                             <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>* last2)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">ptrdiff_t</span> len1 = last1 - first1;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">ptrdiff_t</span> len2 = last2 - first2;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> result = <span class="built_in">memcmp</span>(first1, first2, min(len1, len2));</span><br><span class="line">  <span class="keyword">return</span> result != <span class="number">0</span> ? result : (len1 == len2 ? <span class="number">0</span> : (len1 &lt; len2 ? <span class="number">-1</span> : <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lexicographical_compare_3way</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* first1, <span class="keyword">const</span> <span class="keyword">char</span>* last1,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="keyword">const</span> <span class="keyword">char</span>* first2, <span class="keyword">const</span> <span class="keyword">char</span>* last2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> CHAR_MAX == SCHAR_MAX</span></span><br><span class="line">  <span class="keyword">return</span> lexicographical_compare_3way(</span><br><span class="line">				(<span class="keyword">const</span> <span class="keyword">signed</span> <span class="keyword">char</span>*) first1,</span><br><span class="line">                                (<span class="keyword">const</span> <span class="keyword">signed</span> <span class="keyword">char</span>*) last1,</span><br><span class="line">                                (<span class="keyword">const</span> <span class="keyword">signed</span> <span class="keyword">char</span>*) first2,</span><br><span class="line">                                (<span class="keyword">const</span> <span class="keyword">signed</span> <span class="keyword">char</span>*) last2);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="keyword">return</span> lexicographical_compare_3way((<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>*) first1,</span><br><span class="line">                                      (<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>*) last1,</span><br><span class="line">                                      (<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>*) first2,</span><br><span class="line">                                      (<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>*) last2);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="max"><a href="#max" class="headerlink" title="max"></a>max</h3><p>去两个对象中的较大值，有两个版本，版本一使用对象类型T所提供的greater-than判断大小，版本二使用仿函数comp判断大小。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">max</span>(<span class="title">const</span> <span class="title">T</span>&amp; <span class="title">a</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">b</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">return</span>  a &lt; b ? b : a;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">max</span>(<span class="title">const</span> <span class="title">T</span>&amp; <span class="title">a</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">b</span>, <span class="title">Compare</span> <span class="title">comp</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">return</span> comp(a, b) ? b : a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="min"><a href="#min" class="headerlink" title="min"></a>min</h3><p>max和min非常简单了, 由于返回的是引用, 因此可以嵌套使用<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">min</span>(<span class="title">const</span> <span class="title">T</span>&amp; <span class="title">a</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">b</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">return</span> b &lt; a ? b : a;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">min</span>(<span class="title">const</span> <span class="title">T</span>&amp; <span class="title">a</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">b</span>, <span class="title">Compare</span> <span class="title">comp</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">return</span> comp(b, a) ? b : a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="mismatch"><a href="#mismatch" class="headerlink" title="mismatch"></a>mismatch</h3><p>用来平行比较两个序列，指出两者之间的第一个不匹配点：返回一对迭代器，分别指向两序列中的不匹配点，如下图，如果两序列的所有对应元素都匹配，返回的便是两序列各自的iast迭代器。缺省情况下是以equality操作符来比较元素。但第二版本允许用户指定比较操作。如果第二序列的元素个数比第一序列多，多出 来的元素忽略不计。如果第几序列的元素个数比第一序列少，会发生未可预期的行为。</p>
<p><img src="/img/1610542684.jpg" alt></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator1</span>, <span class="title">class</span> <span class="title">InputIterator2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">pair</span>&lt;InputIterator1, InputIterator2&gt; <span class="title">mismatch</span>(<span class="title">InputIterator1</span> <span class="title">first1</span>,</span></span><br><span class="line"><span class="class">					      <span class="title">InputIterator1</span> <span class="title">last1</span>,</span></span><br><span class="line"><span class="class">					      <span class="title">InputIterator2</span> <span class="title">first2</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">// 遍历区间, 寻找失配点</span></span><br><span class="line">  <span class="keyword">while</span> (first1 != last1 &amp;&amp; *first1 == *first2) &#123;</span><br><span class="line">    ++first1;</span><br><span class="line">    ++first2;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pair&lt;InputIterator1, InputIterator2&gt;(first1, first2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提供用户自定义的二元判别式, 其余同上</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator1</span>, <span class="title">class</span> <span class="title">InputIterator2</span>, <span class="title">class</span> <span class="title">BinaryPredicate</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">pair</span>&lt;InputIterator1, InputIterator2&gt; <span class="title">mismatch</span>(<span class="title">InputIterator1</span> <span class="title">first1</span>,</span></span><br><span class="line"><span class="class">					      <span class="title">InputIterator1</span> <span class="title">last1</span>,</span></span><br><span class="line"><span class="class">					      <span class="title">InputIterator2</span> <span class="title">first2</span>,</span></span><br><span class="line"><span class="class">					      <span class="title">BinaryPredicate</span> <span class="title">binary_pred</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">while</span> (first1 != last1 &amp;&amp; binary_pred(*first1, *first2)) &#123;</span><br><span class="line">    ++first1;</span><br><span class="line">    ++first2;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pair&lt;InputIterator1, InputIterator2&gt;(first1, first2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="swap"><a href="#swap" class="headerlink" title="swap"></a>swap</h3><p>交换对调两个对象内容<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//交换a和b的值</span></span><br><span class="line"><span class="comment">//这里采用引用传参</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">swap</span>(<span class="title">T</span>&amp; <span class="title">a</span>, <span class="title">T</span>&amp; <span class="title">b</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  T tmp = a;</span><br><span class="line">  a = b;</span><br><span class="line">  b = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h3><p><code>copy()</code>是一个调用频率非常高的函数，所以SGI STL的copy算法用尽各种办法，包括函数重载(function overloading)、型别特性(type traits)、偏特化(partial specialization)编程技巧，无所不用其极地加强效率。下图是整个<code>copy()</code>操作的脉络。<br><img src="/img/1610542923.jpg" alt></p>
<p>copy算法将输入区间[first, last)内的元素复制到result指向的输出区间内，赋值操作是向前推进的。如果输入区间和输出区间重叠，复制顺序需要多加讨论。当result位于[first, last)之内时，也就是说，如果输出区间的首部与输入区间重叠，copy的结果可能不正确，建议选用copy_backward；如果输出区间的尾部如输入区间重叠，copy_backward的结果可能不正确，建议选用copy。当然，如果两区间完全不重叠，copy和copy_backward都可以选用。<br><img src="/img/1610543021.jpg" alt></p>
<p>copy算法根据输出迭代器的特性决定是否调用<code>memmove()</code>来执行任务，<code>memmove()</code>会先将整个输入区间的内容复制下来，然后再复制到输入区间。这种情况下，即使输入区间和输出区间有重叠时，copy的结果也是正确的。这也回答了上文中提调的，为什么result位于[first, last)之内时，copy的结果只是“可能不正确”。</p>
<p>copy为输出区间内的元素赋予新值，而不是产生新元素，它不能改变输出区间的长度。换句话说，copy不能用来直接将元素插入到空容器中。如果你想要将元素插入序列之中，要么使用序列容器的insert成员函数，要么使用copy算法并搭配insert_iterator。</p>
<p>下面是copy算法唯三的对外接口，包括一个完全泛化版本和两个重载函数，重载函数针对原生指针<code>const char*</code>和<code>const wchar_t*</code>进行内存直接拷贝操作：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">OutputIterator</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">OutputIterator</span></span></span><br><span class="line"><span class="class"><span class="title">copy</span>(<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>, <span class="title">OutputIterator</span> <span class="title">result</span>) &#123;</span> </span><br><span class="line">    <span class="keyword">return</span> __copy_dispatch&lt;InputIterator, OutputIterator&gt;()(first, last, result); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">char</span>* <span class="title">copy</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* first, <span class="keyword">const</span> <span class="keyword">char</span>* last, <span class="keyword">char</span>* result)</span> </span>&#123; </span><br><span class="line">    memmove(result, first, last - first); </span><br><span class="line">    <span class="keyword">return</span> result + (last - first); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> wchar_t* <span class="title">copy</span><span class="params">(<span class="keyword">const</span> <span class="keyword">wchar_t</span>* first, <span class="keyword">const</span> <span class="keyword">wchar_t</span>* last, <span class="keyword">wchar_t</span>* result)</span> </span>&#123; </span><br><span class="line">    memmove(result, first, last - first); </span><br><span class="line">    <span class="keyword">return</span> result + (last - first); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>copy()</code>函数的泛化版本中调用了一个<code>__copy_dispatch()</code>的仿函数，此仿函数有一个完全泛化版本和两个偏特化版本：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">OutputIterator</span>&gt;  </span></span><br><span class="line"><span class="class"><span class="title">struct</span> __<span class="title">copy_dispatch</span> &#123;</span>  </span><br><span class="line">    <span class="function">OutputIterator <span class="title">operator</span><span class="params">()</span></span>&#123;InputIterator first, InputIterator last, OutputIterator result) &#123;  </span><br><span class="line">        <span class="keyword">return</span> __copy(first, last, result, iterator_category(first);</span><br><span class="line">&#125; ; </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;class T&gt;</span><br><span class="line">struct __copy_dispatch&lt;T*, T*&gt; &#123;  </span><br><span class="line">    T* <span class="keyword">operator</span>()(T* first, T* last, T* result) &#123;  </span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> __type_traits&lt;T&gt;::has_trivial_assignment_operator t;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">__copy_t</span>(first, last, result, t());  </span><br><span class="line">&#125;;  </span><br><span class="line"><span class="keyword">template</span> &lt;class T&gt;  </span><br><span class="line">struct __copy_dispatch&lt;<span class="keyword">const</span> T*, T*&gt; &#123;  </span><br><span class="line">    T* <span class="keyword">operator</span>()(T* first, T* last, T* result) &#123;  </span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> __type_traits&lt;T&gt;::has_trivial_asssignment_operator t;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">__copy_t</span>(first, last, result, t());  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>__copy_dispatch()</code>的完全泛化版本根据迭代器种类的不同，调用不同的<code>__copy()</code>，为的是不同的迭代器使用的循环条件不同，有快慢之别<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">OutputIterator</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">OutputIterator</span> __<span class="title">copy</span>(<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>, </span></span><br><span class="line"><span class="class"><span class="title">OutputIterator</span> <span class="title">result</span>, <span class="title">input_iterator_tag</span>) &#123;</span> </span><br><span class="line">    <span class="keyword">for</span>( ; first != last; ++first, ++result) </span><br><span class="line">        *result = *first; </span><br><span class="line">    <span class="keyword">return</span> result; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>, <span class="title">class</span> <span class="title">OutputIterator</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">OutputIterator</span> __<span class="title">copy</span>(<span class="title">RandomAccessIterator</span> <span class="title">first</span>, <span class="title">RandomAccessIterator</span> <span class="title">last</span>, </span></span><br><span class="line"><span class="class"><span class="title">OutputIterator</span> <span class="title">result</span>, <span class="title">random_access_iterator_tag</span>) &#123;</span> </span><br><span class="line">    __return __copy_d(first, last, result, distance_type(first)); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>, <span class="title">class</span> <span class="title">OutputIterator</span>, <span class="title">class</span> <span class="title">Distance</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">OutputIterator</span> __<span class="title">copy_d</span>(<span class="title">RandomAccessIterator</span> <span class="title">first</span>, <span class="title">RandomAccessIterator</span> <span class="title">last</span>, </span></span><br><span class="line"><span class="class"><span class="title">OutputIterator</span> <span class="title">result</span>, <span class="title">Distance</span>*) &#123;</span> </span><br><span class="line">    <span class="comment">// 以n决定循环次数，速度快 </span></span><br><span class="line">    <span class="keyword">for</span>(Distance n = last - first; n &gt; <span class="number">0</span>; --n, ++result, ++first) &#123; </span><br><span class="line">        *result = *first; </span><br><span class="line">    <span class="keyword">return</span> result; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这两个偏特化版本是在“参数为原生指针形式”的前提下，利用<code>__type_traits&lt;&gt;</code>编程技巧来探测指针所指向之物是否有trivial assignment operator. 如果指针所指对象拥有trivial assignment operator，则可以通过<code>memmove()</code>进行复制，速度要比利用赋值操作赋快许多。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">T</span>* __<span class="title">copy_t</span>(<span class="title">const</span> <span class="title">T</span>* <span class="title">first</span>, <span class="title">const</span> <span class="title">T</span>* <span class="title">last</span>, <span class="title">T</span>* <span class="title">result</span>, __<span class="title">true_type</span>)  &#123;</span> </span><br><span class="line">    memmove(result, first, <span class="keyword">sizeof</span>(T) *(last - first); </span><br><span class="line">    <span class="keyword">return</span> result + (last - first); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">template</span> &lt;class T&gt; </span><br><span class="line"><span class="keyword">inline</span> T* <span class="keyword">__copy_t</span>(<span class="keyword">const</span> T* first, <span class="keyword">const</span> T* last, T* result, __false_type) &#123; </span><br><span class="line">    <span class="keyword">return</span> __copy_d(first, last, result, (<span class="keyword">ptrdiff_t</span> *)<span class="number">0</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="copy-backward"><a href="#copy-backward" class="headerlink" title="copy_backward"></a>copy_backward</h3><p><code>copy_backward()</code>的实现与<code>copy()</code>极为相似，不同是它将[first, last)区间内的每一个元素，以逆行的方向复制到，以result-1为起点，方向同样为逆行的区间上。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">BidirectionalIterator1</span>, <span class="title">class</span> <span class="title">BidirectionalIterator2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">BidirectionalIterator2</span> __<span class="title">copy_backward</span>(<span class="title">BidirectionalIterator1</span> <span class="title">first</span>,</span></span><br><span class="line"><span class="class">                                              <span class="title">BidirectionalIterator1</span> <span class="title">last</span>,</span></span><br><span class="line"><span class="class">                                              <span class="title">BidirectionalIterator2</span> <span class="title">result</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">while</span> (first != last) *--result = *--last;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个算法的考虑以及实现的技巧与copy十分类似，其操作示意如图，将[first, last)区间内的每一个元素，以逆行的方向复制到，以result-1为起点，方向同样为逆行的区间上。返回一个迭代器<code>result-(last-first)</code>。<code>copy_backward</code>所接受的迭代器必须是BidirectionIterators才能够“倒行逆施”。<br><img src="/img/1610543888.jpg" alt></p>
<h2 id="set相关算法"><a href="#set相关算法" class="headerlink" title="set相关算法"></a>set相关算法</h2><p>STL提供了4个set相关的算法，分别是并集（union）、交集（intersection）、差集（difference）和对称差集（symmetric difference），这4个算法接受的set必须是有序区间，都至少接受4个参数，分别表示两个set区间。一般而言，set算法前4个参数分别表示两个区间，第五个参数表示存放结果的区间的起始位置。</p>
<h3 id="set-union"><a href="#set-union" class="headerlink" title="set_union"></a>set_union</h3><p>求两个集合的并集，能够造出S1 U S2，此集合内含S1或S2内的每一个元素。如果某个值在S1出现n次，在S2出现m次，那么该值在输出区间中会出现max(m, n)次。返回值为一个迭代器，指向输出区间的尾端。是一种稳定操作，输入区间内的每个元素相对顺序都不会改变。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//并集，求存在于[first1, last1)或存在于[first2, last2)内的所有元素  </span></span><br><span class="line"><span class="comment">//注意：输入区间必须是已排序  </span></span><br><span class="line"><span class="comment">//版本一,默认是operator&lt;操作的排序方式  </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator1</span>, <span class="title">class</span> <span class="title">InputIterator2</span>, <span class="title">class</span> <span class="title">OutputIterator</span>&gt;  </span></span><br><span class="line"><span class="class"><span class="title">OutputIterator</span> <span class="title">set_union</span>(<span class="title">InputIterator1</span> <span class="title">first1</span>, <span class="title">InputIterator1</span> <span class="title">last1</span>,  </span></span><br><span class="line"><span class="class">    <span class="title">InputIterator2</span> <span class="title">first2</span>, <span class="title">InputIterator2</span> <span class="title">last2</span>,  </span></span><br><span class="line"><span class="class">    <span class="title">OutputIterator</span> <span class="title">result</span>) &#123;</span>  </span><br><span class="line">    <span class="comment">//两个区间都尚未到达区间尾端，执行以下操作  </span></span><br><span class="line">    <span class="keyword">while</span> (first1 != last1 &amp;&amp; first2 != last2) &#123;  </span><br><span class="line">        <span class="comment">/*在两区间内分别移动迭代器，首先将元素较小者(假设为A区)记录在目标区result，</span></span><br><span class="line"><span class="comment">        移动A区迭代器使其前进；同时另一个区的迭代器不变。然后进行一次新的比较， </span></span><br><span class="line"><span class="comment">        记录较小值，移动迭代器...直到两区间中有一个到达尾端。</span></span><br><span class="line"><span class="comment">        若元素相等， 默认取第一区间元素到目标区result，同时移动两个迭代器.*/</span>  </span><br><span class="line">        <span class="keyword">if</span> (*first1 &lt; *first2) &#123;  </span><br><span class="line">            *result = *first1;  </span><br><span class="line">            ++first1;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (*first2 &lt; *first1) &#123;  </span><br><span class="line">            *result = *first2;  </span><br><span class="line">            ++first2;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span> &#123;  </span><br><span class="line">            *result = *first1;  </span><br><span class="line">            ++first1;  </span><br><span class="line">            ++first2;  </span><br><span class="line">        &#125;  </span><br><span class="line">        ++result;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">/*只要两区间之中有一个区间到达尾端，就结束上面的while循环</span></span><br><span class="line"><span class="comment">    以下将尚未到达尾端的区间剩余的元素拷贝到目标区 </span></span><br><span class="line"><span class="comment">    此刻，[first1, last1)和[first2, last2)至少有一个是空区间*/</span>  </span><br><span class="line">    <span class="keyword">return</span> copy(first2, last2, copy(first1, last1, result));  </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//版本二,用户根据仿函数comp指定排序规则  </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator1</span>, <span class="title">class</span> <span class="title">InputIterator2</span>, <span class="title">class</span> <span class="title">OutputIterator</span>,<span class="title">class</span> <span class="title">Compare</span>&gt;  </span></span><br><span class="line"><span class="class"><span class="title">OutputIterator</span> <span class="title">set_union</span>(<span class="title">InputIterator1</span> <span class="title">first1</span>, <span class="title">InputIterator1</span> <span class="title">last1</span>,  </span></span><br><span class="line"><span class="class">    <span class="title">InputIterator2</span> <span class="title">first2</span>, <span class="title">InputIterator2</span> <span class="title">last2</span>,  </span></span><br><span class="line"><span class="class">    <span class="title">OutputIterator</span> <span class="title">result</span>, <span class="title">Compare</span> <span class="title">comp</span>) &#123;</span>  </span><br><span class="line">    <span class="keyword">while</span> (first1 != last1 &amp;&amp; first2 != last2) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (comp(*first1, *first2)) &#123;  </span><br><span class="line">            *result = *first1;  </span><br><span class="line">            ++first1;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (comp(*first2, *first1)) &#123;  </span><br><span class="line">            *result = *first2;  </span><br><span class="line">            ++first2;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span> &#123;  </span><br><span class="line">            *result = *first1;  </span><br><span class="line">            ++first1;  </span><br><span class="line">            ++first2;  </span><br><span class="line">        &#125;  </span><br><span class="line">        ++result;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> copy(first2, last2, copy(first1, last1, result));  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>图解如下：<br><img src="/img/1610544166.jpg" alt></p>
<h3 id="set-intersection"><a href="#set-intersection" class="headerlink" title="set_intersection"></a>set_intersection</h3><p>求两个集合的交集，此集合内含同时出现于S1和S2内的每一个元素。如果某个值在S1出现n次，在S2出现m次，那么该值在输出区间中会出现min(m, n)次，并且全部来自S1。</p>
<p>返回值为一个迭代器，指向输出区间的尾端。</p>
<p>是一种稳定操作，输入区间内的每个元素相对顺序都不会改变。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//交集，求存在于[first1, last1)且存在于[first2, last2)内的所有元素  </span></span><br><span class="line"><span class="comment">//注意：输入区间必须是已排序  </span></span><br><span class="line"><span class="comment">//版本一,默认是operator&lt;操作的排序方式  </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator1</span>, <span class="title">class</span> <span class="title">InputIterator2</span>, <span class="title">class</span> <span class="title">OutputIterator</span>&gt;  </span></span><br><span class="line"><span class="class"><span class="title">OutputIterator</span> <span class="title">set_intersection</span>(<span class="title">InputIterator1</span> <span class="title">first1</span>, <span class="title">InputIterator1</span> <span class="title">last1</span>,  </span></span><br><span class="line"><span class="class">    <span class="title">InputIterator2</span> <span class="title">first2</span>, <span class="title">InputIterator2</span> <span class="title">last2</span>,  </span></span><br><span class="line"><span class="class">    <span class="title">OutputIterator</span> <span class="title">result</span>) &#123;</span>  </span><br><span class="line">    <span class="comment">//若两个区间都尚未到达尾端，则执行以下操作  </span></span><br><span class="line">    <span class="keyword">while</span> (first1 != last1 &amp;&amp; first2 != last2)  </span><br><span class="line">        <span class="comment">//在两个区间分别移动迭代器，直到遇到相等元素，记录到目标区  </span></span><br><span class="line">        <span class="comment">//继续移动迭代器...直到两区间之中有一区到达尾端  </span></span><br><span class="line">        <span class="keyword">if</span> (*first1 &lt; *first2)  </span><br><span class="line">            ++first1;  </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (*first2 &lt; *first1)  </span><br><span class="line">            ++first2;  </span><br><span class="line">        <span class="keyword">else</span> &#123;  </span><br><span class="line">            *result = *first1;  </span><br><span class="line">            ++first1;  </span><br><span class="line">            ++first2;  </span><br><span class="line">            ++result;  </span><br><span class="line">        &#125;  </span><br><span class="line">    <span class="keyword">return</span> result;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>图解如下：<br><img src="/img/1610544209.jpg" alt></p>
<h3 id="set-difference"><a href="#set-difference" class="headerlink" title="set_difference"></a>set_difference</h3><p>求两个集合的差集，此集合内含出现于S1但不出现于S2内的元素。如果某个值在S1出现n次，在S2出现m次，那么该值在输出区间中会出现max(n-m, 0)次，并且全部来自S1。</p>
<p>返回值为一个迭代器，指向输出区间的尾端。</p>
<p>是一种稳定操作，输入区间内的每个元素相对顺序都不会改变。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//差集，求存在于[first1, last1)且不存在于[first2, last2)内的所有元素  </span></span><br><span class="line"><span class="comment">//注意：输入区间必须是已排序  </span></span><br><span class="line"><span class="comment">//版本一，默认是operator&lt;操作的排序方式  </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator1</span>, <span class="title">class</span> <span class="title">InputIterator2</span>, <span class="title">class</span> <span class="title">OutputIterator</span>&gt;  </span></span><br><span class="line"><span class="class"><span class="title">OutputIterator</span> <span class="title">set_difference</span>(<span class="title">InputIterator1</span> <span class="title">first1</span>, <span class="title">InputIterator1</span> <span class="title">last1</span>,  </span></span><br><span class="line"><span class="class">    <span class="title">InputIterator2</span> <span class="title">first2</span>, <span class="title">InputIterator2</span> <span class="title">last2</span>,  </span></span><br><span class="line"><span class="class">    <span class="title">OutputIterator</span> <span class="title">result</span>) &#123;</span>  </span><br><span class="line">    <span class="comment">//若两个区间都尚未到达尾端，则执行以下操作  </span></span><br><span class="line">    <span class="keyword">while</span> (first1 != last1 &amp;&amp; first2 != last2)  </span><br><span class="line">        <span class="comment">/*在两个区间分别移动迭代器，当第一区间元素等于第二区</span></span><br><span class="line"><span class="comment">        间元素时，表示两区间共同存在该元素，则同时移动迭代器； </span></span><br><span class="line"><span class="comment">        当第一区间元素大于第二区间元素时，就让第二区间迭代器前进； </span></span><br><span class="line"><span class="comment">        第一区间元素小于第二区间元素时，把第一区间元素记录到目标区 </span></span><br><span class="line"><span class="comment">        继续移动迭代器...直到两区间之中有到达尾端*/</span>  </span><br><span class="line">        <span class="keyword">if</span> (*first1 &lt; *first2) &#123;  </span><br><span class="line">            *result = *first1;  </span><br><span class="line">            ++first1;  </span><br><span class="line">            ++result;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (*first2 &lt; *first1)  </span><br><span class="line">            ++first2;  </span><br><span class="line">        <span class="keyword">else</span> &#123;  </span><br><span class="line">            ++first1;  </span><br><span class="line">            ++first2;  </span><br><span class="line">        &#125;  </span><br><span class="line">    <span class="comment">//把第一区间剩余的元素(若有剩余)复制到目标区</span></span><br><span class="line">    <span class="keyword">return</span> copy(first1, last1, result);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>图解如下：<br><img src="/img/1610544261.jpg" alt></p>
<h3 id="set-symmetric-difference"><a href="#set-symmetric-difference" class="headerlink" title="set_symmetric_difference"></a>set_symmetric_difference</h3><p>求两个集合的对称差集(s1-s2)∪(s2-s1)，此集合内含出现于S1但不出现于S2内的元素，以及出现于S2但不出现于S1内的每一个元素。如果某个值在S1出现n次，在S2出现m次，那么该值在输出区间中会出现|n-m|次。</p>
<p>返回值为一个迭代器，指向输出区间的尾端。</p>
<p>是一种稳定操作，输入区间内的每个元素相对顺序都不会改变。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对称差集，求存在于[first1, last1)但不存在于[first2, </span></span><br><span class="line"><span class="comment">//last2)内的所有元素以及出现在[first2, last2)但不出现在</span></span><br><span class="line"><span class="comment">//[first1, last1)的所有元素  </span></span><br><span class="line"><span class="comment">//注意：输入区间必须是已排序  </span></span><br><span class="line"><span class="comment">//版本一，默认是operator&lt;操作的排序方式  </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator1</span>, <span class="title">class</span> <span class="title">InputIterator2</span>, <span class="title">class</span> <span class="title">OutputIterator</span>&gt;  </span></span><br><span class="line"><span class="class"><span class="title">OutputIterator</span> <span class="title">set_symmetric_difference</span>(<span class="title">InputIterator1</span> <span class="title">first1</span>,  </span></span><br><span class="line"><span class="class">    <span class="title">InputIterator1</span> <span class="title">last1</span>,  </span></span><br><span class="line"><span class="class">    <span class="title">InputIterator2</span> <span class="title">first2</span>,  </span></span><br><span class="line"><span class="class">    <span class="title">InputIterator2</span> <span class="title">last2</span>,  </span></span><br><span class="line"><span class="class">    <span class="title">OutputIterator</span> <span class="title">result</span>) &#123;</span>  </span><br><span class="line">    <span class="comment">//若两个区间都尚未到达尾端，则执行下面的操作  </span></span><br><span class="line">    <span class="keyword">while</span> (first1 != last1 &amp;&amp; first2 != last2)  </span><br><span class="line">        <span class="comment">/*在两区间内分别移动迭代器。当两区间内的元素相等，就让两区同时前进； </span></span><br><span class="line"><span class="comment">        当两区间内的元素不等，就记录较小值于目标区，并令较小值所在区间前进*/</span>  </span><br><span class="line">        <span class="keyword">if</span> (*first1 &lt; *first2) &#123;  </span><br><span class="line">            *result = *first1;  </span><br><span class="line">            ++first1;  </span><br><span class="line">            ++result;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (*first2 &lt; *first1) &#123;  </span><br><span class="line">            *result = *first2;  </span><br><span class="line">            ++first2;  </span><br><span class="line">            ++result;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span> &#123;  </span><br><span class="line">            ++first1;  </span><br><span class="line">            ++first2;  </span><br><span class="line">        &#125;  </span><br><span class="line">    <span class="keyword">return</span> copy(first2, last2, copy(first1, last1, result));  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>图解如下：<br><img src="/img/1610544307.jpg" alt></p>
<h3 id="应用实例："><a href="#应用实例：" class="headerlink" title="应用实例："></a>应用实例：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iterator&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;  </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">display</span>&#123;</span>  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T&amp; x)</span> <span class="keyword">const</span></span>&#123;  </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">" "</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> ia[] = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span> &#125;;  </span><br><span class="line">    <span class="keyword">int</span> ib[] = &#123; <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span> &#125;;  </span><br><span class="line">    <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; s1(begin(ia), end(ia));  </span><br><span class="line">    <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; s2(begin(ib), end(ib));  </span><br><span class="line"> </span><br><span class="line">    for_each(s1.begin(), s1.end(), display&lt;<span class="keyword">int</span>&gt;());  </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">    for_each(s2.begin(), s2.end(), display&lt;<span class="keyword">int</span>&gt;());  </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line"> </span><br><span class="line">    <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt;::iterator first1 = s1.begin();  </span><br><span class="line">    <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt;::iterator last1 = s1.end();  </span><br><span class="line">    <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt;::iterator first2 = s2.begin();  </span><br><span class="line">    <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt;::iterator last2 = s2.end();  </span><br><span class="line"> </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"union of s1 and s2:"</span>;  </span><br><span class="line">    set_union(first1, last1, first2, last2, ostream_iterator&lt;<span class="keyword">int</span>&gt;(<span class="built_in">cout</span>, <span class="string">" "</span>));  </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line"> </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"intersection of s1 and s2:"</span>;  </span><br><span class="line">    set_intersection(first1, last1, first2, last2, ostream_iterator&lt;<span class="keyword">int</span>&gt;(<span class="built_in">cout</span>, <span class="string">" "</span>));  </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line"> </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"difference of s1 and s2:"</span>;  </span><br><span class="line">    set_difference(first1, last1, first2, last2, ostream_iterator&lt;<span class="keyword">int</span>&gt;(<span class="built_in">cout</span>, <span class="string">" "</span>));  </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line"> </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"symmetric differenceof s1 and s2:"</span>;  </span><br><span class="line">    set_symmetric_difference(first1, last1, first2, last2, ostream_iterator&lt;<span class="keyword">int</span>&gt;(<span class="built_in">cout</span>, <span class="string">" "</span>));  </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="其他算法"><a href="#其他算法" class="headerlink" title="其他算法"></a>其他算法</h2><h3 id="单纯的数据处理"><a href="#单纯的数据处理" class="headerlink" title="单纯的数据处理"></a>单纯的数据处理</h3><p>测试程序：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 仿函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">display</span> &#123;</span> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> T&amp; x)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 仿函数，一元谓词</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">even</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span> x)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x % <span class="number">2</span> ? <span class="literal">false</span> : <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 还是一个仿函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">even_by_two</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span> <span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _x += <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> _x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> even_by_two::_x = <span class="number">0</span>; <span class="comment">// 类内声明类外初始化</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ia[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; iv(ia, ia + <span class="keyword">sizeof</span>(ia) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找出相邻元素值相等的第一个元素</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *adjacent_find(iv.begin(), iv.end()) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 找出相邻元素值相等的第一个元素</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *adjacent_find(iv.begin(), iv.end(), equal_to&lt;<span class="keyword">int</span>&gt;()) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 找出元素值为6的元素个数</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; count(iv.begin(), iv.end(), <span class="number">6</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 找出元素值小于7的元素个数</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; count_if(iv.begin(), iv.end(), bind2nd(less&lt;<span class="keyword">int</span>&gt;(), <span class="number">7</span>)) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找出元素值为4的元素所在位置</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *find(iv.begin(), iv.end(), <span class="number">4</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 找出元素值大于2的第一个元素所在位置</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *find_if(iv.begin(), iv.end(), bind2nd(greater&lt;<span class="keyword">int</span>&gt;(), <span class="number">2</span>)) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找出子序列所出现的最后一个位置，加3</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; iv2(ia + <span class="number">6</span>, ia + <span class="number">8</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *(find_end(iv.begin(), iv.end(), iv2.begin(), iv2.end()) + <span class="number">3</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找出子序列所出现的第一个位置，加3</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *(find_first_of(iv.begin(), iv.end(), iv2.begin(), iv2.end()) + <span class="number">3</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代iv 每个元素进行display</span></span><br><span class="line">    for_each(iv.begin(), iv.end(), display&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下写法错误，generate的第三个参数是仿函数，本身不得有任何参数</span></span><br><span class="line">    <span class="comment">// generate(iv.begin(), iv.end(), bind2nd(plus&lt;int&gt;(), 3)); // error</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代iv2，对每个元素进行even_by_two</span></span><br><span class="line">    generate(iv2.begin(), iv2.end(), even_by_two());</span><br><span class="line">    for_each(iv2.begin(), iv2.end(), display&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 迭代指定区间，对每个元素进行even_by_two</span></span><br><span class="line">    generate_n(iv2.begin(), <span class="number">3</span>, even_by_two());</span><br><span class="line">    for_each(iv2.begin(), iv2.end(), display&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除（但不删除）元素6，尾端可能有残余数据（可以使用erase）</span></span><br><span class="line">    remove(iv.begin(), iv.end(), <span class="number">6</span>);</span><br><span class="line">    for_each(iv.begin(), iv.end(), display&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除（但不删除）元素6，结果置于另一区间</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; iv3(<span class="number">12</span>);</span><br><span class="line">    remove_copy(iv.begin(), iv.end(), iv3.begin(), <span class="number">6</span>);</span><br><span class="line">    for_each(iv3.begin(), iv3.end(), display&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除（但不删除）元素6，尾端可能有残余数据</span></span><br><span class="line">    remove_if(iv.begin(), iv.end(), bind2nd(less&lt;<span class="keyword">int</span>&gt;(), <span class="number">6</span>));</span><br><span class="line">    for_each(iv.begin(), iv.end(), display&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除（但不删除）小于7的元素，结果置于另一区间</span></span><br><span class="line">    remove_copy_if(iv.begin(), iv.end(), iv3.begin(), bind2nd(less&lt;<span class="keyword">int</span>&gt;(), <span class="number">7</span>));</span><br><span class="line">    for_each(iv3.begin(), iv3.end(), display&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将所有的元素值6，改为元素值3</span></span><br><span class="line">    replace(iv.begin(), iv.end(), <span class="number">6</span>, <span class="number">3</span>);</span><br><span class="line">    for_each(iv.begin(), iv.end(), display&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将所有的元素值3，改为元素值5，结果置于另一区间</span></span><br><span class="line">    replace_copy(iv.begin(), iv.end(), iv3.begin(), <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">    for_each(iv3.begin(), iv3.end(), display&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将所有小于5的元素值，改为元素值2</span></span><br><span class="line">    replace_if(iv.begin(), iv.end(), bind2nd(less&lt;<span class="keyword">int</span>&gt;(), <span class="number">5</span>), <span class="number">2</span>);</span><br><span class="line">    for_each(iv.begin(), iv.end(), display&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将所有等于8的元素值，改为元素值9，结果置于另一区间</span></span><br><span class="line">    replace_copy_if(iv.begin(), iv.end(), iv3.begin(), bind2nd(equal_to&lt;<span class="keyword">int</span>&gt;(), <span class="number">8</span>), <span class="number">9</span>);</span><br><span class="line">    for_each(iv3.begin(), iv3.end(), display&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逆向重排每一个元素</span></span><br><span class="line">    reverse(iv.begin(), iv.end());</span><br><span class="line">    for_each(iv.begin(), iv.end(), display&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    <span class="comment">// 逆向重排每一个元素，结果置于另一区间</span></span><br><span class="line">    reverse_copy(iv.begin(), iv.end(), iv3.begin());</span><br><span class="line">    for_each(iv3.begin(), iv3.end(), display&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 旋转（互换元素）[first, middle]和[middle, last]</span></span><br><span class="line">    rotate(iv.begin(), iv.begin() + <span class="number">4</span>, iv.end());</span><br><span class="line">    for_each(iv.begin(), iv.end(), display&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    <span class="comment">// 旋转（互换元素）[first, middle]和[middle, last]</span></span><br><span class="line">    <span class="comment">// 结果置于另一区间</span></span><br><span class="line">    rotate_copy(iv.begin(), iv.begin() + <span class="number">5</span>, iv.end(), iv3.begin());</span><br><span class="line">    for_each(iv3.begin(), iv3.end(), display&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找某个子序列的第一次出现地点</span></span><br><span class="line">    <span class="keyword">int</span> ia2[<span class="number">3</span>] = &#123;<span class="number">2</span>, <span class="number">8</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; iv4(ia2, ia2 + <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *search(iv.begin(), iv.end(), iv4.begin(), iv4.end()) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 查找连续出现2个8的子序列起点</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *search_n(iv.begin(), iv.end(), <span class="number">2</span>, <span class="number">8</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 查找连续出现3个小于8的子序列起点</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *search_n(iv.begin(), iv.end(), <span class="number">3</span>, <span class="number">8</span>, less&lt;<span class="keyword">int</span>&gt;()) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将区间元素互换，第二区间个数不应小于第一区间个数</span></span><br><span class="line">    swap_ranges(iv4.begin(), iv4.end(), iv.begin());</span><br><span class="line">    for_each(iv.begin(), iv.end(), display&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    for_each(iv4.begin(), iv4.end(), display&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 改变区间的值，全部减2，原地搬运</span></span><br><span class="line">    transform(iv.begin(), iv.end(), iv.begin(), bind2nd(minus&lt;<span class="keyword">int</span>&gt;(), <span class="number">2</span>));</span><br><span class="line">    for_each(iv.begin(), iv.end(), display&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 改变区间的值，令 第二区间的元素值加到第一区间上</span></span><br><span class="line">    transform(iv.begin(), iv.end(), iv.begin(), iv.begin(), plus&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    for_each(iv.begin(), iv.end(), display&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// *******************************************</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; iv5(ia, ia + <span class="keyword">sizeof</span>(ia) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; iv6(ia + <span class="number">4</span>, ia + <span class="number">8</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; iv7(<span class="number">15</span>);</span><br><span class="line">    for_each(iv5.begin(), iv5.end(), display&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    for_each(iv6.begin(), iv6.end(), display&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *max_element(iv5.begin(), iv5.end()) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *min_element(iv5.begin(), iv5.end()) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否iv6内的所有元素都出现于iv5中</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; includes(iv5.begin(), iv5.end(), iv6.begin(), iv6.end()) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将两个序列合并，必须有序</span></span><br><span class="line">    merge(iv5.begin(), iv5.end(), iv6.begin(), iv6.end(), iv7.begin());</span><br><span class="line">    for_each(iv7.begin(), iv7.end(), display&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 符合条件的元素放在容器前端，其他放后端</span></span><br><span class="line">    partition(iv7.begin(), iv7.end(), even());</span><br><span class="line">    for_each(iv7.begin(), iv7.end(), display&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 去除连续重复元素</span></span><br><span class="line">    unique(iv5.begin(), iv5.end());</span><br><span class="line">    for_each(iv5.begin(), iv5.end(), display&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    <span class="comment">// 去除连续重复元素，结果置于另一区间</span></span><br><span class="line">    unique_copy(iv5.begin(), iv5.end(), iv7.begin());</span><br><span class="line">    for_each(iv7.begin(), iv7.end(), display&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="adjacent-find"><a href="#adjacent-find" class="headerlink" title="adjacent_find"></a>adjacent_find</h3><p>找出第一组满足条件的相邻元素。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">ForwardIterator</span> <span class="title">adjacent_find</span>(<span class="title">ForwardIterator</span> <span class="title">first</span>, <span class="title">ForwardIterator</span> <span class="title">last</span>) &#123;</span></span><br><span class="line">  <span class="keyword">if</span> (first == last) <span class="keyword">return</span> last;</span><br><span class="line">  ForwardIterator next = first;</span><br><span class="line">  <span class="keyword">while</span>(++next != last) &#123;</span><br><span class="line">    <span class="keyword">if</span> (*first == *next) <span class="keyword">return</span> first;</span><br><span class="line">    first = next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="count"><a href="#count" class="headerlink" title="count"></a>count</h3><p>查找某个元素出现的数目。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Size</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">count</span>(<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">value</span>,</span></span><br><span class="line"><span class="class">           <span class="title">Size</span>&amp; <span class="title">n</span>) &#123;</span></span><br><span class="line">  <span class="keyword">for</span> ( ; first != last; ++first)</span><br><span class="line">    <span class="keyword">if</span> (*first == value)</span><br><span class="line">      ++n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="count-if"><a href="#count-if" class="headerlink" title="count_if"></a>count_if</h3><p>返回仿函数计算结果为true的元素的个数<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">Predicate</span>, <span class="title">class</span> <span class="title">Size</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">count_if</span>(<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>, <span class="title">Predicate</span> <span class="title">pred</span>,</span></span><br><span class="line"><span class="class">              <span class="title">Size</span>&amp; <span class="title">n</span>) &#123;</span></span><br><span class="line">  <span class="keyword">for</span> ( ; first != last; ++first)</span><br><span class="line">    <span class="keyword">if</span> (pred(*first))</span><br><span class="line">      ++n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p>查找第一个匹配的元素<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">InputIterator</span> <span class="title">find</span>(<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">value</span>) &#123;</span></span><br><span class="line">  <span class="keyword">while</span> (first != last &amp;&amp; *first != value) ++first;</span><br><span class="line">  <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="find-if"><a href="#find-if" class="headerlink" title="find_if"></a>find_if</h3><p>查找第一个使仿函数为true的元素。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">Predicate</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">InputIterator</span> <span class="title">find_if</span>(<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>,</span></span><br><span class="line"><span class="class">                      <span class="title">Predicate</span> <span class="title">pred</span>) &#123;</span></span><br><span class="line">  <span class="keyword">while</span> (first != last &amp;&amp; !pred(*first)) ++first;</span><br><span class="line">  <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="find-end"><a href="#find-end" class="headerlink" title="find_end"></a>find_end</h3><p>在序列一的区间内查找序列二的最后一次出现点。要求完全匹配的序列，即连续出现的序列2。可以利用正向查找，每次向后查找，记录上次找的的位置，最后没有找到了，那么上次找到的位置就是最后一次。也可以利用逆向迭代器从后向前找到第一次出现的位置。上层函数为dispatch function。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator1</span>, <span class="title">class</span> <span class="title">ForwardIterator2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">ForwardIterator1</span></span></span><br><span class="line"><span class="class"><span class="title">find_end</span>(<span class="title">ForwardIterator1</span> <span class="title">first1</span>, <span class="title">ForwardIterator1</span> <span class="title">last1</span>,</span></span><br><span class="line"><span class="class">         <span class="title">ForwardIterator2</span> <span class="title">first2</span>, <span class="title">ForwardIterator2</span> <span class="title">last2</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __STL_CLASS_PARTIAL_SPECIALIZATION</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;ForwardIterator1&gt;::iterator_category</span><br><span class="line">          category1;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;ForwardIterator2&gt;::iterator_category</span><br><span class="line">          category2;</span><br><span class="line">  <span class="keyword">return</span> __find_end(first1, last1, first2, last2, category1(), category2());</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">/* __STL_CLASS_PARTIAL_SPECIALIZATION */</span></span></span><br><span class="line">  <span class="keyword">return</span> __find_end(first1, last1, first2, last2,</span><br><span class="line">                    forward_iterator_tag(), forward_iterator_tag());</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __STL_CLASS_PARTIAL_SPECIALIZATION */</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator1</span>, <span class="title">class</span> <span class="title">ForwardIterator2</span>,</span></span><br><span class="line"><span class="class">          <span class="title">class</span> <span class="title">BinaryPredicate</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">ForwardIterator1</span></span></span><br><span class="line"><span class="class"><span class="title">find_end</span>(<span class="title">ForwardIterator1</span> <span class="title">first1</span>, <span class="title">ForwardIterator1</span> <span class="title">last1</span>,</span></span><br><span class="line"><span class="class">         <span class="title">ForwardIterator2</span> <span class="title">first2</span>, <span class="title">ForwardIterator2</span> <span class="title">last2</span>,</span></span><br><span class="line"><span class="class">         <span class="title">BinaryPredicate</span> <span class="title">comp</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __STL_CLASS_PARTIAL_SPECIALIZATION</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;ForwardIterator1&gt;::iterator_category</span><br><span class="line">          category1;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;ForwardIterator2&gt;::iterator_category</span><br><span class="line">          category2;</span><br><span class="line">  <span class="keyword">return</span> __find_end(first1, last1, first2, last2, category1(), category2(),</span><br><span class="line">                    comp);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">/* __STL_CLASS_PARTIAL_SPECIALIZATION */</span></span></span><br><span class="line">  <span class="keyword">return</span> __find_end(first1, last1, first2, last2,</span><br><span class="line">                    forward_iterator_tag(), forward_iterator_tag(),</span><br><span class="line">                    comp);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __STL_CLASS_PARTIAL_SPECIALIZATION */</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一种常见的技巧，令函数传递过程中产生迭代器类型的临时对象，再利用编译器的参数推导机制自动调用某个函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator1</span>, <span class="title">class</span> <span class="title">ForwardIterator2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">ForwardIterator1</span> __<span class="title">find_end</span>(<span class="title">ForwardIterator1</span> <span class="title">first1</span>, <span class="title">ForwardIterator1</span> <span class="title">last1</span>,</span></span><br><span class="line"><span class="class">                            <span class="title">ForwardIterator2</span> <span class="title">first2</span>, <span class="title">ForwardIterator2</span> <span class="title">last2</span>,</span></span><br><span class="line"><span class="class">                            <span class="title">forward_iterator_tag</span>, <span class="title">forward_iterator_tag</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">if</span> (first2 == last2)</span><br><span class="line">    <span class="keyword">return</span> last1;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    ForwardIterator1 result = last1;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">      ForwardIterator1 new_result = search(first1, last1, first2, last2);</span><br><span class="line">      <span class="keyword">if</span> (new_result == last1)</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        result = new_result;</span><br><span class="line">        first1 = new_result;</span><br><span class="line">        ++first1;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator1</span>, <span class="title">class</span> <span class="title">ForwardIterator2</span>,</span></span><br><span class="line"><span class="class">          <span class="title">class</span> <span class="title">BinaryPredicate</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">ForwardIterator1</span> __<span class="title">find_end</span>(<span class="title">ForwardIterator1</span> <span class="title">first1</span>, <span class="title">ForwardIterator1</span> <span class="title">last1</span>,</span></span><br><span class="line"><span class="class">                            <span class="title">ForwardIterator2</span> <span class="title">first2</span>, <span class="title">ForwardIterator2</span> <span class="title">last2</span>,</span></span><br><span class="line"><span class="class">                            <span class="title">forward_iterator_tag</span>, <span class="title">forward_iterator_tag</span>,</span></span><br><span class="line"><span class="class">                            <span class="title">BinaryPredicate</span> <span class="title">comp</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">if</span> (first2 == last2)</span><br><span class="line">    <span class="keyword">return</span> last1;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    ForwardIterator1 result = last1;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">      ForwardIterator1 new_result = search(first1, last1, first2, last2, comp);</span><br><span class="line">      <span class="keyword">if</span> (new_result == last1)</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        result = new_result;</span><br><span class="line">        first1 = new_result;</span><br><span class="line">        ++first1;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// find_end for bidirectional iterators.  Requires partial specialization.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __STL_CLASS_PARTIAL_SPECIALIZATION</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">BidirectionalIterator1</span>, <span class="title">class</span> <span class="title">BidirectionalIterator2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">BidirectionalIterator1</span></span></span><br><span class="line"><span class="class">__<span class="title">find_end</span>(<span class="title">BidirectionalIterator1</span> <span class="title">first1</span>, <span class="title">BidirectionalIterator1</span> <span class="title">last1</span>,</span></span><br><span class="line"><span class="class">           <span class="title">BidirectionalIterator2</span> <span class="title">first2</span>, <span class="title">BidirectionalIterator2</span> <span class="title">last2</span>,</span></span><br><span class="line"><span class="class">           <span class="title">bidirectional_iterator_tag</span>, <span class="title">bidirectional_iterator_tag</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> reverse_iterator&lt;BidirectionalIterator1&gt; reviter1;</span><br><span class="line">  <span class="keyword">typedef</span> reverse_iterator&lt;BidirectionalIterator2&gt; reviter2;</span><br><span class="line"></span><br><span class="line">  <span class="function">reviter1 <span class="title">rlast1</span><span class="params">(first1)</span></span>;</span><br><span class="line">  <span class="function">reviter2 <span class="title">rlast2</span><span class="params">(first2)</span></span>;</span><br><span class="line">  reviter1 rresult = search(reviter1(last1), rlast1, reviter2(last2), rlast2);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (rresult == rlast1)</span><br><span class="line">    <span class="keyword">return</span> last1;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    BidirectionalIterator1 result = rresult.base();</span><br><span class="line">    advance(result, -distance(first2, last2));</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">BidirectionalIterator1</span>, <span class="title">class</span> <span class="title">BidirectionalIterator2</span>,</span></span><br><span class="line"><span class="class">          <span class="title">class</span> <span class="title">BinaryPredicate</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">BidirectionalIterator1</span></span></span><br><span class="line"><span class="class">__<span class="title">find_end</span>(<span class="title">BidirectionalIterator1</span> <span class="title">first1</span>, <span class="title">BidirectionalIterator1</span> <span class="title">last1</span>,</span></span><br><span class="line"><span class="class">           <span class="title">BidirectionalIterator2</span> <span class="title">first2</span>, <span class="title">BidirectionalIterator2</span> <span class="title">last2</span>,</span></span><br><span class="line"><span class="class">           <span class="title">bidirectional_iterator_tag</span>, <span class="title">bidirectional_iterator_tag</span>,</span></span><br><span class="line"><span class="class">           <span class="title">BinaryPredicate</span> <span class="title">comp</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> reverse_iterator&lt;BidirectionalIterator1&gt; reviter1;</span><br><span class="line">  <span class="keyword">typedef</span> reverse_iterator&lt;BidirectionalIterator2&gt; reviter2;</span><br><span class="line"></span><br><span class="line">  <span class="function">reviter1 <span class="title">rlast1</span><span class="params">(first1)</span></span>;</span><br><span class="line">  <span class="function">reviter2 <span class="title">rlast2</span><span class="params">(first2)</span></span>;</span><br><span class="line">  reviter1 rresult = search(reviter1(last1), rlast1, reviter2(last2), rlast2,</span><br><span class="line">                            comp);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (rresult == rlast1)</span><br><span class="line">    <span class="keyword">return</span> last1;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    BidirectionalIterator1 result = rresult.base();</span><br><span class="line">    advance(result, -distance(first2, last2));</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="find-first-of"><a href="#find-first-of" class="headerlink" title="find_first of"></a>find_first of</h3><p>找到序列2中的任何一个元素在序列一中出现的位置。不需要完全配匹配序列2，任何一个元素出现都可以。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">ForwardIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">InputIterator</span> <span class="title">find_first_of</span>(<span class="title">InputIterator</span> <span class="title">first1</span>, <span class="title">InputIterator</span> <span class="title">last1</span>,</span></span><br><span class="line"><span class="class">                            <span class="title">ForwardIterator</span> <span class="title">first2</span>, <span class="title">ForwardIterator</span> <span class="title">last2</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">for</span> ( ; first1 != last1; ++first1)</span><br><span class="line">    <span class="keyword">for</span> (ForwardIterator iter = first2; iter != last2; ++iter)</span><br><span class="line">      <span class="keyword">if</span> (*first1 == *iter)</span><br><span class="line">        <span class="keyword">return</span> first1;</span><br><span class="line">  <span class="keyword">return</span> last1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">ForwardIterator</span>, <span class="title">class</span> <span class="title">BinaryPredicate</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">InputIterator</span> <span class="title">find_first_of</span>(<span class="title">InputIterator</span> <span class="title">first1</span>, <span class="title">InputIterator</span> <span class="title">last1</span>,</span></span><br><span class="line"><span class="class">                            <span class="title">ForwardIterator</span> <span class="title">first2</span>, <span class="title">ForwardIterator</span> <span class="title">last2</span>,</span></span><br><span class="line"><span class="class">                            <span class="title">BinaryPredicate</span> <span class="title">comp</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">for</span> ( ; first1 != last1; ++first1)</span><br><span class="line">    <span class="keyword">for</span> (ForwardIterator iter = first2; iter != last2; ++iter)</span><br><span class="line">      <span class="keyword">if</span> (comp(*first1, *iter))</span><br><span class="line">        <span class="keyword">return</span> first1;</span><br><span class="line">  <span class="keyword">return</span> last1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="for-each"><a href="#for-each" class="headerlink" title="for_each"></a>for_each</h3><p>将仿函数施加于区间内的每个元素之上。不能够改变元素内容，返回值被忽略。可以用于打印元素的值等。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">Function</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">Function</span> <span class="title">for_each</span>(<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>, <span class="title">Function</span> <span class="title">f</span>) &#123;</span></span><br><span class="line">  <span class="keyword">for</span> ( ; first != last; ++first)</span><br><span class="line">    f(*first);</span><br><span class="line">  <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h3><p>将仿函数的运算结果赋值给区间内的每一个元素<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>, <span class="title">class</span> <span class="title">Generator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">generate</span>(<span class="title">ForwardIterator</span> <span class="title">first</span>, <span class="title">ForwardIterator</span> <span class="title">last</span>, <span class="title">Generator</span> <span class="title">gen</span>) &#123;</span></span><br><span class="line">  <span class="keyword">for</span> ( ; first != last; ++first)</span><br><span class="line">    *first = gen();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="generate-n"><a href="#generate-n" class="headerlink" title="generate_n"></a>generate_n</h3><p>将仿函数的运算结果赋值给迭代器first开始的n个元素上<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">OutputIterator</span>, <span class="title">class</span> <span class="title">Size</span>, <span class="title">class</span> <span class="title">Generator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">OutputIterator</span> <span class="title">generate_n</span>(<span class="title">OutputIterator</span> <span class="title">first</span>, <span class="title">Size</span> <span class="title">n</span>, <span class="title">Generator</span> <span class="title">gen</span>) &#123;</span></span><br><span class="line">  <span class="keyword">for</span> ( ; n &gt; <span class="number">0</span>; --n, ++first)</span><br><span class="line">    *first = gen();</span><br><span class="line">  <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="includes"><a href="#includes" class="headerlink" title="includes"></a>includes</h3><p>判断序列二S2是否“涵盖于”序列一S1。S1和S2都必须是有序集合：其中的元素都可重复（不必唯一）。所谓涵盖，意思是“S2的每一个元素都出现于S1”。由于判断两个元素是否相等，必须以less或greater运算为依据（当S1元素不小于S2元素且S2元素不小于S1元素，两者即相等；或说当S1元素不大于S2元素且S2元素不大于S1元素，两者即相等），因此配合着两个序列S1和S2的排序方式（递增或递减），includes算法可供用户选择采用less或greater进行两元素的大小比较（comparison）。 </p>
<p>换句话说，如果S1和S2是递增排序（以operator&lt;执行比较操作），includes 算法应该这么使用：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">includes(S1.begin(), S1.end(), S2.begin(), S2.end());</span><br></pre></td></tr></table></figure></p>
<p>这和下一行完全相同：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">includes(S1.begin(), S1.end(), S2.begin(), S2.end(), less&lt;<span class="keyword">int</span>&gt;());</span><br></pre></td></tr></table></figure></p>
<p>然而如果S1和S2是递减排序（以operator&gt;执行比较操作），includes算法应该这么使用：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">includes(S1.begin(), S1.end(), S2.begin(), S2.end(), greater&lt;<span class="keyword">int</span>&gt;());</span><br></pre></td></tr></table></figure></p>
<p>注意，S1或S2内的元素都可以重复，这种情况下所谓, S1内含一个S2子集合”的定义是：假设某元素在S2出现n次，在S1出现m次。那么如果m &lt; n, 此算法会返回false。<br><img src="/img/1610593476.jpg" alt></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator1</span>, <span class="title">class</span> <span class="title">InputIterator2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">includes</span>(<span class="title">InputIterator1</span> <span class="title">first1</span>, <span class="title">InputIterator1</span> <span class="title">last1</span>,</span></span><br><span class="line"><span class="class">              <span class="title">InputIterator2</span> <span class="title">first2</span>, <span class="title">InputIterator2</span> <span class="title">last2</span>) &#123;</span></span><br><span class="line">  <span class="keyword">while</span> (first1 != last1 &amp;&amp; first2 != last2)</span><br><span class="line">    <span class="keyword">if</span> (*first2 &lt; *first1)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(*first1 &lt; *first2)</span><br><span class="line">      ++first1;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      ++first1, ++first2;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> first2 == last2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator1</span>, <span class="title">class</span> <span class="title">InputIterator2</span>, <span class="title">class</span> <span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">includes</span>(<span class="title">InputIterator1</span> <span class="title">first1</span>, <span class="title">InputIterator1</span> <span class="title">last1</span>,</span></span><br><span class="line"><span class="class">              <span class="title">InputIterator2</span> <span class="title">first2</span>, <span class="title">InputIterator2</span> <span class="title">last2</span>, <span class="title">Compare</span> <span class="title">comp</span>) &#123;</span></span><br><span class="line">  <span class="keyword">while</span> (first1 != last1 &amp;&amp; first2 != last2)</span><br><span class="line">    <span class="keyword">if</span> (comp(*first2, *first1))</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(comp(*first1, *first2))</span><br><span class="line">      ++first1;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      ++first1, ++first2;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> first2 == last2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="max-element"><a href="#max-element" class="headerlink" title="max_element"></a>max_element</h3><p>返回区间内最大的元素。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">ForwardIterator</span> <span class="title">max_element</span>(<span class="title">ForwardIterator</span> <span class="title">first</span>, <span class="title">ForwardIterator</span> <span class="title">last</span>) &#123;</span></span><br><span class="line">  <span class="keyword">if</span> (first == last) <span class="keyword">return</span> first;</span><br><span class="line">  ForwardIterator result = first;</span><br><span class="line">  <span class="keyword">while</span> (++first != last)</span><br><span class="line">    <span class="keyword">if</span> (*result &lt; *first) result = first;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>, <span class="title">class</span> <span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">ForwardIterator</span> <span class="title">max_element</span>(<span class="title">ForwardIterator</span> <span class="title">first</span>, <span class="title">ForwardIterator</span> <span class="title">last</span>,</span></span><br><span class="line"><span class="class">                            <span class="title">Compare</span> <span class="title">comp</span>) &#123;</span></span><br><span class="line">  <span class="keyword">if</span> (first == last) <span class="keyword">return</span> first;</span><br><span class="line">  ForwardIterator result = first;</span><br><span class="line">  <span class="keyword">while</span> (++first != last)</span><br><span class="line">    <span class="keyword">if</span> (comp(*result, *first)) result = first;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h3><p>将两个有序序列融合成一个序列，三个序列都是有序的。返回指向结果序列的尾后元素。<br><img src="/img/1610593588.jpg" alt></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator1</span>, <span class="title">class</span> <span class="title">InputIterator2</span>, <span class="title">class</span> <span class="title">OutputIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">OutputIterator</span> <span class="title">merge</span>(<span class="title">InputIterator1</span> <span class="title">first1</span>, <span class="title">InputIterator1</span> <span class="title">last1</span>,</span></span><br><span class="line"><span class="class">                     <span class="title">InputIterator2</span> <span class="title">first2</span>, <span class="title">InputIterator2</span> <span class="title">last2</span>,</span></span><br><span class="line"><span class="class">                     <span class="title">OutputIterator</span> <span class="title">result</span>) &#123;</span></span><br><span class="line">  <span class="keyword">while</span> (first1 != last1 &amp;&amp; first2 != last2) &#123;</span><br><span class="line">    <span class="keyword">if</span> (*first2 &lt; *first1) &#123;</span><br><span class="line">      *result = *first2;</span><br><span class="line">      ++first2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      *result = *first1;</span><br><span class="line">      ++first1;</span><br><span class="line">    &#125;</span><br><span class="line">    ++result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> copy(first2, last2, copy(first1, last1, result));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator1</span>, <span class="title">class</span> <span class="title">InputIterator2</span>, <span class="title">class</span> <span class="title">OutputIterator</span>,</span></span><br><span class="line"><span class="class">          <span class="title">class</span> <span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">OutputIterator</span> <span class="title">merge</span>(<span class="title">InputIterator1</span> <span class="title">first1</span>, <span class="title">InputIterator1</span> <span class="title">last1</span>,</span></span><br><span class="line"><span class="class">                     <span class="title">InputIterator2</span> <span class="title">first2</span>, <span class="title">InputIterator2</span> <span class="title">last2</span>,</span></span><br><span class="line"><span class="class">                     <span class="title">OutputIterator</span> <span class="title">result</span>, <span class="title">Compare</span> <span class="title">comp</span>) &#123;</span></span><br><span class="line">  <span class="keyword">while</span> (first1 != last1 &amp;&amp; first2 != last2) &#123;</span><br><span class="line">    <span class="keyword">if</span> (comp(*first2, *first1)) &#123;</span><br><span class="line">      *result = *first2;</span><br><span class="line">      ++first2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      *result = *first1;</span><br><span class="line">      ++first1;</span><br><span class="line">    &#125;</span><br><span class="line">    ++result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> copy(first2, last2, copy(first1, last1, result));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="min-element"><a href="#min-element" class="headerlink" title="min_element"></a>min_element</h3><p>返回序列中数值最小的元素<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">ForwardIterator</span> <span class="title">min_element</span>(<span class="title">ForwardIterator</span> <span class="title">first</span>, <span class="title">ForwardIterator</span> <span class="title">last</span>) &#123;</span></span><br><span class="line">  <span class="keyword">if</span> (first == last) <span class="keyword">return</span> first;</span><br><span class="line">  ForwardIterator result = first;</span><br><span class="line">  <span class="keyword">while</span> (++first != last)</span><br><span class="line">    <span class="keyword">if</span> (*first &lt; *result) result = first;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>, <span class="title">class</span> <span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">ForwardIterator</span> <span class="title">min_element</span>(<span class="title">ForwardIterator</span> <span class="title">first</span>, <span class="title">ForwardIterator</span> <span class="title">last</span>,</span></span><br><span class="line"><span class="class">                            <span class="title">Compare</span> <span class="title">comp</span>) &#123;</span></span><br><span class="line">  <span class="keyword">if</span> (first == last) <span class="keyword">return</span> first;</span><br><span class="line">  ForwardIterator result = first;</span><br><span class="line">  <span class="keyword">while</span> (++first != last)</span><br><span class="line">    <span class="keyword">if</span> (comp(*first, *result)) result = first;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="partition"><a href="#partition" class="headerlink" title="partition"></a>partition</h3><p>对区间进行重新排列，所有被仿函数判定为true的元素被放倒区间的前端，被判定为false的元素被放到区间的后端。这个算法并不保留元素的原始相对位置。需要保留原始相对位置，应使用stable_partition。算法实现类似于快排，先从前向后找到一个false,再从后向前找到一个true，然后交换。<br><img src="/img/1610593775.jpg" alt></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">BidirectionalIterator</span>, <span class="title">class</span> <span class="title">Predicate</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">BidirectionalIterator</span> <span class="title">partition</span>(<span class="title">BidirectionalIterator</span> <span class="title">first</span>,</span></span><br><span class="line"><span class="class">                                <span class="title">BidirectionalIterator</span> <span class="title">last</span>, <span class="title">Predicate</span> <span class="title">pred</span>) &#123;</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">      <span class="keyword">if</span> (first == last)</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (pred(*first))</span><br><span class="line">        ++first;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    --last;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">      <span class="keyword">if</span> (first == last)</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (!pred(*last))</span><br><span class="line">        --last;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    iter_swap(first, last);</span><br><span class="line">    ++first;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h3><p>移除区间内与value相等的元素。并不是真正移除，容器大小并未改变。只是将不相等的元素重新赋值到原区间上，所以会在原来有多余的元素。返回在重新整理后的元素的下一位置<br><img src="/img/1610593860.jpg" alt></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">ForwardIterator</span> <span class="title">remove</span>(<span class="title">ForwardIterator</span> <span class="title">first</span>, <span class="title">ForwardIterator</span> <span class="title">last</span>,</span></span><br><span class="line"><span class="class">                       <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">value</span>) &#123;</span></span><br><span class="line">  first = find(first, last, value);</span><br><span class="line">  ForwardIterator next = first;</span><br><span class="line">  <span class="keyword">return</span> first == last ? first : remove_copy(++next, last, first, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="remove-copy"><a href="#remove-copy" class="headerlink" title="remove_copy"></a>remove_copy</h3><p>移除区间内所有与value相等的元素；它并不真正从容器中删除那些元素（换句话说，原容器没有任何改变），而是将结果复制到一个以result标示起始位置的容器身上，新容器可以和原容器重叠，但如果对新容器实际给值时、 超越了旧容器的大小，会产生无法预期的结果。返回值OuputIterator指出被复制的最后元素的下一位置。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">OutputIterator</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">OutputIterator</span> <span class="title">remove_copy</span>(<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>,</span></span><br><span class="line"><span class="class">                           <span class="title">OutputIterator</span> <span class="title">result</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">value</span>) &#123;</span></span><br><span class="line">  <span class="keyword">for</span> ( ; first != last; ++first)</span><br><span class="line">    <span class="keyword">if</span> (*first != value) &#123;</span><br><span class="line">      *result = *first;</span><br><span class="line">      ++result;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="remove-if"><a href="#remove-if" class="headerlink" title="remove_if"></a>remove_if</h3><p>移除[first, last)区间内所有被仿函数pred核定为true的元素。它并不真正从容器中删除那些元素（换句话说，容器大小并未改变），每一个不符合pred条件的元素都会被轮番赋值给first之后的空间。返回值ForwardIterator标示出重新整理后的最后元素的下一位置，此算法会留有一些残余数据，如果要删除那些残余数据，可将返回的迭代器交给区间所在之容器的erase() member function。<br><img src="/img/1610594128.jpg" alt></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>, <span class="title">class</span> <span class="title">Predicate</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">ForwardIterator</span> <span class="title">remove_if</span>(<span class="title">ForwardIterator</span> <span class="title">first</span>, <span class="title">ForwardIterator</span> <span class="title">last</span>,</span></span><br><span class="line"><span class="class">                          <span class="title">Predicate</span> <span class="title">pred</span>) &#123;</span></span><br><span class="line">  first = find_if(first, last, pred);</span><br><span class="line">  ForwardIterator next = first;</span><br><span class="line">  <span class="keyword">return</span> first == last ? first : remove_copy_if(++next, last, first, pred);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="remove-copy-if"><a href="#remove-copy-if" class="headerlink" title="remove_copy_if"></a>remove_copy_if</h3><p>移除区间内所有与value相等的元素；它并不真正从容器中删除那些元素（换句话说，原容器没有任何改变），而是将结果复制到一个以result标示起始位置的容器身上，新容器可以和原容器重叠，但如果对新容器实际给值时、 超越了旧容器的大小，会产生无法预期的结果。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">OutputIterator</span>, <span class="title">class</span> <span class="title">Predicate</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">OutputIterator</span> <span class="title">remove_copy_if</span>(<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>,</span></span><br><span class="line"><span class="class">                              <span class="title">OutputIterator</span> <span class="title">result</span>, <span class="title">Predicate</span> <span class="title">pred</span>) &#123;</span></span><br><span class="line">  <span class="keyword">for</span> ( ; first != last; ++first)</span><br><span class="line">    <span class="keyword">if</span> (!pred(*first)) &#123;</span><br><span class="line">      *result = *first;</span><br><span class="line">      ++result;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h3><p>将区间内的所有元素用新元素取代<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">replace</span>(<span class="title">ForwardIterator</span> <span class="title">first</span>, <span class="title">ForwardIterator</span> <span class="title">last</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">old_value</span>,</span></span><br><span class="line"><span class="class">             <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">new_value</span>) &#123;</span></span><br><span class="line">  <span class="keyword">for</span> ( ; first != last; ++first)</span><br><span class="line">    <span class="keyword">if</span> (*first == old_value) *first = new_value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="replace-copy"><a href="#replace-copy" class="headerlink" title="replace_copy"></a>replace_copy</h3><p>与replace类似，只不过复制到其他容器上。新容器可以与原容器重叠<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">OutputIterator</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">OutputIterator</span> <span class="title">replace_copy</span>(<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>,</span></span><br><span class="line"><span class="class">                            <span class="title">OutputIterator</span> <span class="title">result</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">old_value</span>,</span></span><br><span class="line"><span class="class">                            <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">new_value</span>) &#123;</span></span><br><span class="line">  <span class="keyword">for</span> ( ; first != last; ++first, ++result)</span><br><span class="line">    *result = *first == old_value ? new_value : *first;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="replace-if"><a href="#replace-if" class="headerlink" title="replace_if"></a>replace_if</h3><p>移除区间内被仿函数判定为true的元素。原理与replace类似。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>, <span class="title">class</span> <span class="title">Predicate</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">replace_if</span>(<span class="title">ForwardIterator</span> <span class="title">first</span>, <span class="title">ForwardIterator</span> <span class="title">last</span>, <span class="title">Predicate</span> <span class="title">pred</span>,</span></span><br><span class="line"><span class="class">                <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">new_value</span>) &#123;</span></span><br><span class="line">  <span class="keyword">for</span> ( ; first != last; ++first)</span><br><span class="line">    <span class="keyword">if</span> (pred(*first)) *first = new_value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="replace-copy-if"><a href="#replace-copy-if" class="headerlink" title="replace_copy_if"></a>replace_copy_if</h3><p>与replace_if类似，但是新序列复制到result所指的区间内。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Iterator</span>, <span class="title">class</span> <span class="title">OutputIterator</span>, <span class="title">class</span> <span class="title">Predicate</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">OutputIterator</span> <span class="title">replace_copy_if</span>(<span class="title">Iterator</span> <span class="title">first</span>, <span class="title">Iterator</span> <span class="title">last</span>,</span></span><br><span class="line"><span class="class">                               <span class="title">OutputIterator</span> <span class="title">result</span>, <span class="title">Predicate</span> <span class="title">pred</span>,</span></span><br><span class="line"><span class="class">                               <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">new_value</span>) &#123;</span></span><br><span class="line">  <span class="keyword">for</span> ( ; first != last; ++first, ++result)</span><br><span class="line">    *result = pred(*first) ? new_value : *first;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h3><p>将序列的元素在原容器中颠倒重排。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">BidirectionalIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">reverse</span>(<span class="title">BidirectionalIterator</span> <span class="title">first</span>, <span class="title">BidirectionalIterator</span> <span class="title">last</span>,</span></span><br><span class="line"><span class="class">               <span class="title">bidirectional_iterator_tag</span>) &#123;</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">if</span> (first == last || first == --last)</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      iter_swap(first++, last);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">reverse</span>(<span class="title">RandomAccessIterator</span> <span class="title">first</span>, <span class="title">RandomAccessIterator</span> <span class="title">last</span>,</span></span><br><span class="line"><span class="class">               <span class="title">random_access_iterator_tag</span>) &#123;</span></span><br><span class="line">  <span class="keyword">while</span> (first &lt; last) iter_swap(first++, --last);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">BidirectionalIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">reverse</span>(<span class="title">BidirectionalIterator</span> <span class="title">first</span>, <span class="title">BidirectionalIterator</span> <span class="title">last</span>) &#123;</span></span><br><span class="line">  __reverse(first, last, iterator_category(first));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="reverse-copy"><a href="#reverse-copy" class="headerlink" title="reverse_copy"></a>reverse_copy</h3><p>将序列颠倒重排，将结果置于另一序列<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">BidirectionalIterator</span>, <span class="title">class</span> <span class="title">OutputIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">OutputIterator</span> <span class="title">reverse_copy</span>(<span class="title">BidirectionalIterator</span> <span class="title">first</span>,</span></span><br><span class="line"><span class="class">                            <span class="title">BidirectionalIterator</span> <span class="title">last</span>,</span></span><br><span class="line"><span class="class">                            <span class="title">OutputIterator</span> <span class="title">result</span>) &#123;</span></span><br><span class="line">  <span class="keyword">while</span> (first != last) &#123;</span><br><span class="line">    --last;</span><br><span class="line">    *result = *last;</span><br><span class="line">    ++result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="rotate"><a href="#rotate" class="headerlink" title="rotate"></a>rotate</h3><p>以middle为中心将序列旋转，middle所指的元素将会变成第一个元素。<code>rotate()</code>可以交换两个长度不同的区间，<code>swap_range()</code>只能交换长度相同的。<br><img src="/img/1610595244.jpg" alt></p>
<p><img src="/img/1610595463.jpg" alt></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">rotate</span>(<span class="title">ForwardIterator</span> <span class="title">first</span>, <span class="title">ForwardIterator</span> <span class="title">middle</span>,</span></span><br><span class="line"><span class="class">                   <span class="title">ForwardIterator</span> <span class="title">last</span>) &#123;</span></span><br><span class="line">  <span class="keyword">if</span> (first == middle || middle == last) <span class="keyword">return</span>;</span><br><span class="line">  __rotate(first, middle, last, distance_type(first),</span><br><span class="line">           iterator_category(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>, <span class="title">class</span> <span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">rotate</span>(<span class="title">ForwardIterator</span> <span class="title">first</span>, <span class="title">ForwardIterator</span> <span class="title">middle</span>,</span></span><br><span class="line"><span class="class">              <span class="title">ForwardIterator</span> <span class="title">last</span>, <span class="title">Distance</span>*, <span class="title">forward_iterator_tag</span>) &#123;</span></span><br><span class="line">  <span class="keyword">for</span> (ForwardIterator i = middle; ;) &#123;</span><br><span class="line">    iter_swap(first, i);</span><br><span class="line">    ++first;</span><br><span class="line">    ++i;</span><br><span class="line">    <span class="keyword">if</span> (first == middle) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i == last) <span class="keyword">return</span>;</span><br><span class="line">      middle = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (i == last)</span><br><span class="line">      i = middle;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">BidirectionalIterator</span>, <span class="title">class</span> <span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">rotate</span>(<span class="title">BidirectionalIterator</span> <span class="title">first</span>, <span class="title">BidirectionalIterator</span> <span class="title">middle</span>,</span></span><br><span class="line"><span class="class">              <span class="title">BidirectionalIterator</span> <span class="title">last</span>, <span class="title">Distance</span>*,</span></span><br><span class="line"><span class="class">              <span class="title">bidirectional_iterator_tag</span>) &#123;</span></span><br><span class="line">  reverse(first, middle);</span><br><span class="line">  reverse(middle, last);</span><br><span class="line">  reverse(first, last);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>, <span class="title">class</span> <span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">rotate</span>(<span class="title">RandomAccessIterator</span> <span class="title">first</span>, <span class="title">RandomAccessIterator</span> <span class="title">middle</span>,</span></span><br><span class="line"><span class="class">              <span class="title">RandomAccessIterator</span> <span class="title">last</span>, <span class="title">Distance</span>*,</span></span><br><span class="line"><span class="class">              <span class="title">random_access_iterator_tag</span>) &#123;</span></span><br><span class="line">  Distance n = __gcd(last - first, middle - first);</span><br><span class="line">  <span class="keyword">while</span> (n--)</span><br><span class="line">    __rotate_cycle(first, last, first + n, middle - first,</span><br><span class="line">                   value_type(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">EuclideanRingElement</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">EuclideanRingElement</span> __<span class="title">gcd</span>(<span class="title">EuclideanRingElement</span> <span class="title">m</span>, <span class="title">EuclideanRingElement</span> <span class="title">n</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">    EuclideanRingElement t = m % n;</span><br><span class="line">    m = n;</span><br><span class="line">    n = t;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>, <span class="title">class</span> <span class="title">Distance</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">rotate_cycle</span>(<span class="title">RandomAccessIterator</span> <span class="title">first</span>, <span class="title">RandomAccessIterator</span> <span class="title">last</span>,</span></span><br><span class="line"><span class="class">                    <span class="title">RandomAccessIterator</span> <span class="title">initial</span>, <span class="title">Distance</span> <span class="title">shift</span>, <span class="title">T</span>*) &#123;</span></span><br><span class="line">  T value = *initial;</span><br><span class="line">  RandomAccessIterator ptr1 = initial;</span><br><span class="line">  RandomAccessIterator ptr2 = ptr1 + shift;</span><br><span class="line">  <span class="keyword">while</span> (ptr2 != initial) &#123;</span><br><span class="line">    *ptr1 = *ptr2;</span><br><span class="line">    ptr1 = ptr2;</span><br><span class="line">    <span class="keyword">if</span> (last - ptr2 &gt; shift)</span><br><span class="line">      ptr2 += shift;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      ptr2 = first + (shift - (last - ptr2));</span><br><span class="line">  &#125;</span><br><span class="line">  *ptr1 = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="rotate-copy"><a href="#rotate-copy" class="headerlink" title="rotate_copy"></a>rotate_copy</h3><p>和rotate类似，将结果置于另一序列<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>, <span class="title">class</span> <span class="title">OutputIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">OutputIterator</span> <span class="title">rotate_copy</span>(<span class="title">ForwardIterator</span> <span class="title">first</span>, <span class="title">ForwardIterator</span> <span class="title">middle</span>,</span></span><br><span class="line"><span class="class">                           <span class="title">ForwardIterator</span> <span class="title">last</span>, <span class="title">OutputIterator</span> <span class="title">result</span>) &#123;</span></span><br><span class="line">  <span class="keyword">return</span> copy(first, middle, copy(middle, last, result));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="search"><a href="#search" class="headerlink" title="search"></a>search</h3><p>在序列1中查找序列2的首次出现点，序列1中要求序列2完全匹配，不能间隔。不存在就返回last1。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator1</span>, <span class="title">class</span> <span class="title">ForwardIterator2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">ForwardIterator1</span> <span class="title">search</span>(<span class="title">ForwardIterator1</span> <span class="title">first1</span>, <span class="title">ForwardIterator1</span> <span class="title">last1</span>,</span></span><br><span class="line"><span class="class">                               <span class="title">ForwardIterator2</span> <span class="title">first2</span>, <span class="title">ForwardIterator2</span> <span class="title">last2</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">return</span> __search(first1, last1, first2, last2, distance_type(first1),</span><br><span class="line">                  distance_type(first2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator1</span>, <span class="title">class</span> <span class="title">ForwardIterator2</span>,</span></span><br><span class="line"><span class="class">          <span class="title">class</span> <span class="title">BinaryPredicate</span>, <span class="title">class</span> <span class="title">Distance1</span>, <span class="title">class</span> <span class="title">Distance2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">ForwardIterator1</span> __<span class="title">search</span>(<span class="title">ForwardIterator1</span> <span class="title">first1</span>, <span class="title">ForwardIterator1</span> <span class="title">last1</span>,</span></span><br><span class="line"><span class="class">                          <span class="title">ForwardIterator2</span> <span class="title">first2</span>, <span class="title">ForwardIterator2</span> <span class="title">last2</span>,</span></span><br><span class="line"><span class="class">                          <span class="title">BinaryPredicate</span> <span class="title">binary_pred</span>, <span class="title">Distance1</span>*, <span class="title">Distance2</span>*) &#123;</span></span><br><span class="line">  Distance1 d1 = <span class="number">0</span>;</span><br><span class="line">  distance(first1, last1, d1);</span><br><span class="line">  Distance2 d2 = <span class="number">0</span>;</span><br><span class="line">  distance(first2, last2, d2);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (d1 &lt; d2) <span class="keyword">return</span> last1;</span><br><span class="line"></span><br><span class="line">  ForwardIterator1 current1 = first1;</span><br><span class="line">  ForwardIterator2 current2 = first2;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (current2 != last2)</span><br><span class="line">    <span class="keyword">if</span> (binary_pred(*current1, *current2)) &#123;</span><br><span class="line">      ++current1;</span><br><span class="line">      ++current2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (d1 == d2)</span><br><span class="line">        <span class="keyword">return</span> last1;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        current1 = ++first1;</span><br><span class="line">        current2 = first2;</span><br><span class="line">        --d1;</span><br><span class="line">      &#125; </span><br><span class="line">    &#125; </span><br><span class="line">  <span class="keyword">return</span> first1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="search-n"><a href="#search-n" class="headerlink" title="search_n"></a>search_n</h3><p>和search类似，查找连续n个符合条件的元素形成的子序列。<br><img src="/img/1610595681.jpg" alt><br><img src="/img/1610595745.jpg" alt></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>, <span class="title">class</span> <span class="title">Integer</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">ForwardIterator</span> <span class="title">search_n</span>(<span class="title">ForwardIterator</span> <span class="title">first</span>, <span class="title">ForwardIterator</span> <span class="title">last</span>,</span></span><br><span class="line"><span class="class">                         <span class="title">Integer</span> <span class="title">count</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">value</span>) &#123;</span></span><br><span class="line">  <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> first;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    first = find(first, last, value);</span><br><span class="line">    <span class="keyword">while</span> (first != last) &#123;</span><br><span class="line">      Integer n = count - <span class="number">1</span>;</span><br><span class="line">      ForwardIterator i = first;</span><br><span class="line">      ++i;</span><br><span class="line">      <span class="keyword">while</span> (i != last &amp;&amp; n != <span class="number">0</span> &amp;&amp; *i == value) &#123;</span><br><span class="line">        ++i;</span><br><span class="line">        --n;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        first = find(i, last, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> last;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>, <span class="title">class</span> <span class="title">Integer</span>, <span class="title">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">BinaryPredicate</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">ForwardIterator</span> <span class="title">search_n</span>(<span class="title">ForwardIterator</span> <span class="title">first</span>, <span class="title">ForwardIterator</span> <span class="title">last</span>,</span></span><br><span class="line"><span class="class">                         <span class="title">Integer</span> <span class="title">count</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">value</span>,</span></span><br><span class="line"><span class="class">                         <span class="title">BinaryPredicate</span> <span class="title">binary_pred</span>) &#123;</span></span><br><span class="line">  <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> first;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (first != last) &#123;</span><br><span class="line">      <span class="keyword">if</span> (binary_pred(*first, value)) <span class="keyword">break</span>;</span><br><span class="line">      ++first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (first != last) &#123;</span><br><span class="line">      Integer n = count - <span class="number">1</span>;</span><br><span class="line">      ForwardIterator i = first;</span><br><span class="line">      ++i;</span><br><span class="line">      <span class="keyword">while</span> (i != last &amp;&amp; n != <span class="number">0</span> &amp;&amp; binary_pred(*i, value)) &#123;</span><br><span class="line">        ++i;</span><br><span class="line">        --n;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (i != last) &#123;</span><br><span class="line">          <span class="keyword">if</span> (binary_pred(*i, value)) <span class="keyword">break</span>;</span><br><span class="line">          ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        first = i;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> last;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="swap-range"><a href="#swap-range" class="headerlink" title="swap_range"></a>swap_range</h3><p>将两个长度相同的序列交换。两个序列可以在同一容器，也可在不同容器。如果第一个序列长度小于第二个或者两个序列有重叠，结果不可预期。<br>返回第二个序列最后一个交换元素的下一位置<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator1</span>, <span class="title">class</span> <span class="title">ForwardIterator2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">ForwardIterator2</span> <span class="title">swap_ranges</span>(<span class="title">ForwardIterator1</span> <span class="title">first1</span>, <span class="title">ForwardIterator1</span> <span class="title">last1</span>,</span></span><br><span class="line"><span class="class">                             <span class="title">ForwardIterator2</span> <span class="title">first2</span>) &#123;</span></span><br><span class="line">  <span class="keyword">for</span> ( ; first1 != last1; ++first1, ++first2)</span><br><span class="line">    iter_swap(first1, first2);</span><br><span class="line">  <span class="keyword">return</span> first2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="transform"><a href="#transform" class="headerlink" title="transform"></a>transform</h3><p>将仿函数作用于每一个元素身上，并以其结果产生出一个新序列<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">OutputIterator</span>, <span class="title">class</span> <span class="title">UnaryOperation</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">OutputIterator</span> <span class="title">transform</span>(<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>,</span></span><br><span class="line"><span class="class">                         <span class="title">OutputIterator</span> <span class="title">result</span>, <span class="title">UnaryOperation</span> <span class="title">op</span>) &#123;</span></span><br><span class="line">  <span class="keyword">for</span> ( ; first != last; ++first, ++result)</span><br><span class="line">    *result = op(*first);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator1</span>, <span class="title">class</span> <span class="title">InputIterator2</span>, <span class="title">class</span> <span class="title">OutputIterator</span>,</span></span><br><span class="line"><span class="class">          <span class="title">class</span> <span class="title">BinaryOperation</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">OutputIterator</span> <span class="title">transform</span>(<span class="title">InputIterator1</span> <span class="title">first1</span>, <span class="title">InputIterator1</span> <span class="title">last1</span>,</span></span><br><span class="line"><span class="class">                         <span class="title">InputIterator2</span> <span class="title">first2</span>, <span class="title">OutputIterator</span> <span class="title">result</span>,</span></span><br><span class="line"><span class="class">                         <span class="title">BinaryOperation</span> <span class="title">binary_op</span>) &#123;</span></span><br><span class="line">  <span class="keyword">for</span> ( ; first1 != last1; ++first1, ++first2, ++result)</span><br><span class="line">    *result = binary_op(*first1, *first2);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="unique"><a href="#unique" class="headerlink" title="unique"></a>unique</h3><p>移除相邻的重复元素。类似于remove，并不是真正移除，而是将不重复的元素重新赋值于区间上。因为区间大小并未改变，所以尾部会有残余数据。算法是稳定的，所有你保留下来的元素其相对位置不变。<br><img src="/img/1610595857.jpg" alt></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">ForwardIterator</span> <span class="title">unique</span>(<span class="title">ForwardIterator</span> <span class="title">first</span>, <span class="title">ForwardIterator</span> <span class="title">last</span>) &#123;</span></span><br><span class="line">  first = adjacent_find(first, last);</span><br><span class="line">  <span class="keyword">return</span> unique_copy(first, last, first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="unique-copy"><a href="#unique-copy" class="headerlink" title="unique_copy"></a>unique_copy</h3><p>与unique类似，将结果复制到另一区间。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">OutputIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">OutputIterator</span> <span class="title">unique_copy</span>(<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>,</span></span><br><span class="line"><span class="class">                                  <span class="title">OutputIterator</span> <span class="title">result</span>) &#123;</span></span><br><span class="line">  <span class="keyword">if</span> (first == last) <span class="keyword">return</span> result;</span><br><span class="line">  <span class="keyword">return</span> __unique_copy(first, last, result, iterator_category(result));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">ForwardIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">ForwardIterator</span> __<span class="title">unique_copy</span>(<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>,</span></span><br><span class="line"><span class="class">                              <span class="title">ForwardIterator</span> <span class="title">result</span>, <span class="title">forward_iterator_tag</span>) &#123;</span></span><br><span class="line">  *result = *first;</span><br><span class="line">  <span class="keyword">while</span> (++first != last)</span><br><span class="line">    <span class="keyword">if</span> (*result != *first) *++result = *first;</span><br><span class="line">  <span class="keyword">return</span> ++result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">OutputIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">OutputIterator</span> __<span class="title">unique_copy</span>(<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>,</span></span><br><span class="line"><span class="class">                                    <span class="title">OutputIterator</span> <span class="title">result</span>,</span></span><br><span class="line"><span class="class">                                    <span class="title">output_iterator_tag</span>) &#123;</span></span><br><span class="line">  <span class="keyword">return</span> __unique_copy(first, last, result, value_type(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">OutputIterator</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">OutputIterator</span> __<span class="title">unique_copy</span>(<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>,</span></span><br><span class="line"><span class="class">                             <span class="title">OutputIterator</span> <span class="title">result</span>, <span class="title">T</span>*) &#123;</span></span><br><span class="line">  T value = *first;</span><br><span class="line">  *result = value;</span><br><span class="line">  <span class="keyword">while</span> (++first != last)</span><br><span class="line">    <span class="keyword">if</span> (value != *first) &#123;</span><br><span class="line">      value = *first;</span><br><span class="line">      *++result = value;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> ++result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="lower-bound"><a href="#lower-bound" class="headerlink" title="lower_bound"></a>lower_bound</h3><p>lower_bound 二分查找的一个版本，在已排序区间中查找value。如果区间中有该元素，则返回迭代器，指向第一个该元素。如果没有改元素，则返回一个不小于value的元素。返回值为：在不破坏排序的情况下，可插入value的位置。<br><img src="/img/1610604585.jpg" alt></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">ForwardIterator</span> <span class="title">lower_bound</span>(<span class="title">ForwardIterator</span> <span class="title">first</span>, <span class="title">ForwardIterator</span> <span class="title">last</span>,</span></span><br><span class="line"><span class="class">                                   <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">value</span>) &#123;</span></span><br><span class="line">  <span class="keyword">return</span> __lower_bound(first, last, value, distance_type(first),</span><br><span class="line">                       iterator_category(first));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>, <span class="title">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">ForwardIterator</span> <span class="title">lower_bound</span>(<span class="title">ForwardIterator</span> <span class="title">first</span>, <span class="title">ForwardIterator</span> <span class="title">last</span>,</span></span><br><span class="line"><span class="class">                                   <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">value</span>, <span class="title">Compare</span> <span class="title">comp</span>) &#123;</span></span><br><span class="line">  <span class="keyword">return</span> __lower_bound(first, last, value, comp, distance_type(first),</span><br><span class="line">                       iterator_category(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>, <span class="title">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Compare</span>, <span class="title">class</span> <span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">ForwardIterator</span> __<span class="title">lower_bound</span>(<span class="title">ForwardIterator</span> <span class="title">first</span>, <span class="title">ForwardIterator</span> <span class="title">last</span>,</span></span><br><span class="line"><span class="class">                              <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">value</span>, <span class="title">Compare</span> <span class="title">comp</span>, <span class="title">Distance</span>*,</span></span><br><span class="line"><span class="class">                              <span class="title">forward_iterator_tag</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Distance len = <span class="number">0</span>;</span><br><span class="line">    distance(first, last, len);</span><br><span class="line">    Distance half;</span><br><span class="line">    ForwardIterator middle;</span><br><span class="line">    <span class="keyword">while</span>(len &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        half = len &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        middle = first; <span class="comment">//对于前向迭代器才需要用这种方式寻找位置，对于随机访问迭代器可以直接+ </span></span><br><span class="line">        first = advance(middle, half);</span><br><span class="line">        <span class="keyword">if</span>(*middle &lt; value)</span><br><span class="line">        &#123;</span><br><span class="line">            first = middle + <span class="number">1</span>;</span><br><span class="line">            ++first;</span><br><span class="line">            len = len - half - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//即使是相等，还需要迭代，因为要找出相等的元素中最前一个的位置 </span></span><br><span class="line">        &#123;</span><br><span class="line">            len = half;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>, <span class="title">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Compare</span>, <span class="title">class</span> <span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">RandomAccessIterator</span> __<span class="title">lower_bound</span>(<span class="title">RandomAccessIterator</span> <span class="title">first</span>,</span></span><br><span class="line"><span class="class">                                   <span class="title">RandomAccessIterator</span> <span class="title">last</span>,</span></span><br><span class="line"><span class="class">                                   <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">value</span>, <span class="title">Compare</span> <span class="title">comp</span>, <span class="title">Distance</span>*,</span></span><br><span class="line"><span class="class">                                   <span class="title">random_access_iterator_tag</span>) &#123;</span></span><br><span class="line">  Distance len = last - first;</span><br><span class="line">  Distance half;</span><br><span class="line">  RandomAccessIterator middle;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    half = len &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    middle = first + half;</span><br><span class="line">    <span class="keyword">if</span> (comp(*middle, value)) &#123;</span><br><span class="line">      first = middle + <span class="number">1</span>;</span><br><span class="line">      len = len - half - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      len = half;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="upper-bound"><a href="#upper-bound" class="headerlink" title="upper_bound"></a>upper_bound</h3><p>upper_bound 和上述函数类似，寻找的是符合条件的位置的上限</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">ForwardIterator</span> <span class="title">upper_bound</span>(<span class="title">ForwardIterator</span> <span class="title">first</span>, <span class="title">ForwardIterator</span> <span class="title">last</span>,</span></span><br><span class="line"><span class="class">                                   <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">value</span>) &#123;</span></span><br><span class="line">  <span class="keyword">return</span> __upper_bound(first, last, value, distance_type(first),</span><br><span class="line">                       iterator_category(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>, <span class="title">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">ForwardIterator</span> <span class="title">upper_bound</span>(<span class="title">ForwardIterator</span> <span class="title">first</span>, <span class="title">ForwardIterator</span> <span class="title">last</span>,</span></span><br><span class="line"><span class="class">                                   <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">value</span>, <span class="title">Compare</span> <span class="title">comp</span>) &#123;</span></span><br><span class="line">  <span class="keyword">return</span> __upper_bound(first, last, value, comp, distance_type(first),</span><br><span class="line">                       iterator_category(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>, <span class="title">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">ForwardIterator</span> __<span class="title">upper_bound</span>(<span class="title">ForwardIterator</span> <span class="title">first</span>, <span class="title">ForwardIterator</span> <span class="title">last</span>,</span></span><br><span class="line"><span class="class">                              <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">value</span>, <span class="title">Distance</span>*,</span></span><br><span class="line"><span class="class">                              <span class="title">forward_iterator_tag</span>) &#123;</span></span><br><span class="line">  Distance len = <span class="number">0</span>;</span><br><span class="line">  distance(first, last, len);</span><br><span class="line">  Distance half;</span><br><span class="line">  ForwardIterator middle;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    half = len &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    middle = first;</span><br><span class="line">    advance(middle, half);</span><br><span class="line">    <span class="keyword">if</span> (value &lt; *middle)</span><br><span class="line">      len = half;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      first = middle;</span><br><span class="line">      ++first;</span><br><span class="line">      len = len - half - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>, <span class="title">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">RandomAccessIterator</span> __<span class="title">upper_bound</span>(<span class="title">RandomAccessIterator</span> <span class="title">first</span>,</span></span><br><span class="line"><span class="class">                                   <span class="title">RandomAccessIterator</span> <span class="title">last</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">value</span>,</span></span><br><span class="line"><span class="class">                                   <span class="title">Distance</span>*, <span class="title">random_access_iterator_tag</span>) &#123;</span></span><br><span class="line">  Distance len = last - first;</span><br><span class="line">  Distance half;</span><br><span class="line">  RandomAccessIterator middle;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    half = len &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    middle = first + half;</span><br><span class="line">    <span class="keyword">if</span> (value &lt; *middle)</span><br><span class="line">      len = half;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      first = middle + <span class="number">1</span>;</span><br><span class="line">      len = len - half - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>, <span class="title">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Compare</span>, <span class="title">class</span> <span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">ForwardIterator</span> __<span class="title">upper_bound</span>(<span class="title">ForwardIterator</span> <span class="title">first</span>, <span class="title">ForwardIterator</span> <span class="title">last</span>,</span></span><br><span class="line"><span class="class">                              <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">value</span>, <span class="title">Compare</span> <span class="title">comp</span>, <span class="title">Distance</span>*,</span></span><br><span class="line"><span class="class">                              <span class="title">forward_iterator_tag</span>) &#123;</span></span><br><span class="line">  Distance len = <span class="number">0</span>;</span><br><span class="line">  distance(first, last, len);</span><br><span class="line">  Distance half;</span><br><span class="line">  ForwardIterator middle;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    half = len &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    middle = first;</span><br><span class="line">    advance(middle, half);</span><br><span class="line">    <span class="keyword">if</span> (comp(value, *middle))</span><br><span class="line">      len = half;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      first = middle;</span><br><span class="line">      ++first;</span><br><span class="line">      len = len - half - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>, <span class="title">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Compare</span>, <span class="title">class</span> <span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">RandomAccessIterator</span> __<span class="title">upper_bound</span>(<span class="title">RandomAccessIterator</span> <span class="title">first</span>,</span></span><br><span class="line"><span class="class">                                   <span class="title">RandomAccessIterator</span> <span class="title">last</span>,</span></span><br><span class="line"><span class="class">                                   <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">value</span>, <span class="title">Compare</span> <span class="title">comp</span>, <span class="title">Distance</span>*,</span></span><br><span class="line"><span class="class">                                   <span class="title">random_access_iterator_tag</span>) &#123;</span></span><br><span class="line">  Distance len = last - first;</span><br><span class="line">  Distance half;</span><br><span class="line">  RandomAccessIterator middle;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    half = len &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    middle = first + half;</span><br><span class="line">    <span class="keyword">if</span> (comp(value, *middle))</span><br><span class="line">      len = half;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      first = middle + <span class="number">1</span>;</span><br><span class="line">      len = len - half - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="binary-search"><a href="#binary-search" class="headerlink" title="binary_search"></a>binary_search</h3><p>算法binary_search是一种二分查找法，试图在已排序的[first, last)中寻找元素value。如果[first, last)内有等同于value的元素，便返回true， 否则返回false。</p>
<p>返回单纯的bool或许不能满足你，前面所介绍的lower_bound和upper_bound能够提供额外的信息。事实上binary_search便是利用lower_bound先找出“假设value存在的话，应该出现的位置”。然后再对比该位置上的值是 否为我们所要查找的目标，并返回对比结果。 </p>
<p>正式地说，当且仅当(if and only if) [first, last)中存在一个迭代器i使<code>*i &lt; vlaue</code>和<code>value &lt; *i</code>皆不为真，返回true。 </p>
<p>函数实现原理如下：在当前序列中，从尾端往前寻找两个相邻元素，前一个记为<em>i，后一个记为</em>ii，并且满足<em>i &lt; </em>ii。然后再从尾端寻找另一个元素<em>j，如果满足</em>i &lt; *j，即将第i个元素与第j个元素对调，并将第ii个元素之后（包括ii）的所有元素颠倒排序，即求出下一个序列了。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">binary_search</span>(<span class="title">ForwardIterator</span> <span class="title">first</span>, <span class="title">ForwardIterator</span> <span class="title">last</span>,</span></span><br><span class="line"><span class="class">                   <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">value</span>) &#123;</span></span><br><span class="line">  ForwardIterator i = lower_bound(first, last, value);</span><br><span class="line">  <span class="keyword">return</span> i != last &amp;&amp; !(value &lt; *i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>, <span class="title">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">binary_search</span>(<span class="title">ForwardIterator</span> <span class="title">first</span>, <span class="title">ForwardIterator</span> <span class="title">last</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">value</span>,</span></span><br><span class="line"><span class="class">                   <span class="title">Compare</span> <span class="title">comp</span>) &#123;</span></span><br><span class="line">  ForwardIterator i = lower_bound(first, last, value, comp);</span><br><span class="line">  <span class="keyword">return</span> i != last &amp;&amp; !comp(value, *i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="next-permutation-prev-permutation"><a href="#next-permutation-prev-permutation" class="headerlink" title="next_permutation/prev_permutation"></a>next_permutation/prev_permutation</h3><p>STL中提供了2个计算排列组合关系的算法。分别是next_permucation和prev_permutaion。</p>
<p>next_permutation是用来计算下一个（next）字典序排列的组合，而prev_permutation用来计算上一个（prev）字典序的排列组合。</p>
<p>字典排序是指排列组合中，按照大小由小到大的排序，例如123的排列组着，字典排序为123,132,213,231,312,321。<br><img src="/img/1610605328.jpg" alt></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">BidirectionalIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">next_permutation</span>(<span class="title">BidirectionalIterator</span> <span class="title">first</span>,</span></span><br><span class="line"><span class="class">                      <span class="title">BidirectionalIterator</span> <span class="title">last</span>) &#123;</span></span><br><span class="line">  <span class="keyword">if</span> (first == last) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  BidirectionalIterator i = first;</span><br><span class="line">  ++i;</span><br><span class="line">  <span class="keyword">if</span> (i == last) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  i = last;</span><br><span class="line">  --i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">    BidirectionalIterator ii = i;</span><br><span class="line">    --i;</span><br><span class="line">    <span class="keyword">if</span> (*i &lt; *ii) &#123;</span><br><span class="line">      BidirectionalIterator j = last;</span><br><span class="line">      <span class="keyword">while</span> (!(*i &lt; *--j));</span><br><span class="line">      iter_swap(i, j);</span><br><span class="line">      reverse(ii, last);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i == first) &#123;</span><br><span class="line">      reverse(first, last);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">BidirectionalIterator</span>, <span class="title">class</span> <span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">next_permutation</span>(<span class="title">BidirectionalIterator</span> <span class="title">first</span>, <span class="title">BidirectionalIterator</span> <span class="title">last</span>,</span></span><br><span class="line"><span class="class">                      <span class="title">Compare</span> <span class="title">comp</span>) &#123;</span></span><br><span class="line">  <span class="keyword">if</span> (first == last) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  BidirectionalIterator i = first;</span><br><span class="line">  ++i;</span><br><span class="line">  <span class="keyword">if</span> (i == last) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  i = last;</span><br><span class="line">  --i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">    BidirectionalIterator ii = i;</span><br><span class="line">    --i;</span><br><span class="line">    <span class="keyword">if</span> (comp(*i, *ii)) &#123;</span><br><span class="line">      BidirectionalIterator j = last;</span><br><span class="line">      <span class="keyword">while</span> (!comp(*i, *--j));</span><br><span class="line">      iter_swap(i, j);</span><br><span class="line">      reverse(ii, last);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i == first) &#123;</span><br><span class="line">      reverse(first, last);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">BidirectionalIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">prev_permutation</span>(<span class="title">BidirectionalIterator</span> <span class="title">first</span>,</span></span><br><span class="line"><span class="class">                      <span class="title">BidirectionalIterator</span> <span class="title">last</span>) &#123;</span></span><br><span class="line">  <span class="keyword">if</span> (first == last) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  BidirectionalIterator i = first;</span><br><span class="line">  ++i;</span><br><span class="line">  <span class="keyword">if</span> (i == last) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  i = last;</span><br><span class="line">  --i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">    BidirectionalIterator ii = i;</span><br><span class="line">    --i;</span><br><span class="line">    <span class="keyword">if</span> (*ii &lt; *i) &#123;</span><br><span class="line">      BidirectionalIterator j = last;</span><br><span class="line">      <span class="keyword">while</span> (!(*--j &lt; *i));</span><br><span class="line">      iter_swap(i, j);</span><br><span class="line">      reverse(ii, last);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i == first) &#123;</span><br><span class="line">      reverse(first, last);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">BidirectionalIterator</span>, <span class="title">class</span> <span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">prev_permutation</span>(<span class="title">BidirectionalIterator</span> <span class="title">first</span>, <span class="title">BidirectionalIterator</span> <span class="title">last</span>,</span></span><br><span class="line"><span class="class">                      <span class="title">Compare</span> <span class="title">comp</span>) &#123;</span></span><br><span class="line">  <span class="keyword">if</span> (first == last) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  BidirectionalIterator i = first;</span><br><span class="line">  ++i;</span><br><span class="line">  <span class="keyword">if</span> (i == last) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  i = last;</span><br><span class="line">  --i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">    BidirectionalIterator ii = i;</span><br><span class="line">    --i;</span><br><span class="line">    <span class="keyword">if</span> (comp(*ii, *i)) &#123;</span><br><span class="line">      BidirectionalIterator j = last;</span><br><span class="line">      <span class="keyword">while</span> (!comp(*--j, *i));</span><br><span class="line">      iter_swap(i, j);</span><br><span class="line">      reverse(ii, last);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i == first) &#123;</span><br><span class="line">      reverse(first, last);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="random-shuffle"><a href="#random-shuffle" class="headerlink" title="random_shuffle"></a>random_shuffle</h3><p>将区间内的元素随机重排，获得N!种全排列中的任意一种</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>, <span class="title">class</span> <span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">random_shuffle</span>(<span class="title">RandomAccessIterator</span> <span class="title">first</span>, <span class="title">RandomAccessIterator</span> <span class="title">last</span>,</span></span><br><span class="line"><span class="class">                      <span class="title">Distance</span>*) &#123;</span></span><br><span class="line">  <span class="keyword">if</span> (first == last) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">for</span> (RandomAccessIterator i = first + <span class="number">1</span>; i != last; ++i)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __STL_NO_DRAND48</span></span><br><span class="line">    iter_swap(i, first + Distance(rand() % ((i - first) + <span class="number">1</span>)));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  iter_swap(i, first + Distance(lrand48() % ((i - first) + <span class="number">1</span>)));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">random_shuffle</span>(<span class="title">RandomAccessIterator</span> <span class="title">first</span>,</span></span><br><span class="line"><span class="class">                           <span class="title">RandomAccessIterator</span> <span class="title">last</span>) &#123;</span></span><br><span class="line">  __random_shuffle(first, last, distance_type(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>, <span class="title">class</span> <span class="title">RandomNumberGenerator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">random_shuffle</span>(<span class="title">RandomAccessIterator</span> <span class="title">first</span>, <span class="title">RandomAccessIterator</span> <span class="title">last</span>,</span></span><br><span class="line"><span class="class">                    <span class="title">RandomNumberGenerator</span>&amp; <span class="title">rand</span>) &#123;</span></span><br><span class="line">  <span class="keyword">if</span> (first == last) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">for</span> (RandomAccessIterator i = first + <span class="number">1</span>; i != last; ++i)</span><br><span class="line">    iter_swap(i, first + rand((i - first) + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="partial-sort-partial-sort-copy"><a href="#partial-sort-partial-sort-copy" class="headerlink" title="partial_sort/partial_sort_copy"></a>partial_sort/partial_sort_copy</h3><p>本算法接受一个middle迭代器（位于序列[first, last)之内），然后重新安排[first, last)，使序列中的middle-first个最小元素以递增顺序排序， 置于[first, middle)内、其余last-middle个元素安置于[middle, last)中， 不保证有任何特定顺序。 </p>
<p>使用sort算法，同样能保证较小的N个元素以递增顺序置于[first, first+N)中， </p>
<p>partial_sort的任务是找出middle-first个最小元素，因此，首先界定出区间[first, middle)，并利用<code>make_heap()</code>将它组织成一个 max-heap，然后就可以将[middle, last)中的每一个元素拿来与max-heap的最大值比较（max-heap的最大值就在第一个元素身上，轻松可以获得）：如果小于该最大值，则互换位置并保持max-heap状态。<br><img src="/img/1610605767.jpg" alt></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">partial_sort</span>(<span class="title">RandomAccessIterator</span> <span class="title">first</span>, <span class="title">RandomAccessIterator</span> <span class="title">middle</span>,</span></span><br><span class="line"><span class="class">                    <span class="title">RandomAccessIterator</span> <span class="title">last</span>, <span class="title">T</span>*) &#123;</span></span><br><span class="line">  make_heap(first, middle);</span><br><span class="line">  <span class="keyword">for</span> (RandomAccessIterator i = middle; i &lt; last; ++i)</span><br><span class="line">    <span class="keyword">if</span> (*i &lt; *first)</span><br><span class="line">      __pop_heap(first, middle, i, T(*i), distance_type(first));</span><br><span class="line">  sort_heap(first, middle);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">partial_sort</span>(<span class="title">RandomAccessIterator</span> <span class="title">first</span>,</span></span><br><span class="line"><span class="class">                         <span class="title">RandomAccessIterator</span> <span class="title">middle</span>,</span></span><br><span class="line"><span class="class">                         <span class="title">RandomAccessIterator</span> <span class="title">last</span>) &#123;</span></span><br><span class="line">  __partial_sort(first, middle, last, value_type(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>, <span class="title">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">partial_sort</span>(<span class="title">RandomAccessIterator</span> <span class="title">first</span>, <span class="title">RandomAccessIterator</span> <span class="title">middle</span>,</span></span><br><span class="line"><span class="class">                    <span class="title">RandomAccessIterator</span> <span class="title">last</span>, <span class="title">T</span>*, <span class="title">Compare</span> <span class="title">comp</span>) &#123;</span></span><br><span class="line">  make_heap(first, middle, comp);</span><br><span class="line">  <span class="keyword">for</span> (RandomAccessIterator i = middle; i &lt; last; ++i)</span><br><span class="line">    <span class="keyword">if</span> (comp(*i, *first))</span><br><span class="line">      __pop_heap(first, middle, i, T(*i), comp, distance_type(first));</span><br><span class="line">  sort_heap(first, middle, comp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>, <span class="title">class</span> <span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">partial_sort</span>(<span class="title">RandomAccessIterator</span> <span class="title">first</span>,</span></span><br><span class="line"><span class="class">                         <span class="title">RandomAccessIterator</span> <span class="title">middle</span>,</span></span><br><span class="line"><span class="class">                         <span class="title">RandomAccessIterator</span> <span class="title">last</span>, <span class="title">Compare</span> <span class="title">comp</span>) &#123;</span></span><br><span class="line">  __partial_sort(first, middle, last, value_type(first), comp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>partial_sort</code>有一个姊妹，就是<code>partial_sort_copy</code>，它将（last-first）个最小元素排序后的结果置于（rsult_first, result_last）中。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">RandomAccessIterator</span>, <span class="title">class</span> <span class="title">Distance</span>,</span></span><br><span class="line"><span class="class">          <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">RandomAccessIterator</span> __<span class="title">partial_sort_copy</span>(<span class="title">InputIterator</span> <span class="title">first</span>,</span></span><br><span class="line"><span class="class">                                         <span class="title">InputIterator</span> <span class="title">last</span>,</span></span><br><span class="line"><span class="class">                                         <span class="title">RandomAccessIterator</span> <span class="title">result_first</span>,</span></span><br><span class="line"><span class="class">                                         <span class="title">RandomAccessIterator</span> <span class="title">result_last</span>,</span></span><br><span class="line"><span class="class">                                         <span class="title">Distance</span>*, <span class="title">T</span>*) &#123;</span></span><br><span class="line">  <span class="keyword">if</span> (result_first == result_last) <span class="keyword">return</span> result_last;</span><br><span class="line">  RandomAccessIterator result_real_last = result_first;</span><br><span class="line">  <span class="keyword">while</span>(first != last &amp;&amp; result_real_last != result_last) &#123;</span><br><span class="line">    *result_real_last = *first;</span><br><span class="line">    ++result_real_last;</span><br><span class="line">    ++first;</span><br><span class="line">  &#125;</span><br><span class="line">  make_heap(result_first, result_real_last);</span><br><span class="line">  <span class="keyword">while</span> (first != last) &#123;</span><br><span class="line">    <span class="keyword">if</span> (*first &lt; *result_first)</span><br><span class="line">      __adjust_heap(result_first, Distance(<span class="number">0</span>),</span><br><span class="line">                    Distance(result_real_last - result_first), T(*first));</span><br><span class="line">    ++first;</span><br><span class="line">  &#125;</span><br><span class="line">  sort_heap(result_first, result_real_last);</span><br><span class="line">  <span class="keyword">return</span> result_real_last;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">RandomAccessIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">RandomAccessIterator</span></span></span><br><span class="line"><span class="class"><span class="title">partial_sort_copy</span>(<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>,</span></span><br><span class="line"><span class="class">                  <span class="title">RandomAccessIterator</span> <span class="title">result_first</span>,</span></span><br><span class="line"><span class="class">                  <span class="title">RandomAccessIterator</span> <span class="title">result_last</span>) &#123;</span></span><br><span class="line">  <span class="keyword">return</span> __partial_sort_copy(first, last, result_first, result_last,</span><br><span class="line">                             distance_type(result_first), value_type(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">RandomAccessIterator</span>, <span class="title">class</span> <span class="title">Compare</span>,</span></span><br><span class="line"><span class="class">          <span class="title">class</span> <span class="title">Distance</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">RandomAccessIterator</span> __<span class="title">partial_sort_copy</span>(<span class="title">InputIterator</span> <span class="title">first</span>,</span></span><br><span class="line"><span class="class">                                         <span class="title">InputIterator</span> <span class="title">last</span>,</span></span><br><span class="line"><span class="class">                                         <span class="title">RandomAccessIterator</span> <span class="title">result_first</span>,</span></span><br><span class="line"><span class="class">                                         <span class="title">RandomAccessIterator</span> <span class="title">result_last</span>,</span></span><br><span class="line"><span class="class">                                         <span class="title">Compare</span> <span class="title">comp</span>, <span class="title">Distance</span>*, <span class="title">T</span>*) &#123;</span></span><br><span class="line">  <span class="keyword">if</span> (result_first == result_last) <span class="keyword">return</span> result_last;</span><br><span class="line">  RandomAccessIterator result_real_last = result_first;</span><br><span class="line">  <span class="keyword">while</span>(first != last &amp;&amp; result_real_last != result_last) &#123;</span><br><span class="line">    *result_real_last = *first;</span><br><span class="line">    ++result_real_last;</span><br><span class="line">    ++first;</span><br><span class="line">  &#125;</span><br><span class="line">  make_heap(result_first, result_real_last, comp);</span><br><span class="line">  <span class="keyword">while</span> (first != last) &#123;</span><br><span class="line">    <span class="keyword">if</span> (comp(*first, *result_first))</span><br><span class="line">      __adjust_heap(result_first, Distance(<span class="number">0</span>),</span><br><span class="line">                    Distance(result_real_last - result_first), T(*first),</span><br><span class="line">                    comp);</span><br><span class="line">    ++first;</span><br><span class="line">  &#125;</span><br><span class="line">  sort_heap(result_first, result_real_last, comp);</span><br><span class="line">  <span class="keyword">return</span> result_real_last;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">RandomAccessIterator</span>, <span class="title">class</span> <span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">RandomAccessIterator</span></span></span><br><span class="line"><span class="class"><span class="title">partial_sort_copy</span>(<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>,</span></span><br><span class="line"><span class="class">                  <span class="title">RandomAccessIterator</span> <span class="title">result_first</span>,</span></span><br><span class="line"><span class="class">                  <span class="title">RandomAccessIterator</span> <span class="title">result_last</span>, <span class="title">Compare</span> <span class="title">comp</span>) &#123;</span></span><br><span class="line">  <span class="keyword">return</span> __partial_sort_copy(first, last, result_first, result_last, comp,</span><br><span class="line">                             distance_type(result_first), value_type(first));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h3><p>STL所提供的各式各样算法中，<code>sort()</code>是最复杂最庞大的一个，这个算法接受两个RandomAccessIterator（随机存取迭代器），然后将区间内的所有元素以渐增方式由小到大重新排列，第二个版本则允许用户指定一个仿函数(functor), 作为排序标准。STL的所有关系型容器(associative containers）都拥有自动排序功能（底层结构采用RB - tree），所以不需要用到这个sort算法。至于序列式容器(sequence containers）中的stacks、queue和priority-queue都有特别的出入口，不允许用户对元素排序。剩下vector、 deque和list，前两者的迭代器属于RandormAccessIterators，适合使用sort算法，list的迭代器则属于BidirectionalIterators，不在STL标准之列的slist，其迭代器属于ForwardIterators，都不适合使用sort算法。如果要对list或slist排序，应该使用它们自己提供的member functions sort()。</p>
<p>STL的sort算法，数据量大时采用Quick分段递归排序，一旦分段后的数据量小于某个门槛，为了避免QuickSort的递归调用带来过大的额外负荷，就改用InsertionSort.如果递归层次过深，还会改用HeapSort，以下分别介绍OuickSort和lnsertionSort，然后再整合起来介绍STL sort。</p>
<h4 id="InsertionSort"><a href="#InsertionSort" class="headerlink" title="InsertionSort"></a>InsertionSort</h4><p>Insertionsort以双层循环的形式进行，外循环遍历整个序列，每次迭代决定出一个子区间；内循环遍历子区间，将子区间内的每一个“逆转对（inversion)”倒转过来。“逆转对”是指任何两个迭代器i、j，<code>i &lt; j</code>而<code>*i &gt; *j</code>。一旦不存在“逆转对”，序列即排序完毕。这个算法的复杂度为O(N2)，说起来并不理想，但是当数据量很少时，却有不错的效果，原因是实现上有一些技巧，而且不像其它较为复杂的排序算法有着诸如递归调用等操作带来的额外负荷。<br><img src="/img/1610692930.jpg" alt></p>
<p>SGISTL的lnsertionsort两个版本，版本一使用以渐增力式排序，也就是说，以<code>operator&lt;</code>为两元素比较的函数，版本二允许用户指定一个仿函数，作为两元素比较的函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">insertion_sort</span>(<span class="title">RandomAccessIterator</span> <span class="title">first</span>, <span class="title">RandomAccessIterator</span> <span class="title">last</span>) &#123;</span></span><br><span class="line">  <span class="keyword">if</span> (first == last) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">for</span> (RandomAccessIterator i = first + <span class="number">1</span>; i != last; ++i)</span><br><span class="line">    __linear_insert(first, i, value_type(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>, <span class="title">class</span> <span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">insertion_sort</span>(<span class="title">RandomAccessIterator</span> <span class="title">first</span>,</span></span><br><span class="line"><span class="class">                      <span class="title">RandomAccessIterator</span> <span class="title">last</span>, <span class="title">Compare</span> <span class="title">comp</span>) &#123;</span></span><br><span class="line">  <span class="keyword">if</span> (first == last) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">for</span> (RandomAccessIterator i = first + <span class="number">1</span>; i != last; ++i)</span><br><span class="line">    __linear_insert(first, i, value_type(first), comp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> __<span class="title">linear_insert</span>(<span class="title">RandomAccessIterator</span> <span class="title">first</span>,</span></span><br><span class="line"><span class="class">                            <span class="title">RandomAccessIterator</span> <span class="title">last</span>, <span class="title">T</span>*) &#123;</span></span><br><span class="line">  T value = *last;</span><br><span class="line">  <span class="keyword">if</span> (value &lt; *first) &#123;</span><br><span class="line">    copy_backward(first, last, last + <span class="number">1</span>);</span><br><span class="line">    *first = value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    __unguarded_linear_insert(last, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>, <span class="title">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> __<span class="title">linear_insert</span>(<span class="title">RandomAccessIterator</span> <span class="title">first</span>,</span></span><br><span class="line"><span class="class">                            <span class="title">RandomAccessIterator</span> <span class="title">last</span>, <span class="title">T</span>*, <span class="title">Compare</span> <span class="title">comp</span>) &#123;</span></span><br><span class="line">  T value = *last;</span><br><span class="line">  <span class="keyword">if</span> (comp(value, *first)) &#123;</span><br><span class="line">    copy_backward(first, last, last + <span class="number">1</span>);</span><br><span class="line">    *first = value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    __unguarded_linear_insert(last, value, comp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">unguarded_linear_insert</span>(<span class="title">RandomAccessIterator</span> <span class="title">last</span>, <span class="title">T</span> <span class="title">value</span>) &#123;</span></span><br><span class="line">  RandomAccessIterator next = last;</span><br><span class="line">  --next;</span><br><span class="line">  <span class="keyword">while</span> (value &lt; *next) &#123;</span><br><span class="line">    *last = *next;</span><br><span class="line">    last = next;</span><br><span class="line">    --next;</span><br><span class="line">  &#125;</span><br><span class="line">  *last = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>, <span class="title">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">unguarded_linear_insert</span>(<span class="title">RandomAccessIterator</span> <span class="title">last</span>, <span class="title">T</span> <span class="title">value</span>,</span></span><br><span class="line"><span class="class">                               <span class="title">Compare</span> <span class="title">comp</span>) &#123;</span></span><br><span class="line">  RandomAccessIterator next = last;</span><br><span class="line">  --next;</span><br><span class="line">  <span class="keyword">while</span> (comp(value , *next)) &#123;</span><br><span class="line">    *last = *next;</span><br><span class="line">    last = next;</span><br><span class="line">    --next;</span><br><span class="line">  &#125;</span><br><span class="line">  *last = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述函数之所以命名为<code>unguarded_x</code>是因为，一般的Insertion Sort在内循环原本需要做两次判断，判断是否相邻两元素是“逆转对”；同时也判断循环的行进是否超过边界。但由于上述所示的源代码会导致最小值必然在内循环子区间的最边缘，所以两个判断可合为一个判断，所以称为unguarded。省下一个判断操作，乍见之下无足轻重，但是在大数据量的情况下，影响还是可观的，毕竟这是一 个非常根本的算法核心，在大数据量的情况，执行次数非常惊人。 </p>
<h3 id="Quick-Sort"><a href="#Quick-Sort" class="headerlink" title="Quick Sort"></a>Quick Sort</h3><p>如果我们拿Insertion Sort来处理大量数据，其O(N2)的复杂度就令人摇头了。大数据量的情形下有许多更好的排序算法可供选择。正如其名称所昭示，Quick Sort 是目前已知最快的排序法，平均复杂度为O(N logN)，最坏情况下将达O(N2)，不过IntroSort（极类似median-of-three QuickSort的一种排序算法〕可将最坏情况（分割时产生一个空的子区间）推进到O(N logN)。</p>
<p>快排的步骤：</p>
<ol>
<li>如果s的元素是0或者1，结束</li>
<li>取s 中任何一个元素，当做枢纽v</li>
<li>将s 分割为l r两部分，使l内的元素都小于等于v，r内的元素都大于v</li>
<li>对l，r递归执行快排</li>
</ol>
<p><img src="/img/1610693433.jpg" alt></p>
<p>media-of-three partitioning 取头尾中央三个位置的值的中值作为v</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">const</span> <span class="title">T</span>&amp; __<span class="title">median</span>(<span class="title">const</span> <span class="title">T</span>&amp; <span class="title">a</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">b</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">c</span>) &#123;</span></span><br><span class="line">  <span class="keyword">if</span> (a &lt; b)</span><br><span class="line">    <span class="keyword">if</span> (b &lt; c)</span><br><span class="line">      <span class="keyword">return</span> b;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a &lt; c)</span><br><span class="line">      <span class="keyword">return</span> c;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> a;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (a &lt; c)</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (b &lt; c)</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Partitioining（分割）方法不只一种，以下叙述既简单又有良好成效的做法。令头端迭代器first向尾部移动，尾端迭代器last向头部移动。当<code>*first</code>大于或等于枢轴时 就停下来，当<code>*last</code>小于或等于枢轴时也停下来，然后检验两个迭代器是否交错。如果first仍然在左而last仍然在右，就将两者元素互换，然后各自调整一个位置（向中央逼近），再继续进行相同的行为。如果发现两个迭代器交错了，表示整个序列已经调整完毕，以此时的first为轴，将序列分为左右两半，左半部所有元素值都小于或等于枢轴，右半部所有元素值都大于或等于枢轴。<br><img src="/img/1610693726.jpg" alt></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">RandomAccessIterator</span> __<span class="title">unguarded_partition</span>(<span class="title">RandomAccessIterator</span> <span class="title">first</span>,</span></span><br><span class="line"><span class="class">                                           <span class="title">RandomAccessIterator</span> <span class="title">last</span>,</span></span><br><span class="line"><span class="class">                                           <span class="title">T</span> <span class="title">pivot</span>) &#123;</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (*first &lt; pivot) ++first;</span><br><span class="line">    --last;</span><br><span class="line">    <span class="keyword">while</span> (pivot &lt; *last) --last;</span><br><span class="line">    <span class="keyword">if</span> (!(first &lt; last)) <span class="keyword">return</span> first;</span><br><span class="line">    iter_swap(first, last);</span><br><span class="line">    ++first;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>, <span class="title">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">RandomAccessIterator</span> __<span class="title">unguarded_partition</span>(<span class="title">RandomAccessIterator</span> <span class="title">first</span>,</span></span><br><span class="line"><span class="class">                                           <span class="title">RandomAccessIterator</span> <span class="title">last</span>,</span></span><br><span class="line"><span class="class">                                           <span class="title">T</span> <span class="title">pivot</span>, <span class="title">Compare</span> <span class="title">comp</span>) &#123;</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (comp(*first, pivot)) ++first;</span><br><span class="line">    --last;</span><br><span class="line">    <span class="keyword">while</span> (comp(pivot, *last)) --last;</span><br><span class="line">    <span class="keyword">if</span> (!(first &lt; last)) <span class="keyword">return</span> first;</span><br><span class="line">    iter_swap(first, last);</span><br><span class="line">    ++first;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>面对一个只有十来个元素的小型序列，使用像Quick Sort这样复杂而需要大量运算的排序法不划算，在小数据量的情况下，甚至简单如Insertion Sort者也可能快过Quick Sort―因为Quick Sort会为了极小的子序 列而产生许多的函数递归调用。鉴于这种情况，适度评估序列的大小，然后决定采用Quick Sort或Insertion Sort是值得采纳的一种优化措施。然而究竟多小的序列才应该断然改用Insertion Sort呢？并无定论，5-2O都可能导致差不多的结果。实际的最佳值因设备而异。</p>
<p>final insertion sort 优化措施永不嫌多，只要我们不是贸然行事。如果我们令某个大小以下的序列滞留在“几近排序但尚未完成”的状态、最后再以一次Insertion Sort将所有这些“几近排序但尚未竞全功”的子序列做一次完整的排序，其效率一般认为会比“将所有子序列彻底排序”更好。这是因为Insertion Sort在面对“几近排序”的序列时、有很好的表现。</p>
<p>introsort：不当的枢轴选择导致Quick Sort恶化为O(N2)，Introspective Sorting（内省排序）当分割行为有恶化为二次行为时，能够自我侦测，转而改用Heap Sort。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">sort</span>(<span class="title">RandomAccessIterator</span> <span class="title">first</span>, <span class="title">RandomAccessIterator</span> <span class="title">last</span>) &#123;</span></span><br><span class="line">  <span class="keyword">if</span> (first != last) &#123;</span><br><span class="line">    __introsort_loop(first, last, value_type(first), __lg(last - first) * <span class="number">2</span>);</span><br><span class="line">    __final_insertion_sort(first, last);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>, <span class="title">class</span> <span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">sort</span>(<span class="title">RandomAccessIterator</span> <span class="title">first</span>, <span class="title">RandomAccessIterator</span> <span class="title">last</span>,</span></span><br><span class="line"><span class="class">                 <span class="title">Compare</span> <span class="title">comp</span>) &#123;</span></span><br><span class="line">  <span class="keyword">if</span> (first != last) &#123;</span><br><span class="line">    __introsort_loop(first, last, value_type(first), __lg(last - first) * <span class="number">2</span>,</span><br><span class="line">                     comp);</span><br><span class="line">    __final_insertion_sort(first, last, comp);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中的<code>__lg()</code>用于控制分割恶化的情况。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Size</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">Size</span> __<span class="title">lg</span>(<span class="title">Size</span> <span class="title">n</span>) &#123;</span></span><br><span class="line">  Size k;</span><br><span class="line">  <span class="keyword">for</span> (k = <span class="number">0</span>; n &gt; <span class="number">1</span>; n &gt;&gt;= <span class="number">1</span>) ++k;</span><br><span class="line">  <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>元素为40个时，<code>__introsort_loop()</code>的最后一个参数为5*2，意思是最多允许10层分割。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>, <span class="title">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Size</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">introsort_loop</span>(<span class="title">RandomAccessIterator</span> <span class="title">first</span>,</span></span><br><span class="line"><span class="class">                      <span class="title">RandomAccessIterator</span> <span class="title">last</span>, <span class="title">T</span>*,</span></span><br><span class="line"><span class="class">                      <span class="title">Size</span> <span class="title">depth_limit</span>) &#123;</span></span><br><span class="line">  <span class="keyword">while</span> (last - first &gt; __stl_threshold) &#123;</span><br><span class="line">    <span class="keyword">if</span> (depth_limit == <span class="number">0</span>) &#123;</span><br><span class="line">      partial_sort(first, last, last);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    --depth_limit;</span><br><span class="line">    RandomAccessIterator cut = __unguarded_partition</span><br><span class="line">      (first, last, T(__median(*first, *(first + (last - first)/<span class="number">2</span>),</span><br><span class="line">                               *(last - <span class="number">1</span>))));</span><br><span class="line">    __introsort_loop(cut, last, value_type(first), depth_limit);</span><br><span class="line">    last = cut;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>, <span class="title">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Size</span>, <span class="title">class</span> <span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">introsort_loop</span>(<span class="title">RandomAccessIterator</span> <span class="title">first</span>,</span></span><br><span class="line"><span class="class">                      <span class="title">RandomAccessIterator</span> <span class="title">last</span>, <span class="title">T</span>*,</span></span><br><span class="line"><span class="class">                      <span class="title">Size</span> <span class="title">depth_limit</span>, <span class="title">Compare</span> <span class="title">comp</span>) &#123;</span></span><br><span class="line">  <span class="keyword">while</span> (last - first &gt; __stl_threshold) &#123;</span><br><span class="line">    <span class="keyword">if</span> (depth_limit == <span class="number">0</span>) &#123;</span><br><span class="line">      partial_sort(first, last, last, comp);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    --depth_limit;</span><br><span class="line">    RandomAccessIterator cut = __unguarded_partition</span><br><span class="line">      (first, last, T(__median(*first, *(first + (last - first)/<span class="number">2</span>),</span><br><span class="line">                               *(last - <span class="number">1</span>), comp)), comp);</span><br><span class="line">    __introsort_loop(cut, last, value_type(first), depth_limit, comp);</span><br><span class="line">    last = cut;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>函数一开始就判断序列大小，<code>__stl_threshold</code>是个全局整型常数，定义如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> __stl_threshold - <span class="number">16</span>;</span><br></pre></td></tr></table></figure></p>
<p>通过元素个数检验之后，再检查分割层次，如果分割层次超过指定值，就改用<code>partition_sort()</code>。都通过了这些检验之后，便进入与Quick Sort完全相同的程序：以median-of-3方法确定枢轴位置，然后调用<code>__unguarded_partition()</code>找出分割点，然后针对左右段落递归进行IntroSort</p>
<p>当<code>__introsort_loop()</code>结束，[first, last)内有多个“元素个数少于16”的子序列，每个子序列都有相当程度的排序，但尚未完全排序（因为元素个数一旦小于<code>__stl_threshold</code>，就被中止进一步的排序操作。回到母函数<code>sort()</code>，再进入<code>final_insertion_sort()</code>。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">final_insertion_sort</span>(<span class="title">RandomAccessIterator</span> <span class="title">first</span>,</span></span><br><span class="line"><span class="class">                            <span class="title">RandomAccessIterator</span> <span class="title">last</span>) &#123;</span></span><br><span class="line">  <span class="keyword">if</span> (last - first &gt; __stl_threshold) &#123;</span><br><span class="line">    __insertion_sort(first, first + __stl_threshold);</span><br><span class="line">    __unguarded_insertion_sort(first + __stl_threshold, last);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    __insertion_sort(first, last);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>, <span class="title">class</span> <span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">final_insertion_sort</span>(<span class="title">RandomAccessIterator</span> <span class="title">first</span>,</span></span><br><span class="line"><span class="class">                            <span class="title">RandomAccessIterator</span> <span class="title">last</span>, <span class="title">Compare</span> <span class="title">comp</span>) &#123;</span></span><br><span class="line">  <span class="keyword">if</span> (last - first &gt; __stl_threshold) &#123;</span><br><span class="line">    __insertion_sort(first, first + __stl_threshold, comp);</span><br><span class="line">    __unguarded_insertion_sort(first + __stl_threshold, last, comp);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    __insertion_sort(first, last, comp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">unguarded_insertion_sort_aux</span>(<span class="title">RandomAccessIterator</span> <span class="title">first</span>,</span></span><br><span class="line"><span class="class">                                    <span class="title">RandomAccessIterator</span> <span class="title">last</span>, <span class="title">T</span>*) &#123;</span></span><br><span class="line">  <span class="keyword">for</span> (RandomAccessIterator i = first; i != last; ++i)</span><br><span class="line">    __unguarded_linear_insert(i, T(*i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> __<span class="title">unguarded_insertion_sort</span>(<span class="title">RandomAccessIterator</span> <span class="title">first</span>,</span></span><br><span class="line"><span class="class">                                <span class="title">RandomAccessIterator</span> <span class="title">last</span>) &#123;</span></span><br><span class="line">  __unguarded_insertion_sort_aux(first, last, value_type(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>, <span class="title">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">unguarded_insertion_sort_aux</span>(<span class="title">RandomAccessIterator</span> <span class="title">first</span>,</span></span><br><span class="line"><span class="class">                                    <span class="title">RandomAccessIterator</span> <span class="title">last</span>,</span></span><br><span class="line"><span class="class">                                    <span class="title">T</span>*, <span class="title">Compare</span> <span class="title">comp</span>) &#123;</span></span><br><span class="line">  <span class="keyword">for</span> (RandomAccessIterator i = first; i != last; ++i)</span><br><span class="line">    __unguarded_linear_insert(i, T(*i), comp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>, <span class="title">class</span> <span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> __<span class="title">unguarded_insertion_sort</span>(<span class="title">RandomAccessIterator</span> <span class="title">first</span>,</span></span><br><span class="line"><span class="class">                                       <span class="title">RandomAccessIterator</span> <span class="title">last</span>,</span></span><br><span class="line"><span class="class">                                       <span class="title">Compare</span> <span class="title">comp</span>) &#123;</span></span><br><span class="line">  __unguarded_insertion_sort_aux(first, last, value_type(first), comp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="equal-range"><a href="#equal-range" class="headerlink" title="equal_range"></a>equal_range</h3><p>是二分查找法的一个版本，试图在已排序的[first, last)中寻找value，它返回一对迭代器i和j，其中i是在不破坏次序的前提下，value可插人的第一个位置（亦即lower_bound），j则是在不破坏次序的前提下，value可插人的最后一个位置（亦即upper_bound）。因此，[i ,j)内的每个元素都等同于value，而且[i, j)是[fisrt, last)之中符合此一性质的最大子区间。<br><img src="/img/1610695096.jpg" alt></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>, <span class="title">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">pair</span>&lt;ForwardIterator, ForwardIterator&gt;</span></span><br><span class="line"><span class="class">__<span class="title">equal_range</span>(<span class="title">ForwardIterator</span> <span class="title">first</span>, <span class="title">ForwardIterator</span> <span class="title">last</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">value</span>,</span></span><br><span class="line"><span class="class">              <span class="title">Distance</span>*, <span class="title">forward_iterator_tag</span>) &#123;</span></span><br><span class="line">  Distance len = <span class="number">0</span>;</span><br><span class="line">  distance(first, last, len);</span><br><span class="line">  Distance half;</span><br><span class="line">  ForwardIterator middle, left, right;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    half = len &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    middle = first;</span><br><span class="line">    advance(middle, half);</span><br><span class="line">    <span class="keyword">if</span> (*middle &lt; value) &#123;</span><br><span class="line">      first = middle;</span><br><span class="line">      ++first;</span><br><span class="line">      len = len - half - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (value &lt; *middle)</span><br><span class="line">      len = half;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      left = lower_bound(first, middle, value);</span><br><span class="line">      advance(first, len);</span><br><span class="line">      right = upper_bound(++middle, first, value);</span><br><span class="line">      <span class="keyword">return</span> pair&lt;ForwardIterator, ForwardIterator&gt;(left, right);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pair&lt;ForwardIterator, ForwardIterator&gt;(first, first);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>, <span class="title">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">pair</span>&lt;RandomAccessIterator, RandomAccessIterator&gt;</span></span><br><span class="line"><span class="class">__<span class="title">equal_range</span>(<span class="title">RandomAccessIterator</span> <span class="title">first</span>, <span class="title">RandomAccessIterator</span> <span class="title">last</span>,</span></span><br><span class="line"><span class="class">              <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">value</span>, <span class="title">Distance</span>*, <span class="title">random_access_iterator_tag</span>) &#123;</span></span><br><span class="line">  Distance len = last - first;</span><br><span class="line">  Distance half;</span><br><span class="line">  RandomAccessIterator middle, left, right;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    half = len &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    middle = first + half;</span><br><span class="line">    <span class="keyword">if</span> (*middle &lt; value) &#123;</span><br><span class="line">      first = middle + <span class="number">1</span>;</span><br><span class="line">      len = len - half - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (value &lt; *middle)</span><br><span class="line">      len = half;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      left = lower_bound(first, middle, value);</span><br><span class="line">      right = upper_bound(++middle, first + len, value);</span><br><span class="line">      <span class="keyword">return</span> pair&lt;RandomAccessIterator, RandomAccessIterator&gt;(left,</span><br><span class="line">                                                              right);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pair&lt;RandomAccessIterator, RandomAccessIterator&gt;(first, first);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">pair</span>&lt;ForwardIterator, ForwardIterator&gt;</span></span><br><span class="line"><span class="class"><span class="title">equal_range</span>(<span class="title">ForwardIterator</span> <span class="title">first</span>, <span class="title">ForwardIterator</span> <span class="title">last</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">value</span>) &#123;</span></span><br><span class="line">  <span class="keyword">return</span> __equal_range(first, last, value, distance_type(first),</span><br><span class="line">                       iterator_category(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>, <span class="title">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Compare</span>, <span class="title">class</span> <span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">pair</span>&lt;ForwardIterator, ForwardIterator&gt;</span></span><br><span class="line"><span class="class">__<span class="title">equal_range</span>(<span class="title">ForwardIterator</span> <span class="title">first</span>, <span class="title">ForwardIterator</span> <span class="title">last</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">value</span>,</span></span><br><span class="line"><span class="class">              <span class="title">Compare</span> <span class="title">comp</span>, <span class="title">Distance</span>*, <span class="title">forward_iterator_tag</span>) &#123;</span></span><br><span class="line">  Distance len = <span class="number">0</span>;</span><br><span class="line">  distance(first, last, len);</span><br><span class="line">  Distance half;</span><br><span class="line">  ForwardIterator middle, left, right;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    half = len &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    middle = first;</span><br><span class="line">    advance(middle, half);</span><br><span class="line">    <span class="keyword">if</span> (comp(*middle, value)) &#123;</span><br><span class="line">      first = middle;</span><br><span class="line">      ++first;</span><br><span class="line">      len = len - half - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (comp(value, *middle))</span><br><span class="line">      len = half;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      left = lower_bound(first, middle, value, comp);</span><br><span class="line">      advance(first, len);</span><br><span class="line">      right = upper_bound(++middle, first, value, comp);</span><br><span class="line">      <span class="keyword">return</span> pair&lt;ForwardIterator, ForwardIterator&gt;(left, right);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pair&lt;ForwardIterator, ForwardIterator&gt;(first, first);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>, <span class="title">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Compare</span>, <span class="title">class</span> <span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">pair</span>&lt;RandomAccessIterator, RandomAccessIterator&gt;</span></span><br><span class="line"><span class="class">__<span class="title">equal_range</span>(<span class="title">RandomAccessIterator</span> <span class="title">first</span>, <span class="title">RandomAccessIterator</span> <span class="title">last</span>,</span></span><br><span class="line"><span class="class">              <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">value</span>, <span class="title">Compare</span> <span class="title">comp</span>, <span class="title">Distance</span>*,</span></span><br><span class="line"><span class="class">              <span class="title">random_access_iterator_tag</span>) &#123;</span></span><br><span class="line">  Distance len = last - first;</span><br><span class="line">  Distance half;</span><br><span class="line">  RandomAccessIterator middle, left, right;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    half = len &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    middle = first + half;</span><br><span class="line">    <span class="keyword">if</span> (comp(*middle, value)) &#123;</span><br><span class="line">      first = middle + <span class="number">1</span>;</span><br><span class="line">      len = len - half - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (comp(value, *middle))</span><br><span class="line">      len = half;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      left = lower_bound(first, middle, value, comp);</span><br><span class="line">      right = upper_bound(++middle, first + len, value, comp);</span><br><span class="line">      <span class="keyword">return</span> pair&lt;RandomAccessIterator, RandomAccessIterator&gt;(left,</span><br><span class="line">                                                              right);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pair&lt;RandomAccessIterator, RandomAccessIterator&gt;(first, first);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>, <span class="title">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">pair</span>&lt;ForwardIterator, ForwardIterator&gt;</span></span><br><span class="line"><span class="class"><span class="title">equal_range</span>(<span class="title">ForwardIterator</span> <span class="title">first</span>, <span class="title">ForwardIterator</span> <span class="title">last</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">value</span>,</span></span><br><span class="line"><span class="class">            <span class="title">Compare</span> <span class="title">comp</span>) &#123;</span></span><br><span class="line">  <span class="keyword">return</span> __equal_range(first, last, value, comp, distance_type(first),</span><br><span class="line">                       iterator_category(first));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="inplace-merge"><a href="#inplace-merge" class="headerlink" title="inplace_merge"></a>inplace_merge</h3><p>应用于有序区间，把两个连接在一起且各自有序的序列合并成一个序列，仍保持有序。稳定操作，保持相对次序不变，如果有相同元素，第一个序列的排在前面。内部实现时根据有无缓冲不同处理。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">BidirectionalIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">inplace_merge</span>(<span class="title">BidirectionalIterator</span> <span class="title">first</span>,</span></span><br><span class="line"><span class="class">                          <span class="title">BidirectionalIterator</span> <span class="title">middle</span>,</span></span><br><span class="line"><span class="class">                          <span class="title">BidirectionalIterator</span> <span class="title">last</span>) &#123;</span></span><br><span class="line">  <span class="keyword">if</span> (first == middle || middle == last) <span class="keyword">return</span>;</span><br><span class="line">  __inplace_merge_aux(first, middle, last, value_type(first),</span><br><span class="line">                      distance_type(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">BidirectionalIterator</span>, <span class="title">class</span> <span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">inplace_merge</span>(<span class="title">BidirectionalIterator</span> <span class="title">first</span>,</span></span><br><span class="line"><span class="class">                          <span class="title">BidirectionalIterator</span> <span class="title">middle</span>,</span></span><br><span class="line"><span class="class">                          <span class="title">BidirectionalIterator</span> <span class="title">last</span>, <span class="title">Compare</span> <span class="title">comp</span>) &#123;</span></span><br><span class="line">  <span class="keyword">if</span> (first == middle || middle == last) <span class="keyword">return</span>;</span><br><span class="line">  __inplace_merge_aux(first, middle, last, value_type(first),</span><br><span class="line">                      distance_type(first), comp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">BidirectionalIterator</span>, <span class="title">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> __<span class="title">inplace_merge_aux</span>(<span class="title">BidirectionalIterator</span> <span class="title">first</span>,</span></span><br><span class="line"><span class="class">                                <span class="title">BidirectionalIterator</span> <span class="title">middle</span>,</span></span><br><span class="line"><span class="class">                                <span class="title">BidirectionalIterator</span> <span class="title">last</span>, <span class="title">T</span>*, <span class="title">Distance</span>*) &#123;</span></span><br><span class="line">  Distance len1 = <span class="number">0</span>;</span><br><span class="line">  distance(first, middle, len1);</span><br><span class="line">  Distance len2 = <span class="number">0</span>;</span><br><span class="line">  distance(middle, last, len2);</span><br><span class="line"></span><br><span class="line">  temporary_buffer&lt;BidirectionalIterator, T&gt; buf(first, last);</span><br><span class="line">  <span class="keyword">if</span> (buf.begin() == <span class="number">0</span>)</span><br><span class="line">    __merge_without_buffer(first, middle, last, len1, len2);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    __merge_adaptive(first, middle, last, len1, len2,</span><br><span class="line">                     buf.begin(), Distance(buf.size()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">BidirectionalIterator</span>, <span class="title">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Distance</span>, <span class="title">class</span> <span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> __<span class="title">inplace_merge_aux</span>(<span class="title">BidirectionalIterator</span> <span class="title">first</span>,</span></span><br><span class="line"><span class="class">                                <span class="title">BidirectionalIterator</span> <span class="title">middle</span>,</span></span><br><span class="line"><span class="class">                                <span class="title">BidirectionalIterator</span> <span class="title">last</span>, <span class="title">T</span>*, <span class="title">Distance</span>*,</span></span><br><span class="line"><span class="class">                                <span class="title">Compare</span> <span class="title">comp</span>) &#123;</span></span><br><span class="line">  Distance len1 = <span class="number">0</span>;</span><br><span class="line">  distance(first, middle, len1);</span><br><span class="line">  Distance len2 = <span class="number">0</span>;</span><br><span class="line">  distance(middle, last, len2);</span><br><span class="line"></span><br><span class="line">  temporary_buffer&lt;BidirectionalIterator, T&gt; buf(first, last);</span><br><span class="line">  <span class="keyword">if</span> (buf.begin() == <span class="number">0</span>)</span><br><span class="line">    __merge_without_buffer(first, middle, last, len1, len2, comp);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    __merge_adaptive(first, middle, last, len1, len2,</span><br><span class="line">                     buf.begin(), Distance(buf.size()),</span><br><span class="line">                     comp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果有缓冲区的话效率会好很多：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">BidirectionalIterator</span>, <span class="title">class</span> <span class="title">Distance</span>, <span class="title">class</span> <span class="title">Pointer</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">merge_adaptive</span>(<span class="title">BidirectionalIterator</span> <span class="title">first</span>,</span></span><br><span class="line"><span class="class">                      <span class="title">BidirectionalIterator</span> <span class="title">middle</span>,</span></span><br><span class="line"><span class="class">                      <span class="title">BidirectionalIterator</span> <span class="title">last</span>, <span class="title">Distance</span> <span class="title">len1</span>, <span class="title">Distance</span> <span class="title">len2</span>,</span></span><br><span class="line"><span class="class">                      <span class="title">Pointer</span> <span class="title">buffer</span>, <span class="title">Distance</span> <span class="title">buffer_size</span>) &#123;</span></span><br><span class="line">  <span class="keyword">if</span> (len1 &lt;= len2 &amp;&amp; len1 &lt;= buffer_size) &#123;</span><br><span class="line">    Pointer end_buffer = copy(first, middle, buffer);</span><br><span class="line">    merge(buffer, end_buffer, middle, last, first);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (len2 &lt;= buffer_size) &#123;</span><br><span class="line">    Pointer end_buffer = copy(middle, last, buffer);</span><br><span class="line">    __merge_backward(first, middle, buffer, end_buffer, last);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    BidirectionalIterator first_cut = first;</span><br><span class="line">    BidirectionalIterator second_cut = middle;</span><br><span class="line">    Distance len11 = <span class="number">0</span>;</span><br><span class="line">    Distance len22 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (len1 &gt; len2) &#123;</span><br><span class="line">      len11 = len1 / <span class="number">2</span>;</span><br><span class="line">      advance(first_cut, len11);</span><br><span class="line">      second_cut = lower_bound(middle, last, *first_cut);</span><br><span class="line">      distance(middle, second_cut, len22);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      len22 = len2 / <span class="number">2</span>;</span><br><span class="line">      advance(second_cut, len22);</span><br><span class="line">      first_cut = upper_bound(first, middle, *second_cut);</span><br><span class="line">      distance(first, first_cut, len11);</span><br><span class="line">    &#125;</span><br><span class="line">    BidirectionalIterator new_middle =</span><br><span class="line">      __rotate_adaptive(first_cut, middle, second_cut, len1 - len11,</span><br><span class="line">                        len22, buffer, buffer_size);</span><br><span class="line">    __merge_adaptive(first, first_cut, new_middle, len11, len22, buffer,</span><br><span class="line">                     buffer_size);</span><br><span class="line">    __merge_adaptive(new_middle, second_cut, last, len1 - len11,</span><br><span class="line">                     len2 - len22, buffer, buffer_size);</span><br><span class="line">  &#125;                  </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">BidirectionalIterator</span>, <span class="title">class</span> <span class="title">Distance</span>, <span class="title">class</span> <span class="title">Pointer</span>,</span></span><br><span class="line"><span class="class">          <span class="title">class</span> <span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">merge_adaptive</span>(<span class="title">BidirectionalIterator</span> <span class="title">first</span>,</span></span><br><span class="line"><span class="class">                      <span class="title">BidirectionalIterator</span> <span class="title">middle</span>,</span></span><br><span class="line"><span class="class">                      <span class="title">BidirectionalIterator</span> <span class="title">last</span>, <span class="title">Distance</span> <span class="title">len1</span>, <span class="title">Distance</span> <span class="title">len2</span>,</span></span><br><span class="line"><span class="class">                      <span class="title">Pointer</span> <span class="title">buffer</span>, <span class="title">Distance</span> <span class="title">buffer_size</span>, <span class="title">Compare</span> <span class="title">comp</span>) &#123;</span></span><br><span class="line">  <span class="keyword">if</span> (len1 &lt;= len2 &amp;&amp; len1 &lt;= buffer_size) &#123;</span><br><span class="line">    Pointer end_buffer = copy(first, middle, buffer);</span><br><span class="line">    merge(buffer, end_buffer, middle, last, first, comp);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (len2 &lt;= buffer_size) &#123;</span><br><span class="line">    Pointer end_buffer = copy(middle, last, buffer);</span><br><span class="line">    __merge_backward(first, middle, buffer, end_buffer, last, comp);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    BidirectionalIterator first_cut = first;</span><br><span class="line">    BidirectionalIterator second_cut = middle;</span><br><span class="line">    Distance len11 = <span class="number">0</span>;</span><br><span class="line">    Distance len22 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (len1 &gt; len2) &#123;</span><br><span class="line">      len11 = len1 / <span class="number">2</span>;</span><br><span class="line">      advance(first_cut, len11);</span><br><span class="line">      second_cut = lower_bound(middle, last, *first_cut, comp);</span><br><span class="line">      distance(middle, second_cut, len22);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      len22 = len2 / <span class="number">2</span>;</span><br><span class="line">      advance(second_cut, len22);</span><br><span class="line">      first_cut = upper_bound(first, middle, *second_cut, comp);</span><br><span class="line">      distance(first, first_cut, len11);</span><br><span class="line">    &#125; </span><br><span class="line">    BidirectionalIterator new_middle =</span><br><span class="line">      __rotate_adaptive(first_cut, middle, second_cut, len1 - len11,</span><br><span class="line">                        len22, buffer, buffer_size);</span><br><span class="line">    __merge_adaptive(first, first_cut, new_middle, len11, len22, buffer,</span><br><span class="line">                     buffer_size, comp);</span><br><span class="line">    __merge_adaptive(new_middle, second_cut, last, len1 - len11,</span><br><span class="line">                     len2 - len22, buffer, buffer_size, comp);</span><br><span class="line">  &#125;                  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/1610695460.jpg" alt><br><img src="/img/1610695483.jpg" alt></p>
<p>缓冲区不足以容纳一个序列时，以递归分割的方式，让处理长度减半，看能否容纳于缓冲区中。<br><img src="/img/1610695566.jpg" alt></p>
<p>然后执行旋转操作：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">BidirectionalIterator1</span>, <span class="title">class</span> <span class="title">BidirectionalIterator2</span>,</span></span><br><span class="line"><span class="class">          <span class="title">class</span> <span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">BidirectionalIterator1</span> __<span class="title">rotate_adaptive</span>(<span class="title">BidirectionalIterator1</span> <span class="title">first</span>,</span></span><br><span class="line"><span class="class">                                         <span class="title">BidirectionalIterator1</span> <span class="title">middle</span>,</span></span><br><span class="line"><span class="class">                                         <span class="title">BidirectionalIterator1</span> <span class="title">last</span>,</span></span><br><span class="line"><span class="class">                                         <span class="title">Distance</span> <span class="title">len1</span>, <span class="title">Distance</span> <span class="title">len2</span>,</span></span><br><span class="line"><span class="class">                                         <span class="title">BidirectionalIterator2</span> <span class="title">buffer</span>,</span></span><br><span class="line"><span class="class">                                         <span class="title">Distance</span> <span class="title">buffer_size</span>) &#123;</span></span><br><span class="line">  BidirectionalIterator2 buffer_end;</span><br><span class="line">  <span class="keyword">if</span> (len1 &gt; len2 &amp;&amp; len2 &lt;= buffer_size) &#123;</span><br><span class="line">    buffer_end = copy(middle, last, buffer);</span><br><span class="line">    copy_backward(first, middle, last);</span><br><span class="line">    <span class="keyword">return</span> copy(buffer, buffer_end, first);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len1 &lt;= buffer_size) &#123;</span><br><span class="line">    buffer_end = copy(first, middle, buffer);</span><br><span class="line">    copy(middle, last, first);</span><br><span class="line">    <span class="keyword">return</span> copy_backward(buffer, buffer_end, last);</span><br><span class="line">  &#125; <span class="keyword">else</span>  &#123;</span><br><span class="line">    rotate(first, middle, last);</span><br><span class="line">    advance(first, len2);</span><br><span class="line">    <span class="keyword">return</span> first;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="nth-element"><a href="#nth-element" class="headerlink" title="nth_element"></a>nth_element</h3><p>重新排列区间，使迭代器nth 所指向的元素与整个区间内排序后，同一位置的元素同值。保证nth-last 中没有任何一个元素不大于 first-nth 中的元素</p>
<p>不断用首尾中央三点中值为枢纽之分割法，将序列分割成更小的子序列，如果nth 落入左子序列， 就继续分割左子序列，如果落在右子序列就分割右子序列，最后对小于3的序列进行排序<br><img src="/img/1610696018.jpg" alt></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">nth_element</span>(<span class="title">RandomAccessIterator</span> <span class="title">first</span>, <span class="title">RandomAccessIterator</span> <span class="title">nth</span>,</span></span><br><span class="line"><span class="class">                   <span class="title">RandomAccessIterator</span> <span class="title">last</span>, <span class="title">T</span>*) &#123;</span></span><br><span class="line">  <span class="keyword">while</span> (last - first &gt; <span class="number">3</span>) &#123;</span><br><span class="line">    RandomAccessIterator cut = __unguarded_partition</span><br><span class="line">      (first, last, T(__median(*first, *(first + (last - first)/<span class="number">2</span>),</span><br><span class="line">                               *(last - <span class="number">1</span>))));</span><br><span class="line">    <span class="keyword">if</span> (cut &lt;= nth)</span><br><span class="line">      first = cut;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      last = cut;</span><br><span class="line">  &#125;</span><br><span class="line">  __insertion_sort(first, last);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">nth_element</span>(<span class="title">RandomAccessIterator</span> <span class="title">first</span>, <span class="title">RandomAccessIterator</span> <span class="title">nth</span>,</span></span><br><span class="line"><span class="class">                        <span class="title">RandomAccessIterator</span> <span class="title">last</span>) &#123;</span></span><br><span class="line">  __nth_element(first, nth, last, value_type(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>, <span class="title">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">nth_element</span>(<span class="title">RandomAccessIterator</span> <span class="title">first</span>, <span class="title">RandomAccessIterator</span> <span class="title">nth</span>,</span></span><br><span class="line"><span class="class">                   <span class="title">RandomAccessIterator</span> <span class="title">last</span>, <span class="title">T</span>*, <span class="title">Compare</span> <span class="title">comp</span>) &#123;</span></span><br><span class="line">  <span class="keyword">while</span> (last - first &gt; <span class="number">3</span>) &#123;</span><br><span class="line">    RandomAccessIterator cut = __unguarded_partition</span><br><span class="line">      (first, last, T(__median(*first, *(first + (last - first)/<span class="number">2</span>),</span><br><span class="line">                               *(last - <span class="number">1</span>), comp)), comp);</span><br><span class="line">    <span class="keyword">if</span> (cut &lt;= nth)</span><br><span class="line">      first = cut;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      last = cut;</span><br><span class="line">  &#125;</span><br><span class="line">  __insertion_sort(first, last, comp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>, <span class="title">class</span> <span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">nth_element</span>(<span class="title">RandomAccessIterator</span> <span class="title">first</span>, <span class="title">RandomAccessIterator</span> <span class="title">nth</span>,</span></span><br><span class="line"><span class="class">                 <span class="title">RandomAccessIterator</span> <span class="title">last</span>, <span class="title">Compare</span> <span class="title">comp</span>) &#123;</span></span><br><span class="line">  __nth_element(first, nth, last, value_type(first), comp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="merge-sort"><a href="#merge-sort" class="headerlink" title="merge_sort"></a>merge_sort</h3><p>归并排序，需要额外的内存，内存之间的拷贝需要时间，但是实现简单。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator1</span>, <span class="title">class</span> <span class="title">RandomAccessIterator2</span>,</span></span><br><span class="line"><span class="class">          <span class="title">class</span> <span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">merge_sort_loop</span>(<span class="title">RandomAccessIterator1</span> <span class="title">first</span>,</span></span><br><span class="line"><span class="class">                       <span class="title">RandomAccessIterator1</span> <span class="title">last</span>,</span></span><br><span class="line"><span class="class">                       <span class="title">RandomAccessIterator2</span> <span class="title">result</span>, <span class="title">Distance</span> <span class="title">step_size</span>) &#123;</span></span><br><span class="line">  Distance two_step = <span class="number">2</span> * step_size;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (last - first &gt;= two_step) &#123;</span><br><span class="line">    result = merge(first, first + step_size,</span><br><span class="line">                   first + step_size, first + two_step, result);</span><br><span class="line">    first += two_step;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  step_size = min(Distance(last - first), step_size);</span><br><span class="line">  merge(first, first + step_size, first + step_size, last, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator1</span>, <span class="title">class</span> <span class="title">RandomAccessIterator2</span>,</span></span><br><span class="line"><span class="class">          <span class="title">class</span> <span class="title">Distance</span>, <span class="title">class</span> <span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">merge_sort_loop</span>(<span class="title">RandomAccessIterator1</span> <span class="title">first</span>,</span></span><br><span class="line"><span class="class">                       <span class="title">RandomAccessIterator1</span> <span class="title">last</span>,</span></span><br><span class="line"><span class="class">                       <span class="title">RandomAccessIterator2</span> <span class="title">result</span>, <span class="title">Distance</span> <span class="title">step_size</span>,</span></span><br><span class="line"><span class="class">                       <span class="title">Compare</span> <span class="title">comp</span>) &#123;</span></span><br><span class="line">  Distance two_step = <span class="number">2</span> * step_size;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (last - first &gt;= two_step) &#123;</span><br><span class="line">    result = merge(first, first + step_size,</span><br><span class="line">                   first + step_size, first + two_step, result, comp);</span><br><span class="line">    first += two_step;</span><br><span class="line">  &#125;</span><br><span class="line">  step_size = min(Distance(last - first), step_size);</span><br><span class="line"></span><br><span class="line">  merge(first, first + step_size, first + step_size, last, result, comp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/C/" rel="tag"># C++</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/01/06/STL源码剖析 笔记3/" rel="next" title="STL 源码剖析 笔记3">
                <i class="fa fa-chevron-left"></i> STL 源码剖析 笔记3
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/01/15/STL源码剖析 笔记5/" rel="prev" title="STL 源码剖析 笔记5">
                STL 源码剖析 笔记5 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/header.jpg" alt="Hao Yu">
            
              <p class="site-author-name" itemprop="name">Hao Yu</p>
              <p class="site-description motion-element" itemprop="description">Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author</p>
          </div>
          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">353</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>
        	<audio controls="controls" loop="loop" preload="auto" src="/resource/xiaomeihao.mp3">
	        </audio>
	

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yuhao0102" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:yuh18@mails.tsinghua.edu.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#算法"><span class="nav-number">1.</span> <span class="nav-text">算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#算法概观"><span class="nav-number">1.1.</span> <span class="nav-text">算法概观</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#STL算法总览"><span class="nav-number">1.1.1.</span> <span class="nav-text">STL算法总览</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#算法的泛化过程"><span class="nav-number">1.1.2.</span> <span class="nav-text">算法的泛化过程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数值算法"><span class="nav-number">1.2.</span> <span class="nav-text">数值算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#accumlate"><span class="nav-number">1.2.1.</span> <span class="nav-text">accumlate</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#adjacent-differencee"><span class="nav-number">1.2.2.</span> <span class="nav-text">adjacent_differencee</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#partial-sum"><span class="nav-number">1.2.3.</span> <span class="nav-text">partial_sum</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#power"><span class="nav-number">1.2.4.</span> <span class="nav-text">power</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#inner-product"><span class="nav-number">1.2.5.</span> <span class="nav-text">inner_product</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#iota"><span class="nav-number">1.2.6.</span> <span class="nav-text">iota</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基本算法"><span class="nav-number">1.3.</span> <span class="nav-text">基本算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#max"><span class="nav-number">1.3.1.</span> <span class="nav-text">max</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#min"><span class="nav-number">1.3.2.</span> <span class="nav-text">min</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mismatch"><span class="nav-number">1.3.3.</span> <span class="nav-text">mismatch</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#swap"><span class="nav-number">1.3.4.</span> <span class="nav-text">swap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#copy"><span class="nav-number">1.3.5.</span> <span class="nav-text">copy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#copy-backward"><span class="nav-number">1.3.6.</span> <span class="nav-text">copy_backward</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#set相关算法"><span class="nav-number">1.4.</span> <span class="nav-text">set相关算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#set-union"><span class="nav-number">1.4.1.</span> <span class="nav-text">set_union</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#set-intersection"><span class="nav-number">1.4.2.</span> <span class="nav-text">set_intersection</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#set-difference"><span class="nav-number">1.4.3.</span> <span class="nav-text">set_difference</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#set-symmetric-difference"><span class="nav-number">1.4.4.</span> <span class="nav-text">set_symmetric_difference</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#应用实例："><span class="nav-number">1.4.5.</span> <span class="nav-text">应用实例：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#其他算法"><span class="nav-number">1.5.</span> <span class="nav-text">其他算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#单纯的数据处理"><span class="nav-number">1.5.1.</span> <span class="nav-text">单纯的数据处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#adjacent-find"><span class="nav-number">1.5.2.</span> <span class="nav-text">adjacent_find</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#count"><span class="nav-number">1.5.3.</span> <span class="nav-text">count</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#count-if"><span class="nav-number">1.5.4.</span> <span class="nav-text">count_if</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#find"><span class="nav-number">1.5.5.</span> <span class="nav-text">find</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#find-if"><span class="nav-number">1.5.6.</span> <span class="nav-text">find_if</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#find-end"><span class="nav-number">1.5.7.</span> <span class="nav-text">find_end</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#find-first-of"><span class="nav-number">1.5.8.</span> <span class="nav-text">find_first of</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#for-each"><span class="nav-number">1.5.9.</span> <span class="nav-text">for_each</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#generate"><span class="nav-number">1.5.10.</span> <span class="nav-text">generate</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#generate-n"><span class="nav-number">1.5.11.</span> <span class="nav-text">generate_n</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#includes"><span class="nav-number">1.5.12.</span> <span class="nav-text">includes</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#max-element"><span class="nav-number">1.5.13.</span> <span class="nav-text">max_element</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#merge"><span class="nav-number">1.5.14.</span> <span class="nav-text">merge</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#min-element"><span class="nav-number">1.5.15.</span> <span class="nav-text">min_element</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#partition"><span class="nav-number">1.5.16.</span> <span class="nav-text">partition</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#remove"><span class="nav-number">1.5.17.</span> <span class="nav-text">remove</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#remove-copy"><span class="nav-number">1.5.18.</span> <span class="nav-text">remove_copy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#remove-if"><span class="nav-number">1.5.19.</span> <span class="nav-text">remove_if</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#remove-copy-if"><span class="nav-number">1.5.20.</span> <span class="nav-text">remove_copy_if</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#replace"><span class="nav-number">1.5.21.</span> <span class="nav-text">replace</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#replace-copy"><span class="nav-number">1.5.22.</span> <span class="nav-text">replace_copy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#replace-if"><span class="nav-number">1.5.23.</span> <span class="nav-text">replace_if</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#replace-copy-if"><span class="nav-number">1.5.24.</span> <span class="nav-text">replace_copy_if</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#reverse"><span class="nav-number">1.5.25.</span> <span class="nav-text">reverse</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#reverse-copy"><span class="nav-number">1.5.26.</span> <span class="nav-text">reverse_copy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#rotate"><span class="nav-number">1.5.27.</span> <span class="nav-text">rotate</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#rotate-copy"><span class="nav-number">1.5.28.</span> <span class="nav-text">rotate_copy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#search"><span class="nav-number">1.5.29.</span> <span class="nav-text">search</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#search-n"><span class="nav-number">1.5.30.</span> <span class="nav-text">search_n</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#swap-range"><span class="nav-number">1.5.31.</span> <span class="nav-text">swap_range</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#transform"><span class="nav-number">1.5.32.</span> <span class="nav-text">transform</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#unique"><span class="nav-number">1.5.33.</span> <span class="nav-text">unique</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#unique-copy"><span class="nav-number">1.5.34.</span> <span class="nav-text">unique_copy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lower-bound"><span class="nav-number">1.5.35.</span> <span class="nav-text">lower_bound</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#upper-bound"><span class="nav-number">1.5.36.</span> <span class="nav-text">upper_bound</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#binary-search"><span class="nav-number">1.5.37.</span> <span class="nav-text">binary_search</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#next-permutation-prev-permutation"><span class="nav-number">1.5.38.</span> <span class="nav-text">next_permutation/prev_permutation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#random-shuffle"><span class="nav-number">1.5.39.</span> <span class="nav-text">random_shuffle</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#partial-sort-partial-sort-copy"><span class="nav-number">1.5.40.</span> <span class="nav-text">partial_sort/partial_sort_copy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sort"><span class="nav-number">1.5.41.</span> <span class="nav-text">sort</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#InsertionSort"><span class="nav-number">1.5.41.1.</span> <span class="nav-text">InsertionSort</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Quick-Sort"><span class="nav-number">1.5.42.</span> <span class="nav-text">Quick Sort</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#equal-range"><span class="nav-number">1.5.43.</span> <span class="nav-text">equal_range</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#inplace-merge"><span class="nav-number">1.5.44.</span> <span class="nav-text">inplace_merge</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#nth-element"><span class="nav-number">1.5.45.</span> <span class="nav-text">nth_element</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#merge-sort"><span class="nav-number">1.5.46.</span> <span class="nav-text">merge_sort</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>
  <div id="DvelopmentTarget">     
  </div>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart" aria-hidden="false"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>

  
</div>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_uv"> 
  本站访客数<span id="busuanzi_value_site_uv"></span>人次
</span>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  


  

  


  <script type="text/javascript" src="/js/src/love.js"></script>

</body>
</html>
