<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zn-ch">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-center-simple.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="C++,">










<meta name="description" content="关联式容器根据“数据在容器中的排列”特性，容器可概分为序列式（sequence）和关联式（associative）两种。标准的STL关联式容器分为set（集合〕和map（映射表）两大类：以及这两大类的衍生体multi-set（多键集合）和multimap（多键映射表）。这些容器的底层机制均以RB-tree（红黑树）完成。RB-tree也是一个独立容器，但并不开放给外界使用。 RB-tree概述首先">
<meta name="keywords" content="C++">
<meta property="og:type" content="article">
<meta property="og:title" content="STL 源码剖析 笔记3">
<meta property="og:url" content="http://yoursite.com/2021/01/06/STL源码剖析 笔记3/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="关联式容器根据“数据在容器中的排列”特性，容器可概分为序列式（sequence）和关联式（associative）两种。标准的STL关联式容器分为set（集合〕和map（映射表）两大类：以及这两大类的衍生体multi-set（多键集合）和multimap（多键映射表）。这些容器的底层机制均以RB-tree（红黑树）完成。RB-tree也是一个独立容器，但并不开放给外界使用。 RB-tree概述首先">
<meta property="og:locale" content="zn-ch">
<meta property="og:image" content="http://yoursite.com/img/1609849157.jpg">
<meta property="og:image" content="http://yoursite.com/img/1609849605.jpg">
<meta property="og:image" content="http://yoursite.com/img/1609927285.jpg">
<meta property="og:image" content="http://yoursite.com/img/1609934235.png">
<meta property="og:image" content="http://yoursite.com/img/1610004677.jpg">
<meta property="og:image" content="http://yoursite.com/img/1610346576.jpg">
<meta property="og:updated_time" content="2021-01-15T07:39:56.156Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="STL 源码剖析 笔记3">
<meta name="twitter:description" content="关联式容器根据“数据在容器中的排列”特性，容器可概分为序列式（sequence）和关联式（associative）两种。标准的STL关联式容器分为set（集合〕和map（映射表）两大类：以及这两大类的衍生体multi-set（多键集合）和multimap（多键映射表）。这些容器的底层机制均以RB-tree（红黑树）完成。RB-tree也是一个独立容器，但并不开放给外界使用。 RB-tree概述首先">
<meta name="twitter:image" content="http://yoursite.com/img/1609849157.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2021/01/06/STL源码剖析 笔记3/">





  <title>STL 源码剖析 笔记3 | Hao Yu's blog</title>
  








 
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zn-ch">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hao Yu's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">The program monkey was eaten by the siege lion.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/resume.pdf" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-mybetterhalf">
          <a href="/mybetterhalf/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>
            
            mybetterhalf
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/06/STL源码剖析 笔记3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">STL 源码剖析 笔记3</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-01-06T09:13:00+08:00">
                2021-01-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="关联式容器"><a href="#关联式容器" class="headerlink" title="关联式容器"></a>关联式容器</h1><p>根据“数据在容器中的排列”特性，容器可概分为序列式（sequence）和关联式（associative）两种。标准的STL关联式容器分为set（集合〕和map（映射表）两大类：以及这两大类的衍生体multi-set（多键集合）和multimap（多键映射表）。这些容器的底层机制均以RB-tree（红黑树）完成。RB-tree也是一个独立容器，但并不开放给外界使用。</p>
<h2 id="RB-tree概述"><a href="#RB-tree概述" class="headerlink" title="RB-tree概述"></a>RB-tree概述</h2><p>首先介绍一下基本概念，二叉树：任何节点最多只有两个子节点，这两个子节点分别称为左子节点和右子节点。二叉搜索树：任何节点的键值一定大于其左子树中的每一个节点的键值，小于其右子树中的每一个节点的键值。所谓的RB-tree不仅是二叉搜索树，而且必须满足以下规则：</p>
<ul>
<li>每个节点不是红色就是黑色。</li>
<li>根节点为黑色。</li>
<li>如果节点为红色，其子节点必须为黑色。</li>
<li>任意一个节点到到NULL（树尾端）的任何路径，所含之黑色节点数必须相同。</li>
</ul>
<p>根据规则4，新增节点必须为红色；根据规则3，新增节点之父节点必须为黑色。当新增节点根据二叉搜索树的规则到达其插入点时，却未能符合上述条件时，就必须调整颜色并旋转树形，如下图：<br><img src="/img/1609849157.jpg" alt></p>
<p>插入节点，会导致不满足RB-tree的规则条件，经历左旋和右旋等操作，使得重新满足规则。</p>
<h3 id="RB-tree节点设计"><a href="#RB-tree节点设计" class="headerlink" title="RB-tree节点设计"></a>RB-tree节点设计</h3><p>RB-tree的节点和迭代器都是双层结构，RB-tree迭代器的前进和后退操作，都是调用基础迭代器的increment和decrement实现的。RB-tree的极值通过minimum和maximum可以方便地查找到，<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">bool</span> __rb_tree_color_type;</span><br><span class="line"><span class="keyword">const</span> __rb_tree_color_type __rb_tree_red = <span class="literal">false</span>;     <span class="comment">// 红色为0</span></span><br><span class="line"><span class="keyword">const</span> __rb_tree_color_type __rb_tree_black = <span class="literal">true</span>; <span class="comment">// 黑色为1</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">rb_tree_node_base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> __rb_tree_color_type color_type;</span><br><span class="line">  <span class="keyword">typedef</span> __rb_tree_node_base* base_ptr;</span><br><span class="line"> </span><br><span class="line">  color_type color;     <span class="comment">// 节点颜色，红色或黑色</span></span><br><span class="line">  base_ptr parent;      <span class="comment">// 该指针指向其父节点</span></span><br><span class="line">  base_ptr left;        <span class="comment">// 指向左节点</span></span><br><span class="line">  base_ptr right;       <span class="comment">// 指向右节点</span></span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">static</span> base_ptr <span class="title">minimum</span><span class="params">(base_ptr x)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">	 <span class="keyword">while</span> (x-&gt;left != <span class="number">0</span>) x = x-&gt;left; <span class="comment">//一直向左走，找到最小值</span></span><br><span class="line">	 <span class="keyword">return</span> x;                            </span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">static</span> base_ptr <span class="title">maximum</span><span class="params">(base_ptr x)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (x-&gt;right != <span class="number">0</span>) x = x-&gt;right; <span class="comment">//一直向右走，找到最大值</span></span><br><span class="line">    <span class="keyword">return</span> x;                           </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Value</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> __<span class="title">rb_tree_node</span> :</span> <span class="keyword">public</span> __rb_tree_node_base</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">typedef</span> __rb_tree_node&lt;Value&gt;* link_type;</span><br><span class="line">  Value value_field;   <span class="comment">//节点值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="RB-tree的迭代器"><a href="#RB-tree的迭代器" class="headerlink" title="RB-tree的迭代器"></a>RB-tree的迭代器</h3><p>为了更大的弹性，RB-tree迭代器实现为两层，下图即为双层节点结构和双层迭代器结构之间的关系，<code>__rb_tree_node</code>继承自<code>__rb_tree_node_base</code>，<code>__rb_tree_iterator</code>继承自<code>__rb_tree_base_iterator</code>。<br><img src="/img/1609849605.jpg" alt></p>
<p>RB-tree迭代器属于双向迭代器，但不具备随机定位能力，其提领操作和成员访问操作与list十分近似，较为特殊的是其前进和后退操作：注意，RB-tree迭代器的前进操作<code>operator()++</code>调用了基层迭代器的<code>increment()</code>，RB-tree迭代器的后退操作<code>operator--()</code>则调用了基层迭代器的<code>decrement()</code>。前进或后退的举止行为完全依据二叉搜索树的节点排列法则，再加上实现上的某些特殊技巧。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基层迭代器</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">rb_tree_base_iterator</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> __rb_tree_node_base::base_ptr base_ptr;</span><br><span class="line">    <span class="keyword">typedef</span> bidirectional_iterator_tag iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type;</span><br><span class="line"></span><br><span class="line">	base_ptr node; <span class="comment">//与容器之间生成一个连结关系</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (node-&gt;right != <span class="number">0</span>) &#123;</span><br><span class="line">			node = node-&gt;right;</span><br><span class="line">			<span class="keyword">while</span>(node-&gt;left != <span class="number">0</span>)</span><br><span class="line">				node = node-&gt;left;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 如果有右子节点。状况（1），就向右走。然后一直往左子树走到底，即是解答 </span></span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 没有右子节点。状况（2），找出父节点。如果现行节点本身是个右子节点，就一直上溯，直到“不为右子节点”止 </span></span><br><span class="line">			base_ptr y = node-&gt;parent;</span><br><span class="line">			<span class="keyword">while</span>(node == y-&gt;right) &#123;</span><br><span class="line">				node = y;</span><br><span class="line">				y = y-&gt;parent;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (node-&gt;right != y)</span><br><span class="line">				node = y;</span><br><span class="line">			<span class="comment">// 若此时的右子节点不等于此时的父节点，状况（3）此时的父节点即为解答。否则此时的node为解答。状况（4）</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 以下其实可实现于operator--内，因为再无他处会调用此函数了</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">decrement</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (node-&gt;color == ＿rb_tree_red &amp;&amp; node-&gt;parent-&gt;parent == node)</span><br><span class="line">			node = node-&gt;right;</span><br><span class="line">		<span class="comment">// 如果是红节点、且父节点的父节点等于自己，状况（1）右子节点即为解答</span></span><br><span class="line">		<span class="comment">// 以上情况发生于node为header时（亦即node为end()时）</span></span><br><span class="line">		<span class="comment">// 注意，header之右子节点即mostright，指向整棵树的max节点</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (node-&gt;left != <span class="number">0</span>) &#123;</span><br><span class="line">			base_ptr y = node-&gt;left;</span><br><span class="line">			<span class="keyword">while</span>(y-&gt;right != <span class="number">0</span>)</span><br><span class="line">				y = y-&gt;right;</span><br><span class="line">			node = y;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 如果有左子节点。状况（2）令y指向左子节点。当y有右子节点时，一直往右子节点走到底，最后即为答案</span></span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			base_ptr y = node-&gt;parent;</span><br><span class="line">			<span class="keyword">while</span> (node == y-&gt;left) &#123;</span><br><span class="line">				node = y;</span><br><span class="line">				y = y-&gt;parent;</span><br><span class="line">			&#125;</span><br><span class="line">			node = y;</span><br><span class="line">		<span class="comment">// 既非根节点，亦无左子节点，状况（3）找出父节点。当现行节点身为左子节点，一直交替往上走，直到现行节点不为左子节点</span></span><br><span class="line">		<span class="comment">// 此时之父节点即为答案</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Value</span>, <span class="title">class</span> <span class="title">Ref</span>, <span class="title">class</span> <span class="title">Ptr</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">struct</span> __<span class="title">rb_tree_iterator</span> :</span> <span class="keyword">public</span> __rb_tree_base_iterator </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> Value value_type;</span><br><span class="line">	<span class="keyword">typedef</span> Ref reference;</span><br><span class="line">	<span class="keyword">typedef</span> Ptr pointer;</span><br><span class="line">	<span class="keyword">typedef</span> __rb_tree_iterator&lt;Value, Value&amp;, Value*&gt; iterator; </span><br><span class="line">	<span class="keyword">typedef</span> __rb_tree_iterator&lt;Value, <span class="keyword">const</span> value&amp;, <span class="keyword">const</span> value*&gt; const_iterator;</span><br><span class="line">	<span class="keyword">typedef</span> __rb_tree_iterator&lt;Value, Ref, Ptr&gt; self;</span><br><span class="line">	<span class="keyword">typedef</span> __rb_tree_node&lt;Value&gt;* link_type;</span><br><span class="line"></span><br><span class="line">	__rb_tree_iterator()&#123;&#125;</span><br><span class="line">	__rb_tree_iterator(link_type x) &#123; node = x; &#125;</span><br><span class="line">	__rb_tree_iterator (<span class="keyword">const</span> iterator&amp; it) &#123; node = it.node; &#125;</span><br><span class="line"></span><br><span class="line">	reference <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> link_type(node)-&gt;value_field; &#125;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">ifndef</span> __SGI_STL_NO_ARROW_OPERATOR</span></span><br><span class="line">		pointer <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*()); &#125;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/*_SGI_STL_NO_ARROW_OPERATOR*/</span> </span></span><br><span class="line">	</span><br><span class="line">	selt&amp; <span class="keyword">operator</span>++()&#123; increment(); <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">	self <span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123;</span><br><span class="line">		self tmp = *<span class="keyword">this</span>;</span><br><span class="line">		increment(); </span><br><span class="line">		<span class="keyword">return</span> tmp; </span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	self&amp; <span class="keyword">operator</span>--() &#123;decrement(); <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">	self <span class="keyword">operator</span>--(<span class="keyword">int</span>) &#123;</span><br><span class="line">		self tmp = *<span class="keyword">this</span>;</span><br><span class="line">		decrement();</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/1609927285.jpg" alt></p>
<h3 id="RB-tree数据结构"><a href="#RB-tree数据结构" class="headerlink" title="RB-tree数据结构"></a>RB-tree数据结构</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//stl_tree.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __SGI_STL_INTERNAL_TREE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __SGI_STL_INTERNAL_TREE_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Red-black tree（红黑树）class，用来当做SLT关联容器的底层机制（如set，multiset，map，</span></span><br><span class="line"><span class="comment">multimap）。里面所用的insertion和deletion方法以Cormen, Leiserson 和 Riveset所著的</span></span><br><span class="line"><span class="comment">《算法导论》一书为基础，但是有以下两点不同:</span></span><br><span class="line"><span class="comment">(1)header不仅指向root，也指向红黑树的最左节点，以便用常数时间实现begin()，并且也指向红黑树的最右边节点，以便</span></span><br><span class="line"><span class="comment">set相关泛型算法（如set_union等等）可以有线性时间实现。</span></span><br><span class="line"><span class="comment">(2)当一个即将被删除的节点有两个孩子节点时，它的successor（后继）node is relinked into its place, ranther than copied,</span></span><br><span class="line"><span class="comment">如此一来唯一失效的（invalidated）的迭代器就只是那些referring to the deleted node.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stl_algobase.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stl_alloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stl_construct.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stl_function.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="title">class</span> <span class="title">Value</span>, <span class="title">class</span> <span class="title">KeyOfValue</span>, <span class="title">class</span> <span class="title">Compare</span>,</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Alloc</span> = <span class="title">alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">rb_tree</span> &#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">void</span>* void_pointer;</span><br><span class="line">	<span class="keyword">typedef</span> __rb_tree_node_base* base_ptr;</span><br><span class="line">	<span class="keyword">typedef</span> __rb_tree_node&lt;Value&gt; rb_tree_node;</span><br><span class="line">	<span class="keyword">typedef</span> simple_alloc&lt;rb_tree_node, Alloc&gt; rb_tree_node_allocator;</span><br><span class="line">	<span class="keyword">typedef</span> __rb_tree_color_type color_type;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//这里没有定义iterator，在后面定义</span></span><br><span class="line">	<span class="keyword">typedef</span> Key key_type;</span><br><span class="line">	<span class="keyword">typedef</span> Value value_type;</span><br><span class="line">	<span class="keyword">typedef</span> value_type* pointer;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">const</span> value_type* const_pointer;</span><br><span class="line">	<span class="keyword">typedef</span> value_type&amp; reference;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">const</span> value_type&amp; const_reference;</span><br><span class="line">	<span class="keyword">typedef</span> rb_tree_node* link_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="function">link_type <span class="title">get_node</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> rb_tree_node_allocator::allocate(); &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">put_node</span><span class="params">(link_type p)</span> </span>&#123; rb_tree_node_allocator::deallocate(p); &#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function">link_type <span class="title">create_node</span><span class="params">(<span class="keyword">const</span> value_type&amp; x)</span> </span>&#123;</span><br><span class="line">		link_type tmp = get_node();			<span class="comment">// 配置空间</span></span><br><span class="line">		__STL_TRY&#123;</span><br><span class="line">			construct(&amp;tmp-&gt;value_field, x);	<span class="comment">// 构建内容</span></span><br><span class="line">		&#125;</span><br><span class="line">		__STL_UNWIND(put_node(tmp));</span><br><span class="line">		<span class="keyword">return</span> tmp;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function">link_type <span class="title">clone_node</span><span class="params">(link_type x)</span> </span>&#123;	<span class="comment">// 复制一个节点（值和颜色）</span></span><br><span class="line">		link_type tmp = create_node(x-&gt;value_field);</span><br><span class="line">		tmp-&gt;color = x-&gt;color;</span><br><span class="line">		tmp-&gt;left = <span class="number">0</span>;</span><br><span class="line">		tmp-&gt;right = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> tmp;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">destroy_node</span><span class="params">(link_type p)</span> </span>&#123;</span><br><span class="line">		destroy(&amp;p-&gt;value_field);		<span class="comment">// 析构内容</span></span><br><span class="line">		put_node(p);		                <span class="comment">// 释放内存</span></span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="comment">// RB-tree 只以三个资料表现</span></span><br><span class="line">	size_type node_count; <span class="comment">// 追踪记录树的大小（节点总数）</span></span><br><span class="line">	link_type header;     <span class="comment">//这个是实现上的一个技巧</span></span><br><span class="line">	Compare key_compare;	 <span class="comment">// 节点的键值比较判断准则。是个函数 function object。</span></span><br><span class="line"> </span><br><span class="line">	<span class="comment">//以下三个函数用来方便取得header的成员</span></span><br><span class="line">	<span class="function">link_type&amp; <span class="title">root</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> (link_type&amp;)header-&gt;parent; &#125;</span><br><span class="line">	<span class="function">link_type&amp; <span class="title">leftmost</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> (link_type&amp;)header-&gt;left; &#125;</span><br><span class="line">	<span class="function">link_type&amp; <span class="title">rightmost</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> (link_type&amp;)header-&gt;right; &#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//以下六个函数用来方便取得节点x的成员。x为函数参数</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> link_type&amp; <span class="title">left</span><span class="params">(link_type x)</span> </span>&#123; <span class="keyword">return</span> (link_type&amp;)(x-&gt;left); &#125;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> link_type&amp; <span class="title">right</span><span class="params">(link_type x)</span> </span>&#123; <span class="keyword">return</span> (link_type&amp;)(x-&gt;right); &#125;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> link_type&amp; <span class="title">parent</span><span class="params">(link_type x)</span> </span>&#123; <span class="keyword">return</span> (link_type&amp;)(x-&gt;parent); &#125;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> reference <span class="title">value</span><span class="params">(link_type x)</span> </span>&#123; <span class="keyword">return</span> x-&gt;value_field; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">const</span> Key&amp; <span class="title">key</span><span class="params">(link_type x)</span> </span>&#123; <span class="keyword">return</span> KeyOfValue()(value(x)); &#125;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> color_type&amp; <span class="title">color</span><span class="params">(link_type x)</span> </span>&#123; <span class="keyword">return</span> (color_type&amp;)(x-&gt;color); &#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//和上面六个作用相同，注意x参数类型不同。一个是基类指针，一个是派生类指针</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> link_type&amp; <span class="title">left</span><span class="params">(base_ptr x)</span> </span>&#123; <span class="keyword">return</span> (link_type&amp;)(x-&gt;left); &#125;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> link_type&amp; <span class="title">right</span><span class="params">(base_ptr x)</span> </span>&#123; <span class="keyword">return</span> (link_type&amp;)(x-&gt;right); &#125;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> link_type&amp; <span class="title">parent</span><span class="params">(base_ptr x)</span> </span>&#123; <span class="keyword">return</span> (link_type&amp;)(x-&gt;parent); &#125;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> reference <span class="title">value</span><span class="params">(base_ptr x)</span> </span>&#123; <span class="keyword">return</span> ((link_type)x)-&gt;value_field; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">const</span> Key&amp; <span class="title">key</span><span class="params">(base_ptr x)</span> </span>&#123; <span class="keyword">return</span> KeyOfValue()(value(link_type(x))); &#125;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> color_type&amp; <span class="title">color</span><span class="params">(base_ptr x)</span> </span>&#123; <span class="keyword">return</span> (color_type&amp;)(link_type(x)-&gt;color); &#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//找最大值和最小值。node class 有这个功能函数</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> link_type <span class="title">minimum</span><span class="params">(link_type x)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (link_type)__rb_tree_node_base::minimum(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> link_type <span class="title">maximum</span><span class="params">(link_type x)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (link_type)__rb_tree_node_base::maximum(x);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> __rb_tree_iterator&lt;value_type, reference, pointer&gt; iterator;</span><br><span class="line">	<span class="keyword">typedef</span> __rb_tree_iterator&lt;value_type, const_reference, const_pointer&gt;</span><br><span class="line">		const_iterator;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __STL_CLASS_PARTIAL_SPECIALIZATION</span></span><br><span class="line">	<span class="keyword">typedef</span> reverse_iterator&lt;const_iterator&gt; const_reverse_iterator;</span><br><span class="line">	<span class="keyword">typedef</span> reverse_iterator&lt;iterator&gt; reverse_iterator;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">/* __STL_CLASS_PARTIAL_SPECIALIZATION */</span></span></span><br><span class="line">	<span class="keyword">typedef</span> reverse_bidirectional_iterator&lt;iterator, value_type, reference,</span><br><span class="line">		difference_type&gt;</span><br><span class="line">		reverse_iterator;</span><br><span class="line">	<span class="keyword">typedef</span> reverse_bidirectional_iterator&lt;const_iterator, value_type,</span><br><span class="line">		const_reference, difference_type&gt;</span><br><span class="line">		const_reverse_iterator;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __STL_CLASS_PARTIAL_SPECIALIZATION */</span> </span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	iterator __insert(base_ptr x, base_ptr y, <span class="keyword">const</span> value_type&amp; v);</span><br><span class="line">	link_type __copy(link_type x, link_type p);</span><br><span class="line">	<span class="keyword">void</span> __erase(link_type x);</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		header = get_node();	<span class="comment">// 产生一个节点空间，令header指向它</span></span><br><span class="line">		color(header) = __rb_tree_red; <span class="comment">// 令 header 尾红色，用來区 header  </span></span><br><span class="line">		<span class="comment">// 和 root（在 iterator.operator++ 中）</span></span><br><span class="line">		root() = <span class="number">0</span>;</span><br><span class="line">		leftmost() = header;	<span class="comment">// 令 header 的左孩子为自己。</span></span><br><span class="line">		rightmost() = header;	<span class="comment">// 令 header 的右孩子为自己。</span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//默认构造函数                           // allocation/deallocation</span></span><br><span class="line">	rb_tree(<span class="keyword">const</span> Compare&amp; comp = Compare())</span><br><span class="line">		: node_count(<span class="number">0</span>), key_compare(comp) &#123;</span><br><span class="line">		init();</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// 以另一个 rb_tree  x 初始化</span></span><br><span class="line">	rb_tree(<span class="keyword">const</span> rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;&amp; x)</span><br><span class="line">		: node_count(<span class="number">0</span>), key_compare(x.key_compare)</span><br><span class="line">	&#123;</span><br><span class="line">		header = get_node();</span><br><span class="line">		color(header) = __rb_tree_red;</span><br><span class="line">		<span class="keyword">if</span> (x.root() == <span class="number">0</span>) &#123;	<span class="comment">//  如果 x 空树</span></span><br><span class="line">			root() = <span class="number">0</span>;</span><br><span class="line">			leftmost() = header;</span><br><span class="line">			rightmost() = header;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;	<span class="comment">//  x 不是空树</span></span><br><span class="line">			__STL_TRY&#123;</span><br><span class="line">			root() = __copy(x.root(), header);		<span class="comment">// 拷贝红黑树x </span></span><br><span class="line">		&#125;</span><br><span class="line">			__STL_UNWIND(put_node(header));</span><br><span class="line">			leftmost() = minimum(root());	<span class="comment">// 令 header 的左孩子为最小节点</span></span><br><span class="line">			rightmost() = maximum(root());	<span class="comment">// 令 header 的右孩子为最大节点</span></span><br><span class="line">		&#125;</span><br><span class="line">		node_count = x.node_count;</span><br><span class="line">	&#125;</span><br><span class="line">	~rb_tree() &#123;</span><br><span class="line">		clear();</span><br><span class="line">		put_node(header);</span><br><span class="line">	&#125;</span><br><span class="line">	rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;&amp;</span><br><span class="line">		<span class="keyword">operator</span>=(<span class="keyword">const</span> rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;&amp; x);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// accessors:</span></span><br><span class="line">	<span class="function">Compare <span class="title">key_comp</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> key_compare; &#125;</span><br><span class="line">	<span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> leftmost(); &#125;		<span class="comment">// RB 树的起始为最左（最小节点）</span></span><br><span class="line">	<span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> leftmost(); &#125;</span><br><span class="line">	<span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> header; &#125;	<span class="comment">// RB 树的终节点为header所指处</span></span><br><span class="line">	<span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> header; &#125;</span><br><span class="line">	<span class="function">reverse_iterator <span class="title">rbegin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> reverse_iterator(end()); &#125;</span><br><span class="line">	<span class="function">const_reverse_iterator <span class="title">rbegin</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> const_reverse_iterator(end());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">reverse_iterator <span class="title">rend</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> reverse_iterator(begin()); &#125;</span><br><span class="line">	<span class="function">const_reverse_iterator <span class="title">rend</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> const_reverse_iterator(begin());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> node_count == <span class="number">0</span>; &#125;</span><br><span class="line">	<span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> node_count; &#125;</span><br><span class="line">	<span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> size_type(<span class="number">-1</span>); &#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;&amp; t)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">		<span class="comment">//RB-tree只有三个资料表现成员，所以两颗RB-tree互换时，只需互换3个成员</span></span><br><span class="line">		__STD::swap(header, t.header);</span><br><span class="line">		__STD::swap(node_count, t.node_count);</span><br><span class="line">		__STD::swap(key_compare, t.key_compare);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// insert/erase</span></span><br><span class="line">	<span class="comment">// 将 x 安插到 RB-tree 中（保持节点值独一无二）。</span></span><br><span class="line">	pair&lt;iterator, <span class="keyword">bool</span>&gt; insert_unique(<span class="keyword">const</span> value_type&amp; x);</span><br><span class="line">	<span class="comment">// 将 x 安插到 RB-tree 中（允许重复节点）</span></span><br><span class="line">	<span class="function">iterator <span class="title">insert_equal</span><span class="params">(<span class="keyword">const</span> value_type&amp; x)</span></span>;</span><br><span class="line"> </span><br><span class="line">	<span class="function">iterator <span class="title">insert_unique</span><span class="params">(iterator position, <span class="keyword">const</span> value_type&amp; x)</span></span>;</span><br><span class="line">	<span class="function">iterator <span class="title">insert_equal</span><span class="params">(iterator position, <span class="keyword">const</span> value_type&amp; x)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __STL_MEMBER_TEMPLATES  </span></span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="class">	<span class="title">void</span> <span class="title">insert_unique</span>(<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>);</span></span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="class">	<span class="title">void</span> <span class="title">insert_equal</span>(<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">/* __STL_MEMBER_TEMPLATES */</span></span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">insert_unique</span><span class="params">(const_iterator first, const_iterator last)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">insert_unique</span><span class="params">(<span class="keyword">const</span> value_type* first, <span class="keyword">const</span> value_type* last)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">insert_equal</span><span class="params">(const_iterator first, const_iterator last)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">insert_equal</span><span class="params">(<span class="keyword">const</span> value_type* first, <span class="keyword">const</span> value_type* last)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __STL_MEMBER_TEMPLATES */</span></span></span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">(iterator position)</span></span>;</span><br><span class="line">	<span class="function">size_type <span class="title">erase</span><span class="params">(<span class="keyword">const</span> key_type&amp; x)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">(iterator first, iterator last)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">(<span class="keyword">const</span> key_type* first, <span class="keyword">const</span> key_type* last)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (node_count != <span class="number">0</span>) &#123;</span><br><span class="line">			__erase(root());</span><br><span class="line">			leftmost() = header;</span><br><span class="line">			root() = <span class="number">0</span>;</span><br><span class="line">			rightmost() = header;</span><br><span class="line">			node_count = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 集合（set）的各种操作行为</span></span><br><span class="line">	<span class="function">iterator <span class="title">find</span><span class="params">(<span class="keyword">const</span> key_type&amp; x)</span></span>;</span><br><span class="line">	<span class="function">const_iterator <span class="title">find</span><span class="params">(<span class="keyword">const</span> key_type&amp; x)</span> <span class="keyword">const</span></span>;</span><br><span class="line">	<span class="function">size_type <span class="title">count</span><span class="params">(<span class="keyword">const</span> key_type&amp; x)</span> <span class="keyword">const</span></span>;</span><br><span class="line">	<span class="function">iterator <span class="title">lower_bound</span><span class="params">(<span class="keyword">const</span> key_type&amp; x)</span></span>;</span><br><span class="line">	<span class="function">const_iterator <span class="title">lower_bound</span><span class="params">(<span class="keyword">const</span> key_type&amp; x)</span> <span class="keyword">const</span></span>;</span><br><span class="line">	<span class="function">iterator <span class="title">upper_bound</span><span class="params">(<span class="keyword">const</span> key_type&amp; x)</span></span>;</span><br><span class="line">	<span class="function">const_iterator <span class="title">upper_bound</span><span class="params">(<span class="keyword">const</span> key_type&amp; x)</span> <span class="keyword">const</span></span>;</span><br><span class="line">	pair&lt;iterator, iterator&gt; equal_range(<span class="keyword">const</span> key_type&amp; x);</span><br><span class="line">	pair&lt;const_iterator, const_iterator&gt; equal_range(<span class="keyword">const</span> key_type&amp; x) <span class="keyword">const</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// Debugging.</span></span><br><span class="line">	<span class="keyword">bool</span> __rb_verify() <span class="keyword">const</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="title">class</span> <span class="title">Value</span>, <span class="title">class</span> <span class="title">KeyOfValue</span>, <span class="title">class</span> <span class="title">Compare</span>, <span class="title">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">bool</span> <span class="title">operator</span>==(<span class="title">const</span> <span class="title">rb_tree</span>&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;&amp; <span class="title">x</span>,</span></span><br><span class="line"><span class="class">	<span class="title">const</span> <span class="title">rb_tree</span>&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;&amp; <span class="title">y</span>) &#123;</span></span><br><span class="line">	<span class="keyword">return</span> x.size() == y.size() &amp;&amp; equal(x.begin(), x.end(), y.begin());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载 &lt; 运算符，使用的是STL泛型算法lexicographical_compare</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="title">class</span> <span class="title">Value</span>, <span class="title">class</span> <span class="title">KeyOfValue</span>, <span class="title">class</span> <span class="title">Compare</span>, <span class="title">class</span> <span class="title">Alloc</span>&gt; <span class="title">inline</span> <span class="title">bool</span> <span class="title">operator</span> &lt; (const rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;&amp; x, const rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;&amp; y) &#123;</span></span><br><span class="line"><span class="class">	return lexicographical_compare(x.begin(), x.end(), y.begin(), y.end());</span></span><br><span class="line"><span class="class">&#125;</span></span><br><span class="line"><span class="class">#ifdef __STL_FUNCTION_TMPL_PARTIAL_ORDER</span></span><br><span class="line"><span class="class">template &lt;class Key, class Value, class KeyOfValue, class Compare, class Alloc&gt;</span></span><br><span class="line"><span class="class">inline void swap(rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;&amp; x,</span></span><br><span class="line"><span class="class">	rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;&amp; y) &#123;</span></span><br><span class="line"><span class="class">	x.swap(y);</span></span><br><span class="line"><span class="class">&#125;</span></span><br><span class="line"><span class="class">#endif /* __STL_FUNCTION_TMPL_PARTIAL_ORDER */</span></span><br><span class="line"><span class="class">//重载赋值运算符=</span></span><br><span class="line"><span class="class">template &lt;class Key, class Value, class KeyOfValue, class Compare, class Alloc&gt;</span></span><br><span class="line"><span class="class">rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;&amp;</span></span><br><span class="line"><span class="class">rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;::</span></span><br><span class="line"><span class="class">operator=(const rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;&amp; x) &#123;</span></span><br><span class="line"><span class="class">	if (this != &amp;x) &#123;//防止自身赋值</span></span><br><span class="line"><span class="class">		// Note that Key may be a constant type.</span></span><br><span class="line"><span class="class">		clear();//先清除</span></span><br><span class="line"><span class="class">		node_count = 0;</span></span><br><span class="line"><span class="class">		key_compare = x.key_compare;</span></span><br><span class="line"><span class="class">		if (x.root() == 0) &#123;</span></span><br><span class="line"><span class="class">			root() = 0;</span></span><br><span class="line"><span class="class">			leftmost() = header;</span></span><br><span class="line"><span class="class">			rightmost() = header;</span></span><br><span class="line"><span class="class">		&#125;</span></span><br><span class="line"><span class="class">		else &#123;</span></span><br><span class="line"><span class="class">			root() = __copy(x.root(), header);</span></span><br><span class="line"><span class="class">			leftmost() = minimum(root());</span></span><br><span class="line"><span class="class">			rightmost() = maximum(root());</span></span><br><span class="line"><span class="class">			node_count = x.node_count;</span></span><br><span class="line"><span class="class">		&#125;</span></span><br><span class="line"><span class="class">	&#125;</span></span><br><span class="line"><span class="class">	return *this;</span></span><br><span class="line"><span class="class">&#125;</span></span><br><span class="line"><span class="class"> </span></span><br><span class="line"><span class="class">#ifdef __STL_MEMBER_TEMPLATES  </span></span><br><span class="line"><span class="class"> </span></span><br><span class="line"><span class="class">template &lt;class K, class V, class KoV, class Cmp, class Al&gt; template&lt;class II&gt;</span></span><br><span class="line"><span class="class">void rb_tree&lt;K, V, KoV, Cmp, Al&gt;::insert_equal(II first, II last) &#123;</span></span><br><span class="line"><span class="class">	for (; first != last; ++first)</span></span><br><span class="line"><span class="class">		insert_equal(*first);</span></span><br><span class="line"><span class="class">&#125;</span></span><br><span class="line"><span class="class"> </span></span><br><span class="line"><span class="class">template &lt;class K, class V, class KoV, class Cmp, class Al&gt; template&lt;class II&gt;</span></span><br><span class="line"><span class="class">void rb_tree&lt;K, V, KoV, Cmp, Al&gt;::insert_unique(II first, II last) &#123;</span></span><br><span class="line"><span class="class">	for (; first != last; ++first)</span></span><br><span class="line"><span class="class">		insert_unique(*first);</span></span><br><span class="line"><span class="class">&#125;</span></span><br><span class="line"><span class="class"> </span></span><br><span class="line"><span class="class">#else /* __STL_MEMBER_TEMPLATES */</span></span><br><span class="line"><span class="class"> </span></span><br><span class="line"><span class="class">template &lt;class K, class V, class KoV, class Cmp, class Al&gt;</span></span><br><span class="line"><span class="class">void</span></span><br><span class="line"><span class="class">rb_tree&lt;K, V, KoV, Cmp, Al&gt;::insert_equal(const V* first, const V* last) &#123;</span></span><br><span class="line"><span class="class">	for (; first != last; ++first)</span></span><br><span class="line"><span class="class">		insert_equal(*first);</span></span><br><span class="line"><span class="class">&#125;</span></span><br><span class="line"><span class="class"> </span></span><br><span class="line"><span class="class">template &lt;class K, class V, class KoV, class Cmp, class Al&gt;</span></span><br><span class="line"><span class="class">void</span></span><br><span class="line"><span class="class">rb_tree&lt;K, V, KoV, Cmp, Al&gt;::insert_equal(const_iterator first,</span></span><br><span class="line"><span class="class">const_iterator last) &#123;</span></span><br><span class="line"><span class="class">	for (; first != last; ++first)</span></span><br><span class="line"><span class="class">		insert_equal(*first);</span></span><br><span class="line"><span class="class">&#125;</span></span><br><span class="line"><span class="class"> </span></span><br><span class="line"><span class="class">template &lt;class K, class V, class KoV, class Cmp, class A&gt;</span></span><br><span class="line"><span class="class">void</span></span><br><span class="line"><span class="class">rb_tree&lt;K, V, KoV, Cmp, A&gt;::insert_unique(const V* first, const V* last) &#123;</span></span><br><span class="line"><span class="class">	for (; first != last; ++first)</span></span><br><span class="line"><span class="class">		insert_unique(*first);</span></span><br><span class="line"><span class="class">&#125;</span></span><br><span class="line"><span class="class"> </span></span><br><span class="line"><span class="class">template &lt;class K, class V, class KoV, class Cmp, class A&gt;</span></span><br><span class="line"><span class="class">void</span></span><br><span class="line"><span class="class">rb_tree&lt;K, V, KoV, Cmp, A&gt;::insert_unique(const_iterator first,</span></span><br><span class="line"><span class="class">const_iterator last) &#123;</span></span><br><span class="line"><span class="class">	for (; first != last; ++first)</span></span><br><span class="line"><span class="class">		insert_unique(*first);</span></span><br><span class="line"><span class="class">&#125;</span></span><br><span class="line"><span class="class"> </span></span><br><span class="line"><span class="class">#endif /* __STL_MEMBER_TEMPLATES */</span></span><br></pre></td></tr></table></figure>
<h3 id="RB-tree的构造与内存管理"><a href="#RB-tree的构造与内存管理" class="headerlink" title="RB-tree的构造与内存管理"></a>RB-tree的构造与内存管理</h3><p>下面是RB-tree所定义的专属空间配置器<code>rb_tree_node_allocator</code>，每次可恰恰配置一个节点：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="title">class</span> <span class="title">Value</span>, <span class="title">class</span> <span class="title">KeyOfValue</span>, <span class="title">class</span> <span class="title">Compare</span>, <span class="title">class</span> <span class="title">Alloc</span> = <span class="title">alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">rb_tree</span> &#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">typedef</span> __rb_tree_node&lt;Value&gt; rb_tree_node;</span><br><span class="line">	<span class="keyword">typedef</span> simple_alloc&lt;rb_tree_node, Alloc&gt; rb_tree_node_allocator;</span><br></pre></td></tr></table></figure></p>
<p>rb-tree的构造方式有两种，一种是以现有的rb-tree构造一个新的rb-tree，另一种是构造一个空空如也的新树。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rb_tree&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, identity&lt;<span class="keyword">int</span>&gt;, less&lt;<span class="keyword">int</span>&gt; &gt; itree;</span><br></pre></td></tr></table></figure></p>
<p>然后调用构造函数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rb_tree(<span class="keyword">const</span> Compare&amp; comp = Compare()) : node_count(<span class="number">0</span>), key_compare(comp) &#123; init(); &#125;</span><br></pre></td></tr></table></figure></p>
<p>其中的<code>init()</code>是一个关键点<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	header = get_node();	<span class="comment">// 产生一个节点空间，令header指向它</span></span><br><span class="line">	color(header) = __rb_tree_red; <span class="comment">// 令 header 尾红色，用來区 header  </span></span><br><span class="line">	<span class="comment">// 和 root（在 iterator.operator++ 中）</span></span><br><span class="line">	root() = <span class="number">0</span>;</span><br><span class="line">	leftmost() = header;	<span class="comment">// 令 header 的左孩子为自己。</span></span><br><span class="line">	rightmost() = header;	<span class="comment">// 令 header 的右孩子为自己。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>STL为根节点再设计了一个父节点：<br><img src="/img/1609934235.png" alt></p>
<h3 id="RB-tree的元素操作"><a href="#RB-tree的元素操作" class="headerlink" title="RB-tree的元素操作"></a>RB-tree的元素操作</h3><p>RB-tree提供两种插入操作：<code>insert_unique()</code>和<code>insert_equal()</code>，前者标识被插入节点的键值（key）在整棵树中必须独一无二（因此，如果整棵树中已存在相同的键值，插入操作就不会真正进行），后者标识被插入节点的键值在整棵树中可以重复，因此，无论如何插入都会成功（除非空间不足导致配置失败）。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 安插新值；允许键值重复。返回新插入节点的迭代器</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="title">class</span> <span class="title">Value</span>, <span class="title">class</span> <span class="title">KeyOfValue</span>, <span class="title">class</span> <span class="title">Compare</span>, <span class="title">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">typename</span> <span class="title">rb_tree</span>&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;:</span>:iterator</span><br><span class="line">rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;::insert_equal(<span class="keyword">const</span> Value&amp; v)</span><br><span class="line">&#123;</span><br><span class="line">	link_type y = header;</span><br><span class="line">	link_type x = root();</span><br><span class="line">	<span class="keyword">while</span> (x != <span class="number">0</span>) &#123;		<span class="comment">// 从根节点开始，向下寻找适当安插位置</span></span><br><span class="line">		y = x;</span><br><span class="line">		x = key_compare(KeyOfValue()(v), key(x)) ? left(x) : right(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> __insert(x, y, v);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">不允许键值重复，否则安插无效。</span></span><br><span class="line"><span class="comment">返回值是个pair，第一个元素是个RB-tree迭代器，指向新增节点。</span></span><br><span class="line"><span class="comment">第二个元素表示安插是否成功。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="title">class</span> <span class="title">Value</span>, <span class="title">class</span> <span class="title">KeyOfValue</span>, <span class="title">class</span> <span class="title">Compare</span>, <span class="title">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">pair</span>&lt;typename rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;::iterator, bool&gt;</span></span><br><span class="line"><span class="class"><span class="title">rb_tree</span>&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;:</span>:insert_unique(<span class="keyword">const</span> Value&amp; v)</span><br><span class="line">&#123;</span><br><span class="line">	link_type y = header;</span><br><span class="line">	link_type x = root();  <span class="comment">//从根节点开始</span></span><br><span class="line">	<span class="keyword">bool</span> comp = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">while</span> (x != <span class="number">0</span>) &#123; 		<span class="comment">// 从根节点开始向下寻找适当安插位置</span></span><br><span class="line">		y = x;</span><br><span class="line">		comp = key_compare(KeyOfValue()(v), key(x)); <span class="comment">// v 键值小于目前节点的键值？</span></span><br><span class="line">		x = comp ? left(x) : right(x);	<span class="comment">// 遇「大」往左，遇「小于或等于」往右</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//离开while循环之后，y所指即为安插点的父节点，x必为叶子节点</span></span><br><span class="line"> </span><br><span class="line">	iterator j = iterator(y);   <span class="comment">// 令迭代器j指向安插点之父节点 y</span></span><br><span class="line">	<span class="keyword">if</span> (comp)	<span class="comment">//如果离开while循环时comp为真，表示 父节点键值&gt;v ，将安插在左孩子处</span></span><br><span class="line">	<span class="keyword">if</span> (j == begin())   <span class="comment">// 如果j是最左节点</span></span><br><span class="line">		<span class="keyword">return</span> pair&lt;iterator, <span class="keyword">bool</span>&gt;(__insert(x, y, v), <span class="literal">true</span>);</span><br><span class="line">	<span class="comment">// 以上，x 为安插点，y 为安插点之父节点，v 为新值。</span></span><br><span class="line">	<span class="keyword">else</span>	<span class="comment">// 否则（安插点之父节点不是最左节点）</span></span><br><span class="line">		--j;	<span class="comment">// 调整 j，回头准备测试...</span></span><br><span class="line">	<span class="keyword">if</span> (key_compare(key(j.node), KeyOfValue()(v)))</span><br><span class="line">		<span class="comment">// 小于新值（表示遇「小」，将安插于右侧）</span></span><br><span class="line">		<span class="keyword">return</span> pair&lt;iterator, <span class="keyword">bool</span>&gt;(__insert(x, y, v), <span class="literal">true</span>);</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//若运行到这里，表示键值有重复，不应该插入</span></span><br><span class="line">	<span class="keyword">return</span> pair&lt;iterator, <span class="keyword">bool</span>&gt;(j, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="title">class</span> <span class="title">Val</span>, <span class="title">class</span> <span class="title">KeyOfValue</span>, <span class="title">class</span> <span class="title">Compare</span>, <span class="title">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">typename</span> <span class="title">rb_tree</span>&lt;Key, Val, KeyOfValue, Compare, Alloc&gt;:</span>:iterator</span><br><span class="line">rb_tree&lt;Key, Val, KeyOfValue, Compare, Alloc&gt;::insert_unique(iterator position,</span><br><span class="line"><span class="keyword">const</span> Val&amp; v) &#123;</span><br><span class="line">	<span class="keyword">if</span> (position.node == header-&gt;left) <span class="comment">// begin()</span></span><br><span class="line">	<span class="keyword">if</span> (size() &gt; <span class="number">0</span> &amp;&amp; key_compare(KeyOfValue()(v), key(position.node)))</span><br><span class="line">		<span class="keyword">return</span> __insert(position.node, position.node, v);</span><br><span class="line">	<span class="comment">// first argument just needs to be non-null </span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> insert_unique(v).first;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (position.node == header) <span class="comment">// end()</span></span><br><span class="line">	<span class="keyword">if</span> (key_compare(key(rightmost()), KeyOfValue()(v)))</span><br><span class="line">		<span class="keyword">return</span> __insert(<span class="number">0</span>, rightmost(), v);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> insert_unique(v).first;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		iterator before = position;</span><br><span class="line">		--before;</span><br><span class="line">		<span class="keyword">if</span> (key_compare(key(before.node), KeyOfValue()(v))</span><br><span class="line">			&amp;&amp; key_compare(KeyOfValue()(v), key(position.node)))</span><br><span class="line">		<span class="keyword">if</span> (right(before.node) == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> __insert(<span class="number">0</span>, before.node, v);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> __insert(position.node, position.node, v);</span><br><span class="line">		<span class="comment">// first argument just needs to be non-null </span></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> insert_unique(v).first;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="title">class</span> <span class="title">Val</span>, <span class="title">class</span> <span class="title">KeyOfValue</span>, <span class="title">class</span> <span class="title">Compare</span>, <span class="title">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">typename</span> <span class="title">rb_tree</span>&lt;Key, Val, KeyOfValue, Compare, Alloc&gt;:</span>:iterator</span><br><span class="line">rb_tree&lt;Key, Val, KeyOfValue, Compare, Alloc&gt;::insert_equal(iterator position,</span><br><span class="line"><span class="keyword">const</span> Val&amp; v) &#123;</span><br><span class="line">	<span class="keyword">if</span> (position.node == header-&gt;left) <span class="comment">// begin()</span></span><br><span class="line">	<span class="keyword">if</span> (size() &gt; <span class="number">0</span> &amp;&amp; key_compare(KeyOfValue()(v), key(position.node)))</span><br><span class="line">		<span class="keyword">return</span> __insert(position.node, position.node, v);</span><br><span class="line">	<span class="comment">// first argument just needs to be non-null </span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> insert_equal(v);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (position.node == header) <span class="comment">// end()</span></span><br><span class="line">	<span class="keyword">if</span> (!key_compare(KeyOfValue()(v), key(rightmost())))</span><br><span class="line">		<span class="keyword">return</span> __insert(<span class="number">0</span>, rightmost(), v);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> insert_equal(v);</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		iterator before = position;</span><br><span class="line">		--before;</span><br><span class="line">		<span class="keyword">if</span> (!key_compare(KeyOfValue()(v), key(before.node))</span><br><span class="line">			&amp;&amp; !key_compare(key(position.node), KeyOfValue()(v)))</span><br><span class="line">		<span class="keyword">if</span> (right(before.node) == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> __insert(<span class="number">0</span>, before.node, v);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> __insert(position.node, position.node, v);</span><br><span class="line">		<span class="comment">// first argument just needs to be non-null </span></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> insert_equal(v);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>真正的插入程序：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="title">class</span> <span class="title">Value</span>, <span class="title">class</span> <span class="title">KeyOfValue</span>, <span class="title">class</span> <span class="title">Compare</span>, <span class="title">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">typename</span> <span class="title">rb_tree</span>&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;:</span>:iterator</span><br><span class="line">rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;::</span><br><span class="line">__insert(base_ptr x_, base_ptr y_, <span class="keyword">const</span> Value&amp; v) &#123;</span><br><span class="line">	<span class="comment">//参数x_为新值安插点，参数y_为安插点之父节点，参数v 为新值</span></span><br><span class="line">	link_type x = (link_type)x_;</span><br><span class="line">	link_type y = (link_type)y_;</span><br><span class="line">	link_type z;</span><br><span class="line">	<span class="comment">//key_compare是键值得比较准则，是个函数或函数指针</span></span><br><span class="line">	<span class="keyword">if</span> (y == header || x != <span class="number">0</span> || key_compare(KeyOfValue()(v), key(y))) &#123;</span><br><span class="line">		z = create_node(v);  <span class="comment">// 产生一个新节点</span></span><br><span class="line">		left(y) = z;          <span class="comment">// 这使得当y为header时，leftmost()=z</span></span><br><span class="line">		<span class="keyword">if</span> (y == header) &#123;</span><br><span class="line">			root() = z;</span><br><span class="line">			rightmost() = z;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (y == leftmost())	<span class="comment">// 如果y为最左节点</span></span><br><span class="line">			leftmost() = z;           	<span class="comment">// 维护leftmost()，使它永远指向最左节点</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		z = create_node(v);</span><br><span class="line">		right(y) = z;				<span class="comment">// 令新节点成为安插点之父节点y的右孩子</span></span><br><span class="line">		<span class="keyword">if</span> (y == rightmost())</span><br><span class="line">			rightmost() = z;          	<span class="comment">// 维护rightmost()，使它永远指向最右节点</span></span><br><span class="line">	&#125;</span><br><span class="line">	parent(z) = y;		<span class="comment">// 设定新节点的父节点</span></span><br><span class="line">	left(z) = <span class="number">0</span>;		<span class="comment">// 设定新孩子节点的左孩子</span></span><br><span class="line">	right(z) = <span class="number">0</span>; 		<span class="comment">// 设定新孩子节点的右孩子</span></span><br><span class="line">	<span class="comment">// 新节点的颜色将在 __rb_tree_rebalance() 设定并调整</span></span><br><span class="line">	__rb_tree_rebalance(z, header-&gt;parent);	<span class="comment">// 参数一为新增节点，参数二为root</span></span><br><span class="line">	++node_count;		<span class="comment">// 节点数增加</span></span><br><span class="line">	<span class="keyword">return</span> iterator(z);	<span class="comment">// 返回迭代器，指向新增节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><p>set的特性是，所有元素都会根据元素的键值自动排序，set的元素不像map那样可以同时拥有实值和键值，set元素的键值就是实值，实值就是键值，且不允许两个元素有相同的键值。set具有以下特点：</p>
<ul>
<li>不能通过set的迭代器改变set的元素，set iterators被定义为底层RB-tree的const_iterators，杜绝写入操作。</li>
<li>客户端对set进行元素新增或者删除操作时，操作之前的所有迭代器在操作后都依然有效，被删除的元素的迭代器例外。</li>
</ul>
<p>STL特别提供了一组set/multiset相关算法，包括交集、联集、差集、对称差集。STL set以RB-tree为底层机制，set的操作几乎都是转调用RB-tree的函数而已。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="title">class</span> <span class="title">Compare</span> = <span class="title">less</span>&lt;Key&gt;, <span class="title">class</span> <span class="title">Alloc</span> = <span class="title">alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">set</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// typedefs:</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">typedef</span> Key key_type;</span><br><span class="line">  <span class="keyword">typedef</span> Key value_type;</span><br><span class="line">  <span class="keyword">typedef</span> Compare key_compare;</span><br><span class="line">  <span class="keyword">typedef</span> Compare value_compare;</span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  template &lt;class T&gt;</span></span><br><span class="line"><span class="comment">  struct identity : public unary_function&lt;T, T&gt; &#123;</span></span><br><span class="line"><span class="comment">    const T&amp; operator()(const T&amp; x) const &#123; return x; &#125;</span></span><br><span class="line"><span class="comment">  &#125;;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">typedef</span> rb_tree&lt;key_type, value_type, </span><br><span class="line">                  identity&lt;value_type&gt;, key_compare, Alloc&gt; rep_type;</span><br><span class="line">  rep_type t;  <span class="comment">// red-black tree representing set</span></span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_pointer pointer;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_pointer const_pointer;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_reference reference;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_reference const_reference;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_iterator iterator;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_iterator const_iterator;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_reverse_iterator reverse_iterator;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_reverse_iterator const_reverse_iterator;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::size_type size_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::difference_type difference_type;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// allocation/deallocation</span></span><br><span class="line">	<span class="comment">// 注意，set一定使用RB-tree的insert_unique()，而非insert_equal()</span></span><br><span class="line">	<span class="comment">// multiset才使用RB-tree的insert_equal()</span></span><br><span class="line">	<span class="comment">// 因为set不许相同键值存在</span></span><br><span class="line">	<span class="built_in">set</span>() : t(Compare()) &#123;&#125;</span><br><span class="line">	explicit set(const Compare&amp; comp) : t(comp) &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="class">	<span class="title">set</span>(<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>) :</span> t(Compare()) &#123;t.insert_unique(first, last);&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="class">	<span class="title">set</span>(<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>, <span class="title">const</span> <span class="title">Compare</span>&amp; <span class="title">comp</span>) :</span> t(comp) &#123;t.insert_unique(first, last);&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">set</span>(<span class="keyword">const</span> <span class="built_in">set</span>&lt;Key, Compare, Alloc&gt;&amp; x) : t(x.t) &#123;&#125;</span><br><span class="line">	<span class="built_in">set</span>&lt;Key, Compare, Alloc&gt;&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="built_in">set</span>&lt;Key, Compare, Alloc&gt;&amp; x) &#123;</span><br><span class="line">		t = x.t;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// accessors:</span></span><br><span class="line">	<span class="comment">//转调用RB-tree的操作行为</span></span><br><span class="line">	<span class="function">key_compare <span class="title">key_comp</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> t.key_comp(); &#125;</span><br><span class="line">	<span class="function">value_compare <span class="title">value_comp</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> value_compare(t.key_comp()); &#125;</span><br><span class="line">	<span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> t.begin(); &#125;</span><br><span class="line">	<span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> t.end(); &#125;</span><br><span class="line">	<span class="function">reverse_iterator <span class="title">rbegin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> t.rbegin(); &#125;</span><br><span class="line">	<span class="function">reverse_iterator <span class="title">rend</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> t.rend(); &#125;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> t.empty(); &#125;</span><br><span class="line">	<span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> t.size(); &#125;</span><br><span class="line">	<span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> t.max_size(); &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="built_in">set</span>&lt;Key, Compare, Alloc&gt;&amp; x)</span> </span>&#123;t.swap(x.t);&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// insert/erase </span></span><br><span class="line">	<span class="keyword">typedef</span> pair&lt;iterator, <span class="keyword">bool</span>&gt; pair_iterator_bool;</span><br><span class="line">	pair&lt;iterator, <span class="keyword">bool</span>&gt; insert(<span class="keyword">const</span> value_type&amp; x) &#123;</span><br><span class="line">		pair&lt;<span class="keyword">typename</span> rep_type::iterator, <span class="keyword">bool</span>&gt; p = t.insert_unique(x);</span><br><span class="line">		<span class="keyword">return</span> pair&lt;iterator, <span class="keyword">bool</span>&gt;((p.first, p.second);</span><br><span class="line">	&#125;</span><br><span class="line">	iterator insert(iterator position, <span class="keyword">const</span> value_type&amp; x) &#123;</span><br><span class="line">		<span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::iterator rep_iterator; </span><br><span class="line">		<span class="keyword">return</span> t.insert_unique((rep_iterator&amp;)position, x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">template</span> &lt;class InputIterator&gt; </span><br><span class="line">	<span class="keyword">void</span> insert(InputIterator first, InputIterator last) &#123;</span><br><span class="line">		t.insert_unique(first, last); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">void</span> erase(iterator position) &#123;</span><br><span class="line">		<span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::iterator rep_iterator; </span><br><span class="line">		t.erase((rep_iterator&amp;)position);</span><br><span class="line">	&#125; </span><br><span class="line">	size_type erase(<span class="keyword">const</span> key_type&amp; x) &#123; <span class="keyword">return</span> t.erase(x);&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">void</span> erase(iterator first, iterator last) &#123;</span><br><span class="line">		<span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::iterator rep_iterator; </span><br><span class="line">		t.erase((rep_iterators&amp;)first, (rep_iterator&amp;)last); </span><br><span class="line">	&#125;</span><br><span class="line">  	<span class="keyword">void</span> clear() ( t.clear(); &#125; </span><br><span class="line"></span><br><span class="line">	<span class="comment">// set operations:</span></span><br><span class="line">	iterator find(<span class="keyword">const</span> key_type&amp; x) <span class="keyword">const</span> &#123; <span class="keyword">return</span> t.find(x); &#125;</span><br><span class="line">	size_type count(<span class="keyword">const</span> key_type&amp; x) <span class="keyword">const</span> &#123; <span class="keyword">return</span> t.count(x); &#125; </span><br><span class="line">	iterator lowerbound(<span class="keyword">const</span> key_type&amp; x) <span class="keyword">const</span> &#123; </span><br><span class="line">		<span class="keyword">return</span> t.lower_bound(x); </span><br><span class="line">	&#125;</span><br><span class="line">	iterator upper_bound(<span class="keyword">const</span> key_type&amp; x) <span class="keyword">const</span> &#123; <span class="keyword">return</span> t.upppr_bonnd(x); &#125;</span><br><span class="line">	pair&lt;iterator, iterator&gt; equal_range(<span class="keyword">const</span> key_type&amp; x) <span class="keyword">const</span> &#123;</span><br><span class="line">		t.equal_range(x); </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="comment">// 以下的 STL_NULL_TMPL_ARCS 被定义为&lt;&gt;</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>== __STL_NULL_TMPL_ARGS (<span class="keyword">const</span> <span class="built_in">set</span>&amp;, <span class="keyword">const</span> <span class="built_in">set</span>&amp;);</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt; __STL_NULL_TMPL_ARGS (<span class="keyword">const</span> <span class="built_in">set</span>&amp;, <span class="keyword">const</span> <span class="built_in">set</span>&amp;);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">template</span> &lt;class Key, class Compare, class Alloc&gt;</span><br><span class="line">	<span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> <span class="built_in">set</span>&lt;Key, Compare, Alloc&gt;&amp; x, <span class="keyword">const</span> <span class="built_in">set</span>&lt;Key, Compare, Alloc&gt;&amp; y) &#123; </span><br><span class="line">		<span class="keyword">return</span> x.t == y.t; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">template</span> &lt;class Key, class Compare, class Alloc&gt;</span><br><span class="line">	<span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> <span class="built_in">set</span>&lt;Key, Compare, Alloc&gt;&amp; x, <span class="keyword">const</span> <span class="built_in">set</span>&lt;Key, Compare, Alloc&gt;&amp; y) &#123; </span><br><span class="line">		<span class="keyword">return</span> x.t &lt; y.t; </span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>测试程序：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file: 5set-test.cpp</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> ia[<span class="number">5</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; iset&#123;ia, ia + <span class="number">5</span>&#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"size="</span> &lt;&lt; iset.size() &lt;&lt; <span class="built_in">endl</span>;         <span class="comment">//size=5</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"3 count ="</span> &lt;&lt; iset.count(<span class="number">3</span>) &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">//3 count =1</span></span><br><span class="line">    iset.insert(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"size="</span> &lt;&lt; iset.size() &lt;&lt; <span class="built_in">endl</span>;         <span class="comment">//size=5</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"3 count ="</span> &lt;&lt; iset.count(<span class="number">3</span>) &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">//3 count =1</span></span><br><span class="line"> </span><br><span class="line">    iset.insert(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"size="</span> &lt;&lt; iset.size() &lt;&lt; <span class="built_in">endl</span>;         <span class="comment">//size=6</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"5 count ="</span> &lt;&lt; iset.count(<span class="number">5</span>) &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">//5 count =1</span></span><br><span class="line"> </span><br><span class="line">    iset.erase(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"size="</span> &lt;&lt; iset.size() &lt;&lt; <span class="built_in">endl</span>;        <span class="comment">//size=5</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"3 count ="</span> &lt;&lt; iset.count(<span class="number">3</span>) &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//3 count =1</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"1 count ="</span> &lt;&lt; iset.count(<span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//1 count =0</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator ite1 = iset.begin();</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator ite2 = iset.end();</span><br><span class="line">    <span class="keyword">for</span> (; ite1 != ite2; ++ite1) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *ite1;                             <span class="comment">//02345</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 使用STL算法find可以搜索元素，但不推荐</span></span><br><span class="line">    ite1 = find(iset.begin(), iset.end(), <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span> (ite1 != iset.end())</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"3 found"</span> &lt;&lt; <span class="built_in">endl</span>;                <span class="comment">//3 found</span></span><br><span class="line"> </span><br><span class="line">    ite1 = find(iset.begin(), iset.end(), <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (ite1 == iset.end())</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"1 not found"</span> &lt;&lt; <span class="built_in">endl</span>;            <span class="comment">//1 not found</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 关联式容器应使用专用的find函数搜索更有效率</span></span><br><span class="line">    ite1 = iset.find(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span> (ite1 != iset.end())</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"3 found"</span> &lt;&lt; <span class="built_in">endl</span>;                <span class="comment">//3 found</span></span><br><span class="line"> </span><br><span class="line">    ite1 = iset.find(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (ite1 == iset.end())</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"1 not found"</span> &lt;&lt; <span class="built_in">endl</span>;            <span class="comment">//1 not found</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// *ite1 = 9; // 修改失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="multiset"><a href="#multiset" class="headerlink" title="multiset"></a>multiset</h3><p>multiset的特性及用法和set完全相同，唯一的差别在于它允许键值重复，因为它的插入操作采用的是RB-tree的insert_equal()。测试程序：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ia[] = &#123; <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">2</span> &#125;;</span><br><span class="line">	<span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; iset(begin(ia), end(ia));</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"size="</span> &lt;&lt; iset.size() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//size=6</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"3 count="</span> &lt;&lt; iset.count(<span class="number">3</span>) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//3 count=1</span></span><br><span class="line"> </span><br><span class="line">	iset.insert(<span class="number">3</span>); <span class="comment">//和set区别的地方</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"size="</span> &lt;&lt; iset.size() &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//size=7</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"3 count="</span> &lt;&lt; iset.count(<span class="number">3</span>) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//3 count=2</span></span><br><span class="line"> </span><br><span class="line">	iset.insert(<span class="number">7</span>);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"size="</span> &lt;&lt; iset.size() &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//size=8</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"3 count="</span> &lt;&lt; iset.count(<span class="number">3</span>) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//3 count=2</span></span><br><span class="line"> </span><br><span class="line">	iset.erase(<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"size="</span> &lt;&lt; iset.size() &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//size=7</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"1 count="</span> &lt;&lt; iset.count(<span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//1 count=0</span></span><br><span class="line"> </span><br><span class="line">	<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">	<span class="keyword">for</span> (it = iset.begin(); it != iset.end(); ++it)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>; <span class="comment">//2 3 3 4 5 6 7</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">	it = iset.find(<span class="number">3</span>);</span><br><span class="line">	<span class="keyword">if</span> (it != iset.end())</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"3 found"</span> &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//3 found</span></span><br><span class="line"> </span><br><span class="line">	it = iset.find(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (it == iset.end())</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"1 not found"</span> &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//1 not found </span></span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="map概述"><a href="#map概述" class="headerlink" title="map概述"></a>map概述</h2><p>map的特性是，所有元素都会根据元素的键值自动排序，map的所有元素都是pair，pair的第一元素是键值，第二元素是实值。map具有以下特点：</p>
<ul>
<li>不能通过map的迭代器改变map的键值，但通过map的迭代器能改变map的实值。因此map的iterators既不是一种const iterators，也不是一种mutable iterators。</li>
<li>客户端对map进行元素新增或者删除操作时，操作之前的所有迭代器在操作后都依然有效，被删除的元素的迭代器例外。</li>
<li>map不允许两个元素拥有相同的键值。</li>
</ul>
<p>下面是pair的定义<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="title">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">pair</span> &#123;</span></span><br><span class="line">	<span class="keyword">typedef</span> T1 first_type;</span><br><span class="line">	<span class="keyword">typedef</span> T2 second_type;</span><br><span class="line"> </span><br><span class="line">	T1 first;</span><br><span class="line">	T2 second;</span><br><span class="line">	pair() : first(T1()), second(T2()) &#123;&#125;</span><br><span class="line">	pair(<span class="keyword">const</span> T1&amp; a, <span class="keyword">const</span> T2&amp; b) : first(a), second(b) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>从上可以看出，pair 包含两个类型（可以相同，也可以不相同）的公共元素。<br>map同set一样，都是关联式容器，内部元素的实值都会根据其键值来进行排序（set 的实值就是键值），所以都不能任意改变元素的键值，但是map可以任意改变元素的实值，我们所有操作的前提以及是否被允许，要看是否会影响到map元素的排序规则。</p>
<p>同样map和multimap 也是以RB-tree 为底层机制，几乎所有的map操作行为，都只是转调用RB-tree的操作行为而已。</p>
<p>set 和 map的内部结构即元素的存储都是RB-tree，set 中，RB-tree的节点内容是单一元素，而map中，节点内容则是一个pair <code>&lt;key，value&gt;</code>。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">map</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// typedefs:</span></span><br><span class="line"> </span><br><span class="line">	<span class="keyword">typedef</span> Key key_type; <span class="comment">//键值型别</span></span><br><span class="line">	<span class="keyword">typedef</span> T data_type;  <span class="comment">//实值型别</span></span><br><span class="line">	<span class="keyword">typedef</span> pair&lt;<span class="keyword">const</span> Key, T&gt; value_type;  <span class="comment">//元素性别（键值/实值）</span></span><br><span class="line">	<span class="keyword">typedef</span> Compare key_compare;  <span class="comment">//键值比较函数</span></span><br><span class="line"> </span><br><span class="line">	<span class="comment">//定义一个函数，其作用就是调用“元素比较函数”</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">value_compare</span></span></span><br><span class="line"><span class="class">		:</span> <span class="keyword">public</span> binary_function&lt;value_type, value_type, <span class="keyword">bool</span>&gt; &#123;</span><br><span class="line">		<span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">map</span>&lt;Key, T, Compare, Alloc&gt;;</span></span><br><span class="line">	<span class="keyword">protected</span>:</span><br><span class="line">		Compare comp;</span><br><span class="line">		value_compare(Compare c) : comp(c) &#123;&#125;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="comment">//重载</span></span><br><span class="line">		<span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> value_type&amp; x, <span class="keyword">const</span> value_type&amp; y)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> comp(x.first, y.first);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">typedef</span> rb_tree&lt;key_type, value_type,</span><br><span class="line">		select1st&lt;value_type&gt;, key_compare, Alloc&gt; rep_type;</span><br><span class="line">	rep_type t;  <span class="comment">// 以RB-tree为底层实现，所有元素(pair)存放在RB-tree节点中</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//两种类型的都有，因为map允许用户通过迭代器修改元素的实值</span></span><br><span class="line">	<span class="keyword">typedef</span> rep_type::pointer pointer;</span><br><span class="line">	<span class="keyword">typedef</span> rep_type::reference reference;</span><br><span class="line">	<span class="keyword">typedef</span> rep_type::const_reference const_reference;</span><br><span class="line">	<span class="keyword">typedef</span> rep_type::iterator iterator;</span><br><span class="line">	<span class="keyword">typedef</span> rep_type::const_iterator const_iterator;</span><br><span class="line">	<span class="keyword">typedef</span> rep_type::reverse_iterator reverse_iterator;</span><br><span class="line">	<span class="keyword">typedef</span> rep_type::const_reverse_iterator const_reverse_iterator;</span><br><span class="line">	<span class="keyword">typedef</span> rep_type::size_type size_type;</span><br><span class="line">	<span class="keyword">typedef</span> rep_type::difference_type difference_type;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// allocation/deallocation</span></span><br><span class="line">	<span class="comment">//构造函数</span></span><br><span class="line">	<span class="built_in">map</span>() : t(Compare()) &#123;&#125;</span><br><span class="line">	explicit map(const Compare&amp; comp) : t(comp) &#123;&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">/*map一定使用底层RB-tree 的insert_unique()*/</span></span><br><span class="line"> </span><br><span class="line">	<span class="built_in">map</span>(<span class="keyword">const</span> <span class="built_in">map</span>&lt;Key, T, Compare, Alloc&gt;&amp; x) : t(x.t) &#123;&#125;</span><br><span class="line">	<span class="built_in">map</span>&lt;Key, T, Compare, Alloc&gt;&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="built_in">map</span>&lt;Key, T, Compare, Alloc&gt;&amp; x)</span><br><span class="line">	&#123;</span><br><span class="line">		t = x.t;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// accessors:</span></span><br><span class="line">	<span class="comment">//转调用RB-tree的操作行为</span></span><br><span class="line">	<span class="function">key_compare <span class="title">key_comp</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> t.key_comp(); &#125;</span><br><span class="line">	<span class="function">value_compare <span class="title">value_comp</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> value_compare(t.key_comp()); &#125;</span><br><span class="line">	<span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> t.begin(); &#125;</span><br><span class="line">	<span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> t.begin(); &#125;</span><br><span class="line">	<span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> t.end(); &#125;</span><br><span class="line">	<span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> t.end(); &#125;</span><br><span class="line">	<span class="function">reverse_iterator <span class="title">rbegin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> t.rbegin(); &#125;</span><br><span class="line">	<span class="function">const_reverse_iterator <span class="title">rbegin</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> t.rbegin(); &#125;</span><br><span class="line">	<span class="function">reverse_iterator <span class="title">rend</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> t.rend(); &#125;</span><br><span class="line">	<span class="function">const_reverse_iterator <span class="title">rend</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> t.rend(); &#125;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> t.empty(); &#125;</span><br><span class="line">	<span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> t.size(); &#125;</span><br><span class="line">	<span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> t.max_size(); &#125;</span><br><span class="line">	<span class="comment">/*下面这个下标操作符重载函数是的map支持元素的直接存取，索引值是元素的key*/</span></span><br><span class="line">	T&amp; <span class="keyword">operator</span>[](<span class="keyword">const</span> key_type&amp; k) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> (*((insert(value_type(k, T()))).first)).second;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="built_in">map</span>&lt;Key, T, Compare, Alloc&gt;&amp; x)</span> </span>&#123; t.swap(x.t); &#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// insert/erase</span></span><br><span class="line">	<span class="comment">//都是调用底层RB-tree的操作行为</span></span><br><span class="line">	pair&lt;iterator, <span class="keyword">bool</span>&gt; insert(<span class="keyword">const</span> value_type&amp; x) &#123; <span class="keyword">return</span> t.insert_unique(x); &#125;</span><br><span class="line">	<span class="function">iterator <span class="title">insert</span><span class="params">(iterator position, <span class="keyword">const</span> value_type&amp; x)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> t.insert_unique(position, x);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">(iterator position)</span> </span>&#123; t.erase(position); &#125;</span><br><span class="line">	<span class="function">size_type <span class="title">erase</span><span class="params">(<span class="keyword">const</span> key_type&amp; x)</span> </span>&#123; <span class="keyword">return</span> t.erase(x); &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">(iterator first, iterator last)</span> </span>&#123; t.erase(first, last); &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; t.clear(); &#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// map operations:</span></span><br><span class="line">	<span class="comment">/*返回一个迭代器指向键值为key的元素，如果没找到就返回end()*/</span></span><br><span class="line">	<span class="function">iterator <span class="title">find</span><span class="params">(<span class="keyword">const</span> key_type&amp; x)</span> </span>&#123; <span class="keyword">return</span> t.find(x); &#125;</span><br><span class="line">	<span class="function">const_iterator <span class="title">find</span><span class="params">(<span class="keyword">const</span> key_type&amp; x)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> t.find(x); &#125;</span><br><span class="line">	<span class="comment">/*返回键值等于key的元素的个数*/</span></span><br><span class="line">	<span class="function">size_type <span class="title">count</span><span class="params">(<span class="keyword">const</span> key_type&amp; x)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> t.count(x); &#125;</span><br><span class="line">	<span class="comment">/*返回一个迭代器，指向键值&gt;=key的第一个元素*/</span></span><br><span class="line">	<span class="function">iterator <span class="title">lower_bound</span><span class="params">(<span class="keyword">const</span> key_type&amp; x)</span> </span>&#123; <span class="keyword">return</span> t.lower_bound(x); &#125;</span><br><span class="line">	<span class="function">const_iterator <span class="title">lower_bound</span><span class="params">(<span class="keyword">const</span> key_type&amp; x)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> t.lower_bound(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*返回一个迭代器，指向键值&gt;key的第一个元素*/</span></span><br><span class="line">	<span class="function">iterator <span class="title">upper_bound</span><span class="params">(<span class="keyword">const</span> key_type&amp; x)</span> </span>&#123; <span class="keyword">return</span> t.upper_bound(x); &#125;</span><br><span class="line">	<span class="function">const_iterator <span class="title">upper_bound</span><span class="params">(<span class="keyword">const</span> key_type&amp; x)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> t.upper_bound(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*返回键值为key的元素的第一个可安插位置和最后一个可安插位置，也就是“键值==key”的元素区间*/</span></span><br><span class="line">	pair&lt;iterator, iterator&gt; equal_range(<span class="keyword">const</span> key_type&amp; x) &#123;</span><br><span class="line">		<span class="keyword">return</span> t.equal_range(x);</span><br><span class="line">	&#125;</span><br><span class="line">	pair&lt;const_iterator, const_iterator&gt; equal_range(<span class="keyword">const</span> key_type&amp; x) <span class="keyword">const</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> t.equal_range(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> <span class="built_in">map</span>&amp;, <span class="keyword">const</span> <span class="built_in">map</span>&amp;);</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> <span class="built_in">map</span>&amp;, <span class="keyword">const</span> <span class="built_in">map</span>&amp;);</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*运算符重载，几乎有所有的操作行为都是调用RB-tree的操作行为</span></span><br><span class="line"><span class="comment">事实上，包括set在内的关联式容器内部都是以RB-tree方式存放的*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="title">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Compare</span>, <span class="title">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">bool</span> <span class="title">operator</span>==(<span class="title">const</span> <span class="title">map</span>&lt;Key, T, Compare, Alloc&gt;&amp; <span class="title">x</span>,</span></span><br><span class="line"><span class="class">	<span class="title">const</span> <span class="title">map</span>&lt;Key, T, Compare, Alloc&gt;&amp; <span class="title">y</span>) &#123;</span></span><br><span class="line">	<span class="keyword">return</span> x.t == y.t;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="title">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Compare</span>, <span class="title">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">bool</span> <span class="title">operator</span>&lt;(const map&lt;Key, T, Compare, Alloc&gt;&amp; x,</span></span><br><span class="line"><span class="class">	const map&lt;Key, T, Compare, Alloc&gt;&amp; y) &#123;</span></span><br><span class="line"><span class="class">	return x.t &lt; y.t;</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>通常，关联式容器并不提供元素的直接存取，你必须依靠迭代器，不过 map 内部的下标操作符重载函数使得其支持元素的直接存取，看看它是怎么实现的<br>这是map作为关联式容器特殊的地方（multimap没有哦）</p>
<h3 id="map测试程序"><a href="#map测试程序" class="headerlink" title="map测试程序"></a>map测试程序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; stuMap;</span><br><span class="line">    </span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"————————————————————插入操作—————————————————"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	stuMap[<span class="number">1001</span>]=<span class="string">"Jason"</span>;</span><br><span class="line">	stuMap.insert(pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;(<span class="number">1002</span>,<span class="string">"Helen"</span>));</span><br><span class="line">	stuMap.insert(make_pair(<span class="number">1003</span>,<span class="string">"Steve"</span>));</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::const_iterator iter = stuMap.begin();</span><br><span class="line">    <span class="keyword">for</span> (; iter != stuMap.end(); ++iter)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt;<span class="string">"id:"</span>&lt;&lt; iter-&gt;first &lt;&lt;<span class="string">" name:"</span>&lt;&lt; iter-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"————————————————————取值操作—————————————————"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt;<span class="string">"stuMap[1004]:"</span>&lt;&lt;stuMap[<span class="number">1004</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//使用at会进行关键字检查，因此下面语句会报错</span></span><br><span class="line">	<span class="comment">//stuMap.at(1005) = "Bob";</span></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"————————————————————查找操作—————————————————"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	iter = stuMap.find(<span class="number">1001</span>);</span><br><span class="line">	<span class="keyword">if</span> (iter!=stuMap.end())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt;<span class="string">"1001 found name:"</span>&lt;&lt;iter-&gt;second&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	iter = stuMap.find(<span class="number">1005</span>);</span><br><span class="line">	<span class="keyword">if</span> ( iter==stuMap.end())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt;<span class="string">"1005 not found"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"————————————————————容量查询—————————————————"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"stuMap empty state is "</span>&lt;&lt;boolalpha&lt;&lt;stuMap.empty()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"stuMap size is "</span>&lt;&lt;boolalpha&lt;&lt;stuMap.size()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"stuMap.count(1008) is "</span>&lt;&lt;boolalpha&lt;&lt;stuMap.count(<span class="number">1008</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"————————————————————删除操作—————————————————"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"before delete"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	iter = stuMap.begin();</span><br><span class="line">    <span class="keyword">for</span> (; iter != stuMap.end(); ++iter)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt;<span class="string">"id:"</span>&lt;&lt; iter-&gt;first &lt;&lt;<span class="string">" name:"</span>&lt;&lt; iter-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	stuMap.erase(<span class="number">1004</span>);</span><br><span class="line">	</span><br><span class="line">	iter = stuMap.begin();</span><br><span class="line">    <span class="keyword">for</span> (; iter != stuMap.end(); ++iter)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(iter-&gt;second==<span class="string">"Helen"</span>)	</span><br><span class="line">		&#123;</span><br><span class="line">			stuMap.erase(iter);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"after delete"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	iter = stuMap.begin();</span><br><span class="line">    <span class="keyword">for</span> (; iter != stuMap.end(); ++iter)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt;<span class="string">"id:"</span>&lt;&lt; iter-&gt;first &lt;&lt;<span class="string">" name:"</span>&lt;&lt; iter-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[root@<span class="number">192</span> <span class="number">5</span>_STL_associated_container]# ./<span class="number">5</span>_4_map-test</span><br><span class="line">————————————————————插入操作—————————————————</span><br><span class="line">id:<span class="number">1001</span> name:Jason</span><br><span class="line">id:<span class="number">1002</span> name:Helen</span><br><span class="line">id:<span class="number">1003</span> name:Steve</span><br><span class="line">————————————————————取值操作—————————————————</span><br><span class="line">stuMap[<span class="number">1004</span>]:</span><br><span class="line">————————————————————查找操作—————————————————</span><br><span class="line"><span class="number">1001</span> found name:Jason</span><br><span class="line"><span class="number">1005</span> <span class="keyword">not</span> found</span><br><span class="line">————————————————————容量查询—————————————————</span><br><span class="line">stuMap empty state is <span class="literal">false</span></span><br><span class="line">stuMap size is <span class="number">4</span></span><br><span class="line">stuMap.count(<span class="number">1008</span>) is <span class="number">0</span></span><br><span class="line">————————————————————删除操作—————————————————</span><br><span class="line">before <span class="keyword">delete</span></span><br><span class="line">id:<span class="number">1001</span> name:Jason</span><br><span class="line">id:<span class="number">1002</span> name:Helen</span><br><span class="line">id:<span class="number">1003</span> name:Steve</span><br><span class="line">id:<span class="number">1004</span> name:</span><br><span class="line">after <span class="keyword">delete</span></span><br><span class="line">id:<span class="number">1001</span> name:Jason</span><br><span class="line">id:<span class="number">1003</span> name:Steve</span><br></pre></td></tr></table></figure></p>
<h2 id="hashtable"><a href="#hashtable" class="headerlink" title="hashtable"></a>hashtable</h2><p>hashtable在插入，删除，搜寻等操作上具有＂常数平均时间＂的表现，而且这种表现以统计为基础，不依赖输入元素的随机性。（二叉搜索树具有对数平均时间的表现，是建立在输入数据有足够随机性的基础上。）</p>
<p>hash table 可提供对任何有名项的存取操作和删除操作。由于操作对象是有名项，所以hashtable可被视为一种字典结构（dictionary）。举个例子，如果所有元素时16-bits且不带有正负号的整数，范围为0-65535，则可以通过配置一个array拥有65536个元素，对应位置记录元素出现个数，添加A[i]++，删除A[i]—，查找A[i]==0判断。但是进一步，如果所有元素是32-bits，那大小必须是2^32=4GB，那直接分配这么大的空间就不太实际。再进一步，如果元素时字符串，每个字符用7-bits数值(ASCII)表示，这种方法就更不可取了。</p>
<p>为了解决上述问题，引入了hash funtion的概念。hashfuntion可以将某一元素映射为一个“大小可接受之索引”，即大数映射成小数。hashtable通过hashfunction将元素映射到不同的位置，但当不同的元素通过hash function映射到相同位置时，便产生了＂碰撞＂问题．解决碰撞问题的方法主要有线性探测，二次探测，开链法等．</p>
<ul>
<li>线性探测：当hash function计算出某个元素的插入位置，而该位置的空间已不可用时，循序往下寻找下一个可用位置(到达尾端时绕到头部继续寻找)，会产生primary clustering（一次聚集）问题。</li>
<li>二次探测：当hash function计算出某个元素的插入位置为H，而该位置的空间已经被占用，就尝试用H+１²、H+2²…，会产生secondary clustering(二次聚集)问题。</li>
<li>开链：在每一个表格元素中维护一个list：hash function为我们分配某个list，在那个list上进行元素的插入，删除，搜寻等操作．SGI STL解决碰撞问题的方法就是此方法。</li>
</ul>
<p>下面以开链法完成hash table的图形表述，hash table 表格内的元素为桶子（bucket），每个bucket都维护一个链表，来解决哈希碰撞，如下所示：<br><img src="/img/1610004677.jpg" alt></p>
<p>下面看一下 hashtable 的定义：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Value</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> __<span class="title">hastabl_node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	__hastable_node* next;</span><br><span class="line">	Value val;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>以下是hash table的迭代器的定义<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Value</span>, <span class="title">class</span> <span class="title">Key</span>, <span class="title">class</span> <span class="title">HashFcn</span>,</span></span><br><span class="line"><span class="class">          <span class="title">class</span> <span class="title">ExtractKey</span>, <span class="title">class</span> <span class="title">EqualKey</span>, <span class="title">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> __<span class="title">hashtable_iterator</span> &#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> hashtable&lt;Value, Key, HashFcn, ExtractKey, EqualKey, Alloc&gt; hashtable;</span><br><span class="line">  <span class="keyword">typedef</span> __hashtable_iterator&lt;Value, Key, HashFcn, ExtractKey, EqualKey, Alloc&gt; iterator;</span><br><span class="line">  <span class="keyword">typedef</span> __hashtable_const_iterator&lt;Value, Key, HashFcn, ExtractKey, EqualKey, Alloc&gt; const_iterator;</span><br><span class="line">  <span class="keyword">typedef</span> __hashtable_node&lt;Value&gt; node;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">typedef</span> forward_iterator_tag iterator_category;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;</span><br><span class="line">  <span class="keyword">typedef</span> Value&amp; reference;</span><br><span class="line">  <span class="keyword">typedef</span> Value* pointer;</span><br><span class="line"> </span><br><span class="line">  node* cur;    <span class="comment">//迭代器目前所指之节点</span></span><br><span class="line">  hashtable* ht;   <span class="comment">//保持容器的连结关系</span></span><br><span class="line">  ...</span><br><span class="line">  __hashtable_iterator(node* n, hashtable* tab) : cur(n), ht(tab) &#123;&#125;</span><br><span class="line">  __hashtable_iterator() &#123;&#125;</span><br><span class="line">  reference <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> cur-&gt;val; &#125; </span><br><span class="line">  pointer <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*()); &#125; </span><br><span class="line">  iterator&amp; <span class="keyword">operator</span>++(); </span><br><span class="line">  iterator <span class="keyword">operator</span>++(<span class="keyword">int</span>); </span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> iterator&amp; it) <span class="keyword">const</span> &#123; <span class="keyword">return</span> cur == it.cur; &#125;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> iterator&amp; it) <span class="keyword">const</span> &#123; <span class="keyword">return</span> cur != it.cur; &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>注意hashtable迭代器必须永远维系着与整个buckets vector的关系，并记录目前所指的节点。其前进操作是首先尝试从目前所指的节点出发，前进一个位置〔节点），由于节点被安置于st内，所以利用节点的next指针即可轻易达成前进操作，如果目前节点正巧是list的尾端，就跳至下一个bucket身上，那正是指向下一个bucket的头部节点。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">V</span>, <span class="title">class</span> <span class="title">K</span>, <span class="title">class</span> <span class="title">HF</span>, <span class="title">Class</span> <span class="title">ExK</span>, <span class="title">class</span> <span class="title">EqK</span>, <span class="title">class</span> <span class="title">A</span>&gt;</span></span><br><span class="line"><span class="class">__<span class="title">hashtable_iteratorc</span>&lt;V, K, HF, ExK, EqK, A&gt;&amp; </span></span><br><span class="line"><span class="class">__<span class="title">hashtable_iteratorc</span>&lt;V, K, HF, ExK, EqK, A&gt;:</span>:<span class="keyword">operator</span>++()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">const</span> node* old = cur;</span><br><span class="line">	cur = cur-&gt;next; <span class="comment">//如果存在，就是它。否则进入以下流程</span></span><br><span class="line">	<span class="keyword">if</span>(!cur) &#123; </span><br><span class="line">	<span class="comment">//根据元素值，定位出下一个bucket，其起头处就是我们的目的地</span></span><br><span class="line">		size_type bucket = ht-&gt;bkt_num(old-&gt;val);</span><br><span class="line">		<span class="keyword">while</span> (!cur &amp;&amp; ++bucket &lt; ht-&gt;buckets.size())</span><br><span class="line">			cur = ht-&gt;buckets[bucket];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">V</span>, <span class="title">class</span> <span class="title">K</span>, <span class="title">class</span> <span class="title">HF</span>, <span class="title">Class</span> <span class="title">ExK</span>, <span class="title">class</span> <span class="title">EqK</span>, <span class="title">class</span> <span class="title">A</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> __<span class="title">hashtable_iteratorc</span>&lt;V, K, HF, ExK, EqK, A&gt; </span></span><br><span class="line"><span class="class">__<span class="title">hashtable_iteratorc</span>&lt;V, K, HF, ExK, EqK, A&gt;:</span>:<span class="keyword">operator</span>++(<span class="keyword">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">	iterator tmp = *<span class="keyword">this</span>;</span><br><span class="line">	++*<span class="keyword">this</span>;</span><br><span class="line">	<span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>hashtable没有逆向操作（operator—()）。</p>
<h3 id="hashtable的数据结构"><a href="#hashtable的数据结构" class="headerlink" title="hashtable的数据结构"></a>hashtable的数据结构</h3><p>下图是hashtable的定义摘要，其中可见bucket聚合体以vector完成，以利动态扩充：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Value</span>,<span class="title">class</span> <span class="title">Key</span>, <span class="title">class</span> <span class="title">HashFcn</span>, <span class="title">class</span> <span class="title">ExtractKey</span>, <span class="title">class</span> <span class="title">EqualKey</span>, <span class="title">class</span> <span class="title">Alloc</span> = <span class="title">alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">hashtable</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">Value</span>, <span class="title">class</span> <span class="title">Key</span>, <span class="title">class</span> <span class="title">HashFcn</span>, <span class="title">class</span> <span class="title">ExtractKey</span>, <span class="title">class</span> <span class="title">EqualKey</span>, <span class="title">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">hashtable</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> HashFcn hasher;</span><br><span class="line">	<span class="keyword">typedef</span> EqualKey key_equal;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	hasher hash;</span><br><span class="line">	key_equal equals;</span><br><span class="line">	ExtractKey get_key;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> __hashtable_node&lt;Value&gt; node;</span><br><span class="line">	<span class="keyword">typedef</span> simple_alloc&lt;node, Alloc&gt; node_allocator;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">vector</span>&lt;node*, Alloc&gt; buckets;</span><br><span class="line">	size_type num_elements;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">size_type <span class="title">bucket_count</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> buckets.size(); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>虽然开链法不要求表格大小必须为质数，但是SGI STL仍然以质数来设计表格大小。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//表格大小必须为质数，从下述28个质数中取最接近的</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> __stl_num_primes = <span class="number">28</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> __stl_prime_list[__stl_num_primes] =</span><br><span class="line">&#123;</span><br><span class="line">  <span class="number">53</span>,         <span class="number">97</span>,           <span class="number">193</span>,         <span class="number">389</span>,       <span class="number">769</span>,</span><br><span class="line">  <span class="number">1543</span>,       <span class="number">3079</span>,         <span class="number">6151</span>,        <span class="number">12289</span>,     <span class="number">24593</span>,</span><br><span class="line">  <span class="number">49157</span>,      <span class="number">98317</span>,        <span class="number">196613</span>,      <span class="number">393241</span>,    <span class="number">786433</span>,</span><br><span class="line">  <span class="number">1572869</span>,    <span class="number">3145739</span>,      <span class="number">6291469</span>,     <span class="number">12582917</span>,  <span class="number">25165843</span>,</span><br><span class="line">  <span class="number">50331653</span>,   <span class="number">100663319</span>,    <span class="number">201326611</span>,   <span class="number">402653189</span>, <span class="number">805306457</span>, </span><br><span class="line">  <span class="number">1610612741</span>, <span class="number">3221225473u</span>l, <span class="number">4294967291u</span>l</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 获取桶的数量 */</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> __stl_next_prime(<span class="keyword">unsigned</span> <span class="keyword">long</span> n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">long</span>* first = __stl_prime_list;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">long</span>* last = __stl_prime_list + __stl_num_primes;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">long</span>* pos = lower_bound(first, last, n); <span class="comment">//&gt;=</span></span><br><span class="line">  <span class="keyword">return</span> pos == last ? *(last - <span class="number">1</span>) : *pos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 总共可以有多少个buckets</span></span><br><span class="line"><span class="function">size_type <span class="title">max_bucket_count</span><span class="params">()</span> <span class="keyword">const</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> __stl_prime_list(__stl_num_promes - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="hashtable的构造与内存管理"><a href="#hashtable的构造与内存管理" class="headerlink" title="hashtable的构造与内存管理"></a>hashtable的构造与内存管理</h3><p>节点配置函数和节点释放函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">node* <span class="title">new_node</span><span class="params">(<span class="keyword">const</span> value_type&amp; obj)</span> </span>&#123;</span><br><span class="line">	node* n = node_allocator::allocate();</span><br><span class="line">	n-&gt;next = <span class="number">0</span>;</span><br><span class="line">	__STL_TRY &#123;</span><br><span class="line">		construct(&amp;n-&gt;val, obj);</span><br><span class="line">		<span class="keyword">return</span> n;</span><br><span class="line">	&#125;</span><br><span class="line">	__STL_UNWIND(node_allocator::deallocate(n));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete_node</span><span class="params">(node* n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	destroy(&amp;n-&gt;val);</span><br><span class="line">	node_allocator::deallocate(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当我们初始构造一个拥有50个节点的hashtable如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;value,key,hash-func,extract-key,equal-key,allocator&gt;</span></span><br><span class="line"><span class="comment">// 注意：hashtable没有提供default constructor</span></span><br><span class="line">hashtable&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, hash&lt;<span class="keyword">int</span>&gt;, identity&lt;<span class="keyword">int</span>&gt;, equal_to&lt;<span class="keyword">int</span>&gt;, alloc&gt; iht(<span class="number">50</span>, hash&lt;<span class="keyword">int</span>&gt;(), equal_to&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;iht.size()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;iht.bucket_count()&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p>
<p>上述定义调用：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hashtable(size_type n,</span><br><span class="line">          <span class="keyword">const</span> HashFcn&amp;    hf,</span><br><span class="line">          <span class="keyword">const</span> EqualKey&amp;   eql)</span><br><span class="line">  : hash(hf), equals(eql), get_key(ExtractKey()), num_elements(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">  initialize_buckets(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先初始化三个仿函数，然后调用 initialize_buckets 来初始化hashtable。initialize_buckets 函数定义如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initialize_buckets</span><span class="params">(size_type n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cost size_type n_buckets = next_size(n);</span><br><span class="line">  buckets.reserve(n_buckets);</span><br><span class="line">  buckets.insert(buckets.end(), n_buckets, (node*) <span class="number">0</span>);</span><br><span class="line">  num_elements = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先确定 bucket 的数量，然后通过 reserve 初始化，然后再通过 insert 将所有的 bucket 初始化为 NULL。最后将元素个数填为0（其中的 buckets 是一个 vector）。</p>
<p>hashtable 的插入 跟 RB-tree 的插入类似，有两种插入方法 insert_unique 和 insert_equal ，意思也是一样的，insert_unique 不允许有重复值，而 insert_equal 允许有重复值。因为都会用到是否需要重建表格的判断，我们先来整理这一部分：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">V</span>, <span class="title">class</span> <span class="title">K</span>, <span class="title">class</span> <span class="title">HF</span>, <span class="title">class</span> <span class="title">Ex</span>, <span class="title">class</span> <span class="title">Eq</span>, <span class="title">class</span> <span class="title">A</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">hashtable</span>&lt;V, K, HF, Ex, Eq, A&gt;:</span>:resize(size_type num_elements_hint)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//判断 “表格重建与否” 是拿元素个数和 bucket vector 的大小来比，如果前者大于后者，就重建表格</span></span><br><span class="line">	<span class="comment">//所以 每个 bucket list 的最大容量和 bucket vector 的大小相同</span></span><br><span class="line">	<span class="keyword">const</span> size_type old_n = buckets.size();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>( num_elements_hint &gt; old_n )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">const</span> size_type n = next_size(num_elements_hint); <span class="comment">//next_size 底层调用 __stl_next_prime()</span></span><br><span class="line">		<span class="keyword">if</span>( n &gt; old_n)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">vector</span>&lt;node*,A&gt; tmp(n, (node*) <span class="number">0</span>);		<span class="comment">//设立新的 buckets</span></span><br><span class="line">			</span><br><span class="line">			<span class="comment">//以下是处理每一个旧的 bucket</span></span><br><span class="line">			<span class="keyword">for</span>( size_type bucket = <span class="number">0</span>; bucket &lt; old_n; ++bucket )</span><br><span class="line">			&#123;</span><br><span class="line">				node* first = buckets[bucket];		<span class="comment">//指向节点所对应之串行的起始节点</span></span><br><span class="line">				<span class="keyword">while</span>( first )						<span class="comment">//串行还没结束</span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="comment">//找出当前节点应该放在 新buckets 的哪一个位置</span></span><br><span class="line">					size_type new_bucket = bkt_num(first-&gt;val, n);</span><br><span class="line">					</span><br><span class="line">					<span class="comment">//以下就是对新旧表格的处理，同时还要维护好 first 指针</span></span><br><span class="line">					buckets[bucket] = first-&gt;next; <span class="comment">// 令旧bucket指向其所对应串行的下一个节点</span></span><br><span class="line">					first-&gt;next = tmp[new_bucket]; <span class="comment">// 将当前节点插入到新bucket中，成为其对应串行的第一个节点</span></span><br><span class="line">					tmp[new_bucket] = first;</span><br><span class="line">					first = buckets[bucket]; <span class="comment">// 回到旧bucket所指的待处理串行，准备处理下一个节点</span></span><br><span class="line">				&#125;</span><br><span class="line">				buckets.swap( tmp );				<span class="comment">//vector::swap 函数，新旧两个buckets对调，对调之后释放tmp内存</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在来看一下 insert_unique 函数，需要注意的是插入时，新节点直接插入到链表的头节点，代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;iterator, <span class="keyword">bool</span>&gt; insert_unique(<span class="keyword">const</span> value_type&amp; obj)</span><br><span class="line">&#123;</span><br><span class="line">	resize(num_elements + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> insert_unique_noresize(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在不需要重建表格的情况插入新节点，键值不允许重复<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;iterator, <span class="keyword">bool</span>&gt; insert_unique_noresize(<span class="keyword">const</span> value_type&amp; obj)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">const</span> size_type n = bkt_num(obj);	<span class="comment">//决定 obj 应位于 buckets 的那一个链表中</span></span><br><span class="line">	node* first = buckets[n];</span><br><span class="line"></span><br><span class="line">	<span class="comment">//遍历当前链表，如果发现有相同的键值，就不插入，立刻返回</span></span><br><span class="line">	<span class="keyword">for</span>( node* cur = first; cur; cur = cur-&gt;next)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>( equals(get_key(cur-&gt;val), get_key(obj)) )</span><br><span class="line">			<span class="keyword">return</span> pair&lt;iterator, <span class="keyword">bool</span>&gt;(iterator(cur, <span class="keyword">this</span>), <span class="literal">false</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//离开以上循环（或根本未进入循环）时，first指向 bucket 所指链表的头节点</span></span><br><span class="line">	node* tmp = new_node(obj);		<span class="comment">//产生新节点</span></span><br><span class="line">	tmp-&gt;next = first;</span><br><span class="line">	buckets[n] = tmp;				<span class="comment">//令新节点为链表的第一个节点</span></span><br><span class="line">	++num_elements;					<span class="comment">//节点个数累加1</span></span><br><span class="line">	<span class="keyword">return</span> pair&lt;iterator, <span class="keyword">bool</span>&gt;( iterator(tmp,<span class="keyword">this</span>), <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>resize()</code>如果有必要就得做表格重建工作:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//(1)令旧bucket指向其所对应之链表的下一个节点（以便迭代处理）</span></span><br><span class="line">buckets[bucket】 = first-&gt;next;</span><br><span class="line"><span class="comment">// (2)(3) 将当前节点插人到新bucket内，成为其对应链表的第一个节点</span></span><br><span class="line">first-&gt;next = tmp[new_bucket];</span><br><span class="line">tmp[new_bucket] = first;</span><br><span class="line"><span class="comment">// (4) 回到旧bucket所指的待处理链表，准备处理下一个节点</span></span><br><span class="line">first = buckets[bucket];</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/1610346576.jpg" alt></p>
<p>允许重复插入的 insert_equal，需要注意的是插入时，重复节点插入到相同节点的后面，新节点还是插入到链表的头节点，代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">insert_equal</span><span class="params">(<span class="keyword">const</span> value_type&amp; obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	resize( num_elements + <span class="number">1</span> ); <span class="comment">//判断是否 需要重建表格，如需要就扩充</span></span><br><span class="line">	<span class="keyword">return</span> insert_equal_noresize(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">V</span>, <span class="title">class</span> <span class="title">K</span>, <span class="title">class</span> <span class="title">HF</span>, <span class="title">class</span> <span class="title">Ex</span>, <span class="title">class</span> <span class="title">Eq</span>, <span class="title">class</span> <span class="title">A</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">typename</span> <span class="title">hashtable</span>&lt;V, K, HF, Ex, Eq, A&gt;:</span>:iterator</span><br><span class="line">hashtable&lt;V, K, HF, Ex, Eq, A&gt;::insert_equal_noresize(<span class="keyword">const</span> value_type&amp; obj)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">const</span> size_type n = bkt_num(obj);	<span class="comment">//决定 obj 应位于 buckets 的那一个链表中</span></span><br><span class="line">	node* first = buckets[n];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历当前链表，如果发现有相同的键值，就马上插入，立刻返回</span></span><br><span class="line">    <span class="keyword">for</span>( node* cur = first; cur; cur = cur-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="keyword">if</span>( equals(get_key(cur-&gt;val), get_key(obj)) )</span><br><span class="line">    	&#123;</span><br><span class="line">    		node* tmp = new_node(obj);</span><br><span class="line">    		tmp-&gt;next = cur-&gt;next;		<span class="comment">//新节点插入当前节点位置之后</span></span><br><span class="line">    		cur-&gt;next = tmp;</span><br><span class="line">    		++num_elements;</span><br><span class="line">    		<span class="keyword">return</span> iterator(tmp, <span class="keyword">this</span>);</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    	</span><br><span class="line">    <span class="comment">//运行到这里，表示没有发现重复的键值</span></span><br><span class="line">    node* tmp = new_node(obj);		<span class="comment">//产生新节点</span></span><br><span class="line">    tmp-&gt;next = first;</span><br><span class="line">    buckets[n] = tmp;				<span class="comment">//令新节点为链表的第一个节点</span></span><br><span class="line">    ++num_elements;					<span class="comment">//节点个数累加1</span></span><br><span class="line">    <span class="keyword">return</span> iterator(tmp, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><p>首先找到指定的bucket，然后从第二个元素开始遍历，如果节点的 key 等于指定的 key，将将其删除。最后再检查第一个元素的 key，如果等于指定的 key，那么就将其删除。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">V</span>, <span class="title">class</span> <span class="title">K</span>, <span class="title">class</span> <span class="title">HF</span>, <span class="title">class</span> <span class="title">Ex</span>, <span class="title">class</span> <span class="title">Eq</span>, <span class="title">class</span> <span class="title">A</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">typename</span> <span class="title">hashtable</span>&lt;V, K, HF, Ex, Eq, A&gt;:</span>:size_type </span><br><span class="line">hashtable&lt;V, K, HF, Ex, Eq, A&gt;::erase(<span class="keyword">const</span> key_type&amp; key)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">const</span> size_type n = bkt_num_key(key);</span><br><span class="line">  node* first = buckets[n];</span><br><span class="line">  size_type erased = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (first) &#123;</span><br><span class="line">    node* cur = first;</span><br><span class="line">    node* next = cur-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (next) &#123;</span><br><span class="line">      <span class="keyword">if</span> (equals(get_key(next-&gt;val), key)) &#123;</span><br><span class="line">        cur-&gt;next = next-&gt;next;</span><br><span class="line">        delete_node(next);</span><br><span class="line">        next = cur-&gt;next;</span><br><span class="line">        ++erased;</span><br><span class="line">        --num_elements;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        cur = next;</span><br><span class="line">        next = cur-&gt;next;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (equals(get_key(first-&gt;val), key)) &#123;</span><br><span class="line">      buckets[n] = first-&gt;next;</span><br><span class="line">      delete_node(first);</span><br><span class="line">      ++erased;</span><br><span class="line">      --num_elements;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> erased;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">V</span>, <span class="title">class</span> <span class="title">K</span>, <span class="title">class</span> <span class="title">HF</span>, <span class="title">class</span> <span class="title">Ex</span>, <span class="title">class</span> <span class="title">Eq</span>, <span class="title">class</span> <span class="title">A</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">hashtable</span>&lt;V, K, HF, Ex, Eq, A&gt;:</span>:clear()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>( size_type i = <span class="number">0</span>; i&lt;buckets.size(); ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		node* cur = buckets[i];</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//将 bucket list 中的每一个节点删除掉</span></span><br><span class="line">		<span class="keyword">while</span>( cur != <span class="number">0</span> )</span><br><span class="line">		&#123;</span><br><span class="line">			node* next = cur-&gt;next;</span><br><span class="line">			delete_node(cur);</span><br><span class="line">			cur = next;</span><br><span class="line">		&#125;</span><br><span class="line">		buckets[i] = <span class="number">0</span>; 	<span class="comment">//令bucket内容为null指针</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	num_elements = <span class="number">0</span>;		<span class="comment">//令总节点个数为 0</span></span><br><span class="line">	<span class="comment">//注意：buckets vector 并未释放掉空间，扔保留原来大小</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复制操作 copy_from，代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">V</span>, <span class="title">class</span> <span class="title">K</span>, <span class="title">class</span> <span class="title">HF</span>, <span class="title">class</span> <span class="title">Ex</span>, <span class="title">class</span> <span class="title">Eq</span>, <span class="title">class</span> <span class="title">A</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">hashtable</span>&lt;V, K, HF, Ex, Eq, A&gt;:</span>:copy_from(<span class="keyword">const</span> hashtable&amp; ht)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//先清除己方的 buckets vector</span></span><br><span class="line">	buckets.clear();</span><br><span class="line">	buckets.reserve(ht.buckets.size());</span><br><span class="line"></span><br><span class="line">	<span class="comment">//从己方的 buckets vector 尾端开始，插入 n 个元素，其值为 null 指针</span></span><br><span class="line">	buckets.insert(buckets.end(), ht.buckets.size(),  (node*)<span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//真正的执行复制操作</span></span><br><span class="line">	<span class="keyword">for</span>(size_type i = <span class="number">0</span>; i &lt; ht.buckets.size(); ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>( <span class="keyword">const</span> node* cur = ht.bucktes[i] ）</span><br><span class="line">		&#123;</span><br><span class="line">			node* copy = new_node(cur-&gt;val);</span><br><span class="line">			buckets[i] = copy;</span><br><span class="line">			<span class="keyword">for</span>(node* next = cur-&gt;next; next; cur = next, next = cur-&gt;next)</span><br><span class="line">			&#123;</span><br><span class="line">				copy-&gt;next = new_node(next-&gt;val);</span><br><span class="line">				copy = copy-&gt;next;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="hash-set"><a href="#hash-set" class="headerlink" title="hash_set"></a>hash_set</h2><p>虽然STL只规范复杂度与接口，并不规范实现方法，但STL set多半以RB-tree为底层机制。SGI则是在STL标准规格之外另又提供了一个所谓的hash_set，以hashtable为底层机制。由于hash_set所供应的操作接口， hashtable都提供了，所以几乎所有的hash_set操作行为，都只是转调用hashtable的操作行为而己。 </p>
<p>运用set，为的是能够快速搜寻元素。这一点，不论其底层是RB-tree或是hash table、都可以达成任务。但是请注意，RB-tree有自动排序功能而hashtable没有，反应出来的结果就是，set的元素有自动排序功能而hash_set没有。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Value</span>, <span class="title">class</span> <span class="title">HashFcn</span> = <span class="title">hash</span>&lt;Value&gt;,</span></span><br><span class="line"><span class="class">                <span class="title">class</span> <span class="title">EqualKey</span> = <span class="title">equal_to</span>&lt;Value&gt;, <span class="title">class</span> <span class="title">Alloc</span>=<span class="title">alloc</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">class</span> <span class="title">hash_set</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">typedef</span> hashtable&lt;Value, Value, HashFcn, identity&lt;Value&gt;,</span><br><span class="line">                            EqualKey, Alloc&gt; ht;</span><br><span class="line">        ht rep;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::key_type key_type;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::value_type value_type;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::hasher hasher;         <span class="comment">//hashtable中: typedef HashFcn hasher</span></span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::key_equel key_equel;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::size_type size_type;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::difference_type difference_type;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::const_pointer pointer;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::const_pointer const_pointer;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::const_reference reference;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::const_reference const_reference;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::const_iterator iterator;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::const_iterator const_iterator;</span><br><span class="line">        </span><br><span class="line">        <span class="function">hasher <span class="title">hash_funct</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> rep.hash_funct(); &#125;</span><br><span class="line">        <span class="function">key_equel <span class="title">key_eq</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> rep.key_eq(); &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//各种构造函数 ,不给定大小的话默认值为100,实际上找到的质数为193</span></span><br><span class="line">        hash_set() : rep(<span class="number">100</span>,hasher(), key_equel())&#123;&#125;</span><br><span class="line">        explicit hash_set(size_type n) : rep(n, hasher(), key_equel()) &#123;&#125;</span><br><span class="line">        hash_set(size_type n, <span class="keyword">const</span> hasher&amp; hf) : rep(n, hf, key_equel()) &#123;&#125;</span><br><span class="line">        hash_set(size_type n, <span class="keyword">const</span> hasher&amp; hf, <span class="keyword">const</span> key_equel&amp; eql)</span><br><span class="line">            : rep(n, hf, eql) &#123;&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="title">hash_set</span>(<span class="title">InputIterator</span> <span class="title">f</span>, <span class="title">InputIterator</span> <span class="title">l</span>)</span></span><br><span class="line"><span class="class">        :</span> rep(<span class="number">100</span>, hasher(), key_equel()) &#123; rep.insert_unique(f, l); &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="title">hash_set</span>(<span class="title">InputIterator</span> <span class="title">f</span>, <span class="title">InputIterator</span> <span class="title">l</span>, <span class="title">size_type</span> <span class="title">n</span>)</span></span><br><span class="line"><span class="class">        :</span> rep(n, hasher(), key_equel()) &#123; rep.insert_unique(f, l); &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="title">hash_set</span>(<span class="title">InputIterator</span> <span class="title">f</span>, <span class="title">InputIterator</span> <span class="title">l</span>, <span class="title">size_type</span> <span class="title">n</span>, <span class="title">const</span> <span class="title">hasher</span>&amp; <span class="title">hf</span>)</span></span><br><span class="line"><span class="class">        :</span> rep(n, hf, key_equel()) &#123; rep.insert_unique(f, l); &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="title">hash_set</span>(<span class="title">InputIterator</span> <span class="title">f</span>, <span class="title">InputIterator</span> <span class="title">l</span>, <span class="title">size_type</span> <span class="title">n</span>, <span class="title">const</span> <span class="title">hasher</span>&amp; <span class="title">hf</span></span></span><br><span class="line"><span class="class">                    <span class="title">const</span> <span class="title">key_equel</span>&amp; <span class="title">eql</span>)</span></span><br><span class="line"><span class="class">        :</span> rep(n, hf, eql) &#123; rep.insert_unique(f, l); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> rep.size();&#125;</span><br><span class="line">        <span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> rep.max_size(); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> rep.empty(); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(hash_set&amp; hs)</span> </span>&#123; rep.swap(hs.rep); &#125;</span><br><span class="line">        <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>== __STL_NULL_TMPL_ARGS (<span class="keyword">const</span> hash_set&amp;, <span class="keyword">const</span> hash_set&amp;);</span><br><span class="line">        <span class="function">iterator <span class="title">begin</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> rep.begin(); &#125;</span><br><span class="line">        <span class="function">iterator <span class="title">end</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> rep.end(); &#125;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        pair&lt;iterator, <span class="keyword">bool</span>&gt; insert(<span class="keyword">const</span> value_type&amp; obj)</span><br><span class="line">        &#123;</span><br><span class="line">           pair&lt;<span class="keyword">typename</span> ht::iterator, <span class="keyword">bool</span>&gt; p =rep.insert_unique(obj);</span><br><span class="line">            <span class="keyword">return</span> pair&lt;iterator, <span class="keyword">bool</span>&gt;(p.first, p.second);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="title">void</span> <span class="title">insert</span>(<span class="title">InputIterator</span> <span class="title">f</span>, <span class="title">InputIterator</span> <span class="title">l</span>) &#123;</span> rep.insert_unique(f,l); &#125;</span><br><span class="line">        pair&lt;iterator, <span class="keyword">bool</span>&gt; insert_noresize(<span class="keyword">const</span> value_type&amp; obj)</span><br><span class="line">        &#123;</span><br><span class="line">            pair&lt;<span class="keyword">typename</span> ht::iterator, <span class="keyword">bool</span>&gt; p = rep.insert_unique_noresize(obj);</span><br><span class="line">            <span class="keyword">return</span> pair&lt;iterator, <span class="keyword">bool</span>&gt;(p.first, p.second);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function">iterator <span class="title">find</span><span class="params">(<span class="keyword">const</span> key_type&amp; key)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> rep.find(key); &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function">size_type <span class="title">count</span><span class="params">(<span class="keyword">const</span> key_type&amp; key)</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> rep.count(key); &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//相等的key的位置(是一个左闭右开的区间)，由迭代器给出</span></span><br><span class="line">        pair&lt;iterator, iterator&gt; equal_range(<span class="keyword">const</span> key_type&amp; key) <span class="keyword">const</span></span><br><span class="line">        &#123; <span class="keyword">return</span> rep.equal_range(key); &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function">size_type <span class="title">erase</span><span class="params">(<span class="keyword">const</span> key_type&amp; key)</span> </span>&#123; <span class="keyword">return</span> rep.erase(key); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">(iterator it)</span> </span>&#123; rep.erase(it); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">(iterator f, iterator l)</span> </span>&#123; rep.erase(f, l); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; rep.clear(); &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span>    <span class="title">resize</span><span class="params">(size_type hint)</span> </span>&#123; rep.resize(hint); &#125;</span><br><span class="line">        <span class="function">size_type <span class="title">bucket_count</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> rep.bucket_count(); &#125;</span><br><span class="line">        <span class="function">size_type <span class="title">elems_in_bucket</span><span class="params">(size_type n)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">        </span>&#123; <span class="keyword">return</span> rep.elems_in_bucket(n); &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//class</span></span><br><span class="line">        <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Value</span>, <span class="title">class</span> <span class="title">HashFcn</span>, <span class="title">class</span> <span class="title">EqualKey</span>, <span class="title">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="title">inline</span> <span class="title">bool</span> <span class="title">operator</span>==(<span class="title">const</span> <span class="title">hash_set</span>&lt;Value, HashFcn, EqualKey, Alloc&gt;&amp; <span class="title">hs1</span>,</span></span><br><span class="line"><span class="class">                               <span class="title">const</span> <span class="title">hash_set</span>&lt;Value, HashFcn, EqualKey, Alloc&gt;&amp; <span class="title">hs2</span>)</span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            <span class="keyword">return</span> has1.rep == has2.rep;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="hash-map"><a href="#hash-map" class="headerlink" title="hash_map"></a>hash_map</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//class</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="title">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">HashFcn</span> = <span class="title">hash</span>&lt;Value&gt;,</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">EqualKey</span> = <span class="title">equal_to</span>&lt;Value&gt;, <span class="title">class</span> <span class="title">Alloc</span>=<span class="title">alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">hash_map</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">typedef</span> hashtable&lt;pair&lt;<span class="keyword">const</span> Key, T&gt;, Key, HashFcn,</span><br><span class="line">                        select1st&lt;pair&lt;<span class="keyword">const</span> Key, T&gt;, EqualKey, Alloc&gt; ht;</span><br><span class="line"></span><br><span class="line">    ht rep;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::key_type key_type;</span><br><span class="line">    <span class="keyword">typedef</span> T data_type;</span><br><span class="line">    <span class="keyword">typedef</span> T mapped_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::value_type value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::hasher hasher;         <span class="comment">//hashtable中: typedef HashFcn hasher</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::key_equel key_equel;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::size_type size_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::difference_type difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::pointer pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::const_pointer const_pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::reference reference;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::const_reference const_reference;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::iterator iterator;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::const_iterator const_iterator;</span><br><span class="line"></span><br><span class="line">    <span class="function">hasher <span class="title">hash_funct</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> rep.hash_funct(); &#125;</span><br><span class="line">    <span class="function">key_equel <span class="title">key_eq</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> rep.key_eq(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">//各种构造函数 ,不给定大小的话默认值为100,实际上找到的质数为193</span></span><br><span class="line">    hash_map() : rep(<span class="number">100</span>, hasher(), key_equel())&#123;&#125;</span><br><span class="line">    explicit hash_map(size_type n) : rep(n, hasher(), key_equel()) &#123;&#125;</span><br><span class="line">    hash_map(size_type n, <span class="keyword">const</span> hasher&amp; hf) : rep(n, hf, key_equel()) &#123;&#125;</span><br><span class="line">    hash_map(size_type n, <span class="keyword">const</span> hasher&amp; hf, <span class="keyword">const</span> key_equel&amp; eql)</span><br><span class="line">    : rep(n, hf, eql) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">hash_map</span>(<span class="title">InputIterator</span> <span class="title">f</span>, <span class="title">InputIterator</span> <span class="title">l</span>)</span></span><br><span class="line"><span class="class">    :</span> rep(<span class="number">100</span>, hasher(), key_equel()) &#123; rep.insert_unique(f, l); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">hash_map</span>(<span class="title">InputIterator</span> <span class="title">f</span>, <span class="title">InputIterator</span> <span class="title">l</span>, <span class="title">size_type</span> <span class="title">n</span>)</span></span><br><span class="line"><span class="class">    :</span> rep(n, hasher(), key_equel()) &#123; rep.insert_unique(f, l); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">hash_map</span>(<span class="title">InputIterator</span> <span class="title">f</span>, <span class="title">InputIterator</span> <span class="title">l</span>, <span class="title">size_type</span> <span class="title">n</span>, <span class="title">const</span> <span class="title">hasher</span>&amp; <span class="title">hf</span>)</span></span><br><span class="line"><span class="class">    :</span> rep(n, hf, key_equel()) &#123; rep.insert_unique(f, l); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">hash_map</span>(<span class="title">InputIterator</span> <span class="title">f</span>, <span class="title">InputIterator</span> <span class="title">l</span>, <span class="title">size_type</span> <span class="title">n</span>, <span class="title">const</span> <span class="title">hasher</span>&amp; <span class="title">hf</span></span></span><br><span class="line"><span class="class">             <span class="title">const</span> <span class="title">key_equel</span>&amp; <span class="title">eql</span>)</span></span><br><span class="line"><span class="class">    :</span> rep(n, hf, eql) &#123; rep.insert_unique(f, l); &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> rep.size();&#125;</span><br><span class="line">    <span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> rep.max_size(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> rep.empty(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(hash_map&amp; hs)</span> </span>&#123; rep.swap(hs.rep); &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>== __STL_NULL_TMPL_ARGS (<span class="keyword">const</span> hash_map&amp;, <span class="keyword">const</span> hash_map&amp;);</span><br><span class="line"></span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> rep.begin(); &#125;</span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> rep.end(); &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    pair&lt;iterator, <span class="keyword">bool</span>&gt; insert(<span class="keyword">const</span> value_type&amp; obj)</span><br><span class="line">    &#123;</span><br><span class="line">     <span class="comment">//之前在set中就想过 为什么不直接返回 在map中看到时直接返回了，</span></span><br><span class="line">        <span class="comment">//不是像set中一样还要先申请一个临时变量 再返回临时变量</span></span><br><span class="line">        <span class="comment">//经过一番努力，发现：set的iterator是const_iterator，因为set不能更改值嘛</span></span><br><span class="line">        <span class="comment">//所以需要进行转化，所以set那里会复杂一些</span></span><br><span class="line">        <span class="keyword">return</span> rep.insert_unique(obj);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">void</span> <span class="title">insert</span>(<span class="title">InputIterator</span> <span class="title">f</span>, <span class="title">InputIterator</span> <span class="title">l</span>) &#123;</span> rep.insert_unique(f,l); &#125;</span><br><span class="line">    pair&lt;iterator, <span class="keyword">bool</span>&gt; insert_noresize(<span class="keyword">const</span> value_type&amp; obj)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>  rep.insert_unique_noresize(obj);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">iterator <span class="title">find</span><span class="params">(<span class="keyword">const</span> key_type&amp; key)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> rep.find(key); &#125;</span><br><span class="line">    <span class="function">const_iterator <span class="title">find</span><span class="params">(<span class="keyword">const</span> key_type&amp; key)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> rep.find(key);&#125;</span><br><span class="line"></span><br><span class="line">    T&amp; <span class="keyword">operator</span>[](<span class="keyword">const</span> key_type&amp; key)</span><br><span class="line">    &#123;</span><br><span class="line">         <span class="keyword">return</span> rep.find_or_insert(value_type(key, T())).second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">size_type <span class="title">count</span><span class="params">(<span class="keyword">const</span> key_type&amp; key)</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> rep.count(key); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//相等的key的位置(是一个左闭右开的区间)，由迭代器给出</span></span><br><span class="line">    pair&lt;iterator, iterator&gt; equal_range(<span class="keyword">const</span> key_type&amp; key) <span class="keyword">const</span></span><br><span class="line">    &#123; <span class="keyword">return</span> rep.equal_range(key); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">size_type <span class="title">erase</span><span class="params">(<span class="keyword">const</span> key_type&amp; key)</span> </span>&#123; <span class="keyword">return</span> rep.erase(key); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">(iterator it)</span> </span>&#123; rep.erase(it); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">(iterator f, iterator l)</span> </span>&#123; rep.erase(f, l); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; rep.clear(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span>    <span class="title">resize</span><span class="params">(size_type hint)</span> </span>&#123; rep.resize(hint); &#125;</span><br><span class="line">    <span class="function">size_type <span class="title">bucket_count</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> rep.bucket_count(); &#125;</span><br><span class="line">    <span class="function">size_type <span class="title">elems_in_bucket</span><span class="params">(size_type n)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> rep.elems_in_bucket(n); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//class</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Value</span>, <span class="title">class</span> <span class="title">HashFcn</span>, <span class="title">class</span> <span class="title">EqualKey</span>, <span class="title">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">inline</span> <span class="title">bool</span> <span class="title">operator</span>==(<span class="title">const</span> <span class="title">hash_map</span>&lt;Value, HashFcn, EqualKey, Alloc&gt;&amp; <span class="title">hm1</span>,</span></span><br><span class="line"><span class="class">                           <span class="title">const</span> <span class="title">hash_map</span>&lt;Value, HashFcn, EqualKey, Alloc&gt;&amp; <span class="title">hm2</span>)</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">         <span class="keyword">return</span> has1.rep == has2.rep;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="hash-multiset"><a href="#hash-multiset" class="headerlink" title="hash_multiset"></a>hash_multiset</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Value</span>, <span class="title">class</span> <span class="title">HashFcn</span> = <span class="title">hash</span>&lt;Value&gt;,</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">EqualKey</span> = <span class="title">equal_to</span>&lt;Value&gt;, <span class="title">class</span> <span class="title">Alloc</span>=<span class="title">alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">hash_multiset</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">typedef</span> hash_multiset&lt;Value, Value, HashFcn, identity&lt;Value&gt;,</span><br><span class="line">    EqualKey, Alloc&gt; ht;</span><br><span class="line"></span><br><span class="line">    ht rep;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::key_type key_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::value_type value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::hasher hasher;         <span class="comment">//hashtable中: typedef HashFcn hasher</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::key_equel key_equel;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::size_type size_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::difference_type difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::const_pointer pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::const_pointer const_pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::const_reference reference;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::const_reference const_reference;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::const_iterator iterator;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::const_iterator const_iterator;</span><br><span class="line"></span><br><span class="line">    <span class="function">hasher <span class="title">hash_funct</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> rep.hash_funct(); &#125;</span><br><span class="line">    <span class="function">key_equel <span class="title">key_eq</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> rep.key_eq(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">//各种构造函数 ,不给定大小的话默认值为100,实际上找到的质数为193</span></span><br><span class="line">    hash_multiset() : rep(<span class="number">100</span>,hasher(), key_equel())&#123;&#125;</span><br><span class="line">    explicit hash_multiset(size_type n) : rep(n, hasher(), key_equel()) &#123;&#125;</span><br><span class="line">    hash_multiset(size_type n, <span class="keyword">const</span> hasher&amp; hf) : rep(n, hf, key_equel()) &#123;&#125;</span><br><span class="line">    hash_multiset(size_type n, <span class="keyword">const</span> hasher&amp; hf, <span class="keyword">const</span> key_equel&amp; eql)</span><br><span class="line">    : rep(n, hf, eql) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">hash_multiset</span>(<span class="title">InputIterator</span> <span class="title">f</span>, <span class="title">InputIterator</span> <span class="title">l</span>)</span></span><br><span class="line"><span class="class">    :</span> rep(<span class="number">100</span>, hasher(), key_equel()) &#123; rep.insert_equal(f, l); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">hash_multiset</span>(<span class="title">InputIterator</span> <span class="title">f</span>, <span class="title">InputIterator</span> <span class="title">l</span>, <span class="title">size_type</span> <span class="title">n</span>)</span></span><br><span class="line"><span class="class">    :</span> rep(n, hasher(), key_equel()) &#123; rep.insert_equal(f, l); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">hash_multiset</span>(<span class="title">InputIterator</span> <span class="title">f</span>, <span class="title">InputIterator</span> <span class="title">l</span>, <span class="title">size_type</span> <span class="title">n</span>, <span class="title">const</span> <span class="title">hasher</span>&amp; <span class="title">hf</span>)</span></span><br><span class="line"><span class="class">    :</span> rep(n, hf, key_equel()) &#123; rep.insert_equal(f, l); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">hash_multiset</span>(<span class="title">InputIterator</span> <span class="title">f</span>, <span class="title">InputIterator</span> <span class="title">l</span>, <span class="title">size_type</span> <span class="title">n</span>, <span class="title">const</span> <span class="title">hasher</span>&amp; <span class="title">hf</span></span></span><br><span class="line"><span class="class">             <span class="title">const</span> <span class="title">key_equel</span>&amp; <span class="title">eql</span>)</span></span><br><span class="line"><span class="class">    :</span> rep(n, hf, eql) &#123; rep.insert_equal(f, l); &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> rep.size();&#125;</span><br><span class="line">    <span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> rep.max_size(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> rep.empty(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(hash_multiset&amp; hs)</span> </span>&#123; rep.swap(hs.rep); &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>== __STL_NULL_TMPL_ARGS (<span class="keyword">const</span> hash_multiset&amp;, <span class="keyword">const</span> hash_multiset&amp;);</span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> rep.begin(); &#125;</span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> rep.end(); &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">iterator <span class="title">insert</span><span class="params">(<span class="keyword">const</span> value_type&amp; obj)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> rep.insert_equal(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">void</span> <span class="title">insert</span>(<span class="title">InputIterator</span> <span class="title">f</span>, <span class="title">InputIterator</span> <span class="title">l</span>) &#123;</span> rep.insert_equal(f,l); &#125;</span><br><span class="line">    <span class="function">iterator <span class="title">insert_noresize</span><span class="params">(<span class="keyword">const</span> value_type&amp; obj)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> rep.insert_equal_noresize(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">iterator <span class="title">find</span><span class="params">(<span class="keyword">const</span> key_type&amp; key)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> rep.find(key); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">size_type <span class="title">count</span><span class="params">(<span class="keyword">const</span> key_type&amp; key)</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> rep.count(key); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//相等的key的位置(是一个左闭右开的区间)，由迭代器给出</span></span><br><span class="line">    pair&lt;iterator, iterator&gt; equal_range(<span class="keyword">const</span> key_type&amp; key) <span class="keyword">const</span></span><br><span class="line">    &#123; <span class="keyword">return</span> rep.equal_range(key); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">size_type <span class="title">erase</span><span class="params">(<span class="keyword">const</span> key_type&amp; key)</span> </span>&#123; <span class="keyword">return</span> rep.erase(key); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">(iterator it)</span> </span>&#123; rep.erase(it); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">(iterator f, iterator l)</span> </span>&#123; rep.erase(f, l); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; rep.clear(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span>    <span class="title">resize</span><span class="params">(size_type hint)</span> </span>&#123; rep.resize(hint); &#125;</span><br><span class="line">    <span class="function">size_type <span class="title">bucket_count</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> rep.bucket_count(); &#125;</span><br><span class="line">    <span class="function">size_type <span class="title">elems_in_bucket</span><span class="params">(size_type n)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> rep.elems_in_bucket(n); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//class</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Value</span>, <span class="title">class</span> <span class="title">HashFcn</span>, <span class="title">class</span> <span class="title">EqualKey</span>, <span class="title">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">inline</span> <span class="title">bool</span> <span class="title">operator</span>==(<span class="title">const</span> <span class="title">hash_multiset</span>&lt;Value, HashFcn, EqualKey, Alloc&gt;&amp; <span class="title">hs1</span>,</span></span><br><span class="line"><span class="class">                           <span class="title">const</span> <span class="title">hash_multiset</span>&lt;Value, HashFcn, EqualKey, Alloc&gt;&amp; <span class="title">hs2</span>)</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">         <span class="keyword">return</span> has1.rep == has2.rep;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="hash-multimap"><a href="#hash-multimap" class="headerlink" title="hash_multimap"></a>hash_multimap</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="title">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">HashFcn</span> = <span class="title">hash</span>&lt;Value&gt;,</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">EqualKey</span> = <span class="title">equal_to</span>&lt;Value&gt;, <span class="title">class</span> <span class="title">Alloc</span>=<span class="title">alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">hash_multimap</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">typedef</span> hashtable&lt;pair&lt;<span class="keyword">const</span> Key, T&gt;, Key, HashFcn,</span><br><span class="line">    select1st&lt;pair&lt;<span class="keyword">const</span> Key, T&gt;, EqualKey, Alloc&gt; ht;</span><br><span class="line"></span><br><span class="line">    ht rep;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::key_type key_type;</span><br><span class="line">    <span class="keyword">typedef</span> T data_type;</span><br><span class="line">    <span class="keyword">typedef</span> T mapped_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::value_type value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::hasher hasher;         <span class="comment">//hashtable中: typedef HashFcn hasher</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::key_equel key_equel;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::size_type size_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::difference_type difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::pointer pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::const_pointer const_pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::reference reference;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::const_reference const_reference;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::iterator iterator;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> ht::const_iterator const_iterator;</span><br><span class="line"></span><br><span class="line">    <span class="function">hasher <span class="title">hash_funct</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> rep.hash_funct(); &#125;</span><br><span class="line">    <span class="function">key_equel <span class="title">key_eq</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> rep.key_eq(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">//各种构造函数 ,不给定大小的话默认值为100,实际上找到的质数为193</span></span><br><span class="line">    hash_multimap() : rep(<span class="number">100</span>, hasher(), key_equel())&#123;&#125;</span><br><span class="line">    explicit hash_multimap(size_type n) : rep(n, hasher(), key_equel()) &#123;&#125;</span><br><span class="line">    hash_multimap(size_type n, <span class="keyword">const</span> hasher&amp; hf) : rep(n, hf, key_equel()) &#123;&#125;</span><br><span class="line">    hash_multimap(size_type n, <span class="keyword">const</span> hasher&amp; hf, <span class="keyword">const</span> key_equel&amp; eql)</span><br><span class="line">    : rep(n, hf, eql) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">hash_multimap</span>(<span class="title">InputIterator</span> <span class="title">f</span>, <span class="title">InputIterator</span> <span class="title">l</span>)</span></span><br><span class="line"><span class="class">    :</span> rep(<span class="number">100</span>, hasher(), key_equel()) &#123; rep.insert_equal(f, l); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">hash_multimap</span>(<span class="title">InputIterator</span> <span class="title">f</span>, <span class="title">InputIterator</span> <span class="title">l</span>, <span class="title">size_type</span> <span class="title">n</span>)</span></span><br><span class="line"><span class="class">    :</span> rep(n, hasher(), key_equel()) &#123; rep.insert_equal(f, l); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">hash_multimap</span>(<span class="title">InputIterator</span> <span class="title">f</span>, <span class="title">InputIterator</span> <span class="title">l</span>, <span class="title">size_type</span> <span class="title">n</span>, <span class="title">const</span> <span class="title">hasher</span>&amp; <span class="title">hf</span>)</span></span><br><span class="line"><span class="class">    :</span> rep(n, hf, key_equel()) &#123; rep.insert_equal(f, l); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">hash_multimap</span>(<span class="title">InputIterator</span> <span class="title">f</span>, <span class="title">InputIterator</span> <span class="title">l</span>, <span class="title">size_type</span> <span class="title">n</span>, <span class="title">const</span> <span class="title">hasher</span>&amp; <span class="title">hf</span></span></span><br><span class="line"><span class="class">             <span class="title">const</span> <span class="title">key_equel</span>&amp; <span class="title">eql</span>)</span></span><br><span class="line"><span class="class">    :</span> rep(n, hf, eql) &#123; rep.insert_equal(f, l); &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> rep.size();&#125;</span><br><span class="line">    <span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> rep.max_size(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> rep.empty(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(hash_multimap&amp; hs)</span> </span>&#123; rep.swap(hs.rep); &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>== __STL_NULL_TMPL_ARGS (<span class="keyword">const</span> hash_multimap&amp;, <span class="keyword">const</span> hash_multimap&amp;);</span><br><span class="line"></span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> rep.begin(); &#125;</span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> rep.end(); &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">iterator <span class="title">insert</span><span class="params">(<span class="keyword">const</span> value_type&amp; obj)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> rep.insert_equal(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">void</span> <span class="title">insert</span>(<span class="title">InputIterator</span> <span class="title">f</span>, <span class="title">InputIterator</span> <span class="title">l</span>) &#123;</span> rep.insert_equal(f,l); &#125;</span><br><span class="line">    <span class="function">iterator <span class="title">insert_noresize</span><span class="params">(<span class="keyword">const</span> value_type&amp; obj)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">     <span class="keyword">return</span>  rep.insert_equal_noresize(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">iterator <span class="title">find</span><span class="params">(<span class="keyword">const</span> key_type&amp; key)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> rep.find(key); &#125;</span><br><span class="line">    <span class="function">const_iterator <span class="title">find</span><span class="params">(<span class="keyword">const</span> key_type&amp; key)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> rep.find(key);&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">size_type <span class="title">count</span><span class="params">(<span class="keyword">const</span> key_type&amp; key)</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> rep.count(key); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//相等的key的位置(是一个左闭右开的区间)，由迭代器给出</span></span><br><span class="line">    pair&lt;iterator, iterator&gt; equal_range(<span class="keyword">const</span> key_type&amp; key) <span class="keyword">const</span></span><br><span class="line">    &#123; <span class="keyword">return</span> rep.equal_range(key); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">size_type <span class="title">erase</span><span class="params">(<span class="keyword">const</span> key_type&amp; key)</span> </span>&#123; <span class="keyword">return</span> rep.erase(key); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">(iterator it)</span> </span>&#123; rep.erase(it); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">(iterator f, iterator l)</span> </span>&#123; rep.erase(f, l); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; rep.clear(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span>    <span class="title">resize</span><span class="params">(size_type hint)</span> </span>&#123; rep.resize(hint); &#125;</span><br><span class="line">    <span class="function">size_type <span class="title">bucket_count</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> rep.bucket_count(); &#125;</span><br><span class="line">    <span class="function">size_type <span class="title">elems_in_bucket</span><span class="params">(size_type n)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> rep.elems_in_bucket(n); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//class</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Value</span>, <span class="title">class</span> <span class="title">HashFcn</span>, <span class="title">class</span> <span class="title">EqualKey</span>, <span class="title">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">inline</span> <span class="title">bool</span> <span class="title">operator</span>==(<span class="title">const</span> <span class="title">hash_multimap</span>&lt;Value, HashFcn, EqualKey, Alloc&gt;&amp; <span class="title">hm1</span>,</span></span><br><span class="line"><span class="class">                           <span class="title">const</span> <span class="title">hash_multimap</span>&lt;Value, HashFcn, EqualKey, Alloc&gt;&amp; <span class="title">hm2</span>)</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">         <span class="keyword">return</span> has1.rep == has2.rep;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/C/" rel="tag"># C++</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/12/30/STL源码剖析 笔记2/" rel="next" title="STL 源码剖析 笔记2">
                <i class="fa fa-chevron-left"></i> STL 源码剖析 笔记2
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/01/11/STL源码剖析 笔记4/" rel="prev" title="STL 源码剖析 笔记4">
                STL 源码剖析 笔记4 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/header.jpg" alt="Hao Yu">
            
              <p class="site-author-name" itemprop="name">Hao Yu</p>
              <p class="site-description motion-element" itemprop="description">Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author</p>
          </div>
          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">281</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>
        	<audio controls="controls" loop="loop" preload="auto" src="/resource/xiaomeihao.mp3">
	        </audio>
	

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yuhao0102" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:yuh18@mails.tsinghua.edu.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#关联式容器"><span class="nav-number">1.</span> <span class="nav-text">关联式容器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#RB-tree概述"><span class="nav-number">1.1.</span> <span class="nav-text">RB-tree概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#RB-tree节点设计"><span class="nav-number">1.1.1.</span> <span class="nav-text">RB-tree节点设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RB-tree的迭代器"><span class="nav-number">1.1.2.</span> <span class="nav-text">RB-tree的迭代器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RB-tree数据结构"><span class="nav-number">1.1.3.</span> <span class="nav-text">RB-tree数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RB-tree的构造与内存管理"><span class="nav-number">1.1.4.</span> <span class="nav-text">RB-tree的构造与内存管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RB-tree的元素操作"><span class="nav-number">1.1.5.</span> <span class="nav-text">RB-tree的元素操作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#set"><span class="nav-number">1.2.</span> <span class="nav-text">set</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#multiset"><span class="nav-number">1.2.1.</span> <span class="nav-text">multiset</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#map概述"><span class="nav-number">1.3.</span> <span class="nav-text">map概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#map测试程序"><span class="nav-number">1.3.1.</span> <span class="nav-text">map测试程序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#hashtable"><span class="nav-number">1.4.</span> <span class="nav-text">hashtable</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#hashtable的数据结构"><span class="nav-number">1.4.1.</span> <span class="nav-text">hashtable的数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hashtable的构造与内存管理"><span class="nav-number">1.4.2.</span> <span class="nav-text">hashtable的构造与内存管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#删除元素"><span class="nav-number">1.4.3.</span> <span class="nav-text">删除元素</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#hash-set"><span class="nav-number">1.5.</span> <span class="nav-text">hash_set</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#hash-map"><span class="nav-number">1.6.</span> <span class="nav-text">hash_map</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#hash-multiset"><span class="nav-number">1.7.</span> <span class="nav-text">hash_multiset</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#hash-multimap"><span class="nav-number">1.8.</span> <span class="nav-text">hash_multimap</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>
  <div id="DvelopmentTarget">     
  </div>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart" aria-hidden="false"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>

  
</div>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_uv"> 
  本站访客数<span id="busuanzi_value_site_uv"></span>人次
</span>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  


  

  


  <script type="text/javascript" src="/js/src/love.js"></script>

</body>
</html>
