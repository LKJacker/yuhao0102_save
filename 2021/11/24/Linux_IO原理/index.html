<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zn-ch">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-center-simple.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Linux,">










<meta name="description" content="导言如今的网络应用早已从 CPU 密集型转向了 I/O 密集型，网络服务器大多是基于 C-S 模型，也即 客户端 - 服务端 模型，客户端需要和服务端进行大量的网络通信，这也决定了现代网络应用的性能瓶颈：I/O。 传统的 Linux 操作系统的标准 I/O 接口是基于数据拷贝操作的，即 I/O 操作会导致数据在操作系统内核地址空间的缓冲区和用户进程地址空间定义的缓冲区之间进行传输。设置缓冲区最大的">
<meta name="keywords" content="Linux">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux I&#x2F;O 原理和 Zero-copy 技术全面揭秘">
<meta property="og:url" content="http://yoursite.com/2021/11/24/Linux_IO原理/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="导言如今的网络应用早已从 CPU 密集型转向了 I/O 密集型，网络服务器大多是基于 C-S 模型，也即 客户端 - 服务端 模型，客户端需要和服务端进行大量的网络通信，这也决定了现代网络应用的性能瓶颈：I/O。 传统的 Linux 操作系统的标准 I/O 接口是基于数据拷贝操作的，即 I/O 操作会导致数据在操作系统内核地址空间的缓冲区和用户进程地址空间定义的缓冲区之间进行传输。设置缓冲区最大的">
<meta property="og:locale" content="zn-ch">
<meta property="og:image" content="http://yoursite.com/img/v2-339fc1c254df291ad7eb12008f38a4ef_720w.jpg">
<meta property="og:image" content="http://yoursite.com/img/v2-3743073fa3f83c50434b4c02b44dd769_720w.jpg">
<meta property="og:image" content="http://yoursite.com/img/v2-9a6c68bfcddbc196a091ee8ed7a509ad_720w.jpg">
<meta property="og:image" content="http://yoursite.com/img/v2-1fa456ede3dc9c8e6f950f5ca97713d7_720w.jpg">
<meta property="og:image" content="http://yoursite.com/img/v2-ada8c33007ca9e0fa0af6d1c3a061a03_720w.jpg">
<meta property="og:image" content="http://yoursite.com/img/v2-2d74d7110e0d7496e99a047768d9e626_720w.jpg">
<meta property="og:image" content="http://yoursite.com/img/v2-e5dcc4158c745179454a4add2794fbcb_720w.jpg">
<meta property="og:image" content="http://yoursite.com/img/v2-92f0fd4f60c9ce2b21ec6fd32c75d35d_720w.jpg">
<meta property="og:image" content="http://yoursite.com/img/v2-42fdd6deb027842d849b5ee7e2b92bba_720w.jpg">
<meta property="og:image" content="http://yoursite.com/img/v2-31c98b8d3f28acd6558aa06cec952709_720w.jpg">
<meta property="og:image" content="http://yoursite.com/img/v2-99408f5d660858c994024b55aaa26514_720w.jpg">
<meta property="og:image" content="http://yoursite.com/img/v2-cadabc5672c37a84a83ee837de545be5_720w.jpg">
<meta property="og:image" content="http://yoursite.com/img/v2-80018696eff24ce1e4b9e9b5e127416b_720w.jpg">
<meta property="og:image" content="http://yoursite.com/img/v2-17ce86192cb8e4d88282aaf9a7c844a3_720w.jpg">
<meta property="og:image" content="http://yoursite.com/img/v2-0d99113bd0d67e41d288b1f1034d4704_720w.jpg">
<meta property="og:image" content="http://yoursite.com/img/v2-e179bc30903178cec7e9324d628f33a5_720w.jpg">
<meta property="og:image" content="http://yoursite.com/img/v2-9f9f00d7645cf1aebe3843c2dcf44bc3_720w.jpg">
<meta property="og:image" content="http://yoursite.com/img/v2-89e764295fa13980880679ff5c5a63e3_720w.jpg">
<meta property="og:image" content="http://yoursite.com/img/v2-9b6aace364e295bd5a6271c146d477ab_720w.jpg">
<meta property="og:image" content="http://yoursite.com/img/78608ad5-89dd-319b-8c50-d7fa341ba9da.bmp">
<meta property="og:image" content="http://yoursite.com/img/7a411842-3615-3c89-aee0-3f5cfb36a044.bmp">
<meta property="og:updated_time" content="2022-10-01T04:43:18.415Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Linux I&#x2F;O 原理和 Zero-copy 技术全面揭秘">
<meta name="twitter:description" content="导言如今的网络应用早已从 CPU 密集型转向了 I/O 密集型，网络服务器大多是基于 C-S 模型，也即 客户端 - 服务端 模型，客户端需要和服务端进行大量的网络通信，这也决定了现代网络应用的性能瓶颈：I/O。 传统的 Linux 操作系统的标准 I/O 接口是基于数据拷贝操作的，即 I/O 操作会导致数据在操作系统内核地址空间的缓冲区和用户进程地址空间定义的缓冲区之间进行传输。设置缓冲区最大的">
<meta name="twitter:image" content="http://yoursite.com/img/v2-339fc1c254df291ad7eb12008f38a4ef_720w.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2021/11/24/Linux_IO原理/">





  <title>Linux I/O 原理和 Zero-copy 技术全面揭秘 | Hao Yu's blog</title>
  








 
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zn-ch">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hao Yu's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">The program monkey was eaten by the siege lion.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/resume.pdf" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-mybetterhalf">
          <a href="/mybetterhalf/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>
            
            mybetterhalf
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/11/24/Linux_IO原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Linux I/O 原理和 Zero-copy 技术全面揭秘</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-11-24T17:37:00+08:00">
                2021-11-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="导言"><a href="#导言" class="headerlink" title="导言"></a>导言</h1><p>如今的网络应用早已从 CPU 密集型转向了 I/O 密集型，网络服务器大多是基于 C-S 模型，也即 客户端 - 服务端 模型，客户端需要和服务端进行大量的网络通信，这也决定了现代网络应用的性能瓶颈：I/O。</p>
<p>传统的 Linux 操作系统的标准 I/O 接口是基于数据拷贝操作的，即 I/O 操作会导致数据在操作系统内核地址空间的缓冲区和用户进程地址空间定义的缓冲区之间进行传输。设置缓冲区最大的好处是可以减少磁盘 I/O 的操作，如果所请求的数据已经存放在操作系统的高速缓冲存储器中，那么就不需要再进行实际的物理磁盘 I/O 操作；然而传统的 Linux I/O 在数据传输过程中的数据拷贝操作深度依赖 CPU，也就是说 I/O 过程需要 CPU 去执行数据拷贝的操作，因此导致了极大的系统开销，限制了操作系统有效进行数据传输操作的能力。</p>
<p>I/O 是决定网络服务器性能瓶颈的关键，而传统的 Linux I/O 机制又会导致大量的数据拷贝操作，损耗性能，所以我们亟需一种新的技术来解决数据大量拷贝的问题，这个答案就是零拷贝(Zero-copy)。</p>
<h2 id="计算机存储器"><a href="#计算机存储器" class="headerlink" title="计算机存储器"></a>计算机存储器</h2><p>既然要分析 Linux I/O，就不能不了解计算机的各类存储器。</p>
<p>存储器是计算机的核心部件之一，在完全理想的状态下，存储器应该要同时具备以下三种特性：</p>
<ol>
<li>速度足够快：存储器的存取速度应当快于 CPU 执行一条指令，这样 CPU 的效率才不会受限于存储器</li>
<li>容量足够大：容量能够存储计算机所需的全部数据</li>
<li>价格足够便宜：价格低廉，所有类型的计算机都能配备</li>
</ol>
<p>但是现实往往是残酷的，我们目前的计算机技术无法同时满足上述的三个条件，于是现代计算机的存储器设计采用了一种分层次的结构：</p>
<p>从顶至底，现代计算机里的存储器类型分别有：寄存器、高速缓存、主存和磁盘，这些存储器的速度逐级递减而容量逐级递增 。存取速度最快的是寄存器，因为寄存器的制作材料和 CPU 是相同的，所以速度和 CPU 一样快，CPU 访问寄存器是没有时延的，然而因为价格昂贵，因此容量也极小，一般 32 位的 CPU 配备的寄存器容量是 32✖️32 Bit，64 位的 CPU 则是 64✖️64 Bit，不管是 32 位还是 64 位，寄存器容量都小于 1 KB，且寄存器也必须通过软件自行管理。</p>
<p>第二层是高速缓存，也即我们平时了解的 CPU 高速缓存 L1、L2、L3，一般 L1 是每个 CPU 独享，L3 是全部 CPU 共享，而 L2 则根据不同的架构设计会被设计成独享或者共享两种模式之一，比如 Intel 的多核芯片采用的是共享 L2 模式而 AMD 的多核芯片则采用的是独享 L2 模式。</p>
<p>第三层则是主存，也即主内存，通常称作随机访问存储器（Random Access Memory, RAM）。是与 CPU 直接交换数据的内部存储器。它可以随时读写（刷新时除外），而且速度很快，通常作为操作系统或其他正在运行中的程序的临时资料存储介质。</p>
<p>最后则是磁盘，磁盘和主存相比，每个二进制位的成本低了两个数量级，因此容量比之会大得多，动辄上 GB、TB，而问题是访问速度则比主存慢了大概三个数量级。机械硬盘速度慢主要是因为机械臂需要不断在金属盘片之间移动，等待磁盘扇区旋转至磁头之下，然后才能进行读写操作，因此效率很低。</p>
<p>主内存是操作系统进行 I/O 操作的重中之重，绝大部分的工作都是在用户进程和内核的内存缓冲区里完成的，因此我们接下来需要提前学习一些主存的相关原理。</p>
<h2 id="物理内存"><a href="#物理内存" class="headerlink" title="物理内存"></a>物理内存</h2><p>我们平时一直提及的物理内存就是上文中对应的第三种计算机存储器，RAM 主存，它在计算机中以内存条的形式存在，嵌在主板的内存槽上，用来加载各式各样的程序与数据以供 CPU 直接运行和使用。</p>
<h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><p>在计算机领域有一句如同摩西十诫般神圣的哲言：”计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决”，从内存管理、网络模型、并发调度甚至是硬件架构，都能看到这句哲言在闪烁着光芒，而虚拟内存则是这一哲言的完美实践之一。</p>
<p>虚拟内存是现代计算机中的一个非常重要的存储器抽象，主要是用来解决应用程序日益增长的内存使用需求：现代物理内存的容量增长已经非常快速了，然而还是跟不上应用程序对主存需求的增长速度，对于应用程序来说内存还是不够用，因此便需要一种方法来解决这两者之间的容量差矛盾。</p>
<p>计算机对多程序内存访问的管理经历了 静态重定位 —&gt; 动态重定位 —&gt; 交换(swapping)技术 —&gt; 虚拟内存，最原始的多程序内存访问是直接访问绝对内存地址，这种方式几乎是完全不可用的方案，因为如果每一个程序都直接访问物理内存地址的话，比如两个程序并发执行以下指令的时候：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mov cx, 2</span><br><span class="line">mov bx, 1000H</span><br><span class="line">mov ds, bx</span><br><span class="line">mov [0], cx</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">mov ax, [0]</span><br><span class="line">add ax, ax</span><br></pre></td></tr></table></figure></p>
<p>这一段汇编表示在地址 1000:0 处存入数值 2，然后在后面的逻辑中把该地址的值取出来乘以 2，最终存入 ax 寄存器的值就是 4，如果第二个程序存入 cx 寄存器里的值是 3，那么并发执行的时候，第一个程序最终从 ax 寄存器里得到的值就可能是 6，这就完全错误了，得到脏数据还顶多算程序结果错误，要是其他程序往特定的地址里写入一些危险的指令而被另一个程序取出来执行，还可能会导致整个系统的崩溃。所以，为了确保进程间互不干扰，每一个用户进程都需要实时知晓当前其他进程在使用哪些内存地址，这对于写程序的人来说无疑是一场噩梦。</p>
<p>因此，操作绝对内存地址是完全不可行的方案，那就只能用操作相对内存地址，我们知道每个进程都会有自己的进程地址，从 0 开始，可以通过相对地址来访问内存，但是这同样有问题，还是前面类似的问题，比如有两个大小为 16KB 的程序 A 和 B，现在它们都被加载进了内存，内存地址段分别是 0 ~ 16384，16384 ~ 32768。A 的第一条指令是 jmp 1024，而在地址 1024 处是一条<code>mov</code>指令，下一条指令是 add，基于前面的<code>mov</code>指令做加法运算，与此同时，B 的第一条指令是 jmp 1028，本来在 B 的相对地址 1028 处应该也是一条<code>mov</code>去操作自己的内存地址上的值，但是由于这两个程序共享了段寄存器，因此虽然他们使用了各自的相对地址，但是依然操作的还是绝对内存地址，于是 B 就会跳去执行 add 指令，这时候就会因为非法的内存操作而 crash。</p>
<p>有一种静态重定位的技术可以解决这个问题，它的工作原理非常简单粗暴：当 B 程序被加载到地址 16384 处之后，把 B 的所有相对内存地址都加上 16384，这样的话当 B 执行 jmp 1028 之时，其实执行的是<code>jmp 1028+16384</code>，就可以跳转到正确的内存地址处去执行正确的指令了，但是这种技术并不通用，而且还会对程序装载进内存的性能有影响。</p>
<p>再往后，就发展出来了存储器抽象：地址空间，就好像进程是 CPU 的抽象，地址空间则是存储器的抽象，每个进程都会分配独享的地址空间，但是独享的地址空间又带来了新的问题：如何实现不同进程的相同相对地址指向不同的物理地址？最开始是使用动态重定位技术来实现，这是用一种相对简单的地址空间到物理内存的映射方法。基本原理就是为每一个 CPU 配备两个特殊的硬件寄存器：基址寄存器和界限寄存器，用来动态保存每一个程序的起始物理内存地址和长度，比如前文中的 A，B 两个程序，当 A 运行时基址寄存器和界限寄存器就会分别存入 0 和 16384，而当 B 运行时则两个寄存器又会分别存入 16384 和 32768。然后每次访问指定的内存地址时，CPU 会在把地址发往内存总线之前自动把基址寄存器里的值加到该内存地址上，得到一个真正的物理内存地址，同时还会根据界限寄存器里的值检查该地址是否溢出，若是，则产生错误中止程序，动态重定位技术解决了静态重定位技术造成的程序装载速度慢的问题，但是也有新问题：每次访问内存都需要进行加法和比较运算，比较运算本身可以很快，但是加法运算由于进位传递时间的问题，除非使用特殊的电路，否则会比较慢。</p>
<p>然后就是 交换（swapping）技术，这种技术简单来说就是动态地把程序在内存和磁盘之间进行交换保存，要运行一个进程的时候就把程序的代码段和数据段调入内存，然后再把程序封存，存入磁盘，如此反复。为什么要这么麻烦？因为前面那两种重定位技术的前提条件是计算机内存足够大，能够把所有要运行的进程地址空间都加载进主存，才能够并发运行这些进程，但是现实往往不是如此，内存的大小总是有限的，所有就需要另一类方法来处理内存超载的情况，第一种便是简单的交换技术：<br><img src="/img/v2-339fc1c254df291ad7eb12008f38a4ef_720w.jpg" alt></p>
<p>先把进程 A 换入内存，然后启动进程 B 和 C，也换入内存，接着 A 被从内存交换到磁盘，然后又有新的进程 D 调入内存，用了 A 退出之后空出来的内存空间，最后 A 又被重新换入内存，由于内存布局已经发生了变化，所以 A 在换入内存之时会通过软件或者在运行期间通过硬件（基址寄存器和界限寄存器）对其内存地址进行重定位，多数情况下都是通过硬件。</p>
<p>另一种处理内存超载的技术就是虚拟内存技术了，它比交换（swapping）技术更复杂而又更高效，是目前最新应用最广泛的存储器抽象技术：</p>
<p>虚拟内存的核心原理是：为每个程序设置一段”连续”的虚拟地址空间，把这个地址空间分割成多个具有连续地址范围的页 (page)，并把这些页和物理内存做映射，在程序运行期间动态映射到物理内存。当程序引用到一段在物理内存的地址空间时，由硬件立刻执行必要的映射；而当程序引用到一段不在物理内存中的地址空间时，由操作系统负责将缺失的部分装入物理内存并重新执行失败的指令：<br><img src="/img/v2-3743073fa3f83c50434b4c02b44dd769_720w.jpg" alt></p>
<p>虚拟地址空间按照固定大小划分成被称为页（page）的若干单元，物理内存中对应的则是页框（page frame）。这两者一般来说是一样的大小，如上图中的是 4KB，不过实际上计算机系统中一般是 512 字节到 1 GB，这就是虚拟内存的分页技术。因为是虚拟内存空间，每个进程分配的大小是 4GB (32 位架构)，而实际上当然不可能给所有在运行中的进程都分配 4GB 的物理内存，所以虚拟内存技术还需要利用到前面介绍的交换（swapping）技术，在进程运行期间只分配映射当前使用到的内存，暂时不使用的数据则写回磁盘作为副本保存，需要用的时候再读入内存，动态地在磁盘和内存之间交换数据。</p>
<p>其实虚拟内存技术从某种角度来看的话，很像是糅合了基址寄存器和界限寄存器之后的新技术。它使得整个进程的地址空间可以通过较小的单元映射到物理内存，而不需要为程序的代码和数据地址进行重定位。</p>
<p>进程在运行期间产生的内存地址都是虚拟地址，如果计算机没有引入虚拟内存这种存储器抽象技术的话，则 CPU 会把这些地址直接发送到内存地址总线上，直接访问和虚拟地址相同值的物理地址；如果使用虚拟内存技术的话，CPU 则是把这些虚拟地址通过地址总线送到内存管理单元（Memory Management Unit，MMU），MMU 将虚拟地址映射为物理地址之后再通过内存总线去访问物理内存：<br><img src="/img/v2-9a6c68bfcddbc196a091ee8ed7a509ad_720w.jpg" alt></p>
<p>虚拟地址（比如 16 位地址 8196=0010 000000000100）分为两部分：虚拟页号（高位部分）和偏移量（低位部分），虚拟地址转换成物理地址是通过页表（page table）来实现的，页表由页表项构成，页表项中保存了页框号、修改位、访问位、保护位和 “在/不在” 位等信息，从数学角度来说页表就是一个函数，入参是虚拟页号，输出是物理页框号，得到物理页框号之后复制到寄存器的高三位中，最后直接把 12 位的偏移量复制到寄存器的末 12 位构成 15 位的物理地址，即可以把该寄存器的存储的物理内存地址发送到内存总线：<br><img src="/img/v2-1fa456ede3dc9c8e6f950f5ca97713d7_720w.jpg" alt></p>
<p>在 MMU 进行地址转换时，如果页表项的 “在/不在” 位是 0，则表示该页面并没有映射到真实的物理页框，则会引发一个缺页中断，CPU 陷入操作系统内核，接着操作系统就会通过页面置换算法选择一个页面将其换出 (swap)，以便为即将调入的新页面腾出位置，如果要换出的页面的页表项里的修改位已经被设置过，也就是被更新过，则这是一个脏页 (dirty page)，需要写回磁盘更新改页面在磁盘上的副本，如果该页面是”干净”的，也就是没有被修改过，则直接用调入的新页面覆盖掉被换出的旧页面即可。</p>
<p>最后，还需要了解的一个概念是转换检测缓冲器（Translation Lookaside Buffer，TLB），也叫快表，是用来加速虚拟地址映射的，因为虚拟内存的分页机制，页表一般是保存内存中的一块固定的存储区，导致进程通过 MMU 访问内存比直接访问内存多了一次内存访问，性能至少下降一半，因此需要引入加速机制，即 TLB 快表，TLB 可以简单地理解成页表的高速缓存，保存了最高频被访问的页表项，由于一般是硬件实现的，因此速度极快，MMU 收到虚拟地址时一般会先通过硬件 TLB 查询对应的页表号，若命中且该页表项的访问操作合法，则直接从 TLB 取出对应的物理页框号返回，若不命中则穿透到内存页表里查询，并且会用这个从内存页表里查询到最新页表项替换到现有 TLB 里的其中一个，以备下次缓存命中。</p>
<p>至此，我们介绍完了包含虚拟内存在内的多项计算机存储器抽象技术，虚拟内存的其他内容比如针对大内存的多级页表、倒排页表，以及处理缺页中断的页面置换算法等等，以后有机会再单独写一篇文章介绍，或者各位读者也可以先行去查阅相关资料了解，这里就不再深入了。</p>
<h2 id="用户态和内核态"><a href="#用户态和内核态" class="headerlink" title="用户态和内核态"></a>用户态和内核态</h2><p>一般来说，我们在编写程序操作 Linux I/O 之时十有八九是在用户空间和内核空间之间传输数据，因此有必要先了解一下 Linux 的用户态和内核态的概念。</p>
<p>首先是用户态和内核态：<br><img src="/img/v2-ada8c33007ca9e0fa0af6d1c3a061a03_720w.jpg" alt></p>
<p>从宏观上来看，Linux 操作系统的体系架构分为用户态和内核态（或者用户空间和内核）。内核从本质上看是一种软件 —— 控制计算机的硬件资源，并提供上层应用程序 (进程) 运行的环境。用户态即上层应用程序 (进程) 的运行空间，应用程序 (进程) 的执行必须依托于内核提供的资源，这其中包括但不限于 CPU 资源、存储资源、I/O 资源等等。</p>
<p>现代操作系统都是采用虚拟存储器，那么对 32 位操作系统而言，它的寻址空间（虚拟存储空间）为 2^32 B = 4G。操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核（kernel），保证内核的安全，操心系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。针对 Linux 操作系统而言，将最高的 1G 字节（从虚拟地址 0xC0000000 到 0xFFFFFFFF），供内核使用，称为内核空间，而将较低的 3G 字节（从虚拟地址 0x00000000 到 0xBFFFFFFF），供各个进程使用，称为用户空间。</p>
<p>因为操作系统的资源是有限的，如果访问资源的操作过多，必然会消耗过多的系统资源，而且如果不对这些操作加以区分，很可能造成资源访问的冲突。所以，为了减少有限资源的访问和使用冲突，Unix/Linux 的设计哲学之一就是：对不同的操作赋予不同的执行等级，就是所谓特权的概念。简单说就是有多大能力做多大的事，与系统相关的一些特别关键的操作必须由最高特权的程序来完成。Intel 的 x86 架构的 CPU 提供了 0 到 3 四个特权级，数字越小，特权越高，Linux 操作系统中主要采用了 0 和 3 两个特权级，分别对应的就是内核态和用户态。运行于用户态的进程可以执行的操作和访问的资源都会受到极大的限制，而运行在内核态的进程则可以执行任何操作并且在资源的使用上没有限制。很多程序开始时运行于用户态，但在执行的过程中，一些操作需要在内核权限下才能执行，这就涉及到一个从用户态切换到内核态的过程。比如 C 函数库中的内存分配函数<code>malloc()</code>，它具体是使用<code>sbrk()</code>系统调用来分配内存，当<code>malloc</code>调用<code>sbrk()</code>的时候就涉及一次从用户态到内核态的切换，类似的函数还有<code>printf()</code>，调用的是<code>wirte()</code>系统调用来输出字符串，等等。</p>
<p>用户进程在系统中运行时，大部分时间是处在用户态空间里的，在其需要操作系统帮助完成一些用户态没有特权和能力完成的操作时就需要切换到内核态。那么用户进程如何切换到内核态去使用那些内核资源呢？答案是：1) 系统调用（trap），2) 异常（exception）和 3) 中断（interrupt）。</p>
<ul>
<li>系统调用：用户进程主动发起的操作。用户态进程发起系统调用主动要求切换到内核态，陷入内核之后，由操作系统来操作系统资源，完成之后再返回到进程。</li>
<li>异常：被动的操作，且用户进程无法预测其发生的时机。当用户进程在运行期间发生了异常（比如某条指令出了问题），这时会触发由当前运行进程切换到处理此异常的内核相关进程中，也即是切换到了内核态。异常包括程序运算引起的各种错误如除 0、缓冲区溢出、缺页等。</li>
<li>中断：当外围设备完成用户请求的操作后，会向 CPU 发出相应的中断信号，这时 CPU 会暂停执行下一条即将要执行的指令而转到与中断信号对应的处理程序去执行，如果前面执行的指令是用户态下的程序，那么转换的过程自然就会是从用户态到内核态的切换。中断包括 I/O 中断、外部信号中断、各种定时器引起的时钟中断等。中断和异常类似，都是通过中断向量表来找到相应的处理程序进行处理。区别在于，中断来自处理器外部，不是由任何一条专门的指令造成，而异常是执行当前指令的结果。</li>
</ul>
<p>通过上面的分析，我们可以得出 Linux 的内部层级可分为三大部分：</p>
<ul>
<li>用户空间；</li>
<li>内核空间；</li>
<li>硬件。</li>
</ul>
<h1 id="Linux-I-O"><a href="#Linux-I-O" class="headerlink" title="Linux I/O"></a>Linux I/O</h1><h2 id="I-O-缓冲区"><a href="#I-O-缓冲区" class="headerlink" title="I/O 缓冲区"></a>I/O 缓冲区</h2><p><img src="/img/v2-2d74d7110e0d7496e99a047768d9e626_720w.jpg" alt><br>在 Linux 中，当程序调用各类文件操作函数后，用户数据（User Data）到达磁盘（Disk）的流程如上图所示。</p>
<p>图中描述了 Linux 中文件操作函数的层级关系和内存缓存层的存在位置，中间的黑色实线是用户态和内核态的分界线。</p>
<p><code>read(2)/write(2)</code>是 Linux 系统中最基本的 I/O 读写系统调用，我们开发操作 I/O 的程序时必定会接触到它们，而在这两个系统调用和真实的磁盘读写之间存在一层称为 Kernel buffer cache 的缓冲区缓存。在 Linux 中 I/O 缓存其实可以细分为两个：Page Cache 和 Buffer Cache，这两个其实是一体两面，共同组成了 Linux 的内核缓冲区（Kernel Buffer Cache）：</p>
<ul>
<li>读磁盘：内核会先检查 Page Cache 里是不是已经缓存了这个数据，若是，直接从这个内存缓冲区里读取返回，若否，则穿透到磁盘去读取，然后再缓存在 Page Cache 里，以备下次缓存命中；</li>
<li>写磁盘：内核直接把数据写入 Page Cache，并把对应的页标记为 dirty，添加到 dirty list 里，然后就直接返回，内核会定期把 dirty list 的页缓存 flush 到磁盘，保证页缓存和磁盘的最终一致性。</li>
</ul>
<p>Page Cache 会通过页面置换算法如 LRU 定期淘汰旧的页面，加载新的页面。可以看出，所谓 I/O 缓冲区缓存就是在内核和磁盘、网卡等外设之间的一层缓冲区，用来提升读写性能的。</p>
<p>在 Linux 还不支持虚拟内存技术之前，还没有页的概念，因此 Buffer Cache 是基于操作系统读写磁盘的最小单位 — 块（block）来进行的，所有的磁盘块操作都是通过 Buffer Cache 来加速，Linux 引入虚拟内存的机制来管理内存后，页成为虚拟内存管理的最小单位，因此也引入了 Page Cache 来缓存 Linux 文件内容，主要用来作为文件系统上的文件数据的缓存，提升读写性能，常见的是针对文件的<code>read()/write()</code>操作，另外也包括了通过<code>mmap()</code>映射之后的块设备，也就是说，事实上 Page Cache 负责了大部分的块设备文件的缓存工作。而 Buffer Cache 用来在系统对块设备进行读写的时候，对块进行数据缓存的系统来使用，实际上负责所有对磁盘的 I/O 访问：<br><img src="/img/v2-e5dcc4158c745179454a4add2794fbcb_720w.jpg" alt></p>
<p>因为 Buffer Cache 是对粒度更细的设备块的缓存，而 Page Cache 是基于虚拟内存的页单元缓存，因此还是会基于 Buffer Cache，也就是说如果是缓存文件内容数据就会在内存里缓存两份相同的数据，这就会导致同一份文件保存了两份，冗余且低效。另外一个问题是，调用 write 后，有效数据是在 Buffer Cache 中，而非 Page Cache 中。这就导致 mmap 访问的文件数据可能存在不一致问题。为了规避这个问题，所有基于磁盘文件系统的 write，都需要调用 update_vm_cache() 函数，该操作会把调用 write 之后的 Buffer Cache 更新到 Page Cache 去。由于有这些设计上的弊端，因此在 Linux 2.4 版本之后，kernel 就将两者进行了统一，Buffer Cache 不再以独立的形式存在，而是以融合的方式存在于 Page Cache 中：<br><img src="/img/v2-92f0fd4f60c9ce2b21ec6fd32c75d35d_720w.jpg" alt></p>
<p>融合之后就可以统一操作 Page Cache 和 Buffer Cache：处理文件 I/O 缓存交给 Page Cache，而当底层 RAW device 刷新数据时以 Buffer Cache 的块单位来实际处理。</p>
<h2 id="I-O-模式"><a href="#I-O-模式" class="headerlink" title="I/O 模式"></a>I/O 模式</h2><p>在 Linux 或者其他 Unix-like 操作系统里，I/O 模式一般有三种：</p>
<ul>
<li>程序控制 I/O</li>
<li>中断驱动 I/O</li>
<li>DMA I/O</li>
</ul>
<p>下面我分别详细地讲解一下这三种 I/O 模式。</p>
<h3 id="程序控制-I-O"><a href="#程序控制-I-O" class="headerlink" title="程序控制 I/O"></a>程序控制 I/O</h3><p>这是最简单的一种 I/O 模式，也叫忙等待或者轮询：用户通过发起一个系统调用，陷入内核态，内核将系统调用翻译成一个对应设备驱动程序的过程调用，接着设备驱动程序会启动 I/O 不断循环去检查该设备，看看是否已经就绪，一般通过返回码来表示，I/O 结束之后，设备驱动程序会把数据送到指定的地方并返回，切回用户态。</p>
<p>比如发起系统调用<code>read()</code>：<br><img src="/img/v2-42fdd6deb027842d849b5ee7e2b92bba_720w.jpg" alt></p>
<h3 id="中断驱动-I-O"><a href="#中断驱动-I-O" class="headerlink" title="中断驱动 I/O"></a>中断驱动 I/O</h3><p>第二种 I/O 模式是利用中断来实现的：<br><img src="/img/v2-31c98b8d3f28acd6558aa06cec952709_720w.jpg" alt></p>
<p>流程如下：</p>
<ol>
<li>用户进程发起一个<code>read()</code>系统调用读取磁盘文件，陷入内核态并由其所在的 CPU 通过设备驱动程序向设备寄存器写入一个通知信号，告知设备控制器 (我们这里是磁盘控制器)要读取数据；</li>
<li>磁盘控制器启动磁盘读取的过程，把数据从磁盘拷贝到磁盘控制器缓冲区里；</li>
<li>完成拷贝之后磁盘控制器会通过总线发送一个中断信号到中断控制器，如果此时中断控制器手头还有正在处理的中断或者有一个和该中断信号同时到达的更高优先级的中断，则这个中断信号将被忽略，而磁盘控制器会在后面持续发送中断信号直至中断控制器受理；</li>
<li>中断控制器收到磁盘控制器的中断信号之后会通过地址总线存入一个磁盘设备的编号，表示这次中断需要关注的设备是磁盘；</li>
<li>中断控制器向 CPU 置起一个磁盘中断信号；</li>
<li>CPU 收到中断信号之后停止当前的工作，把当前的 PC/PSW 等寄存器压入堆栈保存现场，然后从地址总线取出设备编号，通过编号找到中断向量所包含的中断服务的入口地址，压入 PC 寄存器，开始运行磁盘中断服务，把数据从磁盘控制器的缓冲区拷贝到主存里的内核缓冲区；</li>
<li>最后 CPU 再把数据从内核缓冲区拷贝到用户缓冲区，完成读取操作，<code>read()</code>返回，切换回用户态。</li>
</ol>
<h3 id="DMA-I-O"><a href="#DMA-I-O" class="headerlink" title="DMA I/O"></a>DMA I/O</h3><p>并发系统的性能高低究其根本，是取决于如何对 CPU 资源的高效调度和使用，而回头看前面的中断驱动 I/O 模式的流程，可以发现第 6、7 步的数据拷贝工作都是由 CPU 亲自完成的，也就是在这两次数据拷贝阶段中 CPU 是完全被占用而不能处理其他工作的，那么这里明显是有优化空间的；第 7 步的数据拷贝是从内核缓冲区到用户缓冲区，都是在主存里，所以这一步只能由 CPU 亲自完成，但是第 6 步的数据拷贝，是从磁盘控制器的缓冲区到主存，是两个设备之间的数据传输，这一步并非一定要 CPU 来完成，可以借助 DMA 来完成，减轻 CPU 的负担。</p>
<p>DMA 全称是 Direct Memory Access，也即直接存储器存取，是一种用来提供在外设和存储器之间或者存储器和存储器之间的高速数据传输。整个过程无须 CPU 参与，数据直接通过 DMA 控制器进行快速地移动拷贝，节省 CPU 的资源去做其他工作。</p>
<p>目前，大部分的计算机都配备了 DMA 控制器，而 DMA 技术也支持大部分的外设和存储器。借助于 DMA 机制，计算机的 I/O 过程就能更加高效：<br><img src="/img/v2-99408f5d660858c994024b55aaa26514_720w.jpg" alt></p>
<p>DMA 控制器内部包含若干个可以被 CPU 读写的寄存器：一个主存地址寄存器 MAR（存放要交换数据的主存地址）、一个外设地址寄存器 ADR（存放 I/O 设备的设备码，或者是设备信息存储区的寻址信息）、一个字节数寄存器 WC（对传送数据的总字数进行统计）、和一个或多个控制寄存器。</p>
<ol>
<li>用户进程发起一个<code>read()</code>系统调用读取磁盘文件，陷入内核态并由其所在的 CPU 通过设置 DMA 控制器的寄存器对它进行编程：把内核缓冲区和磁盘文件的地址分别写入 MAR 和 ADR 寄存器，然后把期望读取的字节数写入 WC 寄存器，启动 DMA 控制器；</li>
<li>DMA 控制器根据 ADR 寄存器里的信息知道这次 I/O 需要读取的外设是磁盘的某个地址，便向磁盘控制器发出一个命令，通知它从磁盘读取数据到其内部的缓冲区里；</li>
<li>磁盘控制器启动磁盘读取的过程，把数据从磁盘拷贝到磁盘控制器缓冲区里，并对缓冲区内数据的校验和进行检验，如果数据是有效的，那么 DMA 就可以开始了；</li>
<li>DMA 控制器通过总线向磁盘控制器发出一个读请求信号从而发起 DMA 传输，这个信号和前面的中断驱动 I/O 小节里 CPU 发给磁盘控制器的读请求是一样的，它并不知道或者并不关心这个读请求是来自 CPU 还是 DMA 控制器；</li>
<li>紧接着 DMA 控制器将引导磁盘控制器将数据传输到 MAR 寄存器里的地址，也就是内核缓冲区；</li>
<li>数据传输完成之后，返回一个 ack 给 DMA 控制器，WC 寄存器里的值会减去相应的数据长度，如果 WC 还不为 0，则重复第 4 步到第 6 步，一直到 WC 里的字节数等于 0；</li>
<li>收到 ack 信号的 DMA 控制器会通过总线发送一个中断信号到中断控制器，如果此时中断控制器手头还有正在处理的中断或者有一个和该中断信号同时到达的更高优先级的中断，则这个中断信号将被忽略，而 DMA 控制器会在后面持续发送中断信号直至中断控制器受理；</li>
<li>中断控制器收到磁盘控制器的中断信号之后会通过地址总线存入一个主存设备的编号，表示这次中断需要关注的设备是主存；</li>
<li>中断控制器向 CPU 置起一个 DMA 中断的信号；</li>
<li>CPU 收到中断信号之后停止当前的工作，把当前的 PC/PSW 等寄存器压入堆栈保存现场，然后从地址总线取出设备编号，通过编号找到中断向量所包含的中断服务的入口地址，压入 PC 寄存器，开始运行 DMA 中断服务，把数据从内核缓冲区拷贝到用户缓冲区，完成读取操作，read() 返回，切换回用户态。</li>
</ol>
<h2 id="传统-I-O-读写模式"><a href="#传统-I-O-读写模式" class="headerlink" title="传统 I/O 读写模式"></a>传统 I/O 读写模式</h2><p>Linux 中传统的 I/O 读写是通过<code>read()/write()</code>系统调用完成的，<code>read()</code>把数据从存储器 (磁盘、网卡等) 读取到用户缓冲区，<code>write()</code>则是把数据从用户缓冲区写出到存储器：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> read(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count);</span><br><span class="line"><span class="keyword">ssize_t</span> write(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count);</span><br></pre></td></tr></table></figure></p>
<p>一次完整的读磁盘文件然后写出到网卡的底层传输过程如下：<br><img src="/img/v2-cadabc5672c37a84a83ee837de545be5_720w.jpg" alt></p>
<p>可以清楚看到这里一共触发了 4 次用户态和内核态的上下文切换，分别是<code>read()/write()</code>调用和返回时的切换，2 次 DMA 拷贝，2 次 CPU 拷贝，加起来一共 4 次拷贝操作。</p>
<p>通过引入 DMA，我们已经把 Linux 的 I/O 过程中的 CPU 拷贝次数从 4 次减少到了 2 次，但是 CPU 拷贝依然是代价很大的操作，对系统性能的影响还是很大，特别是那些频繁 I/O 的场景，更是会因为 CPU 拷贝而损失掉很多性能，我们需要进一步优化，降低、甚至是完全避免 CPU 拷贝。</p>
<h2 id="零拷贝-Zero-copy"><a href="#零拷贝-Zero-copy" class="headerlink" title="零拷贝 (Zero-copy)"></a>零拷贝 (Zero-copy)</h2><h3 id="Zero-copy-是什么？"><a href="#Zero-copy-是什么？" class="headerlink" title="Zero-copy 是什么？"></a>Zero-copy 是什么？</h3><p>Wikipedia 的解释如下：</p>
<blockquote>
<p>“Zero-copy” describes computer operations in which the CPU does not perform the task of copying data from one memory area to another. This is frequently used to save CPU cycles and memory bandwidth when transmitting a file over a network.</p>
</blockquote>
<p>零拷贝技术是指计算机执行操作时，CPU不需要先将数据从某处内存复制到另一个特定区域。这种技术通常用于通过网络传输文件时节省 CPU 周期和内存带宽。</p>
<h3 id="Zero-copy-能做什么？"><a href="#Zero-copy-能做什么？" class="headerlink" title="Zero-copy 能做什么？"></a>Zero-copy 能做什么？</h3><ul>
<li>减少甚至完全避免操作系统内核和用户应用程序地址空间这两者之间进行数据拷贝操作，从而减少用户态 — 内核态上下文切换带来的系统开销。</li>
<li>减少甚至完全避免操作系统内核缓冲区之间进行数据拷贝操作。</li>
<li>帮助用户进程绕开操作系统内核空间直接访问硬件存储接口操作数据。</li>
<li>利用 DMA 而非 CPU 来完成硬件接口和内核缓冲区之间的数据拷贝，从而解放 CPU，使之能去执行其他的任务，提升系统性能。</li>
</ul>
<h3 id="Zero-copy-的实现方式有哪些？"><a href="#Zero-copy-的实现方式有哪些？" class="headerlink" title="Zero-copy 的实现方式有哪些？"></a>Zero-copy 的实现方式有哪些？</h3><p>从 zero-copy 这个概念被提出以来，相关的实现技术便犹如雨后春笋，层出不穷。但是截至目前为止，并没有任何一种 zero-copy 技术能满足所有的场景需求，还是计算机领域那句无比经典的名言：”There is no silver bullet”!</p>
<p>而在 Linux 平台上，同样也有很多的 zero-copy 技术，新旧各不同，可能存在于不同的内核版本里，很多技术可能有了很大的改进或者被更新的实现方式所替代，这些不同的实现技术按照其核心思想可以归纳成大致的以下三类：</p>
<ul>
<li>减少甚至避免用户空间和内核空间之间的数据拷贝：在一些场景下，用户进程在数据传输过程中并不需要对数据进行访问和处理，那么数据在 Linux 的 Page Cache 和用户进程的缓冲区之间的传输就完全可以避免，让数据拷贝完全在内核里进行，甚至可以通过更巧妙的方式避免在内核里的数据拷贝。这一类实现一般是通过增加新的系统调用来完成的，比如 Linux 中的<code>mmap()</code>，<code>sendfile()</code>以及<code>splice()</code>等。</li>
<li>绕过内核的直接 I/O：允许在用户态进程绕过内核直接和硬件进行数据传输，内核在传输过程中只负责一些管理和辅助的工作。这种方式其实和第一种有点类似，也是试图避免用户空间和内核空间之间的数据传输，只是第一种方式是把数据传输过程放在内核态完成，而这种方式则是直接绕过内核和硬件通信，效果类似但原理完全不同。</li>
<li>内核缓冲区和用户缓冲区之间的传输优化：这种方式侧重于在用户进程的缓冲区和操作系统的页缓存之间的 CPU 拷贝的优化。这种方法延续了以往那种传统的通信方式，但更灵活。</li>
</ul>
<h2 id="减少甚至避免用户空间和内核空间之间的数据拷贝"><a href="#减少甚至避免用户空间和内核空间之间的数据拷贝" class="headerlink" title="减少甚至避免用户空间和内核空间之间的数据拷贝"></a>减少甚至避免用户空间和内核空间之间的数据拷贝</h2><h3 id="mmap"><a href="#mmap" class="headerlink" title="mmap()"></a>mmap()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mmap</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> length, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags, <span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">munmap</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> length)</span></span>;</span><br></pre></td></tr></table></figure>
<p>一种简单的实现方案是在一次读写过程中用 Linux 的另一个系统调用<code>mmap()</code>替换原先的<code>read()</code>，<code>mmap()</code>也即是内存映射（memory map）：把用户进程空间的一段内存缓冲区（user buffer）映射到文件所在的内核缓冲区（kernel buffer）上。<br><img src="/img/v2-80018696eff24ce1e4b9e9b5e127416b_720w.jpg" alt></p>
<p>利用<code>mmap()</code>替换<code>read()</code>，配合<code>write()</code> 调用的整个流程如下：</p>
<ul>
<li>用户进程调用<code>mmap()</code>，从用户态陷入内核态，将内核缓冲区映射到用户缓存区；</li>
<li>DMA 控制器将数据从硬盘拷贝到内核缓冲区；</li>
<li><code>mmap()</code>返回，上下文从内核态切换回用户态；</li>
<li>用户进程调用<code>write()</code>，尝试把文件数据写到内核里的套接字缓冲区，再次陷入内核态；</li>
<li>CPU 将内核缓冲区中的数据拷贝到的套接字缓冲区；</li>
<li>DMA 控制器将数据从套接字缓冲区拷贝到网卡完成数据传输；</li>
<li><code>write()</code>返回，上下文从内核态切换回用户态。</li>
</ul>
<p>通过这种方式，有两个优点：一是节省内存空间，因为用户进程上的这一段内存是虚拟的，并不真正占据物理内存，只是映射到文件所在的内核缓冲区上，因此可以节省一半的内存占用；二是省去了一次 CPU 拷贝，对比传统的 Linux I/O 读写，数据不需要再经过用户进程进行转发了，而是直接在内核里就完成了拷贝。所以使用<code>mmap()</code>之后的拷贝次数是 2 次 DMA 拷贝，1 次 CPU 拷贝，加起来一共 3 次拷贝操作，比传统的 I/O 方式节省了一次 CPU 拷贝以及一半的内存，不过因为<code>mmap()</code>也是一个系统调用，因此用户态和内核态的切换还是 4 次。</p>
<p><code>mmap()</code>因为既节省 CPU 拷贝次数又节省内存，所以比较适合大文件传输的场景。虽然<code>mmap()</code>完全是符合 POSIX 标准的，但是它也不是完美的，因为它并不总是能达到理想的数据传输性能。首先是因为数据数据传输过程中依然需要一次 CPU 拷贝，其次是内存映射技术是一个开销很大的虚拟存储操作：这种操作需要修改页表以及用内核缓冲区里的文件数据汰换掉当前 TLB 里的缓存以维持虚拟内存映射的一致性。但是，因为内存映射通常针对的是相对较大的数据区域，所以对于相同大小的数据来说，内存映射所带来的开销远远低于 CPU 拷贝所带来的开销。此外，使用<code>mmap()</code>还可能会遇到一些需要值得关注的特殊情况，例如，在<code>mmap()</code>—&gt;<code>write()</code>这两个系统调用的整个传输过程中，如果有其他的进程突然截断了这个文件，那么这时用户进程就会因为访问非法地址而被一个从总线传来的 SIGBUS 中断信号杀死并且产生一个 core dump。有两种解决办法：</p>
<ul>
<li>设置一个信号处理器，专门用来处理 SIGBUS 信号，这个处理器直接返回，<code>write()</code>就可以正常返回已写入的字节数而不会被<code>SIGBUS</code>中断，<code>errno</code>错误码也会被设置成 success。然而这实际上是一个掩耳盗铃的解决方案，因为 BIGBUS 信号的带来的信息是系统发生了一些很严重的错误，而我们却选择忽略掉它，一般不建议采用这种方式。</li>
<li>通过内核的文件租借锁（这是 Linux 的叫法，Windows 上称之为机会锁）来解决这个问题，这种方法相对来说更好一些。我们可以通过内核对文件描述符上读/写的租借锁，当另外一个进程尝试对当前用户进程正在进行传输的文件进行截断的时候，内核会发送给用户一个实时信号：RT_SIGNAL_LEASE 信号，这个信号会告诉用户内核正在破坏你加在那个文件上的读/写租借锁，这时<code>write()</code>系统调用会被中断，并且当前用户进程会被 SIGBUS 信号杀死，返回值则是中断前写的字节数，errno 同样会被设置为 success。文件租借锁需要在对文件进行内存映射之前设置，最后在用户进程结束之前释放掉。</li>
</ul>
<h3 id="sendfile"><a href="#sendfile" class="headerlink" title="sendfile()"></a>sendfile()</h3><p>在 Linux 内核 2.1 版本中，引入了一个新的系统调用<code>sendfile()</code>：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sendfile.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> sendfile(<span class="keyword">int</span> out_fd, <span class="keyword">int</span> in_fd, <span class="keyword">off_t</span> *offset, <span class="keyword">size_t</span> count);</span><br></pre></td></tr></table></figure></p>
<p>从功能上来看，这个系统调用将<code>mmap()</code>+<code>write()</code>这两个系统调用合二为一，实现了一样效果的同时还简化了用户接口，其他的一些 Unix-like 的系统像 BSD、Solaris 和 AIX 等也有类似的实现，甚至 Windows 上也有一个功能类似的 API 函数 TransmitFile。</p>
<p><code>out_fd</code>和<code>in_fd</code>分别代表了写入和读出的文件描述符，<code>in_fd</code>必须是一个指向文件的文件描述符，且要能支持类<code>mmap()</code>内存映射，不能是 Socket 类型，而<code>out_fd</code>在 Linux 内核 2.6.33 版本之前只能是一个指向<code>Socket</code>的文件描述符，从 2.6.33 之后则可以是任意类型的文件描述符。off_t 是一个代表了<code>in_fd</code>偏移量的指针，指示<code>sendfile()</code>该从<code>in_fd</code>的哪个位置开始读取，函数返回后，这个指针会被更新成<code>sendfile()</code>最后读取的字节位置处，表明此次调用共读取了多少文件数据，最后的<code>count</code>参数则是此次调用需要传输的字节总数。<br><img src="/img/v2-17ce86192cb8e4d88282aaf9a7c844a3_720w.jpg" alt></p>
<p>使用<code>sendfile()</code>完成一次数据读写的流程如下：</p>
<ul>
<li>用户进程调用<code>sendfile()</code>从用户态陷入内核态；</li>
<li>DMA 控制器将数据从硬盘拷贝到内核缓冲区；</li>
<li>CPU 将内核缓冲区中的数据拷贝到套接字缓冲区；</li>
<li>DMA 控制器将数据从套接字缓冲区拷贝到网卡完成数据传输；</li>
<li><code>sendfile()</code>返回，上下文从内核态切换回用户态。</li>
</ul>
<p>基于<code>sendfile()</code>，整个数据传输过程中共发生 2 次 DMA 拷贝和 1 次 CPU 拷贝，这个和<code>mmap()</code>+<code>write()</code>相同，但是因为<code>sendfile()</code>只是一次系统调用，因此比前者少了一次用户态和内核态的上下文切换开销。读到这里，聪明的读者应该会开始提问了：”<code>sendfile()</code>会不会遇到和<code>mmap()</code>+<code>write()</code>相似的文件截断问题呢？”，很不幸，答案是肯定的。sendfile() 一样会有文件截断的问题，但欣慰的是，<code>sendfile()</code>不仅比<code>mmap()</code>+<code>write()</code>在接口使用上更加简洁，而且处理文件截断时也更加优雅：如果<code>sendfile()</code>过程中遭遇文件截断，则<code>sendfile()</code>系统调用会被中断杀死之前返回给用户进程其中断前所传输的字节数，errno 会被设置为 success，无需用户提前设置信号处理器，当然你要设置一个进行个性化处理也可以，也不需要像之前那样提前给文件描述符设置一个租借锁，因为最终结果还是一样的。</p>
<p><code>sendfile()</code>相较于<code>mmap()</code>的另一个优势在于数据在传输过程中始终没有越过用户态和内核态的边界，因此极大地减少了存储管理的开销。即便如此，sendfile() 依然是一个适用性很窄的技术，最适合的场景基本也就是一个静态文件服务器了。而且根据 Linus 在 2001 年和其他内核维护者的邮件列表内容，其实当初之所以决定在 Linux 上实现<code>sendfile()</code>仅仅是因为在其他操作系统平台上已经率先实现了，而且有大名鼎鼎的 Apache Web 服务器已经在使用了，为了兼容 Apache Web 服务器才决定在 Linux 上也实现这个技术，而且<code>sendfile()</code>实现上的简洁性也和 Linux 内核的其他部分集成得很好，所以 Linus 也就同意了这个提案。</p>
<p>然而<code>sendfile()</code>本身是有很大问题的，从不同的角度来看的话主要是：</p>
<ul>
<li>首先一个是这个接口并没有进行标准化，导致<code>sendfile()</code>在 Linux 上的接口实现和其他类 Unix 系统的实现并不相同；</li>
<li>其次由于网络传输的异步性，很难在接收端实现和<code>sendfile()</code>对接的技术，因此接收端一直没有实现对应的这种技术；</li>
<li>最后从性能方面考量，因为<code>sendfile()</code>在把磁盘文件从内核缓冲区（page cache）传输到到套接字缓冲区的过程中依然需要 CPU 参与，这就很难避免 CPU 的高速缓存被传输的数据所污染。</li>
</ul>
<p>此外，需要说明下，<code>sendfile()</code>的最初设计并不是用来处理大文件的，因此如果需要处理很大的文件的话，可以使用另一个系统调用<code>sendfile64()</code>，它支持对更大的文件内容进行寻址和偏移。</p>
<h3 id="sendﬁle-with-DMA-Scatter-Gather-Copy"><a href="#sendﬁle-with-DMA-Scatter-Gather-Copy" class="headerlink" title="sendﬁle() with DMA Scatter/Gather Copy"></a>sendﬁle() with DMA Scatter/Gather Copy</h3><p>上一小节介绍的<code>sendfile()</code>技术已经把一次数据读写过程中的 CPU 拷贝的降低至只有 1 次了，但是人永远是贪心和不知足的，现在如果想要把这仅有的一次 CPU 拷贝也去除掉，有没有办法呢？</p>
<p>当然有！通过引入一个新硬件上的支持，我们可以把这个仅剩的一次 CPU 拷贝也给抹掉：Linux 在内核 2.4 版本里引入了 DMA 的 scatter/gather — 分散/收集功能，并修改了<code>sendfile()</code>的代码使之和 DMA 适配。scatter 使得 DMA 拷贝可以不再需要把数据存储在一片连续的内存空间上，而是允许离散存储，gather 则能够让 DMA 控制器根据少量的元信息：一个包含了内存地址和数据大小的缓冲区描述符，收集存储在各处的数据，最终还原成一个完整的网络包，直接拷贝到网卡而非套接字缓冲区，避免了最后一次的 CPU 拷贝：<br><img src="/img/v2-0d99113bd0d67e41d288b1f1034d4704_720w.jpg" alt></p>
<p><code>sendfile() + DMA gather</code>的数据传输过程如下：</p>
<ul>
<li>用户进程调用<code>sendfile()</code>，从用户态陷入内核态；</li>
<li>DMA 控制器使用 scatter 功能把数据从硬盘拷贝到内核缓冲区进行离散存储；</li>
<li>CPU 把包含内存地址和数据长度的缓冲区描述符拷贝到套接字缓冲区，DMA 控制器能够根据这些信息生成网络包数据分组的报头和报尾</li>
<li>DMA 控制器根据缓冲区描述符里的内存地址和数据大小，使用 scatter-gather 功能开始从内核缓冲区收集离散的数据并组包，最后直接把网络包数据拷贝到网卡完成数据传输；</li>
<li><code>sendfile()</code>返回，上下文从内核态切换回用户态。</li>
</ul>
<p>基于这种方案，我们就可以把这仅剩的唯一一次 CPU 拷贝也给去除了（严格来说还是会有一次，但是因为这次 CPU 拷贝的只是那些微乎其微的元信息，开销几乎可以忽略不计），理论上，数据传输过程就再也没有 CPU 的参与了，也因此 CPU 的高速缓存再不会被污染了，也不再需要 CPU 来计算数据校验和了，CPU 可以去执行其他的业务计算任务，同时和 DMA 的 I/O 任务并行，此举能极大地提升系统性能。</p>
<h3 id="splice"><a href="#splice" class="headerlink" title="splice()"></a>splice()</h3><p><code>sendfile() + DMA Scatter/Gather</code>的零拷贝方案虽然高效，但是也有两个缺点：</p>
<ul>
<li>这种方案需要引入新的硬件支持；</li>
<li>虽然<code>sendfile()</code>的输出文件描述符在 Linux kernel 2.6.33 版本之后已经可以支持任意类型的文件描述符，但是输入文件描述符依然只能指向文件。</li>
</ul>
<p>这两个缺点限制了<code>sendfile() + DMA Scatter/Gather</code>方案的适用场景。为此，Linux 在 2.6.17 版本引入了一个新的系统调用<code>splice()</code>，它在功能上和<code>sendfile()</code>非常相似，但是能够实现在任意类型的两个文件描述符时之间传输数据；而在底层实现上，<code>splice()</code>又比<code>sendfile()</code>少了一次 CPU 拷贝，也就是等同于<code>sendfile() + DMA Scatter/Gather</code>，完全去除了数据传输过程中的 CPU 拷贝。</p>
<p><code>splice()</code>系统调用函数定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> pipefd[<span class="number">2</span>])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe2</span><span class="params">(<span class="keyword">int</span> pipefd[<span class="number">2</span>], <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> splice(<span class="keyword">int</span> fd_in, <span class="keyword">loff_t</span> *off_in, <span class="keyword">int</span> fd_out, <span class="keyword">loff_t</span> *off_out, <span class="keyword">size_t</span> len, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags);</span><br></pre></td></tr></table></figure></p>
<p><code>fd_in</code>和<code>fd_out</code>也是分别代表了输入端和输出端的文件描述符，这两个文件描述符必须有一个是指向管道设备的，这也是一个不太友好的限制。</p>
<p><code>off_in</code>和<code>off_out</code>则分别是<code>fd_in</code>和<code>fd_out</code>的偏移量指针，指示内核从哪里读取和写入数据，<code>len</code>则指示了此次调用希望传输的字节数，最后的<code>flags</code>是系统调用的标记选项位掩码，用来设置系统调用的行为属性的，由以下 0 个或者多个值通过『或』操作组合而成：</p>
<ul>
<li><code>SPLICE_F_MOVE</code>：指示<code>splice()</code>尝试仅仅是移动内存页面而不是复制，设置了这个值不代表就一定不会复制内存页面，复制还是移动取决于内核能否从管道中移动内存页面，或者管道中的内存页面是否是完整的；这个标记的初始实现有很多 bug，所以从 Linux 2.6.21 版本开始就已经无效了，但还是保留了下来，因为在未来的版本里可能会重新被实现。</li>
<li><code>SPLICE_F_NONBLOCK</code>：指示<code>splice()</code>不要阻塞 I/O，也就是使得<code>splice()</code>调用成为一个非阻塞调用，可以用来实现异步数据传输，不过需要注意的是，数据传输的两个文件描述符也最好是预先通过 O_NONBLOCK 标记成非阻塞 I/O，不然<code>splice()</code>调用还是有可能被阻塞。</li>
<li><code>SPLICE_F_MORE</code>：通知内核下一个<code>splice()</code>系统调用将会有更多的数据传输过来，这个标记对于输出端是 socket 的场景非常有用。</li>
</ul>
<p><code>splice()</code>是基于 Linux 的管道缓冲区 (pipe buffer) 机制实现的，所以<code>splice()</code>的两个入参文件描述符才要求必须有一个是管道设备，一个典型的<code>splice()</code>用法是：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> pfd[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">pipe(pfd);</span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> bytes = splice(file_fd, <span class="literal">NULL</span>, pfd[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">4096</span>, SPLICE_F_MOVE);</span><br><span class="line">assert(bytes != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">bytes = splice(pfd[<span class="number">0</span>], <span class="literal">NULL</span>, socket_fd, <span class="literal">NULL</span>, bytes, SPLICE_F_MOVE | SPLICE_F_MORE);</span><br><span class="line">assert(bytes != <span class="number">-1</span>);</span><br></pre></td></tr></table></figure></p>
<p>数据传输过程图：<br><img src="/img/v2-e179bc30903178cec7e9324d628f33a5_720w.jpg" alt></p>
<p>使用<code>splice()</code>完成一次磁盘文件到网卡的读写过程如下：</p>
<ul>
<li>用户进程调用<code>pipe()</code>，从用户态陷入内核态，创建匿名单向管道，pipe() 返回，上下文从内核态切换回用户态；</li>
<li>用户进程调用<code>splice()</code>，从用户态陷入内核态；</li>
<li>DMA 控制器将数据从硬盘拷贝到内核缓冲区，从管道的写入端”拷贝”进管道，splice() 返回，上下文从内核态回到用户态；</li>
<li>用户进程再次调用<code>splice()</code>，从用户态陷入内核态；</li>
<li>内核把数据从管道的读取端”拷贝”到套接字缓冲区，DMA 控制器将数据从套接字缓冲区拷贝到网卡；</li>
<li><code>splice()</code>返回，上下文从内核态切换回用户态。</li>
</ul>
<p>相信看完上面的读写流程之后，读者肯定会非常困惑：说好的<code>splice()</code>是<code>sendfile()</code>的改进版呢？<code>sendfile()</code>好歹只需要一次系统调用，<code>splice()</code>居然需要三次，这也就罢了，居然中间还搞出来一个管道，而且还要在内核空间拷贝两次，这算个毛的改进啊？</p>
<p>我最开始了解<code>splice()</code>的时候，也是这个反应，但是深入学习它之后，才渐渐知晓个中奥妙，且听我细细道来：</p>
<p>先来了解一下 pipe buffer 管道，管道是 Linux 上用来供进程之间通信的信道，管道有两个端：写入端和读出端，从进程的视角来看，管道表现为一个 FIFO 字节流环形队列：<br><img src="/img/v2-9f9f00d7645cf1aebe3843c2dcf44bc3_720w.jpg" alt></p>
<p>管道本质上是一个内存中的文件，也就是本质上还是基于 Linux 的 VFS，用户进程可以通过<code>pipe()</code>系统调用创建一个匿名管道，创建完成之后会有两个 VFS 的 file 结构体的 inode 分别指向其写入端和读出端，并返回对应的两个文件描述符，用户进程通过这两个文件描述符读写管道；管道的容量单位是一个虚拟内存的页，也就是 4KB，总大小一般是 16 个页，基于其环形结构，管道的页可以循环使用，提高内存利用率。 Linux 中以<code>pipe_buffer</code>结构体封装管道页，file 结构体里的 inode 字段里会保存一个 pipe_inode_info 结构体指代管道，其中会保存很多读写管道时所需的元信息，环形队列的头部指针页，读写时的同步机制如互斥锁、等待队列等：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> &#123;</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span> <span class="comment">// 内存页结构</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">int</span> offset, len; <span class="comment">// 偏移量，长度</span></span><br><span class="line"> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">int</span> flags;</span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">private</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> &#123;</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mutex</span>;</span></span><br><span class="line"> <span class="keyword">wait_queue_head_t</span> wait;</span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">int</span> nrbufs, curbuf, buffers;</span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">int</span> readers;</span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">int</span> writers;</span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">int</span> files;</span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">int</span> waiting_writers;</span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">int</span> r_counter;</span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">int</span> w_counter;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">tmp_page</span>;</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">fasync_readers</span>;</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">fasync_writers</span>;</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">bufs</span>;</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>pipe_buffer</code>中保存了数据在内存中的页、偏移量和长度，以这三个值来定位数据，注意这里的页不是虚拟内存的页，而用的是物理内存的页框，因为管道时跨进程的信道，因此不能使用虚拟内存来表示，只能使用物理内存的页框定位数据；管道的正常读写操作是通过<code>pipe_write()/pipe_read()</code>来完成的，通过把数据读取/写入环形队列的<code>pipe_buffer</code>来完成数据传输。</p>
<p>splice() 是基于 pipe buffer 实现的，但是它在通过管道传输数据的时候却是零拷贝，因为它在写入读出时并没有使用<code>pipe_write()/pipe_read()</code>真正地在管道缓冲区写入读出数据，而是通过把数据在内存缓冲区中的物理内存页框指针、偏移量和长度赋值给前文提及的<code>pipe_buffer</code>中对应的三个字段来完成数据的”拷贝”，也就是其实只拷贝了数据的内存地址等元信息。</p>
<p><code>splice()</code>在 Linux 内核源码中的内部实现是<code>do_splice()</code>函数，而写入读出管道则分别是通过<code>do_splice_to()</code>和<code>do_splice_from()</code>，这里我们重点来解析下写入管道的源码，也就是<code>do_splice_to()</code>，我现在手头的 Linux 内核版本是 v4.8.17，我们就基于这个版本来分析，至于读出的源码函数<code>do_splice_from()</code>，原理是相通的，大家举一反三即可。</p>
<p><code>splice()</code>写入数据到管道的调用链式：<code>do_splice() --&gt; do_splice_to() --&gt; splice_read()</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">do_splice</span><span class="params">(struct file *in, <span class="keyword">loff_t</span> __user *off_in,</span></span></span><br><span class="line"><span class="function"><span class="params">        struct file *out, <span class="keyword">loff_t</span> __user *off_out,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">size_t</span> len, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 判断是写出 fd 是一个管道设备，则进入数据写入的逻辑</span></span><br><span class="line"> <span class="keyword">if</span> (opipe) &#123;</span><br><span class="line">  <span class="keyword">if</span> (off_out)</span><br><span class="line">   <span class="keyword">return</span> -ESPIPE;</span><br><span class="line">  <span class="keyword">if</span> (off_in) &#123;</span><br><span class="line">   <span class="keyword">if</span> (!(in-&gt;f_mode &amp; FMODE_PREAD))</span><br><span class="line">    <span class="keyword">return</span> -EINVAL;</span><br><span class="line">   <span class="keyword">if</span> (copy_from_user(&amp;offset, off_in, <span class="keyword">sizeof</span>(<span class="keyword">loff_t</span>)))</span><br><span class="line">    <span class="keyword">return</span> -EFAULT;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   offset = in-&gt;f_pos;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用 do_splice_to 把文件内容写入管道</span></span><br><span class="line">  ret = do_splice_to(in, &amp;offset, opipe, len, flags);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!off_in)</span><br><span class="line">   in-&gt;f_pos = offset;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (copy_to_user(off_in, &amp;offset, <span class="keyword">sizeof</span>(<span class="keyword">loff_t</span>)))</span><br><span class="line">   ret = -EFAULT;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进入<code>do_splice_to()</code>之后，再调用<code>splice_read()</code>：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">do_splice_to</span><span class="params">(struct file *in, <span class="keyword">loff_t</span> *ppos,</span></span></span><br><span class="line"><span class="function"><span class="params">    struct pipe_inode_info *pipe, <span class="keyword">size_t</span> len,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">ssize_t</span> (*splice_read)(struct file *, <span class="keyword">loff_t</span> *,</span><br><span class="line">          struct pipe_inode_info *, <span class="keyword">size_t</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span>);</span><br><span class="line"> <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (unlikely(!(in-&gt;f_mode &amp; FMODE_READ)))</span><br><span class="line">  <span class="keyword">return</span> -EBADF;</span><br><span class="line"></span><br><span class="line"> ret = rw_verify_area(READ, in, ppos, len);</span><br><span class="line"> <span class="keyword">if</span> (unlikely(ret &lt; <span class="number">0</span>))</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (unlikely(len &gt; MAX_RW_COUNT))</span><br><span class="line">  len = MAX_RW_COUNT;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 判断文件的文件的 file 结构体的 f_op 中有没有可供使用的、支持 splice 的 splice_read 函数指针</span></span><br><span class="line"> <span class="comment">// 因为是`splice()`调用，因此内核会提前给这个函数指针指派一个可用的函数</span></span><br><span class="line"> <span class="keyword">if</span> (in-&gt;f_op-&gt;splice_read)</span><br><span class="line">  splice_read = in-&gt;f_op-&gt;splice_read;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line">  splice_read = default_file_splice_read;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> splice_read(in, ppos, pipe, len, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>in-&gt;f_op-&gt;splice_read</code>这个函数指针根据文件描述符的类型不同有不同的实现，比如这里的<code>in</code>是一个文件，因此是<code>generic_file_splice_read()</code>，如果是<code>socket</code>的话，则是<code>sock_splice_read()</code>，其他的类型也会有对应的实现，总之我们这里将使用的是<code>generic_file_splice_read()</code>函数，这个函数会继续调用内部函数<code>__generic_file_splice_read</code>完成以下工作：</p>
<ol>
<li>在 page cache 页缓存里进行搜寻，看看我们要读取这个文件内容是否已经在缓存里了，如果是则直接用，否则如果不存在或者只有部分数据在缓存中，则分配一些新的内存页并进行读入数据操作，同时会增加页框的引用计数；</li>
<li>基于这些内存页，初始化<code>splice_pipe_desc</code>结构，这个结构保存会保存文件数据的地址元信息，包含有物理内存页框地址，偏移、数据长度，也就是<code>pipe_buffer</code>所需的三个定位数据的值；</li>
<li>最后，调用<code>splice_to_pipe()</code>，<code>splice_pipe_desc</code>结构体实例是函数入参。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> splice_to_pipe(struct pipe_inode_info *pipe, struct splice_pipe_desc *spd)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!pipe-&gt;readers) &#123;</span><br><span class="line">   send_sig(SIGPIPE, current, <span class="number">0</span>);</span><br><span class="line">   <span class="keyword">if</span> (!ret)</span><br><span class="line">    ret = -EPIPE;</span><br><span class="line">   <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pipe-&gt;nrbufs &lt; pipe-&gt;buffers) &#123;</span><br><span class="line">   <span class="keyword">int</span> newbuf = (pipe-&gt;curbuf + pipe-&gt;nrbufs) &amp; (pipe-&gt;buffers - <span class="number">1</span>);</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">buf</span> = <span class="title">pipe</span>-&gt;<span class="title">bufs</span> + <span class="title">newbuf</span>;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 写入数据到管道，没有真正拷贝数据，而是内存地址指针的移动，</span></span><br><span class="line">   <span class="comment">// 把物理页框、偏移量和数据长度赋值给 pipe_buffer 完成数据入队操作</span></span><br><span class="line">   buf-&gt;page = spd-&gt;pages[page_nr];</span><br><span class="line">   buf-&gt;offset = spd-&gt;partial[page_nr].offset;</span><br><span class="line">   buf-&gt;len = spd-&gt;partial[page_nr].len;</span><br><span class="line">   buf-&gt;<span class="keyword">private</span> = spd-&gt;partial[page_nr].<span class="keyword">private</span>;</span><br><span class="line">   buf-&gt;ops = spd-&gt;ops;</span><br><span class="line">   <span class="keyword">if</span> (spd-&gt;flags &amp; SPLICE_F_GIFT)</span><br><span class="line">    buf-&gt;flags |= PIPE_BUF_FLAG_GIFT;</span><br><span class="line"></span><br><span class="line">   pipe-&gt;nrbufs++;</span><br><span class="line">   page_nr++;</span><br><span class="line">   ret += buf-&gt;len;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (pipe-&gt;files)</span><br><span class="line">    do_wakeup = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (!--spd-&gt;nr_pages)</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">if</span> (pipe-&gt;nrbufs &lt; pipe-&gt;buffers)</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里可以清楚地看到<code>splice()</code>所谓的写入数据到管道其实并没有真正地拷贝数据，而是玩了个 tricky 的操作：只进行内存地址指针的拷贝而不真正去拷贝数据。所以，数据<code>splice()</code>在内核中并没有进行真正的数据拷贝，因此<code>splice()</code>系统调用也是零拷贝。</p>
<p>还有一点需要注意，前面说过管道的容量是 16 个内存页，也就是 16 * 4KB = 64 KB，也就是说一次往管道里写数据的时候最好不要超过 64 KB，否则的话会<code>splice()</code>会阻塞住，除非在创建管道的时候使用的是<code>pipe2()</code>并通过传入 O_NONBLOCK 属性将管道设置为非阻塞。</p>
<p>即使<code>splice()</code>通过内存地址指针避免了真正的拷贝开销，但是算起来它还要使用额外的管道来完成数据传输，也就是比<code>sendfile()</code>多了两次系统调用，这不是又增加了上下文切换的开销吗？为什么不直接在内核创建管道并调用那两次<code>splice()</code>，然后只暴露给用户一次系统调用呢？实际上因为<code>splice()</code>利用管道而非硬件来完成零拷贝的实现比<code>sendfile() + DMA Scatter/Gather</code>的门槛更低，因此后来的<code>sendfile()</code>的底层实现就已经替换成<code>splice()</code>了。</p>
<p>至于说<code>splice()</code>本身的 API 为什么还是这种使用模式，那是因为 Linux 内核开发团队一直想把基于管道的这个限制去掉，但不知道因为什么一直搁置，所以这个 API 也就一直没变化，只能等内核团队哪天想起来了这一茬，然后重构一下使之不再依赖管道，在那之前，使用<code>splice()</code>依然还是需要额外创建管道来作为中间缓冲，如果你的业务场景很适合使用<code>splice()</code>，但又是性能敏感的，不想频繁地创建销毁 pipe buffer 管道缓冲区，那么可以参考一下 HAProxy 使用<code>splice()</code>时采用的优化方案：预先分配一个 pipe buffer pool 缓存管道，每次调用<code>spclie()</code>的时候去缓存池里取一个管道，用完就放回去，循环利用，提升性能。</p>
<h3 id="send-with-MSG-ZEROCOPY"><a href="#send-with-MSG-ZEROCOPY" class="headerlink" title="send() with MSG_ZEROCOPY"></a>send() with MSG_ZEROCOPY</h3><p>Linux 内核在 2017 年的 v4.14 版本接受了来自 Google 工程师 Willem de Bruijn 在 TCP 网络报文的通用发送接口<code>send()</code>中实现的 zero-copy 功能 (MSG_ZEROCOPY) 的 patch，通过这个新功能，用户进程就能够把用户缓冲区的数据通过零拷贝的方式经过内核空间发送到网络套接字中去，这个新技术和前文介绍的几种零拷贝方式相比更加先进，因为前面几种零拷贝技术都是要求用户进程不能处理加工数据而是直接转发到目标文件描述符中去的。Willem de Bruijn 在他的论文里给出的压测数据是：采用 netperf 大包发送测试，性能提升 39%，而线上环境的数据发送性能则提升了 5%~8%，官方文档陈述说这个特性通常只在发送 10KB 左右大包的场景下才会有显著的性能提升。一开始这个特性只支持 TCP，到内核 v5.0 版本之后才支持 UDP。</p>
<p>这个功能的使用模式如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (setsockopt(socket_fd, SOL_SOCKET, SO_ZEROCOPY, &amp;one, <span class="keyword">sizeof</span>(one)))</span><br><span class="line">        error(<span class="number">1</span>, errno, <span class="string">"setsockopt zerocopy"</span>);</span><br><span class="line"></span><br><span class="line">ret = send(socket_fd, buffer, <span class="keyword">sizeof</span>(buffer), MSG_ZEROCOPY);</span><br></pre></td></tr></table></figure></p>
<p>首先第一步，先给要发送数据的<code>socket</code>设置一个<code>SOCK_ZEROCOPY option</code>，然后在调用<code>send()</code>发送数据时再设置一个 MSG_ZEROCOPY option，其实理论上来说只需要调用<code>setsockopt()</code>或者<code>send()</code>时传递这个 zero-copy 的 option 即可，两者选其一，但是这里却要设置同一个 option 两次，官方的说法是为了兼容<code>send()</code>API 以前的设计上的一个错误：send() 以前的实现会忽略掉未知的 option，为了兼容那些可能已经不小心设置了 MSG_ZEROCOPY option 的程序，故而设计成了两步设置。不过我猜还有一种可能：就是给使用者提供更灵活的使用模式，因为这个新功能只在大包场景下才可能会有显著的性能提升，但是现实场景是很复杂的，不仅仅是全部大包或者全部小包的场景，有可能是大包小包混合的场景，因此使用者可以先调用<code>setsockopt()</code>设置 SOCK_ZEROCOPY option，然后再根据实际业务场景中的网络包尺寸选择是否要在调用<code>send()</code>时使用 MSG_ZEROCOPY 进行 zero-copy 传输。</p>
<p>因为<code>send()</code>可能是异步发送数据，因此使用 MSG_ZEROCOPY 有一个需要特别注意的点是：调用<code>send()</code>之后不能立刻重用或释放 buffer，因为 buffer 中的数据不一定已经被内核读走了，所以还需要从 socket 关联的错误队列里读取一下通知消息，看看 buffer 中的数据是否已经被内核读走了：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">pfd.fd = fd;</span><br><span class="line">pfd.events = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (poll(&amp;pfd, <span class="number">1</span>, <span class="number">-1</span>) != <span class="number">1</span> || pfd.revents &amp; POLLERR == <span class="number">0</span>)</span><br><span class="line">        error(<span class="number">1</span>, errno, <span class="string">"poll"</span>);</span><br><span class="line"></span><br><span class="line">ret = recvmsg(fd, &amp;msg, MSG_ERRQUEUE);</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">        error(<span class="number">1</span>, errno, <span class="string">"recvmsg"</span>);</span><br><span class="line"></span><br><span class="line">read_notification(msg);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">uint32_t</span> read_notification(struct msghdr *msg)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">sock_extended_err</span> *<span class="title">serr</span>;</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">cmsghdr</span> *<span class="title">cm</span>;</span></span><br><span class="line"></span><br><span class="line"> cm = CMSG_FIRSTHDR(msg);</span><br><span class="line"> <span class="keyword">if</span> (cm-&gt;cmsg_level != SOL_IP &amp;&amp;</span><br><span class="line">  cm-&gt;cmsg_type != IP_RECVERR)</span><br><span class="line">   error(<span class="number">1</span>, <span class="number">0</span>, <span class="string">"cmsg"</span>);</span><br><span class="line"></span><br><span class="line"> serr = (<span class="keyword">void</span> *) CMSG_DATA(cm);</span><br><span class="line"> <span class="keyword">if</span> (serr-&gt;ee_errno != <span class="number">0</span> ||</span><br><span class="line">  serr-&gt;ee_origin != SO_EE_ORIGIN_ZEROCOPY)</span><br><span class="line">   error(<span class="number">1</span>, <span class="number">0</span>, <span class="string">"serr"</span>);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> serr-&gt;ee _ data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个技术是基于 redhat 红帽在 2010 年给 Linux 内核提交的 virtio-net zero-copy 技术之上实现的，至于底层原理，简单来说就是通过<code>send()</code>把数据在用户缓冲区中的分段指针发送到 socket 中去，利用 page pinning 页锁定机制锁住用户缓冲区的内存页，然后利用 DMA 直接在用户缓冲区通过内存地址指针进行数据读取，实现零拷贝；具体的细节可以通过阅读 Willem de Bruijn 的论文 (PDF) 深入了解。</p>
<p>目前来说，这种技术的主要缺陷有：</p>
<ul>
<li>只适用于大文件 (10KB 左右) 的场景，小文件场景因为 page pinning 页锁定和等待缓冲区释放的通知消息这些机制，甚至可能比直接 CPU 拷贝更耗时；</li>
<li>因为可能异步发送数据，需要额外调用<code>poll()</code>和 recvmsg() 系统调用等待 buffer 被释放的通知消息，增加代码复杂度，以及会导致多次用户态和内核态的上下文切换；</li>
<li>MSG_ZEROCOPY 目前只支持发送端，接收端暂不支持。</li>
</ul>
<h2 id="绕过内核的直接-I-O"><a href="#绕过内核的直接-I-O" class="headerlink" title="绕过内核的直接 I/O"></a>绕过内核的直接 I/O</h2><p>可以看出，前面种种的 zero-copy 的方法，都是在想方设法地优化减少或者去掉用户态和内核态之间以及内核态和内核态之间的数据拷贝，为了实现避免这些拷贝可谓是八仙过海，各显神通，采用了各种各样的手段，那么如果我们换个思路：其实这么费劲地去消除这些拷贝不就是因为有内核在掺和吗？如果我们绕过内核直接进行 I/O 不就没有这些烦人的拷贝问题了吗？这就是绕过内核直接 I/O 技术：<br><img src="/img/v2-89e764295fa13980880679ff5c5a63e3_720w.jpg" alt></p>
<p>这种方案有两种实现方式：</p>
<ul>
<li>用户直接访问硬件</li>
<li>内核控制访问硬件</li>
</ul>
<h3 id="用户直接访问硬件"><a href="#用户直接访问硬件" class="headerlink" title="用户直接访问硬件"></a>用户直接访问硬件</h3><p>这种技术赋予用户进程直接访问硬件设备的权限，这让用户进程能有直接读写硬件设备，在数据传输过程中只需要内核做一些虚拟内存配置相关的工作。这种无需数据拷贝和内核干预的直接 I/O，理论上是最高效的数据传输技术，但是正如前面所说的那样，并不存在能解决一切问题的银弹，这种直接 I/O 技术虽然有可能非常高效，但是它的适用性也非常窄，目前只适用于诸如 MPI 高性能通信、丛集计算系统中的远程共享内存等有限的场景。</p>
<p>这种技术实际上破坏了现代计算机操作系统最重要的概念之一 —— 硬件抽象，我们之前提过，抽象是计算机领域最最核心的设计思路，正式由于有了抽象和分层，各个层级才能不必去关心很多底层细节从而专注于真正的工作，才使得系统的运作更加高效和快速。此外，网卡通常使用功能较弱的 CPU，例如只包含简单指令集的 MIPS 架构处理器（没有不必要的功能，如浮点数计算等），也没有太多的内存来容纳复杂的软件。因此，通常只有那些基于以太网之上的专用协议会使用这种技术，这些专用协议的设计要比远比 TCP/IP 简单得多，而且多用于局域网环境中，在这种环境中，数据包丢失和损坏很少发生，因此没有必要进行复杂的数据包确认和流量控制机制。而且这种技术还需要定制的网卡，所以它是高度依赖硬件的。</p>
<p>与传统的通信设计相比，直接硬件访问技术给程序设计带来了各种限制：由于设备之间的数据传输是通过 DMA 完成的，因此用户空间的数据缓冲区内存页必须进行 page pinning（页锁定），这是为了防止其物理页框地址被交换到磁盘或者被移动到新的地址而导致 DMA 去拷贝数据的时候在指定的地址找不到内存页从而引发缺页错误，而页锁定的开销并不比 CPU 拷贝小，所以为了避免频繁的页锁定系统调用，应用程序必须分配和注册一个持久的内存池，用于数据缓冲。</p>
<p>用户直接访问硬件的技术可以得到极高的 I/O 性能，但是其应用领域和适用场景也极其的有限，如集群或网络存储系统中的节点通信。它需要定制的硬件和专门设计的应用程序，但相应地对操作系统内核的改动比较小，可以很容易地以内核模块或设备驱动程序的形式实现出来。直接访问硬件还可能会带来严重的安全问题，因为用户进程拥有直接访问硬件的极高权限，所以如果你的程序设计没有做好的话，可能会消耗本来就有限的硬件资源或者进行非法地址访问，可能也会因此间接地影响其他正在使用同一设备的应用程序，而因为绕开了内核，所以也无法让内核替你去控制和管理。</p>
<h3 id="内核控制访问硬件"><a href="#内核控制访问硬件" class="headerlink" title="内核控制访问硬件"></a>内核控制访问硬件</h3><p>相较于用户直接访问硬件技术，通过内核控制的直接访问硬件技术更加的安全，它比前者在数据传输过程中会多干预一点，但也仅仅是作为一个代理人这样的角色，不会参与到实际的数据传输过程，内核会控制 DMA 引擎去替用户进程做缓冲区的数据传输工作。同样的，这种方式也是高度依赖硬件的，比如一些集成了专有网络栈协议的网卡。这种技术的一个优势就是用户集成去 I/O 时的接口不会改变，就和普通的<code>read()/write()</code>系统调用那样使用即可，所有的脏活累活都在内核里完成，用户接口友好度很高，不过需要注意的是，使用这种技术的过程中如果发生了什么不可预知的意外从而导致无法使用这种技术进行数据传输的话，则内核会自动切换为最传统 I/O 模式，也就是性能最差的那种模式。</p>
<p>这种技术也有着和用户直接访问硬件技术一样的问题：DMA 传输数据的过程中，用户进程的缓冲区内存页必须进行 page pinning 页锁定，数据传输完成后才能解锁。CPU 高速缓存内保存的多个内存地址也会被冲刷掉以保证 DMA 传输前后的数据一致性。这些机制有可能会导致数据传输的性能变得更差，因为<code>read()/write()</code>系统调用的语义并不能提前通知 CPU 用户缓冲区要参与 DMA 数据传输传输，因此也就无法像内核缓冲区那样可依提前加载进高速缓存，提高性能。由于用户缓冲区的内存页可能分布在物理内存中的任意位置，因此一些实现不好的 DMA 控制器引擎可能会有寻址限制从而导致无法访问这些内存区域。一些技术比如 AMD64 架构中的 IOMMU，允许通过将 DMA 地址重新映射到内存中的物理地址来解决这些限制，但反过来又可能会导致可移植性问题，因为其他的处理器架构，甚至是 Intel 64 位 x86 架构的变种 EM64T 都不具备这样的特性单元。此外，还可能存在其他限制，比如 DMA 传输的数据对齐问题，又会导致无法访问用户进程指定的任意缓冲区内存地址。</p>
<h2 id="内核缓冲区和用户缓冲区之间的传输优化"><a href="#内核缓冲区和用户缓冲区之间的传输优化" class="headerlink" title="内核缓冲区和用户缓冲区之间的传输优化"></a>内核缓冲区和用户缓冲区之间的传输优化</h2><p>到目前为止，我们讨论的 zero-copy 技术都是基于减少甚至是避免用户空间和内核空间之间的 CPU 数据拷贝的，虽然有一些技术非常高效，但是大多都有适用性很窄的问题，比如 sendfile()、splice() 这些，效率很高，但是都只适用于那些用户进程不需要直接处理数据的场景，比如静态文件服务器或者是直接转发数据的代理服务器。</p>
<p>现在我们已经知道，硬件设备之间的数据可以通过 DMA 进行传输，然而却并没有这样的传输机制可以应用于用户缓冲区和内核缓冲区之间的数据传输。不过另一方面，广泛应用在现代的 CPU 架构和操作系统上的虚拟内存机制表明，通过在不同的虚拟地址上重新映射页面可以实现在用户进程和内核之间虚拟复制和共享内存，尽管一次传输的内存颗粒度相对较大：4KB 或 8KB。</p>
<p>因此如果要在实现在用户进程内处理数据（这种场景比直接转发数据更加常见）之后再发送出去的话，用户空间和内核空间的数据传输就是不可避免的，既然避无可避，那就只能选择优化了，因此本章节我们要介绍两种优化用户空间和内核空间数据传输的技术：</p>
<ul>
<li>动态重映射与写时拷贝 (Copy-on-Write)</li>
<li>缓冲区共享 (Buffer Sharing)</li>
</ul>
<h3 id="动态重映射与写时拷贝-Copy-on-Write"><a href="#动态重映射与写时拷贝-Copy-on-Write" class="headerlink" title="动态重映射与写时拷贝 (Copy-on-Write)"></a>动态重映射与写时拷贝 (Copy-on-Write)</h3><p>前面我们介绍过利用内存映射技术来减少数据在用户空间和内核空间之间的复制，通常简单模式下，用户进程是对共享的缓冲区进行同步阻塞读写的，这样不会有 data race 问题，但是这种模式下效率并不高，而提升效率的一种方法就是异步地对共享缓冲区进行读写，而这样的话就必须引入保护机制来避免数据冲突问题，写时复制 (Copy on Write) 就是这样的一种技术。</p>
<p>写入时复制（Copy-on-write，COW）是一种计算机程序设计领域的优化策略。其核心思想是，如果有多个调用者（callers）同时请求相同资源（如内存或磁盘上的数据存储），他们会共同获取相同的指针指向相同的资源，直到某个调用者试图修改资源的内容时，系统才会真正复制一份专用副本（private copy）给该调用者，而其他调用者所见到的最初的资源仍然保持不变。这过程对其他的调用者都是透明的。此作法主要的优点是如果调用者没有修改该资源，就不会有副本（private copy）被创建，因此多个调用者只是读取操作时可以共享同一份资源。</p>
<p>举一个例子，引入了 COW 技术之后，用户进程读取磁盘文件进行数据处理最后写到网卡，首先使用内存映射技术让用户缓冲区和内核缓冲区共享了一段内存地址并标记为只读 (read-only)，避免数据拷贝，而当要把数据写到网卡的时候，用户进程选择了异步写的方式，系统调用会直接返回，数据传输就会在内核里异步进行，而用户进程就可以继续其他的工作，并且共享缓冲区的内容可以随时再进行读取，效率很高，但是如果该进程又尝试往共享缓冲区写入数据，则会产生一个 COW 事件，让试图写入数据的进程把数据复制到自己的缓冲区去修改，这里只需要复制要修改的内存页即可，无需所有数据都复制过去，而如果其他访问该共享内存的进程不需要修改数据则可以永远不需要进行数据拷贝。</p>
<p>COW 是一种建构在虚拟内存冲映射技术之上的技术，因此它需要 MMU 的硬件支持，MMU 会记录当前哪些内存页被标记成只读，当有进程尝试往这些内存页中写数据的时候，MMU 就会抛一个异常给操作系统内核，内核处理该异常时为该进程分配一份物理内存并复制数据到此内存地址，重新向 MMU 发出执行该进程的写操作。</p>
<p>COW 最大的优势是节省内存和减少数据拷贝，不过却是通过增加操作系统内核 I/O 过程复杂性作为代价的。当确定采用 COW 来复制页面时，重要的是注意空闲页面的分配位置。许多操作系统为这类请求提供了一个空闲的页面池。当进程的堆栈或堆要扩展时或有写时复制页面需要管理时，通常分配这些空闲页面。操作系统分配这些页面通常采用称为按需填零的技术。按需填零页面在需要分配之前先填零，因此会清除里面旧的内容。</p>
<p>局限性：</p>
<p>COW 这种零拷贝技术比较适用于那种多读少写从而使得 COW 事件发生较少的场景，因为 COW 事件所带来的系统开销要远远高于一次 CPU 拷贝所产生的。此外，在实际应用的过程中，为了避免频繁的内存映射，可以重复使用同一段内存缓冲区，因此，你不需要在只用过一次共享缓冲区之后就解除掉内存页的映射关系，而是重复循环使用，从而提升性能，不过这种内存页映射的持久化并不会减少由于页表往返移动和 TLB 冲刷所带来的系统开销，因为每次接收到 COW 事件之后对内存页而进行加锁或者解锁的时候，页面的只读标志 (read-ony) 都要被更改为 (write-only)。</p>
<h3 id="缓冲区共享-Buffer-Sharing"><a href="#缓冲区共享-Buffer-Sharing" class="headerlink" title="缓冲区共享 (Buffer Sharing)"></a>缓冲区共享 (Buffer Sharing)</h3><p>从前面的介绍可以看出，传统的 Linux I/O 接口，都是基于复制/拷贝的：数据需要在操作系统内核空间和用户空间的缓冲区之间进行拷贝。在进行 I/O 操作之前，用户进程需要预先分配好一个内存缓冲区，使用<code>read()</code>系统调用时，内核会将从存储器或者网卡等设备读入的数据拷贝到这个用户缓冲区里；而使用<code>write()</code> 系统调用时，则是把用户内存缓冲区的数据拷贝至内核缓冲区。</p>
<p>为了实现这种传统的 I/O 模式，Linux 必须要在每一个 I/O 操作时都进行内存虚拟映射和解除。这种内存页重映射的机制的效率严重受限于缓存体系结构、MMU 地址转换速度和 TLB 命中率。如果能够避免处理 I/O 请求的虚拟地址转换和 TLB 刷新所带来的开销，则有可能极大地提升 I/O 性能。而缓冲区共享就是用来解决上述问题的一种技术。</p>
<p>最早支持 Buffer Sharing 的操作系统是 Solaris。后来，Linux 也逐步支持了这种 Buffer Sharing 的技术，但时至今日依然不够完整和成熟。</p>
<p>操作系统内核开发者们实现了一种叫 fbufs 的缓冲区共享的框架，也即快速缓冲区（ Fast Buffers ），使用一个<code>fbuf</code>缓冲区作为数据传输的最小单位，使用这种技术需要调用新的操作系统 API，用户区和内核区、内核区之间的数据都必须严格地在 fbufs 这个体系下进行通信。fbufs 为每一个用户进程分配一个 buffer pool，里面会储存预分配 (也可以使用的时候再分配) 好的 buffers，这些 buffers 会被同时映射到用户内存空间和内核内存空间。fbufs 只需通过一次虚拟内存映射操作即可创建缓冲区，有效地消除那些由存储一致性维护所引发的大多数性能损耗。</p>
<p>传统的 Linux I/O 接口是通过把数据在用户缓冲区和内核缓冲区之间进行拷贝传输来完成的，这种数据传输过程中需要进行大量的数据拷贝，同时由于虚拟内存技术的存在，I/O 过程中还需要频繁地通过 MMU 进行虚拟内存地址到物理内存地址的转换，高速缓存的汰换以及 TLB 的刷新，这些操作均会导致性能的损耗。而如果利用 fbufs 框架来实现数据传输的话，首先可以把 buffers 都缓存到 pool 里循环利用，而不需要每次都去重新分配，而且缓存下来的不止有 buffers 本身，而且还会把虚拟内存地址到物理内存地址的映射关系也缓存下来，也就可以避免每次都进行地址转换，从发送接收数据的层面来说，用户进程和 I/O 子系统比如设备驱动程序、网卡等可以直接传输整个缓冲区本身而不是其中的数据内容，也可以理解成是传输内存地址指针，这样就就避免了大量的数据内容拷贝：用户进程/ IO 子系统通过发送一个个的<code>fbuf</code>写出数据到内核而非直接传递数据内容，相对应的，用户进程/ IO 子系统通过接收一个个的<code>fbuf</code>而从内核读入数据，这样就能减少传统的<code>read()/write()</code>系统调用带来的数据拷贝开销：<br><img src="/img/v2-9b6aace364e295bd5a6271c146d477ab_720w.jpg" alt></p>
<ul>
<li>发送方用户进程调用<code>uf_allocate</code>从自己的 buffer pool 获取一个<code>fbuf</code>缓冲区，往其中填充内容之后调用<code>uf_write</code>向内核区发送指向<code>fbuf</code>的文件描述符；</li>
<li>I/O 子系统接收到<code>fbuf</code>之后，调用 uf_allocb 从接收方用户进程的 buffer pool 获取一个 fubf 并用接收到的数据进行填充，然后向用户区发送指向<code>fbuf</code>的文件描述符；</li>
<li>接收方用户进程调用<code>uf_get</code>接收到<code>fbuf</code>，读取数据进行处理，完成之后调用<code>uf_deallocate</code>把<code>fbuf</code>放回自己的 buffer pool。</li>
</ul>
<h3 id="fbufs-的缺陷"><a href="#fbufs-的缺陷" class="headerlink" title="fbufs 的缺陷"></a>fbufs 的缺陷</h3><p>共享缓冲区技术的实现需要依赖于用户进程、操作系统内核、以及 I/O 子系统 (设备驱动程序，文件系统等)之间协同工作。比如，设计得不好的用户进程容易就会修改已经发送出去的<code>fbuf</code>从而污染数据，更要命的是这种问题很难 debug。虽然这个技术的设计方案非常精彩，但是它的门槛和限制却不比前面介绍的其他技术少：首先会对操作系统 API 造成变动，需要使用新的一些 API 调用，其次还需要设备驱动程序配合改动，还有由于是内存共享，内核需要很小心谨慎地实现对这部分共享的内存进行数据保护和同步的机制，而这种并发的同步机制是非常容易出 bug 的从而又增加了内核的代码复杂度，等等。因此这一类的技术还远远没有到发展成熟和广泛应用的阶段，目前大多数的实现都还处于实验阶段。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文中我主要讲解了 Linux I/O 底层原理，然后介绍并解析了 Linux 中的 Zero-copy 技术，并给出了 Linux 对 I/O 模块的优化和改进思路。</p>
<p>Linux 的 Zero-copy 技术可以归纳成以下三大类：</p>
<ul>
<li>减少甚至避免用户空间和内核空间之间的数据拷贝：在一些场景下，用户进程在数据传输过程中并不需要对数据进行访问和处理，那么数据在 Linux 的 Page Cache 和用户进程的缓冲区之间的传输就完全可以避免，让数据拷贝完全在内核里进行，甚至可以通过更巧妙的方式避免在内核里的数据拷贝。这一类实现一般是是通过增加新的系统调用来完成的，比如 Linux 中的<code>mmap()</code>，sendfile() 以及<code>splice()</code>等。</li>
<li>绕过内核的直接 I/O：允许在用户态进程绕过内核直接和硬件进行数据传输，内核在传输过程中只负责一些管理和辅助的工作。这种方式其实和第一种有点类似，也是试图避免用户空间和内核空间之间的数据传输，只是第一种方式是把数据传输过程放在内核态完成，而这种方式则是直接绕过内核和硬件通信，效果类似但原理完全不同。</li>
<li>内核缓冲区和用户缓冲区之间的传输优化：这种方式侧重于在用户进程的缓冲区和操作系统的页缓存之间的 CPU 拷贝的优化。这种方法延续了以往那种传统的通信方式，但更灵活。</li>
</ul>
<p>本文从虚拟内存、I/O 缓冲区，用户态&amp;内核态以及 I/O 模式等等知识点全面而又详尽地剖析了 Linux 系统的 I/O 底层原理，分析了 Linux 传统的 I/O 模式的弊端，进而引入 Linux Zero-copy 零拷贝技术的介绍和原理解析，通过将零拷贝技术和传统的 I/O 模式进行区分和对比，带领读者经历了 Linux I/O 的演化历史，通过帮助读者理解 Linux 内核对 I/O 模块的优化改进思路，相信不仅仅是让读者了解 Linux 底层系统的设计原理，更能对读者们在以后优化改进自己的程序设计过程中能够有所启发。</p>
<h1 id="poll-select-epoll剖析"><a href="#poll-select-epoll剖析" class="headerlink" title="poll select epoll剖析"></a>poll select epoll剖析</h1><p>poll/select/epoll的实现都是基于文件提供的poll方法(f_op-&gt;poll)，<br>该方法利用poll_table提供的_qproc方法向文件内部事件掩码_key对应的的一个或多个等待队列(wait_queue_head_t)上添加包含唤醒函数(wait_queue_t.func)的节点(wait_queue_t)，并检查文件当前就绪的状态返回给poll的调用者(依赖于文件的实现)。<br>当文件的状态发生改变时(例如网络数据包到达)，文件就会遍历事件对应的等待队列并调用回调函数(wait_queue_t.func)唤醒等待线程。</p>
<p>通常的file.f_ops.poll实现及相关结构体如下<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> &#123;</span>  </span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span>    *<span class="title">f_op</span>;</span>  </span><br><span class="line">    <span class="keyword">spinlock_t</span>          f_lock;  </span><br><span class="line">    <span class="comment">// 文件内部实现细节  </span></span><br><span class="line">    <span class="keyword">void</span>               *private_data;  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_EPOLL  </span></span><br><span class="line">    <span class="comment">/* Used by fs/eventpoll.c to link all the hooks to this file */</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">f_ep_links</span>;</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">f_tfile_llink</span>;</span>  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* #ifdef CONFIG_EPOLL */</span>  </span></span><br><span class="line">    <span class="comment">// 其他细节....  </span></span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 文件操作  </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> &#123;</span>  </span><br><span class="line">    <span class="comment">// 文件提供给poll/select/epoll  </span></span><br><span class="line">    <span class="comment">// 获取文件当前状态, 以及就绪通知接口函数  </span></span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*poll)</span> <span class="params">(struct file *, struct poll_table_struct *)</span></span>;  </span><br><span class="line">    <span class="comment">// 其他方法read/write 等... ...  </span></span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 通常的file.f_ops.poll 方法的实现  </span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">file_f_op_poll</span> <span class="params">(struct file *filp, struct poll_table_struct *wait)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> mask = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">wait_queue_head_t</span> * wait_queue;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//1. 根据事件掩码wait-&gt;key_和文件实现filep-&gt;private_data 取得事件掩码对应的一个或多个wait queue head  </span></span><br><span class="line">    some_code();  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 2. 调用poll_wait 向获得的wait queue head 添加节点  </span></span><br><span class="line">    poll_wait(filp, wait_queue, wait);  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 3. 取得当前就绪状态保存到mask  </span></span><br><span class="line">    some_code();  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> mask;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// select/poll/epoll 向文件注册就绪后回调节点的接口结构  </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">poll_table_struct</span> &#123;</span>  </span><br><span class="line">    <span class="comment">// 向wait_queue_head 添加回调节点(wait_queue_t)的接口函数  </span></span><br><span class="line">    poll_queue_proc _qproc;  </span><br><span class="line">    <span class="comment">// 关注的事件掩码, 文件的实现利用此掩码将等待队列传递给_qproc  </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>   _key;  </span><br><span class="line">&#125; poll_table;  </span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*poll_queue_proc)</span><span class="params">(struct file *, <span class="keyword">wait_queue_head_t</span> *, struct poll_table_struct *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通用的poll_wait 函数, 文件的f_ops-&gt;poll 通常会调用此函数  </span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">poll_wait</span><span class="params">(struct file * filp, <span class="keyword">wait_queue_head_t</span> * wait_address, poll_table *p)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (p &amp;&amp; p-&gt;_qproc &amp;&amp; wait_address) &#123;  </span><br><span class="line">        <span class="comment">// 调用_qproc 在wait_address 上添加节点和回调函数  </span></span><br><span class="line">        <span class="comment">// 调用 poll_table_struct 上的函数指针向wait_address添加节点, 并设置节点的func  </span></span><br><span class="line">        <span class="comment">// (如果是select或poll 则是 __pollwait, 如果是 epoll 则是 ep_ptable_queue_proc),  </span></span><br><span class="line">        p-&gt;_qproc(filp, wait_address, p);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// wait_queue 头节点  </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">wait_queue_head</span> <span class="title">wait_queue_head_t</span>;</span>  </span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">wait_queue_head</span> &#123;</span>  </span><br><span class="line">    <span class="keyword">spinlock_t</span> lock;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">task_list</span>;</span>  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// wait_queue 节点  </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">wait_queue</span> <span class="title">wait_queue_t</span>;</span>  </span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">wait_queue</span> &#123;</span>  </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> flags;  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WQ_FLAG_EXCLUSIVE   0x01  </span></span><br><span class="line">    <span class="keyword">void</span> *<span class="keyword">private</span>;  </span><br><span class="line">    <span class="keyword">wait_queue_func_t</span> func;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">task_list</span>;</span>  </span><br><span class="line">&#125;;  </span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*<span class="keyword">wait_queue_func_t</span>)</span><span class="params">(<span class="keyword">wait_queue_t</span> *wait, <span class="keyword">unsigned</span> mode, <span class="keyword">int</span> flags, <span class="keyword">void</span> *key)</span></span>;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 当文件的状态发生改变时, 文件会调用此函数，此函数通过调用wait_queue_t.func通知poll的调用者  </span></span><br><span class="line"><span class="comment">// 其中key是文件当前的事件掩码  </span></span><br><span class="line"><span class="keyword">void</span> __wake_up(<span class="keyword">wait_queue_head_t</span> *q, <span class="keyword">unsigned</span> <span class="keyword">int</span> mode,  </span><br><span class="line">               <span class="keyword">int</span> nr_exclusive, <span class="keyword">void</span> *key)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;  </span><br><span class="line">  </span><br><span class="line">    spin_lock_irqsave(&amp;q-&gt;lock, flags);  </span><br><span class="line">    __wake_up_common(q, mode, nr_exclusive, <span class="number">0</span>, key);  </span><br><span class="line">    spin_unlock_irqrestore(&amp;q-&gt;lock, flags);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __wake_up_common(<span class="keyword">wait_queue_head_t</span> *q, <span class="keyword">unsigned</span> <span class="keyword">int</span> mode,  </span><br><span class="line">                             <span class="keyword">int</span> nr_exclusive, <span class="keyword">int</span> wake_flags, <span class="keyword">void</span> *key)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">wait_queue_t</span> *curr, *next;  </span><br><span class="line">    <span class="comment">// 遍历并调用func 唤醒, 通常func会唤醒调用poll的线程  </span></span><br><span class="line">    list_for_each_entry_safe(curr, next, &amp;q-&gt;task_list, task_list) &#123;  </span><br><span class="line">        <span class="keyword">unsigned</span> flags = curr-&gt;flags;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (curr-&gt;func(curr, mode, wake_flags, key) &amp;&amp;  </span><br><span class="line">                (flags &amp; WQ_FLAG_EXCLUSIVE) &amp;&amp; !--nr_exclusive) &#123;  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="poll-和-select"><a href="#poll-和-select" class="headerlink" title="poll 和 select"></a>poll 和 select</h2><p>poll和select的实现基本上是一致的，只是传递参数有所不同，他们的基本流程如下：</p>
<ol>
<li>复制用户数据到内核空间</li>
<li>估计超时时间</li>
<li>遍历每个文件并调用f_op-&gt;poll 取得文件当前就绪状态， 如果前面遍历的文件都没有就绪，向文件插入wait_queue节点</li>
<li>遍历完成后检查状态：<pre><code> a). 如果已经有就绪的文件转到5；
 b). 如果有信号产生，重启poll或select（转到 1或3）；
 c). 否则挂起进程等待超时或唤醒，超时或被唤醒后再次遍历所有文件取得每个文件的就绪状态
</code></pre></li>
<li>将所有文件的就绪状态复制到用户空间</li>
<li>清理申请的资源</li>
</ol>
<h3 id="关键结构体"><a href="#关键结构体" class="headerlink" title="关键结构体"></a>关键结构体</h3><p>下面是poll/select共用的结构体及其相关功能:</p>
<p>poll_wqueues 是 select/poll 对poll_table接口的具体化实现,其中的table, inline_index和inline_entries都是为了管理内存。<br>poll_table_entry 与一个文件相关联，用于管理插入到文件的wait_queue节点。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// select/poll 对poll_table的具体化实现  </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">poll_wqueues</span> &#123;</span>  </span><br><span class="line">    poll_table pt;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">poll_table_page</span> *<span class="title">table</span>;</span>     <span class="comment">// 如果inline_entries 空间不足, 从poll_table_page 中分配  </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">polling_task</span>;</span>  <span class="comment">// 调用poll 或select 的进程  </span></span><br><span class="line">    <span class="keyword">int</span> triggered;                     <span class="comment">// 已触发标记  </span></span><br><span class="line">    <span class="keyword">int</span> error;  </span><br><span class="line">    <span class="keyword">int</span> inline_index;                  <span class="comment">// 下一个要分配的inline_entrie 索引  </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">poll_table_entry</span> <span class="title">inline_entries</span>[<span class="title">N_INLINE_POLL_ENTRIES</span>];</span><span class="comment">//  </span></span><br><span class="line">&#125;;  </span><br><span class="line"><span class="comment">// 帮助管理select/poll  申请的内存  </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">poll_table_page</span> &#123;</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">poll_table_page</span>  * <span class="title">next</span>;</span>       <span class="comment">// 下一个 page  </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">poll_table_entry</span> * <span class="title">entry</span>;</span>      <span class="comment">// 指向第一个entries  </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">poll_table_entry</span> <span class="title">entries</span>[0];</span>  </span><br><span class="line">&#125;;  </span><br><span class="line"><span class="comment">// 与一个正在poll /select 的文件相关联,  </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">poll_table_entry</span> &#123;</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">filp</span>;</span>               <span class="comment">// 在poll/select中的文件  </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> key;  </span><br><span class="line">    <span class="keyword">wait_queue_t</span> wait;               <span class="comment">// 插入到wait_queue_head_t 的节点  </span></span><br><span class="line">    <span class="keyword">wait_queue_head_t</span> *wait_address; <span class="comment">// 文件上的wait_queue_head_t 地址  </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="公共函数"><a href="#公共函数" class="headerlink" title="公共函数"></a>公共函数</h3><p>下面是poll/select公用的一些函数，这些函数实现了poll和select的核心功能。</p>
<p>poll_initwait 用于初始化poll_wqueues，</p>
<p>__pollwait 实现了向文件中添加回调节点的逻辑，</p>
<p>pollwake 当文件状态发生改变时，由文件调用，用来唤醒线程，</p>
<p>poll_get_entry，free_poll_entry，poll_freewait用来申请释放poll_table_entry 占用的内存，并负责释放文件上的wait_queue节点。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// poll_wqueues 的初始化:  </span></span><br><span class="line"><span class="comment">// 初始化 poll_wqueues , __pollwait会在文件就绪时被调用  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">poll_initwait</span><span class="params">(struct poll_wqueues *pwq)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="comment">// 初始化poll_table, 相当于调用基类的构造函数  </span></span><br><span class="line">    init_poll_funcptr(&amp;pwq-&gt;pt, __pollwait);  </span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * static inline void init_poll_funcptr(poll_table *pt, poll_queue_proc qproc) </span></span><br><span class="line"><span class="comment">     * &#123; </span></span><br><span class="line"><span class="comment">     *     pt-&gt;_qproc = qproc; </span></span><br><span class="line"><span class="comment">     *     pt-&gt;_key   = ~0UL; </span></span><br><span class="line"><span class="comment">     * &#125; </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    pwq-&gt;polling_task = current;  </span><br><span class="line">    pwq-&gt;triggered = <span class="number">0</span>;  </span><br><span class="line">    pwq-&gt;error = <span class="number">0</span>;  </span><br><span class="line">    pwq-&gt;table = <span class="literal">NULL</span>;  </span><br><span class="line">    pwq-&gt;inline_index = <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// wait_queue设置函数  </span></span><br><span class="line"><span class="comment">// poll/select 向文件wait_queue中添加节点的方法  </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __pollwait(struct file *filp, <span class="keyword">wait_queue_head_t</span> *wait_address,  </span><br><span class="line">                       poll_table *p)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">poll_wqueues</span> *<span class="title">pwq</span> = <span class="title">container_of</span>(<span class="title">p</span>, <span class="title">struct</span> <span class="title">poll_wqueues</span>, <span class="title">pt</span>);</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">poll_table_entry</span> *<span class="title">entry</span> = <span class="title">poll_get_entry</span>(<span class="title">pwq</span>);</span>  </span><br><span class="line">    <span class="keyword">if</span> (!entry) &#123;  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    get_file(filp); <span class="comment">//put_file() in free_poll_entry()  </span></span><br><span class="line">    entry-&gt;filp = filp;  </span><br><span class="line">    entry-&gt;wait_address = wait_address; <span class="comment">// 等待队列头  </span></span><br><span class="line">    entry-&gt;key = p-&gt;key;  </span><br><span class="line">    <span class="comment">// 设置回调为 pollwake  </span></span><br><span class="line">    init_waitqueue_func_entry(&amp;entry-&gt;wait, pollwake);  </span><br><span class="line">    entry-&gt;wait.<span class="keyword">private</span> = pwq;  </span><br><span class="line">    <span class="comment">// 添加到等待队列  </span></span><br><span class="line">    add_wait_queue(wait_address, &amp;entry-&gt;wait);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 在等待队列(wait_queue_t)上回调函数(func)  </span></span><br><span class="line"><span class="comment">// 文件就绪后被调用，唤醒调用进程，其中key是文件提供的当前状态掩码  </span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">pollwake</span><span class="params">(<span class="keyword">wait_queue_t</span> *wait, <span class="keyword">unsigned</span> mode, <span class="keyword">int</span> sync, <span class="keyword">void</span> *key)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">poll_table_entry</span> *<span class="title">entry</span>;</span>  </span><br><span class="line">    <span class="comment">// 取得文件对应的poll_table_entry  </span></span><br><span class="line">    entry = container_of(wait, struct poll_table_entry, wait);  </span><br><span class="line">    <span class="comment">// 过滤不关注的事件  </span></span><br><span class="line">    <span class="keyword">if</span> (key &amp;&amp; !((<span class="keyword">unsigned</span> <span class="keyword">long</span>)key &amp; entry-&gt;key)) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 唤醒  </span></span><br><span class="line">    <span class="keyword">return</span> __pollwake(wait, mode, sync, key);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __pollwake(<span class="keyword">wait_queue_t</span> *wait, <span class="keyword">unsigned</span> mode, <span class="keyword">int</span> sync, <span class="keyword">void</span> *key)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">poll_wqueues</span> *<span class="title">pwq</span> = <span class="title">wait</span>-&gt;<span class="title">private</span>;</span>  </span><br><span class="line">    <span class="comment">// 将调用进程 pwq-&gt;polling_task 关联到 dummy_wait  </span></span><br><span class="line">    DECLARE_WAITQUEUE(dummy_wait, pwq-&gt;polling_task);  </span><br><span class="line">    smp_wmb();  </span><br><span class="line">    pwq-&gt;triggered = <span class="number">1</span>;<span class="comment">// 标记为已触发  </span></span><br><span class="line">    <span class="comment">// 唤醒调用进程  </span></span><br><span class="line">    <span class="keyword">return</span> default_wake_function(&amp;dummy_wait, mode, sync, key);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 默认的唤醒函数,poll/select 设置的回调函数会调用此函数唤醒  </span></span><br><span class="line"><span class="comment">// 直接唤醒等待队列上的线程,即将线程移到运行队列(rq)  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">default_wake_function</span><span class="params">(<span class="keyword">wait_queue_t</span> *curr, <span class="keyword">unsigned</span> mode, <span class="keyword">int</span> wake_flags,  </span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">void</span> *key)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="comment">// 这个函数比较复杂, 这里就不具体分析了  </span></span><br><span class="line">    <span class="keyword">return</span> try_to_wake_up(curr-&gt;<span class="keyword">private</span>, mode, wake_flags);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>poll，select对poll_table_entry的申请和释放采用的是类似内存池的管理方式，先使用预分配的空间，预分配的空间不足时，分配一个内存页，使用内存页上的空间。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分配或使用已先前申请的 poll_table_entry,  </span></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct poll_table_entry *<span class="title">poll_get_entry</span><span class="params">(struct poll_wqueues *p)</span> </span>&#123;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">poll_table_page</span> *<span class="title">table</span> = <span class="title">p</span>-&gt;<span class="title">table</span>;</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (p-&gt;inline_index &lt; N_INLINE_POLL_ENTRIES) &#123;  </span><br><span class="line">        <span class="keyword">return</span> p-&gt;inline_entries + p-&gt;inline_index++;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (!table || POLL_TABLE_FULL(table)) &#123;  </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">poll_table_page</span> *<span class="title">new_table</span>;</span>  </span><br><span class="line">        new_table = (struct poll_table_page *) __get_free_page(GFP_KERNEL);  </span><br><span class="line">        <span class="keyword">if</span> (!new_table) &#123;  </span><br><span class="line">            p-&gt;error = -ENOMEM;  </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        new_table-&gt;entry = new_table-&gt;entries;  </span><br><span class="line">        new_table-&gt;next = table;  </span><br><span class="line">        p-&gt;table = new_table;  </span><br><span class="line">        table = new_table;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> table-&gt;entry++;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 清理poll_wqueues 占用的资源  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">poll_freewait</span><span class="params">(struct poll_wqueues *pwq)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">poll_table_page</span> * <span class="title">p</span> = <span class="title">pwq</span>-&gt;<span class="title">table</span>;</span>  </span><br><span class="line">    <span class="comment">// 遍历所有已分配的inline poll_table_entry  </span></span><br><span class="line">    <span class="keyword">int</span> i;  </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pwq-&gt;inline_index; i++) &#123;  </span><br><span class="line">        free_poll_entry(pwq-&gt;inline_entries + i);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 遍历在poll_table_page上分配的inline poll_table_entry  </span></span><br><span class="line">    <span class="comment">// 并释放poll_table_page  </span></span><br><span class="line">    <span class="keyword">while</span> (p) &#123;  </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">poll_table_entry</span> * <span class="title">entry</span>;</span>  </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">poll_table_page</span> *<span class="title">old</span>;</span>  </span><br><span class="line">        entry = p-&gt;entry;  </span><br><span class="line">        <span class="keyword">do</span> &#123;  </span><br><span class="line">            entry--;  </span><br><span class="line">            free_poll_entry(entry);  </span><br><span class="line">        &#125; <span class="keyword">while</span> (entry &gt; p-&gt;entries);  </span><br><span class="line">        old = p;  </span><br><span class="line">        p = p-&gt;next;  </span><br><span class="line">        free_page((<span class="keyword">unsigned</span> <span class="keyword">long</span>) old);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">free_poll_entry</span><span class="params">(struct poll_table_entry *entry)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="comment">// 从等待队列中删除, 释放文件引用计数  </span></span><br><span class="line">    remove_wait_queue(entry-&gt;wait_address, &amp;entry-&gt;wait);  </span><br><span class="line">    fput(entry-&gt;filp);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="poll-select核心结构关系"><a href="#poll-select核心结构关系" class="headerlink" title="poll/select核心结构关系"></a>poll/select核心结构关系</h3><p>下图是 poll/select 实现公共部分的关系图，包含了与文件直接的关系，以及函数之间的依赖。<br><img src="/img/78608ad5-89dd-319b-8c50-d7fa341ba9da.bmp" alt></p>
<h2 id="poll的实现"><a href="#poll的实现" class="headerlink" title="poll的实现"></a>poll的实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// poll 使用的结构体  </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span>  </span><br><span class="line">    <span class="keyword">int</span> fd;        <span class="comment">// 描述符  </span></span><br><span class="line">    <span class="keyword">short</span> events;  <span class="comment">// 关注的事件掩码  </span></span><br><span class="line">    <span class="keyword">short</span> revents; <span class="comment">// 返回的事件掩码  </span></span><br><span class="line">&#125;;  </span><br><span class="line"><span class="comment">// long sys_poll(struct pollfd *ufds, unsigned int nfds, long timeout_msecs)  </span></span><br><span class="line">SYSCALL_DEFINE3(poll, struct pollfd __user *, ufds, <span class="keyword">unsigned</span> <span class="keyword">int</span>, nfds,  </span><br><span class="line">                <span class="keyword">long</span>, timeout_msecs)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">end_time</span>, *<span class="title">to</span> = <span class="title">NULL</span>;</span>  </span><br><span class="line">    <span class="keyword">int</span> ret;  </span><br><span class="line">    <span class="keyword">if</span> (timeout_msecs &gt;= <span class="number">0</span>) &#123;  </span><br><span class="line">        to = &amp;end_time;  </span><br><span class="line">        <span class="comment">// 将相对超时时间msec 转化为绝对时间  </span></span><br><span class="line">        poll_select_set_timeout(to, timeout_msecs / MSEC_PER_SEC,  </span><br><span class="line">                                NSEC_PER_MSEC * (timeout_msecs % MSEC_PER_SEC));  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// do sys poll  </span></span><br><span class="line">    ret = do_sys_poll(ufds, nfds, to);  </span><br><span class="line">    <span class="comment">// do_sys_poll 被信号中断, 重新调用, 对使用者来说 poll 是不会被信号中断的.  </span></span><br><span class="line">    <span class="keyword">if</span> (ret == -EINTR) &#123;  </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">restart_block</span> *<span class="title">restart_block</span>;</span>  </span><br><span class="line">        restart_block = &amp;current_thread_info()-&gt;restart_block;  </span><br><span class="line">        restart_block-&gt;fn = do_restart_poll; <span class="comment">// 设置重启的函数  </span></span><br><span class="line">        restart_block-&gt;poll.ufds = ufds;  </span><br><span class="line">        restart_block-&gt;poll.nfds = nfds;  </span><br><span class="line">        <span class="keyword">if</span> (timeout_msecs &gt;= <span class="number">0</span>) &#123;  </span><br><span class="line">            restart_block-&gt;poll.tv_sec = end_time.tv_sec;  </span><br><span class="line">            restart_block-&gt;poll.tv_nsec = end_time.tv_nsec;  </span><br><span class="line">            restart_block-&gt;poll.has_timeout = <span class="number">1</span>;  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            restart_block-&gt;poll.has_timeout = <span class="number">0</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">// ERESTART_RESTARTBLOCK 不会返回给用户进程,  </span></span><br><span class="line">        <span class="comment">// 而是会被系统捕获, 然后调用 do_restart_poll,  </span></span><br><span class="line">        ret = -ERESTART_RESTARTBLOCK;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> ret;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_sys_poll</span><span class="params">(struct pollfd __user *ufds, <span class="keyword">unsigned</span> <span class="keyword">int</span> nfds,  </span></span></span><br><span class="line"><span class="function"><span class="params">                struct timespec *end_time)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">poll_wqueues</span> <span class="title">table</span>;</span>  </span><br><span class="line">    <span class="keyword">int</span> err = -EFAULT, fdcount, len, size;  </span><br><span class="line">    <span class="comment">/* 首先使用栈上的空间，节约内存，加速访问 */</span>  </span><br><span class="line">    <span class="keyword">long</span> stack_pps[POLL_STACK_ALLOC/<span class="keyword">sizeof</span>(<span class="keyword">long</span>)];  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">poll_list</span> *<span class="title">const</span> <span class="title">head</span> = (<span class="title">struct</span> <span class="title">poll_list</span> *)<span class="title">stack_pps</span>;</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">poll_list</span> *<span class="title">walk</span> = <span class="title">head</span>;</span>  </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> todo = nfds;  </span><br><span class="line">    <span class="keyword">if</span> (nfds &gt; rlimit(RLIMIT_NOFILE)) &#123;  </span><br><span class="line">        <span class="comment">// 文件描述符数量超过当前进程限制  </span></span><br><span class="line">        <span class="keyword">return</span> -EINVAL;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 复制用户空间数据到内核  </span></span><br><span class="line">    len = <span class="keyword">min_t</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span>, nfds, N_STACK_PPS);  </span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;  </span><br><span class="line">        walk-&gt;next = <span class="literal">NULL</span>;  </span><br><span class="line">        walk-&gt;len = len;  </span><br><span class="line">        <span class="keyword">if</span> (!len) &#123;  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">// 复制到当前的 entries  </span></span><br><span class="line">        <span class="keyword">if</span> (copy_from_user(walk-&gt;entries, ufds + nfds-todo,  </span><br><span class="line">                           <span class="keyword">sizeof</span>(struct pollfd) * walk-&gt;len)) &#123;  </span><br><span class="line">            <span class="keyword">goto</span> out_fds;  </span><br><span class="line">        &#125;  </span><br><span class="line">        todo -= walk-&gt;len;  </span><br><span class="line">        <span class="keyword">if</span> (!todo) &#123;  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">// 栈上空间不足，在堆上申请剩余部分  </span></span><br><span class="line">        len = min(todo, POLLFD_PER_PAGE);  </span><br><span class="line">        size = <span class="keyword">sizeof</span>(struct poll_list) + <span class="keyword">sizeof</span>(struct pollfd) * len;  </span><br><span class="line">        walk = walk-&gt;next = kmalloc(size, GFP_KERNEL);  </span><br><span class="line">        <span class="keyword">if</span> (!walk) &#123;  </span><br><span class="line">            err = -ENOMEM;  </span><br><span class="line">            <span class="keyword">goto</span> out_fds;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 初始化 poll_wqueues 结构, 设置函数指针_qproc  为__pollwait  </span></span><br><span class="line">    poll_initwait(&amp;table);  </span><br><span class="line">    <span class="comment">// poll  </span></span><br><span class="line">    fdcount = do_poll(nfds, head, &amp;table, end_time);  </span><br><span class="line">    <span class="comment">// 从文件wait queue 中移除对应的节点, 释放entry.  </span></span><br><span class="line">    poll_freewait(&amp;table);  </span><br><span class="line">    <span class="comment">// 复制结果到用户空间  </span></span><br><span class="line">    <span class="keyword">for</span> (walk = head; walk; walk = walk-&gt;next) &#123;  </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> *<span class="title">fds</span> = <span class="title">walk</span>-&gt;<span class="title">entries</span>;</span>  </span><br><span class="line">        <span class="keyword">int</span> j;  </span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; len; j++, ufds++)  </span><br><span class="line">            <span class="keyword">if</span> (__put_user(fds[j].revents, &amp;ufds-&gt;revents)) &#123;  </span><br><span class="line">                <span class="keyword">goto</span> out_fds;  </span><br><span class="line">            &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    err = fdcount;  </span><br><span class="line">out_fds:  </span><br><span class="line">    <span class="comment">// 释放申请的内存  </span></span><br><span class="line">    walk = head-&gt;next;  </span><br><span class="line">    <span class="keyword">while</span> (walk) &#123;  </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">poll_list</span> *<span class="title">pos</span> = <span class="title">walk</span>;</span>  </span><br><span class="line">        walk = walk-&gt;next;  </span><br><span class="line">        kfree(pos);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> err;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// 真正的处理函数  </span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">do_poll</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> nfds,  struct poll_list *<span class="built_in">list</span>,  </span></span></span><br><span class="line"><span class="function"><span class="params">                   struct poll_wqueues *wait, struct timespec *end_time)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    poll_table* pt = &amp;wait-&gt;pt;  </span><br><span class="line">    <span class="keyword">ktime_t</span> expire, *to = <span class="literal">NULL</span>;  </span><br><span class="line">    <span class="keyword">int</span> timed_out = <span class="number">0</span>, count = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> slack = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">if</span> (end_time &amp;&amp; !end_time-&gt;tv_sec &amp;&amp; !end_time-&gt;tv_nsec) &#123;  </span><br><span class="line">        <span class="comment">// 已经超时,直接遍历所有文件描述符, 然后返回  </span></span><br><span class="line">        pt = <span class="literal">NULL</span>;  </span><br><span class="line">        timed_out = <span class="number">1</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (end_time &amp;&amp; !timed_out) &#123;  </span><br><span class="line">        <span class="comment">// 估计进程等待时间，纳秒  </span></span><br><span class="line">        slack = select_estimate_accuracy(end_time);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 遍历文件，为每个文件的等待队列添加唤醒函数(pollwake)  </span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;  </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">poll_list</span> *<span class="title">walk</span>;</span>  </span><br><span class="line">        <span class="keyword">for</span> (walk = <span class="built_in">list</span>; walk != <span class="literal">NULL</span>; walk = walk-&gt;next) &#123;  </span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> * <span class="title">pfd</span>, * <span class="title">pfd_end</span>;</span>  </span><br><span class="line">            pfd = walk-&gt;entries;  </span><br><span class="line">            pfd_end = pfd + walk-&gt;len;  </span><br><span class="line">            <span class="keyword">for</span> (; pfd != pfd_end; pfd++) &#123;  </span><br><span class="line">                <span class="comment">// do_pollfd 会向文件对应的wait queue 中添加节点  </span></span><br><span class="line">                <span class="comment">// 和回调函数(如果 pt 不为空)  </span></span><br><span class="line">                <span class="comment">// 并检查当前文件状态并设置返回的掩码  </span></span><br><span class="line">                <span class="keyword">if</span> (do_pollfd(pfd, pt)) &#123;  </span><br><span class="line">                    <span class="comment">// 该文件已经准备好了.  </span></span><br><span class="line">                    <span class="comment">// 不需要向后面文件的wait queue 中添加唤醒函数了.  </span></span><br><span class="line">                    count++;  </span><br><span class="line">                    pt = <span class="literal">NULL</span>;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">// 下次循环的时候不需要向文件的wait queue 中添加节点,  </span></span><br><span class="line">        <span class="comment">// 因为前面的循环已经把该添加的都添加了  </span></span><br><span class="line">        pt = <span class="literal">NULL</span>;  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 第一次遍历没有发现ready的文件  </span></span><br><span class="line">        <span class="keyword">if</span> (!count) &#123;  </span><br><span class="line">            count = wait-&gt;error;  </span><br><span class="line">            <span class="comment">// 有信号产生  </span></span><br><span class="line">            <span class="keyword">if</span> (signal_pending(current)) &#123;  </span><br><span class="line">                count = -EINTR;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 有ready的文件或已经超时  </span></span><br><span class="line">        <span class="keyword">if</span> (count || timed_out) &#123;  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">// 转换为内核时间  </span></span><br><span class="line">        <span class="keyword">if</span> (end_time &amp;&amp; !to) &#123;  </span><br><span class="line">            expire = timespec_to_ktime(*end_time);  </span><br><span class="line">            to = &amp;expire;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">// 等待事件就绪, 如果有事件发生或超时，就再循  </span></span><br><span class="line">        <span class="comment">// 环一遍，取得事件状态掩码并计数,  </span></span><br><span class="line">        <span class="comment">// 注意此次循环中, 文件 wait queue 中的节点依然存在  </span></span><br><span class="line">        <span class="keyword">if</span> (!poll_schedule_timeout(wait, TASK_INTERRUPTIBLE, to, slack)) &#123;  </span><br><span class="line">            timed_out = <span class="number">1</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> count;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">do_pollfd</span><span class="params">(struct pollfd *pollfd, poll_table *pwait)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> mask;  </span><br><span class="line">    <span class="keyword">int</span> fd;  </span><br><span class="line">    mask = <span class="number">0</span>;  </span><br><span class="line">    fd = pollfd-&gt;fd;  </span><br><span class="line">    <span class="keyword">if</span> (fd &gt;= <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="keyword">int</span> fput_needed;  </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">file</span> * <span class="title">file</span>;</span>  </span><br><span class="line">        <span class="comment">// 取得fd对应的文件结构体  </span></span><br><span class="line">        file = fget_light(fd, &amp;fput_needed);  </span><br><span class="line">        mask = POLLNVAL;  </span><br><span class="line">        <span class="keyword">if</span> (file != <span class="literal">NULL</span>) &#123;  </span><br><span class="line">            <span class="comment">// 如果没有 f_op 或 f_op-&gt;poll 则认为文件始终处于就绪状态.  </span></span><br><span class="line">            mask = DEFAULT_POLLMASK;  </span><br><span class="line">            <span class="keyword">if</span> (file-&gt;f_op &amp;&amp; file-&gt;f_op-&gt;poll) &#123;  </span><br><span class="line">                <span class="keyword">if</span> (pwait) &#123;  </span><br><span class="line">                    <span class="comment">// 设置关注的事件掩码  </span></span><br><span class="line">                    pwait-&gt;key = pollfd-&gt;events | POLLERR | POLLHUP;  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="comment">// 注册回调函数，并返回当前就绪状态，就绪后会调用pollwake  </span></span><br><span class="line">                mask = file-&gt;f_op-&gt;poll(file, pwait);  </span><br><span class="line">            &#125;  </span><br><span class="line">            mask &amp;= pollfd-&gt;events | POLLERR | POLLHUP; <span class="comment">// 移除不需要的状态掩码  </span></span><br><span class="line">            fput_light(file, fput_needed);<span class="comment">// 释放文件  </span></span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    pollfd-&gt;revents = mask; <span class="comment">// 更新事件状态  </span></span><br><span class="line">    <span class="keyword">return</span> mask;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">do_restart_poll</span><span class="params">(struct restart_block *restart_block)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> __<span class="title">user</span> *<span class="title">ufds</span> = <span class="title">restart_block</span>-&gt;<span class="title">poll</span>.<span class="title">ufds</span>;</span>  </span><br><span class="line">    <span class="keyword">int</span> nfds = restart_block-&gt;poll.nfds;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> *<span class="title">to</span> = <span class="title">NULL</span>, <span class="title">end_time</span>;</span>  </span><br><span class="line">    <span class="keyword">int</span> ret;  </span><br><span class="line">    <span class="keyword">if</span> (restart_block-&gt;poll.has_timeout) &#123;  </span><br><span class="line">        <span class="comment">// 获取先前的超时时间  </span></span><br><span class="line">        end_time.tv_sec = restart_block-&gt;poll.tv_sec;  </span><br><span class="line">        end_time.tv_nsec = restart_block-&gt;poll.tv_nsec;  </span><br><span class="line">        to = &amp;end_time;  </span><br><span class="line">    &#125;  </span><br><span class="line">    ret = do_sys_poll(ufds, nfds, to); <span class="comment">// 重新调用 do_sys_poll  </span></span><br><span class="line">    <span class="keyword">if</span> (ret == -EINTR) &#123;  </span><br><span class="line">        <span class="comment">// 又被信号中断了, 再次重启  </span></span><br><span class="line">        restart_block-&gt;fn = do_restart_poll;  </span><br><span class="line">        ret = -ERESTART_RESTARTBLOCK;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> ret;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="select-实现"><a href="#select-实现" class="headerlink" title="select 实现"></a>select 实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>  </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *in, *out, *ex;  </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *res_in, *res_out, *res_ex;  </span><br><span class="line">&#125; fd_set_bits;  </span><br><span class="line"><span class="comment">//  long sys_select(int n, fd_set *inp, fd_set *outp, fd_set *exp, struct timeval *tvp)  </span></span><br><span class="line">SYSCALL_DEFINE5(select, <span class="keyword">int</span>, n, fd_set __user *, inp, fd_set __user *, outp,  </span><br><span class="line">                fd_set __user *, <span class="built_in">exp</span>, struct timeval __user *, tvp)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">end_time</span>, *<span class="title">to</span> = <span class="title">NULL</span>;</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span>  </span><br><span class="line">    <span class="keyword">int</span> ret;  </span><br><span class="line">    <span class="keyword">if</span> (tvp) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (copy_from_user(&amp;tv, tvp, <span class="keyword">sizeof</span>(tv))) &#123;  </span><br><span class="line">            <span class="keyword">return</span> -EFAULT;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">// 计算超时时间  </span></span><br><span class="line">        to = &amp;end_time;  </span><br><span class="line">        <span class="keyword">if</span> (poll_select_set_timeout(to,  </span><br><span class="line">                                    tv.tv_sec + (tv.tv_usec / USEC_PER_SEC),  </span><br><span class="line">                                    (tv.tv_usec % USEC_PER_SEC) * NSEC_PER_USEC)) &#123;  </span><br><span class="line">            <span class="keyword">return</span> -EINVAL;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    ret = core_sys_select(n, inp, outp, <span class="built_in">exp</span>, to);  </span><br><span class="line">    <span class="comment">// 复制剩余时间到用户空间  </span></span><br><span class="line">    ret = poll_select_copy_remaining(&amp;end_time, tvp, <span class="number">1</span>, ret);  </span><br><span class="line">    <span class="keyword">return</span> ret;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">core_sys_select</span><span class="params">(<span class="keyword">int</span> n, fd_set __user *inp, fd_set __user *outp,  </span></span></span><br><span class="line"><span class="function"><span class="params">                    fd_set __user *<span class="built_in">exp</span>, struct timespec *end_time)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    fd_set_bits fds;  </span><br><span class="line">    <span class="keyword">void</span> *bits;  </span><br><span class="line">    <span class="keyword">int</span> ret, max_fds;  </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> size;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fdtable</span> *<span class="title">fdt</span>;</span>  </span><br><span class="line">    <span class="comment">//小对象使用栈上的空间,节约内存, 加快访问速度  </span></span><br><span class="line">    <span class="keyword">long</span> stack_fds[SELECT_STACK_ALLOC/<span class="keyword">sizeof</span>(<span class="keyword">long</span>)];  </span><br><span class="line">  </span><br><span class="line">    ret = -EINVAL;  </span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="keyword">goto</span> out_nofds;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    rcu_read_lock();  </span><br><span class="line">    <span class="comment">// 取得进程对应的 fdtable  </span></span><br><span class="line">    fdt = files_fdtable(current-&gt;files);  </span><br><span class="line">    max_fds = fdt-&gt;max_fds;  </span><br><span class="line">    rcu_read_unlock();  </span><br><span class="line">    <span class="keyword">if</span> (n &gt; max_fds) &#123;  </span><br><span class="line">        n = max_fds;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    size = FDS_BYTES(n);  </span><br><span class="line">    bits = stack_fds;  </span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="keyword">sizeof</span>(stack_fds) / <span class="number">6</span>) &#123;  </span><br><span class="line">        <span class="comment">// 栈上的空间不够, 申请内存, 全部使用堆上的空间  </span></span><br><span class="line">        ret = -ENOMEM;  </span><br><span class="line">        bits = kmalloc(<span class="number">6</span> * size, GFP_KERNEL);  </span><br><span class="line">        <span class="keyword">if</span> (!bits) &#123;  </span><br><span class="line">            <span class="keyword">goto</span> out_nofds;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    fds.in     = bits;  </span><br><span class="line">    fds.out    = bits +   size;  </span><br><span class="line">    fds.ex     = bits + <span class="number">2</span>*size;  </span><br><span class="line">    fds.res_in  = bits + <span class="number">3</span>*size;  </span><br><span class="line">    fds.res_out = bits + <span class="number">4</span>*size;  </span><br><span class="line">    fds.res_ex  = bits + <span class="number">5</span>*size;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 复制用户空间到内核  </span></span><br><span class="line">    <span class="keyword">if</span> ((ret = get_fd_set(n, inp, fds.in)) ||  </span><br><span class="line">            (ret = get_fd_set(n, outp, fds.out)) ||  </span><br><span class="line">            (ret = get_fd_set(n, <span class="built_in">exp</span>, fds.ex))) &#123;  </span><br><span class="line">        <span class="keyword">goto</span> out;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 初始化fd set  </span></span><br><span class="line">    zero_fd_set(n, fds.res_in);  </span><br><span class="line">    zero_fd_set(n, fds.res_out);  </span><br><span class="line">    zero_fd_set(n, fds.res_ex);  </span><br><span class="line">  </span><br><span class="line">    ret = do_select(n, &amp;fds, end_time);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="keyword">goto</span> out;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (!ret) &#123;  </span><br><span class="line">        <span class="comment">// 该返回值会被系统捕获, 并以同样的参数重新调用sys_select()  </span></span><br><span class="line">        ret = -ERESTARTNOHAND;  </span><br><span class="line">        <span class="keyword">if</span> (signal_pending(current)) &#123;  </span><br><span class="line">            <span class="keyword">goto</span> out;  </span><br><span class="line">        &#125;  </span><br><span class="line">        ret = <span class="number">0</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 复制到用户空间  </span></span><br><span class="line">    <span class="keyword">if</span> (set_fd_set(n, inp, fds.res_in) ||  </span><br><span class="line">            set_fd_set(n, outp, fds.res_out) ||  </span><br><span class="line">            set_fd_set(n, <span class="built_in">exp</span>, fds.res_ex)) &#123;  </span><br><span class="line">        ret = -EFAULT;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">out:  </span><br><span class="line">    <span class="keyword">if</span> (bits != stack_fds) &#123;  </span><br><span class="line">        kfree(bits);  </span><br><span class="line">    &#125;  </span><br><span class="line">out_nofds:  </span><br><span class="line">    <span class="keyword">return</span> ret;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_select</span><span class="params">(<span class="keyword">int</span> n, fd_set_bits *fds, struct timespec *end_time)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">ktime_t</span> expire, *to = <span class="literal">NULL</span>;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">poll_wqueues</span> <span class="title">table</span>;</span>  </span><br><span class="line">    poll_table *wait;  </span><br><span class="line">    <span class="keyword">int</span> retval, i, timed_out = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> slack = <span class="number">0</span>;  </span><br><span class="line">  </span><br><span class="line">    rcu_read_lock();  </span><br><span class="line">    <span class="comment">// 检查fds中fd的有效性, 并获取当前最大的fd  </span></span><br><span class="line">    retval = max_select_fd(n, fds);  </span><br><span class="line">    rcu_read_unlock();  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (retval &lt; <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> retval;  </span><br><span class="line">    &#125;  </span><br><span class="line">    n = retval;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 初始化 poll_wqueues 结构, 设置函数指针_qproc    为__pollwait  </span></span><br><span class="line">    poll_initwait(&amp;table);  </span><br><span class="line">    wait = &amp;table.pt;  </span><br><span class="line">    <span class="keyword">if</span> (end_time &amp;&amp; !end_time-&gt;tv_sec &amp;&amp; !end_time-&gt;tv_nsec) &#123;  </span><br><span class="line">        wait = <span class="literal">NULL</span>;  </span><br><span class="line">        timed_out = <span class="number">1</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (end_time &amp;&amp; !timed_out) &#123;  </span><br><span class="line">        <span class="comment">// 估计需要等待的时间.  </span></span><br><span class="line">        slack = select_estimate_accuracy(end_time);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    retval = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;  </span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> *rinp, *routp, *rexp, *inp, *outp, *<span class="built_in">exp</span>;  </span><br><span class="line">  </span><br><span class="line">        inp = fds-&gt;in;  </span><br><span class="line">        outp = fds-&gt;out;  </span><br><span class="line">        <span class="built_in">exp</span> = fds-&gt;ex;  </span><br><span class="line">        rinp = fds-&gt;res_in;  </span><br><span class="line">        routp = fds-&gt;res_out;  </span><br><span class="line">        rexp = fds-&gt;res_ex;  </span><br><span class="line">        <span class="comment">// 遍历所有的描述符, i 文件描述符  </span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++rinp, ++routp, ++rexp) &#123;  </span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">long</span> in, out, ex, all_bits, bit = <span class="number">1</span>, mask, j;  </span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">long</span> res_in = <span class="number">0</span>, res_out = <span class="number">0</span>, res_ex = <span class="number">0</span>;  </span><br><span class="line">            <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">f_op</span> = <span class="title">NULL</span>;</span>  </span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span> = <span class="title">NULL</span>;</span>  </span><br><span class="line">            <span class="comment">// 检查当前的 slot 中的描述符  </span></span><br><span class="line">            in = *inp++;  </span><br><span class="line">            out = *outp++;  </span><br><span class="line">            ex = *<span class="built_in">exp</span>++;  </span><br><span class="line">            all_bits = in | out | ex;  </span><br><span class="line">            <span class="keyword">if</span> (all_bits == <span class="number">0</span>) &#123; <span class="comment">// 没有需要监听的描述符, 下一个slot  </span></span><br><span class="line">                i += __NFDBITS;  </span><br><span class="line">                <span class="keyword">continue</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">  </span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; __NFDBITS; ++j, ++i, bit &lt;&lt;= <span class="number">1</span>) &#123;  </span><br><span class="line">                <span class="keyword">int</span> fput_needed;  </span><br><span class="line">                <span class="keyword">if</span> (i &gt;= n) &#123;  </span><br><span class="line">                    <span class="keyword">break</span>;  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="comment">// 不需要监听描述符 i  </span></span><br><span class="line">                <span class="keyword">if</span> (!(bit &amp; all_bits)) &#123;  </span><br><span class="line">                    <span class="keyword">continue</span>;  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="comment">// 取得文件结构  </span></span><br><span class="line">                file = fget_light(i, &amp;fput_needed);  </span><br><span class="line">                <span class="keyword">if</span> (file) &#123;  </span><br><span class="line">                    f_op = file-&gt;f_op;  </span><br><span class="line">                    <span class="comment">// 没有 f_op 的话就认为一直处于就绪状态  </span></span><br><span class="line">                    mask = DEFAULT_POLLMASK;  </span><br><span class="line">                    <span class="keyword">if</span> (f_op &amp;&amp; f_op-&gt;poll) &#123;  </span><br><span class="line">                        <span class="comment">// 设置等待事件的掩码  </span></span><br><span class="line">                        wait_key_set(wait, in, out, bit);  </span><br><span class="line">                        <span class="comment">/* </span></span><br><span class="line"><span class="comment">                        static inline void wait_key_set(poll_table *wait, unsigned long in, </span></span><br><span class="line"><span class="comment">                        unsigned long out, unsigned long bit) </span></span><br><span class="line"><span class="comment">                        &#123; </span></span><br><span class="line"><span class="comment">                        wait-&gt;_key = POLLEX_SET;// (POLLPRI) </span></span><br><span class="line"><span class="comment">                        if (in &amp; bit) </span></span><br><span class="line"><span class="comment">                        wait-&gt;_key |= POLLIN_SET;//(POLLRDNORM | POLLRDBAND | POLLIN | POLLHUP | POLLERR) </span></span><br><span class="line"><span class="comment">                        if (out &amp; bit) </span></span><br><span class="line"><span class="comment">                        wait-&gt;_key |= POLLOUT_SET;//POLLOUT_SET (POLLWRBAND | POLLWRNORM | POLLOUT | POLLERR) </span></span><br><span class="line"><span class="comment">                        &#125; </span></span><br><span class="line"><span class="comment">                        */</span>  </span><br><span class="line">                        <span class="comment">// 获取当前的就绪状态, 并添加到文件的对应等待队列中  </span></span><br><span class="line">                        mask = (*f_op-&gt;poll)(file, wait);  </span><br><span class="line">                        <span class="comment">// 和poll完全一样  </span></span><br><span class="line">                    &#125;  </span><br><span class="line">                    fput_light(file, fput_needed);  </span><br><span class="line">                    <span class="comment">// 释放文件  </span></span><br><span class="line">                    <span class="comment">// 检查文件 i 是否已有事件就绪，  </span></span><br><span class="line">                    <span class="keyword">if</span> ((mask &amp; POLLIN_SET) &amp;&amp; (in &amp; bit)) &#123;  </span><br><span class="line">                        res_in |= bit;  </span><br><span class="line">                        retval++;  </span><br><span class="line">                        <span class="comment">// 如果已有就绪事件就不再向其他文件的  </span></span><br><span class="line">                        <span class="comment">// 等待队列中添加回调函数  </span></span><br><span class="line">                        wait = <span class="literal">NULL</span>;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                    <span class="keyword">if</span> ((mask &amp; POLLOUT_SET) &amp;&amp; (out &amp; bit)) &#123;  </span><br><span class="line">                        res_out |= bit;  </span><br><span class="line">                        retval++;  </span><br><span class="line">                        wait = <span class="literal">NULL</span>;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                    <span class="keyword">if</span> ((mask &amp; POLLEX_SET) &amp;&amp; (ex &amp; bit)) &#123;  </span><br><span class="line">                        res_ex |= bit;  </span><br><span class="line">                        retval++;  </span><br><span class="line">                        wait = <span class="literal">NULL</span>;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">if</span> (res_in) &#123;  </span><br><span class="line">                *rinp = res_in;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">if</span> (res_out) &#123;  </span><br><span class="line">                *routp = res_out;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">if</span> (res_ex) &#123;  </span><br><span class="line">                *rexp = res_ex;  </span><br><span class="line">            &#125;  </span><br><span class="line">            cond_resched();  </span><br><span class="line">        &#125;  </span><br><span class="line">        wait = <span class="literal">NULL</span>; <span class="comment">// 该添加回调函数的都已经添加了  </span></span><br><span class="line">        <span class="keyword">if</span> (retval || timed_out || signal_pending(current)) &#123;  </span><br><span class="line">            <span class="keyword">break</span>;   <span class="comment">// 信号发生，监听事件就绪或超时  </span></span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span> (table.error) &#123;  </span><br><span class="line">            retval = table.error; <span class="comment">// 产生错误了  </span></span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">// 转换到内核时间  </span></span><br><span class="line">        <span class="keyword">if</span> (end_time &amp;&amp; !to) &#123;  </span><br><span class="line">            expire = timespec_to_ktime(*end_time);  </span><br><span class="line">            to = &amp;expire;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">// 等待直到超时, 或由回调函数唤醒, 超时后会再次遍历文件描述符  </span></span><br><span class="line">        <span class="keyword">if</span> (!poll_schedule_timeout(&amp;table, TASK_INTERRUPTIBLE,  </span><br><span class="line">                                   to, slack)) &#123;  </span><br><span class="line">            timed_out = <span class="number">1</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    poll_freewait(&amp;table);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> retval;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="epoll实现"><a href="#epoll实现" class="headerlink" title="epoll实现"></a>epoll实现</h2><p>epoll 的实现比poll/select 复杂一些，这是因为：</p>
<ol>
<li>epoll_wait, epoll_ctl 的调用完全独立开来,内核需要锁机制对这些操作进行保护，并且需要持久的维护添加到epoll的文件</li>
<li>epoll本身也是文件，也可以被poll/select/epoll监视，这可能导致epoll之间循环唤醒的问题</li>
<li>单个文件的状态改变可能唤醒过多监听在其上的epoll，产生唤醒风暴</li>
</ol>
<p>epoll各个功能的实现要非常小心面对这些问题，使得复杂度大大增加。</p>
<h3 id="epoll的核心数据结构"><a href="#epoll的核心数据结构" class="headerlink" title="epoll的核心数据结构"></a>epoll的核心数据结构</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// epoll的核心实现对应于一个epoll描述符  </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> &#123;</span>  </span><br><span class="line">    <span class="keyword">spinlock_t</span> lock;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mtx</span>;</span>  </span><br><span class="line">    <span class="keyword">wait_queue_head_t</span> wq; <span class="comment">// sys_epoll_wait() 等待在这里  </span></span><br><span class="line">    <span class="comment">// f_op-&gt;poll()  使用的, 被其他事件通知机制利用的wait_address  </span></span><br><span class="line">    <span class="keyword">wait_queue_head_t</span> poll_wait;  </span><br><span class="line">    <span class="comment">/* 已就绪的需要检查的epitem 列表 */</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">rdllist</span>;</span>  </span><br><span class="line">    <span class="comment">/* 保存所有加入到当前epoll的文件对应的epitem*/</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">rbr</span>;</span>  </span><br><span class="line">    <span class="comment">// 当正在向用户空间复制数据时, 产生的可用文件  </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">ovflist</span>;</span>  </span><br><span class="line">    <span class="comment">/* The user that created the eventpoll descriptor */</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span>  </span><br><span class="line">    <span class="comment">/*优化循环检查，避免循环检查中重复的遍历 */</span>  </span><br><span class="line">    <span class="keyword">int</span> visited;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">visited_list_link</span>;</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 对应于一个加入到epoll的文件  </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> &#123;</span>  </span><br><span class="line">    <span class="comment">// 挂载到eventpoll 的红黑树节点  </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">rbn</span>;</span>  </span><br><span class="line">    <span class="comment">// 挂载到eventpoll.rdllist 的节点  </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">rdllink</span>;</span>  </span><br><span class="line">    <span class="comment">// 连接到ovflist 的指针  </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">next</span>;</span>  </span><br><span class="line">    <span class="comment">/* 文件描述符信息fd + file, 红黑树的key */</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_filefd</span> <span class="title">ffd</span>;</span>  </span><br><span class="line">    <span class="comment">/* Number of active wait queue attached to poll operations */</span>  </span><br><span class="line">    <span class="keyword">int</span> nwait;  </span><br><span class="line">    <span class="comment">// 当前文件的等待队列(eppoll_entry)列表  </span></span><br><span class="line">    <span class="comment">// 同一个文件上可能会监视多种事件,  </span></span><br><span class="line">    <span class="comment">// 这些事件可能属于不同的wait_queue中  </span></span><br><span class="line">    <span class="comment">// (取决于对应文件类型的实现),  </span></span><br><span class="line">    <span class="comment">// 所以需要使用链表  </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">pwqlist</span>;</span>  </span><br><span class="line">    <span class="comment">// 当前epitem 的所有者  </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep</span>;</span>  </span><br><span class="line">    <span class="comment">/* List header used to link this item to the &amp;quot;struct file&amp;quot; items list */</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">fllink</span>;</span>  </span><br><span class="line">    <span class="comment">/* epoll_ctl 传入的用户数据 */</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span>  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_filefd</span> &#123;</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span>  </span><br><span class="line">    <span class="keyword">int</span> fd;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 与一个文件上的一个wait_queue_head 相关联，因为同一文件可能有多个等待的事件，这些事件可能使用不同的等待队列  </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eppoll_entry</span> &#123;</span>  </span><br><span class="line">    <span class="comment">// List struct epitem.pwqlist  </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">llink</span>;</span>  </span><br><span class="line">    <span class="comment">// 所有者  </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">base</span>;</span>  </span><br><span class="line">    <span class="comment">// 添加到wait_queue 中的节点  </span></span><br><span class="line">    <span class="keyword">wait_queue_t</span> wait;  </span><br><span class="line">    <span class="comment">// 文件wait_queue 头  </span></span><br><span class="line">    <span class="keyword">wait_queue_head_t</span> *whead;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 用户使用的epoll_event  </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span>  </span><br><span class="line">    __u32 events;  </span><br><span class="line">    __u64 data;  </span><br><span class="line">&#125; EPOLL_PACKED;</span><br></pre></td></tr></table></figure>
<h3 id="文件系统初始化和epoll-create"><a href="#文件系统初始化和epoll-create" class="headerlink" title="文件系统初始化和epoll_create"></a>文件系统初始化和epoll_create</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// epoll 文件系统的相关实现  </span></span><br><span class="line"><span class="comment">// epoll 文件系统初始化, 在系统启动时会调用  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">eventpoll_init</span><span class="params">(<span class="keyword">void</span>)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sysinfo</span> <span class="title">si</span>;</span>  </span><br><span class="line">  </span><br><span class="line">    si_meminfo(&amp;si);  </span><br><span class="line">    <span class="comment">// 限制可添加到epoll的最多的描述符数量  </span></span><br><span class="line">  </span><br><span class="line">    max_user_watches = (((si.totalram - si.totalhigh) / <span class="number">25</span>) &lt;&lt; PAGE_SHIFT) /  </span><br><span class="line">                       EP_ITEM_COST;  </span><br><span class="line">    BUG_ON(max_user_watches &lt; <span class="number">0</span>);  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 初始化递归检查队列  </span></span><br><span class="line">   ep_nested_calls_init(&amp;poll_loop_ncalls);  </span><br><span class="line">    ep_nested_calls_init(&amp;poll_safewake_ncalls);  </span><br><span class="line">    ep_nested_calls_init(&amp;poll_readywalk_ncalls);  </span><br><span class="line">    <span class="comment">// epoll 使用的slab分配器分别用来分配epitem和eppoll_entry  </span></span><br><span class="line">    epi_cache = kmem_cache_create(<span class="string">"eventpoll_epi"</span>, <span class="keyword">sizeof</span>(struct epitem),  </span><br><span class="line">                                  <span class="number">0</span>, SLAB_HWCACHE_ALIGN | SLAB_PANIC, <span class="literal">NULL</span>);  </span><br><span class="line">    pwq_cache = kmem_cache_create(<span class="string">"eventpoll_pwq"</span>,  </span><br><span class="line">                                  <span class="keyword">sizeof</span>(struct eppoll_entry), <span class="number">0</span>, SLAB_PANIC, <span class="literal">NULL</span>);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">SYSCALL_DEFINE1(epoll_create, <span class="keyword">int</span>, size)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">if</span> (size &lt;= <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> -EINVAL;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> sys_epoll_create1(<span class="number">0</span>);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">SYSCALL_DEFINE1(epoll_create1, <span class="keyword">int</span>, flags)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">int</span> error, fd;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep</span> = <span class="title">NULL</span>;</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* Check the EPOLL_* constant for consistency.  */</span>  </span><br><span class="line">    BUILD_BUG_ON(EPOLL_CLOEXEC != O_CLOEXEC);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (flags &amp; ~EPOLL_CLOEXEC) &#123;  </span><br><span class="line">        <span class="keyword">return</span> -EINVAL;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * Create the internal data structure ("struct eventpoll"). </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    error = ep_alloc(&amp;ep);  </span><br><span class="line">    <span class="keyword">if</span> (error &lt; <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> error;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * Creates all the items needed to setup an eventpoll file. That is, </span></span><br><span class="line"><span class="comment">     * a file structure and a free file descriptor. </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    fd = get_unused_fd_flags(O_RDWR | (flags &amp; O_CLOEXEC));  </span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;  </span><br><span class="line">         error = fd;  </span><br><span class="line">         <span class="keyword">goto</span> out_free_ep;  </span><br><span class="line">      &#125;  </span><br><span class="line">      <span class="comment">// 设置epfd的相关操作，由于epoll也是文件也提供了poll操作  </span></span><br><span class="line">    file = anon_inode_getfile(<span class="string">"[eventpoll]"</span>, &amp;eventpoll_fops, ep,  </span><br><span class="line">                              O_RDWR | (flags &amp; O_CLOEXEC));  </span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(file)) &#123;  </span><br><span class="line">        error = PTR_ERR(file);  </span><br><span class="line">        <span class="keyword">goto</span> out_free_fd;  </span><br><span class="line">    &#125;  </span><br><span class="line">    fd_install(fd, file);  </span><br><span class="line">    ep-&gt;file = file;  </span><br><span class="line">    <span class="keyword">return</span> fd;  </span><br><span class="line">  </span><br><span class="line">out_free_fd:  </span><br><span class="line">    put_unused_fd(fd);  </span><br><span class="line">out_free_ep:  </span><br><span class="line">    ep_free(ep);  </span><br><span class="line">    <span class="keyword">return</span> error;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="epoll中的递归死循环和深度检查"><a href="#epoll中的递归死循环和深度检查" class="headerlink" title="epoll中的递归死循环和深度检查"></a>epoll中的递归死循环和深度检查</h3><h4 id="递归深度检测-ep-call-nested"><a href="#递归深度检测-ep-call-nested" class="headerlink" title="递归深度检测(ep_call_nested)"></a>递归深度检测(ep_call_nested)</h4><p>epoll本身也是文件，也可以被poll/select/epoll监视，如果epoll之间互相监视就有可能导致死循环。epoll的实现中，所有可能产生递归调用的函数都由函函数ep_call_nested进行包裹，递归调用过程中出现死循环或递归过深就会打破死循环和递归调用直接返回。该函数的实现依赖于一个外部的全局链表nested_call_node(不同的函数调用使用不同的节点)，每次调用可能发生递归的函数(nproc)就向链表中添加一个包含当前函数调用上下文ctx(进程，CPU，或epoll文件)和处理的对象标识cookie的节点，通过检测是否有相同的节点就可以知道是否发生了死循环，检查链表中同一上下文包含的节点个数就可以知道递归的深度。以下就是这一过程的源码。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nested_call_node</span> &#123;</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">llink</span>;</span>  </span><br><span class="line">    <span class="keyword">void</span> *cookie;   <span class="comment">// 函数运行标识, 任务标志  </span></span><br><span class="line">    <span class="keyword">void</span> *ctx;      <span class="comment">// 运行环境标识  </span></span><br><span class="line">&#125;;  </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nested_calls</span> &#123;</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">tasks_call_list</span>;</span>  </span><br><span class="line">    <span class="keyword">spinlock_t</span> lock;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 全局的不同调用使用的链表  </span></span><br><span class="line"><span class="comment">// 死循环检查和唤醒风暴检查链表  </span></span><br><span class="line"><span class="keyword">static</span> nested_call_node poll_loop_ncalls;  </span><br><span class="line"><span class="comment">// 唤醒时使用的检查链表  </span></span><br><span class="line"><span class="keyword">static</span> nested_call_node poll_safewake_ncalls;  </span><br><span class="line"><span class="comment">// 扫描readylist 时使用的链表  </span></span><br><span class="line"><span class="keyword">static</span> nested_call_node poll_readywalk_ncalls;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 限制epoll 中直接或间接递归调用的深度并防止死循环  </span></span><br><span class="line"><span class="comment">// ctx: 任务运行上下文(进程, CPU 等)  </span></span><br><span class="line"><span class="comment">// cookie: 每个任务的标识  </span></span><br><span class="line"><span class="comment">// priv: 任务运行需要的私有数据  </span></span><br><span class="line"><span class="comment">// 如果用面向对象语言实现应该就会是一个wapper类  </span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ep_call_nested</span><span class="params">(struct nested_calls *ncalls, <span class="keyword">int</span> max_nests,  </span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> (*nproc)(<span class="keyword">void</span> *, <span class="keyword">void</span> *, <span class="keyword">int</span>), <span class="keyword">void</span> *priv,  </span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">void</span> *cookie, <span class="keyword">void</span> *ctx)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> error, call_nests = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">lsthead</span> = &amp;<span class="title">ncalls</span>-&gt;<span class="title">tasks_call_list</span>;</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nested_call_node</span> *<span class="title">tncur</span>;</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nested_call_node</span> <span class="title">tnode</span>;</span>  </span><br><span class="line">    spin_lock_irqsave(&amp;ncalls-&gt;lock, flags);  </span><br><span class="line">    <span class="comment">// 检查原有的嵌套调用链表ncalls, 查看是否有深度超过限制的情况  </span></span><br><span class="line">    list_for_each_entry(tncur, lsthead, llink) &#123;  </span><br><span class="line">        <span class="comment">// 同一上下文中(ctx)有相同的任务(cookie)说明产生了死循环  </span></span><br><span class="line">        <span class="comment">// 同一上下文的递归深度call_nests 超过限制  </span></span><br><span class="line">        <span class="keyword">if</span> (tncur-&gt;ctx == ctx &amp;&amp;  </span><br><span class="line">                (tncur-&gt;cookie == cookie || ++call_nests &gt; max_nests)) &#123;  </span><br><span class="line">            error = <span class="number">-1</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">goto</span> out_unlock;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">/* 将当前的任务请求添加到调用列表*/</span>  </span><br><span class="line">    tnode.ctx = ctx;  </span><br><span class="line">    tnode.cookie = cookie;  </span><br><span class="line">    list_add(&amp;tnode.llink, lsthead);  </span><br><span class="line">    spin_unlock_irqrestore(&amp;ncalls-&gt;lock, flags);  </span><br><span class="line">    <span class="comment">/* nproc 可能会导致递归调用(直接或间接)ep_call_nested </span></span><br><span class="line"><span class="comment">         * 如果发生递归调用, 那么在此函数返回之前, </span></span><br><span class="line"><span class="comment">         * ncalls 又会被加入额外的节点, </span></span><br><span class="line"><span class="comment">         * 这样通过前面的检测就可以知道递归调用的深度 </span></span><br><span class="line"><span class="comment">      */</span>  </span><br><span class="line">    error = (*nproc)(priv, cookie, call_nests);  </span><br><span class="line">    <span class="comment">/* 从链表中删除当前任务*/</span>  </span><br><span class="line">    spin_lock_irqsave(&amp;ncalls-&gt;lock, flags);  </span><br><span class="line">    list_del(&amp;tnode.llink);  </span><br><span class="line">out_unlock:  </span><br><span class="line">    spin_unlock_irqrestore(&amp;ncalls-&gt;lock, flags);  </span><br><span class="line">    <span class="keyword">return</span> error;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="循环检测-ep-loop-check"><a href="#循环检测-ep-loop-check" class="headerlink" title="循环检测(ep_loop_check)"></a>循环检测(ep_loop_check)</h3><p>循环检查(ep_loop_check)，该函数递归调用ep_loop_check_proc利用ep_call_nested来实现epoll之间相互监视的死循环。因为ep_call_nested中已经对死循环和过深的递归做了检查，实际的ep_loop_check_proc的实现只是递归调用自己。其中的visited_list和visited标记完全是为了优化处理速度，如果没有visited_list和visited标记函数也是能够工作的。该函数中得上下文就是当前的进程，cookie就是正在遍历的epoll结构。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">static LIST_HEAD(visited_list);  </span><br><span class="line">// 检查 file (epoll)和ep 之间是否有循环  </span><br><span class="line">static int ep_loop_check(struct eventpoll *ep, struct file *file)  </span><br><span class="line">&#123;  </span><br><span class="line">    int ret;  </span><br><span class="line">    struct eventpoll *ep_cur, *ep_next;  </span><br><span class="line">  </span><br><span class="line">    ret = ep_call_nested(&amp;poll_loop_ncalls, EP_MAX_NESTS,  </span><br><span class="line">                         ep_loop_check_proc, file, ep, current);  </span><br><span class="line">    /* 清除链表和标志 */  </span><br><span class="line">    list_for_each_entry_safe(ep_cur, ep_next, &amp;visited_list,  </span><br><span class="line">                             visited_list_link) &#123;  </span><br><span class="line">        ep_cur-&gt;visited = 0;  </span><br><span class="line">        list_del(&amp;ep_cur-&gt;visited_list_link);  </span><br><span class="line">    &#125;  </span><br><span class="line">    return ret;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">static int ep_loop_check_proc(void *priv, void *cookie, int call_nests)  </span><br><span class="line">&#123;  </span><br><span class="line">    int error = 0;  </span><br><span class="line">    struct file *file = priv;  </span><br><span class="line">    struct eventpoll *ep = file-&gt;private_data;  </span><br><span class="line">    struct eventpoll *ep_tovisit;  </span><br><span class="line">    struct rb_node *rbp;  </span><br><span class="line">    struct epitem *epi;  </span><br><span class="line">  </span><br><span class="line">    mutex_lock_nested(&amp;ep-&gt;mtx, call_nests + 1);  </span><br><span class="line">    // 标记当前为已遍历  </span><br><span class="line">    ep-&gt;visited = 1;  </span><br><span class="line">    list_add(&amp;ep-&gt;visited_list_link, &amp;visited_list);  </span><br><span class="line">    // 遍历所有ep 监视的文件  </span><br><span class="line">    for (rbp = rb_first(&amp;ep-&gt;rbr); rbp; rbp = rb_next(rbp)) &#123;  </span><br><span class="line">        epi = rb_entry(rbp, struct epitem, rbn);  </span><br><span class="line">        if (unlikely(is_file_epoll(epi-&gt;ffd.file))) &#123;  </span><br><span class="line">            ep_tovisit = epi-&gt;ffd.file-&gt;private_data;  </span><br><span class="line">            // 跳过先前已遍历的, 避免循环检查  </span><br><span class="line">            if (ep_tovisit-&gt;visited) &#123;  </span><br><span class="line">                continue;  </span><br><span class="line">            &#125;  </span><br><span class="line">            // 所有ep监视的未遍历的epoll  </span><br><span class="line">            error = ep_call_nested(&amp;poll_loop_ncalls, EP_MAX_NESTS,  </span><br><span class="line">                                   ep_loop_check_proc, epi-&gt;ffd.file,  </span><br><span class="line">                                   ep_tovisit, current);  </span><br><span class="line">            if (error != 0) &#123;  </span><br><span class="line">                break;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125; else &#123;  </span><br><span class="line">            // 文件不在tfile_check_list 中, 添加  </span><br><span class="line">            // 最外层的epoll 需要检查子epoll监视的文件  </span><br><span class="line">            if (list_empty(&amp;epi-&gt;ffd.file-&gt;f_tfile_llink))  </span><br><span class="line">                list_add(&amp;epi-&gt;ffd.file-&gt;f_tfile_llink,  </span><br><span class="line">                         &amp;tfile_check_list);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    mutex_unlock(&amp;ep-&gt;mtx);  </span><br><span class="line">  </span><br><span class="line">    return error;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="唤醒风暴检测（reverse-path-check）"><a href="#唤醒风暴检测（reverse-path-check）" class="headerlink" title="唤醒风暴检测（reverse_path_check）"></a>唤醒风暴检测（reverse_path_check）</h3><p> 当文件状态发生改变时，会唤醒监听在其上的epoll文件，而这个epoll文件还可能唤醒其他的epoll文件，这种连续的唤醒就形成了一个唤醒路径，所有的唤醒路径就形成了一个有向图。如果文件对应的epoll唤醒有向图的节点过多，那么文件状态的改变就会唤醒所有的这些epoll(可能会唤醒很多进程，这样的开销是很大的)，而实际上一个文件经过少数epoll处理以后就可能从就绪转到未就绪，剩余的epoll虽然认为文件已就绪而实际上经过某些处理后已不可用。epoll的实现中考虑到了此问题，在每次添加新文件到epoll中时，就会首先检查是否会出现这样的唤醒风暴。</p>
<p>该函数的实现逻辑是这样的，递归调用reverse_path_check_proc遍历监听在当前文件上的epoll文件，在reverse_pach_check_proc中统计并检查不同路径深度上epoll的个数，从而避免产生唤醒风暴。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PATH_ARR_SIZE 5  </span></span><br><span class="line"><span class="comment">// 在EPOLL_CTL_ADD 时, 检查是否有可能产生唤醒风暴  </span></span><br><span class="line"><span class="comment">// epoll 允许的单个文件的唤醒深度小于5, 例如  </span></span><br><span class="line"><span class="comment">// 一个文件最多允许唤醒1000个深度为1的epoll描述符,  </span></span><br><span class="line"><span class="comment">//允许所有被单个文件直接唤醒的epoll描述符再次唤醒的epoll描述符总数是500  </span></span><br><span class="line"><span class="comment">//  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// 深度限制  </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> path_limits[PATH_ARR_SIZE] = &#123; <span class="number">1000</span>, <span class="number">500</span>, <span class="number">100</span>, <span class="number">50</span>, <span class="number">10</span> &#125;;  </span><br><span class="line"><span class="comment">// 计算出来的深度  </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> path_count[PATH_ARR_SIZE];  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">path_count_inc</span><span class="params">(<span class="keyword">int</span> nests)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="comment">/* Allow an arbitrary number of depth 1 paths */</span>  </span><br><span class="line">    <span class="keyword">if</span> (nests == <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (++path_count[nests] &gt; path_limits[nests]) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">path_count_init</span><span class="params">(<span class="keyword">void</span>)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> i;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; PATH_ARR_SIZE; i++) &#123;  </span><br><span class="line">        path_count[i] = <span class="number">0</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 唤醒风暴检查函数  </span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">reverse_path_check</span><span class="params">(<span class="keyword">void</span>)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> error = <span class="number">0</span>;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">current_file</span>;</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* let's call this for all tfiles */</span>  </span><br><span class="line">    <span class="comment">// 遍历全局tfile_check_list 中的文件, 第一级  </span></span><br><span class="line">    list_for_each_entry(current_file, &amp;tfile_check_list, f_tfile_llink) &#123;  </span><br><span class="line">        <span class="comment">// 初始化  </span></span><br><span class="line">        path_count_init();  </span><br><span class="line">        <span class="comment">// 限制递归的深度, 并检查每个深度上唤醒的epoll 数量  </span></span><br><span class="line">        error = ep_call_nested(&amp;poll_loop_ncalls, EP_MAX_NESTS,  </span><br><span class="line">                               reverse_path_check_proc, current_file,  </span><br><span class="line">                               current_file, current);  </span><br><span class="line">        <span class="keyword">if</span> (error) &#123;  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> error;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">reverse_path_check_proc</span><span class="params">(<span class="keyword">void</span> *priv, <span class="keyword">void</span> *cookie, <span class="keyword">int</span> call_nests)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> error = <span class="number">0</span>;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span> = <span class="title">priv</span>;</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">child_file</span>;</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">epi</span>;</span>  </span><br><span class="line">  </span><br><span class="line">    list_for_each_entry(epi, &amp;file-&gt;f_ep_links, fllink) &#123;  </span><br><span class="line">        <span class="comment">// 遍历监视file 的epoll  </span></span><br><span class="line">        child_file = epi-&gt;ep-&gt;file;  </span><br><span class="line">        <span class="keyword">if</span> (is_file_epoll(child_file)) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (list_empty(&amp;child_file-&gt;f_ep_links)) &#123;  </span><br><span class="line">                <span class="comment">// 没有其他的epoll监视当前的这个epoll,  </span></span><br><span class="line">                <span class="comment">// 已经是叶子了  </span></span><br><span class="line">                <span class="keyword">if</span> (path_count_inc(call_nests)) &#123;  </span><br><span class="line">                    error = <span class="number">-1</span>;  </span><br><span class="line">                    <span class="keyword">break</span>;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                <span class="comment">// 遍历监视这个epoll 文件的epoll,  </span></span><br><span class="line">                <span class="comment">// 递归调用  </span></span><br><span class="line">                error = ep_call_nested(&amp;poll_loop_ncalls,  </span><br><span class="line">                                       EP_MAX_NESTS,  </span><br><span class="line">                                       reverse_path_check_proc,  </span><br><span class="line">                                       child_file, child_file,  </span><br><span class="line">                                       current);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">if</span> (error != <span class="number">0</span>) &#123;  </span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            <span class="comment">// 不是epoll , 不可能吧?  </span></span><br><span class="line">            printk(KERN_ERR <span class="string">"reverse_path_check_proc: "</span>  </span><br><span class="line">                   <span class="string">"file is not an ep!\n"</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> error;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="epoll-的唤醒过程"><a href="#epoll-的唤醒过程" class="headerlink" title="epoll 的唤醒过程"></a>epoll 的唤醒过程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ep_poll_safewake</span><span class="params">(<span class="keyword">wait_queue_head_t</span> *wq)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> this_cpu = get_cpu();  </span><br><span class="line">  </span><br><span class="line">    ep_call_nested(&amp;poll_safewake_ncalls, EP_MAX_NESTS,  </span><br><span class="line">                   ep_poll_wakeup_proc, <span class="literal">NULL</span>, wq, (<span class="keyword">void</span> *) (<span class="keyword">long</span>) this_cpu);  </span><br><span class="line">  </span><br><span class="line">    put_cpu();  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ep_poll_wakeup_proc</span><span class="params">(<span class="keyword">void</span> *priv, <span class="keyword">void</span> *cookie, <span class="keyword">int</span> call_nests)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    ep_wake_up_nested((<span class="keyword">wait_queue_head_t</span> *) cookie, POLLIN,  </span><br><span class="line">                      <span class="number">1</span> + call_nests);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">ep_wake_up_nested</span><span class="params">(<span class="keyword">wait_queue_head_t</span> *wqueue,  </span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="keyword">unsigned</span> <span class="keyword">long</span> events, <span class="keyword">int</span> subclass)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="comment">// 这回唤醒所有正在等待此epfd 的select/epoll/poll 等  </span></span><br><span class="line">    <span class="comment">// 如果唤醒的是epoll 就可能唤醒其他的epoll, 产生连锁反应  </span></span><br><span class="line">    <span class="comment">// 这个很可能在中断上下文中被调用  </span></span><br><span class="line">    wake_up_poll(wqueue, events);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="epoll-ctl"><a href="#epoll-ctl" class="headerlink" title="epoll_ctl"></a>epoll_ctl</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// long epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);  </span></span><br><span class="line">  </span><br><span class="line">SYSCALL_DEFINE4(epoll_ctl, <span class="keyword">int</span>, epfd, <span class="keyword">int</span>, op, <span class="keyword">int</span>, fd,  </span><br><span class="line">                struct epoll_event __user *, event)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">int</span> error;  </span><br><span class="line">    <span class="keyword">int</span> did_lock_epmutex = <span class="number">0</span>;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>, *<span class="title">tfile</span>;</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep</span>;</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">epi</span>;</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">epds</span>;</span>  </span><br><span class="line">  </span><br><span class="line">    error = -EFAULT;  </span><br><span class="line">    <span class="keyword">if</span> (ep_op_has_event(op) &amp;&amp;  </span><br><span class="line">            <span class="comment">// 复制用户空间数据到内核  </span></span><br><span class="line">            copy_from_user(&amp;epds, event, <span class="keyword">sizeof</span>(struct epoll_event))) &#123;  </span><br><span class="line">        <span class="keyword">goto</span> error_return;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 取得 epfd 对应的文件  </span></span><br><span class="line">    error = -EBADF;  </span><br><span class="line">    file = fget(epfd);  </span><br><span class="line">    <span class="keyword">if</span> (!file) &#123;  </span><br><span class="line">        <span class="keyword">goto</span> error_return;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 取得目标文件  </span></span><br><span class="line">    tfile = fget(fd);  </span><br><span class="line">    <span class="keyword">if</span> (!tfile) &#123;  </span><br><span class="line">        <span class="keyword">goto</span> error_fput;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 目标文件必须提供 poll 操作  </span></span><br><span class="line">    error = -EPERM;  </span><br><span class="line">    <span class="keyword">if</span> (!tfile-&gt;f_op || !tfile-&gt;f_op-&gt;poll) &#123;  </span><br><span class="line">        <span class="keyword">goto</span> error_tgt_fput;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 添加自身或epfd 不是epoll 句柄  </span></span><br><span class="line">    error = -EINVAL;  </span><br><span class="line">    <span class="keyword">if</span> (file == tfile || !is_file_epoll(file)) &#123;  </span><br><span class="line">        <span class="keyword">goto</span> error_tgt_fput;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 取得内部结构eventpoll  </span></span><br><span class="line">    ep = file-&gt;private_data;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// EPOLL_CTL_MOD 不需要加全局锁 epmutex  </span></span><br><span class="line">    <span class="keyword">if</span> (op == EPOLL_CTL_ADD || op == EPOLL_CTL_DEL) &#123;  </span><br><span class="line">        mutex_lock(&amp;epmutex);  </span><br><span class="line">        did_lock_epmutex = <span class="number">1</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (op == EPOLL_CTL_ADD) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (is_file_epoll(tfile)) &#123;  </span><br><span class="line">            error = -ELOOP;  </span><br><span class="line">            <span class="comment">// 目标文件也是epoll 检测是否有循环包含的问题  </span></span><br><span class="line">            <span class="keyword">if</span> (ep_loop_check(ep, tfile) != <span class="number">0</span>) &#123;  </span><br><span class="line">                <span class="keyword">goto</span> error_tgt_fput;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125; <span class="keyword">else</span>  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="comment">// 将目标文件添加到 epoll 全局的tfile_check_list 中  </span></span><br><span class="line">            list_add(&amp;tfile-&gt;f_tfile_llink, &amp;tfile_check_list);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    mutex_lock_nested(&amp;ep-&gt;mtx, <span class="number">0</span>);  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 以tfile 和fd 为key 在rbtree 中查找文件对应的epitem  </span></span><br><span class="line">    epi = ep_find(ep, tfile, fd);  </span><br><span class="line">  </span><br><span class="line">    error = -EINVAL;  </span><br><span class="line">    <span class="keyword">switch</span> (op) &#123;  </span><br><span class="line">    <span class="keyword">case</span> EPOLL_CTL_ADD:  </span><br><span class="line">        <span class="keyword">if</span> (!epi) &#123;  </span><br><span class="line">            <span class="comment">// 没找到, 添加额外添加ERR HUP 事件  </span></span><br><span class="line">            epds.events |= POLLERR | POLLHUP;  </span><br><span class="line">            error = ep_insert(ep, &amp;epds, tfile, fd);  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            error = -EEXIST;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">// 清空文件检查列表  </span></span><br><span class="line">        clear_tfile_check_list();  </span><br><span class="line">        <span class="keyword">break</span>;  </span><br><span class="line">    <span class="keyword">case</span> EPOLL_CTL_DEL:  </span><br><span class="line">        <span class="keyword">if</span> (epi) &#123;  </span><br><span class="line">            error = ep_remove(ep, epi);  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            error = -ENOENT;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">break</span>;  </span><br><span class="line">    <span class="keyword">case</span> EPOLL_CTL_MOD:  </span><br><span class="line">        <span class="keyword">if</span> (epi) &#123;  </span><br><span class="line">            epds.events |= POLLERR | POLLHUP;  </span><br><span class="line">            error = ep_modify(ep, epi, &amp;epds);  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            error = -ENOENT;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">break</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    mutex_unlock(&amp;ep-&gt;mtx);  </span><br><span class="line">  </span><br><span class="line">error_tgt_fput:  </span><br><span class="line">    <span class="keyword">if</span> (did_lock_epmutex) &#123;  </span><br><span class="line">        mutex_unlock(&amp;epmutex);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    fput(tfile);  </span><br><span class="line">error_fput:  </span><br><span class="line">    fput(file);  </span><br><span class="line">error_return:  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> error;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="EPOLL-CTL-ADD-实现"><a href="#EPOLL-CTL-ADD-实现" class="headerlink" title="EPOLL_CTL_ADD 实现"></a>EPOLL_CTL_ADD 实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line">// EPOLL_CTL_ADD  </span><br><span class="line">static int ep_insert(struct eventpoll *ep, struct epoll_event *event,  </span><br><span class="line">                     struct file *tfile, int fd)  </span><br><span class="line">&#123;  </span><br><span class="line">    int error, revents, pwake = 0;  </span><br><span class="line">    unsigned long flags;  </span><br><span class="line">    long user_watches;  </span><br><span class="line">    struct epitem *epi;  </span><br><span class="line">    struct ep_pqueue epq;  </span><br><span class="line">    /* </span><br><span class="line">    struct ep_pqueue &#123; </span><br><span class="line">        poll_table pt; </span><br><span class="line">        struct epitem *epi; </span><br><span class="line">    &#125;; </span><br><span class="line">    */  </span><br><span class="line">  </span><br><span class="line">    // 增加监视文件数  </span><br><span class="line">    user_watches = atomic_long_read(&amp;ep-&gt;user-&gt;epoll_watches);  </span><br><span class="line">    if (unlikely(user_watches &gt;= max_user_watches)) &#123;  </span><br><span class="line">        return -ENOSPC;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    // 分配初始化 epi  </span><br><span class="line">    if (!(epi = kmem_cache_alloc(epi_cache, GFP_KERNEL))) &#123;  </span><br><span class="line">        return -ENOMEM;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    INIT_LIST_HEAD(&amp;epi-&gt;rdllink);  </span><br><span class="line">    INIT_LIST_HEAD(&amp;epi-&gt;fllink);  </span><br><span class="line">    INIT_LIST_HEAD(&amp;epi-&gt;pwqlist);  </span><br><span class="line">    epi-&gt;ep = ep;  </span><br><span class="line">    // 初始化红黑树中的key  </span><br><span class="line">    ep_set_ffd(&amp;epi-&gt;ffd, tfile, fd);  </span><br><span class="line">    // 直接复制用户结构  </span><br><span class="line">    epi-&gt;event = *event;  </span><br><span class="line">    epi-&gt;nwait = 0;  </span><br><span class="line">    epi-&gt;next = EP_UNACTIVE_PTR;  </span><br><span class="line">  </span><br><span class="line">    // 初始化临时的 epq  </span><br><span class="line">    epq.epi = epi;  </span><br><span class="line">    init_poll_funcptr(&amp;epq.pt, ep_ptable_queue_proc);  </span><br><span class="line">    // 设置事件掩码  </span><br><span class="line">    epq.pt._key = event-&gt;events;  </span><br><span class="line">    //  内部会调用ep_ptable_queue_proc, 在文件对应的wait queue head 上  </span><br><span class="line">    // 注册回调函数, 并返回当前文件的状态  </span><br><span class="line">    revents = tfile-&gt;f_op-&gt;poll(tfile, &amp;epq.pt);  </span><br><span class="line">  </span><br><span class="line">    // 检查错误  </span><br><span class="line">    error = -ENOMEM;  </span><br><span class="line">    if (epi-&gt;nwait &lt; 0) &#123; // f_op-&gt;poll 过程出错  </span><br><span class="line">        goto error_unregister;  </span><br><span class="line">    &#125;  </span><br><span class="line">    // 添加当前的epitem 到文件的f_ep_links 链表  </span><br><span class="line">    spin_lock(&amp;tfile-&gt;f_lock);  </span><br><span class="line">    list_add_tail(&amp;epi-&gt;fllink, &amp;tfile-&gt;f_ep_links);  </span><br><span class="line">    spin_unlock(&amp;tfile-&gt;f_lock);  </span><br><span class="line">  </span><br><span class="line">    // 插入epi 到rbtree  </span><br><span class="line">    ep_rbtree_insert(ep, epi);  </span><br><span class="line">  </span><br><span class="line">    /* now check if we&apos;ve created too many backpaths */  </span><br><span class="line">    error = -EINVAL;  </span><br><span class="line">    if (reverse_path_check()) &#123;  </span><br><span class="line">        goto error_remove_epi;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    spin_lock_irqsave(&amp;ep-&gt;lock, flags);  </span><br><span class="line">  </span><br><span class="line">    /* 文件已经就绪插入到就绪链表rdllist */  </span><br><span class="line">    if ((revents &amp; event-&gt;events) &amp;&amp; !ep_is_linked(&amp;epi-&gt;rdllink)) &#123;  </span><br><span class="line">        list_add_tail(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist);  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">        if (waitqueue_active(&amp;ep-&gt;wq))  </span><br><span class="line">            // 通知sys_epoll_wait , 调用回调函数唤醒sys_epoll_wait 进程  </span><br><span class="line">        &#123;  </span><br><span class="line">            wake_up_locked(&amp;ep-&gt;wq);  </span><br><span class="line">        &#125;  </span><br><span class="line">        // 先不通知调用eventpoll_poll 的进程  </span><br><span class="line">        if (waitqueue_active(&amp;ep-&gt;poll_wait)) &#123;  </span><br><span class="line">            pwake++;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    spin_unlock_irqrestore(&amp;ep-&gt;lock, flags);  </span><br><span class="line">  </span><br><span class="line">    atomic_long_inc(&amp;ep-&gt;user-&gt;epoll_watches);  </span><br><span class="line">  </span><br><span class="line">    if (pwake)  </span><br><span class="line">        // 安全通知调用eventpoll_poll 的进程  </span><br><span class="line">    &#123;  </span><br><span class="line">        ep_poll_safewake(&amp;ep-&gt;poll_wait);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    return 0;  </span><br><span class="line">  </span><br><span class="line">error_remove_epi:  </span><br><span class="line">    spin_lock(&amp;tfile-&gt;f_lock);  </span><br><span class="line">    // 删除文件上的 epi  </span><br><span class="line">    if (ep_is_linked(&amp;epi-&gt;fllink)) &#123;  </span><br><span class="line">        list_del_init(&amp;epi-&gt;fllink);  </span><br><span class="line">    &#125;  </span><br><span class="line">    spin_unlock(&amp;tfile-&gt;f_lock);  </span><br><span class="line">  </span><br><span class="line">    // 从红黑树中删除  </span><br><span class="line">    rb_erase(&amp;epi-&gt;rbn, &amp;ep-&gt;rbr);  </span><br><span class="line">  </span><br><span class="line">error_unregister:  </span><br><span class="line">    // 从文件的wait_queue 中删除, 释放epitem 关联的所有eppoll_entry  </span><br><span class="line">    ep_unregister_pollwait(ep, epi);  </span><br><span class="line">  </span><br><span class="line">    /* </span><br><span class="line">     * We need to do this because an event could have been arrived on some </span><br><span class="line">     * allocated wait queue. Note that we don&apos;t care about the ep-&gt;ovflist </span><br><span class="line">     * list, since that is used/cleaned only inside a section bound by &quot;mtx&quot;. </span><br><span class="line">     * And ep_insert() is called with &quot;mtx&quot; held. </span><br><span class="line">     */  </span><br><span class="line">    // TODO:  </span><br><span class="line">    spin_lock_irqsave(&amp;ep-&gt;lock, flags);  </span><br><span class="line">    if (ep_is_linked(&amp;epi-&gt;rdllink)) &#123;  </span><br><span class="line">        list_del_init(&amp;epi-&gt;rdllink);  </span><br><span class="line">    &#125;  </span><br><span class="line">    spin_unlock_irqrestore(&amp;ep-&gt;lock, flags);  </span><br><span class="line">  </span><br><span class="line">    // 释放epi  </span><br><span class="line">    kmem_cache_free(epi_cache, epi);  </span><br><span class="line">  </span><br><span class="line">    return error;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="EPOLL-CTL-DEL"><a href="#EPOLL-CTL-DEL" class="headerlink" title="EPOLL_CTL_DEL"></a>EPOLL_CTL_DEL</h3><p>EPOLL_CTL_DEL 的实现调用的是 ep_remove 函数，函数只是清除ADD时， 添加的各种结构，EPOLL_CTL_MOD 的实现调用的是ep_modify，在ep_modify中用新的事件掩码调用f_ops-&gt;poll，检测事件是否已可用，如果可用就直接唤醒epoll，这两个的实现与EPOLL_CTL_ADD 类似，代码上比较清晰，这里就不具体分析了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">static int ep_remove(struct eventpoll *ep, struct epitem *epi)  </span><br><span class="line">&#123;  </span><br><span class="line">    unsigned long flags;  </span><br><span class="line">    struct file *file = epi-&gt;ffd.file;  </span><br><span class="line">  </span><br><span class="line">    /* </span><br><span class="line">     * Removes poll wait queue hooks. We _have_ to do this without holding </span><br><span class="line">     * the &quot;ep-&gt;lock&quot; otherwise a deadlock might occur. This because of the </span><br><span class="line">     * sequence of the lock acquisition. Here we do &quot;ep-&gt;lock&quot; then the wait </span><br><span class="line">     * queue head lock when unregistering the wait queue. The wakeup callback </span><br><span class="line">     * will run by holding the wait queue head lock and will call our callback </span><br><span class="line">     * that will try to get &quot;ep-&gt;lock&quot;. </span><br><span class="line">     */  </span><br><span class="line">    ep_unregister_pollwait(ep, epi);  </span><br><span class="line">  </span><br><span class="line">    /* Remove the current item from the list of epoll hooks */  </span><br><span class="line">    spin_lock(&amp;file-&gt;f_lock);  </span><br><span class="line">    if (ep_is_linked(&amp;epi-&gt;fllink))  </span><br><span class="line">        list_del_init(&amp;epi-&gt;fllink);  </span><br><span class="line">    spin_unlock(&amp;file-&gt;f_lock);  </span><br><span class="line">  </span><br><span class="line">    rb_erase(&amp;epi-&gt;rbn, &amp;ep-&gt;rbr);  </span><br><span class="line">  </span><br><span class="line">    spin_lock_irqsave(&amp;ep-&gt;lock, flags);  </span><br><span class="line">    if (ep_is_linked(&amp;epi-&gt;rdllink))  </span><br><span class="line">        list_del_init(&amp;epi-&gt;rdllink);  </span><br><span class="line">    spin_unlock_irqrestore(&amp;ep-&gt;lock, flags);  </span><br><span class="line">  </span><br><span class="line">    /* At this point it is safe to free the eventpoll item */  </span><br><span class="line">    kmem_cache_free(epi_cache, epi);  </span><br><span class="line">  </span><br><span class="line">    atomic_long_dec(&amp;ep-&gt;user-&gt;epoll_watches);  </span><br><span class="line">  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line"> * Modify the interest event mask by dropping an event if the new mask </span><br><span class="line"> * has a match in the current file status. Must be called with &quot;mtx&quot; held. </span><br><span class="line"> */  </span><br><span class="line">static int ep_modify(struct eventpoll *ep, struct epitem *epi, struct epoll_event *event)  </span><br><span class="line">&#123;  </span><br><span class="line">    int pwake = 0;  </span><br><span class="line">    unsigned int revents;  </span><br><span class="line">    poll_table pt;  </span><br><span class="line">  </span><br><span class="line">    init_poll_funcptr(&amp;pt, NULL);  </span><br><span class="line">  </span><br><span class="line">    /* </span><br><span class="line">     * Set the new event interest mask before calling f_op-&gt;poll(); </span><br><span class="line">     * otherwise we might miss an event that happens between the </span><br><span class="line">     * f_op-&gt;poll() call and the new event set registering. </span><br><span class="line">     */  </span><br><span class="line">    epi-&gt;event.events = event-&gt;events;  </span><br><span class="line">    pt._key = event-&gt;events;  </span><br><span class="line">    epi-&gt;event.data = event-&gt;data; /* protected by mtx */  </span><br><span class="line">  </span><br><span class="line">    /* </span><br><span class="line">     * Get current event bits. We can safely use the file* here because </span><br><span class="line">     * its usage count has been increased by the caller of this function. </span><br><span class="line">     */  </span><br><span class="line">    revents = epi-&gt;ffd.file-&gt;f_op-&gt;poll(epi-&gt;ffd.file, &amp;pt);  </span><br><span class="line">  </span><br><span class="line">    /* </span><br><span class="line">     * If the item is &quot;hot&quot; and it is not registered inside the ready </span><br><span class="line">     * list, push it inside. </span><br><span class="line">     */  </span><br><span class="line">    if (revents &amp; event-&gt;events) &#123;  </span><br><span class="line">        spin_lock_irq(&amp;ep-&gt;lock);  </span><br><span class="line">        if (!ep_is_linked(&amp;epi-&gt;rdllink)) &#123;  </span><br><span class="line">            list_add_tail(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist);  </span><br><span class="line">  </span><br><span class="line">            /* Notify waiting tasks that events are available */  </span><br><span class="line">            if (waitqueue_active(&amp;ep-&gt;wq))  </span><br><span class="line">                wake_up_locked(&amp;ep-&gt;wq);  </span><br><span class="line">            if (waitqueue_active(&amp;ep-&gt;poll_wait))  </span><br><span class="line">                pwake++;  </span><br><span class="line">        &#125;  </span><br><span class="line">        spin_unlock_irq(&amp;ep-&gt;lock);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    /* We have to call this outside the lock */  </span><br><span class="line">    if (pwake)  </span><br><span class="line">        ep_poll_safewake(&amp;ep-&gt;poll_wait);  </span><br><span class="line">  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="epoll-wait"><a href="#epoll-wait" class="headerlink" title="epoll_wait"></a>epoll_wait</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line">epoll_wait实现 </span><br><span class="line">*/  </span><br><span class="line">  </span><br><span class="line">SYSCALL_DEFINE4(epoll_wait, int, epfd, struct epoll_event __user *, events,  </span><br><span class="line">                int, maxevents, int, timeout)  </span><br><span class="line">&#123;  </span><br><span class="line">    int error;  </span><br><span class="line">    struct file *file;  </span><br><span class="line">    struct eventpoll *ep;  </span><br><span class="line">  </span><br><span class="line">    // 检查输入数据有效性  </span><br><span class="line">    if (maxevents &lt;= 0 || maxevents &gt; EP_MAX_EVENTS) &#123;  </span><br><span class="line">        return -EINVAL;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    if (!access_ok(VERIFY_WRITE, events, maxevents * sizeof(struct epoll_event))) &#123;  </span><br><span class="line">        error = -EFAULT;  </span><br><span class="line">        goto error_return;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    /* Get the &quot;struct file *&quot; for the eventpoll file */  </span><br><span class="line">    error = -EBADF;  </span><br><span class="line">    file = fget(epfd);  </span><br><span class="line">    if (!file) &#123;  </span><br><span class="line">        goto error_return;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    error = -EINVAL;  </span><br><span class="line">    if (!is_file_epoll(file)) &#123;  </span><br><span class="line">        goto error_fput;  </span><br><span class="line">    &#125;  </span><br><span class="line">    // 取得ep 结构  </span><br><span class="line">    ep = file-&gt;private_data;  </span><br><span class="line">  </span><br><span class="line">    // 等待事件  </span><br><span class="line">    error = ep_poll(ep, events, maxevents, timeout);  </span><br><span class="line">  </span><br><span class="line">error_fput:  </span><br><span class="line">    fput(file);  </span><br><span class="line">error_return:  </span><br><span class="line">  </span><br><span class="line">    return error;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">static int ep_poll(struct eventpoll *ep, struct epoll_event __user *events,  </span><br><span class="line">                   int maxevents, long timeout)  </span><br><span class="line">&#123;  </span><br><span class="line">    int res = 0, eavail, timed_out = 0;  </span><br><span class="line">    unsigned long flags;  </span><br><span class="line">    long slack = 0;  </span><br><span class="line">    wait_queue_t wait;  </span><br><span class="line">    ktime_t expires, *to = NULL;  </span><br><span class="line">  </span><br><span class="line">    if (timeout &gt; 0) &#123;  </span><br><span class="line">        // 转换为内核时间  </span><br><span class="line">        struct timespec end_time = ep_set_mstimeout(timeout);  </span><br><span class="line">  </span><br><span class="line">        slack = select_estimate_accuracy(&amp;end_time);  </span><br><span class="line">        to = &amp;expires;  </span><br><span class="line">        *to = timespec_to_ktime(end_time);  </span><br><span class="line">    &#125; else if (timeout == 0) &#123;  </span><br><span class="line">        // 已经超时直接检查readylist  </span><br><span class="line">        timed_out = 1;  </span><br><span class="line">        spin_lock_irqsave(&amp;ep-&gt;lock, flags);  </span><br><span class="line">        goto check_events;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">fetch_events:  </span><br><span class="line">    spin_lock_irqsave(&amp;ep-&gt;lock, flags);  </span><br><span class="line">  </span><br><span class="line">    // 没有可用的事件，ready list 和ovflist 都为空  </span><br><span class="line">    if (!ep_events_available(ep)) &#123;  </span><br><span class="line">  </span><br><span class="line">        // 添加当前进程的唤醒函数  </span><br><span class="line">        init_waitqueue_entry(&amp;wait, current);  </span><br><span class="line">        __add_wait_queue_exclusive(&amp;ep-&gt;wq, &amp;wait);  </span><br><span class="line">  </span><br><span class="line">        for (;;) &#123;  </span><br><span class="line">            /* </span><br><span class="line">             * We don&apos;t want to sleep if the ep_poll_callback() sends us </span><br><span class="line">             * a wakeup in between. That&apos;s why we set the task state </span><br><span class="line">             * to TASK_INTERRUPTIBLE before doing the checks. </span><br><span class="line">             */  </span><br><span class="line">            set_current_state(TASK_INTERRUPTIBLE);  </span><br><span class="line">            if (ep_events_available(ep) || timed_out) &#123;  </span><br><span class="line">                break;  </span><br><span class="line">            &#125;  </span><br><span class="line">            if (signal_pending(current)) &#123;  </span><br><span class="line">                res = -EINTR;  </span><br><span class="line">                break;  </span><br><span class="line">            &#125;  </span><br><span class="line">  </span><br><span class="line">            spin_unlock_irqrestore(&amp;ep-&gt;lock, flags);  </span><br><span class="line">            // 挂起当前进程，等待唤醒或超时  </span><br><span class="line">            if (!schedule_hrtimeout_range(to, slack, HRTIMER_MODE_ABS)) &#123;  </span><br><span class="line">                timed_out = 1;  </span><br><span class="line">            &#125;  </span><br><span class="line">  </span><br><span class="line">            spin_lock_irqsave(&amp;ep-&gt;lock, flags);  </span><br><span class="line">        &#125;  </span><br><span class="line">      </span><br><span class="line">        __remove_wait_queue(&amp;ep-&gt;wq, &amp;wait);  </span><br><span class="line">  </span><br><span class="line">        set_current_state(TASK_RUNNING);  </span><br><span class="line">    &#125;  </span><br><span class="line">check_events:  </span><br><span class="line">    // 再次检查是否有可用事件  </span><br><span class="line">    eavail = ep_events_available(ep);  </span><br><span class="line">  </span><br><span class="line">    spin_unlock_irqrestore(&amp;ep-&gt;lock, flags);  </span><br><span class="line">  </span><br><span class="line">    /* </span><br><span class="line">     * Try to transfer events to user space. In case we get 0 events and </span><br><span class="line">     * there&apos;s still timeout left over, we go trying again in search of </span><br><span class="line">     * more luck. </span><br><span class="line">     */  </span><br><span class="line">    if (!res &amp;&amp; eavail   </span><br><span class="line">            &amp;&amp; !(res = ep_send_events(ep, events, maxevents)) // 复制事件到用户空间  </span><br><span class="line">            &amp;&amp; !timed_out) // 复制事件失败并且没有超时，重新等待。  </span><br><span class="line">            &#123;  </span><br><span class="line">        goto fetch_events;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    return res;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">static inline int ep_events_available(struct eventpoll *ep)  </span><br><span class="line">&#123;  </span><br><span class="line">    return !list_empty(&amp;ep-&gt;rdllist) || ep-&gt;ovflist != EP_UNACTIVE_PTR;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">struct ep_send_events_data &#123;  </span><br><span class="line">    int maxevents;  </span><br><span class="line">    struct epoll_event __user *events;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line">static int ep_send_events(struct eventpoll *ep,  </span><br><span class="line">                          struct epoll_event __user *events, int maxevents)  </span><br><span class="line">&#123;  </span><br><span class="line">    struct ep_send_events_data esed;  </span><br><span class="line">  </span><br><span class="line">    esed.maxevents = maxevents;  </span><br><span class="line">    esed.events = events;  </span><br><span class="line">  </span><br><span class="line">    return ep_scan_ready_list(ep, ep_send_events_proc, &amp;esed, 0);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">static int ep_send_events_proc(struct eventpoll *ep, struct list_head *head,  </span><br><span class="line">                               void *priv)  </span><br><span class="line">&#123;  </span><br><span class="line">    struct ep_send_events_data *esed = priv;  </span><br><span class="line">    int eventcnt;  </span><br><span class="line">    unsigned int revents;  </span><br><span class="line">    struct epitem *epi;  </span><br><span class="line">    struct epoll_event __user *uevent;  </span><br><span class="line">  </span><br><span class="line">    // 遍历已就绪链表  </span><br><span class="line">    for (eventcnt = 0, uevent = esed-&gt;events;  </span><br><span class="line">            !list_empty(head) &amp;&amp; eventcnt &lt; esed-&gt;maxevents;) &#123;  </span><br><span class="line">        epi = list_first_entry(head, struct epitem, rdllink);  </span><br><span class="line">  </span><br><span class="line">        list_del_init(&amp;epi-&gt;rdllink);  </span><br><span class="line">        // 获取ready 事件掩码  </span><br><span class="line">        revents = epi-&gt;ffd.file-&gt;f_op-&gt;poll(epi-&gt;ffd.file, NULL) &amp;  </span><br><span class="line">                  epi-&gt;event.events;  </span><br><span class="line">  </span><br><span class="line">        /* </span><br><span class="line">         * If the event mask intersect the caller-requested one, </span><br><span class="line">         * deliver the event to userspace. Again, ep_scan_ready_list() </span><br><span class="line">         * is holding &quot;mtx&quot;, so no operations coming from userspace </span><br><span class="line">         * can change the item. </span><br><span class="line">         */  </span><br><span class="line">        if (revents) &#123;  </span><br><span class="line">            // 事件就绪, 复制到用户空间  </span><br><span class="line">            if (__put_user(revents, &amp;uevent-&gt;events) ||  </span><br><span class="line">                    __put_user(epi-&gt;event.data, &amp;uevent-&gt;data)) &#123;  </span><br><span class="line">                list_add(&amp;epi-&gt;rdllink, head);  </span><br><span class="line">                return eventcnt ? eventcnt : -EFAULT;  </span><br><span class="line">            &#125;  </span><br><span class="line">            eventcnt++;  </span><br><span class="line">            uevent++;  </span><br><span class="line">            if (epi-&gt;event.events &amp; EPOLLONESHOT) &#123;  </span><br><span class="line">                epi-&gt;event.events &amp;= EP_PRIVATE_BITS;  </span><br><span class="line">            &#125; else if (!(epi-&gt;event.events &amp; EPOLLET)) &#123;  </span><br><span class="line">                // 不是边缘模式, 再次添加到ready list,  </span><br><span class="line">                // 下次epoll_wait 时直接进入此函数检查ready list是否仍然继续  </span><br><span class="line">                list_add_tail(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist);  </span><br><span class="line">            &#125;  </span><br><span class="line">            // 如果是边缘模式, 只有当文件状态发生改变时,  </span><br><span class="line">            // 才文件会再次触发wait_address 上wait_queue的回调函数,  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    return eventcnt;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="eventpoll-poll"><a href="#eventpoll-poll" class="headerlink" title="eventpoll_poll"></a>eventpoll_poll</h2><p> 由于epoll自身也是文件系统，其描述符也可以被poll/select/epoll监视，因此需要实现poll方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">static const struct file_operations eventpoll_fops = &#123;  </span><br><span class="line">    .release = ep_eventpoll_release,  </span><br><span class="line">    .poll    = ep_eventpoll_poll,  </span><br><span class="line">    .llseek  = noop_llseek,  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line">static unsigned int ep_eventpoll_poll(struct file *file, poll_table *wait)  </span><br><span class="line">&#123;  </span><br><span class="line">    int pollflags;  </span><br><span class="line">    struct eventpoll *ep = file-&gt;private_data;  </span><br><span class="line">    // 插入到wait_queue  </span><br><span class="line">    poll_wait(file, &amp;ep-&gt;poll_wait, wait);  </span><br><span class="line">    // 扫描就绪的文件列表, 调用每个文件上的poll 检测是否真的就绪,  </span><br><span class="line">    // 然后复制到用户空间  </span><br><span class="line">    // 文件列表中有可能有epoll文件, 调用poll的时候有可能会产生递归,  </span><br><span class="line">    // 调用所以用ep_call_nested 包装一下, 防止死循环和过深的调用  </span><br><span class="line">    pollflags = ep_call_nested(&amp;poll_readywalk_ncalls, EP_MAX_NESTS,  </span><br><span class="line">                               ep_poll_readyevents_proc, ep, ep, current);  </span><br><span class="line">    // static struct nested_calls poll_readywalk_ncalls;  </span><br><span class="line">    return pollflags != -1 ? pollflags : 0;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">static int ep_poll_readyevents_proc(void *priv, void *cookie, int call_nests)  </span><br><span class="line">&#123;  </span><br><span class="line">    return ep_scan_ready_list(priv, ep_read_events_proc, NULL, call_nests + 1);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">static int ep_scan_ready_list(struct eventpoll *ep,  </span><br><span class="line">                              int (*sproc)(struct eventpoll *,  </span><br><span class="line">                                      struct list_head *, void *),  </span><br><span class="line">                              void *priv,  </span><br><span class="line">                              int depth)  </span><br><span class="line">&#123;  </span><br><span class="line">    int error, pwake = 0;  </span><br><span class="line">    unsigned long flags;  </span><br><span class="line">    struct epitem *epi, *nepi;  </span><br><span class="line">    LIST_HEAD(txlist);  </span><br><span class="line">  </span><br><span class="line">    /* </span><br><span class="line">     * We need to lock this because we could be hit by </span><br><span class="line">     * eventpoll_release_file() and epoll_ctl(). </span><br><span class="line">     */  </span><br><span class="line">    mutex_lock_nested(&amp;ep-&gt;mtx, depth);  </span><br><span class="line">  </span><br><span class="line">    spin_lock_irqsave(&amp;ep-&gt;lock, flags);  </span><br><span class="line">    // 移动rdllist 到新的链表txlist  </span><br><span class="line">    list_splice_init(&amp;ep-&gt;rdllist, &amp;txlist);  </span><br><span class="line">    // 改变ovflist 的状态, 如果ep-&gt;ovflist != EP_UNACTIVE_PTR,  </span><br><span class="line">    // 当文件激活wait_queue时，就会将对应的epitem加入到ep-&gt;ovflist  </span><br><span class="line">    // 否则将文件直接加入到ep-&gt;rdllist，  </span><br><span class="line">    // 这样做的目的是避免丢失事件  </span><br><span class="line">    // 这里不需要检查ep-&gt;ovflist 的状态，因为ep-&gt;mtx的存在保证此处的ep-&gt;ovflist  </span><br><span class="line">    // 一定是EP_UNACTIVE_PTR  </span><br><span class="line">    ep-&gt;ovflist = NULL;  </span><br><span class="line">    spin_unlock_irqrestore(&amp;ep-&gt;lock, flags);  </span><br><span class="line">  </span><br><span class="line">    // 调用扫描函数处理txlist  </span><br><span class="line">    error = (*sproc)(ep, &amp;txlist, priv);  </span><br><span class="line">  </span><br><span class="line">    spin_lock_irqsave(&amp;ep-&gt;lock, flags);  </span><br><span class="line">  </span><br><span class="line">    // 调用 sproc 时可能有新的事件，遍历这些新的事件将其插入到ready list  </span><br><span class="line">    for (nepi = ep-&gt;ovflist; (epi = nepi) != NULL;  </span><br><span class="line">            nepi = epi-&gt;next, epi-&gt;next = EP_UNACTIVE_PTR) &#123;  </span><br><span class="line">        // #define EP_UNACTIVE_PTR (void *) -1  </span><br><span class="line">        // epi 不在rdllist, 插入  </span><br><span class="line">        if (!ep_is_linked(&amp;epi-&gt;rdllink)) &#123;  </span><br><span class="line">            list_add_tail(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    // 还原ep-&gt;ovflist的状态  </span><br><span class="line">    ep-&gt;ovflist = EP_UNACTIVE_PTR;  </span><br><span class="line">  </span><br><span class="line">    // 将处理后的 txlist 链接到 rdllist  </span><br><span class="line">    list_splice(&amp;txlist, &amp;ep-&gt;rdllist);  </span><br><span class="line">  </span><br><span class="line">    if (!list_empty(&amp;ep-&gt;rdllist)) &#123;  </span><br><span class="line">        // 唤醒epoll_wait  </span><br><span class="line">        if (waitqueue_active(&amp;ep-&gt;wq)) &#123;  </span><br><span class="line">            wake_up_locked(&amp;ep-&gt;wq);  </span><br><span class="line">        &#125;  </span><br><span class="line">        // 当前的ep有其他的事件通知机制监控  </span><br><span class="line">        if (waitqueue_active(&amp;ep-&gt;poll_wait)) &#123;  </span><br><span class="line">            pwake++;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    spin_unlock_irqrestore(&amp;ep-&gt;lock, flags);  </span><br><span class="line">  </span><br><span class="line">    mutex_unlock(&amp;ep-&gt;mtx);  </span><br><span class="line">  </span><br><span class="line">    if (pwake) &#123;  </span><br><span class="line">        // 安全唤醒外部的事件通知机制  </span><br><span class="line">        ep_poll_safewake(&amp;ep-&gt;poll_wait);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    return error;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">static int ep_read_events_proc(struct eventpoll *ep, struct list_head *head,  </span><br><span class="line">                               void *priv)  </span><br><span class="line">&#123;  </span><br><span class="line">    struct epitem *epi, *tmp;  </span><br><span class="line">    poll_table pt;  </span><br><span class="line">    init_poll_funcptr(&amp;pt, NULL);  </span><br><span class="line">    list_for_each_entry_safe(epi, tmp, head, rdllink) &#123;  </span><br><span class="line">        pt._key = epi-&gt;event.events;  </span><br><span class="line">        if (epi-&gt;ffd.file-&gt;f_op-&gt;poll(epi-&gt;ffd.file, &amp;pt) &amp;  </span><br><span class="line">                epi-&gt;event.events) &#123;  </span><br><span class="line">            return POLLIN | POLLRDNORM;  </span><br><span class="line">        &#125; else &#123;  </span><br><span class="line">             // 这个事件虽然在就绪列表中,  </span><br><span class="line">             // 但是实际上并没有就绪, 将他移除  </span><br><span class="line">         // 这有可能是水平触发模式中没有将文件从就绪列表中移除  </span><br><span class="line">         // 也可能是事件插入到就绪列表后有其他的线程对文件进行了操作  </span><br><span class="line">            list_del_init(&amp;epi-&gt;rdllink);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="epoll全景"><a href="#epoll全景" class="headerlink" title="epoll全景"></a>epoll全景</h2><p>以下是epoll使用的全部数据结构之间的关系图，采用的是一种类UML图，希望对理解epoll的内部实现有所帮助。<br><img src="/img/7a411842-3615-3c89-aee0-3f5cfb36a044.bmp" alt></p>
<h1 id="poll-select-epoll-对比"><a href="#poll-select-epoll-对比" class="headerlink" title="poll/select/epoll 对比"></a>poll/select/epoll 对比</h1><p>通过以上的分析可以看出，poll和select的实现基本是一致，只是用户到内核传递的数据格式有所不同，</p>
<p>select和poll即使只有一个描述符就绪，也要遍历整个集合。如果集合中活跃的描述符很少，遍历过程的开销就会变得很大，而如果集合中大部分的描述符都是活跃的，遍历过程的开销又可以忽略。</p>
<p>epoll的实现中每次只遍历活跃的描述符(如果是水平触发，也会遍历先前活跃的描述符)，在活跃描述符较少的情况下就会很有优势，在代码的分析过程中可以看到epoll的实现过于复杂并且其实现过程中需要同步处理(锁)，如果大部分描述符都是活跃的，epoll的效率可能不如select或poll。(参见epoll 和poll的性能测试 <a href="http://jacquesmattheij.com/Poll+vs+Epoll+once+again" target="_blank" rel="noopener">http://jacquesmattheij.com/Poll+vs+Epoll+once+again</a>)</p>
<p>select能够处理的最大fd无法超出FDSETSIZE。</p>
<p>select会复写传入的fd_set 指针，而poll对每个fd返回一个掩码，不更改原来的掩码，从而可以对同一个集合多次调用poll，而无需调整。</p>
<p>select对每个文件描述符最多使用3个bit，而poll采用的pollfd需要使用64个bit，epoll采用的 epoll_event则需要96个bit</p>
<p>如果事件需要循环处理select, poll 每一次的处理都要将全部的数据复制到内核，而epoll的实现中，内核将持久维护加入的描述符，减少了内核和用户复制数据的开销。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Linux/" rel="tag"># Linux</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/11/16/6.828-lab6/" rel="next" title="6.828 lab6">
                <i class="fa fa-chevron-left"></i> 6.828 lab6
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/11/27/编译器常用的一些优化方法/" rel="prev" title="编译器常用的一些优化方法">
                编译器常用的一些优化方法 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/header.jpg" alt="Hao Yu">
            
              <p class="site-author-name" itemprop="name">Hao Yu</p>
              <p class="site-description motion-element" itemprop="description">Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author</p>
          </div>
          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">252</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>
        	<audio controls="controls" loop="loop" preload="auto" src="/resource/xiaomeihao.mp3">
	        </audio>
	

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yuhao0102" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:yuh18@mails.tsinghua.edu.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#导言"><span class="nav-number">1.</span> <span class="nav-text">导言</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#计算机存储器"><span class="nav-number">1.1.</span> <span class="nav-text">计算机存储器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#物理内存"><span class="nav-number">1.2.</span> <span class="nav-text">物理内存</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#虚拟内存"><span class="nav-number">1.3.</span> <span class="nav-text">虚拟内存</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#用户态和内核态"><span class="nav-number">1.4.</span> <span class="nav-text">用户态和内核态</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Linux-I-O"><span class="nav-number">2.</span> <span class="nav-text">Linux I/O</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#I-O-缓冲区"><span class="nav-number">2.1.</span> <span class="nav-text">I/O 缓冲区</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#I-O-模式"><span class="nav-number">2.2.</span> <span class="nav-text">I/O 模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#程序控制-I-O"><span class="nav-number">2.2.1.</span> <span class="nav-text">程序控制 I/O</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#中断驱动-I-O"><span class="nav-number">2.2.2.</span> <span class="nav-text">中断驱动 I/O</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DMA-I-O"><span class="nav-number">2.2.3.</span> <span class="nav-text">DMA I/O</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#传统-I-O-读写模式"><span class="nav-number">2.3.</span> <span class="nav-text">传统 I/O 读写模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#零拷贝-Zero-copy"><span class="nav-number">2.4.</span> <span class="nav-text">零拷贝 (Zero-copy)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Zero-copy-是什么？"><span class="nav-number">2.4.1.</span> <span class="nav-text">Zero-copy 是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Zero-copy-能做什么？"><span class="nav-number">2.4.2.</span> <span class="nav-text">Zero-copy 能做什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Zero-copy-的实现方式有哪些？"><span class="nav-number">2.4.3.</span> <span class="nav-text">Zero-copy 的实现方式有哪些？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#减少甚至避免用户空间和内核空间之间的数据拷贝"><span class="nav-number">2.5.</span> <span class="nav-text">减少甚至避免用户空间和内核空间之间的数据拷贝</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#mmap"><span class="nav-number">2.5.1.</span> <span class="nav-text">mmap()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sendfile"><span class="nav-number">2.5.2.</span> <span class="nav-text">sendfile()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sendﬁle-with-DMA-Scatter-Gather-Copy"><span class="nav-number">2.5.3.</span> <span class="nav-text">sendﬁle() with DMA Scatter/Gather Copy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#splice"><span class="nav-number">2.5.4.</span> <span class="nav-text">splice()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#send-with-MSG-ZEROCOPY"><span class="nav-number">2.5.5.</span> <span class="nav-text">send() with MSG_ZEROCOPY</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#绕过内核的直接-I-O"><span class="nav-number">2.6.</span> <span class="nav-text">绕过内核的直接 I/O</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#用户直接访问硬件"><span class="nav-number">2.6.1.</span> <span class="nav-text">用户直接访问硬件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内核控制访问硬件"><span class="nav-number">2.6.2.</span> <span class="nav-text">内核控制访问硬件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内核缓冲区和用户缓冲区之间的传输优化"><span class="nav-number">2.7.</span> <span class="nav-text">内核缓冲区和用户缓冲区之间的传输优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#动态重映射与写时拷贝-Copy-on-Write"><span class="nav-number">2.7.1.</span> <span class="nav-text">动态重映射与写时拷贝 (Copy-on-Write)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缓冲区共享-Buffer-Sharing"><span class="nav-number">2.7.2.</span> <span class="nav-text">缓冲区共享 (Buffer Sharing)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#fbufs-的缺陷"><span class="nav-number">2.7.3.</span> <span class="nav-text">fbufs 的缺陷</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#总结"><span class="nav-number">3.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#poll-select-epoll剖析"><span class="nav-number">4.</span> <span class="nav-text">poll select epoll剖析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#poll-和-select"><span class="nav-number">4.1.</span> <span class="nav-text">poll 和 select</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#关键结构体"><span class="nav-number">4.1.1.</span> <span class="nav-text">关键结构体</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#公共函数"><span class="nav-number">4.1.2.</span> <span class="nav-text">公共函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#poll-select核心结构关系"><span class="nav-number">4.1.3.</span> <span class="nav-text">poll/select核心结构关系</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#poll的实现"><span class="nav-number">4.2.</span> <span class="nav-text">poll的实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#select-实现"><span class="nav-number">4.3.</span> <span class="nav-text">select 实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#epoll实现"><span class="nav-number">4.4.</span> <span class="nav-text">epoll实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#epoll的核心数据结构"><span class="nav-number">4.4.1.</span> <span class="nav-text">epoll的核心数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#文件系统初始化和epoll-create"><span class="nav-number">4.4.2.</span> <span class="nav-text">文件系统初始化和epoll_create</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#epoll中的递归死循环和深度检查"><span class="nav-number">4.4.3.</span> <span class="nav-text">epoll中的递归死循环和深度检查</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#递归深度检测-ep-call-nested"><span class="nav-number">4.4.3.1.</span> <span class="nav-text">递归深度检测(ep_call_nested)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#循环检测-ep-loop-check"><span class="nav-number">4.4.4.</span> <span class="nav-text">循环检测(ep_loop_check)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#唤醒风暴检测（reverse-path-check）"><span class="nav-number">4.4.5.</span> <span class="nav-text">唤醒风暴检测（reverse_path_check）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#epoll-的唤醒过程"><span class="nav-number">4.4.6.</span> <span class="nav-text">epoll 的唤醒过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#epoll-ctl"><span class="nav-number">4.4.7.</span> <span class="nav-text">epoll_ctl</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#EPOLL-CTL-ADD-实现"><span class="nav-number">4.4.8.</span> <span class="nav-text">EPOLL_CTL_ADD 实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#EPOLL-CTL-DEL"><span class="nav-number">4.4.9.</span> <span class="nav-text">EPOLL_CTL_DEL</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#epoll-wait"><span class="nav-number">4.5.</span> <span class="nav-text">epoll_wait</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#eventpoll-poll"><span class="nav-number">4.6.</span> <span class="nav-text">eventpoll_poll</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#epoll全景"><span class="nav-number">4.7.</span> <span class="nav-text">epoll全景</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#poll-select-epoll-对比"><span class="nav-number">5.</span> <span class="nav-text">poll/select/epoll 对比</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>
  <div id="DvelopmentTarget">     
  </div>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart" aria-hidden="false"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>

  
</div>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_uv"> 
  本站访客数<span id="busuanzi_value_site_uv"></span>人次
</span>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  


  

  


  <script type="text/javascript" src="/js/src/love.js"></script>

</body>
</html>
