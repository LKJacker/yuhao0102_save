<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zn-ch">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-center-simple.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="C++,">










<meta name="description" content="jemalloc是一个通用的malloc(3)实现，着重于减少内存碎片和提高并发性能，在许多项目中都有用到，比如Rust和Redis。 背景知识内存的来源Linux提供了几个系统调用用于分配内存:  brk()：调整program break，改变data segment的大小。 mmap()：在进程的虚拟地址空间中创建新的内存映射。内存分配器一般使用该系统调用创建私有匿名映射分配内存，内核会以p">
<meta name="keywords" content="C++">
<meta property="og:type" content="article">
<meta property="og:title" content="jemalloc源码解析">
<meta property="og:url" content="http://yoursite.com/2021/11/01/jemalloc源码解析/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="jemalloc是一个通用的malloc(3)实现，着重于减少内存碎片和提高并发性能，在许多项目中都有用到，比如Rust和Redis。 背景知识内存的来源Linux提供了几个系统调用用于分配内存:  brk()：调整program break，改变data segment的大小。 mmap()：在进程的虚拟地址空间中创建新的内存映射。内存分配器一般使用该系统调用创建私有匿名映射分配内存，内核会以p">
<meta property="og:locale" content="zn-ch">
<meta property="og:image" content="http://yoursite.com/img/20211102100900.png">
<meta property="og:image" content="http://yoursite.com/img/c2dv3kuw94.png">
<meta property="og:image" content="http://yoursite.com/img/20211102100901.png">
<meta property="og:image" content="http://yoursite.com/img/20211102100902.png">
<meta property="og:image" content="http://yoursite.com/img/20211102100903.png">
<meta property="og:image" content="http://yoursite.com/img/20211102100904.png">
<meta property="og:image" content="http://yoursite.com/img/v2-92f9c4741a626e4a48a9ca987d36b82c_1440w.jpg">
<meta property="og:image" content="http://yoursite.com/img/v2-4ce3efe4b89f927df4b4c0cfbd588558_1440w.jpg">
<meta property="og:image" content="http://yoursite.com/img/v2-07d44c859efbc6ac177b27793acb96e8_1440w.jpg">
<meta property="og:updated_time" content="2021-11-14T08:22:08.504Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="jemalloc源码解析">
<meta name="twitter:description" content="jemalloc是一个通用的malloc(3)实现，着重于减少内存碎片和提高并发性能，在许多项目中都有用到，比如Rust和Redis。 背景知识内存的来源Linux提供了几个系统调用用于分配内存:  brk()：调整program break，改变data segment的大小。 mmap()：在进程的虚拟地址空间中创建新的内存映射。内存分配器一般使用该系统调用创建私有匿名映射分配内存，内核会以p">
<meta name="twitter:image" content="http://yoursite.com/img/20211102100900.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2021/11/01/jemalloc源码解析/">





  <title>jemalloc源码解析 | Hao Yu's blog</title>
  








 
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zn-ch">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hao Yu's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">The program monkey was eaten by the siege lion.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/resume.pdf" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-mybetterhalf">
          <a href="/mybetterhalf/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>
            
            mybetterhalf
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/11/01/jemalloc源码解析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">jemalloc源码解析</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-11-01T23:57:00+08:00">
                2021-11-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><code>jemalloc</code>是一个通用的<code>malloc(3)</code>实现，着重于减少内存碎片和提高并发性能，在许多项目中都有用到，比如<code>Rust</code>和<code>Redis</code>。</p>
<h1 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h1><h2 id="内存的来源"><a href="#内存的来源" class="headerlink" title="内存的来源"></a>内存的来源</h2><p><code>Linux</code>提供了几个系统调用用于分配内存:</p>
<ul>
<li><code>brk()</code>：调整<code>program break</code>，改变<code>data segment</code>的大小。</li>
<li><code>mmap()</code>：在进程的虚拟地址空间中创建新的内存映射。内存分配器一般使用该系统调用创建私有匿名映射分配内存，内核会以<code>page size</code>大小倍数来分配，<code>page size</code>一般为 4096 字节。</li>
</ul>
<p>对应的释放内存也有几种方式:</p>
<ul>
<li><code>brk()</code>：既可以增大也可以缩小。</li>
<li><code>munmap()</code>：解除映射。</li>
<li><code>madvise()</code>：该系统调用会告诉操作系统这块内存之后会如何使用，由操作系统进行处理。释放时，会使用<code>MADV_DONTNEED</code>或 <code>MADV_FREE</code>:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">MADV_DONTNEED</span><br><span class="line">           Do not expect access in the near future.  (For the time being,</span><br><span class="line">           the application is finished with the given range, so the</span><br><span class="line">           kernel can free resources associated with it.)</span><br><span class="line"></span><br><span class="line">           After a successful MADV_DONTNEED operation, the semantics of</span><br><span class="line">           memory access in the specified region are changed: subsequent</span><br><span class="line">           accesses of pages in the range will succeed, but will result</span><br><span class="line">           in either repopulating the memory contents from the up-to-date</span><br><span class="line">           contents of the underlying mapped file (for shared file</span><br><span class="line">           mappings, shared anonymous mappings, and shmem-based</span><br><span class="line">           techniques such as System V shared memory segments) or zero-</span><br><span class="line">           fill-on-demand pages for anonymous private mappings.</span><br><span class="line"></span><br><span class="line">           Note that, when applied to shared mappings, MADV_DONTNEED</span><br><span class="line">           might not lead to immediate freeing of the pages in the range.</span><br><span class="line">           The kernel is free to delay freeing the pages until an</span><br><span class="line">           appropriate moment.  The resident set size (RSS) of the</span><br><span class="line">           calling process will be immediately reduced however.</span><br><span class="line"></span><br><span class="line">           MADV_DONTNEED cannot be applied to locked pages, Huge TLB</span><br><span class="line">           pages, or VM_PFNMAP pages.  (Pages marked with the kernel-</span><br><span class="line">           internal VM_PFNMAP flag are special memory areas that are not</span><br><span class="line">           managed by the virtual memory subsystem.  Such pages are</span><br><span class="line">           typically created by device drivers that map the pages into</span><br><span class="line">           user space.)</span><br></pre></td></tr></table></figure>
<p>可以看出来，对于私有匿名映射会立即释放，而在之后再次访问这块内存时，不需要重新分配。</p>
<h2 id="False-cache-line-sharing"><a href="#False-cache-line-sharing" class="headerlink" title="False cache line sharing"></a>False cache line sharing</h2><p>为了减少存储器访问延迟，<code>CPU</code>中会有本地<code>Cache</code>，<code>Cache</code>被划分为<code>cache line</code>，大小一般为<code>64B</code>。<code>CPU</code>访问内存时，会首先将内存缓存在<code>cache line</code>中。 在多处理器系统中，每个<code>CPU</code>都有自己的本地<code>Cache</code>，会导致数据多副本，也就带来了一致性问题：多个<code>CPU</code>的<code>cache line</code>中有相同地址的内存。需要实现<code>Cache Coherence Protocol</code>来解决这个问题。现代处理器一般使用<code>MESI</code>协议实现<code>Cache Coherence</code>，这会带来通讯耗时、总线压力、导致<code>cache line</code>的抖动，影响性能。</p>
<p>避免这个问题主要有下面几个方法：</p>
<ul>
<li><code>__declspec (align(64))</code>：变量起始地址按<code>cache line</code>对齐</li>
<li>当使用数组或结构体时，不仅需要起始地址对齐，还需要<code>padding</code>，使得数组元素或结构体大小为<code>cache line</code>倍数</li>
<li>避免多线程使用相近地址的内存，多使用局部变量</li>
</ul>
<h2 id="内存着色"><a href="#内存着色" class="headerlink" title="内存着色"></a>内存着色</h2><p>现代<code>CPU</code>的<code>Cache</code>映射策略有很多，如组相联、全相联、直接相联。不同地址的内存有可能映射到相同的<code>cache line</code>(主要发生在地址对齐的情况，如不同对象的地址按照<code>page size</code>对齐)，如果频繁交替访问映射到相同<code>cache line</code>的内存，就会造成<code>cache line</code>的颠簸。 内存着色通过给对象地址增加<code>cache line</code>大小倍数的偏移，从而映射到不同的<code>cache line</code>，来避免上面的问题。</p>
<h2 id="为什么需要内存分配器"><a href="#为什么需要内存分配器" class="headerlink" title="为什么需要内存分配器"></a>为什么需要内存分配器</h2><p>因为<code>mmap()</code>按照<code>page size</code>进行分配，一般是 4096 字节，若每次分配时都调用一次会造成极大的内存浪费，并且性能不好。若由程序员自己管理<code>page</code>，容易出错且性能不好，所以<code>glibc</code>中提供了标准<code>malloc(3)</code>供程序员使用。</p>
<h2 id="内存分配器的目标"><a href="#内存分配器的目标" class="headerlink" title="内存分配器的目标"></a>内存分配器的目标</h2><p>内存分配器的目标主要有2个：</p>
<ul>
<li>减少内存碎片，包括内部碎片和外部碎片:<ul>
<li>内部碎片：分配出去的但没有使用到的内存，比如需要 32 字节，分配了 40 字节，多余的 8 字节就是内部碎片。</li>
<li>外部碎片：大小不合适导致无法分配出去的内存，比如一直申请 16 字节的内存，但是内存分配器中保存着部分 8 字节的内存，一直分配不出去。</li>
</ul>
</li>
<li>提高性能:<ul>
<li>单线程性能</li>
<li>多线程性能</li>
</ul>
</li>
</ul>
<p><code>jemalloc</code>和<code>tcmalloc</code>都是对<code>glibc</code>中的优化，目的也是为了减少内存碎片和提高性能。</p>
<h1 id="常用内存分配器算法"><a href="#常用内存分配器算法" class="headerlink" title="常用内存分配器算法"></a>常用内存分配器算法</h1><h2 id="Dynamic-memory-allocation"><a href="#Dynamic-memory-allocation" class="headerlink" title="Dynamic memory allocation"></a>Dynamic memory allocation</h2><p>首先分配一整块内存，然后按需从这块内存中分配。一般会在分配出的内存前面保存<code>metadata</code>，还会维护<code>freelist</code>用于查找空闲内存。但这会导致比较严重的外部碎片:<br><img src="/img/20211102100900.png" alt></p>
<h2 id="Buddy-memory-allocation"><a href="#Buddy-memory-allocation" class="headerlink" title="Buddy memory allocation"></a>Buddy memory allocation</h2><p>以<code>Binary buddy algorithm</code>为例：同样从一块内存中分配，但此时不是按需分配大小，而是这块内存不断分成一半，直到到达目标大小或者下界。在释放的时候，会和之前分裂的且空闲的进行合并。 一般会用有序结构如红黑树，来存储不同大小的<code>buddy block</code>，这样分配和合并时可以快速查找合适的内存。</p>
<p>这种算法能够有效减少外部碎片，但内部碎片很严重，<code>Binary buddy algorithm</code>最严重会带来 50% 的内部碎片。</p>
<h2 id="Slab-allocation"><a href="#Slab-allocation" class="headerlink" title="Slab allocation"></a>Slab allocation</h2><p>对象的初始化和释放往往比内存的分配和释放代价大，基于此发明了<code>slab</code>。<code>slab</code>会提前分配一块内存，然后将这块连续内存划分为大小相同的<code>slots</code>，使用相应的数据结构记录每个<code>slots</code>的分配状况，如<code>bitmap</code>。 当需要分配时，就查找对应大小的<code>slab</code>，分配出一个空闲<code>slot</code>，而释放时就是把这个<code>slot</code>标记为空闲。</p>
<p><code>slab</code>的<code>size classes</code>影响碎片的产生，需要精心选择：</p>
<ul>
<li><code>size classes</code>太稀疏会导致内部碎片</li>
<li><code>size classes</code>太密集又会导致外部碎片</li>
</ul>
<h1 id="jemalloc-源码分析"><a href="#jemalloc-源码分析" class="headerlink" title="jemalloc 源码分析"></a>jemalloc 源码分析</h1><p><code>Redis</code>一般不使用<code>glibc</code>中默认的内存分配器，在编译时可以指定使用自带的<code>jemalloc</code>，版本为 4.0.3，编译参数如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --with-lg-quantum=3 --with-jemalloc-prefix=je_ --enable-cc-silence CFLAGS=&quot;-std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops &quot; LDFLAGS=&quot;&quot;</span><br></pre></td></tr></table></figure></p>
<ol>
<li><code>--with-lg-quantum=&lt;lg-quantum&gt;</code>：Base 2 log of minimum allocation alignment. 8字节对齐</li>
<li><code>--with-jemalloc-prefix=&lt;prefix&gt;</code>：Prefix to prepend to all public APIs.</li>
<li><code>--disable-cc-silence</code>：Do not silence irrelevant compiler warnings.</li>
</ol>
<p><code>jemalloc</code>可以在编译时配置也支持运行时配置，配置项可以查看文档，可配置的有 page size、chunksize、quantum 等。配置支持 4 种方式:</p>
<ul>
<li><code>/etc/malloc.conf</code> 符号链接</li>
<li><code>MALLOC_OPTIONS</code> 环境变量</li>
<li><code>_malloc_options</code> 全局变量</li>
<li><code>je_mallctl()</code> 在代码里进行配置</li>
</ul>
<p><img src="/img/c2dv3kuw94.png" alt></p>
<h2 id="page"><a href="#page" class="headerlink" title="page"></a>page</h2><p>最底层是从操作系统申请内存，由<code>pages.h/pages.c</code>封装了跨平台实现，<code>Linux</code>中使用<code>mmap(2)</code>。主要关注下面几个函数:</p>
<ul>
<li><code>pages_map()</code>：调用<code>mmap()</code>分配可读可写、私有匿名映射。</li>
<li><code>pages_unmap()</code>：调用<code>mummap()</code>删除指定范围的映射。</li>
<li><code>pages_trim()</code>：<code>trim</code>头尾部分的内存映射，用于内存对齐。</li>
<li><code>pages_purge()</code>：调用<code>madvise()</code>清除(purge)部分内存页，也就是释放。</li>
</ul>
<p><code>mmap()</code>会以<code>page size</code>的倍数分配内存，匿名映射会初始化为0，私有映射采用 COW 策略。</p>
<h2 id="chunk"><a href="#chunk" class="headerlink" title="chunk"></a>chunk</h2><p>每当内存不够用了，<code>jemalloc</code>会以<code>chunk</code>为单位从操作系统申请内存，大小为<code>page size</code>倍数，默认为 2 MiB，分配的函数为<code>chunk_alloc_mmap()</code>。<code>chunk_alloc_map()</code>会调用<code>pages_map()</code>分配地址按<code>chunk_size</code>对齐的内存，既可以避免 false cache line sharing，也可以在常量时间内得到起始地址。 但是<code>pages_map()</code>不能保证对齐，首先会调用<code>pages_map()</code>分配一块内存查看是否对齐，若没对齐，会重新多分配一些内存，然后调用<code>pages_trim()</code>截取两端使内存对齐 ，所以可能会有多次<code>mmap()</code>和<code>munmap()</code>的过程。</p>
<p><code>chunk</code>分配出来需要进行管理，每个<code>chunk</code>会分配一个头部<code>extent_node_t</code>记录其中的信息，如:</p>
<ul>
<li><code>en_arena</code>：负责该<code>chunk</code>的<code>arena</code>(后面介绍)。</li>
<li><code>en_addr</code>：该<code>chunk</code>的起始地址。<br><code>chunk</code>分配出来会插入到<code>chunks_rtree(radix tree)</code>中，保存<code>chunk</code>地址到<code>extent_node_t</code>的映射，以便能快速从地址找到<code>node</code>，方便后面<code>huge object</code>的释放。</li>
</ul>
<h2 id="base"><a href="#base" class="headerlink" title="base"></a>base</h2><p><code>jemalloc</code>不可能只使用栈空间或全局变量，内部也需要动态分配一些内存。<code>base.h/base.c</code>实现了内部使用的内存分配器。</p>
<p><code>base</code>通过地址对齐和<code>padding</code>避免 false cache line sharing：<code>chunk</code>会按照<code>chunksize</code>地址对齐，且分配的大小会<code>padding</code>到<code>cache line</code>大小倍数。</p>
<p><code>base</code>以<code>chunk</code>为单位申请内存，记录<code>chunk</code>信息的<code>extent_node_t</code>使用<code>chunk</code>的起始内存:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">extent_node_t</span> *</span><br><span class="line">base_chunk_alloc(<span class="keyword">size_t</span> minsize)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">extent_node_t</span> *node;</span><br><span class="line">	<span class="keyword">size_t</span> csize, nsize;</span><br><span class="line">	<span class="keyword">void</span> *addr;</span><br><span class="line"></span><br><span class="line">	assert(minsize != <span class="number">0</span>);</span><br><span class="line">        <span class="comment">/* 尝试从 base_nodes 中复用 node */</span></span><br><span class="line">	node = base_node_try_alloc();</span><br><span class="line">	<span class="comment">/* Allocate enough space to also carve a node out if necessary. */</span></span><br><span class="line">        <span class="comment">// 需要分配的 node 的内存</span></span><br><span class="line">	nsize = (node == <span class="literal">NULL</span>) ? CACHELINE_CEILING(<span class="keyword">sizeof</span>(<span class="keyword">extent_node_t</span>)) : <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 多分配 node size，也按照 chunk size 对齐</span></span><br><span class="line">	csize = CHUNK_CEILING(minsize + nsize);</span><br><span class="line">        <span class="comment">// 内部调用 chunk_alloc_mmap()</span></span><br><span class="line">	addr = chunk_alloc_base(csize);</span><br><span class="line">	<span class="keyword">if</span> (addr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (node != <span class="literal">NULL</span>)</span><br><span class="line">			base_node_dalloc(node);</span><br><span class="line">		<span class="keyword">return</span> (<span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	base_mapped += csize;</span><br><span class="line">	<span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 使用 chunk 的起始内存</span></span><br><span class="line">		node = (<span class="keyword">extent_node_t</span> *)addr;</span><br><span class="line">		addr = (<span class="keyword">void</span> *)((<span class="keyword">uintptr_t</span>)addr + nsize);</span><br><span class="line">		csize -= nsize;</span><br><span class="line">		<span class="keyword">if</span> (config_stats) &#123;</span><br><span class="line">			base_allocated += nsize;</span><br><span class="line">			base_resident += PAGE_CEILING(nsize);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	extent_node_init(node, <span class="literal">NULL</span>, addr, csize, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line">	<span class="keyword">return</span> (node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>base</code>使用<code>extent_node_t</code>组成的红黑树<code>base_avail_szad</code>管理<code>chunk</code>。每次需要分配时，会从红黑树中查找内存大小相同或略大的、地址最低的<code>node</code>，然后从<code>node</code>负责的<code>chunk</code>中分配内存，剩下的内存会继续由该<code>node</code>负责，修改大小和地址后再次插入到红黑树中；若该<code>node</code>负责的内存全部分配完了，会将该<code>node</code>添加到链表头<code>base_nodes</code>，留待后续分配时复用。当没有合适的<code>node</code>时，会新分配<code>chunk</code>大小倍数的内存，由<code>node</code>负责，这个<code>node</code>优先从链表<code>base_nodes</code>中分配，也可能是新分配的连续内存的起始位置构成的<code>node</code>。</p>
<p><code>base_alloc()</code>：从<code>base_avail_szad</code>中查找大小相同或略大的、地址最低的<code>extent_node_t</code>，再从<code>chunk</code>里分配内存。如果没有合适的内存，会先调用<code>base_chunk_alloc()</code>分配<code>chunk</code>大小倍数的内存，返回负责这块内存的<code>node</code>，然后进行分配。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ret = extent_node_addr_get(node); <span class="comment">/* node 中用于分配内存的起始地址 */</span></span><br><span class="line"><span class="keyword">if</span> (extent_node_size_get(node) &gt; csize) &#123;</span><br><span class="line">    extent_node_addr_set(node, (<span class="keyword">void</span> *)((<span class="keyword">uintptr_t</span>)ret + csize)); <span class="comment">/* 起始地址增加 csize，表明之前的内存被分配出去 */</span></span><br><span class="line">    extent_node_size_set(node, extent_node_size_get(node) - csize); <span class="comment">/* 内存大小减少 */</span></span><br><span class="line">    extent_tree_szad_insert(&amp;base_avail_szad, node); <span class="comment">/* 按照大小、地址顺序插入到红黑树 */</span></span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">    <span class="comment">/* 这种情况只发生在 extent_node_size_get(node) == csize 这种情况。</span></span><br><span class="line"><span class="comment">     * 此时该 node 负责的内存已经全部分配了，会将该 node 插入到一个链表中去，备用。</span></span><br><span class="line"><span class="comment">     * 该链表用嵌入式实现，在 node 的起始内存存放下一个 node 的地址，节省空间 */</span></span><br><span class="line">    base_node_dalloc(node);</span><br></pre></td></tr></table></figure></p>
<p>为了减少内存浪费，<code>base_nodes</code>链表缓存了之前分配的<code>extent_node_t</code>，<code>base_nodes</code>指向链表头，<code>base_node_dalloc()</code>将<code>node</code>添加到表头，而<code>base_node_try_alloc()</code>移除表头。 采用嵌入式实现，比较晦涩:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">extent_node_t</span> *</span><br><span class="line">base_node_try_alloc(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">extent_node_t</span> *node;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (base_nodes == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> (<span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">// 返回链表头</span></span><br><span class="line">	node = base_nodes;</span><br><span class="line">        <span class="comment">// base_nodes 指向下一个 node</span></span><br><span class="line">	base_nodes = *(<span class="keyword">extent_node_t</span> **)node;</span><br><span class="line">	JEMALLOC_VALGRIND_MAKE_MEM_UNDEFINED(node, <span class="keyword">sizeof</span>(<span class="keyword">extent_node_t</span>));</span><br><span class="line">	<span class="keyword">return</span> (node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* base_mtx must be held. */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">base_node_dalloc(<span class="keyword">extent_node_t</span> *node)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	JEMALLOC_VALGRIND_MAKE_MEM_UNDEFINED(node, <span class="keyword">sizeof</span>(<span class="keyword">extent_node_t</span>));</span><br><span class="line">        <span class="comment">// 将 base_nodes 指向的地址保存在 node 的指向的内存起始处</span></span><br><span class="line">        <span class="comment">// 形成一个 node 的链表，base_nodes 指向链表头，内存起始处为</span></span><br><span class="line">        <span class="comment">// 下一个 node 的地址</span></span><br><span class="line">	*(<span class="keyword">extent_node_t</span> **)node = base_nodes;</span><br><span class="line">	base_nodes = node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="arena"><a href="#arena" class="headerlink" title="arena"></a>arena</h2><p><code>arena</code>是<code>jemalloc</code>中最重要的部分，内存大多数由<code>arena</code>管理，分配算法是<code>Buddy allocation</code>和<code>Slab allocation</code>的组合:</p>
<ul>
<li><code>chunk</code>使用<code>Buddy allocation</code>划分为不同大小的<code>run</code>。</li>
<li><code>run</code>使用<code>Slab allocation</code>划分为固定大小的<code>region</code>，大部分内存分配直接查找对应的<code>run</code>，从中分配空闲的<code>region</code>，释放就是标记<code>region</code>为空闲。</li>
<li><code>run</code>被释放会和空闲的、相邻的<code>run</code>进行合并。当合并为整个<code>chunk</code>时，若发现有相邻的空闲<code>chunk</code>，也会进行合并。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">arena_s</span> &#123;</span></span><br><span class="line">	<span class="comment">/* This arena's index within the arenas array. */</span></span><br><span class="line">	<span class="keyword">unsigned</span>		ind;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Number of threads currently assigned to this arena.  This field is</span></span><br><span class="line"><span class="comment">	 * protected by arenas_lock.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span>		nthreads;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * There are three classes of arena operations from a locking</span></span><br><span class="line"><span class="comment">	 * perspective:</span></span><br><span class="line"><span class="comment">	 * 1) Thread assignment (modifies nthreads) is protected by arenas_lock.</span></span><br><span class="line"><span class="comment">	 * 2) Bin-related operations are protected by bin locks.</span></span><br><span class="line"><span class="comment">	 * 3) Chunk- and run-related operations are protected by this mutex.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">malloc_mutex_t</span>		lock;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">arena_stats_t</span>		stats;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * List of tcaches for extant threads associated with this arena.</span></span><br><span class="line"><span class="comment">	 * Stats from these are merged incrementally, and at exit if</span></span><br><span class="line"><span class="comment">	 * opt_stats_print is enabled.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ql_head(<span class="keyword">tcache_t</span>)	tcache_ql;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">uint64_t</span>		prof_accumbytes;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * PRNG state for cache index randomization of large allocation base</span></span><br><span class="line"><span class="comment">	 * pointers.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">uint64_t</span>		offset_state;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">dss_prec_t</span>		dss_prec;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * In order to avoid rapid chunk allocation/deallocation when an arena</span></span><br><span class="line"><span class="comment">	 * oscillates right on the cusp of needing a new chunk, cache the most</span></span><br><span class="line"><span class="comment">	 * recently freed chunk.  The spare is left in the arena's chunk trees</span></span><br><span class="line"><span class="comment">	 * until it is deleted.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * There is one spare chunk per arena, rather than one spare total, in</span></span><br><span class="line"><span class="comment">	 * order to avoid interactions between multiple threads that could make</span></span><br><span class="line"><span class="comment">	 * a single spare inadequate.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">arena_chunk_t</span>		*spare;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Minimum ratio (log base 2) of nactive:ndirty. */</span></span><br><span class="line">	<span class="keyword">ssize_t</span>			lg_dirty_mult;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* True if a thread is currently executing arena_purge(). */</span></span><br><span class="line">	<span class="keyword">bool</span>			purging;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Number of pages in active runs and huge regions. */</span></span><br><span class="line">        <span class="comment">// 已经分配出的 page 个数</span></span><br><span class="line">	<span class="keyword">size_t</span>			nactive;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Current count of pages within unused runs that are potentially</span></span><br><span class="line"><span class="comment">	 * dirty, and for which madvise(... MADV_DONTNEED) has not been called.</span></span><br><span class="line"><span class="comment">	 * By tracking this, we can institute a limit on how much dirty unused</span></span><br><span class="line"><span class="comment">	 * memory is mapped for each arena.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">        <span class="comment">// runs_dirty 中的page数目(包含 chunk)</span></span><br><span class="line">	<span class="keyword">size_t</span>			ndirty;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Size/address-ordered tree of this arena's available runs.  The tree</span></span><br><span class="line"><span class="comment">	 * is used for first-best-fit run allocation.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">        <span class="comment">// 红黑树</span></span><br><span class="line">	<span class="keyword">arena_avail_tree_t</span>	runs_avail;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Unused dirty memory this arena manages.  Dirty memory is conceptually</span></span><br><span class="line"><span class="comment">	 * tracked as an arbitrarily interleaved LRU of dirty runs and cached</span></span><br><span class="line"><span class="comment">	 * chunks, but the list linkage is actually semi-duplicated in order to</span></span><br><span class="line"><span class="comment">	 * avoid extra arena_chunk_map_misc_t space overhead.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 *   LRU-----------------------------------------------------------MRU</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 *        /-- arena ---\</span></span><br><span class="line"><span class="comment">	 *        |            |</span></span><br><span class="line"><span class="comment">	 *        |            |</span></span><br><span class="line"><span class="comment">	 *        |------------|                             /- chunk -\</span></span><br><span class="line"><span class="comment">	 *   ...-&gt;|chunks_cache|&lt;---------------------------&gt;|  /----\ |&lt;--...</span></span><br><span class="line"><span class="comment">	 *        |------------|                             |  |node| |</span></span><br><span class="line"><span class="comment">	 *        |            |                             |  |    | |</span></span><br><span class="line"><span class="comment">	 *        |            |    /- run -\    /- run -\   |  |    | |</span></span><br><span class="line"><span class="comment">	 *        |            |    |       |    |       |   |  |    | |</span></span><br><span class="line"><span class="comment">	 *        |            |    |       |    |       |   |  |    | |</span></span><br><span class="line"><span class="comment">	 *        |------------|    |-------|    |-------|   |  |----| |</span></span><br><span class="line"><span class="comment">	 *   ...-&gt;|runs_dirty  |&lt;--&gt;|rd     |&lt;--&gt;|rd     |&lt;----&gt;|rd  |&lt;----...</span></span><br><span class="line"><span class="comment">	 *        |------------|    |-------|    |-------|   |  |----| |</span></span><br><span class="line"><span class="comment">	 *        |            |    |       |    |       |   |  |    | |</span></span><br><span class="line"><span class="comment">	 *        |            |    |       |    |       |   |  \----/ |</span></span><br><span class="line"><span class="comment">	 *        |            |    \-------/    \-------/   |         |</span></span><br><span class="line"><span class="comment">	 *        |            |                             |         |</span></span><br><span class="line"><span class="comment">	 *        |            |                             |         |</span></span><br><span class="line"><span class="comment">	 *        \------------/                             \---------/</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">        <span class="comment">// 空闲的 dirty run 会存在这，用于 purge</span></span><br><span class="line">	<span class="keyword">arena_runs_dirty_link_t</span>	runs_dirty;</span><br><span class="line">        <span class="comment">// 都是 runs_dirty 中存在的，是为了保存脏的 chunk</span></span><br><span class="line">	<span class="keyword">extent_node_t</span>		chunks_cache;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Extant huge allocations. */</span></span><br><span class="line">	ql_head(<span class="keyword">extent_node_t</span>)	huge;</span><br><span class="line">	<span class="comment">/* Synchronizes all huge allocation/update/deallocation. */</span></span><br><span class="line">	<span class="keyword">malloc_mutex_t</span>		huge_mtx;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Trees of chunks that were previously allocated (trees differ only in</span></span><br><span class="line"><span class="comment">	 * node ordering).  These are used when allocating chunks, in an attempt</span></span><br><span class="line"><span class="comment">	 * to re-use address space.  Depending on function, different tree</span></span><br><span class="line"><span class="comment">	 * orderings are needed, which is why there are two trees with the same</span></span><br><span class="line"><span class="comment">	 * contents.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">        <span class="comment">// 用于复用 chunk</span></span><br><span class="line">        <span class="comment">// 2种树的内容一样，order 不同</span></span><br><span class="line">	<span class="keyword">extent_tree_t</span>		chunks_szad_cached;</span><br><span class="line">	<span class="keyword">extent_tree_t</span>		chunks_ad_cached;</span><br><span class="line">	<span class="keyword">extent_tree_t</span>		chunks_szad_retained;</span><br><span class="line">	<span class="keyword">extent_tree_t</span>		chunks_ad_retained;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">malloc_mutex_t</span>		chunks_mtx;</span><br><span class="line">	<span class="comment">/* Cache of nodes that were allocated via base_alloc(). */</span></span><br><span class="line">	ql_head(<span class="keyword">extent_node_t</span>)	node_cache;</span><br><span class="line">	<span class="keyword">malloc_mutex_t</span>		node_cache_mtx;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* User-configurable chunk hook functions. */</span></span><br><span class="line">    <span class="comment">// chunk_hooks_default</span></span><br><span class="line">	<span class="keyword">chunk_hooks_t</span>		chunk_hooks;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* bins is used to store trees of free regions. */</span></span><br><span class="line">	<span class="keyword">arena_bin_t</span>		bins[NBINS];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>整体的结构图如下，忽略了很多细节：<br><img src="/img/20211102100901.png" alt></p>
<h2 id="run"><a href="#run" class="headerlink" title="run"></a>run</h2><p><code>small classes</code>从<code>run</code>中使用<code>slab</code>算法分配，每个<code>run</code>对应一块连续的内存，大小为<code>page size</code>倍数，划分为等大小的<code>region</code>，分配时就从<code>run</code>中分配一个空闲<code>region</code>，释放时就标记该<code>region</code>为空闲，留待之后分配。</p>
<p><code>arena_run_t</code>记录了<code>run</code>的分配情况:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">arena_run_s</span> &#123;</span></span><br><span class="line">	<span class="comment">/* Index of bin this run is associated with. */</span></span><br><span class="line">	<span class="keyword">szind_t</span>		binind;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Number of free regions in run. */</span></span><br><span class="line">	<span class="keyword">unsigned</span>	nfree;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Per region allocated/deallocated bitmap. */</span></span><br><span class="line">        <span class="comment">// 记录 run 中 region 的分配情况，每 bit 对应1个 region</span></span><br><span class="line">	<span class="keyword">bitmap_t</span>	bitmap[BITMAP_GROUPS_MAX];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>现在看一下如何从<code>run</code>中分配:</p>
<ul>
<li>首先设置<code>bitmap</code>中第一个未设置的并返回，也就是要分配的<code>region id</code></li>
<li>返回对应的<code>region</code>，具体的地址计算后面再来看</li>
<li><code>nfree--</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">JEMALLOC_INLINE_C <span class="keyword">void</span> *</span><br><span class="line">arena_run_reg_alloc(<span class="keyword">arena_run_t</span> *run, <span class="keyword">arena_bin_info_t</span> *bin_info)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">void</span> *ret;</span><br><span class="line">	<span class="keyword">unsigned</span> regind;</span><br><span class="line">	<span class="keyword">arena_chunk_map_misc_t</span> *miscelm;</span><br><span class="line">	<span class="keyword">void</span> *rpages;</span><br><span class="line"></span><br><span class="line">	assert(run-&gt;nfree &gt; <span class="number">0</span>);</span><br><span class="line">	assert(!bitmap_full(run-&gt;bitmap, &amp;bin_info-&gt;bitmap_info));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// set first unset 并 返回</span></span><br><span class="line">	regind = bitmap_sfu(run-&gt;bitmap, &amp;bin_info-&gt;bitmap_info);</span><br><span class="line">	miscelm = arena_run_to_miscelm(run);</span><br><span class="line">	rpages = arena_miscelm_to_rpages(miscelm);</span><br><span class="line">        <span class="comment">// 获取 run 中对应的 region，返回</span></span><br><span class="line">	ret = (<span class="keyword">void</span> *)((<span class="keyword">uintptr_t</span>)rpages + (<span class="keyword">uintptr_t</span>)bin_info-&gt;reg0_offset +</span><br><span class="line">	    (<span class="keyword">uintptr_t</span>)(bin_info-&gt;reg_interval * regind));</span><br><span class="line">	run-&gt;nfree--;</span><br><span class="line">	<span class="keyword">return</span> (ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>释放是相反的过程:</p>
<ul>
<li>首先获取该<code>ptr</code>的<code>region id</code></li>
<li><code>unset</code>对应的<code>bitmap</code></li>
<li><code>nfree++</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">JEMALLOC_INLINE_C <span class="keyword">void</span></span><br><span class="line">arena_run_reg_dalloc(<span class="keyword">arena_run_t</span> *run, <span class="keyword">void</span> *ptr)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">arena_chunk_t</span> *chunk = (<span class="keyword">arena_chunk_t</span> *)CHUNK_ADDR2BASE(run);</span><br><span class="line">	<span class="keyword">size_t</span> pageind = ((<span class="keyword">uintptr_t</span>)ptr - (<span class="keyword">uintptr_t</span>)chunk) &gt;&gt; LG_PAGE;</span><br><span class="line">	<span class="keyword">size_t</span> mapbits = arena_mapbits_get(chunk, pageind);</span><br><span class="line">	<span class="keyword">szind_t</span> binind = arena_ptr_small_binind_get(ptr, mapbits);</span><br><span class="line">	<span class="keyword">arena_bin_info_t</span> *bin_info = &amp;arena_bin_info[binind];</span><br><span class="line">	<span class="keyword">unsigned</span> regind = arena_run_regind(run, bin_info, ptr);</span><br><span class="line"></span><br><span class="line">	assert(run-&gt;nfree &lt; bin_info-&gt;nregs);</span><br><span class="line">	<span class="comment">/* Freeing an interior pointer can cause assertion failure. */</span></span><br><span class="line">	assert(((<span class="keyword">uintptr_t</span>)ptr -</span><br><span class="line">	    ((<span class="keyword">uintptr_t</span>)arena_miscelm_to_rpages(arena_run_to_miscelm(run)) +</span><br><span class="line">	    (<span class="keyword">uintptr_t</span>)bin_info-&gt;reg0_offset)) %</span><br><span class="line">	    (<span class="keyword">uintptr_t</span>)bin_info-&gt;reg_interval == <span class="number">0</span>);</span><br><span class="line">	assert((<span class="keyword">uintptr_t</span>)ptr &gt;=</span><br><span class="line">	    (<span class="keyword">uintptr_t</span>)arena_miscelm_to_rpages(arena_run_to_miscelm(run)) +</span><br><span class="line">	    (<span class="keyword">uintptr_t</span>)bin_info-&gt;reg0_offset);</span><br><span class="line">	<span class="comment">/* Freeing an unallocated pointer can cause assertion failure. */</span></span><br><span class="line">	assert(bitmap_get(run-&gt;bitmap, &amp;bin_info-&gt;bitmap_info, regind));</span><br><span class="line"></span><br><span class="line">	bitmap_unset(run-&gt;bitmap, &amp;bin_info-&gt;bitmap_info, regind);</span><br><span class="line">	run-&gt;nfree++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="bin"><a href="#bin" class="headerlink" title="bin"></a>bin</h2><p><code>jemalloc</code>中<code>small size classes</code>都使用<code>slab</code>算法分配，所以会有多种不同的<code>run</code>。<code>bin</code>管理相同类型的<code>run</code>，<code>bin_info</code>记录了对应的<code>run</code>的内存格式。</p>
<p><code>bin_info_init()</code>根据<code>size classes</code>初始化<code>small class bins</code>的信息<code>arena_bin_info[NBINS]</code>。数组中每个元素记录了<code>bin</code>对应的<code>run</code>的信息:</p>
<ul>
<li><code>reg_size</code>：每个<code>region</code>的大小，对应着<code>small size classes</code>大小</li>
<li><code>run_size</code>：<code>bin</code>对应的整个<code>run</code>的大小，<code>page_size</code>的倍数，一般为<code>reg_size</code>和<code>page_size</code>的最小公倍数，但是不能超过<code>arena_maxrun</code>。</li>
<li><code>nregs</code>：该<code>run</code>中<code>region</code>的个数</li>
<li><code>reg0_offset</code>：第一个<code>region</code>距离<code>run</code>起始地址的偏移</li>
</ul>
<p>还有一些其他的信息，主要用于<code>debug</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Read-only information associated with each element of arena_t's bins array</span></span><br><span class="line"><span class="comment"> * is stored separately, partly to reduce memory usage (only one copy, rather</span></span><br><span class="line"><span class="comment"> * than one per arena), but mainly to avoid false cacheline sharing.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Each run has the following layout:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *               /--------------------\</span></span><br><span class="line"><span class="comment"> *               | pad?               |</span></span><br><span class="line"><span class="comment"> *               |--------------------|</span></span><br><span class="line"><span class="comment"> *               | redzone            |</span></span><br><span class="line"><span class="comment"> *   reg0_offset | region 0           |</span></span><br><span class="line"><span class="comment"> *               | redzone            |</span></span><br><span class="line"><span class="comment"> *               |--------------------| \</span></span><br><span class="line"><span class="comment"> *               | redzone            | |</span></span><br><span class="line"><span class="comment"> *               | region 1           |  &gt; reg_interval</span></span><br><span class="line"><span class="comment"> *               | redzone            | /</span></span><br><span class="line"><span class="comment"> *               |--------------------|</span></span><br><span class="line"><span class="comment"> *               | ...                |</span></span><br><span class="line"><span class="comment"> *               | ...                |</span></span><br><span class="line"><span class="comment"> *               | ...                |</span></span><br><span class="line"><span class="comment"> *               |--------------------|</span></span><br><span class="line"><span class="comment"> *               | redzone            |</span></span><br><span class="line"><span class="comment"> *               | region nregs-1     |</span></span><br><span class="line"><span class="comment"> *               | redzone            |</span></span><br><span class="line"><span class="comment"> *               |--------------------|</span></span><br><span class="line"><span class="comment"> *               | alignment pad?     |</span></span><br><span class="line"><span class="comment"> *               \--------------------/</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * reg_interval has at least the same minimum alignment as reg_size; this</span></span><br><span class="line"><span class="comment"> * preserves the alignment constraint that sa2u() depends on.  Alignment pad is</span></span><br><span class="line"><span class="comment"> * either 0 or redzone_size; it is present only if needed to align reg0_offset.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p>
<p><code>bin</code>的结构如下:</p>
<ul>
<li><code>runcur</code>：指向有空闲<code>region</code>且地址最低的<code>run</code></li>
<li><code>runs</code>：红黑树，管理有空闲<code>region</code>的<code>run</code>，按照<code>run</code>的地址排序</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">arena_bin_s</span> &#123;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * All operations on runcur, runs, and stats require that lock be</span></span><br><span class="line"><span class="comment">	 * locked.  Run allocation/deallocation are protected by the arena lock,</span></span><br><span class="line"><span class="comment">	 * which may be acquired while holding one or more bin locks, but not</span></span><br><span class="line"><span class="comment">	 * vise versa.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">malloc_mutex_t</span>	lock;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Current run being used to service allocations of this bin's size</span></span><br><span class="line"><span class="comment">	 * class.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">arena_run_t</span>	*runcur;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Tree of non-full runs.  This tree is used when looking for an</span></span><br><span class="line"><span class="comment">	 * existing run when runcur is no longer usable.  We choose the</span></span><br><span class="line"><span class="comment">	 * non-full run that is lowest in memory; this policy tends to keep</span></span><br><span class="line"><span class="comment">	 * objects packed well, and it can also help reduce the number of</span></span><br><span class="line"><span class="comment">	 * almost-empty chunks.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">        <span class="comment">// 红黑树 non-full runs，按照地址排序</span></span><br><span class="line">	<span class="keyword">arena_run_tree_t</span> runs;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Bin statistics. */</span></span><br><span class="line">	<span class="keyword">malloc_bin_stats_t</span> stats;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>来看下如何从<code>bin</code>中分配<code>run</code>:</p>
<ul>
<li>若<code>runcur != NULL</code>，则从该<code>run</code>分配</li>
<li>从<code>runs</code>中查找地址最低的<code>run</code>，分配</li>
</ul>
<p>当从<code>run</code>中释放<code>region</code>时，根据<code>run</code>的状态会有不同的操作:</p>
<ul>
<li>若该<code>run</code>原先已满，则会调用<code>arena_bin_lower_run()</code>设置为<code>runcur</code>或者插入到<code>runs</code>中</li>
<li>若该<code>run</code>之前有空闲空间，说明是<code>runcur</code>或已经在<code>runs</code>中，此时无特殊处理</li>
<li>若该<code>run</code>释放<code>region</code>后已空，则会将该<code>run</code>与<code>bin</code>解除关系，返回到<code>arena</code>中，后面再来看这种情况</li>
</ul>
<p><code>bin-&gt;runcur</code>指向的永远是地址最低的<code>run</code>，目的是减少<code>active pages</code>。</p>
<h2 id="chunk-1"><a href="#chunk-1" class="headerlink" title="chunk"></a>chunk</h2><p><code>chunk</code>是<code>jemalloc</code>中申请内存的基本单位。<code>arena</code>中有如下元素管理<code>chunk</code>:</p>
<ul>
<li><code>spare</code>：缓存最近空闲的<code>chunk</code>，为了避免频繁的<code>chunk</code>分配和释放</li>
<li><code>chunks_szad_cached/chunks_ad_cached</code>：<code>extent_node_t</code>的红黑树，缓存之前分配的、空闲的<code>chunk</code>，数据一样，只是顺序不同:</li>
<li><code>szad</code>：按照<code>size</code>、<code>address</code>排序</li>
<li><code>ad</code>：按照<code>address</code>排序</li>
<li><code>chunks_szad_retained/chunks_ad_retained</code>：<code>extent_node_t</code>的红黑树，缓存已经被释放的、空闲的<code>chunk</code>，在后面<code>purge</code>阶段会看到</li>
</ul>
<p>现在来看一下<code>chunk</code>的申请过程:</p>
<ul>
<li>若<code>spare != NULL</code>，则返回<code>spare</code></li>
<li>从<code>cached</code>中查找</li>
<li>从<code>retained</code>中查找</li>
<li>调用<code>chunk_alloc_mmap()</code>新分配一个<code>chunk</code></li>
</ul>
<p>第2、3步会调用<code>chunk_recycle()</code>实施伙伴算法的分裂过程：从对应的树中进行分配指定大小的<code>chunk</code>，<code>chunk</code>起始地址会按<code>chunk_size</code>对齐。因为需要对齐且大小不一定相等，所以前后需要进行裁剪，<code>leadsize</code>和<code>trailsize</code>也会重新插入树中，留待之后的分配使用。</p>
<p>相对应的，<code>chunk</code>释放过程如下:</p>
<ul>
<li>若<code>spare == NULL</code>，则设置为<code>spare</code></li>
<li>将原先的<code>spare</code>插入到<code>cached</code>中，设置为<code>spare</code></li>
</ul>
<p>第2步会调用<code>chunk_record()</code>实施伙伴算法的合并过程：会查找连续地址空间的前后的<code>chunk</code>在不在树中，如果在的话会进行合并，然后再插入到树中。</p>
<h2 id="arena-chunk-t"><a href="#arena-chunk-t" class="headerlink" title="arena_chunk_t"></a>arena_chunk_t</h2><p><code>run</code>从<code>chunk</code>中分配，同样采用伙伴算法。一整个<code>chunk</code>的内存分为4个部分:</p>
<ul>
<li><code>extent_node_t</code>：记录<code>chunk</code>的状态，用于之后管理<code>chunk</code></li>
<li><code>arena_chunk_map_bits_t</code>：一一对应<code>chunk</code>内每个<code>page</code>，记录从<code>chunk</code>分配出去的<code>run</code>的大小和信息、记录<code>page</code>的分配状态。</li>
<li><code>arena_chunk_map_misc_t</code>：一一对应<code>chunk</code>内每个<code>page</code>对应的<code>run</code></li>
<li><code>page</code>：大小为 4096B</li>
</ul>
<p>这些记录<code>chunk</code>信息的<code>header</code>存放在每个<code>chunk</code>起始地址处，所以会占用掉部分内存。这些<code>header</code>和<code>chunk</code>中的<code>page</code>个数有关，而<code>chunk</code>中减去<code>header</code>的内存又和<code>page</code>的个数有关，所以<code>arena_boot()</code>中使用循环计算<code>header</code>占用的<code>page</code>个数(map_bias):</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Compute the header size such that it is large enough to contain the</span></span><br><span class="line"><span class="comment">* page map.  The page map is biased to omit entries for the header</span></span><br><span class="line"><span class="comment">* itself, so some iteration is necessary to compute the map bias.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 1) Compute safe header_size and map_bias values that include enough</span></span><br><span class="line"><span class="comment">*    space for an unbiased page map.</span></span><br><span class="line"><span class="comment">* 2) Refine map_bias based on (1) to omit the header pages in the page</span></span><br><span class="line"><span class="comment">*    map.  The resulting map_bias may be one too small.</span></span><br><span class="line"><span class="comment">* 3) Refine map_bias based on (2).  The result will be &gt;= the result</span></span><br><span class="line"><span class="comment">*    from (2), and will always be correct.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">map_bias = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">size_t</span> header_size = offsetof(<span class="keyword">arena_chunk_t</span>, map_bits) +</span><br><span class="line">        ((<span class="keyword">sizeof</span>(<span class="keyword">arena_chunk_map_bits_t</span>) +</span><br><span class="line">        <span class="keyword">sizeof</span>(<span class="keyword">arena_chunk_map_misc_t</span>)) * (chunk_npages-map_bias));</span><br><span class="line">    map_bias = (header_size + PAGE_MASK) &gt;&gt; LG_PAGE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>header</code>使用连续内存存放而不是每个<code>page</code>头部存放有如下好处:</p>
<ul>
<li>提高<code>header</code>的缓存局部性</li>
<li>提高<code>page</code>中分配出去的缓存局部性</li>
<li>可以减少<code>rss</code>占用，因为操作系统按照<code>page</code>管理虚拟地址，若每个空闲<code>page</code>都有些<code>header</code>占用，会使一整个<code>page</code>驻留在内存中</li>
</ul>
<p><code>arena_chunk_map_bits_t</code>在64位系统上，共有<code>64bits</code>，记录了<code>chunk</code>内每个<code>page</code>的分配情况，这些信息用于快速的查找<code>metadata</code>。对于不同状态的<code>page</code>有不同的格式:</p>
<ul>
<li>未分配<code>page</code>：连续、未分配的<code>page</code>会作为一个整体，由起始<code>page</code>对应的<code>run</code>进行管理。首尾<code>page</code>对应的<code>arena_chunk_map_bits_t</code>中会设置连续的空闲<code>page</code>的数量，中间的<code>page</code>不设置。同时，管理这些空闲<code>page</code>的<code>run</code>会插入到<code>runs_avail</code>中，该<code>run</code>的大小就是整个空闲<code>page</code>的大小(从<code>arena_chunk_map_bits_t</code>中获取)</li>
<li>已分配的<code>run</code>对应的<code>page</code>：每个<code>page</code>会设置该<code>page</code>是<code>run</code>中第几个<code>page</code>(<code>run page offset</code>)，并且设置<code>run</code>对应的<code>bin id</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Run address (or size) and various flags are stored together.  The bit</span></span><br><span class="line"><span class="comment">* layout looks like (assuming 32-bit system):</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*   ???????? ???????? ???nnnnn nnndumla</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* ? : Unallocated: Run address for first/last pages, unset for internal</span></span><br><span class="line"><span class="comment">*                  pages.</span></span><br><span class="line"><span class="comment">*     Small: Run page offset.</span></span><br><span class="line"><span class="comment">*     Large: Run page count for first page, unset for trailing pages.</span></span><br><span class="line"><span class="comment">* n : binind for small size class, BININD_INVALID for large size class.</span></span><br><span class="line"><span class="comment">* d : dirty?</span></span><br><span class="line"><span class="comment">* u : unzeroed?</span></span><br><span class="line"><span class="comment">* m : decommitted?</span></span><br><span class="line"><span class="comment">* l : large?</span></span><br><span class="line"><span class="comment">* a : allocated?</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Following are example bit patterns for the three types of runs.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* p : run page offset (这个page是run中第几个page (offset))</span></span><br><span class="line"><span class="comment">* s : run size (连续的空闲 page 个数)</span></span><br><span class="line"><span class="comment">* n : binind for size class; large objects set these to BININD_INVALID(该 page 对应的 bin Id)</span></span><br><span class="line"><span class="comment">* x : don't care</span></span><br><span class="line"><span class="comment">* - : 0</span></span><br><span class="line"><span class="comment">* + : 1</span></span><br><span class="line"><span class="comment">* [DUMLA] : bit set</span></span><br><span class="line"><span class="comment">* [dumla] : bit unset</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*   Unallocated (clean):</span></span><br><span class="line"><span class="comment">*     ssssssss ssssssss sss+++++ +++dum-a</span></span><br><span class="line"><span class="comment">*     xxxxxxxx xxxxxxxx xxxxxxxx xxx-Uxxx</span></span><br><span class="line"><span class="comment">*     ssssssss ssssssss sss+++++ +++dUm-a</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*   Unallocated (dirty):</span></span><br><span class="line"><span class="comment">*     ssssssss ssssssss sss+++++ +++D-m-a</span></span><br><span class="line"><span class="comment">*     xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx</span></span><br><span class="line"><span class="comment">*     ssssssss ssssssss sss+++++ +++D-m-a</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*   Small:</span></span><br><span class="line"><span class="comment">*     pppppppp pppppppp pppnnnnn nnnd---A</span></span><br><span class="line"><span class="comment">*     pppppppp pppppppp pppnnnnn nnn----A</span></span><br><span class="line"><span class="comment">*     pppppppp pppppppp pppnnnnn nnnd---A</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*   Large:</span></span><br><span class="line"><span class="comment">*     ssssssss ssssssss sss+++++ +++D--LA</span></span><br><span class="line"><span class="comment">*     xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx</span></span><br><span class="line"><span class="comment">*     -------- -------- ---+++++ +++D--LA</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*   Large (sampled, size &lt;= LARGE_MINCLASS):</span></span><br><span class="line"><span class="comment">*     ssssssss ssssssss sssnnnnn nnnD--LA</span></span><br><span class="line"><span class="comment">*     xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx</span></span><br><span class="line"><span class="comment">*     -------- -------- ---+++++ +++D--LA</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*   Large (not sampled, size == LARGE_MINCLASS):</span></span><br><span class="line"><span class="comment">*     ssssssss ssssssss sss+++++ +++D--LA</span></span><br><span class="line"><span class="comment">*     xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx</span></span><br><span class="line"><span class="comment">*     -------- -------- ---+++++ +++D--LA</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p><code>arena_chunk_map_misc_t</code>顾名思义，有很多用途，主要用于记录<code>run</code>的<code>metadata</code>。<code>run</code>大小是<code>page size</code>倍数，每个<code>run</code>会由起始<code>page</code>对应的<code>arena_chunk_map_misc_t</code>中的<code>run</code>管理。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">arena_chunk_map_misc_s</span> &#123;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Linkage for run trees.  There are two disjoint uses:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * 1) arena_t's runs_avail tree.</span></span><br><span class="line"><span class="comment">	 * 2) arena_run_t conceptually uses this linkage for in-use non-full</span></span><br><span class="line"><span class="comment">	 *    runs, rather than directly embedding linkage.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	rb_node(<span class="keyword">arena_chunk_map_misc_t</span>)		rb_link;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="comment">/* Linkage for list of dirty runs. */</span></span><br><span class="line">		<span class="keyword">arena_runs_dirty_link_t</span>		rd;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Profile counters, used for large object runs. */</span></span><br><span class="line">		<span class="keyword">union</span> &#123;</span><br><span class="line">			<span class="keyword">void</span>				*prof_tctx_pun;</span><br><span class="line">			<span class="keyword">prof_tctx_t</span>			*prof_tctx;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Small region run metadata. */</span></span><br><span class="line">		<span class="keyword">arena_run_t</span>			run;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>接下来看一下如何从<code>chunk</code>中分配<code>run</code>。</p>
<p>第一个<code>chunk</code>是调用<code>chunk_alloc_mmap()</code>分配的，然后调用<code>arena_mapbits_unallocated_set()</code>设置首尾<code>page</code>对应的<code>arena_chunk_map_bits_t</code>，然后将整个空闲<code>chunk</code>作为大小为<code>arena_maxrun</code>的空闲<code>run</code>插入到<code>runs_avail</code>中:<br><img src="/img/20211102100902.png" alt></p>
<p>然后调用<code>arena_run_split_small()</code>将该<code>run</code>分解为对应的<code>bin</code>管理的<code>run</code>:</p>
<ul>
<li>从<code>run</code>中分配出需要的<code>page</code>，多余的<code>page</code>会设置首尾<code>page</code>对应的<code>map_bits</code>，再次插入到<code>avail_runs</code>中留待后续分配</li>
<li>设置分配出去的<code>run</code>对应的<code>map_bits</code>，返回分配出去的第一个<code>page</code>对应的<code>misc</code>中的<code>run</code></li>
<li>之后<code>run</code>就会有对应的<code>bin</code>进行管理</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">bool</span></span><br><span class="line">arena_run_split_small(<span class="keyword">arena_t</span> *arena, <span class="keyword">arena_run_t</span> *run, <span class="keyword">size_t</span> size,</span><br><span class="line">    <span class="keyword">szind_t</span> binind)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">arena_chunk_t</span> *chunk;</span><br><span class="line">	<span class="keyword">arena_chunk_map_misc_t</span> *miscelm;</span><br><span class="line">	<span class="keyword">size_t</span> flag_dirty, flag_decommitted, run_ind, need_pages, i;</span><br><span class="line"></span><br><span class="line">	assert(binind != BININD_INVALID);</span><br><span class="line"></span><br><span class="line">	chunk = (<span class="keyword">arena_chunk_t</span> *)CHUNK_ADDR2BASE(run);</span><br><span class="line">	miscelm = arena_run_to_miscelm(run);</span><br><span class="line">	run_ind = arena_miscelm_to_pageind(miscelm);</span><br><span class="line">	flag_dirty = arena_mapbits_dirty_get(chunk, run_ind);</span><br><span class="line">	flag_decommitted = arena_mapbits_decommitted_get(chunk, run_ind);</span><br><span class="line">        <span class="comment">// size 是 bin 对应的 run_size </span></span><br><span class="line">	need_pages = (size &gt;&gt; LG_PAGE);</span><br><span class="line">	assert(need_pages &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (flag_decommitted != <span class="number">0</span> &amp;&amp; arena-&gt;chunk_hooks.commit(chunk, chunksize,</span><br><span class="line">	    run_ind &lt;&lt; LG_PAGE, size, arena-&gt;ind))</span><br><span class="line">		<span class="keyword">return</span> (<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">	arena_run_split_remove(arena, chunk, run_ind, flag_dirty,</span><br><span class="line">	    flag_decommitted, need_pages);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置分配出去的 page 对应的 map_bits</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; need_pages; i++) &#123;</span><br><span class="line">		<span class="keyword">size_t</span> flag_unzeroed = arena_mapbits_unzeroed_get(chunk,</span><br><span class="line">		    run_ind+i);</span><br><span class="line">		arena_mapbits_small_set(chunk, run_ind+i, i, binind,</span><br><span class="line">		    flag_unzeroed);</span><br><span class="line">		<span class="keyword">if</span> (config_debug &amp;&amp; flag_dirty == <span class="number">0</span> &amp;&amp; flag_unzeroed == <span class="number">0</span>)</span><br><span class="line">			arena_run_page_validate_zeroed(chunk, run_ind+i);</span><br><span class="line">	&#125;</span><br><span class="line">	JEMALLOC_VALGRIND_MAKE_MEM_UNDEFINED((<span class="keyword">void</span> *)((<span class="keyword">uintptr_t</span>)chunk +</span><br><span class="line">	    (run_ind &lt;&lt; LG_PAGE)), (need_pages &lt;&lt; LG_PAGE));</span><br><span class="line">	<span class="keyword">return</span> (<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 run_ind 对应 run 中分配出 need_pages，剩余的再次插入到 avail_runs 中</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">arena_run_split_remove(<span class="keyword">arena_t</span> *arena, <span class="keyword">arena_chunk_t</span> *chunk, <span class="keyword">size_t</span> run_ind,</span><br><span class="line">    <span class="keyword">size_t</span> flag_dirty, <span class="keyword">size_t</span> flag_decommitted, <span class="keyword">size_t</span> need_pages)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">size_t</span> total_pages, rem_pages;</span><br><span class="line"></span><br><span class="line">	assert(flag_dirty == <span class="number">0</span> || flag_decommitted == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	total_pages = arena_mapbits_unallocated_size_get(chunk, run_ind) &gt;&gt;</span><br><span class="line">	    LG_PAGE;</span><br><span class="line">	assert(arena_mapbits_dirty_get(chunk, run_ind+total_pages<span class="number">-1</span>) ==</span><br><span class="line">	    flag_dirty);</span><br><span class="line">	assert(need_pages &lt;= total_pages);</span><br><span class="line">	rem_pages = total_pages - need_pages;</span><br><span class="line"></span><br><span class="line">	arena_avail_remove(arena, chunk, run_ind, total_pages);</span><br><span class="line">	<span class="keyword">if</span> (flag_dirty != <span class="number">0</span>)</span><br><span class="line">		arena_run_dirty_remove(arena, chunk, run_ind, total_pages);</span><br><span class="line">	arena_cactive_update(arena, need_pages, <span class="number">0</span>);</span><br><span class="line">	arena-&gt;nactive += need_pages;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Keep track of trailing unused pages for later use. */</span></span><br><span class="line">	<span class="keyword">if</span> (rem_pages &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">size_t</span> flags = flag_dirty | flag_decommitted;</span><br><span class="line">		<span class="keyword">size_t</span> flag_unzeroed_mask = (flags == <span class="number">0</span>) ?  CHUNK_MAP_UNZEROED :</span><br><span class="line">		    <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置 run 对应的 page 的信息，设置开头和结尾的 page 对应的 map_bits 的</span></span><br><span class="line">            <span class="comment">// 未分配内存大小</span></span><br><span class="line">		arena_mapbits_unallocated_set(chunk, run_ind+need_pages,</span><br><span class="line">		    (rem_pages &lt;&lt; LG_PAGE), flags |</span><br><span class="line">		    (arena_mapbits_unzeroed_get(chunk, run_ind+need_pages) &amp;</span><br><span class="line">		    flag_unzeroed_mask));</span><br><span class="line">		arena_mapbits_unallocated_set(chunk, run_ind+total_pages<span class="number">-1</span>,</span><br><span class="line">		    (rem_pages &lt;&lt; LG_PAGE), flags |</span><br><span class="line">		    (arena_mapbits_unzeroed_get(chunk, run_ind+total_pages<span class="number">-1</span>) &amp;</span><br><span class="line">		    flag_unzeroed_mask));</span><br><span class="line">		<span class="keyword">if</span> (flag_dirty != <span class="number">0</span>) &#123;</span><br><span class="line">			arena_run_dirty_insert(arena, chunk, run_ind+need_pages,</span><br><span class="line">			    rem_pages);</span><br><span class="line">		&#125;</span><br><span class="line">		arena_avail_insert(arena, chunk, run_ind+need_pages, rem_pages);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/img/20211102100903.png" alt></p>
<p>当<code>bin</code>中有完全空闲的<code>run</code>时，会返回给<code>arena</code>管理:</p>
<ul>
<li>调用<code>arena_dissociate_bin_run()</code>解除该<code>run</code>和<code>bin</code>的关系:</li>
<li>若该<code>run</code>为<code>bin-&gt;runcur</code>，设置<code>bin-&gt;runcur =NULL</code></li>
<li>从<code>bin-&gt;runs</code>中移除</li>
<li>调用<code>arena_run_coalesce()</code>尝试合并相邻的空闲<code>run</code></li>
<li>将<code>run</code>插入到<code>avail_runs</code>中</li>
<li>若该<code>run</code>大小已经达到<code>arena_maxrun</code>，表明整个<code>chunk</code>都是空闲的，调用<code>arena_chunk_dalloc()</code>释放<code>run</code></li>
</ul>
<h1 id="常量时间获取-metadata"><a href="#常量时间获取-metadata" class="headerlink" title="常量时间获取 metadata"></a>常量时间获取 metadata</h1><p>有了上面的铺垫，现在可以来看一下<code>jemalloc</code>中的地址运算操作及如何在常量时间获取<code>metadata</code>。</p>
<h2 id="从-run-到-region"><a href="#从-run-到-region" class="headerlink" title="从 run 到 region"></a>从 run 到 region</h2><p><code>arena_run_t</code>中只记录了<code>run</code>的分配情况，并没有地址，需要快速的获取到需要分配的<code>region</code>的地址:</p>
<p>先获取到<code>misc</code>的地址:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">arena_chunk_map_misc_t</span> *miscelm = (<span class="keyword">arena_chunk_map_misc_t</span></span><br><span class="line"> *)((<span class="keyword">uintptr_t</span>)run - offsetof(<span class="keyword">arena_chunk_map_misc_t</span>, run));</span><br></pre></td></tr></table></figure></p>
<p>获取包含该<code>misc</code>的<code>chunk</code>起始地址:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 因为内存申请以chunk为单位，且按照chunk size对齐，所以只要将低位置零即可获取chunk起始地址 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	CHUNK_ADDR2BASE(a)						\</span></span><br><span class="line"> ((<span class="keyword">void</span> *)((<span class="keyword">uintptr_t</span>)(a) &amp; ~chunksize_mask))</span><br><span class="line"><span class="keyword">arena_chunk_t</span> *chunk = (<span class="keyword">arena_chunk_t</span> *)CHUNK_ADDR2BASE(miscelm);</span><br></pre></td></tr></table></figure></p>
<p>获取该<code>misc</code>的<code>page id</code>:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">arena_chunk_t</span> *chunk = (<span class="keyword">arena_chunk_t</span> *)CHUNK_ADDR2BASE(miscelm);</span><br><span class="line"><span class="comment">/* (该 misc 在数组中的地址偏移 / misc 大小) 即可获取是数组中第几个元素 */</span></span><br><span class="line"><span class="keyword">size_t</span> pageind = ((<span class="keyword">uintptr_t</span>)miscelm - ((<span class="keyword">uintptr_t</span>)chunk +</span><br><span class="line"> map_misc_offset)) / <span class="keyword">sizeof</span>(<span class="keyword">arena_chunk_map_misc_t</span>) + map_bias;</span><br></pre></td></tr></table></figure></p>
<p>获取<code>misc</code>对应的<code>page</code>地址:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> ((<span class="keyword">void</span> *)((<span class="keyword">uintptr_t</span>)chunk + (pageind &lt;&lt; LG_PAGE)));</span><br></pre></td></tr></table></figure></p>
<p>获取对应的<code>region</code>:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* page 起始地址 + region0 的偏移 + (region id * region size) */</span></span><br><span class="line">ret = (<span class="keyword">void</span> *)((<span class="keyword">uintptr_t</span>)rpages + (<span class="keyword">uintptr_t</span>)bin_info-&gt;reg0_offset +</span><br><span class="line"> (<span class="keyword">uintptr_t</span>)(bin_info-&gt;reg_interval * regind));</span><br></pre></td></tr></table></figure></p>
<h2 id="从-region-到-run"><a href="#从-region-到-run" class="headerlink" title="从 region 到 run"></a>从 region 到 run</h2><p>当释放<code>region</code>时，需要快速查找<code>region</code>对应的<code>run</code>及<code>region id</code>:</p>
<p>先获取到<code>chunk</code>起始地址:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chunk = (<span class="keyword">arena_chunk_t</span> *)CHUNK_ADDR2BASE(ptr);</span><br></pre></td></tr></table></figure></p>
<p>获取<code>region</code>的<code>page id</code>:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pageind = ((<span class="keyword">uintptr_t</span>)ptr - (<span class="keyword">uintptr_t</span>)chunk) &gt;&gt; LG_PAGE;</span><br></pre></td></tr></table></figure></p>
<p>获取<code>page</code>对应的<code>map_bits</code>:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> (&amp;chunk-&gt;map_bits[pageind-map_bias]);</span><br></pre></td></tr></table></figure></p>
<p>根据<code>map_bits</code>中设置的<code>run page offset</code>获取<code>run</code>的起始<code>page id</code>：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">rpages_ind = pageind - arena_mapbits_small_runind_get(chunk, pageind);</span><br><span class="line"></span><br><span class="line">JEMALLOC_ALWAYS_INLINE <span class="keyword">size_t</span></span><br><span class="line">arena_mapbits_small_runind_get(<span class="keyword">arena_chunk_t</span> *chunk, <span class="keyword">size_t</span> pageind)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">size_t</span> mapbits;</span><br><span class="line">    mapbits = arena_mapbits_get(chunk, pageind);</span><br><span class="line">    assert((mapbits &amp; (CHUNK_MAP_LARGE|CHUNK_MAP_ALLOCATED)) ==</span><br><span class="line">        CHUNK_MAP_ALLOCATED);</span><br><span class="line">    <span class="keyword">return</span> (mapbits &gt;&gt; CHUNK_MAP_RUNIND_SHIFT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>获取管理该<code>region</code>的<code>run</code>:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run = &amp;arena_miscelm_get(chunk, rpages_ind)-&gt;run;</span><br></pre></td></tr></table></figure></p>
<p>从<code>run</code>中得到<code>bin_info</code>，再根据<code>bin_info</code>获取<code>region id</code>:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* diff 为 region 在 run 中的偏移 */</span></span><br><span class="line">diff = (<span class="keyword">unsigned</span>)((<span class="keyword">uintptr_t</span>)ptr - (<span class="keyword">uintptr_t</span>)rpages -</span><br><span class="line">    bin_info-&gt;reg0_offset);</span><br><span class="line"><span class="comment">/* region id 可以通过 diff / bin_info-&gt;reg_interval 得到，但是 jemalloc 使用了复杂的运算为了提高性能，下面是它的注释 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Avoid doing division with a variable divisor if possible.  Using</span></span><br><span class="line"><span class="comment"> * actual division here can reduce allocator throughput by over 20%!</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p>
<p>之后就可以设置<code>region</code>对应的<code>bitmap</code>进行释放了</p>
<h2 id="run-的合并"><a href="#run-的合并" class="headerlink" title="run 的合并"></a>run 的合并</h2><p>前面看到<code>run</code>释放时会前后进行合并:</p>
<ol>
<li>查看<code>run</code>相邻的后面的<code>page</code>是不是空闲的:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 根据后面 page 的 map_bits 获取分配状态</span></span><br><span class="line"><span class="comment">arena_mapbits_allocated_get(chunk, run_ind+run_pages) == 0</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>根据<code>map_bits</code>获取空闲<code>page</code>的大小:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> nrun_size = arena_mapbits_unallocated_size_get(chunk, run_ind+run_pages);</span><br><span class="line"><span class="keyword">size_t</span> nrun_pages = nrun_size &gt;&gt; LG_PAGE;</span><br></pre></td></tr></table></figure></p>
<p>然后将大小合并，在设置首尾<code>page</code>的<code>map_bits</code>:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">size += nrun_size;</span><br><span class="line">run_pages += nrun_pages;</span><br><span class="line"></span><br><span class="line">arena_mapbits_unallocated_size_set(chunk, run_ind, size);</span><br><span class="line">arena_mapbits_unallocated_size_set(chunk, run_ind+run_pages<span class="number">-1</span>, size);</span><br></pre></td></tr></table></figure></p>
<p>查看<code>run</code>相邻的前面的<code>page</code>是不是空闲的:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arena_mapbits_allocated_get(chunk, run_ind<span class="number">-1</span>) == <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>根据<code>map_bits</code>获取空闲<code>page</code>的大小:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> prun_size = arena_mapbits_unallocated_size_get(chunk, run_ind<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">size_t</span> prun_pages = prun_size &gt;&gt; LG_PAGE;</span><br></pre></td></tr></table></figure></p>
<p>然后将大小合并，再设置首尾<code>page</code>的<code>map_bits</code>:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">size += prun_size;</span><br><span class="line">run_pages += prun_pages;</span><br><span class="line"></span><br><span class="line">arena_mapbits_unallocated_size_set(chunk, run_ind, size);</span><br><span class="line">arena_mapbits_unallocated_size_set(chunk, run_ind+run_pages<span class="number">-1</span>, size);</span><br></pre></td></tr></table></figure></p>
<p>由此得知，因为前后都需要进行合并，所以首尾<code>page</code>对应的<code>map_bits</code>都会设置大小。</p>
<h1 id="size-classes"><a href="#size-classes" class="headerlink" title="size classes"></a>size classes</h1><p><code>jemalloc</code>将对象按大小分为3类，不同大小类别的分配算法不同:</p>
<ul>
<li><code>small</code>:从对应<code>bin</code>管理的<code>run</code>中返回一个<code>region</code></li>
<li><code>large</code>:大小比<code>chunk</code>小，比<code>page</code>大，会单独返回一个<code>run</code></li>
<li><code>huge</code>:大小为<code>chunk</code>倍数，会分配<code>chunk</code></li>
</ul>
<p>在 2MiB chunk，4KiB page 的64位系统上，<code>size classes</code>如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">+---------+---------+--------------------------------------+</span><br><span class="line">|Category | Spacing | Size                                 |</span><br><span class="line">+---------+---------+--------------------------------------+</span><br><span class="line">|         |      lg | [<span class="number">8</span>]                                  |</span><br><span class="line">|         +---------+--------------------------------------+</span><br><span class="line">|         |      <span class="number">16</span> | [<span class="number">16</span>, <span class="number">32</span>, <span class="number">48</span>, <span class="number">64</span>, <span class="number">80</span>, <span class="number">96</span>, <span class="number">112</span>, <span class="number">128</span>]   |</span><br><span class="line">|         +---------+--------------------------------------+</span><br><span class="line">|         |      <span class="number">32</span> | [<span class="number">160</span>, <span class="number">192</span>, <span class="number">224</span>, <span class="number">256</span>]                 |</span><br><span class="line">|         +---------+--------------------------------------+</span><br><span class="line">|         |      <span class="number">64</span> | [<span class="number">320</span>, <span class="number">384</span>, <span class="number">448</span>, <span class="number">512</span>]                 |</span><br><span class="line">|         +---------+--------------------------------------+</span><br><span class="line">|Small    |     <span class="number">128</span> | [<span class="number">640</span>, <span class="number">768</span>, <span class="number">896</span>, <span class="number">1024</span>]                |</span><br><span class="line">|         +---------+--------------------------------------+</span><br><span class="line">|         |     <span class="number">256</span> | [<span class="number">1280</span>, <span class="number">1536</span>, <span class="number">1792</span>, <span class="number">2048</span>]             |</span><br><span class="line">|         +---------+--------------------------------------+</span><br><span class="line">|         |     <span class="number">512</span> | [<span class="number">2560</span>, <span class="number">3072</span>, <span class="number">3584</span>, <span class="number">4096</span>]             |</span><br><span class="line">|         +---------+--------------------------------------+</span><br><span class="line">|         |   <span class="number">1</span> KiB | [<span class="number">5</span> KiB, <span class="number">6</span> KiB, <span class="number">7</span> KiB, <span class="number">8</span> KiB]         |</span><br><span class="line">|         +---------+--------------------------------------+</span><br><span class="line">|         |   <span class="number">2</span> KiB | [<span class="number">10</span> KiB, <span class="number">12</span> KiB, <span class="number">14</span> KiB]             |</span><br><span class="line">+---------+---------+--------------------------------------+</span><br><span class="line">|         |   <span class="number">2</span> KiB | [<span class="number">16</span> KiB]                             |</span><br><span class="line">|         +---------+--------------------------------------+</span><br><span class="line">|         |   <span class="number">4</span> KiB | [<span class="number">20</span> KiB, <span class="number">24</span> KiB, <span class="number">28</span> KiB, <span class="number">32</span> KiB]     |</span><br><span class="line">|         +---------+--------------------------------------+</span><br><span class="line">|         |   <span class="number">8</span> KiB | [<span class="number">40</span> KiB, <span class="number">48</span> KiB, <span class="number">54</span> KiB, <span class="number">64</span> KiB]     |</span><br><span class="line">|         +---------+--------------------------------------+</span><br><span class="line">|         |  <span class="number">16</span> KiB | [<span class="number">80</span> KiB, <span class="number">96</span> KiB, <span class="number">112</span> KiB, <span class="number">128</span> KiB]   |</span><br><span class="line">|Large    +---------+--------------------------------------+</span><br><span class="line">|         |  <span class="number">32</span> KiB | [<span class="number">160</span> KiB, <span class="number">192</span> KiB, <span class="number">224</span> KiB, <span class="number">256</span> KiB] |</span><br><span class="line">|         +---------+--------------------------------------+</span><br><span class="line">|         |  <span class="number">64</span> KiB | [<span class="number">320</span> KiB, <span class="number">384</span> KiB, <span class="number">448</span> KiB, <span class="number">512</span> KiB] |</span><br><span class="line">|         +---------+--------------------------------------+</span><br><span class="line">|         | <span class="number">128</span> KiB | [<span class="number">640</span> KiB, <span class="number">768</span> KiB, <span class="number">896</span> KiB, <span class="number">1</span> MiB]   |</span><br><span class="line">|         +---------+--------------------------------------+</span><br><span class="line">|         | <span class="number">256</span> KiB | [<span class="number">1280</span> KiB, <span class="number">1536</span> KiB, <span class="number">1792</span> KiB]       |</span><br><span class="line">+---------+---------+--------------------------------------+</span><br><span class="line">|         | <span class="number">256</span> KiB | [<span class="number">2</span> MiB]                              |</span><br><span class="line">|         +---------+--------------------------------------+</span><br><span class="line">|         | <span class="number">512</span> KiB | [<span class="number">2560</span> KiB, <span class="number">3</span> MiB, <span class="number">3584</span> KiB, <span class="number">4</span> MiB]   |</span><br><span class="line">|         +---------+--------------------------------------+</span><br><span class="line">|         |   <span class="number">1</span> MiB | [<span class="number">5</span> MiB, <span class="number">6</span> MiB, <span class="number">7</span> MiB, <span class="number">8</span> MiB]         |</span><br><span class="line">|         +---------+--------------------------------------+</span><br><span class="line">|Huge     |   <span class="number">2</span> MiB | [<span class="number">10</span> MiB, <span class="number">12</span> MiB, <span class="number">14</span> MiB, <span class="number">16</span> MiB]     |</span><br><span class="line">|         +---------+--------------------------------------+</span><br><span class="line">|         |   <span class="number">4</span> MiB | [<span class="number">20</span> MiB, <span class="number">24</span> MiB, <span class="number">28</span> MiB, <span class="number">32</span> MiB]     |</span><br><span class="line">|         +---------+--------------------------------------+</span><br><span class="line">|         |   <span class="number">8</span> MiB | [<span class="number">40</span> MiB, <span class="number">48</span> MiB, <span class="number">56</span> MiB, <span class="number">64</span> MiB]     |</span><br><span class="line">|         +---------+--------------------------------------+</span><br><span class="line">|         |     ... | ...                                  |</span><br><span class="line">+---------+---------+--------------------------------------+</span><br></pre></td></tr></table></figure></p>
<h2 id="small"><a href="#small" class="headerlink" title="small"></a>small</h2><p><code>small</code>的分配流程如下：</p>
<ul>
<li>查找对应<code>size classes</code>的<code>bin</code></li>
<li>从<code>bin</code>中获取<code>run</code>:<ul>
<li><code>bin-&gt;runcur</code></li>
<li>从<code>bin-&gt;runs</code>查找未满的<code>run</code></li>
</ul>
</li>
<li>从<code>arena</code>中获取<code>run</code>:<ul>
<li>从<code>arena-&gt;avail_runs</code>中查找空闲<code>run</code></li>
<li>当没有合适<code>run</code>时，从<code>chunk</code>中分配<code>run</code>:<ul>
<li><code>arena-&gt;spare</code></li>
<li><code>arena-&gt;cached_tree</code></li>
<li><code>arena-&gt;retained_tree</code></li>
<li>调用<code>mmap()</code>新分配一块<code>chunk</code></li>
</ul>
</li>
</ul>
</li>
<li>从<code>run</code>中返回一个空闲<code>region</code></li>
</ul>
<p><code>small</code>的释放流程如下：</p>
<ul>
<li>将该<code>region</code>返回给对应的<code>run</code>，即设置<code>bitmap</code>为空闲，增加<code>nfree</code></li>
<li>将<code>run</code>还给<code>bin</code>:<ul>
<li>如果<code>run-&gt;nfree == 1</code>，则设置为<code>bin-&gt;runcur</code>或者插入到<code>bin-&gt;runs</code>中</li>
</ul>
</li>
<li>如果<code>run-&gt;nfree == bin_info-&gt;nregs</code>，则将该<code>run</code>与<code>bin</code>分离，再将<code>run</code>还给<code>arena</code>:<ul>
<li>尝试与相同<code>chunk</code>中前后相邻的空闲<code>run</code>进行合并，然后插入到<code>arena-&gt;avail_runs</code>中</li>
<li>若合并完后，整个<code>chunk</code>为空，则尝试与连续地址空间的空闲<code>chunk</code>进行合并，然后插入到<code>arena-&gt;cached_tree</code>中</li>
</ul>
</li>
</ul>
<h2 id="large"><a href="#large" class="headerlink" title="large"></a>large</h2><p>分配<code>large</code>和分配<code>small</code>类似:</p>
<ul>
<li>先从<code>arena-&gt;avail_runs</code>中查找，因为<code>large object</code>不由<code>bin</code>管理，所以与<code>small object</code>相比，少了从<code>bin-&gt;runs</code>中查找的一步</li>
<li>分配<code>chunk</code>，步骤和<code>small</code>一样，然后从<code>chunk</code>中分配需要的<code>run</code>大小，此时<code>run</code>的大小为单个<code>object</code>的大小，而<code>small run</code>的大小会从<code>bin_info[]</code>中获取</li>
</ul>
<p>因为<code>large</code>大小是<code>page</code>的倍数，且会按照<code>page size</code>地址对齐，有可能造成<code>cache line</code>颠簸， 所以会根据配置多分配一个<code>page</code>，用于内存着色，防止<code>cache line</code>的颠簸<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (config_cache_oblivious) &#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> r;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Compute a uniformly distributed offset within the first page</span></span><br><span class="line"><span class="comment">     * that is a multiple of the cacheline size, e.g. [0 .. 63) * 64</span></span><br><span class="line"><span class="comment">     * for 4 KiB pages and 64-byte cachelines.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    prng64(r, LG_PAGE - LG_CACHELINE, arena-&gt;offset_state,</span><br><span class="line">        UINT64_C(<span class="number">6364136223846793009</span>),</span><br><span class="line">        UINT64_C(<span class="number">1442695040888963409</span>));</span><br><span class="line">    random_offset = ((<span class="keyword">uintptr_t</span>)r) &lt;&lt; LG_CACHELINE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>large</code>和<code>small</code>的<code>arena_chunk_map_misc_t</code>格式也不同，<code>large</code>只在首个<code>page</code>设置<code>run</code>的大小。释放流程和<code>small</code>一样，只是缺少了<code>run</code>在<code>bin</code>中的处理，直接将<code>run</code>还给<code>arena</code>。</p>
<h2 id="huge"><a href="#huge" class="headerlink" title="huge"></a>huge</h2><p><code>huge object</code>大小比<code>chunk</code>大。分配策略和上面分配<code>chunk</code>一样:</p>
<ul>
<li>从<code>arena</code>中分配<code>extent_node_t</code></li>
<li>从<code>arena</code>中分配<code>chunk</code>:<ul>
<li>从<code>arena-&gt;cached_tree</code>中分配<code>chunk</code></li>
<li>从<code>arena-&gt;retained_tree</code>中分配</li>
<li>调用<code>mmap()</code>新分配一块<code>chunk</code></li>
</ul>
</li>
<li>将<code>chunk</code>和<code>node</code>插入到<code>chunks_rtree</code>中</li>
<li>插入到<code>arena-&gt;huge</code>链表中</li>
</ul>
<p>释放和分配过程相反:</p>
<ul>
<li>从<code>chunks_rtree</code>中获取<code>chunk</code>对应的<code>node</code>，从而获取对应的<code>arena</code></li>
<li>移出<code>arena-&gt;huge</code></li>
<li>释放<code>chunk</code>，插入到<code>arena-&gt;cached_tree</code>中</li>
<li>释放<code>node</code></li>
</ul>
<p><code>huge</code>使用了线程间共享的<code>chunks_rtree</code>来保存信息，这会导致锁的竞争，但是应用程序很少会分配如此大的内存，所以带来的影响很小。</p>
<h2 id="purge"><a href="#purge" class="headerlink" title="purge"></a>purge</h2><p>前面的释放只是将之前分配的缓存起来，备用，现在来看一下真正的释放操作。</p>
<p><code>arena</code>中会统计<code>dirty</code>和<code>active</code>的数目：</p>
<ul>
<li><code>nactive</code>：已经分配出去的<code>page</code>数目</li>
<li><code>ndirty</code>：分配出去又被释放的<code>page</code>数目</li>
<li><code>arena</code>中会保存最多<code>nactive &gt;&gt; lg_dirty_mult</code>的<code>dirty pages</code>暂存使用，当超出时，就会释放掉多余的部分。</li>
</ul>
<p><code>purge</code>按照<code>page</code>维度进行回收。<code>arena</code>中<code>runs_dirty</code>和<code>chunks_cache</code>存放着<code>dirty pages</code>，当<code>run</code>和<code>chunk</code>被释放时，会插入到这里(<code>chunk</code>也会插入到<code>runs_dirty</code>中，同时也插入到<code>chunks_cache</code>)：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">*</span><br><span class="line">* Unused dirty memory <span class="keyword">this</span> arena manages.  Dirty memory is conceptually</span><br><span class="line">* tracked as an arbitrarily interleaved LRU of dirty runs <span class="keyword">and</span> cached</span><br><span class="line">* chunks, but the <span class="built_in">list</span> linkage is actually semi-duplicated in order to</span><br><span class="line">* avoid extra <span class="keyword">arena_chunk_map_misc_t</span> space overhead.</span><br><span class="line">*</span><br><span class="line">*   LRU-----------------------------------------------------------MRU</span><br><span class="line">*</span><br><span class="line">*        /-- arena ---\</span><br><span class="line">*        |            |</span><br><span class="line">*        |            |</span><br><span class="line">*        |------------|                             /- chunk -\</span><br><span class="line">*   ...-&gt;|chunks_cache|&lt;---------------------------&gt;|  /----\ |&lt;--...</span><br><span class="line">*        |------------|                             |  |node| |</span><br><span class="line">*        |            |                             |  |    | |</span><br><span class="line">*        |            |    /- run -\    /- run -\   |  |    | |</span><br><span class="line">*        |            |    |       |    |       |   |  |    | |</span><br><span class="line">*        |            |    |       |    |       |   |  |    | |</span><br><span class="line">*        |------------|    |-------|    |-------|   |  |----| |</span><br><span class="line">*   ...-&gt;|runs_dirty  |&lt;--&gt;|rd     |&lt;--&gt;|rd     |&lt;----&gt;|rd  |&lt;----...</span><br><span class="line">*        |------------|    |-------|    |-------|   |  |----| |</span><br><span class="line">*        |            |    |       |    |       |   |  |    | |</span><br><span class="line">*        |            |    |       |    |       |   |  \----/ |</span><br><span class="line">*        |            |    \-------/    \-------/   |         |</span><br><span class="line">*        |            |                             |         |</span><br><span class="line">*        |            |                             |         |</span><br><span class="line">*        \------------/                             \---------/</span><br><span class="line">*</span><br></pre></td></tr></table></figure></p>
<p>在每次<code>dalloc run/chunk</code>时都会调用<code>arena_maybe_purge()</code>尝试<code>purge</code>。<code>arena</code>根据<code>lg_dirty_mult</code>判断是否需要<code>purge</code>，当<code>(nactive &gt;&gt; lg_dirty_mult) &lt;= ndirty</code>时进行<code>purge</code>，默认配置为<code>8 ： 1</code>。</p>
<p><code>purge</code>分为4步：</p>
<ul>
<li><code>arena_compute_npurge()</code>：返回需要<code>purge</code>的<code>page</code>数目，为超出<code>nactive &gt;&gt; lg_dirty_mult</code>的<code>page</code>数。</li>
<li><code>arena_stash_dirty()</code>：将需要<code>purge</code>的部分从<code>arena-&gt;cached_tree</code>或<code>arena-&gt;avail_runs</code>中移除，防止<code>purge</code>过程中被其他线程分配出去，并插入到需要<code>purge</code>的循环链表中。</li>
<li><code>arena_purge_stashed()</code>：将循环链表中的<code>run</code>进行<code>purge</code></li>
<li><code>arena_unstash_purged()</code>：将<code>chunk</code>进行<code>purge</code>。将<code>purged</code>插入到<code>arena-&gt;cached_tree</code>或<code>arena-&gt;avail_runs</code>，留待后面分配。</li>
</ul>
<p>对<code>chunk</code>和<code>run</code>采取不同的<code>purge</code>：</p>
<ul>
<li>对于<code>run</code>而言，并不是真正的释放，根据操作系统的不同，会使用不同的方式，在<code>linux</code>中会调用<code>madvise(addr, size, MADV_DONTNEED)</code>。</li>
<li><code>jemalloc</code>以<code>chunk</code>为单位向操作系统申请内存，在释放<code>chunk</code>时，会尽量调用<code>munmap()</code>(因为根据操作系统和配置的不同，<code>chunk</code>的来源也不同)，否则会类似<code>run</code>，调用<code>madvise()</code>然后再插入到<code>chunk_retained_tree</code>中，留待后续分配。</li>
</ul>
<p><code>jemalloc</code>中单线程的部分就到此结束了，下面开始看<code>jemalloc</code>是如何提升多线程性能的。</p>
<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><p><code>jemalloc</code>的一个目标就是提高多线程的性能，多线程的分配思路和单线程是一样的，每个线程还是从<code>arena</code>中分配内存，不过会多了线程间的同步和竞争。想要提高多线程性能，主要通过下面 2 个方式:</p>
<ul>
<li>减少锁的竞争：缩小临界区，更细粒度的锁</li>
<li>避免锁的竞争：线程间不共享数据，使用局部变量、线程特有数据(tsd)、线程局部存储(tls)等</li>
</ul>
<h2 id="arena-1"><a href="#arena-1" class="headerlink" title="arena"></a>arena</h2><p><code>jemalloc</code>会创建多个<code>arena</code>，每个线程由一个<code>arena</code>负责。在<code>malloc_init_hard_finish()</code>中会设置<code>arena</code>的相关配置，<code>narenas_auto</code>和<code>narenas_total</code>都设置为<code>cpu核数*4</code>，默认最多创建那么多<code>arena</code>。<code>arena-&gt;nthreads</code>记录负责的线程数量。</p>
<p>每个线程分配时会首先调用<code>arena_choose()</code>选择一个<code>arena</code>来负责该线程的分配。选择<code>arena</code>的逻辑如下:</p>
<ol>
<li>若有空闲的(<code>nthreads==0</code>)已创建的<code>arena</code>，则选择该<code>arena</code></li>
<li>若还有未创建的<code>arena</code>，则选择新创建一个<code>arena</code></li>
<li>选择负载最低的<code>arena</code>(<code>nthreads</code>最小)</li>
</ol>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p><code>mutex</code>尽量使用<code>spinlock</code>，减少线程间的上下文切换:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">JEMALLOC_INLINE <span class="keyword">void</span></span><br><span class="line">malloc_mutex_lock(<span class="keyword">malloc_mutex_t</span> *mutex)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (isthreaded) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _WIN32</span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">if</span> _WIN32_WINNT &gt;= 0x0600</span></span><br><span class="line">		AcquireSRWLockExclusive(&amp;mutex-&gt;lock);</span><br><span class="line"><span class="meta">#  <span class="meta-keyword">else</span></span></span><br><span class="line">		EnterCriticalSection(&amp;mutex-&gt;lock);</span><br><span class="line"><span class="meta">#  <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> (defined(JEMALLOC_OSSPIN))</span></span><br><span class="line">		OSSpinLockLock(&amp;mutex-&gt;lock);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">		pthread_mutex_lock(&amp;mutex-&gt;lock);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为了缩小临界区，<code>arena</code>中有多个锁管理不同的部分:</p>
<ul>
<li><code>arenas_lock</code>：<code>arena</code>的初始化、分配等</li>
<li><code>arena-&gt;lock</code>：<code>run</code>和<code>chunk</code>的管理</li>
<li><code>arena-&gt;huge_mtx</code>：<code>huge object</code>的管理</li>
<li><code>bin-&gt;lock</code>：<code>bin</code>中的操作</li>
</ul>
<h2 id="tsd"><a href="#tsd" class="headerlink" title="tsd"></a>tsd</h2><p>当选择完<code>arena</code>后，会将<code>arena</code>绑定到<code>tsd</code>中，之后会直接从<code>tsd</code>中获取<code>arena</code>。</p>
<p><code>tsd</code>用于保存每个线程特有的数据，主要是<code>arena</code>和<code>tcache</code>，避免锁的竞争。<code>tsd_t</code>中的数据会在第一次访问时延迟初始化(调用相应的<code>get_hard()</code>)，<code>tsd</code>中各元素使用宏生成对应的<code>get/set</code>函数来获取/设置，在线程退出时，会调用相应的<code>cleanup</code>函数清理。下面只介绍<code>linux</code>平台中的实现。</p>
<p>在<code>linux</code>中会使用<code>tls(__thread)</code>和<code>tsd(pthread_key_create(), pthread_setspecific())</code>来实现:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> (defined(JEMALLOC_TLS))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	malloc_tsd_data(a_attr, a_name, a_type, a_initializer)		\</span></span><br><span class="line">a_attr __thread a_type JEMALLOC_TLS_MODEL				\</span><br><span class="line">    a_name##tsd_tls = a_initializer;					\</span><br><span class="line">a_attr <span class="keyword">pthread_key_t</span>	a_name##tsd_tsd;				\</span><br><span class="line">a_attr <span class="keyword">bool</span>		a_name##tsd_booted = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>__thread</code>保存需要线程局部存储的数据<code>tsd_t</code></li>
<li><code>pthread_key_t</code>将<code>key</code>与<code>__thread</code>联系起来，用于注册<code>destructor，</code>在线程退出时清理<code>tsd_t</code></li>
</ul>
<p>其实可以只用<code>pthread_key_t</code>来实现，但使用<code>__thread</code>可以直接获取数据，不用再调用<code>pthread_getspecific()</code>。</p>
<h2 id="tcache"><a href="#tcache" class="headerlink" title="tcache"></a>tcache</h2><p><code>tcache</code>用于<code>small</code>和<code>large</code>的分配，避免多线程的同步。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"opt.tcache"</span> (<span class="keyword">bool</span>) r- [--enable-tcache]</span><br><span class="line">        Thread-specific caching (tcache) enabled/disabled. When there are multiple threads, each thread uses a tcache for objects up to a certain size. Thread-specific caching allows many allocations to be satisfied without performing any</span><br><span class="line">        thread synchronization, at the cost of increased memory use. See the <span class="string">"opt.lg_tcache_max"</span> option <span class="keyword">for</span> related tuning information. This option is enabled by <span class="keyword">default</span> unless running inside Valgrind[<span class="number">2</span>], in which <span class="keyword">case</span> it is forcefully</span><br><span class="line">        disabled.</span><br><span class="line"></span><br><span class="line"><span class="string">"opt.lg_tcache_max"</span> (<span class="keyword">size_t</span>) r- [--enable-tcache]</span><br><span class="line">    Maximum size class (log base 2) to cache in the thread-specific cache (tcache). At a minimum, all small size classes are cached, and at a maximum all large size classes are cached. The default maximum is 32 KiB (2^15).</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcache_s</span> &#123;</span></span><br><span class="line">	ql_elm(<span class="keyword">tcache_t</span>) link;		<span class="comment">/* Used for aggregating stats. */</span></span><br><span class="line">	<span class="keyword">uint64_t</span>	prof_accumbytes;<span class="comment">/* Cleared after arena_prof_accum(). */</span></span><br><span class="line">	<span class="keyword">unsigned</span>	ev_cnt;		<span class="comment">/* Event count since incremental GC. */</span></span><br><span class="line">	<span class="keyword">szind_t</span>		next_gc_bin;	<span class="comment">/* Next bin to GC. */</span></span><br><span class="line">	<span class="keyword">tcache_bin_t</span>	tbins[<span class="number">1</span>];	<span class="comment">/* Dynamically sized. */</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The pointer stacks associated with tbins follow as a contiguous</span></span><br><span class="line"><span class="comment">	 * array.  During tcache initialization, the avail pointer in each</span></span><br><span class="line"><span class="comment">	 * element of tbins is initialized to point to the proper offset within</span></span><br><span class="line"><span class="comment">	 * this array.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcache_bin_s</span> &#123;</span></span><br><span class="line">	<span class="keyword">tcache_bin_stats_t</span> tstats;</span><br><span class="line">	<span class="keyword">int</span>		low_water;	<span class="comment">/* Min # cached since last GC. */</span></span><br><span class="line">	<span class="keyword">unsigned</span>	lg_fill_div;	<span class="comment">/* Fill (ncached_max &gt;&gt; lg_fill_div). */</span></span><br><span class="line">	<span class="keyword">unsigned</span>	ncached;	<span class="comment">/* # of cached objects. */</span></span><br><span class="line">	<span class="keyword">void</span>		**avail;	<span class="comment">/* Stack of available objects. */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>tcache</code>同样使用<code>slab</code>算法分配:</p>
<ul>
<li><code>tcache</code>中有多种<code>bin</code>，每个<code>bin</code>管理一个<code>size class</code></li>
<li>当分配时，从对应<code>bin</code>中返回一个<code>cache slot</code></li>
<li>当释放时，将<code>cache slot</code>返回给对应的<code>bin</code></li>
</ul>
<p><code>tcache</code>中<code>avail</code>是指针数组，每个数组元素指向对应的<code>cache slot</code>，<code>cache slot</code>是从<code>arena</code>中分配的，缓存在<code>tcache</code>中。</p>
<p><code>tcache_boot()</code>：根据配置<code>opt.lg_tcache_max</code>设置<code>tcache</code>中<code>bin</code>的范围(<code>nhbins</code>)。设置<code>tcache_bin_info</code>，保存每种<code>bin</code>的<code>cache slots</code>个数(类似<code>arena_bin_info</code>中<code>nregs</code>)，<code>small</code>在<code>TCACHE_NSLOTS_SMALL_MIN</code>到<code>TCACHE_NSLOTS_SMALL_MAX</code>间，<code>large</code>固定为<code>TCACHE_NSLOTS_LARGE</code>。</p>
<p><code>tcache_create()</code>：<code>tcache_t</code>中保存着<code>tbins[]</code>信息，<code>tcache_bin_t</code>中<code>avail</code>指向每一个<code>cache slot</code>(类似<code>arena-&gt;bin</code>中<code>region</code>)，<code>tcache_create()</code>根据<code>tcache_boot()</code>设置的配置分配<code>tcache_t</code>和<code>tcache_bin_t</code>的内存，<code>tcache_t</code>和<code>tbins[]</code>为连续内存，<code>tbins[]</code>中<code>avail</code>使用后面连续空间的内存。</p>
<p><img src="/img/20211102100904.png" alt></p>
<h2 id="small-1"><a href="#small-1" class="headerlink" title="small"></a>small</h2><p><code>small</code>分配流程如下:</p>
<ol>
<li><code>tcache_alloc_small()</code>：先获取对应的<code>tbin</code>，调用<code>tcache_alloc_easy()</code>，若<code>tbin</code>中还有剩余的元素，返回<code>tbin-&gt;avail[tbin-&gt;ncached]</code>(从后往前分配，<code>ncached</code>既是剩余数量也是索引)，<code>tbin-&gt;low_water</code>保存着<code>tbin-&gt;ncached</code>的最小值。</li>
<li><code>tcache_alloc_small_hard()</code>：<code>tbin</code>已空，先调用<code>arena_tcache_fill_small()</code>重新装载<code>tbin</code>，再调用<code>tcache_alloc_easy()</code>分配。</li>
<li><code>arena_tcache_fill_small()</code>：从<code>arena</code>中对应的<code>bin</code>分配<code>region</code>保存在<code>tbin-&gt;avail</code>中，只会填充<code>ncached_max &gt;&gt; lg_fill_div</code>个。</li>
</ol>
<p><code>small</code>释放流程如下:</p>
<ol>
<li><code>tcache_dalloc_small()</code>：通过<code>ptr</code>对应的<code>map_bits</code>获取<code>binind</code>，然后将<code>ptr</code>释放(保存在<code>tbin-&gt;avail[tbin-&gt;ncached]</code>，同时<code>tbin-&gt;ncached++</code>)。若该<code>tbin</code>已满(<code>tbin-&gt;ncached == tbin_info-&gt;ncached_max</code>)，会调用<code>tcache_bin_flush_small()</code>，释放一半<code>cache slots</code>给<code>arena</code>。</li>
<li><code>tcache_bin_flush_small()</code>：会释放<code>tbin</code>中部分<code>avail</code>返回给<code>arena</code>中对应的<code>bin</code>，这里为了减少锁的调用，会在一次加锁中，释放所有对应该锁(bin)的<code>cache slot</code>。</li>
</ol>
<h2 id="large-1"><a href="#large-1" class="headerlink" title="large"></a>large</h2><p>分配和<code>small</code>类似，先调用<code>tcache_alloc_easy()</code>，不过若<code>tbin</code>为空时，不会像<code>small</code>一样分配所有的<code>avail</code>，而是调用<code>arena_malloc_large()</code>从<code>arena</code>中分配一个<code>run</code>。因为创建多个<code>large object</code>太过昂贵，并且有可能会用不到，浪费空间。</p>
<p>释放和<code>small</code>类似，先释放到<code>tbin-&gt;avail[tbin-&gt;ncached]</code>中，备用。若该<code>tbin</code>已满，调用<code>arena_bin_flush_large()</code>释放一半到<code>arena</code>中。</p>
<h2 id="gc"><a href="#gc" class="headerlink" title="gc"></a>gc</h2><p>前面注意到，当从<code>arena</code>分配<code>small</code>时， 会分配<code>ncached_max &gt;&gt; lg_fill_div</code>个，若每次均分配固定数目，有可能会造成内存浪费，<code>jemalloc</code>对<code>tcache</code>中的<code>bin</code>采用渐进式<code>GC</code>，动态的调整分配数目。有 2 个宏控制着<code>GC</code>的进行:</p>
<ul>
<li><code>TCACHE_GC_SWEEP</code>：可以近似认为每发生该数量的分配或释放操作，所有的<code>bin</code>都被<code>GC</code></li>
<li><code>TCACHE_GC_INCR</code>：每发生该数量的分配或释放操作，单个<code>bin</code>进行一次<code>GC</code></li>
</ul>
<p><code>tcache</code>中每个<code>bin</code>会有如下2个字段:</p>
<ul>
<li><code>low_water</code>：保存着一次<code>GC</code>时间间隔内，<code>ncached</code>的最小值，也就意味着在这之下的<code>avail</code>都没被分配</li>
<li><code>lg_fill_div</code>：用于控制每次分配的数量(<code>ncached_max &gt;&gt; lg_fill_div</code>)，初始为 1</li>
</ul>
<p>在每次分配和释放时，都会调用<code>tcache_event()</code>，增加<code>tcache-&gt;ev_cnt</code>，若和<code>TCACHE_GC_INCR</code>相等，则调用<code>tcache_event_hard()</code>对单个<code>bin</code>进行<code>GC</code>(只对<code>small object</code>有效)。<code>tcache_event_hard()</code>：对单个<code>bin</code>(<code>next_gc_bin</code>)进行<code>GC</code>:</p>
<ol>
<li>若<code>tbin-&gt;low_water &gt; 0</code>：说明<code>tbin-&gt;avail</code>中有些未被用到，可以尝试减少分配。对应的操作就是释放掉<code>3/4 low_water</code>，<code>lg_fill_div++</code>(下次分配时会减少一半)</li>
<li>若<code>tbin-&gt;low_water &lt; 0</code>：只有在该<code>tbin-&gt;avail</code>全部分配完才会置<code>low_water = -1</code>，说明不够用，所以会<code>lg_fill_div--</code>(下次分配时加倍)</li>
</ol>
<p><code>tcache</code>中的<code>tbin</code>分配数量就会一直动态调整。</p>
<h2 id="线程退出"><a href="#线程退出" class="headerlink" title="线程退出"></a>线程退出</h2><p>线程退出时，会调用<code>tsd_cleanup()</code>对<code>tsd</code>中数据进行清理:</p>
<ul>
<li><code>arena</code>：降低<code>arena</code>负载(<code>arena-&gt;nthreads--</code>)</li>
<li><code>tcache</code>：调用<code>tcache_bin_flush_small/large()</code>释放<code>tcache-&gt;tbins[]</code>所有元素，释放<code>tcache</code>本身</li>
</ul>
<p>当从一个线程分配的内存由另一个线程释放时，该内存还是由原先的<code>arena</code>来管理，通过<code>chunk</code>的<code>extent_node_t</code>来获取对应的<code>arena</code>。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><code>jemalloc</code>中大量使用了宏生成代码，比较晦涩，不过其他部分还是比较清楚的，只要理解了它的思路就容易看懂，一层一层的。现在来总结一下<code>jemalloc</code>的思路：</p>
<ul>
<li>通过避免<code>false cache line sharing</code>，使用内存着色等，提高<code>cache line</code>效率</li>
<li>使用<code>slab</code>分配不同大小的对象，精心选择<code>size classes</code>，减少内存碎片</li>
<li>使用多层缓存，内存的释放和分配会经历很多阶段，提升速度</li>
<li><code>metadata</code>存放在连续内存，降低<code>metadata</code>的<code>overhead</code>，同时能减少<code>active pages</code></li>
<li>地址对齐从而在常量时间内获取<code>metadata</code></li>
<li>首先复用低地址的内存，减少<code>active pages</code></li>
<li>使用多个<code>arena</code>管理、更细粒度的锁、<code>tsd</code>、<code>tcache</code>等，最小化锁竞争</li>
</ul>
<h1 id="JeMalloc-5-1-0-版本"><a href="#JeMalloc-5-1-0-版本" class="headerlink" title="JeMalloc-5.1.0 版本"></a>JeMalloc-5.1.0 版本</h1><p>这篇文章介绍JeMalloc-5.1.0 版本（release 日期：2018年5月9日）的实现细节。</p>
<p>对于对老版本比较熟悉的人来说，有几点需要说明：</p>
<ul>
<li><code>chunk</code>这一概念被替换成了 extent</li>
<li><code>dirty page</code>的<code>decay</code>（或者说 gc） 变成了两阶段，dirty -&gt; muzzy -&gt; retained</li>
<li><code>huge class</code>这一概念不再存在</li>
<li>红黑树不再使用，取而代之的是 pairing heap</li>
</ul>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>以下内容介绍 JeMalloc 中比较重要的概念以及数据结构。</p>
<h3 id="size-class"><a href="#size-class" class="headerlink" title="size_class"></a>size_class</h3><p>每个<code>size_class</code>代表<code>jemalloc</code>分配的内存大小，共有<code>NSIZES</code>（232）个小类（如果用户申请的大小位于两个小类之间，会取较大的，比如申请14字节，位于8和16字节之间，按16字节分配），分为2大类：</p>
<ul>
<li><code>small_class</code>（小内存） : 对于64位机器来说，通常区间是 [8, 14kb]，常见的有 8, 16, 32, 48, 64, …, 2kb, 4kb, 8kb，注意为了减少内存碎片并不都是2的次幂，比如如果没有48字节，那当申请33字节时，分配64字节显然会造成约50%的外部碎片</li>
<li><code>large_class</code>（大内存）: 对于64位机器来说，通常区间是 [16kb, 7EiB]，从 4 * page_size 开始，常见的比如 16kb, 32kb, …, 1mb, 2mb, 4mb，最大是<code>2^63 + 3^60</code></li>
<li><code>size_index</code>: size 位于 size_class 中的索引号，区间为 [0，231]，比如8字节则为0，14字节（按16计算）为1，4kb字节为28，当<code>size</code>是<code>small_class</code>时，<code>size_index</code>也称作<code>binind</code></li>
</ul>
<h3 id="base-1"><a href="#base-1" class="headerlink" title="base"></a>base</h3><p>用于分配 jemalloc 元数据内存的结构，通常一个 base 大小为 2mb， 所有 base 组成一个链表。</p>
<ul>
<li><code>base.extents[NSIZES]</code>: 存放每个<code>size_class</code>的<code>extent</code>元数据</li>
</ul>
<h3 id="bin-1"><a href="#bin-1" class="headerlink" title="bin"></a>bin</h3><p>管理正在使用中的<code>slab</code>（即用于小内存分配的 extent） 的集合，每个<code>bin</code>对应一个<code>size_class</code></p>
<ul>
<li><code>bin.slabcur</code>: 当前使用中的 slab</li>
<li><code>bin.slabs_nonfull</code>: 有空闲内存块的 slab</li>
</ul>
<h3 id="extent"><a href="#extent" class="headerlink" title="extent"></a>extent</h3><p>管理 jemalloc 内存块（即用于用户分配的内存）的结构，每一个内存块大小可以是<code>N * page_size(4kb)</code>（N &gt;= 1）。每个<code>extent</code>有一个序列号（serial number）。</p>
<p>一个<code>extent</code>可以用来分配一次<code>large_class</code>的内存申请，但可以用来分配多次<code>small_class</code>的内存申请。</p>
<ul>
<li><code>extent.e_bits</code>: 8字节长，记录多种信息</li>
<li><code>extent.e_addr</code>: 管理的内存块的起始地址</li>
<li><code>extent.e_slab_data</code>: 位图，当此<code>extent</code>用于分配<code>small_class</code>内存时，用来记录这个<code>extent</code>的分配情况，此时每个<code>extent</code>的内的小内存称为<code>region</code></li>
</ul>
<h3 id="slab"><a href="#slab" class="headerlink" title="slab"></a>slab</h3><p>当<code>extent</code>用于分配<code>small_class</code>内存时，称其为<code>slab</code>。一个<code>extent</code>可以被用来处理多个同一<code>size_class</code>的内存申请。</p>
<h3 id="extents"><a href="#extents" class="headerlink" title="extents"></a>extents</h3><p>管理<code>extent</code>的集合。</p>
<ul>
<li><code>extents.heaps[NPSIZES+1]</code>: 各种 page(4kb) 倍数大小的 extent</li>
<li><code>extents.lru</code>: 存放所有<code>extent</code>的双向链表</li>
<li><code>extents.delay_coalesce</code>: 是否延迟<code>extent</code>的合并</li>
</ul>
<h3 id="arena-2"><a href="#arena-2" class="headerlink" title="arena"></a>arena</h3><p>用于分配&amp;回收<code>extent</code>的结构，每个用户线程会被绑定到一个<code>arena</code>上，默认每个逻辑 CPU 会有 4 个<code>arena</code>来减少锁的竞争，各个<code>arena</code>所管理的内存相互独立。</p>
<ul>
<li><code>arena.extents_dirty</code>：刚被释放后空闲<code>extent</code>位于的地方</li>
<li><code>arena.extents_muzzy</code>：<code>extents_dirty</code>进行<code>lazy purge</code>后位于的地方，dirty -&gt; muzzy</li>
<li><code>arena.extents_retained</code>：<code>extents_muzzy</code>进行<code>decommit</code>或<code>force purge</code>后<code>extent</code>位于的地方，muzzy -&gt; retained</li>
<li><code>arena.large</code>：存放<code>large extent</code>的 extents</li>
<li><code>arena.extent_avail</code>：<code>heap</code>，存放可用的<code>extent</code>元数据</li>
<li><code>arena.bins[NBINS]</code>：所以用于分配小内存的<code>bin</code></li>
<li><code>arena.base</code>：用于分配元数据的<code>base</code></li>
</ul>
<h3 id="rtree"><a href="#rtree" class="headerlink" title="rtree"></a>rtree</h3><p>全局唯一的存放每个<code>extent</code>信息的 Radix Tree，以<code>extent-&gt;e_addr</code>即<code>uintptr_t</code>为<code>key</code>，以我的机器为例，<code>uintptr_t</code>为64位（8字节），<code>rtree</code>的高度为3，由于<code>extent-&gt;e_addr</code>是<code>page(1 &lt;&lt; 12)</code>对齐的，也就是说需要 64 - 12 = 52 位即可确定在树中的位置，每一层分别通过第0-16位，17-33位，34-51位来进行访问。</p>
<p><img src="/img/v2-92f9c4741a626e4a48a9ca987d36b82c_1440w.jpg" alt></p>
<h3 id="cache-bin"><a href="#cache-bin" class="headerlink" title="cache_bin"></a>cache_bin</h3><p>每个线程独有的用于分配小内存的缓存</p>
<ul>
<li><code>low_water</code>：上一次 gc 后剩余的缓存数量</li>
<li><code>cache_bin.ncached</code>：当前 cache_bin 存放的缓存数量</li>
<li><code>cache_bin.avail</code>：可直接用于分配的内存，从左往右依次分配（注意这里的寻址方式）</li>
</ul>
<p><img src="/img/v2-4ce3efe4b89f927df4b4c0cfbd588558_1440w.jpg" alt></p>
<h3 id="tcache-1"><a href="#tcache-1" class="headerlink" title="tcache"></a>tcache</h3><p>每个线程独有的缓存（Thread Cache），大多数内存申请都可以在 tcache 中直接得到，从而避免加锁</p>
<ul>
<li><code>tcache.bins_small[NBINS]</code>：小内存的<code>cache_bin</code></li>
</ul>
<h3 id="tsd-1"><a href="#tsd-1" class="headerlink" title="tsd"></a>tsd</h3><p>Thread Specific Data，每个线程独有，用于存放与这个线程相关的结构</p>
<ul>
<li><code>tsd.rtree_ctx</code>：当前线程的<code>rtree context</code>，用于快速访问<code>extent</code>信息</li>
<li><code>tsd.arena</code>：当前线程绑定的<code>arena</code></li>
<li><code>tsd.tcache</code>：当前线程的<code>tcache</code></li>
</ul>
<h2 id="内存分配（malloc）"><a href="#内存分配（malloc）" class="headerlink" title="内存分配（malloc）"></a>内存分配（malloc）</h2><h3 id="小内存-small-class-分配"><a href="#小内存-small-class-分配" class="headerlink" title="小内存(small_class)分配"></a>小内存(small_class)分配</h3><p>首先从<code>tsd-&gt;tcache-&gt;bins_small[binind]</code>中获取对应<code>size_class</code>的内存，有的话将内存直接返回给用户，如果<code>bins_small[binind]</code>中没有的话，需要通过<code>slab(extent)</code>对<code>tsd-&gt;tcache-&gt;bins_small[binind]</code>进行填充，一次填充多个以备后续分配，填充方式如下（当前步骤无法成功则进行下一步）：</p>
<ol>
<li>通过<code>bin-&gt;slabcur</code>分配</li>
<li>从<code>bin-&gt;slabs_nonfull</code>中获取可使用的<code>extent</code></li>
<li>从<code>arena-&gt;extents_dirty</code>中回收<code>extent</code>，回收方式为<code>best-fit</code>，即满足大小要求的最小<code>extent</code>，在<code>arena-&gt;extents_dirty-&gt;bitmap</code>中找到满足大小要求并且第一个非空<code>heap</code>的索引<code>i</code>，然后从<code>extents-&gt;heaps[i]</code>中获取第一个<code>extent</code>。由于<code>extent</code>可能较大，为了防止产生内存碎片，需要对<code>extent</code>进行分裂（伙伴算法），然后将分裂后不使用的<code>extent</code>放回<code>extents_dirty</code>中</li>
<li>从<code>arena-&gt;extents_muzzy</code>中回收<code>extent</code>，回收方式为<code>first-fit</code>，即满足大小要求且序列号最小地址最低（最旧）的<code>extent</code>，遍历每个满足大小要求并且非空的<code>arena-&gt;extents_dirty-&gt;bitmap</code>，获取其对应<code>extents-&gt;heaps</code>中第一个<code>extent</code>，然后进行比较，找到最旧的<code>extent</code>，之后仍然需要分裂</li>
<li>从<code>arena-&gt;extents_retained</code>中回收<code>extent</code>，回收方式与<code>extents_muzzy</code>相同</li>
<li>尝试通过<code>mmap</code>向内核获取所需的<code>extent</code>内存，并且在<code>rtree</code>中注册新<code>extent</code>的信息</li>
<li>再次尝试从<code>bin-&gt;slabs_nonfull</code>中获取可使用的<code>extent</code></li>
</ol>
<p>简单来说，这个流程是这样的，<code>cache_bin -&gt; slab -&gt; slabs_nonfull -&gt; extents_dirty -&gt; extents_muzzy -&gt; extents_retained -&gt; kernal</code>。</p>
<p><img src="/img/v2-07d44c859efbc6ac177b27793acb96e8_1440w.jpg" alt></p>
<h3 id="大内存-large-class-分配"><a href="#大内存-large-class-分配" class="headerlink" title="大内存(large_class)分配"></a>大内存(large_class)分配</h3><p>大内存不存放在<code>tsd-&gt;tcache</code>中，因为这样可能会浪费内存，所以每次申请都需要重新分配一个<code>extent</code>，申请的流程和小内存申请<code>extent</code>流程中的3, 4, 5, 6是一样的。</p>
<h2 id="内存释放（free）"><a href="#内存释放（free）" class="headerlink" title="内存释放（free）"></a>内存释放（free）</h2><h3 id="小内存释放"><a href="#小内存释放" class="headerlink" title="小内存释放"></a>小内存释放</h3><p>在<code>rtree</code>中找到需要被释放内存所属的<code>extent</code>信息，将要被释放的内存还给<code>tsd-&gt;tcache-&gt;bins_small[binind]</code>，如果<code>tsd-&gt;tcache-&gt;bins_small[binind]</code>已满，需要对其进行<code>flush</code>，流程如下：</p>
<ol>
<li>将这块内存返还给所属<code>extent</code>，如果这个<code>extent</code>中空闲的内存块变成了最大（即没有一份内存被分配），跳到2；如果这个<code>extent</code>中的空闲块变成了1并且这个<code>extent</code>不是<code>arena-&gt;bins[binind]-&gt;slabcur</code>，跳到3</li>
<li>将这个<code>extent</code>释放，即插入<code>arena-&gt;extents_dirty</code>中</li>
<li>将<code>arena-&gt;bins[binind]-&gt;slabcur</code>切换为这个<code>extent</code>，前提是这个<code>extent</code>“更旧”（序列号更小地址更低），并且将替换后的<code>extent</code>移入<code>arena-&gt;bins[binind]-&gt;slabs_nonfull</code></li>
</ol>
<h3 id="大内存释放"><a href="#大内存释放" class="headerlink" title="大内存释放"></a>大内存释放</h3><p>因为大内存不存放在<code>tsd-&gt;tcache</code>中，所以大内存释放只进行小内存释放的步骤2，即将<code>extent</code>插入<code>arena-&gt;extents_dirty</code>中。</p>
<h2 id="内存再分配（realloc）"><a href="#内存再分配（realloc）" class="headerlink" title="内存再分配（realloc）"></a>内存再分配（realloc）</h2><h3 id="小内存再分配"><a href="#小内存再分配" class="headerlink" title="小内存再分配"></a>小内存再分配</h3><ol>
<li>尝试进行 no move 分配，如果之前的实际分配满足条件的话，可以不做任何事情，直接返回。比如第一次申请了12字节，但实际上 jemalloc 会实际分配16字节，然后第二次申请将12扩大到15字节或者缩小到9字节，那这时候16字节就已经满足需求了，所以不做任何事情，如果无法满足，跳到2</li>
<li>重新分配，申请新内存大小（参考内存分配），然后将旧内存内容拷贝到新地址，之后释放旧内存（参考内存释放），最后返回新内存</li>
</ol>
<h3 id="大内存再分配"><a href="#大内存再分配" class="headerlink" title="大内存再分配"></a>大内存再分配</h3><ol>
<li>尝试进行 no move 分配，如果两次申请位于同一 size class 的话就可以不做任何事情，直接返回。</li>
<li>尝试进行 no move resize 分配，如果第二次申请的大小大于第一次，则尝试对当前地址所属<code>extent</code>的下一地址查看是否可以分配，比如当前<code>extent</code>地址是 0x1000，大小是 0x1000，那么我们查看地址 0x2000 开始的<code>extent</code>是否存在（通过 rtree）并且是否满足要求，如果满足要求那两个<code>extent</code>可以进行合并，成为一个新的<code>extent</code>而不需要重新分配；如果第二次申请的大小小于第一次，那么尝试对当前<code>extent</code>进行<code>split</code>，移除不需要的后半部分，以减少内存碎片；如果无法进行 no move resize 分配，跳到3</li>
<li>重新分配，申请新内存大小（参考内存分配），然后将旧内存内容拷贝到新地址，之后释放旧内存（参考内存释放），最后返回新内存</li>
</ol>
<h2 id="内存-GC"><a href="#内存-GC" class="headerlink" title="内存 GC"></a>内存 GC</h2><p>分为2种， tcache 和 extent GC。其实更准确来说是 decay，为了方便还是用 gc 吧。</p>
<h3 id="tcache-GC"><a href="#tcache-GC" class="headerlink" title="tcache GC"></a>tcache GC</h3><p>针对 small_class，防止某个线程预先分配了内存但是却没有实际分配给用户，会定期将缓存 flush 到 extent。</p>
<p>GC 策略：每次对于 tcache 进行 malloc 或者 free 操作都会执行一次计数，默认情况下达到228次就会触发 gc，每次 gc 一个<code>cache_bin</code>。</p>
<p>如何 GC：</p>
<ol>
<li><code>cache_bin.low_water &gt; 0</code>: gc 掉 low_water 的 3/4，同时，将<code>cache_bin</code>能缓存的最大数量缩小一倍</li>
<li><code>cache_bin.low_water &lt; 0</code>: 将<code>cache_bin</code>能缓存的最大数量增大一倍</li>
</ol>
<p>总的来说保证当前<code>cache_bin</code>分配越频繁，则会缓存更多的内存，否则则会减少。</p>
<h3 id="extent-GC"><a href="#extent-GC" class="headerlink" title="extent GC"></a>extent GC</h3><p>调用<code>free</code>时，内存并没有归还给内核。<code>jemalloc</code>内部会不定期地将没有用于分配的<code>extent</code>逐步GC，流程和内存申请是反向的，<code>free -&gt; extents_dirty -&gt; extents_muzzy -&gt; extents_retained -&gt; kernal</code>。</p>
<p>GC 策略：默认10s为<code>extents_dirty</code>和<code>extents_muzzy</code>的一个 gc 周期，每次对于<code>arena</code>进行<code>malloc</code>或者<code>free</code>操作都会执行一次计数，达到1000次会检测有没有达到<code>gc</code>的<code>deadline</code>，如果是的话进行 gc。</p>
<p>注意并不是每隔10s一次性 gc，实际上 jemalloc 会将10s划分成200份，即每隔0.05s进行一次 gc，这样一来如果<code>t</code>时刻有<code>N</code>个<code>page</code>需要<code>gc</code>，那么<code>jemalloc</code>尽力保证在<code>t+10</code>时刻这<code>N</code>个<code>page</code>会被<code>gc</code>完成。</p>
<p>对于<code>N</code>个需要<code>gc</code>的<code>page</code>来说，并不是简单地每0.05s处理<code>N/200</code>个<code>page</code>，<code>jemalloc</code>引入了<code>Smoothstep</code>（主要用于计算机图形学）来获得更加平滑的<code>gc</code>机制，这也是 jemalloc 非常有意思的一个点。</p>
<p>jemalloc 内部维护了一个长度为200的数组，用来计算在10s的 gc 周期内每个时间点应该对多少 page 进行 gc。这样保证两次 gc 的时间段内产生的需要 gc 的 page 都会以图中绿色线条（默认使用 smootherstep）的变化曲线在10s的周期内从 N 减为 0（从右往左）。</p>
<p>如何 GC：先进行<code>extents_dirty</code>的 gc，后进行<code>extents_muzzy</code>。</p>
<ol>
<li>将<code>extents_dirty</code>中的<code>extent</code>移入<code>extents_muzzy</code>：<ol>
<li>在<code>extents_dirty</code>中的<code>LRU</code>链表中，获得要进行<code>gc</code>的<code>extent</code>，尝试对<code>extent</code>进行前后合并（前提是两个<code>extent</code>位于同一<code>arena</code>并且位于同一<code>extents</code>中），获得新的<code>extent</code>，然后将其移除</li>
<li>对当前<code>extent</code>管理的地址进行<code>lazy purge</code>，即通过<code>madvise</code>使用<code>MADV_FREE</code>参数告诉内核当前<code>extent</code>管理的内存可能不会再被访问</li>
<li>在<code>extents_muzzy</code>中尝试对当前<code>extent</code>进行前后合并，获得新的<code>extent</code>，最后将其插入<code>extents_muzzy</code></li>
</ol>
</li>
<li>将<code>extents_muzzy</code>中的<code>extent</code>移入<code>extents_retained</code>:<ol>
<li>在<code>extents_muzzy</code>中的<code>LRU</code>链表中，获得要进行<code>gc</code>的<code>extent</code>，尝试对<code>extent</code>进行前后合并，获得新的<code>extent</code>，然后将其移除</li>
<li>对当前<code>extent</code>管理的地址进行<code>decommit</code>，即调用<code>mmap</code>带上<code>PROT_NONE</code>告诉内核当前<code>extent</code>管理的地址可能不会再被访问，如果<code>decommit</code>失败，会进行<code>force purge</code>，即通过<code>madvise</code>使用<code>MADV_DONTNEED</code>参数告诉内核当前<code>extent</code>管理的内存可能不会再被访问</li>
<li>在<code>extents_retained</code>中尝试对当前<code>extent</code>进行前后合并，获得新的<code>extent</code>，最后将其插入<code>extents_retained</code></li>
</ol>
</li>
<li>jemalloc 默认不会将内存归还给内核，只有进程结束时，所有内存才会<code>munmap</code>，从而归还给内核。不过可以手动进行<code>arena</code>的销毁，从而将<code>extents_retained</code>中的内存进行<code>munmap</code></li>
</ol>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/C/" rel="tag"># C++</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/10/25/jemalloc介绍/" rel="next" title="Inside of Jemalloc">
                <i class="fa fa-chevron-left"></i> Inside of Jemalloc
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/11/02/性能优化-使用objdump分析core堆栈/" rel="prev" title="性能优化-使用objdump分析core堆栈">
                性能优化-使用objdump分析core堆栈 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/header.jpg" alt="Hao Yu">
            
              <p class="site-author-name" itemprop="name">Hao Yu</p>
              <p class="site-description motion-element" itemprop="description">Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author</p>
          </div>
          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">281</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>
        	<audio controls="controls" loop="loop" preload="auto" src="/resource/xiaomeihao.mp3">
	        </audio>
	

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yuhao0102" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:yuh18@mails.tsinghua.edu.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#背景知识"><span class="nav-number">1.</span> <span class="nav-text">背景知识</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#内存的来源"><span class="nav-number">1.1.</span> <span class="nav-text">内存的来源</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#False-cache-line-sharing"><span class="nav-number">1.2.</span> <span class="nav-text">False cache line sharing</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内存着色"><span class="nav-number">1.3.</span> <span class="nav-text">内存着色</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么需要内存分配器"><span class="nav-number">1.4.</span> <span class="nav-text">为什么需要内存分配器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内存分配器的目标"><span class="nav-number">1.5.</span> <span class="nav-text">内存分配器的目标</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#常用内存分配器算法"><span class="nav-number">2.</span> <span class="nav-text">常用内存分配器算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Dynamic-memory-allocation"><span class="nav-number">2.1.</span> <span class="nav-text">Dynamic memory allocation</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Buddy-memory-allocation"><span class="nav-number">2.2.</span> <span class="nav-text">Buddy memory allocation</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Slab-allocation"><span class="nav-number">2.3.</span> <span class="nav-text">Slab allocation</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#jemalloc-源码分析"><span class="nav-number">3.</span> <span class="nav-text">jemalloc 源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#page"><span class="nav-number">3.1.</span> <span class="nav-text">page</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#chunk"><span class="nav-number">3.2.</span> <span class="nav-text">chunk</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#base"><span class="nav-number">3.3.</span> <span class="nav-text">base</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#arena"><span class="nav-number">3.4.</span> <span class="nav-text">arena</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#run"><span class="nav-number">3.5.</span> <span class="nav-text">run</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#bin"><span class="nav-number">3.6.</span> <span class="nav-text">bin</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#chunk-1"><span class="nav-number">3.7.</span> <span class="nav-text">chunk</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#arena-chunk-t"><span class="nav-number">3.8.</span> <span class="nav-text">arena_chunk_t</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#常量时间获取-metadata"><span class="nav-number">4.</span> <span class="nav-text">常量时间获取 metadata</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#从-run-到-region"><span class="nav-number">4.1.</span> <span class="nav-text">从 run 到 region</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#从-region-到-run"><span class="nav-number">4.2.</span> <span class="nav-text">从 region 到 run</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#run-的合并"><span class="nav-number">4.3.</span> <span class="nav-text">run 的合并</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#size-classes"><span class="nav-number">5.</span> <span class="nav-text">size classes</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#small"><span class="nav-number">5.1.</span> <span class="nav-text">small</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#large"><span class="nav-number">5.2.</span> <span class="nav-text">large</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#huge"><span class="nav-number">5.3.</span> <span class="nav-text">huge</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#purge"><span class="nav-number">5.4.</span> <span class="nav-text">purge</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#多线程"><span class="nav-number">6.</span> <span class="nav-text">多线程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#arena-1"><span class="nav-number">6.1.</span> <span class="nav-text">arena</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#锁"><span class="nav-number">6.2.</span> <span class="nav-text">锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#tsd"><span class="nav-number">6.3.</span> <span class="nav-text">tsd</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#tcache"><span class="nav-number">6.4.</span> <span class="nav-text">tcache</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#small-1"><span class="nav-number">6.5.</span> <span class="nav-text">small</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#large-1"><span class="nav-number">6.6.</span> <span class="nav-text">large</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#gc"><span class="nav-number">6.7.</span> <span class="nav-text">gc</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程退出"><span class="nav-number">6.8.</span> <span class="nav-text">线程退出</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#总结"><span class="nav-number">7.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JeMalloc-5-1-0-版本"><span class="nav-number">8.</span> <span class="nav-text">JeMalloc-5.1.0 版本</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#基础知识"><span class="nav-number">8.1.</span> <span class="nav-text">基础知识</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#size-class"><span class="nav-number">8.1.1.</span> <span class="nav-text">size_class</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#base-1"><span class="nav-number">8.1.2.</span> <span class="nav-text">base</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bin-1"><span class="nav-number">8.1.3.</span> <span class="nav-text">bin</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#extent"><span class="nav-number">8.1.4.</span> <span class="nav-text">extent</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#slab"><span class="nav-number">8.1.5.</span> <span class="nav-text">slab</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#extents"><span class="nav-number">8.1.6.</span> <span class="nav-text">extents</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#arena-2"><span class="nav-number">8.1.7.</span> <span class="nav-text">arena</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#rtree"><span class="nav-number">8.1.8.</span> <span class="nav-text">rtree</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cache-bin"><span class="nav-number">8.1.9.</span> <span class="nav-text">cache_bin</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tcache-1"><span class="nav-number">8.1.10.</span> <span class="nav-text">tcache</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tsd-1"><span class="nav-number">8.1.11.</span> <span class="nav-text">tsd</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内存分配（malloc）"><span class="nav-number">8.2.</span> <span class="nav-text">内存分配（malloc）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#小内存-small-class-分配"><span class="nav-number">8.2.1.</span> <span class="nav-text">小内存(small_class)分配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#大内存-large-class-分配"><span class="nav-number">8.2.2.</span> <span class="nav-text">大内存(large_class)分配</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内存释放（free）"><span class="nav-number">8.3.</span> <span class="nav-text">内存释放（free）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#小内存释放"><span class="nav-number">8.3.1.</span> <span class="nav-text">小内存释放</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#大内存释放"><span class="nav-number">8.3.2.</span> <span class="nav-text">大内存释放</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内存再分配（realloc）"><span class="nav-number">8.4.</span> <span class="nav-text">内存再分配（realloc）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#小内存再分配"><span class="nav-number">8.4.1.</span> <span class="nav-text">小内存再分配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#大内存再分配"><span class="nav-number">8.4.2.</span> <span class="nav-text">大内存再分配</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内存-GC"><span class="nav-number">8.5.</span> <span class="nav-text">内存 GC</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#tcache-GC"><span class="nav-number">8.5.1.</span> <span class="nav-text">tcache GC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#extent-GC"><span class="nav-number">8.5.2.</span> <span class="nav-text">extent GC</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>
  <div id="DvelopmentTarget">     
  </div>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart" aria-hidden="false"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>

  
</div>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_uv"> 
  本站访客数<span id="busuanzi_value_site_uv"></span>人次
</span>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  


  

  


  <script type="text/javascript" src="/js/src/love.js"></script>

</body>
</html>
