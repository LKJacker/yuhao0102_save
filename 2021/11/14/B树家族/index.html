<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zn-ch">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-center-simple.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="算法,">










<meta name="description" content="二叉树 所有非叶子结点至多拥有两个儿子（Left和Right）； 所有结点存储一个关键字； 非叶子结点的左指针指向小于其关键字的子树，右指针指向大于其关键字的子树；  二叉树的搜索，从根结点开始，如果查询的关键字与结点的关键字相等，那么就命中；否则，如果查询关键字比结点关键字小，就进入左儿子；如果比结点关键字大，就进入右儿子；如果左儿子或右儿子的指针为空，则报告找不到相应的关键字；如果二叉树的所有">
<meta name="keywords" content="算法">
<meta property="og:type" content="article">
<meta property="og:title" content="B树家族">
<meta property="og:url" content="http://yoursite.com/2021/11/14/B树家族/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="二叉树 所有非叶子结点至多拥有两个儿子（Left和Right）； 所有结点存储一个关键字； 非叶子结点的左指针指向小于其关键字的子树，右指针指向大于其关键字的子树；  二叉树的搜索，从根结点开始，如果查询的关键字与结点的关键字相等，那么就命中；否则，如果查询关键字比结点关键字小，就进入左儿子；如果比结点关键字大，就进入右儿子；如果左儿子或右儿子的指针为空，则报告找不到相应的关键字；如果二叉树的所有">
<meta property="og:locale" content="zn-ch">
<meta property="og:image" content="http://yoursite.com/img/20211114005300.jpg">
<meta property="og:image" content="http://yoursite.com/img/20211114005301.jpg">
<meta property="og:image" content="http://yoursite.com/img/5959612-b81be8294621eb26.webp">
<meta property="og:image" content="http://yoursite.com/img/5959612-c11df32046f7c405.webp">
<meta property="og:image" content="http://yoursite.com/img/5959612-c347422b9a94f5bb.webp">
<meta property="og:image" content="http://yoursite.com/img/5959612-b979b0489ef0a576.webp">
<meta property="og:image" content="http://yoursite.com/img/5959612-d9cc5aa6b00fae0d.webp">
<meta property="og:image" content="http://yoursite.com/img/5959612-82ca66cb555eeaa6.webp">
<meta property="og:image" content="http://yoursite.com/img/5959612-3d9383c247d3112b.webp">
<meta property="og:image" content="http://yoursite.com/img/5959612-0ecb25e96e2f6210.webp">
<meta property="og:image" content="http://yoursite.com/img/20211114005302.jpg">
<meta property="og:image" content="http://yoursite.com/img/20211114005306.jpg">
<meta property="og:image" content="http://yoursite.com/img/20211114005307.jpg">
<meta property="og:image" content="http://yoursite.com/img/20211114005308.jpg">
<meta property="og:image" content="http://yoursite.com/img/20211114005309.jpg">
<meta property="og:image" content="http://yoursite.com/img/20211114005310.jpg">
<meta property="og:image" content="http://yoursite.com/img/20211114005311.jpg">
<meta property="og:image" content="http://yoursite.com/img/20211114005312.jpg">
<meta property="og:image" content="http://yoursite.com/img/20211114005313.jpg">
<meta property="og:image" content="http://yoursite.com/img/20211114005314.jpg">
<meta property="og:image" content="http://yoursite.com/img/20211114005315.jpg">
<meta property="og:image" content="http://yoursite.com/img/20211114005316.jpg">
<meta property="og:image" content="http://yoursite.com/img/20211114005317.jpg">
<meta property="og:image" content="http://yoursite.com/img/20211114005318.jpg">
<meta property="og:image" content="http://yoursite.com/img/20211114005319.jpg">
<meta property="og:image" content="http://yoursite.com/img/20211114005320.jpg">
<meta property="og:image" content="http://yoursite.com/img/20211114005321.jpg">
<meta property="og:image" content="http://yoursite.com/img/20211114005322.jpg">
<meta property="og:image" content="http://yoursite.com/img/20211114005303.jpg">
<meta property="og:image" content="http://yoursite.com/img/20211114005323.jpg">
<meta property="og:image" content="http://yoursite.com/img/20211114005305.jpg">
<meta property="og:image" content="http://yoursite.com/img/20211114005324.jpg">
<meta property="og:updated_time" content="2021-11-14T03:37:54.934Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="B树家族">
<meta name="twitter:description" content="二叉树 所有非叶子结点至多拥有两个儿子（Left和Right）； 所有结点存储一个关键字； 非叶子结点的左指针指向小于其关键字的子树，右指针指向大于其关键字的子树；  二叉树的搜索，从根结点开始，如果查询的关键字与结点的关键字相等，那么就命中；否则，如果查询关键字比结点关键字小，就进入左儿子；如果比结点关键字大，就进入右儿子；如果左儿子或右儿子的指针为空，则报告找不到相应的关键字；如果二叉树的所有">
<meta name="twitter:image" content="http://yoursite.com/img/20211114005300.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2021/11/14/B树家族/">





  <title>B树家族 | Hao Yu's blog</title>
  








 
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zn-ch">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hao Yu's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">The program monkey was eaten by the siege lion.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/resume.pdf" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-mybetterhalf">
          <a href="/mybetterhalf/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>
            
            mybetterhalf
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/11/14/B树家族/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">B树家族</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-11-14T00:50:00+08:00">
                2021-11-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><ol>
<li>所有非叶子结点至多拥有两个儿子（Left和Right）；</li>
<li>所有结点存储一个关键字；</li>
<li>非叶子结点的左指针指向小于其关键字的子树，右指针指向大于其关键字的子树；</li>
</ol>
<p>二叉树的搜索，从根结点开始，如果查询的关键字与结点的关键字相等，那么就命中；否则，如果查询关键字比结点关键字小，就进入左儿子；如果比结点关键字大，就进入右儿子；如果左儿子或右儿子的指针为空，则报告找不到相应的关键字；如果二叉树的所有非叶子结点的左右子树的结点数目均保持差不多（平衡），那么二叉树的搜索性能逼近二分查找；但它比连续内存空间的二分查找的优点是，改变二叉树结构（插入与删除结点）不需要移动大段的内存数据，甚至通常是常数开销；</p>
<p><img src="/img/20211114005300.jpg" alt></p>
<p>但二叉树在经过多次插入与删除后，有可能导致不同的结构：<br><img src="/img/20211114005301.jpg" alt></p>
<p>右边也是一个二叉树，但它的搜索性能已经是线性的了；同样的关键字集合有可能导致不同的树结构索引；所以，使用二叉树还要考虑尽可能让二叉树保持左图的结构，和避免右图的结构，也就是所谓的“平衡”问题；实际使用的二叉树都是在原二叉树的基础上加上平衡算法，即“平衡二叉树”；如何保持二叉树结点分布均匀的平衡算法是平衡二叉树的关键；平衡算法是一种在二叉树中插入和删除结点的策略。</p>
<h1 id="B-树"><a href="#B-树" class="headerlink" title="B-树"></a>B-树</h1><p>定义：B-树是一类树，包括B-树、B+树、B*树等，是一棵自平衡的搜索树，它类似普通的平衡二叉树，不同的一点是B-树允许每个节点有更多的子节点。</p>
<p>一个 m 阶的B树满足以下条件：</p>
<ul>
<li>每个结点至多拥有m棵子树；</li>
<li>根结点至少拥有两颗子树（存在子树的情况下）；</li>
<li>除了根结点以外，其余每个分支结点至少拥有 m/2 棵子树；</li>
<li>所有的叶结点都在同一层上；</li>
<li>有 k 棵子树的分支结点则存在 k-1 个关键码，关键码按照递增次序进行排列；</li>
<li>关键字数量需要满足ceil(m/2)-1 &lt;= n &lt;= m-1；</li>
</ul>
<p><img src="/img/5959612-b81be8294621eb26.webp" alt></p>
<p>B树上大部分的操作所需要的磁盘存取次数和B树的高度是成正比的，在B树中可以检查多个子结点，由于在一棵树中检查任意一个结点都需要一次磁盘访问，所以B树避免了大量的磁盘访问。</p>
<p>B-树是专门为外部存储器设计的，如磁盘，它对于读取和写入大块数据有良好的性能，所以一般被用在文件系统及数据库中。</p>
<p>定义只需要知道B-树允许每个节点有更多的子节点即可（多叉树）。子节点数量一般在上千，具体数量依赖外部存储器的特性。</p>
<p>先来看看为什么会出现B-树这类数据结构。</p>
<p>传统用来搜索的平衡二叉树有很多，如 AVL 树，红黑树等。这些树在一般情况下查询性能非常好，但当数据非常大的时候它们就无能为力了。原因当数据量非常大时，内存不够用，大部分数据只能存放在磁盘上，只有需要的数据才加载到内存中。一般而言内存访问的时间约为 50 ns，而磁盘在 10 ms 左右。速度相差了近 5 个数量级，磁盘读取时间远远超过了数据在内存中比较的时间。这说明程序大部分时间会阻塞在磁盘 IO 上。那么我们如何提高程序性能？减少磁盘 IO 次数，像 AVL 树，红黑树这类平衡二叉树从设计上无法“迎合”磁盘。</p>
<p>平衡二叉树是通过旋转来保持平衡的，而旋转是对整棵树的操作，若部分加载到内存中则无法完成旋转操作。其次平衡二叉树的高度相对较大为 log n（底数为2），这样逻辑上很近的节点实际可能非常远，无法很好的利用磁盘预读（局部性原理），所以这类平衡二叉树在数据库和文件系统上的选择就被 pass 了。</p>
<p>空间局部性原理：如果一个存储器的某个位置被访问，那么将它附近的位置也会被访问。</p>
<p>我们从“迎合”磁盘的角度来看看B-树的设计。</p>
<p>索引的效率依赖与磁盘 IO 的次数，快速索引需要有效的减少磁盘 IO 次数，如何快速索引呢？索引的原理其实是不断的缩小查找范围，就如我们平时用字典查单词一样，先找首字母缩小范围，再第二个字母等等。平衡二叉树是每次将范围分割为两个区间。为了更快，B-树每次将范围分割为多个区间，区间越多，定位数据越快越精确。那么如果节点为区间范围，每个节点就较大了。所以新建节点时，直接申请页大小的空间（磁盘存储单位是按 block 分的，一般为 512 Byte。磁盘 IO 一次读取若干个 block，我们称为一页，具体大小和操作系统有关，一般为 4 k，8 k或 16 k），计算机内存分配是按页对齐的，这样就实现了一个节点只需要一次 IO。</p>
<p>多叉的好处非常明显，有效的降低了B-树的高度，为底数很大的 log n，底数大小与节点的子节点数目有关，一般一棵B-树的高度在 3 层左右。层数低，每个节点区确定的范围更精确，范围缩小的速度越快（比二叉树深层次的搜索肯定快很多）。上面说了一个节点需要进行一次 IO，那么总 IO 的次数就缩减为了 log n 次。B-树的每个节点是 n 个有序的序列(a1,a2,a3…an)，并将该节点的子节点分割成 n+1 个区间来进行索引(X1&lt; a1, a2 &lt; X2 &lt; a3, … , an+1 &lt; Xn &lt; anXn+1 &gt; an)。</p>
<p>点评：B树的每个节点，都是存多个值的，不像二叉树那样，一个节点就一个值，B树把每个节点都给了一点的范围区间，区间更多的情况下，搜索也就更快了，比如：有1-100个数，二叉树一次只能分两个范围，0-50和51-100，而B树，分成4个范围 1-25， 25-50，51-75，76-100一次就能筛选走四分之三的数据。所以作为多叉树的B树是更快的。</p>
<h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>新结点一般插在第h层，通过搜索找到对应的结点进行插入，那么根据即将插入的结点的数量又分为下面几种情况。</p>
<p>如果该结点的关键字个数没有到达m-1个，那么直接插入即可；</p>
<p>如果该结点的关键字个数已经到达了m-1个，那么根据B树的性质显然无法满足，需要将其进行分裂。分裂的规则是该结点分成两半，将中间的关键字进行提升，加入到父亲结点中，但是这又可能存在父亲结点也满员的情况，则不得不向上进行回溯，甚至是要对根结点进行分裂，那么整棵树都加了一层。</p>
<p>其过程如下：<br><img src="/img/5959612-c11df32046f7c405.webp" alt></p>
<p><img src="/img/5959612-c347422b9a94f5bb.webp" alt></p>
<p><img src="/img/5959612-b979b0489ef0a576.webp" alt></p>
<p><img src="/img/5959612-d9cc5aa6b00fae0d.webp" alt></p>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>同样的，我们需要先通过搜索找到相应的值，存在则进行删除，需要考虑删除以后的情况，</p>
<ul>
<li>如果该结点拥有关键字数量仍然满足B树性质，则不做任何处理；</li>
<li>如果该结点在删除关键字以后不满足B树的性质（关键字没有到达ceil(m/2)-1的数量），则需要向兄弟结点借关键字，这有分为兄弟结点的关键字数量是否足够的情况。</li>
<li>如果兄弟结点的关键字足够借给该结点，则过程为将父亲结点的关键字下移，兄弟结点的关键字上移；</li>
<li>如果兄弟结点的关键字在借出去以后也无法满足情况，即之前兄弟结点的关键字的数量为ceil(m/2)-1，借的一方的关键字数量为ceil(m/2)-2的情况，那么我们可以将该结点合并到兄弟结点中，合并之后的子结点数量少了一个，则需要将父亲结点的关键字下放，如果父亲结点不满足性质，则向上回溯；</li>
<li>其余情况参照BST中的删除。</li>
</ul>
<p>其过程如下：<br><img src="/img/5959612-82ca66cb555eeaa6.webp" alt></p>
<p><img src="/img/5959612-3d9383c247d3112b.webp" alt></p>
<p><img src="/img/5959612-0ecb25e96e2f6210.webp" alt></p>
<p>B-树是一种多路搜索树（并不是二叉的）：</p>
<ol>
<li>定义任意非叶子结点最多只有M个儿子；且M&gt;2；</li>
<li>根结点的儿子数为[2, M]；</li>
<li>除根结点以外的非叶子结点的儿子数为[M/2, M]；</li>
<li>每个结点存放至少M/2-1（取上整）和至多M-1个关键字；（至少2个关键字）</li>
<li>非叶子结点的关键字个数=指向儿子的指针个数-1；</li>
<li>非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] &lt; K[i+1]；</li>
<li>非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树；</li>
<li>所有叶子结点位于同一层；</li>
</ol>
<p>如：（M=3）<br><img src="/img/20211114005302.jpg" alt></p>
<p>来模拟下查找文件29的过程：</p>
<ol>
<li>根据根结点指针找到文件目录的根磁盘块1，将其中的信息导入内存。【磁盘IO操作1次】</li>
<li>此时内存中有两个文件名17，35和三个存储其他磁盘页面地址的数据。根据算法我们发现17&lt;29&lt;35，因此我们找到指针p2。</li>
<li>根据p2指针，我们定位到磁盘块3，并将其中的信息导入内存。【磁盘IO操作2次】</li>
<li>此时内存中有两个文件名26，30和三个存储其他磁盘页面地址的数据。根据算法我们发现26&lt;29&lt;30，因此我们找到指针p2。</li>
<li>根据p2指针，我们定位到磁盘块8，并将其中的信息导入内存。【磁盘IO操作3次】</li>
<li>此时内存中有两个文件名28，29。根据算法我们查找到文件29，并定位了该文件内存的磁盘地址。</li>
</ol>
<p>生成从空树开始，逐个插入关键字。但是由于B-树节点关键字必须大于等于<code>[ceil(m/2)-1]</code>，所以每次插入一个关键字不是在树中添加一个叶子结点，而是首先在最底层的某个非终端节点中添加一个“关键字”，该结点的关键字不超过m-1，则插入完成；否则要产生结点的“分裂”，将一半数量的关键字元素分裂到新的其相邻右结点中，中间关键字元素上移到父结点中。</p>
<p>1、咱们通过一个实例来逐步讲解下。插入以下字符字母到一棵空的B 树中（非根结点关键字数小了（小于2个）就合并，大了（超过4个）就分裂）：C N G A H E K Q M F W L T Z D P R X Y S，首先，结点空间足够，4个字母插入相同的结点中，如下图：<br><img src="/img/20211114005306.jpg" alt></p>
<p>2、当咱们试着插入H时，结点发现空间不够，以致将其分裂成2个结点，移动中间元素G上移到新的根结点中，在实现过程中，咱们把A和C留在当前结点中，而H和N放置新的其右邻居结点中。如下图：<br><img src="/img/20211114005307.jpg" alt></p>
<p>3、当咱们插入E,K,Q时，不需要任何分裂操作<br><img src="/img/20211114005308.jpg" alt></p>
<p>4、插入M需要一次分裂，注意M恰好是中间关键字元素，以致向上移到父节点中<br><img src="/img/20211114005309.jpg" alt></p>
<p>5、插入F,W,L,T不需要任何分裂操作<br><img src="/img/20211114005310.jpg" alt></p>
<p>6、插入Z时，最右的叶子结点空间满了，需要进行分裂操作，中间元素T上移到父节点中，注意通过上移中间元素，树最终还是保持平衡，分裂结果的结点存在2个关键字元素。<br><img src="/img/20211114005311.jpg" alt></p>
<p>7、插入D时，导致最左边的叶子结点被分裂，D恰好也是中间元素，上移到父节点中，然后字母P,R,X,Y陆续插入不需要任何分裂操作（别忘了，树中至多5个孩子）。<br><img src="/img/20211114005312.jpg" alt></p>
<p>8、最后，当插入S时，含有N,P,Q,R的结点需要分裂，把中间元素Q上移到父节点中，但是情况来了，父节点中空间已经满了，所以也要进行分裂，将父节点中的中间元素M上移到新形成的根结点中，注意以前在父节点中的第三个指针在修改后包括D和G节点中。这样具体插入操作的完成。<br><img src="/img/20211114005313.jpg" alt></p>
<h2 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h2><p>首先查找B树中需删除的元素,如果该元素在B树中存在，则将该元素在其结点中进行删除，如果删除该元素后，首先判断该元素是否有左右孩子结点，如果有，则上移孩子结点中的某相近元素到父节点中，然后是移动之后的情况；如果没有，直接删除后，移动之后的情况。</p>
<p>删除元素，移动相应元素之后，如果某结点中元素数目（即关键字数）小于<code>ceil(m/2)-1</code>，则需要看其某相邻兄弟结点是否丰满（结点中元素个数大于<code>ceil(m/2)-1)</code>（还记得第一节中关于B树的第5个特性中的c点么?：c)除根结点之外的结点（包括叶子结点）的关键字的个数n必须满足：<code>(ceil(m / 2)-1) &lt;= n &lt;= m-1</code>。m表示最多含有m个孩子，n表示关键字数。在本小节中举的一颗B树的示例中，关键字数n满足：<code>2&lt;=n&lt;=4</code>），如果丰满，则向父节点借一个元素来满足条件；如果其相邻兄弟都刚脱贫，即借了之后其结点数目小于<code>ceil(m/2)-1</code>，则该结点与其相邻的某一兄弟结点进行“合并”成一个结点，以此来满足条件。那咱们通过下面实例来详细了解吧。</p>
<p>以上述插入操作构造的一棵5阶B树（树中最多含有m（m=5）个孩子，因此关键字数最小为ceil(m / 2)-1=2。还是这句话，关键字数小了（小于2个）就合并，大了（超过4个）就分裂）为例，依次删除H,T,R,E。</p>
<p><img src="/img/20211114005314.jpg" alt></p>
<p>1、首先删除元素H，当然首先查找H，H在一个叶子结点中，且该叶子结点元素数目3大于最小元素数目ceil(m/2)-1=2，则操作很简单，咱们只需要移动K至原来H的位置，移动L至K的位置（也就是结点中删除元素后面的元素向前移动）<br><img src="/img/20211114005315.jpg" alt></p>
<p>2、下一步，删除T,因为T没有在叶子结点中，而是在中间结点中找到，咱们发现他的继承者W(字母升序的下个元素)，将W上移到T的位置，然后将原包含W的孩子结点中的W进行删除，这里恰好删除W后，该孩子结点中元素个数大于2，无需进行合并操作。<br><img src="/img/20211114005316.jpg" alt></p>
<p>3、下一步删除R，R在叶子结点中，但是该结点中元素数目为2，删除导致只有1个元素，已经小于最小元素数目<code>ceil(5/2)-1=2</code>，而由前面我们已经知道：如果其某个相邻兄弟结点中比较丰满（元素个数大于<code>ceil(5/2)-1=2</code>），则可以向父结点借一个元素，然后将最丰满的相邻兄弟结点中上移最后或最前一个元素到父节点中（有没有看到红黑树中左旋操作的影子?），在这个实例中，右相邻兄弟结点中比较丰满（3个元素大于2），所以先向父节点借一个元素W下移到该叶子结点中，代替原来S的位置，S前移；然后X在相邻右兄弟结点中上移到父结点中，最后在相邻右兄弟结点中删除X，后面元素前移。<br><img src="/img/20211114005317.jpg" alt></p>
<p>4、最后一步删除E，删除后会导致很多问题，因为E所在的结点数目刚好达标，刚好满足最小元素个数（ceil(5/2)-1=2），而相邻的兄弟结点也是同样的情况，删除一个元素都不能满足条件，所以需要该节点与某相邻兄弟结点进行合并操作；首先移动父结点中的元素（该元素在两个需要合并的两个结点元素之间）下移到其子结点中，然后将这两个结点进行合并成一个结点。所以在该实例中，咱们首先将父节点中的元素D下移到已经删除E而只有F的结点中，然后将含有D和F的结点和含有A,C的相邻兄弟结点进行合并成一个结点。<br><img src="/img/20211114005318.jpg" alt></p>
<p>5、也许你认为这样删除操作已经结束了，其实不然，在看看上图，对于这种特殊情况，你立即会发现父节点只包含一个元素G，没达标（因为非根节点包括叶子结点的关键字数n必须满足于<code>2=&lt;n&lt;=4</code>，而此处的n=1），这是不能够接受的。如果这个问题结点的相邻兄弟比较丰满，则可以向父结点借一个元素。假设这时右兄弟结点（含有Q,X）有一个以上的元素（Q右边还有元素），然后咱们将M下移到元素很少的子结点中，将Q上移到M的位置，这时，Q的左子树将变成M的右子树，也就是含有N，P结点被依附在M的右指针上。所以在这个实例中，咱们没有办法去借一个元素，只能与兄弟结点进行合并成一个结点，而根结点中的唯一元素M下移到子结点，这样，树的高度减少一层。<br><img src="/img/20211114005319.jpg" alt></p>
<p>为了进一步详细讨论删除的情况，再举另外一个实例：这里是一棵不同的5序B树，那咱们试着删除C<br><img src="/img/20211114005320.jpg" alt></p>
<p>于是将删除元素C的右子结点中的D元素上移到C的位置，但是出现上移元素后，只有一个元素的结点的情况。</p>
<p>又因为含有E的结点，其相邻兄弟结点才刚脱贫（最少元素个数为2），不可能向父节点借元素，所以只能进行合并操作，于是这里将含有A,B的左兄弟结点和含有E的结点进行合并成一个结点。<br><img src="/img/20211114005321.jpg" alt></p>
<p>这样又出现只含有一个元素F结点的情况，这时，其相邻的兄弟结点是丰满的（元素个数为3&gt;最小元素个数2），这样就可以想父结点借元素了，把父结点中的J下移到该结点中，相应的如果结点中J后有元素则前移，然后相邻兄弟结点中的第一个元素（或者最后一个元素）上移到父节点中，后面的元素（或者前面的元素）前移（或者后移）；注意含有K，L的结点以前依附在M的左边，现在变为依附在J的右边。这样每个结点都满足B树结构性质。<br><img src="/img/20211114005322.jpg" alt></p>
<p>从以上操作可看出：除根结点之外的结点（包括叶子结点）的关键字的个数n满足：<code>(ceil(m / 2)-1) &lt;= n &lt;= m-1</code>，即2&lt;=n&lt;=4。这也佐证了咱们之前的观点。删除操作完。</p>
<p>B-树的搜索，从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点；</p>
<p>B-树的特性：</p>
<ol>
<li>关键字集合分布在整颗树中；</li>
<li>任何一个关键字出现且只出现在一个结点中；</li>
<li>搜索有可能在非叶子结点结束；</li>
<li>其搜索性能等价于在关键字全集内做一次二分查找；</li>
<li>自动层次控制；</li>
</ol>
<p>由于限制了除根结点以外的非叶子结点，至少含有M/2个儿子，确保了结点的至少利用率，其最底搜索性能为：<br><img src="/img/20211114005303.jpg" alt></p>
<p>其中，M为设定的非叶子结点最多子树个数，N为关键字总数；所以B-树的性能总是等价于二分查找（与M值无关），也就没有B树平衡的问题；由于M/2的限制，在插入结点时，如果结点已满，需要将结点分裂为两个各占M/2的结点；删除结点时，需将两个不足M/2的兄弟结点合并；</p>
<h1 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B+树"></a>B+树</h1><p>B+树是B-树的变体，也是一种多路搜索树：</p>
<ol>
<li>其定义基本与B-树同，除了：</li>
<li>非叶子结点的子树指针与关键字个数相同；</li>
<li>非叶子结点的子树指针P[i]，指向关键字值属于[K[i], K[i+1])的子树（B-树是开区间）；</li>
<li>为所有叶子结点增加一个链指针；</li>
<li>所有关键字都在叶子结点出现；</li>
</ol>
<p><img src="/img/20211114005323.jpg" alt></p>
<p>B+的搜索与B-树也基本相同，区别是B+树只有达到叶子结点才命中（B-树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找。B+树的主要优点：非终端结点仅仅起高层索引作用，而B树非终端结点的关键字除作子树分界外，本身还是实际记录的有效关键字（含记录指针），因此相同的结点空间，B+树可以设计的阶树比B树大，相同的索引，B+树的索引层数比B树少，因此检索速度比B树快。此外，B+树叶子结点包含完整的索引信息，可以较方便地表示文件的稀疏索引。最后，B+树的检索、插入和删除都在叶子结点进行，比B树相对简单。</p>
<p>B+的特性：</p>
<ol>
<li>所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的；</li>
<li>不可能在非叶子结点命中；</li>
<li>非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层；</li>
<li>更适合文件索引系统；</li>
</ol>
<p>B树和B+树的区别是由于B+树和B具有这不同的存储结构所造成的区别，以一个m阶树为例。</p>
<ul>
<li>关键字的数量不同；B+树中分支结点有m个关键字，其叶子结点也有m个，其关键字只是起到了一个索引的作用，但是B树虽然也有m个子结点，但是其只拥有m-1个关键字。</li>
<li>存储的位置不同；B+树中的数据都存储在叶子结点上，也就是其所有叶子结点的数据组合起来就是完整的数据，但是B树的数据存储在每一个结点中，并不仅仅存储在叶子结点上。</li>
<li>分支结点的构造不同；B+树的分支结点仅仅存储着关键字信息和儿子的指针（这里的指针指的是磁盘块的偏移量），也就是说内部结点仅仅包含着索引信息。</li>
<li>查询不同；B树在找到具体的数值以后，则结束，而B+树则需要通过索引找到叶子结点中的数据才结束，也就是说B+树的搜索过程中走了一条从根结点到叶子结点的路径。</li>
</ul>
<h1 id="B-树-2"><a href="#B-树-2" class="headerlink" title="B*树"></a>B*树</h1><p>是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针；<br><img src="/img/20211114005305.jpg" alt></p>
<p><code>B*</code>树定义了非叶子结点关键字个数至少为(2/3)*M，即块的最低使用率为2/3（代替B+树的1/2）；</p>
<p>B+树的分裂：当一个结点满时，分配一个新的结点，并将原结点中1/2的数据复制到新结点，最后在父结点中增加新结点的指针；B+树的分裂只影响原结点和父结点，而不会影响兄弟结点，所以它不需要指向兄弟的指针；</p>
<p><code>B*</code>树的分裂：当一个结点满时，如果它的下一个兄弟结点未满，那么将一部分数据移到兄弟结点中，再在原结点插入关键字，最后修改父结点中兄弟结点的关键字（因为兄弟结点的关键字范围改变了）；如果兄弟也满了，则在原结点与兄弟结点之间增加新结点，并各复制1/3的数据到新结点，最后在父结点增加新结点的指针；</p>
<p>所以，B*树分配新结点的概率比B+树要低，空间使用率更高；</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>根据B树的特点，我们首先可以写出B树的整体的结构。</p>
<h2 id="B树结构"><a href="#B树结构" class="headerlink" title="B树结构"></a>B树结构</h2><p>B树的结构我们定义需要参考规则，我们首先是需要给出保存键值的一个数组，这个数组的大小取决与我们定义的M，然后我们根据规则，可以得到一个保存M+1个子的一个数组，然后当然为了方便访问，parent指针，然后要有一个记录每个节点中键值个数的一个size。</p>
<p>所以定义如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K,<span class="keyword">int</span> M&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BTreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    K _keys[M];                     <span class="comment">//用来保存键值。</span></span><br><span class="line">    BTreeNode&lt;K, M&gt;* _sub[M + <span class="number">1</span>];   <span class="comment">//用来保存子。</span></span><br><span class="line">    BTreeNode&lt;K, M&gt;* _parent;</span><br><span class="line">    <span class="keyword">size_t</span> _size;</span><br><span class="line">    BTreeNode()</span><br><span class="line">        :_parent(<span class="literal">NULL</span>)</span><br><span class="line">        , _size(<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; M; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            _keys[i] = K();</span><br><span class="line">            _sub[i] = K();</span><br><span class="line">        &#125;</span><br><span class="line">        _sub[i] = K();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="B树的查找"><a href="#B树的查找" class="headerlink" title="B树的查找"></a>B树的查找</h2><p>对于AVL，BST，红黑树，B树这些高级的数据结构而言，查找算法是非常重要的。我们首先确定返回值，对于这种关于key和key-value的数据结构，参考map和set，我们让它返回一个pair的一个结构体。</p>
<p>pair结构体的定义在std中是<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> K,<span class="keyword">typename</span> V&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pair</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    K key;</span><br><span class="line">    V value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们只需要让这个里面的value变为bool值，value返回以后说明的是存不存就可以了。</p>
<p>接下来的思路就是从根节点进行和这个节点当中的每一个key比较，如果=那么就返回找到了，如果小于，那么就到这个节点左面的子节点中找，如果大了，就继续向后面的键值进行查找。如果相等那么就返回。</p>
<p>示例代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">pair &lt;Node*, <span class="keyword">int</span>&gt; Find(<span class="keyword">const</span> K &amp;key)</span><br><span class="line">    &#123;</span><br><span class="line">        Node* cur = _root;</span><br><span class="line">        Node* parent = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">size_t</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; cur-&gt;_size)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//如果小于当前，向后</span></span><br><span class="line">                <span class="keyword">if</span> (cur-&gt;_keys[i] &lt; key)</span><br><span class="line">                &#123;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果大于，</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (cur-&gt;_keys[i]&gt;key)</span><br><span class="line">                &#123;</span><br><span class="line">                    cur = cur-&gt;_sub[i];</span><br><span class="line">                    parent = cur;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//相等，返回这个节点</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> pair&lt;Node *, <span class="keyword">int</span>&gt;(<span class="literal">NULL</span>, <span class="number">-1</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (key &gt; cur-&gt;_sub[i + <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                cur = cur-&gt;_sub[i];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//为了防止出现我返回空指针操作，如果是空指针，那么就返回父亲</span></span><br><span class="line">            <span class="keyword">if</span> (cur != <span class="literal">NULL</span> &amp;&amp; i == cur-&gt;_size)</span><br><span class="line">            &#123;</span><br><span class="line">                parent = cur;</span><br><span class="line">                cur = cur-&gt;_sub[i];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pair&lt;Node *, <span class="keyword">int</span>&gt;(parent, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="B树的插入"><a href="#B树的插入" class="headerlink" title="B树的插入"></a>B树的插入</h2><p><img src="/img/20211114005324.jpg" alt></p>
<p>示例代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Insert</span><span class="params">(<span class="keyword">const</span> K &amp;key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//首先来考虑空树的情况</span></span><br><span class="line">    <span class="keyword">if</span> (_root == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//给这个节点中添加key，并且让size++。</span></span><br><span class="line">        _root = <span class="keyword">new</span> Node;</span><br><span class="line">        _root-&gt;_keys[<span class="number">0</span>] = key;</span><br><span class="line">        _root-&gt;_size++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//使用通用的key-value结构体来保存找到的key所在的节点。</span></span><br><span class="line"></span><br><span class="line">    pair&lt;Node*,<span class="keyword">int</span> &gt; ret=Find(key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在这里来看这个节点是否存在，存在就直接return false。</span></span><br><span class="line">    <span class="keyword">if</span> (ret.second == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node* cur = ret.first;</span><br><span class="line">    K newKey = key;</span><br><span class="line">    Node *sub = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//此时表示考虑插入。</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//向cur里面进行插入，如果没满插入，满了就进行分裂。</span></span><br><span class="line">        InsetKey(cur, newKey, sub);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//小于M，这样就可以直接插入</span></span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;_size &lt; M)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果==M，那么就应该进行分裂</span></span><br><span class="line">        <span class="comment">//首先找到中间的节点</span></span><br><span class="line">        <span class="keyword">size_t</span> mid = cur-&gt;_size / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//创建一个节点，用来保存中间节点右边所有的节点和子节点。</span></span><br><span class="line">        Node * tmp = <span class="keyword">new</span> Node;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">size_t</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//进行移动sub以及所有的子接点。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = mid + <span class="number">1</span>; i &lt; cur-&gt;_size; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp-&gt;_keys[j] = cur-&gt;_keys[i];</span><br><span class="line">            cur-&gt;_keys[i] = K();</span><br><span class="line">            cur-&gt;_size--;</span><br><span class="line">            tmp-&gt;_size++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//移动子串</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; tmp-&gt;_size + <span class="number">1</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp-&gt;_sub[j] = cur-&gt;_sub[mid + <span class="number">1</span> + j];</span><br><span class="line">            <span class="keyword">if</span> (tmp-&gt;_sub[j])</span><br><span class="line">            &#123;</span><br><span class="line">                tmp-&gt;_sub[j]-&gt;_parent = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            cur-&gt;_sub[mid + <span class="number">1</span> + j] = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//进行其他的移动</span></span><br><span class="line">        <span class="comment">//分裂的条件就是要么分裂根，要么就是分裂子节点，要么就是所在节点的节点数小于M。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//考虑根分裂，分裂的时候创建节点，然后把中间节点上拉，记得要更改最后的parent</span></span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;_parent == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            _root = <span class="keyword">new</span> Node();</span><br><span class="line">            _root-&gt;_keys[<span class="number">0</span>] = cur-&gt;_keys[mid];</span><br><span class="line">            cur-&gt;_keys[mid] = K();</span><br><span class="line">            cur-&gt;_size--;</span><br><span class="line">            _root-&gt;_size++;</span><br><span class="line"></span><br><span class="line">            _root-&gt;_sub[<span class="number">0</span>] = cur;</span><br><span class="line">            cur-&gt;_parent = _root;</span><br><span class="line"></span><br><span class="line">            _root-&gt;_sub[<span class="number">1</span>] = tmp;</span><br><span class="line">            tmp-&gt;_parent = _root;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//分裂如果不是根节点，那么就把mid节点插入到上一层节点中，然后看上一层节点是否要分裂。注意修改cur和sub</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            newKey = cur-&gt;_keys[mid];</span><br><span class="line">            cur-&gt;_keys[mid] = K();</span><br><span class="line">            cur-&gt;_size--;</span><br><span class="line">            cur = cur-&gt;_parent;</span><br><span class="line"></span><br><span class="line">            sub = tmp;</span><br><span class="line">            sub-&gt;_parent = cur;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsetKey</span><span class="params">(Node* cur, <span class="keyword">const</span> K &amp;key, Node* sub)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = cur-&gt;_size - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i&gt;=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//进行插入</span></span><br><span class="line">        <span class="keyword">if</span> (key &gt; cur-&gt;_keys[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//进行移动</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cur-&gt;_keys[i + <span class="number">1</span>] = cur-&gt;_keys[i];</span><br><span class="line">            cur-&gt;_sub[i + <span class="number">2</span>] = cur-&gt;_sub[i + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        i--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//进行插入</span></span><br><span class="line">    cur-&gt;_keys[i + <span class="number">1</span>] = key;</span><br><span class="line">    <span class="comment">//插入子</span></span><br><span class="line">    cur-&gt;_sub[i + <span class="number">2</span>] = sub;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果没满，只需要对size++；</span></span><br><span class="line">    <span class="keyword">if</span> (cur-&gt;_size &lt; M)</span><br><span class="line">    &#123;</span><br><span class="line">        cur-&gt;_size++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/算法/" rel="tag"># 算法</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/11/13/平衡二叉树详解/" rel="next" title="平衡二叉树详解">
                <i class="fa fa-chevron-left"></i> 平衡二叉树详解
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/11/14/多叉树家族/" rel="prev" title="多叉树家族及mysql中用到的B树">
                多叉树家族及mysql中用到的B树 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/header.jpg" alt="Hao Yu">
            
              <p class="site-author-name" itemprop="name">Hao Yu</p>
              <p class="site-description motion-element" itemprop="description">Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author</p>
          </div>
          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">291</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>
        	<audio controls="controls" loop="loop" preload="auto" src="/resource/xiaomeihao.mp3">
	        </audio>
	

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yuhao0102" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:yuh18@mails.tsinghua.edu.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#二叉树"><span class="nav-number">1.</span> <span class="nav-text">二叉树</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#B-树"><span class="nav-number">2.</span> <span class="nav-text">B-树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#插入"><span class="nav-number">2.1.</span> <span class="nav-text">插入</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#删除"><span class="nav-number">2.2.</span> <span class="nav-text">删除</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#删除操作"><span class="nav-number">2.3.</span> <span class="nav-text">删除操作</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#B-树-1"><span class="nav-number">3.</span> <span class="nav-text">B+树</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#B-树-2"><span class="nav-number">4.</span> <span class="nav-text">B*树</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#实现"><span class="nav-number">5.</span> <span class="nav-text">实现</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#B树结构"><span class="nav-number">5.1.</span> <span class="nav-text">B树结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#B树的查找"><span class="nav-number">5.2.</span> <span class="nav-text">B树的查找</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#B树的插入"><span class="nav-number">5.3.</span> <span class="nav-text">B树的插入</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>
  <div id="DvelopmentTarget">     
  </div>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart" aria-hidden="false"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>

  
</div>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_uv"> 
  本站访客数<span id="busuanzi_value_site_uv"></span>人次
</span>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  


  

  


  <script type="text/javascript" src="/js/src/love.js"></script>

</body>
</html>
