<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zn-ch">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-center-simple.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="算法,">










<meta name="description" content="二叉树 所有非叶子结点至多拥有两个儿子（Left和Right）； 所有结点存储一个关键字； 非叶子结点的左指针指向小于其关键字的子树，右指针指向大于其关键字的子树；  二叉树的搜索，从根结点开始，如果查询的关键字与结点的关键字相等，那么就命中；否则，如果查询关键字比结点关键字小，就进入左儿子；如果比结点关键字大，就进入右儿子；如果左儿子或右儿子的指针为空，则报告找不到相应的关键字；如果二叉树的所有">
<meta name="keywords" content="算法">
<meta property="og:type" content="article">
<meta property="og:title" content="多叉树家族及mysql中用到的B树">
<meta property="og:url" content="http://yoursite.com/2021/11/14/多叉树家族/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="二叉树 所有非叶子结点至多拥有两个儿子（Left和Right）； 所有结点存储一个关键字； 非叶子结点的左指针指向小于其关键字的子树，右指针指向大于其关键字的子树；  二叉树的搜索，从根结点开始，如果查询的关键字与结点的关键字相等，那么就命中；否则，如果查询关键字比结点关键字小，就进入左儿子；如果比结点关键字大，就进入右儿子；如果左儿子或右儿子的指针为空，则报告找不到相应的关键字；如果二叉树的所有">
<meta property="og:locale" content="zn-ch">
<meta property="og:image" content="http://yoursite.com/img/20211114005300.jpg">
<meta property="og:image" content="http://yoursite.com/img/20211114005301.jpg">
<meta property="og:image" content="http://yoursite.com/img/48e19c1215d19ce879969eaded83857a.png">
<meta property="og:image" content="http://yoursite.com/img/8a27a65b20d282c20b086d7289a5c8bc.jpg">
<meta property="og:image" content="http://yoursite.com/img/883755cf230779f56d5a0aecc6c4af8b.jpg">
<meta property="og:image" content="http://yoursite.com/img/eda14ebcb2f586f09385f18608fb7af1.png">
<meta property="og:image" content="http://yoursite.com/img/3c09f162bdd31bf42dbc3e0147813f3f.jpg">
<meta property="og:image" content="http://yoursite.com/img/b546a317a515e7af9f17750e8d39e7c3.png">
<meta property="og:image" content="http://yoursite.com/img/abccd8c302b9609b787495f0bf9bd364.png">
<meta property="og:image" content="http://yoursite.com/img/71c621876faa1e651fb3a4197a1d0c11.png">
<meta property="og:image" content="http://yoursite.com/img/48a23e1dd9c8a341741d380033ad008f.png">
<meta property="og:image" content="http://yoursite.com/img/30150a1882bfb7cf3a549be1eddc84a6.jpg">
<meta property="og:image" content="http://yoursite.com/img/17f62ec19a5985fd20373f8f76ae1938.png">
<meta property="og:image" content="http://yoursite.com/img/5d18899b2274d575830eb9608b8e0af5.jpg">
<meta property="og:image" content="http://yoursite.com/img/a1bedcc86a524ba67d5c1856e231721f.png">
<meta property="og:image" content="http://yoursite.com/img/4615e62775c541bc9e75beb2fdb25f65.png">
<meta property="og:image" content="http://yoursite.com/img/4f2a0549924de35b50f72e4f212145a0.png">
<meta property="og:image" content="http://yoursite.com/img/cb828f494ba4b69cecce89f8e5bceb20.png">
<meta property="og:image" content="http://yoursite.com/img/f5f3fd791411fbb6fb45d5d6a7612e9a.png">
<meta property="og:image" content="http://yoursite.com/img/62a98f17efedf822e68f2c1e38fc7779.png">
<meta property="og:image" content="http://yoursite.com/img/413808e1b75212f1f23a6e122897d0c5.png">
<meta property="og:image" content="http://yoursite.com/img/5959612-b81be8294621eb26.webp">
<meta property="og:image" content="http://yoursite.com/img/5959612-c11df32046f7c405.webp">
<meta property="og:image" content="http://yoursite.com/img/5959612-c347422b9a94f5bb.webp">
<meta property="og:image" content="http://yoursite.com/img/5959612-b979b0489ef0a576.webp">
<meta property="og:image" content="http://yoursite.com/img/5959612-d9cc5aa6b00fae0d.webp">
<meta property="og:image" content="http://yoursite.com/img/5959612-82ca66cb555eeaa6.webp">
<meta property="og:image" content="http://yoursite.com/img/5959612-3d9383c247d3112b.webp">
<meta property="og:image" content="http://yoursite.com/img/5959612-0ecb25e96e2f6210.webp">
<meta property="og:image" content="http://yoursite.com/img/20211114005302.jpg">
<meta property="og:image" content="http://yoursite.com/img/20211114005306.jpg">
<meta property="og:image" content="http://yoursite.com/img/20211114005307.jpg">
<meta property="og:image" content="http://yoursite.com/img/20211114005308.jpg">
<meta property="og:image" content="http://yoursite.com/img/20211114005309.jpg">
<meta property="og:image" content="http://yoursite.com/img/20211114005310.jpg">
<meta property="og:image" content="http://yoursite.com/img/20211114005311.jpg">
<meta property="og:image" content="http://yoursite.com/img/20211114005312.jpg">
<meta property="og:image" content="http://yoursite.com/img/20211114005313.jpg">
<meta property="og:image" content="http://yoursite.com/img/20211114005314.jpg">
<meta property="og:image" content="http://yoursite.com/img/20211114005315.jpg">
<meta property="og:image" content="http://yoursite.com/img/20211114005316.jpg">
<meta property="og:image" content="http://yoursite.com/img/20211114005317.jpg">
<meta property="og:image" content="http://yoursite.com/img/20211114005318.jpg">
<meta property="og:image" content="http://yoursite.com/img/20211114005319.jpg">
<meta property="og:image" content="http://yoursite.com/img/20211114005320.jpg">
<meta property="og:image" content="http://yoursite.com/img/20211114005321.jpg">
<meta property="og:image" content="http://yoursite.com/img/20211114005322.jpg">
<meta property="og:image" content="http://yoursite.com/img/20211114005303.jpg">
<meta property="og:image" content="http://yoursite.com/img/20211114005323.jpg">
<meta property="og:image" content="http://yoursite.com/img/v2-705cee41307cbf12d84d2dc9c9c1dae7_1440w.jpg">
<meta property="og:image" content="http://yoursite.com/img/v2-e623d8c85e5dde67eb9948484d4305f9_1440w.jpg">
<meta property="og:image" content="http://yoursite.com/img/v2-7a83d0068331c5fe82ae2557b97e52d8_1440w.jpg">
<meta property="og:image" content="http://yoursite.com/img/v2-8133213bd9817012f8a8e95b079c6817_1440w.jpg">
<meta property="og:image" content="http://yoursite.com/img/v2-25c1c0b8a4ea8c300e180e3d87339bfb_1440w.jpg">
<meta property="og:image" content="http://yoursite.com/img/v2-efa3f8f327b9e55930e8a772f8183ab7_1440w.jpg">
<meta property="og:image" content="http://yoursite.com/img/v2-efc68940b3f85ba0b6f6a2352df43bff_1440w.jpg">
<meta property="og:image" content="http://yoursite.com/img/v2-54282f355f16664a05863e764135ace0_1440w.jpg">
<meta property="og:image" content="http://yoursite.com/img/v2-65789684f319ca8675040ee7044e365c_1440w.jpg">
<meta property="og:image" content="http://yoursite.com/img/v2-7a83d0068331c5fe82ae2557b97e52d8_1440w.jpg">
<meta property="og:image" content="http://yoursite.com/img/v2-8133213bd9817012f8a8e95b079c6817_1440w.jpg">
<meta property="og:image" content="http://yoursite.com/img/v2-386cefe3c3c93b726387ee2abc577691_b.jpg">
<meta property="og:image" content="http://yoursite.com/img/v2-4e621ab9044dcb42643066f6031226b0_b.webp">
<meta property="og:image" content="http://yoursite.com/img/v2-467b2c27f41bad29b01be13e1e5cd1bb_b.gif">
<meta property="og:image" content="http://yoursite.com/img/v2-85fb69b1f6d5134f45808fc884ad2e4a_b.webp">
<meta property="og:image" content="http://yoursite.com/img/v2-7607b34265b14b3527101d53ce9c2b70_b.gif">
<meta property="og:image" content="http://yoursite.com/img/v2-3aee225a4ba3e3a1b428e3f30e312637_b.gif">
<meta property="og:image" content="http://yoursite.com/img/v2-8dae05b8aa006d6d1fc6bb54c24169a5_b.gif">
<meta property="og:image" content="http://yoursite.com/img/v2-909e556bc9375489e5f975f90b25dfa8_1440w.jpg">
<meta property="og:image" content="http://yoursite.com/img/v2-c33a70c8eaa38e96c3052a6bddc9d0d4_b.webp">
<meta property="og:image" content="http://yoursite.com/img/v2-ae4011609fdf74e80d10fefb9e47dbb8_b.gif">
<meta property="og:image" content="http://yoursite.com/img/20211114005305.jpg">
<meta property="og:image" content="http://yoursite.com/img/20211114005324.jpg">
<meta property="og:image" content="http://yoursite.com/img/20211114114100.png">
<meta property="og:image" content="http://yoursite.com/img/20211114114101.png">
<meta property="og:image" content="http://yoursite.com/img/20211114114102.png">
<meta property="og:image" content="http://yoursite.com/img/20211114114103.png">
<meta property="og:image" content="http://yoursite.com/img/20211114114104.png">
<meta property="og:image" content="http://yoursite.com/img/20211114114105.png">
<meta property="og:updated_time" content="2021-11-14T10:40:20.072Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="多叉树家族及mysql中用到的B树">
<meta name="twitter:description" content="二叉树 所有非叶子结点至多拥有两个儿子（Left和Right）； 所有结点存储一个关键字； 非叶子结点的左指针指向小于其关键字的子树，右指针指向大于其关键字的子树；  二叉树的搜索，从根结点开始，如果查询的关键字与结点的关键字相等，那么就命中；否则，如果查询关键字比结点关键字小，就进入左儿子；如果比结点关键字大，就进入右儿子；如果左儿子或右儿子的指针为空，则报告找不到相应的关键字；如果二叉树的所有">
<meta name="twitter:image" content="http://yoursite.com/img/20211114005300.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2021/11/14/多叉树家族/">





  <title>多叉树家族及mysql中用到的B树 | Hao Yu's blog</title>
  








 
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zn-ch">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hao Yu's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">The program monkey was eaten by the siege lion.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/resume.pdf" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-mybetterhalf">
          <a href="/mybetterhalf/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>
            
            mybetterhalf
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/11/14/多叉树家族/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">多叉树家族及mysql中用到的B树</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-11-14T00:50:00+08:00">
                2021-11-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><ol>
<li>所有非叶子结点至多拥有两个儿子（Left和Right）；</li>
<li>所有结点存储一个关键字；</li>
<li>非叶子结点的左指针指向小于其关键字的子树，右指针指向大于其关键字的子树；</li>
</ol>
<p>二叉树的搜索，从根结点开始，如果查询的关键字与结点的关键字相等，那么就命中；否则，如果查询关键字比结点关键字小，就进入左儿子；如果比结点关键字大，就进入右儿子；如果左儿子或右儿子的指针为空，则报告找不到相应的关键字；如果二叉树的所有非叶子结点的左右子树的结点数目均保持差不多（平衡），那么二叉树的搜索性能逼近二分查找；但它比连续内存空间的二分查找的优点是，改变二叉树结构（插入与删除结点）不需要移动大段的内存数据，甚至通常是常数开销；</p>
<p><img src="/img/20211114005300.jpg" alt></p>
<p>但二叉树在经过多次插入与删除后，有可能导致不同的结构：<br><img src="/img/20211114005301.jpg" alt></p>
<p>右边也是一个二叉树，但它的搜索性能已经是线性的了；同样的关键字集合有可能导致不同的树结构索引；所以，使用二叉树还要考虑尽可能让二叉树保持左图的结构，和避免右图的结构，也就是所谓的“平衡”问题；实际使用的二叉树都是在原二叉树的基础上加上平衡算法，即“平衡二叉树”；如何保持二叉树结点分布均匀的平衡算法是平衡二叉树的关键；平衡算法是一种在二叉树中插入和删除结点的策略。</p>
<h1 id="2-3-树"><a href="#2-3-树" class="headerlink" title="2-3 树"></a>2-3 树</h1><p>2-3 树的定义如下：</p>
<ol>
<li>2-3 树要么为空要么具有以下性质：</li>
<li>对于 2- 节点，和普通的 BST 节点一样，有一个数据域和两个子节点指针，两个子节点要么为空，要么也是一个2-3树，当前节点的数据的值要大于左子树中所有节点的数据，要小于右子树中所有节点的数据。</li>
<li>对于 3- 节点，有两个数据域 a 和 b 和三个子节点指针，左子树中所有的节点数据要小于a，中子树中所有节点数据要大于 a 而小于 b ，右子树中所有节点数据要大于 b 。</li>
</ol>
<p>例如图 2.1 所示的树为一棵 2-3 树：<br><img src="/img/48e19c1215d19ce879969eaded83857a.png" alt></p>
<h2 id="2-3-树性质"><a href="#2-3-树性质" class="headerlink" title="2-3 树性质"></a>2-3 树性质</h2><p>性质：</p>
<ol>
<li>对于每一个结点有 1 或者 2 个关键码。</li>
<li>当节点有一个关键码的时，节点有 2 个子树。</li>
<li>当节点有 2 个关键码时，节点有 3 个子树。</li>
<li>所有叶子点都在树的同一层。</li>
</ol>
<h2 id="2-3树查找"><a href="#2-3树查找" class="headerlink" title="2-3树查找"></a>2-3树查找</h2><p>2-3 树的查找类似二叉搜索树的查找过程，根据键值的比较来决定查找的方向。</p>
<p>例如在图 2.1 所示的 2-3 树中查找键为H的节点：<br><img src="/img/8a27a65b20d282c20b086d7289a5c8bc.jpg" alt></p>
<p>例如在图 2.1 所示的 2-3 树中查找键为 B 的节点：<br><img src="/img/883755cf230779f56d5a0aecc6c4af8b.jpg" alt></p>
<h2 id="2-3树插入"><a href="#2-3树插入" class="headerlink" title="2-3树插入"></a>2-3树插入</h2><p>在树的插入之前需要对带插入的节点进行一次查找操作，若树中已经有此节点则不予插入，若没有查找到此节点则记录未命中查找结束时访问的最后一个节点。</p>
<p>空树的插入最简单，创建一个节点即可，这里不予赘述。</p>
<p>对于非空树插入主要分为 4 种情况：</p>
<ol>
<li>向 2- 节点中插入新节点</li>
<li>向一棵只含 3- 节点的树中插入新节点</li>
<li>向一个父节点为 2- 节点的 3- 节点中插入新节点</li>
<li>向一个父节点为 3- 节点的 3- 节点中插入新节点</li>
</ol>
<p>向2-节点中插入新节点的操作步骤：如果未命中查找结束于一个 2-节点，直接将 2- 节点替换为一个 3- 节点，并将要插入的键保存在其中。</p>
<p>图解：<br><img src="/img/eda14ebcb2f586f09385f18608fb7af1.png" alt></p>
<p><img src="/img/3c09f162bdd31bf42dbc3e0147813f3f.jpg" alt></p>
<p>向一棵只含 3- 节点的树中插入新节点的操作步骤：先临时将新键存入唯一的 3- 节点中，使其成为一个 4- 节点，再将它转化为一颗由 3 个 2- 节点组成的 2-3 树，分解后树高会增加 1。</p>
<p>图解：<br><img src="/img/b546a317a515e7af9f17750e8d39e7c3.png" alt></p>
<p>向一个父节点为 2- 节点的 3- 节点中插入新节点的操作步骤：先构造一个临时的 4- 节点并将其分解，分解时将中键移动到父节点中(中键移动后，其父节点中的位置由键的大小确定)</p>
<p>图解：<br><img src="/img/abccd8c302b9609b787495f0bf9bd364.png" alt><br><img src="/img/71c621876faa1e651fb3a4197a1d0c11.png" alt></p>
<p>向一个父节点为3-节点的3-节点中插入新节点的操作步骤：插入节点后一直向上分解构造的临时4-节点并将中键移动到更高层双亲节点，直到遇到一个-2节点并将其替换为一个不需要继续分解的3-节点，或是到达树根(3-节点)。</p>
<p>图解：<br><img src="/img/48a23e1dd9c8a341741d380033ad008f.png" alt></p>
<p><img src="/img/30150a1882bfb7cf3a549be1eddc84a6.jpg" alt></p>
<p><img src="/img/17f62ec19a5985fd20373f8f76ae1938.png" alt></p>
<p>分解根节点<br>操作步骤：如果从插入节点到根节点的路径上全是3-节点（包含根节点在内），根节点将最终被替换为一个临时的4-节点，将临时的4-节点分解为3个2-节点，分解后树高会增加1。</p>
<p>图解：<br><img src="/img/5d18899b2274d575830eb9608b8e0af5.jpg" alt></p>
<h2 id="2-3树删除"><a href="#2-3树删除" class="headerlink" title="2-3树删除"></a>2-3树删除</h2><p>删除之前，先要对2-3树进行一次命中的查找，查找成功才可以进行删除操作。删除节点大概分为3种情形</p>
<ol>
<li>删除非叶子节点。</li>
<li>删除不为2-节点的叶子节点。</li>
<li>删除为2-节点的叶子节点。</li>
</ol>
<h3 id="删除非叶子节点"><a href="#删除非叶子节点" class="headerlink" title="删除非叶子节点"></a>删除非叶子节点</h3><p>操作步骤：使用中序遍历下的直接后继节点key来覆盖当前待删除节点key，再删除用来覆盖的后继节点key。</p>
<p>图解：<br><img src="/img/a1bedcc86a524ba67d5c1856e231721f.png" alt></p>
<p>删除不为2-节点的叶子节点操作步骤：删除不为2-节点的叶子节点，直接删除节点即可。**</p>
<p>图解：<br><img src="/img/4615e62775c541bc9e75beb2fdb25f65.png" alt></p>
<p>删除为2-节点的叶子节点<br>删除为2-节点的叶子节点的步骤相对复杂，删除节点后需要做出相应判断，并根据判断结果调整树结构。主要分为四种情形：</p>
<p>删除节点为2-节点，父节点为2-节点，兄弟节点为3-节点的操作步骤：当前待删除节点的父节点是2-节点、兄弟节点是3-节点，将父节点移动到当前待删除节点位置，再将兄弟节点中最接近当前位置的key移动到父节点中。</p>
<p>图解：<br><img src="/img/4f2a0549924de35b50f72e4f212145a0.png" alt></p>
<p>删除节点为2-节点，父节点为2-节点，兄弟节点为2-节点的操作步骤：当前待删除节点的父节点是2-节点、兄弟节点也是2-节点，先通过移动兄弟节点的中序遍历直接后驱到兄弟节点，以使兄弟节点变为3-节点；再进行6.3.1的操作。</p>
<p>图解：<br><img src="/img/cb828f494ba4b69cecce89f8e5bceb20.png" alt><br><img src="/img/f5f3fd791411fbb6fb45d5d6a7612e9a.png" alt></p>
<p>删除节点为2-节点，父节点为3-节点的操作步骤：当前待删除节点的父节点是3-节点，拆分父节点使其成为2-节点，再将再将父节点中最接近的一个拆分key与中孩子合并，将合并后的节点作为当前节点。</p>
<p>图解：<br><img src="/img/62a98f17efedf822e68f2c1e38fc7779.png" alt></p>
<p>2-3树为满二叉树，删除叶子节点的操作步骤：若2-3树是一颗满二叉树，将2-3树层树减少，并将当前删除节点的兄弟节点合并到父节点中，同时将父节点的所有兄弟节点合并到父节点的父节点中，如果生成了4-节点，再分解4-节点。</p>
<p>图解：<br><img src="/img/413808e1b75212f1f23a6e122897d0c5.png" alt></p>
<h2 id="2-3-4树"><a href="#2-3-4树" class="headerlink" title="2-3-4树"></a>2-3-4树</h2><p>2-3-4树是对2-3树的概念扩展，包括了4节点的使用。一个4节点中包含小中大三个元素和四个孩子(要么有四个孩子要么没有，不存在其他情况)，如果某个4节点有孩子的话，左子树包含小于最小元素的元素；第二子树包含大于最小元素，小于第二元素的元素；第三子树包含大于第二元素，小于最大元素的元素；右子树包含大于最大元素的元素。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>先找插入结点，若结点有空(即2-结点)，则直接插入。如结点没空(即3-结点)，则插入使其临时容纳这个元素，然后分裂此结点，把中间元素移到其父结点中。对父结点亦如此处理。（中键一直往上移，直到找到空位，在此过程中没有空位就先搞个临时的，再分裂。）</p>
<p>2-3树插入算法的根本在于这些变换都是局部的：除了相关的结点和链接之外不必修改或者检查树的其他部分。每次变换中，变更的链接数量不会超过一个很小的常数。所有局部变换都不会影响整棵树的有序性和平衡性。</p>
<p>同时，通过上面树的深度增加的例子，可以看出2-3树和标准二叉树不同，标准的二叉树的的深度是由上到下的增加的，而2-3树的深度生长是由下至上的。</p>
<h1 id="B-树"><a href="#B-树" class="headerlink" title="B-树"></a>B-树</h1><p>定义：B-树是一类树，包括B-树、B+树、B*树等，是一棵自平衡的搜索树，它类似普通的平衡二叉树，不同的一点是B-树允许每个节点有更多的子节点。</p>
<p>一个 m 阶的B树满足以下条件：</p>
<ul>
<li>每个结点至多拥有m棵子树；</li>
<li>根结点至少拥有两颗子树（存在子树的情况下）；</li>
<li>除了根结点以外，其余每个分支结点至少拥有 m/2 棵子树；</li>
<li>所有的叶结点都在同一层上；</li>
<li>有 k 棵子树的分支结点则存在 k-1 个关键码，关键码按照递增次序进行排列；</li>
<li>关键字数量需要满足ceil(m/2)-1 &lt;= n &lt;= m-1；</li>
</ul>
<p><img src="/img/5959612-b81be8294621eb26.webp" alt></p>
<p>B树上大部分的操作所需要的磁盘存取次数和B树的高度是成正比的，在B树中可以检查多个子结点，由于在一棵树中检查任意一个结点都需要一次磁盘访问，所以B树避免了大量的磁盘访问。</p>
<p>B-树是专门为外部存储器设计的，如磁盘，它对于读取和写入大块数据有良好的性能，所以一般被用在文件系统及数据库中。</p>
<p>定义只需要知道B-树允许每个节点有更多的子节点即可（多叉树）。子节点数量一般在上千，具体数量依赖外部存储器的特性。</p>
<p>先来看看为什么会出现B-树这类数据结构。</p>
<p>传统用来搜索的平衡二叉树有很多，如 AVL 树，红黑树等。这些树在一般情况下查询性能非常好，但当数据非常大的时候它们就无能为力了。原因当数据量非常大时，内存不够用，大部分数据只能存放在磁盘上，只有需要的数据才加载到内存中。一般而言内存访问的时间约为 50 ns，而磁盘在 10 ms 左右。速度相差了近 5 个数量级，磁盘读取时间远远超过了数据在内存中比较的时间。这说明程序大部分时间会阻塞在磁盘 IO 上。那么我们如何提高程序性能？减少磁盘 IO 次数，像 AVL 树，红黑树这类平衡二叉树从设计上无法“迎合”磁盘。</p>
<p>平衡二叉树是通过旋转来保持平衡的，而旋转是对整棵树的操作，若部分加载到内存中则无法完成旋转操作。其次平衡二叉树的高度相对较大为 log n（底数为2），这样逻辑上很近的节点实际可能非常远，无法很好的利用磁盘预读（局部性原理），所以这类平衡二叉树在数据库和文件系统上的选择就被 pass 了。</p>
<p>空间局部性原理：如果一个存储器的某个位置被访问，那么将它附近的位置也会被访问。</p>
<p>我们从“迎合”磁盘的角度来看看B-树的设计。</p>
<p>索引的效率依赖与磁盘 IO 的次数，快速索引需要有效的减少磁盘 IO 次数，如何快速索引呢？索引的原理其实是不断的缩小查找范围，就如我们平时用字典查单词一样，先找首字母缩小范围，再第二个字母等等。平衡二叉树是每次将范围分割为两个区间。为了更快，B-树每次将范围分割为多个区间，区间越多，定位数据越快越精确。那么如果节点为区间范围，每个节点就较大了。所以新建节点时，直接申请页大小的空间（磁盘存储单位是按 block 分的，一般为 512 Byte。磁盘 IO 一次读取若干个 block，我们称为一页，具体大小和操作系统有关，一般为 4 k，8 k或 16 k），计算机内存分配是按页对齐的，这样就实现了一个节点只需要一次 IO。</p>
<p>多叉的好处非常明显，有效的降低了B-树的高度，为底数很大的 log n，底数大小与节点的子节点数目有关，一般一棵B-树的高度在 3 层左右。层数低，每个节点区确定的范围更精确，范围缩小的速度越快（比二叉树深层次的搜索肯定快很多）。上面说了一个节点需要进行一次 IO，那么总 IO 的次数就缩减为了 log n 次。B-树的每个节点是 n 个有序的序列(a1,a2,a3…an)，并将该节点的子节点分割成 n+1 个区间来进行索引(X1&lt; a1, a2 &lt; X2 &lt; a3, … , an+1 &lt; Xn &lt; anXn+1 &gt; an)。</p>
<p>点评：B树的每个节点，都是存多个值的，不像二叉树那样，一个节点就一个值，B树把每个节点都给了一点的范围区间，区间更多的情况下，搜索也就更快了，比如：有1-100个数，二叉树一次只能分两个范围，0-50和51-100，而B树，分成4个范围 1-25， 25-50，51-75，76-100一次就能筛选走四分之三的数据。所以作为多叉树的B树是更快的。</p>
<h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>新结点一般插在第h层，通过搜索找到对应的结点进行插入，那么根据即将插入的结点的数量又分为下面几种情况。</p>
<p>如果该结点的关键字个数没有到达m-1个，那么直接插入即可；</p>
<p>如果该结点的关键字个数已经到达了m-1个，那么根据B树的性质显然无法满足，需要将其进行分裂。分裂的规则是该结点分成两半，将中间的关键字进行提升，加入到父亲结点中，但是这又可能存在父亲结点也满员的情况，则不得不向上进行回溯，甚至是要对根结点进行分裂，那么整棵树都加了一层。</p>
<p>其过程如下：<br><img src="/img/5959612-c11df32046f7c405.webp" alt></p>
<p><img src="/img/5959612-c347422b9a94f5bb.webp" alt></p>
<p><img src="/img/5959612-b979b0489ef0a576.webp" alt></p>
<p><img src="/img/5959612-d9cc5aa6b00fae0d.webp" alt></p>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>同样的，我们需要先通过搜索找到相应的值，存在则进行删除，需要考虑删除以后的情况，</p>
<ul>
<li>如果该结点拥有关键字数量仍然满足B树性质，则不做任何处理；</li>
<li>如果该结点在删除关键字以后不满足B树的性质（关键字没有到达ceil(m/2)-1的数量），则需要向兄弟结点借关键字，这有分为兄弟结点的关键字数量是否足够的情况。</li>
<li>如果兄弟结点的关键字足够借给该结点，则过程为将父亲结点的关键字下移，兄弟结点的关键字上移；</li>
<li>如果兄弟结点的关键字在借出去以后也无法满足情况，即之前兄弟结点的关键字的数量为ceil(m/2)-1，借的一方的关键字数量为ceil(m/2)-2的情况，那么我们可以将该结点合并到兄弟结点中，合并之后的子结点数量少了一个，则需要将父亲结点的关键字下放，如果父亲结点不满足性质，则向上回溯；</li>
<li>其余情况参照BST中的删除。</li>
</ul>
<p>其过程如下：<br><img src="/img/5959612-82ca66cb555eeaa6.webp" alt></p>
<p><img src="/img/5959612-3d9383c247d3112b.webp" alt></p>
<p><img src="/img/5959612-0ecb25e96e2f6210.webp" alt></p>
<p>B-树是一种多路搜索树（并不是二叉的）：</p>
<ol>
<li>定义任意非叶子结点最多只有M个儿子；且M&gt;2；</li>
<li>根结点的儿子数为[2, M]；</li>
<li>除根结点以外的非叶子结点的儿子数为[M/2, M]；</li>
<li>每个结点存放至少M/2-1（取上整）和至多M-1个关键字；（至少2个关键字）</li>
<li>非叶子结点的关键字个数=指向儿子的指针个数-1；</li>
<li>非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] &lt; K[i+1]；</li>
<li>非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树；</li>
<li>所有叶子结点位于同一层；</li>
</ol>
<p>如：（M=3）<br><img src="/img/20211114005302.jpg" alt></p>
<p>来模拟下查找文件29的过程：</p>
<ol>
<li>根据根结点指针找到文件目录的根磁盘块1，将其中的信息导入内存。【磁盘IO操作1次】</li>
<li>此时内存中有两个文件名17，35和三个存储其他磁盘页面地址的数据。根据算法我们发现17&lt;29&lt;35，因此我们找到指针p2。</li>
<li>根据p2指针，我们定位到磁盘块3，并将其中的信息导入内存。【磁盘IO操作2次】</li>
<li>此时内存中有两个文件名26，30和三个存储其他磁盘页面地址的数据。根据算法我们发现26&lt;29&lt;30，因此我们找到指针p2。</li>
<li>根据p2指针，我们定位到磁盘块8，并将其中的信息导入内存。【磁盘IO操作3次】</li>
<li>此时内存中有两个文件名28，29。根据算法我们查找到文件29，并定位了该文件内存的磁盘地址。</li>
</ol>
<p>生成从空树开始，逐个插入关键字。但是由于B-树节点关键字必须大于等于<code>[ceil(m/2)-1]</code>，所以每次插入一个关键字不是在树中添加一个叶子结点，而是首先在最底层的某个非终端节点中添加一个“关键字”，该结点的关键字不超过m-1，则插入完成；否则要产生结点的“分裂”，将一半数量的关键字元素分裂到新的其相邻右结点中，中间关键字元素上移到父结点中。</p>
<p>1、咱们通过一个实例来逐步讲解下。插入以下字符字母到一棵空的B 树中（非根结点关键字数小了（小于2个）就合并，大了（超过4个）就分裂）：C N G A H E K Q M F W L T Z D P R X Y S，首先，结点空间足够，4个字母插入相同的结点中，如下图：<br><img src="/img/20211114005306.jpg" alt></p>
<p>2、当咱们试着插入H时，结点发现空间不够，以致将其分裂成2个结点，移动中间元素G上移到新的根结点中，在实现过程中，咱们把A和C留在当前结点中，而H和N放置新的其右邻居结点中。如下图：<br><img src="/img/20211114005307.jpg" alt></p>
<p>3、当咱们插入E,K,Q时，不需要任何分裂操作<br><img src="/img/20211114005308.jpg" alt></p>
<p>4、插入M需要一次分裂，注意M恰好是中间关键字元素，以致向上移到父节点中<br><img src="/img/20211114005309.jpg" alt></p>
<p>5、插入F,W,L,T不需要任何分裂操作<br><img src="/img/20211114005310.jpg" alt></p>
<p>6、插入Z时，最右的叶子结点空间满了，需要进行分裂操作，中间元素T上移到父节点中，注意通过上移中间元素，树最终还是保持平衡，分裂结果的结点存在2个关键字元素。<br><img src="/img/20211114005311.jpg" alt></p>
<p>7、插入D时，导致最左边的叶子结点被分裂，D恰好也是中间元素，上移到父节点中，然后字母P,R,X,Y陆续插入不需要任何分裂操作（别忘了，树中至多5个孩子）。<br><img src="/img/20211114005312.jpg" alt></p>
<p>8、最后，当插入S时，含有N,P,Q,R的结点需要分裂，把中间元素Q上移到父节点中，但是情况来了，父节点中空间已经满了，所以也要进行分裂，将父节点中的中间元素M上移到新形成的根结点中，注意以前在父节点中的第三个指针在修改后包括D和G节点中。这样具体插入操作的完成。<br><img src="/img/20211114005313.jpg" alt></p>
<h2 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h2><p>首先查找B树中需删除的元素,如果该元素在B树中存在，则将该元素在其结点中进行删除，如果删除该元素后，首先判断该元素是否有左右孩子结点，如果有，则上移孩子结点中的某相近元素到父节点中，然后是移动之后的情况；如果没有，直接删除后，移动之后的情况。</p>
<p>删除元素，移动相应元素之后，如果某结点中元素数目（即关键字数）小于<code>ceil(m/2)-1</code>，则需要看其某相邻兄弟结点是否丰满（结点中元素个数大于<code>ceil(m/2)-1)</code>（还记得第一节中关于B树的第5个特性中的c点么?：c)除根结点之外的结点（包括叶子结点）的关键字的个数n必须满足：<code>(ceil(m / 2)-1) &lt;= n &lt;= m-1</code>。m表示最多含有m个孩子，n表示关键字数。在本小节中举的一颗B树的示例中，关键字数n满足：<code>2&lt;=n&lt;=4</code>），如果丰满，则向父节点借一个元素来满足条件；如果其相邻兄弟都刚脱贫，即借了之后其结点数目小于<code>ceil(m/2)-1</code>，则该结点与其相邻的某一兄弟结点进行“合并”成一个结点，以此来满足条件。那咱们通过下面实例来详细了解吧。</p>
<p>以上述插入操作构造的一棵5阶B树（树中最多含有m（m=5）个孩子，因此关键字数最小为ceil(m / 2)-1=2。还是这句话，关键字数小了（小于2个）就合并，大了（超过4个）就分裂）为例，依次删除H,T,R,E。</p>
<p><img src="/img/20211114005314.jpg" alt></p>
<p>1、首先删除元素H，当然首先查找H，H在一个叶子结点中，且该叶子结点元素数目3大于最小元素数目ceil(m/2)-1=2，则操作很简单，咱们只需要移动K至原来H的位置，移动L至K的位置（也就是结点中删除元素后面的元素向前移动）<br><img src="/img/20211114005315.jpg" alt></p>
<p>2、下一步，删除T,因为T没有在叶子结点中，而是在中间结点中找到，咱们发现他的继承者W(字母升序的下个元素)，将W上移到T的位置，然后将原包含W的孩子结点中的W进行删除，这里恰好删除W后，该孩子结点中元素个数大于2，无需进行合并操作。<br><img src="/img/20211114005316.jpg" alt></p>
<p>3、下一步删除R，R在叶子结点中，但是该结点中元素数目为2，删除导致只有1个元素，已经小于最小元素数目<code>ceil(5/2)-1=2</code>，而由前面我们已经知道：如果其某个相邻兄弟结点中比较丰满（元素个数大于<code>ceil(5/2)-1=2</code>），则可以向父结点借一个元素，然后将最丰满的相邻兄弟结点中上移最后或最前一个元素到父节点中（有没有看到红黑树中左旋操作的影子?），在这个实例中，右相邻兄弟结点中比较丰满（3个元素大于2），所以先向父节点借一个元素W下移到该叶子结点中，代替原来S的位置，S前移；然后X在相邻右兄弟结点中上移到父结点中，最后在相邻右兄弟结点中删除X，后面元素前移。<br><img src="/img/20211114005317.jpg" alt></p>
<p>4、最后一步删除E，删除后会导致很多问题，因为E所在的结点数目刚好达标，刚好满足最小元素个数（ceil(5/2)-1=2），而相邻的兄弟结点也是同样的情况，删除一个元素都不能满足条件，所以需要该节点与某相邻兄弟结点进行合并操作；首先移动父结点中的元素（该元素在两个需要合并的两个结点元素之间）下移到其子结点中，然后将这两个结点进行合并成一个结点。所以在该实例中，咱们首先将父节点中的元素D下移到已经删除E而只有F的结点中，然后将含有D和F的结点和含有A,C的相邻兄弟结点进行合并成一个结点。<br><img src="/img/20211114005318.jpg" alt></p>
<p>5、也许你认为这样删除操作已经结束了，其实不然，在看看上图，对于这种特殊情况，你立即会发现父节点只包含一个元素G，没达标（因为非根节点包括叶子结点的关键字数n必须满足于<code>2=&lt;n&lt;=4</code>，而此处的n=1），这是不能够接受的。如果这个问题结点的相邻兄弟比较丰满，则可以向父结点借一个元素。假设这时右兄弟结点（含有Q,X）有一个以上的元素（Q右边还有元素），然后咱们将M下移到元素很少的子结点中，将Q上移到M的位置，这时，Q的左子树将变成M的右子树，也就是含有N，P结点被依附在M的右指针上。所以在这个实例中，咱们没有办法去借一个元素，只能与兄弟结点进行合并成一个结点，而根结点中的唯一元素M下移到子结点，这样，树的高度减少一层。<br><img src="/img/20211114005319.jpg" alt></p>
<p>为了进一步详细讨论删除的情况，再举另外一个实例：这里是一棵不同的5序B树，那咱们试着删除C<br><img src="/img/20211114005320.jpg" alt></p>
<p>于是将删除元素C的右子结点中的D元素上移到C的位置，但是出现上移元素后，只有一个元素的结点的情况。</p>
<p>又因为含有E的结点，其相邻兄弟结点才刚脱贫（最少元素个数为2），不可能向父节点借元素，所以只能进行合并操作，于是这里将含有A,B的左兄弟结点和含有E的结点进行合并成一个结点。<br><img src="/img/20211114005321.jpg" alt></p>
<p>这样又出现只含有一个元素F结点的情况，这时，其相邻的兄弟结点是丰满的（元素个数为3&gt;最小元素个数2），这样就可以想父结点借元素了，把父结点中的J下移到该结点中，相应的如果结点中J后有元素则前移，然后相邻兄弟结点中的第一个元素（或者最后一个元素）上移到父节点中，后面的元素（或者前面的元素）前移（或者后移）；注意含有K，L的结点以前依附在M的左边，现在变为依附在J的右边。这样每个结点都满足B树结构性质。<br><img src="/img/20211114005322.jpg" alt></p>
<p>从以上操作可看出：除根结点之外的结点（包括叶子结点）的关键字的个数n满足：<code>(ceil(m / 2)-1) &lt;= n &lt;= m-1</code>，即2&lt;=n&lt;=4。这也佐证了咱们之前的观点。删除操作完。</p>
<p>B-树的搜索，从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点；</p>
<p>B-树的特性：</p>
<ol>
<li>关键字集合分布在整颗树中；</li>
<li>任何一个关键字出现且只出现在一个结点中；</li>
<li>搜索有可能在非叶子结点结束；</li>
<li>其搜索性能等价于在关键字全集内做一次二分查找；</li>
<li>自动层次控制；</li>
</ol>
<p>由于限制了除根结点以外的非叶子结点，至少含有M/2个儿子，确保了结点的至少利用率，其最底搜索性能为：<br><img src="/img/20211114005303.jpg" alt></p>
<p>其中，M为设定的非叶子结点最多子树个数，N为关键字总数；所以B-树的性能总是等价于二分查找（与M值无关），也就没有B树平衡的问题；由于M/2的限制，在插入结点时，如果结点已满，需要将结点分裂为两个各占M/2的结点；删除结点时，需将两个不足M/2的兄弟结点合并；</p>
<h1 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B+树"></a>B+树</h1><p>B+树是B-树的变体，也是一种多路搜索树：</p>
<ol>
<li>其定义基本与B-树同，除了：</li>
<li>非叶子结点的子树指针与关键字个数相同；</li>
<li>非叶子结点的子树指针P[i]，指向关键字值属于[K[i], K[i+1])的子树（B-树是开区间）；</li>
<li>为所有叶子结点增加一个链指针；</li>
<li>所有关键字都在叶子结点出现；</li>
</ol>
<p><img src="/img/20211114005323.jpg" alt></p>
<p>B+的搜索与B-树也基本相同，区别是B+树只有达到叶子结点才命中（B-树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找。B+树的主要优点：非终端结点仅仅起高层索引作用，而B树非终端结点的关键字除作子树分界外，本身还是实际记录的有效关键字（含记录指针），因此相同的结点空间，B+树可以设计的阶树比B树大，相同的索引，B+树的索引层数比B树少，因此检索速度比B树快。此外，B+树叶子结点包含完整的索引信息，可以较方便地表示文件的稀疏索引。最后，B+树的检索、插入和删除都在叶子结点进行，比B树相对简单。</p>
<p>B+的特性：</p>
<ol>
<li>所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的；</li>
<li>不可能在非叶子结点命中；</li>
<li>非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层；</li>
<li>更适合文件索引系统；</li>
</ol>
<p>B树和B+树的区别是由于B+树和B具有这不同的存储结构所造成的区别，以一个m阶树为例。</p>
<ul>
<li>关键字的数量不同；B+树中分支结点有m个关键字，其叶子结点也有m个，其关键字只是起到了一个索引的作用，但是B树虽然也有m个子结点，但是其只拥有m-1个关键字。</li>
<li>存储的位置不同；B+树中的数据都存储在叶子结点上，也就是其所有叶子结点的数据组合起来就是完整的数据，但是B树的数据存储在每一个结点中，并不仅仅存储在叶子结点上。</li>
<li>分支结点的构造不同；B+树的分支结点仅仅存储着关键字信息和儿子的指针（这里的指针指的是磁盘块的偏移量），也就是说内部结点仅仅包含着索引信息。</li>
<li>查询不同；B树在找到具体的数值以后，则结束，而B+树则需要通过索引找到叶子结点中的数据才结束，也就是说B+树的搜索过程中走了一条从根结点到叶子结点的路径。</li>
</ul>
<p>与 B 树相比，B+ 树有着如下的好处：</p>
<ul>
<li>B+ 树的磁盘读写代价更低<ul>
<li>B+ 树的内部结点并没有指向关键字具体信息的指针，所以其内部结点相对 B 树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多，所以一次性读入内存中的需要查找的关键字也就越多。相对来说 IO 读写次数也就降低了，查找速度就更快了。</li>
</ul>
</li>
<li>B+ 树查询效率更加稳定<ul>
<li>由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以 B+ 树中任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。而对于 B 树来说，因为其每个节点都存具体的数据，因此其查询速度可能更快，但是却并不稳定。</li>
</ul>
</li>
<li>B+ 树便于范围查询（最重要的原因，范围查找是数据库的常态）<ul>
<li>B 树在提高了 IO 性能的同时，并没有解决元素遍历效率低下的问题。为了解决这个问题，B+ 树应用而生。B+ 树只需要去遍历叶子节点就可以实现整棵树的遍历。在数据库中基于范围的查询是非常频繁的，因此 MySQL 的 Innodb 引擎就使用了 B+ 树作为其索引的数据结构。</li>
</ul>
</li>
</ul>
<p>阶为 a 的 B+树内部结点的结构如下：<br><img src="/img/v2-705cee41307cbf12d84d2dc9c9c1dae7_1440w.jpg" alt></p>
<ul>
<li>对于每一个形如：<code>&lt;P1, K1, P2, K2, ..., P(c-1), K(c-1), Pc&gt;</code> 的内部结点，其中 <code>c ≤ a</code> ，每一个<code>Pi</code>表示指向子树根结点的指针，<code>Ki</code>表示关键字值</li>
<li>对于每一个内部结点中的关键字值均满足：<code>K1 &lt; K2 &lt; K3 &lt; K(c-1)</code>。(内部结点的关键字由小到大有序排列)</li>
<li>对于一个位于<code>Pi</code>所指向的子树中的结点<code>X</code>而言，满足：<ul>
<li>当<code>1&lt;i&lt;c</code>时，均有<code>K(i-1) &lt; X ≤ Ki</code>。</li>
<li>当<code>i=c</code>时，<code>X &gt; K(c-1)</code>。</li>
<li>当<code>i=1</code>时，<code>X ≤ K1</code>。</li>
</ul>
</li>
<li>每一个内部结点最多有 a 个指向子树的指针，即 c 最大取 a .</li>
<li>根结点至少包含两个指向子树的结点指针，即对于根结点而言<code>2 ≤ c ≤ a</code>；除了根之外的每个结点都包含最少<code>ceil(a/2)</code>个指向子树的指针。</li>
<li>如果任意一个内部结点包含<code>c</code>个指向孩子结点的指针且<code>c ≤ a</code>，则该结点包含<code>c-1</code>的关键字。</li>
</ul>
<p>阶为 b 的 B+树叶子结点的结构：<br><img src="/img/v2-e623d8c85e5dde67eb9948484d4305f9_1440w.jpg" alt></p>
<ul>
<li>对于每一个形如：<code>&lt;&lt;K1, D1&gt;, &lt;K2, D2&gt;, ..., &lt;K(c-1), D(c-1)&gt;, P(next)&gt;</code> 的内部结点，其中 <code>c ≤ b</code> ，<code>Di</code>是一个数据指针（指向磁盘上的值等于<code>Ki</code>的真实记录的指针，或者包含记录<code>Ki</code>的磁盘文件块），<code>Ki</code>是一个关键字，<code>P(next)</code>表示 B+树中指向下一个叶子结点的指针。</li>
<li>对任意一个叶子结点均有：<code>K1 &lt; K2 &lt; K3 &lt; K(c-1)</code>。</li>
<li>每一个叶子结点至少包含<code>ceil(a/2)</code>个值。</li>
<li>所有的叶子结点在同一层。</li>
</ul>
<p>使用<code>P(next)</code>指针可以遍历所有的叶子结点，就和单链表一样，从而实现对磁盘上记录的有序访问。</p>
<p>下图为一颗完整的 B+树的结构示例：<br><img src="/img/v2-7a83d0068331c5fe82ae2557b97e52d8_1440w.jpg" alt></p>
<p>同为h层的 B-树和 B+树，B+树可以存储更多的结点元素，更加 ”矮胖“。这也是 B+树最大的优势坐在，极大地改善了 B-树的查找效率。对于同样多的记录，B+树的高度会更矮，并且<code>P(next)</code>指针的出现可以帮助 B+树快速访问磁盘记录且效率非常高。总之，就是 B+树比 B-树更加好，B+树的磁盘 I / O 会更少，相比于 B-树的中序遍历，B+树只需要像遍历单链表一样扫描一遍叶子结点。</p>
<h2 id="查找操作"><a href="#查找操作" class="headerlink" title="查找操作"></a>查找操作</h2><p><img src="/img/v2-8133213bd9817012f8a8e95b079c6817_1440w.jpg" alt></p>
<p>第一点：B+树中的所有数据均保存在叶子结点，且根结点和内部结点均只是充当控制查找记录的媒介，并不代表数据本身，所有的内部结点元素都同时存在于子结点中，是子节点元素中是最大（或最小）元素。<br><img src="/img/v2-25c1c0b8a4ea8c300e180e3d87339bfb_1440w.jpg" alt></p>
<p>比如 B+ 树中的结点 59 （结点 15、44、97、72 类似），是其子结点 [15、44、59] 中的最大元素，也是叶子结点 [51、59] 中的最大元素。所有的数据 [10、15、21、37、44、51、59、63、72、85、91、97] 均保存在叶子结点之中，而根结点 [59、97] 及内部结点 [15、44、59] 与 [72、97] 均不是数据本身，只是充当控制查找记录的媒介。</p>
<p>需要注意的是，根结点的最大元素 97 是整颗 B+树当中最大的元素，无论之后在叶子结点中插入或删除多少元素，始终要保证最大元素在根结点当中，这个讲插入和删除时还会看到。</p>
<p>第二点：每一个叶子结点都有指向下一个叶子结点的<code>P(next)</code>指针，便捷之处就在于之后我们将看到的区间查找。<br><img src="/img/v2-efa3f8f327b9e55930e8a772f8183ab7_1440w.jpg" alt></p>
<p>我们以查询 59 为例进行说明。</p>
<p>第一次磁盘 I/O ：访问根结点 [59、97] ，发现 59 小于等于 [59、97] 中的 59 ，则访问根结点的第一个孩子结点。<br><img src="/img/v2-efc68940b3f85ba0b6f6a2352df43bff_1440w.jpg" alt></p>
<p>第二次磁盘 I/O : 访问结点 [15、44、59] ，发现 59 大于 44 且小于等于 59 ，则访问当前结点的第三个孩子结点 [51、59] .<br><img src="/img/v2-54282f355f16664a05863e764135ace0_1440w.jpg" alt></p>
<p>第三次磁盘 I/O ：访问叶子结点 [51、59] ，顺序遍历结点内部，找到要查找的元素 59 .<br><img src="/img/v2-65789684f319ca8675040ee7044e365c_1440w.jpg" alt></p>
<p>我想你已经注意到了和 B-树的区别，对于 B+树中单个元素的查找而言，每一个元素都有相同的磁盘 I/O操作次数，即使查询的元素出现在根结点中，但那只是一个充当控制查找记录的媒介，并不是数据本身，数据真正存在于叶子结点当中，所以 B+树中查找任何一个元素都要从根结点一直走到叶子结点才可以。<br><img src="/img/v2-7a83d0068331c5fe82ae2557b97e52d8_1440w.jpg" alt></p>
<p>B+树的非叶子结点均不存储 Data (即<code>Di</code>，官方将其称为卫星数据) ，所以与 B-树相比，同样大小的磁盘页，B+树的非叶子结点可以存储更多的索引（关键字），这也就意味着在数据量相同的情况下，B+树的结构比 B-树更加 “矮胖”，查询时磁盘 I/O 次数会更少。</p>
<p>注意： B-树的查询性能并不稳定，对于根结点中关键字可能只有一次磁盘 I/O，而对于叶子结点中的关键字需要树的高度次磁盘 I/O 操作。</p>
<h2 id="B-树的插入操作"><a href="#B-树的插入操作" class="headerlink" title="B+树的插入操作"></a>B+树的插入操作</h2><p>在B+树中插入关键字时，需要注意以下几点：</p>
<ul>
<li>插入的操作全部都在叶子结点上进行，且不能破坏关键字自小而大的顺序；</li>
<li>由于 B+树中各结点中存储的关键字的个数有明确的范围，做插入操作可能会出现结点中关键字个数超过阶数的情况，此时需要将该结点进行 “分裂”；</li>
</ul>
<p>我们依旧以之前介绍查找操作时使用的图对插入操作进行说明，需要注意的是，B+树的阶数 M = 3 ，且 ⌈M/2⌉ = 2（取上限） 、⌊M/2⌋ = 1（取下限） ：<br><img src="/img/v2-8133213bd9817012f8a8e95b079c6817_1440w.jpg" alt></p>
<p>B+树中做插入关键字的操作，有以下 3 种情况：</p>
<p>1、 若被插入关键字所在的结点，其含有关键字数目小于阶数 M，则直接插入；比如插入关键字 12 ，插入关键字所在的结点的 [10，15] 包含两个关键字，小于 M ，则直接插入关键字 12 。<br><img src="/img/v2-386cefe3c3c93b726387ee2abc577691_b.jpg" alt></p>
<p>2、 若被插入关键字所在的结点，其含有关键字数目等于阶数 M，则需要将该结点分裂为两个结点，一个结点包含 ⌊M/2⌋ ，另一个结点包含 ⌈M/2⌉ 。同时，将⌈M/2⌉的关键字上移至其双亲结点。假设其双亲结点中包含的关键字个数小于 M，则插入操作完成。</p>
<p>插入关键字 95 ，插入关键字所在结点 [85、91、97] 包含 3 个关键字，等于阶数 M ，则将 [85、91、97] 分裂为两个结点 [85、91] 和结点 [97] , 关键字 95 插入到结点 [95、97] 中，并将关键字 91 上移至其双亲结点中，发现其双亲结点 [72、97] 中包含的关键字的个数 2 小于阶数 M ，插入操作完成。<br><img src="/img/v2-4e621ab9044dcb42643066f6031226b0_b.webp" alt></p>
<p>3、在第 2 情况中，如果上移操作导致其双亲结点中关键字个数大于 M，则应继续分裂其双亲结点。</p>
<p>插入关键字 40 ，按照第 2 种情况将结点分裂，并将关键字 37 上移到父结点，发现父结点 [15、37、44、59] 包含的关键字的个数大于 M ，所以将结点 [15、37、44、59] 分裂为两个结点 [15、37] 和结点 [44、59] ，并将关键字 37 上移到父结点中 [37、59、97] . 父结点包含关键字个数没有超过 M ，插入结束。<br><img src="/img/v2-467b2c27f41bad29b01be13e1e5cd1bb_b.gif" alt></p>
<p>4、若插入的关键字比当前结点中的最大值还大，破坏了B+树中从根结点到当前结点的所有索引值，此时需要及时修正后，再做其他操作。</p>
<p>插入关键字 100，由于其值比最大值 97 还大，插入之后，从根结点到该结点经过的所有结点中的所有值都要由 97 改为 100。改完之后再做分裂操作。<br><img src="/img/v2-85fb69b1f6d5134f45808fc884ad2e4a_b.webp" alt></p>
<h2 id="B-树的删除操作"><a href="#B-树的删除操作" class="headerlink" title="B+树的删除操作"></a>B+树的删除操作</h2><p>“对于 B+的删除操作而言，与 B-树类似”，我想你笑了，那我们接着看，哈哈！</p>
<p>在 B+树中删除关键字时，有以下几种情况：</p>
<p>1、 找到存储有该关键字所在的结点时，由于该结点中关键字个数大于⌈M/2⌉，做删除操作不会破坏 B+树，则可以直接删除。</p>
<p>删除关键字 91，包含关键字 91 的结点 [85、91、97] 中关键字的个数 3 大于 ⌈M/2⌉ = 2 ，做删除操作不会破坏 B+树的特性，直接删除。<br><img src="/img/v2-7607b34265b14b3527101d53ce9c2b70_b.gif" alt></p>
<p>2、 当删除某结点中最大或者最小的关键字，就会涉及到更改其双亲结点一直到根结点中所有索引值的更改。</p>
<p>以删除整颗 B+树中最大的关键字 97 为例，查找并删除关键字 97 ， 然后向上回溯，将所有关键字 97 替换为次最大的关键字 91 :<br><img src="/img/v2-3aee225a4ba3e3a1b428e3f30e312637_b.gif" alt></p>
<p>3、 当删除该关键字，导致当前结点中关键字个数小于 ⌈M/2⌉，若其兄弟结点中含有多余的关键字，可以从兄弟结点中借关键字完成删除操作。</p>
<p>当删除某个关键字之后，结点中关键字个数小于 ⌈M/2⌉ ，则不符合 B+树的特性，则需要按照 3 he 4 两种情况分别处理。以删除关键字 51 为例，由于其兄弟结点 [21、37、44] 中含有 3 个关键字，所以可以选择借一个关键字 44，同时将双亲结点中的索引值 44 修改 37 ，删除过程如下图所示：<br><img src="/img/v2-8dae05b8aa006d6d1fc6bb54c24169a5_b.gif" alt></p>
<p>4、 第 3 种情况中，如果其兄弟结点没有多余的关键字，则需要同其兄弟结点进行合并。</p>
<p>为了说明这种情况，我们在第 3 种情况最终得到的 B+树之上进行删除操作。第 3 种情况删除关键字 51 之后得到如下所示 B+树：<br><img src="/img/v2-909e556bc9375489e5f975f90b25dfa8_1440w.jpg" alt></p>
<p>我们以删除上面这个 B+树中的关键字 59 说明第 4 种情况，首先查找到关键 59 所在结点 [44、59] ，发现该结点的兄弟结点 [21、37] 包含的关键字的个数 2 等于 ⌈M/2⌉， 所以删除关键字 59 ，并将结点 [21、37] 和 [44] 进行合并 [21、37、44] ，然后向上回溯，将所有关键字 59 替换为次最大的关键字 44 :<br><img src="/img/v2-c33a70c8eaa38e96c3052a6bddc9d0d4_b.webp" alt></p>
<p>5、 当进行合并时，可能会产生因合并使其双亲结点破坏 B+树的结构，需要依照以上规律处理其双亲结点。</p>
<p>删除关键字 63，当删除关键字后，该结点中只剩关键字 72，且其兄弟结点 [85、91] 中只有 2 个关键字，所以将 [72] 和 [85、91] 进行合并，向上回溯，删除结点 [72、91] 当中的关键字 72 ，此时结点中只有关键 91 ，不满足 B+树中结点关键字个数要求，但其兄弟结点 [15、44、59] 中包含的 3 个关键字，所以从其兄弟结点当中借一个关键字 59 , 再对其兄弟结点的父结点中的关键字进行调整，将关键字 59 替换为 44 .<br><img src="/img/v2-ae4011609fdf74e80d10fefb9e47dbb8_b.gif" alt></p>
<p>总之，在 B+树中做删除关键字的操作，采取如下的步骤：</p>
<ul>
<li>删除该关键字，如果不破坏 B+树本身的性质，直接完成删除操作（情况 1）；</li>
<li>如果删除操作导致其该结点中最大（或最小）值改变，则应相应改动其父结点中的索引值（情况 2）；</li>
<li>在删除关键字后，如果导致其结点中关键字个数不足，有两种方法：一种是向兄弟结点去借，另外一种是同兄弟结点合并（情况 3、4 和 5）。（注意这两种方式有时需要更改其父结点中的索引值。）</li>
</ul>
<h1 id="B-树-2"><a href="#B-树-2" class="headerlink" title="B*树"></a>B*树</h1><p>是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针；<br><img src="/img/20211114005305.jpg" alt></p>
<p><code>B*</code>树定义了非叶子结点关键字个数至少为(2/3)*M，即块的最低使用率为2/3（代替B+树的1/2）；</p>
<p>B+树的分裂：当一个结点满时，分配一个新的结点，并将原结点中1/2的数据复制到新结点，最后在父结点中增加新结点的指针；B+树的分裂只影响原结点和父结点，而不会影响兄弟结点，所以它不需要指向兄弟的指针；</p>
<p><code>B*</code>树的分裂：当一个结点满时，如果它的下一个兄弟结点未满，那么将一部分数据移到兄弟结点中，再在原结点插入关键字，最后修改父结点中兄弟结点的关键字（因为兄弟结点的关键字范围改变了）；如果兄弟也满了，则在原结点与兄弟结点之间增加新结点，并各复制1/3的数据到新结点，最后在父结点增加新结点的指针；</p>
<p>所以，B*树分配新结点的概率比B+树要低，空间使用率更高；</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>根据B树的特点，我们首先可以写出B树的整体的结构。</p>
<h2 id="B树结构"><a href="#B树结构" class="headerlink" title="B树结构"></a>B树结构</h2><p>B树的结构我们定义需要参考规则，我们首先是需要给出保存键值的一个数组，这个数组的大小取决与我们定义的M，然后我们根据规则，可以得到一个保存M+1个子的一个数组，然后当然为了方便访问，parent指针，然后要有一个记录每个节点中键值个数的一个size。</p>
<p>所以定义如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K,<span class="keyword">int</span> M&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BTreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    K _keys[M];                     <span class="comment">//用来保存键值。</span></span><br><span class="line">    BTreeNode&lt;K, M&gt;* _sub[M + <span class="number">1</span>];   <span class="comment">//用来保存子。</span></span><br><span class="line">    BTreeNode&lt;K, M&gt;* _parent;</span><br><span class="line">    <span class="keyword">size_t</span> _size;</span><br><span class="line">    BTreeNode()</span><br><span class="line">        :_parent(<span class="literal">NULL</span>)</span><br><span class="line">        , _size(<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; M; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            _keys[i] = K();</span><br><span class="line">            _sub[i] = K();</span><br><span class="line">        &#125;</span><br><span class="line">        _sub[i] = K();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="B树的查找"><a href="#B树的查找" class="headerlink" title="B树的查找"></a>B树的查找</h2><p>对于AVL，BST，红黑树，B树这些高级的数据结构而言，查找算法是非常重要的。我们首先确定返回值，对于这种关于key和key-value的数据结构，参考map和set，我们让它返回一个pair的一个结构体。</p>
<p>pair结构体的定义在std中是<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> K,<span class="keyword">typename</span> V&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pair</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    K key;</span><br><span class="line">    V value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们只需要让这个里面的value变为bool值，value返回以后说明的是存不存就可以了。</p>
<p>接下来的思路就是从根节点进行和这个节点当中的每一个key比较，如果=那么就返回找到了，如果小于，那么就到这个节点左面的子节点中找，如果大了，就继续向后面的键值进行查找。如果相等那么就返回。</p>
<p>示例代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">pair &lt;Node*, <span class="keyword">int</span>&gt; Find(<span class="keyword">const</span> K &amp;key)</span><br><span class="line">    &#123;</span><br><span class="line">        Node* cur = _root;</span><br><span class="line">        Node* parent = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">size_t</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; cur-&gt;_size)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//如果小于当前，向后</span></span><br><span class="line">                <span class="keyword">if</span> (cur-&gt;_keys[i] &lt; key)</span><br><span class="line">                &#123;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果大于，</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (cur-&gt;_keys[i]&gt;key)</span><br><span class="line">                &#123;</span><br><span class="line">                    cur = cur-&gt;_sub[i];</span><br><span class="line">                    parent = cur;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//相等，返回这个节点</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> pair&lt;Node *, <span class="keyword">int</span>&gt;(<span class="literal">NULL</span>, <span class="number">-1</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (key &gt; cur-&gt;_sub[i + <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                cur = cur-&gt;_sub[i];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//为了防止出现我返回空指针操作，如果是空指针，那么就返回父亲</span></span><br><span class="line">            <span class="keyword">if</span> (cur != <span class="literal">NULL</span> &amp;&amp; i == cur-&gt;_size)</span><br><span class="line">            &#123;</span><br><span class="line">                parent = cur;</span><br><span class="line">                cur = cur-&gt;_sub[i];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pair&lt;Node *, <span class="keyword">int</span>&gt;(parent, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="B树的插入"><a href="#B树的插入" class="headerlink" title="B树的插入"></a>B树的插入</h2><p><img src="/img/20211114005324.jpg" alt></p>
<p>示例代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Insert</span><span class="params">(<span class="keyword">const</span> K &amp;key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//首先来考虑空树的情况</span></span><br><span class="line">    <span class="keyword">if</span> (_root == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//给这个节点中添加key，并且让size++。</span></span><br><span class="line">        _root = <span class="keyword">new</span> Node;</span><br><span class="line">        _root-&gt;_keys[<span class="number">0</span>] = key;</span><br><span class="line">        _root-&gt;_size++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//使用通用的key-value结构体来保存找到的key所在的节点。</span></span><br><span class="line"></span><br><span class="line">    pair&lt;Node*,<span class="keyword">int</span> &gt; ret=Find(key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在这里来看这个节点是否存在，存在就直接return false。</span></span><br><span class="line">    <span class="keyword">if</span> (ret.second == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node* cur = ret.first;</span><br><span class="line">    K newKey = key;</span><br><span class="line">    Node *sub = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//此时表示考虑插入。</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//向cur里面进行插入，如果没满插入，满了就进行分裂。</span></span><br><span class="line">        InsetKey(cur, newKey, sub);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//小于M，这样就可以直接插入</span></span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;_size &lt; M)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果==M，那么就应该进行分裂</span></span><br><span class="line">        <span class="comment">//首先找到中间的节点</span></span><br><span class="line">        <span class="keyword">size_t</span> mid = cur-&gt;_size / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//创建一个节点，用来保存中间节点右边所有的节点和子节点。</span></span><br><span class="line">        Node * tmp = <span class="keyword">new</span> Node;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">size_t</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//进行移动sub以及所有的子接点。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = mid + <span class="number">1</span>; i &lt; cur-&gt;_size; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp-&gt;_keys[j] = cur-&gt;_keys[i];</span><br><span class="line">            cur-&gt;_keys[i] = K();</span><br><span class="line">            cur-&gt;_size--;</span><br><span class="line">            tmp-&gt;_size++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//移动子串</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; tmp-&gt;_size + <span class="number">1</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp-&gt;_sub[j] = cur-&gt;_sub[mid + <span class="number">1</span> + j];</span><br><span class="line">            <span class="keyword">if</span> (tmp-&gt;_sub[j])</span><br><span class="line">            &#123;</span><br><span class="line">                tmp-&gt;_sub[j]-&gt;_parent = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            cur-&gt;_sub[mid + <span class="number">1</span> + j] = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//进行其他的移动</span></span><br><span class="line">        <span class="comment">//分裂的条件就是要么分裂根，要么就是分裂子节点，要么就是所在节点的节点数小于M。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//考虑根分裂，分裂的时候创建节点，然后把中间节点上拉，记得要更改最后的parent</span></span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;_parent == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            _root = <span class="keyword">new</span> Node();</span><br><span class="line">            _root-&gt;_keys[<span class="number">0</span>] = cur-&gt;_keys[mid];</span><br><span class="line">            cur-&gt;_keys[mid] = K();</span><br><span class="line">            cur-&gt;_size--;</span><br><span class="line">            _root-&gt;_size++;</span><br><span class="line"></span><br><span class="line">            _root-&gt;_sub[<span class="number">0</span>] = cur;</span><br><span class="line">            cur-&gt;_parent = _root;</span><br><span class="line"></span><br><span class="line">            _root-&gt;_sub[<span class="number">1</span>] = tmp;</span><br><span class="line">            tmp-&gt;_parent = _root;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//分裂如果不是根节点，那么就把mid节点插入到上一层节点中，然后看上一层节点是否要分裂。注意修改cur和sub</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            newKey = cur-&gt;_keys[mid];</span><br><span class="line">            cur-&gt;_keys[mid] = K();</span><br><span class="line">            cur-&gt;_size--;</span><br><span class="line">            cur = cur-&gt;_parent;</span><br><span class="line"></span><br><span class="line">            sub = tmp;</span><br><span class="line">            sub-&gt;_parent = cur;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsetKey</span><span class="params">(Node* cur, <span class="keyword">const</span> K &amp;key, Node* sub)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = cur-&gt;_size - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i&gt;=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//进行插入</span></span><br><span class="line">        <span class="keyword">if</span> (key &gt; cur-&gt;_keys[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//进行移动</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cur-&gt;_keys[i + <span class="number">1</span>] = cur-&gt;_keys[i];</span><br><span class="line">            cur-&gt;_sub[i + <span class="number">2</span>] = cur-&gt;_sub[i + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        i--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//进行插入</span></span><br><span class="line">    cur-&gt;_keys[i + <span class="number">1</span>] = key;</span><br><span class="line">    <span class="comment">//插入子</span></span><br><span class="line">    cur-&gt;_sub[i + <span class="number">2</span>] = sub;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果没满，只需要对size++；</span></span><br><span class="line">    <span class="keyword">if</span> (cur-&gt;_size &lt; M)</span><br><span class="line">    &#123;</span><br><span class="line">        cur-&gt;_size++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="MySQL-Innodb-索引的原理"><a href="#MySQL-Innodb-索引的原理" class="headerlink" title="MySQL(Innodb)索引的原理"></a>MySQL(Innodb)索引的原理</h1><h2 id="索引的科普"><a href="#索引的科普" class="headerlink" title="索引的科普"></a>索引的科普</h2><p>先引进聚簇索引和非聚簇索引的概念！我们平时在使用的Mysql中，使用下述语句<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE [UNIQUE|FULLTEXT|SPATIAL] INDEX index_name</span><br><span class="line">    [USING index_type]</span><br><span class="line">    ON tbl_name (index_col_name,...)</span><br><span class="line"> </span><br><span class="line">index_col_name:</span><br><span class="line">    col_name [(length)] [ASC | DESC]</span><br></pre></td></tr></table></figure></p>
<p>创建的索引，如复合索引、前缀索引、唯一索引，都是属于非聚簇索引，在有的书籍中，又将其称为辅助索引(secondary index)。在后文中，我们称其为非聚簇索引，其数据结构为B+树。</p>
<p>那么，这个聚簇索引，在Mysql中是没有语句来另外生成的。在Innodb中，Mysql中的数据是按照主键的顺序来存放的。那么聚簇索引就是按照每张表的主键来构造一颗B+树，叶子节点存放的就是整张表的行数据。由于表里的数据只能按照一颗B+树排序，因此一张表只能有一个聚簇索引。</p>
<p>在Innodb中，聚簇索引默认就是主键索引。</p>
<p>如果没有主键，则按照下列规则来建聚簇索引</p>
<ul>
<li>没有主键时，会用一个唯一且不为空的索引列做为主键，成为此表的聚簇索引</li>
<li>如果没有这样的索引，InnoDB会隐式定义一个主键来作为聚簇索引。</li>
</ul>
<h2 id="索引原理介绍"><a href="#索引原理介绍" class="headerlink" title="索引原理介绍"></a>索引原理介绍</h2><p>先来一张带主键的表，如下所示，pId是主键</p>
<table>
<thead>
<tr>
<th>pId</th>
<th>name</th>
<th>birthday</th>
</tr>
</thead>
<tbody>
<tr>
<td>5</td>
<td>zhangsan</td>
<td>2016-10-02</td>
</tr>
<tr>
<td>8</td>
<td>lisi</td>
<td>2015-10-04</td>
</tr>
<tr>
<td>11</td>
<td>wangwu</td>
<td>2016-09-02</td>
</tr>
<tr>
<td>13</td>
<td>zhaoliu</td>
<td>2015-10-07</td>
</tr>
</tbody>
</table>
<p>画出该表的结构图如下<br><img src="/img/20211114114100.png" alt></p>
<p>如上图所示，分为上下两个部分，上半部分是由主键形成的B+树，下半部分就是磁盘上真实的数据！那么，当我们， 执行下面的语句<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> pId=<span class="string">'11'</span></span><br></pre></td></tr></table></figure></p>
<p>那么，执行过程如下<br><img src="/img/20211114114101.png" alt></p>
<p>如上图所示，从根开始，经过3次查找，就可以找到真实数据。如果不使用索引，那就要在磁盘上，进行逐行扫描，直到找到数据位置。显然，使用索引速度会快。但是在写入数据的时候，需要维护这颗B+树的结构，因此写入性能会下降！<br>OK，接下来引入非聚簇索引!我们执行下面的语句<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> index_name <span class="keyword">on</span> <span class="keyword">table</span>(<span class="keyword">name</span>);</span><br></pre></td></tr></table></figure></p>
<p>此时结构图如下所示<br><img src="/img/20211114114102.png" alt></p>
<p>大家注意看，会根据你的索引字段生成一颗新的B+树。因此， 我们每加一个索引，就会增加表的体积， 占用磁盘存储空间。然而，注意看叶子节点，非聚簇索引的叶子节点并不是真实数据，它的叶子节点依然是索引节点，存放的是该索引字段的值以及对应的主键索引(聚簇索引)。<br>如果我们执行下列语句<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'lisi'</span></span><br></pre></td></tr></table></figure></p>
<p>此时结构图如下所示<br><img src="/img/20211114114103.png" alt></p>
<p>通过上图红线可以看出，先从非聚簇索引树开始查找，然后找到聚簇索引后。根据聚簇索引，在聚簇索引的B+树上，找到完整的数据！<br>那</p>
<p>什么情况不去聚簇索引树上查询呢？</p>
<p>还记得我们的非聚簇索引树上存着该索引字段的值么。如果，此时我们执行下面的语句<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'lisi'</span></span><br></pre></td></tr></table></figure></p>
<p>此时结构图如下<br><img src="/img/20211114114104.png" alt></p>
<p>如上图红线所示，如果在非聚簇索引树上找到了想要的值，就不会去聚簇索引树上查询。</p>
<p>当执行<code>select col from table where col = ?，col</code>上有索引的时候，效率比执行<code>select * from table where col = ?</code>速度快好几倍！</p>
<p>那么这个时候，我们执行了下述语句，又会发生什么呢？<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> index_birthday <span class="keyword">on</span> <span class="keyword">table</span>(birthday);</span><br></pre></td></tr></table></figure></p>
<p>此时结构图如下<br><img src="/img/20211114114105.png" alt></p>
<p>多加一个索引，就会多生成一颗非聚簇索引树。因此，很多文章才说，索引不能乱加。因为，有几个索引，就有几颗非聚簇索引树！你在做插入操作的时候，需要同时维护这几颗树的变化！因此，如果索引太多，插入性能就会下降!</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/算法/" rel="tag"># 算法</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/11/14/B树家族/" rel="next" title="B树家族">
                <i class="fa fa-chevron-left"></i> B树家族
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/11/14/TCMalloc的使用与源码剖析/" rel="prev" title="TCMalloc的使用与源码剖析">
                TCMalloc的使用与源码剖析 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/header.jpg" alt="Hao Yu">
            
              <p class="site-author-name" itemprop="name">Hao Yu</p>
              <p class="site-description motion-element" itemprop="description">Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author</p>
          </div>
          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">342</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>
        	<audio controls="controls" loop="loop" preload="auto" src="/resource/xiaomeihao.mp3">
	        </audio>
	

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yuhao0102" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:yuh18@mails.tsinghua.edu.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#二叉树"><span class="nav-number">1.</span> <span class="nav-text">二叉树</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-3-树"><span class="nav-number">2.</span> <span class="nav-text">2-3 树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-树性质"><span class="nav-number">2.1.</span> <span class="nav-text">2-3 树性质</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3树查找"><span class="nav-number">2.2.</span> <span class="nav-text">2-3树查找</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3树插入"><span class="nav-number">2.3.</span> <span class="nav-text">2-3树插入</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3树删除"><span class="nav-number">2.4.</span> <span class="nav-text">2-3树删除</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#删除非叶子节点"><span class="nav-number">2.4.1.</span> <span class="nav-text">删除非叶子节点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-4树"><span class="nav-number">2.5.</span> <span class="nav-text">2-3-4树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">2.6.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#B-树"><span class="nav-number">3.</span> <span class="nav-text">B-树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#插入"><span class="nav-number">3.1.</span> <span class="nav-text">插入</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#删除"><span class="nav-number">3.2.</span> <span class="nav-text">删除</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#删除操作"><span class="nav-number">3.3.</span> <span class="nav-text">删除操作</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#B-树-1"><span class="nav-number">4.</span> <span class="nav-text">B+树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#查找操作"><span class="nav-number">4.1.</span> <span class="nav-text">查找操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#B-树的插入操作"><span class="nav-number">4.2.</span> <span class="nav-text">B+树的插入操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#B-树的删除操作"><span class="nav-number">4.3.</span> <span class="nav-text">B+树的删除操作</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#B-树-2"><span class="nav-number">5.</span> <span class="nav-text">B*树</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#实现"><span class="nav-number">6.</span> <span class="nav-text">实现</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#B树结构"><span class="nav-number">6.1.</span> <span class="nav-text">B树结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#B树的查找"><span class="nav-number">6.2.</span> <span class="nav-text">B树的查找</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#B树的插入"><span class="nav-number">6.3.</span> <span class="nav-text">B树的插入</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MySQL-Innodb-索引的原理"><span class="nav-number">7.</span> <span class="nav-text">MySQL(Innodb)索引的原理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#索引的科普"><span class="nav-number">7.1.</span> <span class="nav-text">索引的科普</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#索引原理介绍"><span class="nav-number">7.2.</span> <span class="nav-text">索引原理介绍</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>
  <div id="DvelopmentTarget">     
  </div>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart" aria-hidden="false"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>

  
</div>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_uv"> 
  本站访客数<span id="busuanzi_value_site_uv"></span>人次
</span>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  


  <script type="text/javascript" src="/js/src/love.js"></script>

</body>
</html>
