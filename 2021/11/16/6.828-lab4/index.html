<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zn-ch">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-center-simple.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="操作系统,">










<meta name="description" content="简介在 lab4 中我们将实现多个同时运行的用户进程之间的抢占式多任务处理。  在 part A 中，我们需要给 JOS 增加多处理器支持。实现轮询( round-robin, RR )调度，并增加基本的用户程序管理系统调用( 创建和销毁进程，分配和映射内存 )。 在 part B 中，我们需要实现一个与 Unix 类似的fork()，允许一个用户进程创建自己的拷贝。 在 part C中，我们会添">
<meta name="keywords" content="操作系统">
<meta property="og:type" content="article">
<meta property="og:title" content="6.828 lab4">
<meta property="og:url" content="http://yoursite.com/2021/11/16/6.828-lab4/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="简介在 lab4 中我们将实现多个同时运行的用户进程之间的抢占式多任务处理。  在 part A 中，我们需要给 JOS 增加多处理器支持。实现轮询( round-robin, RR )调度，并增加基本的用户程序管理系统调用( 创建和销毁进程，分配和映射内存 )。 在 part B 中，我们需要实现一个与 Unix 类似的fork()，允许一个用户进程创建自己的拷贝。 在 part C中，我们会添">
<meta property="og:locale" content="zn-ch">
<meta property="og:image" content="http://yoursite.com/img/20211124224000.png">
<meta property="og:image" content="http://yoursite.com/img/20211124224001.png">
<meta property="og:updated_time" content="2021-12-01T08:27:02.809Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="6.828 lab4">
<meta name="twitter:description" content="简介在 lab4 中我们将实现多个同时运行的用户进程之间的抢占式多任务处理。  在 part A 中，我们需要给 JOS 增加多处理器支持。实现轮询( round-robin, RR )调度，并增加基本的用户程序管理系统调用( 创建和销毁进程，分配和映射内存 )。 在 part B 中，我们需要实现一个与 Unix 类似的fork()，允许一个用户进程创建自己的拷贝。 在 part C中，我们会添">
<meta name="twitter:image" content="http://yoursite.com/img/20211124224000.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2021/11/16/6.828-lab4/">





  <title>6.828 lab4 | Hao Yu's blog</title>
  








 
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zn-ch">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hao Yu's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">The program monkey was eaten by the siege lion.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/resume.pdf" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-mybetterhalf">
          <a href="/mybetterhalf/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>
            
            mybetterhalf
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/11/16/6.828-lab4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">6.828 lab4</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-11-16T15:28:00+08:00">
                2021-11-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>在 lab4 中我们将实现多个同时运行的用户进程之间的抢占式多任务处理。</p>
<ul>
<li>在 part A 中，我们需要给 JOS 增加多处理器支持。实现轮询( round-robin, RR )调度，并增加基本的用户程序管理系统调用( 创建和销毁进程，分配和映射内存 )。</li>
<li>在 part B 中，我们需要实现一个与 Unix 类似的<code>fork()</code>，允许一个用户进程创建自己的拷贝。</li>
<li>在 part C中，我们会添加对进程间通信 ( IPC ) 的支持，允许不同的用户进程相互通信和同步。还要增加对硬件时钟中断和抢占的支持。</li>
</ul>
<p>Lab 4 包含许多新的源文件：</p>
<ul>
<li><code>kern/cpu.h</code>：多处理器支持的内核私有定义</li>
<li><code>kern/mpconfig.c</code>：读取多处理器配置的代码</li>
<li><code>kern/lapic.c</code>：驱动每个处理器中的本地 APIC 单元的内核代码</li>
<li><code>kern/mpentry.S</code>：非引导 CPU 的汇编语言入口代码</li>
<li><code>kern/spinlock.h</code>：自旋锁的内核私有定义，包括大内核锁</li>
<li><code>kern/spinlock.c</code>：实现自旋锁的内核代码</li>
<li><code>kern/sched.c</code>：将要实现的调度程序的代码框架</li>
</ul>
<h1 id="Part-A-多处理器支持及协同多任务处理"><a href="#Part-A-多处理器支持及协同多任务处理" class="headerlink" title="Part A: 多处理器支持及协同多任务处理"></a>Part A: 多处理器支持及协同多任务处理</h1><p>我们首先需要把 JOS 扩展到在多处理器系统中运行。然后实现一些新的 JOS 系统调用来允许用户进程创建新的进程。我们还要实现协同轮询调度，在当前进程不使用 CPU 时允许内核切换到另一个进程。</p>
<h2 id="多处理器支持"><a href="#多处理器支持" class="headerlink" title="多处理器支持"></a>多处理器支持</h2><p>我们即将使 JOS 能够支持“对称多处理” (Symmetric MultiProcessing, SMP)。这种模式使所有 CPU 能对等地访问内存、I/O 总线等系统资源。虽然 CPU 在 SMP 下以同样的方式工作，在启动过程中他们可以被分为两个类型：</p>
<ul>
<li>引导处理器(BootStrap Processor, BSP) 负责初始化系统以及启动操作系统；</li>
<li>应用处理器( Application Processors, AP ) 在操作系统拉起并运行后由 BSP 激活。</li>
</ul>
<p>哪个 CPU 作为 BSP 由硬件和 BIOS 决定。也就是说目前我们所有的 JOS 代码都运行在 BSP 上。</p>
<p>在 SMP 系统中，每个 CPU 都有一个附属的 (local APIC) LAPIC 单元。LAPIC 单元用于传递中断，并给它所属的 CPU 一个唯一的 ID。在 lab4 中，我们将会用到 LAPIC 单元的以下基本功能 ( 见<code>kern/lapic.c1</code>)：</p>
<ul>
<li>读取 APIC ID 来判断我们的代码运行在哪个 CPU 之上。</li>
<li>从 BSP 发送 STARTUP 跨处理器中断 (InterProcessor Interrupt, IPI) 来启动 AP。</li>
<li>在 part C 中，我们为 LAPIC 的内置计时器编程来触发时钟中断以支持抢占式多任务处理。</li>
</ul>
<p>处理器通过映射在内存上的 I/O (Memory-Mapped I/O, MMIO) 来访问它的 LAPIC。在 MMIO 中，物理内存的一部分被硬连接到一些 I/O 设备的寄存器，因此，访问内存的 load/store 指令可以被用于访问设备的寄存器。实际上，我们在 lab1 中已经接触过这样的 IO hole，如0xA0000被用来写 VGA 显示缓冲。</p>
<p>LAPIC 开始于物理地址 0xFE000000 ( 4GB以下32MB处 )。如果用以前的映射算法（将0xF0000000 映射到 0x00000000，也就是说内核空间最高只能到物理地址0x0FFFFFFF）显然太高了。因此，JOS 在<code>MMIOBASE</code>(即 虚拟地址0xEF800000) 预留了 4MB 来映射这类设备。我们需要写一个函数来分配这个空间并在其中映射设备内存。</p>
<p>exercise1需要实现<code>kern/pmap.c</code>中的<code>mmio_map_region</code>。首先还得去看<code>kern/lapic.c</code>中<code>lapic_init</code>的实现。<code>lapic_init()</code>函数的一开始就调用了该函数，将从<code>lapicaddr</code>开始的 4kB 物理地址映射到虚拟地址，并返回其起始地址。注意到，它是以页为单位对齐的，每次都<code>map</code>一个页的大小。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">lapic_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">if</span> (!lapicaddr)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// lapicaddr is the physical address of the LAPIC's 4K MMIO</span></span><br><span class="line">        <span class="comment">// region.  Map it in to virtual memory so we can access it.</span></span><br><span class="line">        lapic = mmio_map_region(lapicaddr, <span class="number">4096</span>);</span><br><span class="line">        .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从基址开始保留大小字节的虚拟内存并将物理页 [pa,pa+size) 映射到虚拟地址 [base,base+size)。 由于这是设备内存而不是常规 DRAM，因此您必须告诉 CPU 缓存访问此内存是不安全的。幸运的是，分页表为此提供了位；除了<code>PTE_W</code>之外，只需使用<code>PTE_PCD|PTE_PWT</code>（缓存禁用和直写）创建映射。</p>
<p>实际就是调用<code>boot_map_region</code>来建立所需要的映射，需要注意的是，每次需要更改base的值，使得每次都是映射到一个新的页面。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Reserve size bytes in the MMIO region and map [pa,pa+size) at this</span></span><br><span class="line"><span class="comment">// location.  Return the base of the reserved region.  size does *not*</span></span><br><span class="line"><span class="comment">// have to be multiple of PGSIZE.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">void</span> *</span><br><span class="line">mmio_map_region(<span class="keyword">physaddr_t</span> pa, <span class="keyword">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">physaddr_t</span> pa_begin = ROUNDDOWN(pa, PGSIZE);</span><br><span class="line">	<span class="keyword">physaddr_t</span> pa_end = ROUNDUP(pa + size, PGSIZE);</span><br><span class="line">	<span class="keyword">if</span> (pa_end - pa_begin &gt;= MMIOLIM - MMIOBASE) &#123;</span><br><span class="line">	    panic(<span class="string">"mmio_map_region: requesting size too large.\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	size = pa_end - pa_begin;</span><br><span class="line">	boot_map_region(kern_pgdir, base, size, pa_begin, PTE_W | PTE_PCD | PTE_PWT);</span><br><span class="line">	<span class="keyword">void</span> *ret = (<span class="keyword">void</span> *)base;</span><br><span class="line">	base += size;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="引导应用处理器"><a href="#引导应用处理器" class="headerlink" title="引导应用处理器"></a>引导应用处理器</h2><p>在启动 APs 之前，<code>BSP</code>需要先搜集多处理器系统的信息，例如 CPU 的总数，CPU 各自的 APIC ID，LAPIC 单元的 MMIO 地址。<code>kern/mpconfig.c</code>中的<code>mp_init()</code>函数通过阅读 BIOS 区域内存中的 MP 配置表来获取这些信息。</p>
<p><code>boot_aps()</code>函数驱动了 AP 的引导。APs 从实模式开始，如同<code>boot/boot.S</code>中<code>bootloader</code>的启动过程。因此<code>boot_aps()</code>将 AP 的入口代码 (<code>kern/mpentry.S</code>) 拷贝到实模式可以寻址的内存区域 (0x7000,<code>MPENTRY_PADDR</code>)。</p>
<p>此后，<code>boot_aps()</code>通过发送<code>STARTUP</code>这个跨处理器中断到各 LAPIC 单元的方式，逐个激活 APs。激活方式为：初始化 AP 的<code>CS:IP</code>值使其从入口代码执行（<code>MPENTRY_PADDR</code>）。<code>kern/mpentry.S</code>中的入口代码跟<code>boot/boot.S</code>中的代码相同。通过一些简单的设置，AP 开启分页进入保护模式，然后调用 C 语言编写的<code>mp_main()</code>。<code>boot_aps()</code>等待 AP 发送<code>CPU_STARTED</code>信号，然后再唤醒下一个。</p>
<p>先看<code>boot_aps()</code>，注释比较清楚，将入口代码复制到<code>MPENTRY_PADDR</code>中，遍历cpu，告诉<code>mpentry.S</code>栈的入口在哪，函数<code>lapic_startup</code>向指定处理器发送信号，触发了中断，让处理器从指定地址开始执行。APIC更具体的操作细节我们就不关心了。启动，等待完成。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Start the non-boot (AP) processors.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">boot_aps(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> mpentry_start[], mpentry_end[];</span><br><span class="line">    <span class="keyword">void</span> *code;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CpuInfo</span> *<span class="title">c</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write entry code to unused memory at MPENTRY_PADDR</span></span><br><span class="line">    code = KADDR(MPENTRY_PADDR);</span><br><span class="line">    memmove(code, mpentry_start, mpentry_end - mpentry_start);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Boot each AP one at a time</span></span><br><span class="line">    <span class="keyword">for</span> (c = cpus; c &lt; cpus + ncpu; c++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == cpus + cpunum())  <span class="comment">// We've started already.</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Tell mpentry.S what stack to use</span></span><br><span class="line">        mpentry_kstack = percpu_kstacks[c - cpus] + KSTKSIZE;</span><br><span class="line">        <span class="comment">// Start the CPU at mpentry_start</span></span><br><span class="line">        lapic_startap(c-&gt;cpu_id, PADDR(code));</span><br><span class="line">        <span class="comment">// Wait for the CPU to finish some basic setup in mp_main()</span></span><br><span class="line">        <span class="keyword">while</span>(c-&gt;cpu_status != CPU_STARTED)</span><br><span class="line">            ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在<code>mpentry.S</code>中，每一个没有启动的CPU(“AP”)都会因为一个<code>STARTUP</code>中断而启动。AP启动时，<code>CS:IP</code>会被设置成<code>XY00:0000</code>，<code>XY</code>是跟着<code>STARTUP</code>一起送过来的值。</p>
<p>代码中设置<code>DS</code>为0，必须从物理地址中的低2^16字节开始运行。</p>
<p>在系统加载的过程中，<code>boot_aps()</code>被调用，然后按照前文所述使用<code>memmove()</code>函数从<code>mpentry.S</code>中拷贝文件中<code>.global mpentry_start</code>标签处开始的入口代码直到<code>.global mpentry_end</code>结束，代码被拷贝到<code>MPENTRY_PADDR</code>（此处是0x7000的I/O hole）对应的内核虚拟地址（别忘了必须拷贝到内核虚拟地址才可以被内核所操作）。然后<code>boot_aps()</code>根据每一个CPU的栈配置<code>percpu_kstacks[]</code>来为每一个AP设置栈地址<code>mpentry_stack</code>。再之后调用<code>lapic_startup()</code>函数来启动AP，并等待AP的状态变为<code>CPU_STARTED</code>以切换到下一个AP的配置。AP启动后会开启分页机制和保护模式，切换运行栈，然后跳转到<code>mp_main()</code>函数。</p>
<p>在<code>mp_main()</code>函数中，使用<code>lcr3</code>指令切换页目录到<code>kern_pgdir</code>，初始化LAPIC、用户环境和陷阱处理机制。最后设置<code>struct CpuInfo</code>中的<code>cpu_status</code>为<code>CPU_STARTED</code>来告知BPS已经启动成功。</p>
<p>此代码类似于<code>boot/boot.S</code>，不同之处在于</p>
<ul>
<li>不需要启用A20</li>
<li>它使用<code>MPBOOTPHYS</code>计算其绝对地址符号，而不是依赖链接器来填充它们</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">.set PROT_MODE_CSEG, 0x8        # kernel code segment selector</span><br><span class="line">.set PROT_MODE_DSEG, 0x10       # kernel data segment selector</span><br><span class="line"></span><br><span class="line">.code16</span><br><span class="line">.globl mpentry_start</span><br><span class="line">mpentry_start:</span><br><span class="line">        cli</span><br><span class="line"></span><br><span class="line">        xorw    %ax, %ax</span><br><span class="line">        movw    %ax, %ds</span><br><span class="line">        movw    %ax, %es</span><br><span class="line">        movw    %ax, %ss</span><br><span class="line"></span><br><span class="line">        lgdt    MPBOOTPHYS(gdtdesc)</span><br><span class="line">        movl    %cr0, %eax</span><br><span class="line">        orl     $CR0_PE, %eax</span><br><span class="line">        movl    %eax, %cr0</span><br><span class="line"></span><br><span class="line">        ljmpl   $(PROT_MODE_CSEG), $(MPBOOTPHYS(start32))</span><br><span class="line"></span><br><span class="line">.code32</span><br><span class="line">start32:</span><br><span class="line">        movw    $(PROT_MODE_DSEG), %ax</span><br><span class="line">        movw    %ax, %ds</span><br><span class="line">        movw    %ax, %es</span><br><span class="line">        movw    %ax, %ss</span><br><span class="line">        movw    $0, %ax</span><br><span class="line">        movw    %ax, %fs</span><br><span class="line">        movw    %ax, %gs</span><br><span class="line"></span><br><span class="line">        # Set up initial page table. We cannot use kern_pgdir yet because</span><br><span class="line">        # we are still running at a low EIP.</span><br><span class="line">        movl    $(RELOC(entry_pgdir)), %eax</span><br><span class="line">        movl    %eax, %cr3</span><br><span class="line">        # Turn on paging.</span><br><span class="line">        movl    %cr0, %eax</span><br><span class="line">        orl     $(CR0_PE|CR0_PG|CR0_WP), %eax</span><br><span class="line">        movl    %eax, %cr0</span><br><span class="line"></span><br><span class="line">        # Switch to the per-cpu stack allocated in boot_aps()</span><br><span class="line">        movl    mpentry_kstack, %esp</span><br><span class="line">        movl    $0x0, %ebp       # nuke frame pointer</span><br><span class="line"></span><br><span class="line">        # Call mp_main().  (Exercise for the reader: why the indirect call?)</span><br><span class="line">        movl    $mp_main, %eax</span><br><span class="line">        call    *%eax</span><br><span class="line"></span><br><span class="line">        # If mp_main returns (it shouldn&apos;t), loop.</span><br><span class="line">spin:</span><br><span class="line">        jmp     spin</span><br><span class="line"></span><br><span class="line"># Bootstrap GDT</span><br><span class="line">.p2align 2                                      # force 4 byte alignment</span><br><span class="line">gdt:</span><br><span class="line">        SEG_NULL                                # null seg</span><br><span class="line">        SEG(STA_X|STA_R, 0x0, 0xffffffff)       # code seg</span><br><span class="line">        SEG(STA_W, 0x0, 0xffffffff)             # data seg</span><br><span class="line"></span><br><span class="line">gdtdesc:</span><br><span class="line">        .word   0x17                            # sizeof(gdt) - 1</span><br><span class="line">        .long   MPBOOTPHYS(gdt)                 # address gdt</span><br><span class="line"></span><br><span class="line">.globl mpentry_end</span><br><span class="line">mpentry_end:</span><br><span class="line">        nop</span><br></pre></td></tr></table></figure>
<p>我们修改文件<code>kern/pmap.c</code>中的函数<code>page_init</code>，在构建链表的时候避开AP使用的引导器的地址。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">page_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// LAB 4:</span></span><br><span class="line">    <span class="comment">// Change your code to mark the physical page at MPENTRY_PADDR as in use</span></span><br><span class="line"></span><br><span class="line">    pages[<span class="number">0</span>].pp_ref = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> mp_page = MPENTRY_PADDR / PGSIZE;</span><br><span class="line">    <span class="keyword">size_t</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; npages_basemem; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == mp_page) &#123; <span class="comment">// lab 4</span></span><br><span class="line">            pages[i].pp_ref = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pages[i].pp_ref = <span class="number">0</span>;</span><br><span class="line">        pages[i].pp_link = page_free_list;</span><br><span class="line">        page_free_list = &amp;pages[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  3) Then comes the IO hole [IOPHYSMEM, EXTPHYSMEM), which must never be allocated.</span></span><br><span class="line">    <span class="keyword">for</span> (i = IOPHYSMEM/PGSIZE; i &lt; EXTPHYSMEM/PGSIZE; i++) &#123;</span><br><span class="line">        pages[i].pp_ref = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  4) Then extended memory [EXTPHYSMEM, ...).</span></span><br><span class="line">    <span class="keyword">size_t</span> first_free_address = PADDR(boot_alloc(<span class="number">0</span>)) / PGSIZE;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; first_free_address; i++) &#123;</span><br><span class="line">        pages[i].pp_ref = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; npages; i++) &#123;</span><br><span class="line">        pages[i].pp_ref = <span class="number">0</span>;</span><br><span class="line">        pages[i].pp_link = page_free_list;</span><br><span class="line">        page_free_list = &amp;pages[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在执行<code>make qemu</code>，可以通过<code>check_kern_pgdir()</code>测试，但是不会通过<code>check_kern_pgdir()</code>检查。</p>
<p><code>kern/mpentry.S</code>是运行在<code>KERNBASE</code>之上的，与其他的内核代码一样。也就是说，类似于<code>mpentry_start</code>，<code>mpentry_end</code>，<code>start32</code>这类地址，都位于<code>0xf0000000</code>之上，显然，实模式是无法寻址的。再仔细看<code>MPBOOTPHYS</code>的定义：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MPBOOTPHYS(s) ((s) - mpentry_start + MPENTRY_PADDR)</span></span><br></pre></td></tr></table></figure></p>
<p>其意义可以表示为，从<code>mpentry_start</code>到<code>MPENTRY_PADDR</code>建立映射，将<code>mpentry_start + offset</code>地址转为<code>MPENTRY_PADDR + offset</code>地址。查看<code>kern/init.c</code>，发现已经完成了这部分地址的内容拷贝。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">boot_aps(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> mpentry_start[], mpentry_end[];</span><br><span class="line">    <span class="keyword">void</span> *code;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CpuInfo</span> *<span class="title">c</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write entry code to unused memory at MPENTRY_PADDR</span></span><br><span class="line">    code = KADDR(MPENTRY_PADDR);</span><br><span class="line">    memmove(code, mpentry_start, mpentry_end - mpentry_start);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因此，实模式下就可以通过<code>MPBOOTPHYS</code>宏的转换，运行这部分代码。<code>boot.S</code>中不需要这个转换是因为代码的本来就被加载在实模式可以寻址的地方。</p>
<h2 id="CPU-状态和初始化"><a href="#CPU-状态和初始化" class="headerlink" title="CPU 状态和初始化"></a>CPU 状态和初始化</h2><p>当写一个多处理器操作系统时，分清 CPU 的私有状态 ( per-CPU state) 及全局状态 (global state) 非常关键。<code>kern/cpu.h</code>定义了大部分的 per-CPU 状态。我们需要注意的 per-CPU 状态有：</p>
<ul>
<li>Per-CPU 内核栈<ul>
<li>因为多 CPU 可能同时陷入内核态，我们需要给每个处理器一个独立的内核栈。<code>percpu_kstacks[NCPU][KSTKSIZE]</code></li>
<li>在 Lab2 中，我们将<code>BSP</code>的内核栈映射到了<code>KSTACKTOP</code>下方。相似地，在 Lab4 中，我们需要把每个 CPU 的内核栈都映射到这个区域，每个栈之间留下一个空页作为缓冲区避免<code>overflow</code>。CPU 0 ，即<code>BSP</code>的栈还是从<code>KSTACKTOP</code>开始，间隔<code>KSTACKGAP</code>的距离就是 CPU 1 的栈，以此类推。</li>
</ul>
</li>
<li>Per-CPU TSS 以及 TSS 描述符<ul>
<li>为了指明每个 CPU 的内核栈位置，需要任务状态段 (Task State Segment, TSS)，其功能在 Lab3 中已经详细讲过。</li>
</ul>
</li>
<li>Per-CPU 当前环境指针<ul>
<li>因为每个 CPU 能够同时运行各自的用户进程，我们重新定义了基于<code>cpus[cpunum()]</code>的<code>curenv</code>。</li>
</ul>
</li>
<li>Per-CPU 系统寄存器<ul>
<li>所有的寄存器，包括系统寄存器，都是 CPU 私有的。因此，初始化这些寄存器的指令，例如<code>lcr3()</code>,<code>ltr()</code>,<code>lgdt()</code>,<code>lidt()</code>等，必须在每个 CPU 都执行一次。</li>
</ul>
</li>
</ul>
<p>在<code>kern/cpu.h</code>中可以找到对<code>NCPU</code>、CPU状态、<code>CpuInfo</code>以及全局变量<code>percpu_kstacks</code>的声明。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Maximum number of CPUs</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NCPU  8</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    CPU_UNUSED = <span class="number">0</span>,</span><br><span class="line">    CPU_STARTED,</span><br><span class="line">    CPU_HALTED,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// Per-CPU state</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CpuInfo</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> cpu_id;                 <span class="comment">// Local APIC ID; index into cpus[] below</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">unsigned</span> cpu_status;   <span class="comment">// The status of the CPU</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">cpu_env</span>;</span>            <span class="comment">// The currently-running environment.</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Taskstate</span> <span class="title">cpu_ts</span>;</span>        <span class="comment">// Used by x86 to find stack for interrupt</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// Per-CPU kernel stacks</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> percpu_kstacks[NCPU][KSTKSIZE];</span><br></pre></td></tr></table></figure></p>
<p><code>percpu_kstacks</code>的定义在<code>kern/mpconfig.c</code>中可以找到，以<code>PGSIZE</code>对齐：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Per-CPU kernel stacks</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> percpu_kstacks[NCPU][KSTKSIZE]</span><br><span class="line">__attribute__ ((aligned(PGSIZE)));</span><br></pre></td></tr></table></figure></p>
<p><code>mp_init()</code>是进行初始化的函数，首先设置一个初始cpu，之后对每个CPU进行处理。先通过调用<code>mpconfig()</code>找到<code>struct mpconf</code>然后根据这个结构体内的<code>entries</code>信息对各个ＣＰＵ结构体进行配置．</p>
<p>如果<code>proc-&gt;flag</code>是<code>MPPROC_BOOT</code>，说明这个入口对应的处理器是用于启动的处理器，我们把结构体数组<code>cpus[ncpu]</code>地址赋值给<code>bootcpu</code>指针．注意这里ncpu是个全局变量，那么这里实质上就是把cpus数组的第一个元素的地址给了<code>bootcpu</code>. </p>
<p>那个<code>ismp</code>是个全局变量，默认的初始值为0, 但是我们进行<code>mp_init()</code>的时候，就把这个全局变量置为1了，如果出现任何entries匹配错误(switch找不到对应项，跳进default)，这个时候我们多可处理器的初始化就失败了，不能用多核处理器进行机器的运行，于是<code>ismp</code>置为0<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">mp_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mp</span> *<span class="title">mp</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mpconf</span> *<span class="title">conf</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mpproc</span> *<span class="title">proc</span>;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> *p;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    bootcpu = &amp;cpus[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> ((conf = mpconfig(&amp;mp)) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    ismp = <span class="number">1</span>;</span><br><span class="line">    lapicaddr = conf-&gt;lapicaddr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (p = conf-&gt;entries, i = <span class="number">0</span>; i &lt; conf-&gt;entry; i++) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (*p) &#123;</span><br><span class="line">        <span class="keyword">case</span> MPPROC:</span><br><span class="line">            proc = (struct mpproc *)p;</span><br><span class="line">            <span class="keyword">if</span> (proc-&gt;flags &amp; MPPROC_BOOT)</span><br><span class="line">                bootcpu = &amp;cpus[ncpu];</span><br><span class="line">            <span class="keyword">if</span> (ncpu &lt; NCPU) &#123;</span><br><span class="line">                cpus[ncpu].cpu_id = ncpu;</span><br><span class="line">                ncpu++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cprintf(<span class="string">"SMP: too many CPUs, CPU %d disabled\n"</span>,</span><br><span class="line">                       proc-&gt;apicid);</span><br><span class="line">            &#125;</span><br><span class="line">            p += <span class="keyword">sizeof</span>(struct mpproc);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">case</span> MPBUS:</span><br><span class="line">        <span class="keyword">case</span> MPIOAPIC:</span><br><span class="line">        <span class="keyword">case</span> MPIOINTR:</span><br><span class="line">        <span class="keyword">case</span> MPLINTR:</span><br><span class="line">            p += <span class="number">8</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            cprintf(<span class="string">"mpinit: unknown config type %x\n"</span>, *p);</span><br><span class="line">            ismp = <span class="number">0</span>;</span><br><span class="line">            i = conf-&gt;entry;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bootcpu-&gt;cpu_status = CPU_STARTED;</span><br><span class="line">    <span class="keyword">if</span> (!ismp) &#123;</span><br><span class="line">        <span class="comment">// Didn't like what we found; fall back to no MP.</span></span><br><span class="line">        ncpu = <span class="number">1</span>;</span><br><span class="line">        lapicaddr = <span class="number">0</span>;</span><br><span class="line">        cprintf(<span class="string">"SMP: configuration not found, SMP disabled\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        cprintf(<span class="string">"SMP: CPU %d found %d CPU(s)\n"</span>, bootcpu-&gt;cpu_id,  ncpu);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mp-&gt;imcrp) &#123;</span><br><span class="line">        <span class="comment">// [MP 3.2.6.1] If the hardware implements PIC mode,</span></span><br><span class="line">        <span class="comment">// switch to getting interrupts from the LAPIC.</span></span><br><span class="line">        cprintf(<span class="string">"SMP: Setting IMCR to switch from PIC mode to symmetric I/O mode\n"</span>);</span><br><span class="line">        outb(<span class="number">0x22</span>, <span class="number">0x70</span>);   <span class="comment">// Select IMCR</span></span><br><span class="line">        outb(<span class="number">0x23</span>, inb(<span class="number">0x23</span>) | <span class="number">1</span>);  <span class="comment">// Mask external interrupts.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>处理器同时运行，不能共享一个栈，每个处理器都要有自己的栈。当然，这种区分是在虚拟地址层面上的，不是在物理地址层面上的，不同虚拟地址可以映射到相同物理地址，也可以映射到不同。在这里，我们当然希望能够映射到不同地址上。</p>
<p>主要工作在函数<code>mem_init_mp</code>，这个函数在<code>mem_init</code>初始化完成BSP使用的栈后调用，为各个AP映射栈地址。</p>
<p>讲义和代码注释要求我们给每个栈分配<code>KSTKSIZE</code>大小，中间留出<code>KSTKGAP</code>作为保护，使得一个栈溢出一定不会影响相邻的栈。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Modify mappings in kern_pgdir to support SMP</span></span><br><span class="line"><span class="comment">//   - Map the per-CPU stacks in the region [KSTACKTOP-PTSIZE, KSTACKTOP)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">mem_init_mp(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// Map per-CPU stacks starting at KSTACKTOP, for up to 'NCPU' CPUs.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// 对每个CPUi，使用percpu_kstacks[i]所代表的物理地址作为内核栈。</span></span><br><span class="line">        <span class="comment">// CPU i的内核栈从kstacktop_i = KSTACKTOP - i * (KSTKSIZE + KSTKGAP)向下生长</span></span><br><span class="line">        <span class="comment">// 为了避免溢出，还会加上GAP</span></span><br><span class="line">        <span class="comment">//     Permissions: kernel RW, user NONE</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// LAB 4: Your code here:</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NCPU; ++i) &#123;</span><br><span class="line">        boot_map_region(kern_pgdir,</span><br><span class="line">                        KSTACKTOP - i * (KSTKSIZE + KSTKGAP) - KSTKSIZE,</span><br><span class="line">                        KSTKSIZE,</span><br><span class="line">                        (<span class="keyword">physaddr_t</span>)PADDR(percpu_kstacks[i]),</span><br><span class="line">                        PTE_W);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我看着比较好的一种写法</span></span><br><span class="line">    <span class="comment">//uintptr_t start_addr = KSTACKTOP - KSTKSIZE;</span></span><br><span class="line">    <span class="comment">//   for (size_t i=0; i&lt;NCPU; i++) &#123;</span></span><br><span class="line">    <span class="comment">//       boot_map_region(kern_pgdir, (uintptr_t) start_addr, KSTKSIZE, PADDR(percpu_kstacks[i]), PTE_W | PTE_P);</span></span><br><span class="line">    <span class="comment">//       start_addr -= KSTKSIZE + KSTKGAP;</span></span><br><span class="line">    <span class="comment">//   &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="各处理器中断初始化"><a href="#各处理器中断初始化" class="headerlink" title="各处理器中断初始化"></a>各处理器中断初始化</h2><p>在文件<code>kern/trap.c</code>中函数<code>trap_init_percpu</code>对每个AP的中断进行初始化。上一个Lab留下的版本，不能正确地在多处理器情况下运行。我们需要做一些小更改，让函数正确初始化每个AP的中断。</p>
<p>上一个Lab中，函数<code>trap_init_percpu</code>在函数<code>trap_init</code>中调用，<code>trap_init</code>在<code>i386_init</code>中调用。这是给BSP初始化中断。</p>
<p>AP内核入口函数<code>mp_main</code>调用了<code>trap_init_percpu</code>，这是给各个AP初始化中断。在BSP调用的<code>trap_init</code>函数中，中断描述符表已经初始化完成了，在各个AP中也就没比要再做，故没有调用<code>trap_init</code>。</p>
<p>只需要将<code>trap_init_percpu</code>的变量<code>ts</code>改为当前处理器的<code>Task State Segment</code>就可以，其它操作和上个Lab相同。需要注意计算出当前处理器的栈的正确地址，不再是<code>KSTACKTOP</code>了。</p>
<p>先注释掉<code>ts</code>，再根据单个cpu的代码做改动。在<code>inc/memlayout.h</code>中可以找到<code>GD_TSS0</code>的定义：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GD_TSS0   0x28     <span class="comment">// Task segment selector for CPU 0</span></span></span><br></pre></td></tr></table></figure></p>
<p>但是并没有其他地方说明其他 CPU 的任务段选择器在哪。因此最大的难点就是找到这个值。实际上，偏移就是<code>cpu_id &lt;&lt; 3</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// static struct Taskstate ts;</span></span><br><span class="line">...</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Taskstate</span>* <span class="title">this_ts</span> = &amp;<span class="title">thiscpu</span>-&gt;<span class="title">cpu_ts</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Setup a TSS so that we get the right stack</span></span><br><span class="line">    <span class="comment">// when we trap to the kernel.</span></span><br><span class="line">    this_ts-&gt;ts_esp0 = KSTACKTOP - thiscpu-&gt;cpu_id*(KSTKSIZE + KSTKGAP);</span><br><span class="line">    this_ts-&gt;ts_ss0 = GD_KD;</span><br><span class="line">    this_ts-&gt;ts_iomb = <span class="keyword">sizeof</span>(struct Taskstate);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize the TSS slot of the gdt.</span></span><br><span class="line">    gdt[(GD_TSS0 &gt;&gt; <span class="number">3</span>) + thiscpu-&gt;cpu_id] = SEG16(STS_T32A, (<span class="keyword">uint32_t</span>) (this_ts),</span><br><span class="line">                    <span class="keyword">sizeof</span>(struct Taskstate) - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    gdt[(GD_TSS0 &gt;&gt; <span class="number">3</span>) + thiscpu-&gt;cpu_id].sd_s = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Load the TSS selector (like other segment selectors, the</span></span><br><span class="line">    <span class="comment">// bottom three bits are special; we leave them 0)</span></span><br><span class="line">    ltr(GD_TSS0 + (thiscpu-&gt;cpu_id &lt;&lt; <span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Load the IDT</span></span><br><span class="line">    lidt(&amp;idt_pd);</span><br></pre></td></tr></table></figure>
<p>运行<code>make qemu CPUS=4</code>成功，输出如下提示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">6828 decimal is 15254 octal!</span><br><span class="line">Physical memory: 131072K available, base = 640K, extended = 130432K</span><br><span class="line">check_page_free_list() succeeded!</span><br><span class="line">check_page_alloc() succeeded!</span><br><span class="line">check_page() succeeded!</span><br><span class="line">check_kern_pgdir() succeeded!</span><br><span class="line">check_page_free_list() succeeded!</span><br><span class="line">check_page_installed_pgdir() succeeded!</span><br><span class="line">SMP: CPU 0 found 4 CPU(s)</span><br><span class="line">enabled interrupts: 1 2</span><br><span class="line">SMP: CPU 1 starting</span><br><span class="line">SMP: CPU 2 starting</span><br><span class="line">SMP: CPU 3 starting</span><br></pre></td></tr></table></figure></p>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>我们现在的代码在初始化 AP 后就会开始自旋。在进一步操作 AP 之前，我们要先处理几个 CPU 同时运行内核代码的竞争情况。最简单的方法是用一个大内核锁 (big kernel lock)。它是一个全局锁，在某个进程进入内核态时锁定，返回用户态时释放。这种模式下，用户进程可以并发地在 CPU 上运行，但是同一时间仅有一个进程可以在内核态，其他需要进入内核态的进程只能等待。<br><code>kern/spinlock.h</code>声明了一个大内核锁<code>kernel_lock</code>。它提供了<code>lock_kernel()</code>和<code>unlock_kernel()</code>方法用于获得和释放锁。在以下 4 个地方需要使用到大内核锁：</p>
<ul>
<li>在<code>i386_init()</code>，BSP 唤醒其他 CPU 之前获得内核锁</li>
<li>在<code>mp_main()</code>，初始化 AP 之后获得内核锁，之后调用<code>sched_yield()</code>在 AP 上运行进程。</li>
<li>在<code>trap()</code>，当从用户态陷入内核态时获得内核锁，通过检查<code>tf_cs</code>的低 2bit 来确定该 trap 是由用户进程还是内核触发。</li>
<li>在<code>env_run()</code>，在切换回用户模式前释放内核锁。</li>
</ul>
<p>Exercise 5是在合适的地方调用<code>lock_kernel()</code>和<code>unlock_kernel()</code>。在这些函数中，我们需要添加<code>lock/unlock</code>：<code>i386_init</code>, <code>mp_main</code>, <code>trap</code>, <code>env_run</code>。</p>
<p><code>i386_init</code>,<code>mp_main</code>函数的lock都发生在初始化完成，准备通过<code>sched_yield</code>进入用户进程之前。这时候加锁，让处理器依次加载用户进程，保证同一时刻只有一个处理器在内核态运行。</p>
<p>其它操作内核锁发生在进入和退出内核态的时候。处理器进入内核态后处在函数<code>trap</code>，故在<code>trap</code>开头加锁，等待其它处理器退出内核态。处理器要进入用户态时放开锁，也就是在<code>env_run</code>的最后，允许其它处理器进入内核态。</p>
<p>其它加锁方式可能更有效率，但比Spin Lock复杂很多。不论如何，这些lock/unlock操作都是为了保证内核只运行在一个处理器上。</p>
<p>在<code>kern/init.c</code>的<code>i386_init</code>中加锁：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Lab 4 multitasking initialization functions</span></span><br><span class="line">pic_init();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Acquire the big kernel lock before waking up APs</span></span><br><span class="line"><span class="comment">// Your code here:</span></span><br><span class="line">lock_kernel();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Starting non-boot CPUs</span></span><br><span class="line">boot_aps();</span><br></pre></td></tr></table></figure></p>
<p>在<code>kern/init.c</code>的<code>mp_main</code>中加锁：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Now that we have finished some basic setup, call sched_yield()</span></span><br><span class="line"><span class="comment">// to start running processes on this CPU.  But make sure that</span></span><br><span class="line"><span class="comment">// only one CPU can enter the scheduler at a time!</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Your code here:</span></span><br><span class="line">lock_kernel();</span><br><span class="line"></span><br><span class="line">sched_yield();</span><br></pre></td></tr></table></figure></p>
<p>在<code>kern/trap.c</code>的<code>trap</code>中加锁：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((tf-&gt;tf_cs &amp; <span class="number">3</span>) == <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="comment">// Trapped from user mode.</span></span><br><span class="line">    <span class="comment">// Acquire the big kernel lock before doing any</span></span><br><span class="line">    <span class="comment">// serious kernel work.</span></span><br><span class="line">    <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">    lock_kernel();</span><br></pre></td></tr></table></figure></p>
<p>在<code>kern/env.c</code>的<code>env_run</code>中解锁：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unlock_kernel();</span><br><span class="line">env_pop_tf(&amp;e-&gt;env_tf);</span><br></pre></td></tr></table></figure></p>
<p>关键要理解两点：</p>
<h3 id="大内核锁的实现"><a href="#大内核锁的实现" class="headerlink" title="大内核锁的实现"></a>大内核锁的实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">spin_lock(struct spinlock *lk)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG_SPINLOCK</span></span><br><span class="line">    <span class="keyword">if</span> (holding(lk))</span><br><span class="line">        panic(<span class="string">"CPU %d cannot acquire %s: already holding"</span>, cpunum(), lk-&gt;name);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// The xchg is atomic.</span></span><br><span class="line">    <span class="comment">// It also serializes, so that reads after acquire are not</span></span><br><span class="line">    <span class="comment">// reordered before it. </span></span><br><span class="line">    <span class="comment">// 关键代码，体现了循环等待的思想</span></span><br><span class="line">    <span class="keyword">while</span> (xchg(&amp;lk-&gt;locked, <span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">        <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(<span class="string">"pause"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Record info about lock acquisition for debugging.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG_SPINLOCK</span></span><br><span class="line">    lk-&gt;cpu = thiscpu;</span><br><span class="line">    get_caller_pcs(lk-&gt;pcs);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，在<code>inc/x86.h</code>中可以找到<code>xchg()</code>函数的实现，使用它而不是用简单的<code>if + 赋值</code>是因为它是一个原子性的操作。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">uint32_t</span></span><br><span class="line">xchg(<span class="keyword">volatile</span> <span class="keyword">uint32_t</span> *addr, <span class="keyword">uint32_t</span> newval)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The + in "+m" denotes a read-modify-write operand.</span></span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">"lock; xchgl %0, %1"</span></span></span></span><br><span class="line"><span class="function"><span class="params">             : <span class="string">"+m"</span> (*addr), <span class="string">"=a"</span> (result)  <span class="comment">// 输出</span></span></span></span><br><span class="line"><span class="function"><span class="params">             : <span class="string">"1"</span> (newval)             <span class="comment">//  输入</span></span></span></span><br><span class="line"><span class="function"><span class="params">             : <span class="string">"cc"</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>lock</code>确保了操作的原子性，其意义是将<code>addr</code>存储的值与<code>newval</code>交换，并返回<code>addr</code>中原本的值。于是，如果最初<code>locked = 0</code>，即未加锁，就能跳出这个<code>while</code>循环。否则就会利用<code>pause</code>命令自旋等待。这就确保了当一个 CPU 获得了 BKL，其他 CPU 如果也要获得就只能自旋等待。</p>
<h3 id="为什么要在这几处加大内核锁"><a href="#为什么要在这几处加大内核锁" class="headerlink" title="为什么要在这几处加大内核锁"></a>为什么要在这几处加大内核锁</h3><p>从根本上来讲，其设计的初衷就是保证独立性。由于分页机制的存在，内核以及每个用户进程都有自己的独立空间。而多进程并发的时候，如果两个进程同时陷入内核态，就无法保证独立性了。例如内核中有某个全局变量<code>A</code>，cpu1 让 A=1， 而后 cpu2 却让 A=2，显然会互相影响。最初 Linux 设计者为了使系统尽快支持 SMP，直接在内核入口放了一把大锁，保证其独立性。</p>
<p>其流程大致为：BPS 启动 AP 前，获取内核锁，所以 AP 会在<code>mp_main</code>执行调度之前阻塞，在启动完 AP 后，BPS 执行调度，运行第一个进程，<code>env_run()</code>函数中会释放内核锁，这样一来，其中一个 AP 就可以开始执行调度，运行其他进程。</p>
<p>Q：看起来大内核锁机制保证了同时只能有一个CPU在内核态运行。那为什么我们还需要将每个CPU的内核栈分开？请描述一个场景，我们不分开内核栈而导致错误。</p>
<blockquote>
<p>假设CPU0因中断陷入内核并在内核栈中保留了相关的信息，此时若CPU1也发生中断而陷入内核，在同一个内核栈的情况下，CPU0中的信息将会被覆盖从而导致出现错误。</p>
</blockquote>
<h3 id="为什么要用不同栈"><a href="#为什么要用不同栈" class="headerlink" title="为什么要用不同栈"></a>为什么要用不同栈</h3><p>本标题对应Question 2。如果一次只有一个处理器运行内核，为什么每个处理器都要一个单独的栈？</p>
<p>这是个挺简单的问题。因为并不是真的只有一个处理器运行内核，处理器进入内核态之后才调用lock_kernel，进而抢锁。在中断发生进入trap函数时，这个处理器就已经在使用内核的代码了，只是可能没有运行真正的内核，而是在跑一个while循环，这也还是内核。</p>
<p>要处理这样同时跑内核的情况，自然要多个栈。可以设想，如果只有一个栈，一个处理器正在运行内核，一个处理器发生中断。被中断的处理器压栈，然后等待另一个处理器退出内核。在另一个处理器看来，栈没有变化，接着正常操作，把刚刚压栈的数据覆盖了。</p>
<h2 id="轮询调度"><a href="#轮询调度" class="headerlink" title="轮询调度"></a>轮询调度</h2><p>下一个任务是让 JOS 内核能够以轮询方式在多个任务之间切换。其原理如下：</p>
<ul>
<li><code>kern/sched.c</code>中的<code>sched_yield()</code>函数用来选择一个新的进程运行。它将从上一个运行的进程开始，按顺序循环搜索<code>envs[]</code>数组，选取第一个状态为<code>ENV_RUNNABLE</code>的进程执行。</li>
<li><code>sched_yield()</code>不能同时在两个CPU上运行同一个进程。如果一个进程已经在某个CPU上运行，其状态会变为<code>ENV_RUNNING</code>。</li>
<li>程序中已经实现了一个新的系统调用<code>sys_yield()</code>，进程可以用它来唤起内核的<code>sched_yield()</code>函数，从而将 CPU 资源移交给一个其他的进程。</li>
</ul>
<p>如何找到目前正在运行的进程在<code>envs[]</code>中的序号？在<code>kern/env.h</code>中，可以找到指向<code>struct Env</code>的指针<code>curenv</code>，表示当前正在运行的进程。但是需要注意，不能直接由<code>curenv-&gt;env_id</code>得到其序号。在<code>inc/env.h</code>中有一个宏可以完成这个转换。</p>
<p><code>sched_yield()</code>将找到下一个<code>runable</code>的进程并切换到这个进程上。主要步骤如下:</p>
<ul>
<li>从当前在<code>running</code>的进程 ( 也就是<code>curenv</code>) 开始 ( 如果<code>curenv</code>不存在，则从数组首部开始查找 )，顺序查找在<code>envs</code>数组 ( in circular fashion，也就是要取模做个环状查找 )，取出首个<code>status</code>为<code>ENV_RUNNABLE</code>的进程，并调用<code>env_run()</code>唤醒取出的进程。</li>
<li>如果上述查询中没有找到任何一个<code>ENV_RUNNABLE</code>的进程，则将观测<code>curenv-&gt;env_status</code>若其为<code>ENV_RUNNING</code>则继续运行这个进程。</li>
<li>若以上两种情况都没发生. 则自然的停止调度.</li>
</ul>
<p>这个函数必须阻止同一个进程在两个不同 CPU 上运行的情况 ( 由于正在运行 env 的状态必定是<code>ENV_RUNNING</code>，在前述中不会发生这种事情 )</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The environment index ENVX(eid) equals the environment's offset in the 'envs[]' array.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ENVX(envid)     ((envid) &amp; (NENV - 1))</span></span><br></pre></td></tr></table></figure>
<p>查看<code>kern/env.c</code>可以发现<code>curenv</code>可能为NULL。因此要注意特例。</p>
<p>在<code>kern/sched.c</code>中实现轮询调度。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">sched_yield(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">idle</span>;</span></span><br><span class="line">    </span><br><span class="line">    idle = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (curenv) &#123;</span><br><span class="line">        <span class="keyword">size_t</span> eidx = ENVX(curenv-&gt;env_id);</span><br><span class="line">        <span class="keyword">uint32_t</span> mask = NENV - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = (eidx + <span class="number">1</span>) &amp; mask; i != eidx; i = (i + <span class="number">1</span>) &amp; mask) &#123;</span><br><span class="line">            <span class="keyword">if</span> (envs[i].env_status == ENV_RUNNABLE) &#123;</span><br><span class="line">                idle = &amp;envs[i];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!idle &amp;&amp; curenv-&gt;env_status == ENV_RUNNING)</span><br><span class="line">            idle = curenv;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; NENV; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (envs[i].env_status == ENV_RUNNABLE) &#123;</span><br><span class="line">                idle = &amp;envs[i];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (idle)</span><br><span class="line">        env_run(idle);</span><br><span class="line">    <span class="comment">// sched_halt never returns</span></span><br><span class="line">    sched_halt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在<code>kern/syscall.c</code>中添加新的系统调用。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// syscall()</span></span><br><span class="line">...</span><br><span class="line">    <span class="keyword">case</span> SYS_yield:</span><br><span class="line">        sys_yield();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>将<code>kern/init.c</code>中运行的用户进程改为以下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// i386_init()</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(TEST)</span></span><br><span class="line">    <span class="comment">// Don't touch -- used by grading script!</span></span><br><span class="line">    ENV_CREATE(TEST, ENV_TYPE_USER);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="comment">// Touch all you want.</span></span><br><span class="line">    ENV_CREATE(user_primes, ENV_TYPE_USER);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// TEST*</span></span></span><br><span class="line">    ENV_CREATE(user_yield, ENV_TYPE_USER);</span><br><span class="line">    ENV_CREATE(user_yield, ENV_TYPE_USER);</span><br><span class="line">    ENV_CREATE(user_yield, ENV_TYPE_USER);</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>运行<code>make qemu CPUS=2</code>可以看到三个进程通过调用<code>sys_yield</code>切换了5次。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Hello, I am environment 00001000.</span><br><span class="line">Hello, I am environment 00001001.</span><br><span class="line">Back in environment 00001000, iteration 0.</span><br><span class="line">Hello, I am environment 00001002.</span><br><span class="line">Back in environment 00001001, iteration 0.</span><br><span class="line">Back in environment 00001000, iteration 1.</span><br><span class="line">Back in environment 00001002, iteration 0.</span><br><span class="line">Back in environment 00001001, iteration 1.</span><br><span class="line">Back in environment 00001000, iteration 2.</span><br><span class="line">Back in environment 00001002, iteration 1.</span><br><span class="line">Back in environment 00001001, iteration 2.</span><br><span class="line">Back in environment 00001000, iteration 3.</span><br><span class="line">Back in environment 00001002, iteration 2.</span><br><span class="line">Back in environment 00001001, iteration 3.</span><br><span class="line">Back in environment 00001000, iteration 4.</span><br><span class="line">Back in environment 00001002, iteration 3.</span><br><span class="line">All done in environment 00001000.</span><br><span class="line">[00001000] exiting gracefully</span><br><span class="line">[00001000] free env 00001000</span><br><span class="line">Back in environment 00001001, iteration 4.</span><br><span class="line">Back in environment 00001002, iteration 4.</span><br><span class="line">All done in environment 00001001.</span><br><span class="line">All done in environment 00001002.</span><br><span class="line">[00001001] exiting gracefully</span><br><span class="line">[00001001] free env 00001001</span><br><span class="line">[00001002] exiting gracefully</span><br><span class="line">[00001002] free env 00001002</span><br><span class="line">No runnable environments in the system!</span><br><span class="line">Welcome to the JOS kernel monitor!</span><br><span class="line">Type &apos;help&apos; for a list of commands.</span><br><span class="line">K&gt;</span><br></pre></td></tr></table></figure>
<p>Q：我们在<code>env_run()</code>的实现中调用了<code>lcr3()</code>。在这个函数的调用之前以及调用之后，你的代码对<code>env_run()</code>的参数<code>e</code>进行了引用。在加载<code>%cr3</code>寄存器之后，MMU的寻址上下文就改变了（页目录切换了）。为什么我们在页目录改变前后都可以对<code>e</code>进行解引用？</p>
<blockquote>
<p>A：在我们lab3实现的过程中，任务的<code>env_pgdir</code>是基于<code>kern_pgdir</code>产生的，也就是说对于<code>UTOP</code>上的地址映射关系在两个页表中是一样的。而<code>e</code>所对应的<code>Env</code>结构由操作系统管理，在虚拟空间地址都是<code>UENVS-UPAGES</code>的范围，因此在所有用户环境的映射也是一样的。</p>
</blockquote>
<p>Q：当内核进行用户环境切换的时候，必须要保证旧的环境的寄存器值被保存起来以便之后恢复。这个过程是在哪里发生的？</p>
<blockquote>
<p>A：用户环境进行环境切换是通过系统调用<code>syscall()</code>，最终通过<code>kern/trap.c</code>中的<code>trap()</code>产生异常然后陷入内核。因而中断触发会进入<code>trapentry.S</code>的代码入口然后调用<code>trap()</code>，系统会在栈上创建一个<code>Trapframe</code>然后赋给用户环境的<code>env_tf</code>从而保护用户环境寄存器。如下所示代码片段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">_alltraps:</span><br><span class="line">	;ds es</span><br><span class="line">	push %ds</span><br><span class="line">	push %es</span><br><span class="line">	pushal   #;其余寄存器</span><br><span class="line"></span><br><span class="line">	#;load DS and ES with GD_KD (不能用立即数设置段寄存器)</span><br><span class="line">	mov $GD_KD, %ax</span><br><span class="line">	mov %ax, %ds</span><br><span class="line">	mov %ax, %es</span><br><span class="line">	pushl %esp</span><br><span class="line">	call trap</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>这里我们将环境的现场全部保护起来压栈使得其结构与<code>Trapframe</code>一样，然后调用<code>trap()</code>就可以使得其作为<code>tf</code>被保存。</p>
<p>恢复：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">env_pop_tf(struct Trapframe *tf)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Record the CPU we are running on for user-space debugging</span></span><br><span class="line">    curenv-&gt;env_cpunum = cpunum();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="string">"\tmovl %0,%%esp\n"</span>  <span class="comment">// 恢复栈顶指针</span></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="string">"\tpopal\n"</span>          <span class="comment">// 恢复其他寄存器</span></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="string">"\tpopl %%es\n"</span>      <span class="comment">// 恢复段寄存器</span></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="string">"\tpopl %%ds\n"</span></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="string">"\taddl $0x8,%%esp\n"</span> <span class="comment">/* skip tf_trapno and tf_errcode */</span></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="string">"\tiret\n"</span></span></span></span><br><span class="line"><span class="function"><span class="params">        : : <span class="string">"g"</span> (tf) : <span class="string">"memory"</span>)</span></span>;</span><br><span class="line">    panic(<span class="string">"iret failed"</span>);  <span class="comment">/* mostly to placate the compiler */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="系统调用：创建进程"><a href="#系统调用：创建进程" class="headerlink" title="系统调用：创建进程"></a>系统调用：创建进程</h2><p>现在我们的内核已经可以运行多个进程，并在其中切换了。不过，现在它仍然只能运行内核最初设定好的程序<code>kern/init.c</code>。现在我们即将实现一个新的系统调用，它允许进程创建并开始新的进程。</p>
<p>Unix 提供了<code>fork()</code>这个原始的系统调用来创建进程。<code>fork()</code>将会拷贝父进程的整个地址空间来创建子进程。在用户空间里，父子进程之间的唯一区别就是它们的进程ID分别为<code>pid</code>和<code>ppid</code>。<code>fork()</code>在父进程中返回其子进程的进程 ID，而在子进程中返回 0。父子进程之间是完全独立的，任意一方修改内存，另一方都不会受到影响。</p>
<p>默认情况下，每一个进程都有其私有的地址空间，而且任意一个进程对于内核的修改都是对于其他进程而言不可见的。</p>
<p>我们将为 JOS 实现一个更原始的系统调用来创建新的进程。涉及到的系统调用如下：</p>
<ul>
<li><code>sys_exofork</code>：这个系统调用将会创建一个空白进程：在其用户空间中没有映射任何物理内存，并且它是不可运行的。刚开始时，它拥有和父进程相同的寄存器状态。<code>sys_exofork</code>将会在父进程返回其子进程的<code>envid_t</code>，子进程返回 0（当然，由于子进程还无法运行，也无法返回值，直到运行）。由于子环境最初被标记为不可执行，故在子环境中<code>sys_exofork()</code>直到父环境显式标记子环境为可执行，其才会在子环境中返回。</li>
<li><code>sys_env_set_status</code>：设置指定进程的状态为<code>ENV_RUNNABLE</code>或者<code>RUN_NOT_RUNNABLE</code>。这个系统调用通常用于在新进程的地址空间和寄存器初始化完成后，将其标记为可运行。</li>
<li><code>sys_page_alloc</code>：分配一个物理页并将其映射到指定进程的指定虚拟地址上。</li>
<li><code>sys_page_map</code>：从一个进程中拷贝一个页面映射（而非物理页的内容）到另一个。即共享内存。</li>
<li><code>sys_page_unmap</code>：删除到指定进程的指定虚拟地址的映射。</li>
</ul>
<p>上述所有系统调用集都需要接受一个环境ID，jos的内核支持了环境号0代表当前环境。在<code>kern/env.c</code>中的<code>envid2env()</code>实现了这种映射。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">envid2env(<span class="keyword">envid_t</span> envid, struct Env **env_store, <span class="keyword">bool</span> checkperm)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果envid为零，则返回当前环境.</span></span><br><span class="line">        <span class="keyword">if</span> (envid == <span class="number">0</span>) &#123;</span><br><span class="line">                *env_store = curenv;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过envid的索引部分查找Env结构，然后检查该结构Env中的env_id字段以确保envid不是陈旧的</span></span><br><span class="line">        e = &amp;envs[ENVX(envid)];</span><br><span class="line">        <span class="keyword">if</span> (e-&gt;env_status == ENV_FREE || e-&gt;env_id != envid) &#123;</span><br><span class="line">                *env_store = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查调用环境是否具有操作指定环境的合法权限。</span></span><br><span class="line">        <span class="comment">// 如果设置了 checkperm，则指定的环境必须是当前环境或当前环境的直接子环境。</span></span><br><span class="line">        <span class="keyword">if</span> (checkperm &amp;&amp; e != curenv &amp;&amp; e-&gt;env_parent_id != curenv-&gt;env_id) &#123;</span><br><span class="line">                *env_store = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        *env_store = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现上述在<code>kern/syscall.c</code>中的系统调用集，确保<code>syscall()</code>可以调用它们。你可能需要用到<code>kern/pmap.c</code>和<code>kern/env.c</code>中的一些函数，尤其是<code>envid2env()</code>。</p>
<p>现在你使用<code>envid2env()</code>的时候，将<code>checkperm</code>参数设置为1，确保当你的一些系统调用参数无效的时候会返回<code>-E_INVAL</code>。使用<code>user/dumpfork.c</code>测试你实现的这些系统调用。</p>
<p><code>sys_exofork()</code>的关键点在于如何让子环境对该系统调用返回0。这个用户态的触发系统调用的函数定义实际上在<code>inc/lib.h</code>中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This must be inlined. </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">envid_t</span> __attribute__((always_inline))</span><br><span class="line">sys_exofork(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">envid_t</span> ret;</span><br><span class="line">	<span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">"int %2"</span></span></span></span><br><span class="line"><span class="function"><span class="params">		     : <span class="string">"=a"</span> (ret)</span></span></span><br><span class="line"><span class="function"><span class="params">		     : <span class="string">"a"</span> (SYS_exofork), <span class="string">"i"</span> (T_SYSCALL))</span></span>;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>整个过程的控制流如下：父环境显式调用该系统调用，通过内联汇编<code>int %2</code>触发中断，然后硬件控制流通过<code>trapentry.S</code>中的入口地址进行保护现场并将控制流转到<code>trap.c</code>最终进入<code>trap_dispatch()</code>:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">trap_dispatch(struct Trapframe *tf)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">	<span class="keyword">if</span> (tf-&gt;tf_trapno == T_SYSCALL)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int32_t</span> retval = syscall(tf-&gt;tf_regs.reg_eax,</span><br><span class="line">								 tf-&gt;tf_regs.reg_edx,</span><br><span class="line">								 tf-&gt;tf_regs.reg_ecx,</span><br><span class="line">								 tf-&gt;tf_regs.reg_ebx,</span><br><span class="line">								 tf-&gt;tf_regs.reg_edi,</span><br><span class="line">								 tf-&gt;tf_regs.reg_esi);</span><br><span class="line">		<span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line">			panic(<span class="string">"[trap_dispatch] syscall : %e\n"</span>, retval);</span><br><span class="line">		tf-&gt;tf_regs.reg_eax = retval;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可见这里系统调用获取返回值的方式是：<code>env_tf</code>中的<code>reg_eax</code>寄存器设置为将系统调用的返回值。然后回到<code>trap</code>中直接通过调用<code>env_run()</code>来返回用户态：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dispatch based on what type of trap occurred</span></span><br><span class="line">	trap_dispatch(tf);         <span class="comment">// &lt;-  这里是上面的返回，返回值存在了其tf的reg_eax中</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// If we made it to this point, then no other environment was</span></span><br><span class="line">	<span class="comment">// scheduled, so we should return to the current environment</span></span><br><span class="line">	<span class="comment">// if doing so makes sense.</span></span><br><span class="line">	<span class="keyword">if</span> (curenv &amp;&amp; curenv-&gt;env_status == ENV_RUNNING)</span><br><span class="line">		env_run(curenv);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		sched_yield();</span><br></pre></td></tr></table></figure></p>
<p>而在我们的<code>sys_exofork()</code>执行过程中，只有父环境发生了系统调用，在陷入内核之前保护了用户环境的下一条指令<code>eip</code>，子环境是没有产生中断以及系统调用的，子环境会从其地址空间的<code>eip</code>指定的代码处继续执行（别忘了子环境的寄存器实际上就是拷贝父环境的）。因此整个<code>kern/trap.c</code>以及<code>kern/syscall.c</code>并没有影响子环境，子环境只会等待内核调用<code>sched_yield()</code>开始执行，因此返回值就是我们伪造的<code>eax=0</code>：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">envid_t</span></span><br><span class="line">sys_exofork(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">    <span class="comment">// panic("sys_exofork not implemented");</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line">    <span class="keyword">int</span> r = env_alloc(&amp;e, curenv-&gt;env_id);</span><br><span class="line">    <span class="keyword">if</span> (r &lt; <span class="number">0</span>) <span class="keyword">return</span> r;</span><br><span class="line">    e-&gt;env_status = ENV_NOT_RUNNABLE;</span><br><span class="line">    e-&gt;env_tf = curenv-&gt;env_tf;</span><br><span class="line">    e-&gt;env_tf.tf_regs.reg_eax = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> e-&gt;env_id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在该函数中，子进程复制了父进程的<code>trapframe</code>，此后把<code>trapframe</code>中的<code>eax</code>的值设为了0。最后，返回了子进程的<code>id</code>。注意，根据<code>kern/trap.c</code>中的<code>trap_dispatch()</code>函数，这个返回值仅仅是存放在了父进程的<code>trapframe</code>中，还没有返回。而是在返回用户态的时候，即在<code>env_run()</code>中调用<code>env_pop_tf()</code>时，才把<code>trapframe</code>中的值赋值给各个寄存器。这时候<code>lib/syscall.c</code>中的函数<code>syscall()</code>才获得真正的返回值。因此，在这里对子进程<code>trapframe</code>的修改，可以使得子进程返回0。</p>
<p><code>sys_page_alloc()</code>函数在进程<code>envid</code>的目标地址<code>va</code>分配一个权限为<code>perm</code>的页面。</p>
<p>在做这个之前需要看一下<code>duppage()</code>函数，这是对这个系统调用的测试函数，里边列举了一些可能会出现的Corner case。<code>duppage()</code>函数利用<code>sys_page_alloc()</code>为子进程分配空闲物理页，再使用<code>sys_page_map()</code>将该新物理页映射到内核 (内核的<code>env_id = 0</code>) 的交换区<code>UTEMP</code>，方便在内核态进行<code>memmove</code>拷贝操作。在拷贝结束后，利用<code>sys_page_unmap()</code>将交换区的映射删除。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">duppage(<span class="keyword">envid_t</span> dstenv, <span class="keyword">void</span> *addr)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This is NOT what you should do in your fork.</span></span><br><span class="line">    <span class="keyword">if</span> ((r = sys_page_alloc(dstenv, addr, PTE_P|PTE_U|PTE_W)) &lt; <span class="number">0</span>)</span><br><span class="line">        panic(<span class="string">"sys_page_alloc: %e"</span>, r);</span><br><span class="line">    <span class="keyword">if</span> ((r = sys_page_map(dstenv, addr, <span class="number">0</span>, UTEMP, PTE_P|PTE_U|PTE_W)) &lt; <span class="number">0</span>)</span><br><span class="line">        panic(<span class="string">"sys_page_map: %e"</span>, r);</span><br><span class="line">    memmove(UTEMP, addr, PGSIZE);</span><br><span class="line">    <span class="keyword">if</span> ((r = sys_page_unmap(<span class="number">0</span>, UTEMP)) &lt; <span class="number">0</span>)</span><br><span class="line">        panic(<span class="string">"sys_page_unmap: %e"</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在写之前也要看一下注释里的提示，注意检查权限位，这个看一下位操作就能搞定。分配了<code>page</code>之后要检查是否没有分配成功，检查能否获得正确的<code>env</code>，检查插入<code>page</code>是否成功，完成这些检查并根据返回值返回相应的错误码。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Allocate a page of memory and map it at 'va' with permission</span></span><br><span class="line"><span class="comment">// 'perm' in the address space of 'envid'.</span></span><br><span class="line"><span class="comment">// The page's contents are set to 0.</span></span><br><span class="line"><span class="comment">// If a page is already mapped at 'va', that page is unmapped as a</span></span><br><span class="line"><span class="comment">// side effect.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// perm -- PTE_U | PTE_P must be set, PTE_AVAIL | PTE_W may or may not be set,</span></span><br><span class="line"><span class="comment">//         but no other bits may be set.  See PTE_SYSCALL in inc/mmu.h.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Return 0 on success, &lt; 0 on error.  Errors are:</span></span><br><span class="line"><span class="comment">//      -E_BAD_ENV if environment envid doesn't currently exist,</span></span><br><span class="line"><span class="comment">//              or the caller doesn't have permission to change envid.</span></span><br><span class="line"><span class="comment">//      -E_INVAL if va &gt;= UTOP, or va is not page-aligned.</span></span><br><span class="line"><span class="comment">//      -E_INVAL if perm is inappropriate (see above).</span></span><br><span class="line"><span class="comment">//      -E_NO_MEM if there's no memory to allocate the new page,</span></span><br><span class="line"><span class="comment">//              or to allocate any necessary page tables.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sys_page_alloc(<span class="keyword">envid_t</span> envid, <span class="keyword">void</span> *va, <span class="keyword">int</span> perm)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// Hint: This function is a wrapper around page_alloc() and</span></span><br><span class="line">        <span class="comment">//   page_insert() from kern/pmap.c.</span></span><br><span class="line">        <span class="comment">//   Most of the new code you write should be to check the</span></span><br><span class="line">        <span class="comment">//   parameters for correctness.</span></span><br><span class="line">        <span class="comment">//   If page_insert() fails, remember to free the page you</span></span><br><span class="line">        <span class="comment">//   allocated!</span></span><br><span class="line">        <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">        <span class="comment">// panic("sys_page_alloc not implemented");</span></span><br><span class="line">        <span class="keyword">if</span> ((~perm &amp; (PTE_U|PTE_P)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">        <span class="keyword">if</span> ((perm &amp; (~(PTE_U|PTE_P|PTE_AVAIL|PTE_W))) != <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">uintptr_t</span>)va &gt;= UTOP || PGOFF(va) != <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span> -E_INVAL;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">page</span> = <span class="title">page_alloc</span>(<span class="title">ALLOC_ZERO</span>);</span></span><br><span class="line">        <span class="keyword">if</span> (!page)</span><br><span class="line">            <span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line">        <span class="keyword">int</span> err = envid2env(envid, &amp;e, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">        err = page_insert(e-&gt;env_pgdir, page, va, perm);</span><br><span class="line">        <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            page_free(page);</span><br><span class="line">            <span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>sys_page_map()</code>函数简单来说，就是建立跨进程的映射。注释中给出了一些需要做的检查，取得src中的页，使用<code>page_insert</code>把这页添加到<code>dst_env-&gt;env_pgdir</code>中即可。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Map the page of memory at 'srcva' in srcenvid's address space</span></span><br><span class="line"><span class="comment">// at 'dstva' in dstenvid's address space with permission 'perm'.</span></span><br><span class="line"><span class="comment">// Perm has the same restrictions as in sys_page_alloc, except</span></span><br><span class="line"><span class="comment">// that it also must not grant write access to a read-only</span></span><br><span class="line"><span class="comment">// page.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Return 0 on success, &lt; 0 on error.  Errors are:</span></span><br><span class="line"><span class="comment">//      -E_BAD_ENV if srcenvid and/or dstenvid doesn't currently exist,</span></span><br><span class="line"><span class="comment">//              or the caller doesn't have permission to change one of them.</span></span><br><span class="line"><span class="comment">//      -E_INVAL if srcva &gt;= UTOP or srcva is not page-aligned,</span></span><br><span class="line"><span class="comment">//              or dstva &gt;= UTOP or dstva is not page-aligned.</span></span><br><span class="line"><span class="comment">//      -E_INVAL is srcva is not mapped in srcenvid's address space.</span></span><br><span class="line"><span class="comment">//      -E_INVAL if perm is inappropriate (see sys_page_alloc).</span></span><br><span class="line"><span class="comment">//      -E_INVAL if (perm &amp; PTE_W), but srcva is read-only in srcenvid's</span></span><br><span class="line"><span class="comment">//              address space.</span></span><br><span class="line"><span class="comment">//      -E_NO_MEM if there's no memory to allocate any necessary page tables.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sys_page_map(<span class="keyword">envid_t</span> srcenvid, <span class="keyword">void</span> *srcva,</span><br><span class="line">             <span class="keyword">envid_t</span> dstenvid, <span class="keyword">void</span> *dstva, <span class="keyword">int</span> perm)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// Hint: This function is a wrapper around page_lookup() and</span></span><br><span class="line">        <span class="comment">//   page_insert() from kern/pmap.c.</span></span><br><span class="line">        <span class="comment">//   Again, most of the new code you write should be to check the</span></span><br><span class="line">        <span class="comment">//   parameters for correctness.</span></span><br><span class="line">        <span class="comment">//   Use the third argument to page_lookup() to</span></span><br><span class="line">        <span class="comment">//   check the current permissions on the page.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">        <span class="comment">//      -E_BAD_ENV if srcenvid and/or dstenvid doesn't currently exist,</span></span><br><span class="line">        <span class="comment">//              or the caller doesn't have permission to change one of them.</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">uintptr_t</span>)srcva &gt;= UTOP || PGOFF(srcva) != <span class="number">0</span> || (<span class="keyword">uintptr_t</span>)dstva &gt;= UTOP || PGOFF(dstva) != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">        <span class="keyword">if</span> ((perm &amp; PTE_U) == <span class="number">0</span> || (perm &amp; PTE_P) == <span class="number">0</span> || (perm &amp; ~PTE_SYSCALL) != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">src_env</span>, *<span class="title">dst_env</span>;</span></span><br><span class="line">        <span class="keyword">if</span> (envid2env(srcenvid, &amp;src_env, <span class="number">1</span>) &lt; <span class="number">0</span> || envid2env(dstenvid, &amp;dst_env, <span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">        <span class="keyword">pte_t</span> *src_pte;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">page</span> = <span class="title">page_lookup</span>(<span class="title">src_env</span>-&gt;<span class="title">env_pgdir</span>, <span class="title">srcva</span>, &amp;<span class="title">src_pte</span>);</span></span><br><span class="line">        <span class="keyword">if</span> ( (*src_pte &amp; PTE_W == <span class="number">0</span>) &amp;&amp; (perm &amp; PTE_W == <span class="number">1</span>))</span><br><span class="line">                <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">        <span class="keyword">if</span> (page_insert(dst_env-&gt;env_pgdir, page, dstva, perm) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>sys_page_unmap()</code>函数取消映射。是对<code>page_remove</code>的封装。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sys_page_unmap(<span class="keyword">envid_t</span> envid, <span class="keyword">void</span> *va)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">uintptr_t</span>)va &gt;= UTOP || PGOFF(va) != <span class="number">0</span>) <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (envid2env(envid, &amp;e, <span class="number">1</span>) &lt; <span class="number">0</span>) <span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">    page_remove(e-&gt;env_pgdir, va);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>sys_env_set_status()</code>函数设置<code>env</code>的状态，在子进程内存<code>map</code>结束后再使用。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sys_env_set_status(<span class="keyword">envid_t</span> envid, <span class="keyword">int</span> status)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">    <span class="comment">// panic("sys_env_set_status not implemented");</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (status != ENV_RUNNABLE &amp;&amp; status != ENV_NOT_RUNNABLE) </span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (envid2env(envid, &amp;e, <span class="number">1</span>) &lt; <span class="number">0</span>) </span><br><span class="line">        <span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">    e-&gt;env_status = status;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="Part-B-写时拷贝的-Fork"><a href="#Part-B-写时拷贝的-Fork" class="headerlink" title="Part B: 写时拷贝的 Fork"></a>Part B: 写时拷贝的 Fork</h1><p>在 Part A 中，我们通过把父进程的所有内存数据拷贝到子进程实现了<code>fork()</code>，这也是 Unix 系统早期的实现。这个拷贝到过程是<code>fork()</code>时最昂贵的操作。</p>
<p>然而，调用了<code>fork()</code>之后往往立即就会在子进程中调用<code>exec()</code>，将子进程的内存更换为新的程序。这样，复制父进程的内存这个操作就完全浪费了。</p>
<p>因此，后来的 Unix 系统让父、子进程共享同一片物理内存，直到某个进程修改了内存。这被称作 copy-on-write。为了实现它，<code>fork()</code>时内核只拷贝页面的映射关系，而不拷贝其内容，同时将共享的页面标记为只读 (read-only)。当父子进程中任一方向内存中写入数据时，就会触发 page fault。此时，Unix 就知道应该分配一个私有的可写内存给这个进程。</p>
<p>也就是说，这样只有在实际进行修改页面的时候，这个页面的内容才会真正被复制。那么这种机制使得<code>exec()</code>降低了开销：实际上子进程可能只需要在调用<code>exec()</code>之前复制当前栈上的一页。</p>
<p>下面，我们就需要实现一个Unix-like的具有写时复制的<code>fork()</code>，作为用户空间库函数例程。（之所以作为用户库函数而不是内核函数，是为了让内核保持简单，同时能让用户定制自身<code>fork()</code>的实现）</p>
<h2 id="用户级别的页错误处理"><a href="#用户级别的页错误处理" class="headerlink" title="用户级别的页错误处理"></a>用户级别的页错误处理</h2><p>内核必须要记录进程不同区域出现页面错误时的处理方法。例如，一个栈区域的<code>page fault</code>会分配并映射一个新的页。一个<code>BSS</code>区域（用于存放程序中未初始化的全局变量、静态变量）的页错误会分配一个新的页面，初始化为0，再映射。<br>用户级别的页错误处理流程为：</p>
<ul>
<li>页错误异常，陷入内核</li>
<li>内核修改<code>%esp</code>切换到进程的异常栈，修改<code>%eip</code>让进程运行<code>_pgfault_upcall</code></li>
<li><code>_pgfault_upcall</code>将运行 page fault handler，此后不通过内核切换回正常栈</li>
</ul>
<p>用户级的写时复制<code>fork()</code>的第一个关键点，在于能够使得用户发现由写权限问题引发的page fault的能力。</p>
<p>通常来说，是设置一个地址空间用以让page fault来指示发生错误时应该采取哪种行为。比如说，大多数的Unix内核通常会为新的进程的栈区域分配一个页的大小，随着进程栈逐渐增长一直到了未映射分配的区域，就会引发page fault，然后内核再按需分配。这时典型的Unix内核需要追踪进程空间不同区域在发生page fault时应该采取何种措施</p>
<ul>
<li>栈区发生page fault，则表示需要新的页面的分配和映射；</li>
<li>BSS区的page faule，则表示应该分配一个新页面并且填充0再映射；</li>
<li>对于具有可执行文件的系统，text段的page fault则表示从磁盘上的二进制文件中读取页面并映射。</li>
</ul>
<p>和传统的内存追踪大量信息的方法不同，这个实验中我们需要让用户自己决定如何处理用户空间的每个页面错误（这些bug的损害通常不大）。这种设计方式为用户定义储存区域带来了较强的灵活性，我们之后将会使用用户级别的错误处理程序来进行映射以及访问磁盘系统的文件。</p>
<p>为了能够处理页错误，用户环境必须向jos的内核注册一个页错误处理程序入口（page fault handler entrypoint）。用户环境通过系统调用<code>sys_env_set_pgfault_upcall()</code>来注册错误处理程序入口。实验中已经对于<code>Env</code>结构增加了新的成员<code>env_pgfault_upcall</code>来记录该信息。</p>
<p>实现<code>sys_env_set_pgfault_upcall()</code>系统调用，相当简单。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Set the page fault upcall for 'envid' by modifying the corresponding struct</span></span><br><span class="line"><span class="comment">// Env's 'env_pgfault_upcall' field.  When 'envid' causes a page fault, the</span></span><br><span class="line"><span class="comment">// kernel will push a fault record onto the exception stack, then branch to</span></span><br><span class="line"><span class="comment">// 'func'.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Returns 0 on success, &lt; 0 on error.  Errors are:</span></span><br><span class="line"><span class="comment">//	-E_BAD_ENV if environment envid doesn't currently exist,</span></span><br><span class="line"><span class="comment">//		or the caller doesn't have permission to change envid.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sys_env_set_pgfault_upcall(<span class="keyword">envid_t</span> envid, <span class="keyword">void</span> *func)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> * <span class="title">env</span>;</span></span><br><span class="line">	<span class="keyword">if</span>(envid2env(envid, &amp;env, <span class="number">1</span>) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">	&#125;</span><br><span class="line">	env-&gt;env_pgfault_upcall = func;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="进程的正常栈和异常栈"><a href="#进程的正常栈和异常栈" class="headerlink" title="进程的正常栈和异常栈"></a>进程的正常栈和异常栈</h3><p>正常运行时，JOS 的进程会运行在正常栈上，<code>ESP</code>从<code>USTACKTOP</code>开始往下生长，栈上的数据存放在<code>[USTACKTOP-PGSIZE, USTACKTOP-1]</code>上。当出现页错误时，内核会把进程在一个新的栈（异常栈）上面重启，运行指定的用户级别页错误处理函数。也就是说完成了一次进程内的栈切换。这个过程与<code>trap</code>的过程很相似。</p>
<p>JOS 的异常栈也只有一个物理页大小，并且它的栈顶定义在虚拟内存<code>UXSTACKTOP</code>处。当用户环境在异常处理栈上运行时，用户级别页错误处理程序可以使用jos系统调用来映射新的页面以解决page fault，最终通过一些汇编代码回到正常栈。</p>
<p>每个需要支持用户级页错误处理的函数都需要分配自己的异常栈。可以使用<code>sys_page_alloc()</code>这个系统调用来实现。</p>
<h3 id="用户页错误处理函数"><a href="#用户页错误处理函数" class="headerlink" title="用户页错误处理函数"></a>用户页错误处理函数</h3><p>现在我们需要修改<code>kern/trap.c</code>中的缺页异常处理函数，使其能够按照特定的方式处理用户模式页错误。我们将用户环境发生错误时的状态称为异常状态（trap-time state）。</p>
<p>如果没有注册<code>page fault handler</code>，JOS内核就直接销毁进程。否则，内核就会初始化一个<code>trap frame</code>记录寄存器状态，在异常栈上处理页错误，恢复进程的执行，<code>fault_va</code>是导致页错误发生的虚拟地址。<code>UTrapframe</code>在异常栈栈上如下所示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">                    &lt;-- UXSTACKTOP</span><br><span class="line">trap-time esp</span><br><span class="line">trap-time eflags</span><br><span class="line">trap-time eip</span><br><span class="line">trap-time eax       start of struct PushRegs</span><br><span class="line">trap-time ecx</span><br><span class="line">trap-time edx</span><br><span class="line">trap-time ebx</span><br><span class="line">trap-time esp</span><br><span class="line">trap-time ebp</span><br><span class="line">trap-time esi</span><br><span class="line">trap-time edi       end of struct PushRegs</span><br><span class="line">tf_err (error code)</span><br><span class="line">fault_va            &lt;-- %esp when handler is run</span><br></pre></td></tr></table></figure></p>
<p>相比<code>trap</code>时使用的<code>Trapframe</code>，多了记录错误位置的<code>fault_va</code>，少了段选择器<code>%cs</code>，<code>%ds</code>，<code>%ss</code>。这反映了两者最大的不同：是否发生了进程的切换。</p>
<p>如果异常发生时，进程已经在异常栈上运行了，这就说明 page fault handler 本身出现了问题。这时，我们就应该在<code>tf-&gt;tf_esp</code>处分配新的栈，而不是在<code>UXSTACKTOP</code>。首先需要 push 一个空的 32bit word (4 bytes，所以要减4)作为占位符，然后是一个<code>UTrapframe</code>结构体。</p>
<p>实现<code>kern/trap.c</code>中的<code>page_fault_handler()</code>。注意上述提及的异常处理栈的机制。</p>
<p>为检查<code>tf-&gt;tf_esp</code>是否已经在异常栈上了，只要检查它是否在区间<code>[UXSTACKTOP-PGSIZE, UXSTACKTOP-1]</code>上即可。</p>
<p>再次分析控制流，当用户环境陷入中断时将<code>tf</code>保护起来，这里传递的参数<code>tf</code>实际上就是用户环境的现场。我们在这个系统调用之后需要将控制权还给用户环境，但是需要让用户环境进入页异常处理函数（如果有）并且将栈切换为异常处理栈。也就是说我们需要改变<code>curenv</code>的<code>ip</code>以及<code>esp</code>。同时我们只需要将<code>tf</code>中保护的现场原样传递给<code>utf</code>即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">page_fault_handler(struct Trapframe *tf)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">uint32_t</span> fault_va;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Read processor's CR2 register to find the faulting address</span></span><br><span class="line">	fault_va = rcr2();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Handle kernel-mode page faults.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">	<span class="keyword">if</span>((tf-&gt;tf_cs &amp; <span class="number">3</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">		panic(<span class="string">"[page_fault_handler] Page fault in kernel.\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// We've already handled kernel-mode exceptions, so if we get here,</span></span><br><span class="line">	<span class="comment">// the page fault happened in user mode.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Call the environment's page fault upcall, if one exists.  Set up a</span></span><br><span class="line">	<span class="comment">// page fault stack frame on the user exception stack (below</span></span><br><span class="line">	<span class="comment">// UXSTACKTOP), then branch to curenv-&gt;env_pgfault_upcall.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// The page fault upcall might cause another page fault, in which case</span></span><br><span class="line">	<span class="comment">// we branch to the page fault upcall recursively, pushing another</span></span><br><span class="line">	<span class="comment">// page fault stack frame on top of the user exception stack.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// It is convenient for our code which returns from a page fault</span></span><br><span class="line">	<span class="comment">// (lib/pfentry.S) to have one word of scratch space at the top of the</span></span><br><span class="line">	<span class="comment">// trap-time stack; it allows us to more easily restore the eip/esp. In</span></span><br><span class="line">	<span class="comment">// the non-recursive case, we don't have to worry about this because</span></span><br><span class="line">	<span class="comment">// the top of the regular user stack is free.  In the recursive case,</span></span><br><span class="line">	<span class="comment">// this means we have to leave an extra word between the current top of</span></span><br><span class="line">	<span class="comment">// the exception stack and the new stack frame because the exception</span></span><br><span class="line">	<span class="comment">// stack _is_ the trap-time stack.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// If there's no page fault upcall, the environment didn't allocate a</span></span><br><span class="line">	<span class="comment">// page for its exception stack or can't write to it, or the exception</span></span><br><span class="line">	<span class="comment">// stack overflows, then destroy the environment that caused the fault.</span></span><br><span class="line">	<span class="comment">// Note that the grade script assumes you will first check for the page</span></span><br><span class="line">	<span class="comment">// fault upcall and print the "user fault va" message below if there is</span></span><br><span class="line">	<span class="comment">// none.  The remaining three checks can be combined into a single test.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Hints:</span></span><br><span class="line">	<span class="comment">//   user_mem_assert() and env_run() are useful here.</span></span><br><span class="line">	<span class="comment">//   To change what the user environment runs, modify 'curenv-&gt;env_tf'</span></span><br><span class="line">	<span class="comment">//   (the 'tf' variable points at 'curenv-&gt;env_tf').</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">UTrapframe</span> * <span class="title">utf</span>;</span></span><br><span class="line">	<span class="keyword">uintptr_t</span> utf_top;</span><br><span class="line">	<span class="comment">//curenv has pg fault handler</span></span><br><span class="line">	<span class="keyword">if</span>(curenv -&gt; env_pgfault_upcall)&#123;</span><br><span class="line">		<span class="comment">//esp already in handler (recursive)</span></span><br><span class="line">		<span class="keyword">if</span> ((tf-&gt;tf_esp &gt;= UXSTACKTOP - PGSIZE) &amp;&amp; (tf-&gt;tf_esp &lt; UXSTACKTOP))&#123;</span><br><span class="line">			<span class="comment">// recursive exception stack</span></span><br><span class="line">			utf_top = tf-&gt;tf_esp - <span class="keyword">sizeof</span>(struct UTrapframe) - <span class="number">4</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			utf_top = UXSTACKTOP - <span class="keyword">sizeof</span>(struct UTrapframe);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//check permission on exception stack</span></span><br><span class="line">		user_mem_assert(curenv, utf_top, <span class="keyword">sizeof</span>(struct UTrapframe), PTE_W | PTE_U);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//push UTrapframe</span></span><br><span class="line">		utf = (struct UTrapframe *)utf_top;</span><br><span class="line">		utf-&gt;utf_fault_va = fault_va;</span><br><span class="line">		utf-&gt;utf_err = tf-&gt;tf_err;</span><br><span class="line">		utf-&gt;utf_regs = tf-&gt;tf_regs;</span><br><span class="line">		utf-&gt;utf_eip = tf-&gt;tf_eip;</span><br><span class="line">		utf-&gt;utf_eflags = tf-&gt;tf_eflags;</span><br><span class="line">		utf-&gt;utf_esp = tf-&gt;tf_esp;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//modify stack and ip</span></span><br><span class="line">		(&amp;(curenv-&gt;env_tf))-&gt;tf_eip = (<span class="keyword">uintptr_t</span>)curenv-&gt;env_pgfault_upcall;</span><br><span class="line">		(&amp;(curenv-&gt;env_tf))-&gt;tf_esp = utf_top;</span><br><span class="line">		env_run(curenv);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Destroy the environment that caused the fault.</span></span><br><span class="line">	cprintf(<span class="string">"[%08x] user fault va %08x ip %08x\n"</span>,</span><br><span class="line">		curenv-&gt;env_id, fault_va, tf-&gt;tf_eip);</span><br><span class="line">	print_trapframe(tf);</span><br><span class="line">	env_destroy(curenv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="用户模式页错误入口"><a href="#用户模式页错误入口" class="headerlink" title="用户模式页错误入口"></a>用户模式页错误入口</h2><p>在处理完页错误之后，现在我们需要编写汇编语句实现从异常栈到正常栈的切换，该例程将会调用C页面错误处理程序（<code>sys_env_set_pgfault_upcall()</code>）。</p>
<p>实现<code>lib/pfentry.S</code>中的<code>_pgfault_upcall</code>例程。这部分最有趣的在于如何返回用户触发page fault的代码。我们在这里将要直接返回而无需再陷入内核。难点在于如何同时切换栈以及重新加载<code>eip</code>。</p>
<ul>
<li><code>_pgfault_upcall()</code>：分析其汇编代码逻辑，我们知道它将<code>_pgfault_handler()</code>这个全局函数指针放入<code>eax</code>中并执行，这个全局函数<code>_pgfault_handler()</code>实际上就是我们的C处理页异常的例程（在<code>pgfault.c</code>中定义并且通过用户环境程序显式调用<code>set_pgfault_handler()</code>去定制该处理函数）。</li>
</ul>
<p>仔细阅读注释，这里有一些坑点：</p>
<p>首先我们要跳转回发生异常的<code>eip</code>时，已经恢复了所有现场（包括<code>esp</code>），这里不能使用<code>jmp</code>进行跳转（因为需要一个目的地址，我们不能用寄存器存了）。而且我们不能直接<code>ret</code>（因为<code>ret</code>会改变<code>esp</code>）。所以我们应该在切换栈之前将异常时的<code>eip</code>装载到异常处理栈的栈顶，切换栈的时候设置<code>esp = esp-4</code>，然后这样使用<code>ret</code>返回时就会取出<code>eip</code>并且返回同时使<code>esp=esp+4</code>。这样做是完全合理的，非嵌套情况下的异常处理栈栈顶之上（更低的地址）是空的，而嵌套情况两个异常处理栈之间会存在32bits的空白空间，因此完全没问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">.text</span><br><span class="line">.globl _pgfault_upcall</span><br><span class="line">_pgfault_upcall:</span><br><span class="line">    // 调用用户定义的页错误处理函数</span><br><span class="line">    // Call the C page fault handler.</span><br><span class="line">    pushl %esp          // function argument: pointer to UTF</span><br><span class="line">    movl _pgfault_handler, %eax</span><br><span class="line">    call *%eax</span><br><span class="line">    addl $4, %esp           // pop function argument</span><br><span class="line"></span><br><span class="line">    // LAB 4: Your code here.</span><br><span class="line">    movl 48(%esp), %ebp</span><br><span class="line">    subl $4, %ebp</span><br><span class="line">    movl %ebp, 48(%esp)</span><br><span class="line">    movl 40(%esp), %eax</span><br><span class="line">    movl %eax, (%ebp)</span><br><span class="line"></span><br><span class="line">    // Restore the trap-time registers.  After you do this, you</span><br><span class="line">    // can no longer modify any general-purpose registers.</span><br><span class="line">    // LAB 4: Your code here.</span><br><span class="line">    // 跳过 utf_err 以及 utf_fault_va</span><br><span class="line">    addl $8, %esp</span><br><span class="line">    // popal 同时 esp 会增加，执行结束后 %esp 指向 utf_eip</span><br><span class="line">    popal</span><br><span class="line"></span><br><span class="line">    // Restore eflags from the stack.  After you do this, you can</span><br><span class="line">    // no longer use arithmetic operations or anything else that</span><br><span class="line">    // modifies eflags.</span><br><span class="line">    // LAB 4: Your code here.</span><br><span class="line">    // 跳过 utf_eip</span><br><span class="line">    addl $4, %esp</span><br><span class="line">    // 恢复 eflags</span><br><span class="line">    popfl</span><br><span class="line"></span><br><span class="line">    // Switch back to the adjusted trap-time stack.</span><br><span class="line">    // LAB 4: Your code here.</span><br><span class="line">    // 恢复 trap-time 的栈顶</span><br><span class="line">    popl %esp</span><br><span class="line">    // Return to re-execute the instruction that faulted.</span><br><span class="line">    // LAB 4: Your code here.</span><br><span class="line">    // ret 指令相当于 popl %eip</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>
<p>首先必须要理解异常栈的结构，下图所示的是嵌套异常时的情况。其中左边表示内容，右边表示地址。需要注意的是，上一次异常的栈顶之下间隔 4byte，就是一个新的异常。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">                 utf_esp</span><br><span class="line">reserved 32 bit  </span><br><span class="line">utf_esp          48(%esp)</span><br><span class="line">utf_eflags       44(%esp)</span><br><span class="line">utf_eip          40(%esp)</span><br><span class="line">utf_regs(end)    36(%esp)</span><br><span class="line">...</span><br><span class="line">utf_regs(start)   8(%esp)</span><br><span class="line">utf_err           4(%esp)</span><br><span class="line">utf_fault_va       (%esp)</span><br></pre></td></tr></table></figure></p>
<p>最难理解的是这一部分：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">movl 48(%esp), %ebp  // 使 %ebp 指向 utf_esp</span><br><span class="line">subl $4, %ebp        // %ebp-4</span><br><span class="line">movl %ebp, 48(%esp)  // 更新 utf_esp 值为 utf_esp-4</span><br><span class="line">movl 40(%esp), %eax</span><br><span class="line">movl %eax, (%ebp)  // 将 utf_esp-4 地址的内容改为 utf_eip</span><br></pre></td></tr></table></figure></p>
<p>经过这一部分的修改，异常栈更新为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">                 utf_esp</span><br><span class="line">utf_eip</span><br><span class="line">utf_esp-4        48(%esp)</span><br><span class="line">utf_eflags       44(%esp)</span><br><span class="line">utf_eip          40(%esp)</span><br><span class="line">utf_regs(end)    36(%esp)</span><br><span class="line">...</span><br><span class="line">utf_regs(start)   8(%esp)</span><br><span class="line">utf_err           4(%esp)</span><br><span class="line">utf_fault_va       (%esp)</span><br></pre></td></tr></table></figure></p>
<p>此后就是恢复各寄存器，最后的<code>ret</code>指令相当于<code>popl %eip</code>，指令寄存器的值修改为<code>utf_eip</code>，达到了返回的效果。</p>
<p>实现<code>set_pgfault_handler()</code>练习是用户用来指定缺页异常处理方式的函数。代码比较简单，但是需要区分清楚<code>handler</code>，<code>_pgfault_handler</code>，<code>_pgfault_upcall</code>三个变量。</p>
<p><code>handler</code>是传入的用户自定义页错误处理函数指针。</p>
<p><code>_pgfault_upcall</code>是一个全局变量，在<code>lib/pfentry.S</code>中完成的初始化。它是页错误处理的总入口，页错误除了运行 page fault handler，还需要切换回正常栈。</p>
<p><code>_pgfault_handler</code>被赋值为<code>handler</code>，会在<code>_pgfault_upcall</code>中被调用，是页错误处理的一部分。具体代码是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.text</span><br><span class="line">.globl _pgfault_upcall</span><br><span class="line">_pgfault_upcall:</span><br><span class="line">    // Call the C page fault handler.</span><br><span class="line">    pushl %esp          // function argument: pointer to UTF</span><br><span class="line">    movl _pgfault_handler, %eax</span><br><span class="line">    call *%eax</span><br><span class="line">    addl $4, %esp</span><br></pre></td></tr></table></figure></p>
<p>若是第一次调用，需要首先在这个<code>env</code>分配一个页面作为异常栈，并且将该进程的<code>upcall</code>设置为 Exercise 10 中的程序。此后如果需要改变<code>handler</code>，不需要再重复这个工作。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">set_pgfault_handler(<span class="keyword">void</span> (*handler)(struct UTrapframe *utf))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_pgfault_handler == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// First time through!</span></span><br><span class="line">        <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">        <span class="keyword">envid_t</span> e_id = sys_getenvid();</span><br><span class="line">        r = sys_page_alloc(e_id, (<span class="keyword">void</span> *)(UXSTACKTOP-PGSIZE), PTE_U | PTE_W | PTE_P);</span><br><span class="line">        <span class="keyword">if</span> (r &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            panic(<span class="string">"pgfault_handler: %e"</span>, r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// r = sys_env_set_pgfault_upcall(e_id, handler);</span></span><br><span class="line">        r = sys_env_set_pgfault_upcall(e_id, _pgfault_upcall);</span><br><span class="line">        <span class="keyword">if</span> (r &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            panic(<span class="string">"pgfault_handler: %e"</span>, r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Save handler pointer for assembly to call.</span></span><br><span class="line">    _pgfault_handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>user/faultalloc</code>的部分输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">envs: f0292000, e: f0292000, e-&gt;env_id: 1000</span><br><span class="line">env_id, 1000</span><br><span class="line">[00000000] new env 00001000</span><br><span class="line">envs[0].env_status: 2</span><br><span class="line">PAGE FAULT</span><br><span class="line">fault deadbeef</span><br><span class="line">this string was faulted in at deadbeef</span><br><span class="line">PAGE FAULT</span><br><span class="line">fault cafebffe</span><br><span class="line">PAGE FAULT</span><br><span class="line">fault cafec000</span><br><span class="line">this string was faulted in at cafebffe</span><br><span class="line">[00001000] exiting gracefully</span><br><span class="line">[00001000] free env 00001000</span><br><span class="line">envs[0].env_status: 0</span><br><span class="line">envs[1].env_status: 0</span><br><span class="line">envs[0].env_status: 0</span><br><span class="line">envs[1].env_status: 0</span><br><span class="line">No runnable environments in the system!</span><br><span class="line">Welcome to the JOS kernel monitor!</span><br><span class="line">Type &apos;help&apos; for a list of commands.</span><br></pre></td></tr></table></figure></p>
<p><code>user/faultallocbad</code>的部分输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">envs: f0292000, e: f0292000, e-&gt;env_id: 1000</span><br><span class="line">env_id, 1000</span><br><span class="line">[00000000] new env 00001000</span><br><span class="line">envs[0].env_status: 2</span><br><span class="line">[00001000] user_mem_check assertion failure for va deadbeef</span><br><span class="line">[00001000] free env 00001000</span><br><span class="line">envs[0].env_status: 0</span><br><span class="line">envs[1].env_status: 0</span><br><span class="line">envs[0].env_status: 0</span><br><span class="line">envs[1].env_status: 0</span><br><span class="line">No runnable environments in the system!</span><br><span class="line">Welcome to the JOS kernel monitor!</span><br><span class="line">Type &apos;help&apos; for a list of commands.</span><br></pre></td></tr></table></figure></p>
<p>可以发现两个程序的输出有所不同，但是两者的page fault handler相同，因为一个使用<code>cprintf()</code>输出，一个使用<code>sys_cput()</code>输出。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test user-level fault handler -- alloc pages to fix faults</span></span><br><span class="line"><span class="comment">// faultalloc.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inc/lib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">handler(struct UTrapframe *utf)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line">	<span class="keyword">void</span> *addr = (<span class="keyword">void</span>*)utf-&gt;utf_fault_va;</span><br><span class="line"></span><br><span class="line">	cprintf(<span class="string">"fault %x\n"</span>, addr);</span><br><span class="line">	<span class="keyword">if</span> ((r = sys_page_alloc(<span class="number">0</span>, ROUNDDOWN(addr, PGSIZE),</span><br><span class="line">				PTE_P|PTE_U|PTE_W)) &lt; <span class="number">0</span>)</span><br><span class="line">		panic(<span class="string">"allocating at %x in page fault handler: %e"</span>, addr, r);</span><br><span class="line">	<span class="built_in">snprintf</span>((<span class="keyword">char</span>*) addr, <span class="number">100</span>, <span class="string">"this string was faulted in at %x"</span>, addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">umain(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span><br><span class="line">&#123;</span><br><span class="line">	set_pgfault_handler(handler);</span><br><span class="line">	cprintf(<span class="string">"%s\n"</span>, (<span class="keyword">char</span>*)<span class="number">0xDeadBeef</span>);</span><br><span class="line">	cprintf(<span class="string">"%s\n"</span>, (<span class="keyword">char</span>*)<span class="number">0xCafeBffe</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// test user-level fault handler -- alloc pages to fix faults</span></span><br><span class="line"><span class="comment">// doesn't work because we sys_cputs instead of cprintf (exercise: why?)</span></span><br><span class="line"><span class="comment">// faultallocbad.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inc/lib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">handler(struct UTrapframe *utf)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line">	<span class="keyword">void</span> *addr = (<span class="keyword">void</span>*)utf-&gt;utf_fault_va;</span><br><span class="line"></span><br><span class="line">	cprintf(<span class="string">"fault %x\n"</span>, addr);</span><br><span class="line">	<span class="keyword">if</span> ((r = sys_page_alloc(<span class="number">0</span>, ROUNDDOWN(addr, PGSIZE),</span><br><span class="line">				PTE_P|PTE_U|PTE_W)) &lt; <span class="number">0</span>)</span><br><span class="line">		panic(<span class="string">"allocating at %x in page fault handler: %e"</span>, addr, r);</span><br><span class="line">	<span class="built_in">snprintf</span>((<span class="keyword">char</span>*) addr, <span class="number">100</span>, <span class="string">"this string was faulted in at %x"</span>, addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">umain(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span><br><span class="line">&#123;</span><br><span class="line">	set_pgfault_handler(handler);</span><br><span class="line">	sys_cputs((<span class="keyword">char</span>*)<span class="number">0xDEADBEEF</span>, <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用<code>sys_cput()</code>的时候会直接通过<code>lib/syscall.c</code>发起系统调用，其在<code>kern/syscall.c</code>中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">sys_cputs(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">size_t</span> len)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Check that the user has permission to read memory [s, s+len).</span></span><br><span class="line">    <span class="comment">// Destroy the environment if not.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">    user_mem_assert(curenv, s, len, PTE_U);</span><br><span class="line">    <span class="comment">// Print the string supplied by the user.</span></span><br><span class="line">    cprintf(<span class="string">"%.*s"</span>, len, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>它检查了内存，因此在这里 panic 了。中途没有触发过页错误。</p>
<p>而<code>cprintf()</code>的实现可以在<code>lib/printf.c</code>中找到：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">vcprintf(<span class="keyword">const</span> <span class="keyword">char</span> *fmt, va_list ap)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">printbuf</span> <span class="title">b</span>;</span></span><br><span class="line"></span><br><span class="line">    b.idx = <span class="number">0</span>;</span><br><span class="line">    b.cnt = <span class="number">0</span>;</span><br><span class="line">    vprintfmt((<span class="keyword">void</span>*)putch, &amp;b, fmt, ap);</span><br><span class="line">    sys_cputs(b.buf, b.idx);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> b.cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">cprintf(<span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span><br><span class="line">&#123;</span><br><span class="line">    va_list ap;</span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line"></span><br><span class="line">    va_start(ap, fmt);</span><br><span class="line">    cnt = vcprintf(fmt, ap);</span><br><span class="line">    va_end(ap);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>它在调用<code>sys_cputs()</code>之前，首先在用户态执行了<code>vprintfmt()</code>将要输出的字符串存入结构体<code>b</code>中。在此过程中试图访问<code>0xdeadbeef</code>地址，触发并处理了页错误（其处理方式是在错误位置处分配一个字符串，内容是 “this string was faulted in at …”），因此在继续调用<code>sys_cputs()</code>时不会出现 panic。</p>
<h3 id="实现-Copy-on-Write-Fork"><a href="#实现-Copy-on-Write-Fork" class="headerlink" title="实现 Copy-on-Write Fork"></a>实现 Copy-on-Write Fork</h3><p>现在我们已经具备了在用户空间实现<code>copy-on-write fork()</code>的条件。</p>
<p>现在同样在<code>lib/fork.c</code>中给出了<code>fork()</code>的框架。如同<code>dumbfork()</code>一样，<code>fork()</code>也要创建一个新进程，并且在新进程中建立与父进程同样的内存映射。关键的不同点是，<code>dumbfork()</code>拷贝了物理页的内容，而<code>fork()</code>仅拷贝了映射关系，仅在某个进程需要改写某一页的内容时，才拷贝这一页的内容。其基本流程如下：</p>
<ul>
<li>父进程使用<code>set_pgfault_handler</code>将<code>pgfault()</code>设为<code>page fault handler</code></li>
<li>父进程使用<code>sys_exofork()</code>建立一个子进程</li>
<li>对每个在<code>UTOP</code>之下可写页面以及 COW 页面（用<code>PTE_COW</code>标识），父进程调用<code>duppage()</code>将其“映射”到子进程，同时将其权限改为只读，并用<code>PTE_COW</code>位来与一般只读页面区别。<ul>
<li>这个函数的作用是把一个页面以写时复制权限<code>PTE_COW</code>映射到子环境，然后再以写时复制权限映射到父进程（这个顺序很重要）。</li>
<li>以写时复制映射：先取消写权限（如果有），然后再加上写时复制权限用以区分普通只读页面。</li>
<li>异常栈的分配方式与此不同，需要在子进程中分配一个新页面。因为<code>page fault handler</code>会实实在在地向异常栈写入内容，并在异常栈上运行。如果异常栈页面都用<code>COW</code>机制，那就没有能够执行拷贝这个过程的载体了</li>
<li><code>fork()</code>同样需要处理<code>PTE_P</code>权限的页面（非可写或写时复制的）</li>
</ul>
</li>
<li>父进程会为子进程设置用户页错误处理入口。</li>
<li>子进程已经就绪，父进程将其设为<code>runnable</code></li>
</ul>
<p>进程第一次往一个 COW page 写入内容时，会发生 page fault，其流程为：</p>
<ul>
<li>内核将 page fault 传递至<code>_pgfault_upcall</code>，它会调用<code>pgfault() handler</code></li>
<li><code>pgfault()</code>检查错误号（error code）是否为<code>FEC_WR</code>（写操作），即是由于写操作触发了异常。然后检查触发异常的页面是否为写时复制的，如果不是则直接panic内核。</li>
<li><code>pgfault()</code>分配一个新的页面并将 fault page 的内容拷贝进去，然后将旧的映射覆盖，使其以可读可写权限映射到该新页面，并且取代原来的映射。</li>
</ul>
<p>用户级别的<code>lib/fork.c</code>代码需要查看环境的页表（查询某个页面是否为写时复制），这也是内核将环境的页表映射到<code>UVPT</code>位置的原因（因为用户环境不能访问内核，不具备访问<code>kern_pgdir</code>以及使用<code>pgdir_walk</code>的权限）。所以为了能够让用户环境访问到<code>PTE</code>和<code>PDE</code>，jos采取了这种clever mapping trick：UVPT</p>
<h3 id="UVPT"><a href="#UVPT" class="headerlink" title="UVPT"></a>UVPT</h3><p>页表的一个很好的概念模型是一个 2^20 条目的数组，它可以通过物理页号进行索引。x86 2 级分页方案通过将巨型页表分成许多页表和一个页目录来打破这个简单的模型。在内核中，我们使用<code>pgdir_walk()</code>通过遍历两级页表来查找条目。以某种方式恢复巨大的简单页表会很好——JOS 中的进程将查看它以弄清楚它们的地址空间中发生了什么。</p>
<p>这个页面描述了 JOS 通过利用分页硬件使用的一个巧妙的技巧——分页硬件非常适合将一组碎片页面放在一个连续的地址空间中。事实证明，我们已经有一个表，其中包含指向所有碎片页表的指针：它是页目录！</p>
<p>因此，我们可以使用页目录作为页表，在虚拟地址空间中某个连续的 2^22 字节范围内映射我们概念上的巨大 2^22 字节页表（由 1024 个页面表示）。我们可以通过将 PDE 条目标记为只读来确保用户进程不能修改他们的页表。</p>
<p>解释一下，每个4GB虚拟地址空间对应一个页目录，一个页目录包含2^10（10bits）个页表，每个页表有 2^10(10bits)页，每页的大小是 2^12B(12bits)，最终形成4GB地址空间。</p>
<p><img src="/img/20211124224000.png" alt></p>
<p>CR3指向页目录，解析一个线性地址，MMU会跟据其PDX，PTX和OFFSET三个部分依次去在页目录（通过目录项找到页表）和页表（通过表项找到页）中进行索引。</p>
<p>但是处理器分不清楚页表、页目录，它只是根据以下过程来进行查找：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pd = lcr3(); </span><br><span class="line">pt = *(pd+4*PDX); </span><br><span class="line">page = *(pt+4*PTX);</span><br></pre></td></tr></table></figure></p>
<p>UVPT是页目录中的一个特殊的entry，它指向的是页目录自身。若UVPT的索引值是V，如果我们用一个PDX和PTX都是V的线性地址去进行解析，就会发现由于在页目录中对第V个entry的索引仍然是页目录本身的地址，这个地址最终解析出的就是页目录的物理地址（你可以理解为页目录本身就是一个页表，这种方式下我们连续两次解析到页目录本身的地址）。在JOS中，V=0x3BD，所以UVPD的虚拟地址是<code>(0x3BD &lt;&lt; 22)|(0x3BD &lt;&lt; 12)</code>。</p>
<p>同理，如果PDX为V而PTX不为V，则会解析出各个页表的地址。在JOS中，V=0x3BD，所以UVPT的虚拟地址是<code>(0x3BD &lt;&lt; 22)</code>。通过这种方式，用户可以在UVPT内存区中访问到页目录和各个页表。<br><img src="/img/20211124224001.png" alt></p>
<h3 id="fork函数"><a href="#fork函数" class="headerlink" title="fork函数"></a>fork函数</h3><p>首先从主函数<code>fork()</code>入手，其大体结构可以仿造<code>user/dumbfork.c</code>写，但是有关键几处不同：</p>
<ul>
<li>设置<code>page fault handler</code>，即<code>page fault upcall</code>调用的函数</li>
<li><code>duppage</code>的范围不同，<code>fork()</code>不需要复制内核区域的映射</li>
<li>为子进程设置<code>page fault upcall</code>，之所以这么做，是因为<code>sys_exofork()</code>并不会复制父进程的<code>e-&gt;env_pgfault_upcall</code>给子进程。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">envid_t</span></span><br><span class="line">fork(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">    <span class="comment">// panic("fork not implemented");</span></span><br><span class="line"></span><br><span class="line">    set_pgfault_handler(pgfault);</span><br><span class="line">    <span class="keyword">envid_t</span> e_id = sys_exofork();</span><br><span class="line">    <span class="keyword">if</span> (e_id &lt; <span class="number">0</span>) panic(<span class="string">"fork: %e"</span>, e_id);</span><br><span class="line">    <span class="keyword">if</span> (e_id == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// child</span></span><br><span class="line">        thisenv = &amp;envs[ENVX(sys_getenvid())];</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// parent</span></span><br><span class="line">    <span class="comment">// extern unsigned char end[];</span></span><br><span class="line">    <span class="comment">// for ((uint8_t *) addr = UTEXT; addr &lt; end; addr += PGSIZE)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uintptr_t</span> addr = UTEXT; addr &lt; USTACKTOP; addr += PGSIZE) &#123;</span><br><span class="line">        <span class="keyword">if</span> ( (uvpd[PDX(addr)] &amp; PTE_P) &amp;&amp; (uvpt[PGNUM(addr)] &amp; PTE_P) ) &#123;</span><br><span class="line">            <span class="comment">// dup page to child</span></span><br><span class="line">            duppage(e_id, PGNUM(addr));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// alloc page for exception stack</span></span><br><span class="line">    <span class="keyword">int</span> r = sys_page_alloc(e_id, (<span class="keyword">void</span> *)(UXSTACKTOP-PGSIZE), PTE_U | PTE_W | PTE_P);</span><br><span class="line">    <span class="keyword">if</span> (r &lt; <span class="number">0</span>) panic(<span class="string">"fork: %e"</span>,r);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// DO NOT FORGET</span></span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">void</span> _pgfault_upcall();</span><br><span class="line">    r = sys_env_set_pgfault_upcall(e_id, _pgfault_upcall);</span><br><span class="line">    <span class="keyword">if</span> (r &lt; <span class="number">0</span>) panic(<span class="string">"fork: set upcall for child fail, %e"</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mark the child environment runnable</span></span><br><span class="line">    <span class="keyword">if</span> ((r = sys_env_set_status(e_id, ENV_RUNNABLE)) &lt; <span class="number">0</span>)</span><br><span class="line">        panic(<span class="string">"sys_env_set_status: %e"</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> e_id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="duppage-函数"><a href="#duppage-函数" class="headerlink" title="duppage()函数"></a>duppage()函数</h3><p>该函数的作用是复制父、子进程的页面映射。尤其注意一个权限问题。由于<code>sys_page_map()</code>页面的权限有硬性要求，因此必须要修正一下权限。之前没有修正导致一直报错，后来发现页面权限为<code>0x865</code>，不符合<code>sys_page_map()</code>要求。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">duppage(<span class="keyword">envid_t</span> envid, <span class="keyword">unsigned</span> pn)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">    <span class="comment">// panic("duppage not implemented");</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">envid_t</span> this_env_id = sys_getenvid();</span><br><span class="line">    <span class="keyword">void</span> * va = (<span class="keyword">void</span> *)(pn * PGSIZE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> perm = uvpt[pn] &amp; <span class="number">0xFFF</span>;</span><br><span class="line">    <span class="keyword">if</span> ( (perm &amp; PTE_W) || (perm &amp; PTE_COW) ) &#123;</span><br><span class="line">        <span class="comment">// marked as COW and read-only</span></span><br><span class="line">        perm |= PTE_COW;</span><br><span class="line">        perm &amp;= ~PTE_W;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// IMPORTANT: adjust permission to the syscall</span></span><br><span class="line">    perm &amp;= PTE_SYSCALL;</span><br><span class="line">    <span class="comment">// cprintf("fromenvid = %x, toenvid = %x, dup page %d, addr = %08p, perm = %03x\n",this_env_id, envid, pn, va, perm);</span></span><br><span class="line">    <span class="keyword">if</span>((r = sys_page_map(this_env_id, va, envid, va, perm)) &lt; <span class="number">0</span>) </span><br><span class="line">        panic(<span class="string">"duppage: %e"</span>,r);</span><br><span class="line">    <span class="keyword">if</span>((r = sys_page_map(this_env_id, va, this_env_id, va, perm)) &lt; <span class="number">0</span>) </span><br><span class="line">        panic(<span class="string">"duppage: %e"</span>,r);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="pgfault-函数"><a href="#pgfault-函数" class="headerlink" title="pgfault() 函数"></a>pgfault() 函数</h3><p>这是<code>_pgfault_upcall</code>中调用的页错误处理函数。在调用之前，父子进程的页错误地址都引用同一页物理内存，该函数作用是分配一个物理页面使得两者独立。</p>
<p>首先，它分配一个页面，映射到了交换区<code>PFTEMP</code>这个虚拟地址，然后通过<code>memmove()</code>函数将<code>addr</code>所在页面拷贝至<code>PFTEMP</code>，此时有两个物理页保存了同样的内容。再将<code>addr</code>也映射到<code>PFTEMP</code>对应的物理页，最后解除了<code>PFTEMP</code>的映射，此时就只有<code>addr</code>指向新分配的物理页了，如此就完成了错误处理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">pgfault(struct UTrapframe *utf)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> *addr = (<span class="keyword">void</span> *) utf-&gt;utf_fault_va;</span><br><span class="line">    <span class="keyword">uint32_t</span> err = utf-&gt;utf_err;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check that the faulting access was (1) a write, and (2) to a</span></span><br><span class="line">    <span class="comment">// copy-on-write page.  If not, panic.</span></span><br><span class="line">    <span class="comment">// Hint:</span></span><br><span class="line">    <span class="comment">//   Use the read-only page table mappings at uvpt</span></span><br><span class="line">    <span class="comment">//   (see &lt;inc/memlayout.h&gt;).</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">    <span class="keyword">if</span> ((err &amp; FEC_WR)==<span class="number">0</span> || (uvpt[PGNUM(addr)] &amp; PTE_COW)==<span class="number">0</span>) &#123;</span><br><span class="line">        panic(<span class="string">"pgfault: invalid user trap frame"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Allocate a new page, map it at a temporary location (PFTEMP),</span></span><br><span class="line">    <span class="comment">// copy the data from the old page to the new page, then move the new</span></span><br><span class="line">    <span class="comment">// page to the old page's address.</span></span><br><span class="line">    <span class="comment">// Hint:</span></span><br><span class="line">    <span class="comment">//   You should make three system calls.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">    <span class="comment">// panic("pgfault not implemented");</span></span><br><span class="line">    <span class="keyword">envid_t</span> envid = sys_getenvid();</span><br><span class="line">    <span class="keyword">if</span> ((r = sys_page_alloc(envid, (<span class="keyword">void</span> *)PFTEMP, PTE_P | PTE_W | PTE_U)) &lt; <span class="number">0</span>)</span><br><span class="line">        panic(<span class="string">"pgfault: page allocation failed %e"</span>, r);</span><br><span class="line"></span><br><span class="line">    addr = ROUNDDOWN(addr, PGSIZE);</span><br><span class="line">    memmove(PFTEMP, addr, PGSIZE);</span><br><span class="line">    <span class="keyword">if</span> ((r = sys_page_unmap(envid, addr)) &lt; <span class="number">0</span>)</span><br><span class="line">        panic(<span class="string">"pgfault: page unmap failed (%e)"</span>, r);</span><br><span class="line">    <span class="keyword">if</span> ((r = sys_page_map(envid, PFTEMP, envid, addr, PTE_P | PTE_W |PTE_U)) &lt; <span class="number">0</span>)</span><br><span class="line">        panic(<span class="string">"pgfault: page map failed (%e)"</span>, r);</span><br><span class="line">    <span class="keyword">if</span> ((r = sys_page_unmap(envid, PFTEMP)) &lt; <span class="number">0</span>)</span><br><span class="line">        panic(<span class="string">"pgfault: page unmap failed (%e)"</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Part-C-抢占式多进程处理-amp-进程间通信"><a href="#Part-C-抢占式多进程处理-amp-进程间通信" class="headerlink" title="Part C: 抢占式多进程处理 &amp; 进程间通信"></a>Part C: 抢占式多进程处理 &amp; 进程间通信</h1><p>作为 lab4 的最后一步，我们要修改内核使之能抢占一些不配合的进程占用的资源，以及允许进程之间的通信。</p>
<h2 id="Part-I-时钟中断以及抢占"><a href="#Part-I-时钟中断以及抢占" class="headerlink" title="Part I: 时钟中断以及抢占"></a>Part I: 时钟中断以及抢占</h2><p>尝试运行一下 user/spin 测试，该测试建立一个子进程，该子进程获得 CPU 资源后就进入死循环，这样内核以及父进程都无法再次获得 CPU。这显然是操作系统需要避免的。为了允许内核从一个正在运行的进程抢夺 CPU 资源，我们需要支持来自硬件时钟的外部硬件中断。</p>
<h3 id="Interrupt-discipline"><a href="#Interrupt-discipline" class="headerlink" title="Interrupt discipline"></a>Interrupt discipline</h3><p>外部中断用 IRQ(Interrupt Request) 表示。一共有 16 种 IRQ，IRQ的编号到IDT表项的映射并不是固定的。<code>picirq.c</code>的<code>pic_init()</code>将会把0-15号IRQ映射到<code>IDT</code>表项中对应的<code>IRQ_OFFSET</code>-<code>IRQ_OFFSET+15</code>。</p>
<p><code>IRQ_OFFSET</code>被定义为32（在<code>inc/trap.h</code>中），那么<code>IDT</code>表项的32-47就对应了15种<code>IRQ</code>，时钟中断是<code>IRQ 0</code>。这样设置不会让处理器异常和IRQ重叠。</p>
<p>Lab3中介绍 x86 的所有异常可以用中断向量 0~31 表示，对应 IDT 的第 0~31 项。例如，页错误产生一个中断向量为 14 的异常。大于 32 的中断向量表示的都是中断</p>
<p>相对 xv6，在 JOS 中我们中了一个关键的简化：在内核态时禁用外部设备中断。外部中断使用<code>%eflag</code>寄存器的<code>FL_IF</code>位控制。当该位置 1 时，开启中断。由于我们的简化，我们只在进入以及离开内核时需要修改这个位。</p>
<p>我们需要确保在用户态时<code>FL_IF</code>置 1，使得当有中断发生时，可以被处理。我们在<code>bootloader</code>的第一条指令<code>cli</code>就关闭了中断，然后再也没有开启过。</p>
<p>exercise13要求我们修改<code>kern/trap.c</code>和<code>kern/trapentry.S</code>，来初始化IDT中的入口，为IRQ 0到15提供处理函数。然后修改<code>env_alloc</code>，确保用户环境能够在使能中断时运行。</p>
<p>比较简单，跟 Lab3 中的 Exercise 4 大同小异。相关的常数定义在<code>inc/trap.h</code>中可以找到。</p>
<p>在<code>kern/trapentry.S</code>中加入：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IRQs</span></span><br><span class="line">TRAPHANDLER(handler32, IRQ_OFFSET + IRQ_TIMER)</span><br><span class="line">TRAPHANDLER(handler33, IRQ_OFFSET + IRQ_KBD)</span><br><span class="line">TRAPHANDLER(handler36, IRQ_OFFSET + IRQ_SERIAL)</span><br><span class="line">TRAPHANDLER(handler39, IRQ_OFFSET + IRQ_SPURIOUS)</span><br><span class="line">TRAPHANDLER(handler46, IRQ_OFFSET + IRQ_IDE)</span><br><span class="line">TRAPHANDLER(handler51, IRQ_OFFSET + IRQ_ERROR)</span><br></pre></td></tr></table></figure></p>
<p>在<code>kern/trap.c</code>的<code>trap_init()</code>中加入：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// IRQs</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handler32</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handler33</span><span class="params">()</span></span>;   </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handler36</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handler39</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handler46</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handler51</span><span class="params">()</span></span>;</span><br><span class="line">...</span><br><span class="line">    <span class="comment">// IRQs</span></span><br><span class="line">    SETGATE(idt[IRQ_OFFSET + IRQ_TIMER], <span class="number">0</span>, GD_KT, handler32, <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[IRQ_OFFSET + IRQ_KBD], <span class="number">0</span>, GD_KT, handler33, <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[IRQ_OFFSET + IRQ_SERIAL], <span class="number">0</span>, GD_KT, handler36, <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[IRQ_OFFSET + IRQ_SPURIOUS], <span class="number">0</span>, GD_KT, handler39, <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[IRQ_OFFSET + IRQ_IDE], <span class="number">0</span>, GD_KT, handler46, <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[IRQ_OFFSET + IRQ_ERROR], <span class="number">0</span>, GD_KT, handler51, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></p>
<p>这里需要注意，<code>SETGATE</code>中<code>istrap</code>参数需要设置为0。根据<code>SETGATE</code>的注释，两个值的区别在于，设为<code>1</code>就会在开始处理中断时将<code>FL_IF</code>位重新置1，而设为<code>0</code>则保持<code>FL_IF</code>位不变。根据这里的需求，显然应该置0。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Set up a normal interrupt/trap gate descriptor.</span></span><br><span class="line"><span class="comment">// - istrap: 1 for a trap (= exception) gate, 0 for an interrupt gate.</span></span><br><span class="line">    <span class="comment">//   see section 9.6.1.3 of the i386 reference: "The difference between</span></span><br><span class="line">    <span class="comment">//   an interrupt gate and a trap gate is in the effect on IF (the</span></span><br><span class="line">    <span class="comment">//   interrupt-enable flag). An interrupt that vectors through an</span></span><br><span class="line">    <span class="comment">//   interrupt gate resets IF, thereby preventing other interrupts from</span></span><br><span class="line">    <span class="comment">//   interfering with the current interrupt handler. A subsequent IRET</span></span><br><span class="line">    <span class="comment">//   instruction restores IF to the value in the EFLAGS image on the</span></span><br><span class="line">    <span class="comment">//   stack. An interrupt through a trap gate does not change IF."</span></span><br><span class="line"><span class="comment">// - sel: Code segment selector for interrupt/trap handler</span></span><br><span class="line"><span class="comment">// - off: Offset in code segment for interrupt/trap handler</span></span><br><span class="line"><span class="comment">// - dpl: Descriptor Privilege Level -</span></span><br><span class="line"><span class="comment">//    the privilege level required for software to invoke</span></span><br><span class="line"><span class="comment">//    this interrupt/trap gate explicitly using an int instruction.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SETGATE(gate, istrap, sel, off, dpl)            \</span></span><br><span class="line">&#123;                               \</span><br><span class="line">    (gate).gd_off_15_0 = (<span class="keyword">uint32_t</span>) (off) &amp; <span class="number">0xffff</span>;     \</span><br><span class="line">    (gate).gd_sel = (sel);                  \</span><br><span class="line">    (gate).gd_args = <span class="number">0</span>;                 \</span><br><span class="line">    (gate).gd_rsv1 = <span class="number">0</span>;                 \</span><br><span class="line">    (gate).gd_type = (istrap) ? STS_TG32 : STS_IG32;    \</span><br><span class="line">    (gate).gd_s = <span class="number">0</span>;                    \</span><br><span class="line">    (gate).gd_dpl = (dpl);                  \</span><br><span class="line">    (gate).gd_p = <span class="number">1</span>;                    \</span><br><span class="line">    (gate).gd_off_31_16 = (<span class="keyword">uint32_t</span>) (off) &gt;&gt; <span class="number">16</span>;       \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>kern/env.c</code>的<code>env_alloc()</code>中加入：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Enable interrupts while in user mode.</span></span><br><span class="line"><span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">e-&gt;env_tf.tf_eflags |= FL_IF;</span><br></pre></td></tr></table></figure></p>
<h3 id="Handling-Clock-Interrupts"><a href="#Handling-Clock-Interrupts" class="headerlink" title="Handling Clock Interrupts"></a>Handling Clock Interrupts</h3><p>在<code>user/spin</code>程序中，子进程开启后就陷入死循环，此后 kernel 无法再获得控制权。我们需要让硬件周期性地产生时钟中断，强制将控制权交给 kernel，使得我们能够切换到其他进程。</p>
<p>Exercise 14需要修改<code>trap_dispatch()</code>函数，当时钟中断到达时，执行新的环境。</p>
<p>直接在<code>trap_dispatch()</code>中添加时钟中断的分支即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Handle clock interrupts. Don't forget to acknowledge the</span></span><br><span class="line"><span class="comment">// interrupt using lapic_eoi() before calling the scheduler!</span></span><br><span class="line"><span class="comment">// LAB 4: Your code here.</span></span><br><span class="line"><span class="keyword">if</span> (tf-&gt;tf_trapno == IRQ_OFFSET + IRQ_TIMER) &#123;</span><br><span class="line">    lapic_eoi();</span><br><span class="line">    sched_yield();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Part-II-进程间通信-IPC"><a href="#Part-II-进程间通信-IPC" class="headerlink" title="Part II: 进程间通信(IPC)"></a>Part II: 进程间通信(IPC)</h2><p>在之前的 Lab 中，我们一直在讲操作系统是如何隔离各个进程的，怎么让程序感觉独占一台机器的。操作系统的另一个重要功能就是允许进程之间相互通信。</p>
<h3 id="IPC-in-JOS"><a href="#IPC-in-JOS" class="headerlink" title="IPC in JOS"></a>IPC in JOS</h3><p>我们将实现两个系统调用：<code>sys_ipc_recv</code>以及<code>sys_ipc_try_send</code>，再将他们封装为两个库函数，<code>ipc_recv</code>和<code>ipc_send</code>以支持通信。</p>
<p>用户环境可以通过jos系统的IPC机制向其他用户环境发送“消息”（message）。这个消息分为两部分：一个32-bit的值，以及一个可选的单页映射。允许用户环境传递页映射是一种比发送32-bit更有效的数据传递方式（很容易实现共享内存）。</p>
<h3 id="发送和接收消息"><a href="#发送和接收消息" class="headerlink" title="发送和接收消息"></a>发送和接收消息</h3><p>进程使用<code>sys_ipc_recv</code>来接收消息。该系统调用会将程序挂起，让出 CPU 资源，直到收到消息。在这个时期，任一进程都能给他发送信息，不限于父子进程。<br>为了发送信息，进程会调用<code>sys_ipc_try_send</code>，以接收者的进程<code>id</code>以及要发送的值为参数。如果接收者已经调用了<code>sys_ipc_recv</code>，则成功发送消息并返回0。否则返回<code>E_IPC_NOT_RECV</code>表明目标进程并没有接收消息。</p>
<p>用户空间的库函数<code>ipc_recv()</code>将会负责调用<code>sys_ipc_recv()</code>，然后在当前环境的<code>struct Env</code>中查找接收值的信息。相似地，库函数<code>ipc_send()</code>负责重复调用<code>sys_ipc_try_send()</code>直到发送成功。</p>
<h3 id="传递页面"><a href="#传递页面" class="headerlink" title="传递页面"></a>传递页面</h3><p>当进程调用<code>sys_ipc_recv</code>并提供一个<code>UTOP</code>以下的合法虚拟地址<code>dstva</code>(必须位于用户空间)时，进程表示它希望能接收一个页面映射。如果发送者发送一个页面，该页面就会被映射到接收者的<code>dstva</code>。同时，之前位于<code>dstva</code>的页面映射会被覆盖。</p>
<p>当进程调用<code>sys_ipc_try_send</code>并提供一个<code>UTOP</code>以下的合法虚拟地址<code>srcva</code>(必须位于用户空间)，表明发送者希望发送位于<code>srcva</code>的页面给接收者，权限设置为<code>perm</code>。当IPC成功进行之后，发送方会保持<code>srcva</code>处的映射关系，但是接受方同样也会在其地址<code>dstva</code>处映射这个页面。那此时这个页面就成了发送方到接受方的共享页面。</p>
<p>在一个成功的 IPC 之后，发送者和接受者将共享一个物理页。</p>
<p>注意，如果发送方和接收方之间的任意一方没有声明需要传输的是一个页面，那就不会有页面进行传输。</p>
<p>在任何IPC结束之后，内核将会设置接受方的<code>struct Env</code>的<code>env_ipc_perm</code>成员。如果没有接受页面则设置为0，如果接受页面则设置为接收到的页面权限<code>perm</code>。</p>
<h3 id="Implementing-IPC"><a href="#Implementing-IPC" class="headerlink" title="Implementing IPC"></a>Implementing IPC</h3><p>exercise 15实现<code>kern/syscall.c</code>中的<code>sys_ipc_recv()</code>和<code>sys_ipc_try_send()</code>。</p>
<p>当我们需要在这些有关IPC的例程中调用<code>envid2env()</code>时，需要将参数<code>checkperm</code>设置为0，这意味着任何环境都被允许与其他环境进行IPC。</p>
<p>然后实现<code>lib/ipc.c</code>中的<code>ipc_recv()</code>和<code>ipc_send()</code>的封装。</p>
<p>首先需要仔细阅读<code>inc/env.h</code>了解用于传递消息的数据结构。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Lab 4 IPC</span></span><br><span class="line"><span class="keyword">bool</span> env_ipc_recving;       <span class="comment">// Env is blocked receiving</span></span><br><span class="line"><span class="keyword">void</span> *env_ipc_dstva;        <span class="comment">// VA at which to map received page</span></span><br><span class="line"><span class="keyword">uint32_t</span> env_ipc_value;     <span class="comment">// Data value sent to us</span></span><br><span class="line"><span class="keyword">envid_t</span> env_ipc_from;       <span class="comment">// envid of the sender</span></span><br><span class="line"><span class="keyword">int</span> env_ipc_perm;       <span class="comment">// Perm of page mapping received</span></span><br></pre></td></tr></table></figure></p>
<p>然后需要注意的是通信流程。</p>
<ol>
<li>调用<code>ipc_recv</code>，设置好<code>Env</code>结构体中的相关<code>field</code></li>
<li>调用<code>ipc_send</code>，它会通过<code>envid</code>找到接收进程，并读取<code>Env</code>中刚才设置好的<code>field</code>，进行通信。</li>
<li>最后返回实际上是在<code>ipc_send</code>中设置好<code>reg_eax</code>，在调用结束，退出内核态时返回。</li>
</ol>
<p>首先从调用过程入手，这部分比较简单。</p>
<h3 id="lib-部分"><a href="#lib-部分" class="headerlink" title="lib 部分"></a>lib 部分</h3><p><code>ipc_recv</code>中，如果<code>pg</code>不为空，则收到的页会被映射到这里。如果<code>from_env_store</code>不为空，则把sender的<code>envid</code>存到这里。如果系统调用失败了，<code>*fromenv</code>和<code>*perm</code>这两个都会被赋值为0。</p>
<p>如果不需要共享页面，则把作为参数的虚拟地址设为<code>UTOP</code>，这个地址在下面的系统调用实现中，会被忽略掉。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int32_t</span></span><br><span class="line">ipc_recv(<span class="keyword">envid_t</span> *from_env_store, <span class="keyword">void</span> *pg, <span class="keyword">int</span> *perm_store)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">    <span class="comment">// panic("ipc_recv not implemented");</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="keyword">if</span> (pg != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        r = sys_ipc_recv(pg);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        r = sys_ipc_recv((<span class="keyword">void</span> *) UTOP);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (r &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// failed</span></span><br><span class="line">        <span class="keyword">if</span> (from_env_store != <span class="literal">NULL</span>) *from_env_store = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (perm_store != <span class="literal">NULL</span>) *perm_store = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (from_env_store != <span class="literal">NULL</span>) </span><br><span class="line">            *from_env_store = thisenv-&gt;env_ipc_from;</span><br><span class="line">        <span class="keyword">if</span> (perm_store != <span class="literal">NULL</span>) </span><br><span class="line">            *perm_store = thisenv-&gt;env_ipc_perm;</span><br><span class="line">        <span class="keyword">return</span> thisenv-&gt;env_ipc_value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数就是会不停地尝试，在这个while里也要调用<code>sys_yield</code>防止一直占用CPU。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">ipc_send(<span class="keyword">envid_t</span> to_env, <span class="keyword">uint32_t</span> val, <span class="keyword">void</span> *pg, <span class="keyword">int</span> perm)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">    <span class="comment">// panic("ipc_send not implemented");</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="keyword">if</span> (pg == <span class="literal">NULL</span>) pg = (<span class="keyword">void</span> *)UTOP;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        r = sys_ipc_try_send(to_env, val, pg, perm);</span><br><span class="line">        <span class="keyword">if</span> (r &lt; <span class="number">0</span> &amp;&amp; r != -E_IPC_NOT_RECV) </span><br><span class="line">            panic(<span class="string">"ipc send failed: %e"</span>, r);</span><br><span class="line">        sys_yield();</span><br><span class="line">    &#125; <span class="keyword">while</span> (r != <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>sys_ipc_recv()</code>首先检查<code>dstva</code>是否合法，这里如果<code>dstva</code>等于<code>UTOP</code>的其实也是合法的，只是不需要去映射地址。然后获取到相应的<code>env</code>对象，设置其ipc数据域，并把当前的<code>env</code>设置成不能运行，直至接收完成。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 接收</span><br><span class="line">static int</span><br><span class="line">sys_ipc_recv(void *dstva)</span><br><span class="line">&#123;</span><br><span class="line">    // LAB 4: Your code here.</span><br><span class="line">    // panic(&quot;sys_ipc_recv not implemented&quot;);</span><br><span class="line">    </span><br><span class="line">    // wrong, because when we don&apos;t want to share page, we set dstva=UTOP</span><br><span class="line">    // but we can still pass value</span><br><span class="line">    // if ( (uintptr_t) dstva &gt;= UTOP) return -E_INVAL;</span><br><span class="line">    if ((uintptr_t) dstva &lt; UTOP &amp;&amp; PGOFF(dstva) != 0) return -E_INVAL;</span><br><span class="line"></span><br><span class="line">    envid_t envid = sys_getenvid();</span><br><span class="line">    struct Env *e;</span><br><span class="line">    // do not check permission</span><br><span class="line">    if (envid2env(envid, &amp;e, 0) &lt; 0) return -E_BAD_ENV;</span><br><span class="line">    </span><br><span class="line">    e-&gt;env_ipc_recving = true;</span><br><span class="line">    e-&gt;env_ipc_dstva = dstva;</span><br><span class="line">    e-&gt;env_status = ENV_NOT_RUNNABLE;</span><br><span class="line">    sys_yield();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>sys_ipc_try_send()</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Try to send 'value' to the target env 'envid'.</span></span><br><span class="line"><span class="comment">// If srcva &lt; UTOP, then also send page currently mapped at 'srcva',</span></span><br><span class="line"><span class="comment">// so that receiver gets a duplicate mapping of the same page.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The send fails with a return value of -E_IPC_NOT_RECV if the</span></span><br><span class="line"><span class="comment">// target is not blocked, waiting for an IPC.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The send also can fail for the other reasons listed below.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Otherwise, the send succeeds, and the target's ipc fields are</span></span><br><span class="line"><span class="comment">// updated as follows:</span></span><br><span class="line"><span class="comment">//    env_ipc_recving is set to 0 to block future sends;</span></span><br><span class="line"><span class="comment">//    env_ipc_from is set to the sending envid;</span></span><br><span class="line"><span class="comment">//    env_ipc_value is set to the 'value' parameter;</span></span><br><span class="line"><span class="comment">//    env_ipc_perm is set to 'perm' if a page was transferred, 0 otherwise.</span></span><br><span class="line"><span class="comment">// The target environment is marked runnable again, returning 0</span></span><br><span class="line"><span class="comment">// from the paused sys_ipc_recv system call.  (Hint: does the</span></span><br><span class="line"><span class="comment">// sys_ipc_recv function ever actually return?)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If the sender wants to send a page but the receiver isn't asking for one,</span></span><br><span class="line"><span class="comment">// then no page mapping is transferred, but no error occurs.</span></span><br><span class="line"><span class="comment">// The ipc only happens when no errors occur.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Returns 0 on success, &lt; 0 on error.</span></span><br><span class="line"><span class="comment">// Errors are:</span></span><br><span class="line"><span class="comment">//	-E_BAD_ENV if environment envid doesn't currently exist.</span></span><br><span class="line"><span class="comment">//		(No need to check permissions.)</span></span><br><span class="line"><span class="comment">//	-E_IPC_NOT_RECV if envid is not currently blocked in sys_ipc_recv,</span></span><br><span class="line"><span class="comment">//		or another environment managed to send first.</span></span><br><span class="line"><span class="comment">//	-E_INVAL if srcva &lt; UTOP but srcva is not page-aligned.</span></span><br><span class="line"><span class="comment">//	-E_INVAL if srcva &lt; UTOP and perm is inappropriate</span></span><br><span class="line"><span class="comment">//		(see sys_page_alloc).</span></span><br><span class="line"><span class="comment">//	-E_INVAL if srcva &lt; UTOP but srcva is not mapped in the caller's</span></span><br><span class="line"><span class="comment">//		address space.</span></span><br><span class="line"><span class="comment">//	-E_INVAL if (perm &amp; PTE_W), but srcva is read-only in the</span></span><br><span class="line"><span class="comment">//		current environment's address space.</span></span><br><span class="line"><span class="comment">//	-E_NO_MEM if there's not enough memory to map srcva in envid's</span></span><br><span class="line"><span class="comment">//		address space.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sys_ipc_try_send(<span class="keyword">envid_t</span> envid, <span class="keyword">uint32_t</span> value, <span class="keyword">void</span> *srcva, <span class="keyword">unsigned</span> perm)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> * <span class="title">tar_env</span>;</span></span><br><span class="line">	<span class="comment">// check target env</span></span><br><span class="line">	<span class="keyword">if</span>(envid2env(envid, &amp;tar_env, <span class="number">0</span>) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// check recver status</span></span><br><span class="line">	<span class="keyword">if</span>(!tar_env-&gt;env_ipc_recving)&#123;</span><br><span class="line">		<span class="keyword">return</span> -E_IPC_NOT_RECV;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// page send</span></span><br><span class="line">	<span class="keyword">if</span>((<span class="keyword">uintptr_t</span>)srcva &lt; UTOP)&#123;</span><br><span class="line">		<span class="comment">//page valid check</span></span><br><span class="line">		<span class="keyword">if</span>(PGOFF(srcva))&#123;</span><br><span class="line">			<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// perm valid check</span></span><br><span class="line">		<span class="keyword">if</span>(perm &amp; (~PTE_SYSCALL) || !(perm &amp; PTE_U) || !(perm &amp; PTE_P))&#123;</span><br><span class="line">			<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// page find</span></span><br><span class="line">		<span class="keyword">pte_t</span> * pte;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> * <span class="title">pginfo</span>;</span></span><br><span class="line">		pginfo = page_lookup(curenv-&gt;env_pgdir, srcva, &amp;pte);</span><br><span class="line">		<span class="keyword">if</span>(!pginfo)&#123;</span><br><span class="line">			<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// sender &amp; receiver PTE_W</span></span><br><span class="line">		<span class="keyword">if</span>((perm &amp; PTE_W) &amp;&amp; !((*pte) &amp; PTE_W))&#123;</span><br><span class="line">			<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// dst check</span></span><br><span class="line">		<span class="keyword">if</span>((<span class="keyword">uintptr_t</span>)(tar_env-&gt;env_ipc_dstva) &lt; UTOP)&#123;</span><br><span class="line">			<span class="comment">// insert page map</span></span><br><span class="line">			<span class="keyword">if</span>(page_insert(tar_env-&gt;env_pgdir, pginfo, tar_env-&gt;env_ipc_dstva, perm) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">				<span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// insert success</span></span><br><span class="line">			tar_env-&gt;env_ipc_perm = perm;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	tar_env-&gt;env_ipc_perm = <span class="number">0</span>;</span><br><span class="line">	tar_env-&gt;env_ipc_value = value;</span><br><span class="line">	<span class="comment">// tar status</span></span><br><span class="line">	tar_env-&gt;env_ipc_from = curenv-&gt;env_id;</span><br><span class="line">	tar_env-&gt;env_ipc_recving = <span class="number">0</span>;</span><br><span class="line">	tar_env-&gt;env_status = ENV_RUNNABLE;</span><br><span class="line">	tar_env-&gt;env_tf.tf_regs.reg_eax = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/操作系统/" rel="tag"># 操作系统</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/11/16/6.828-lab3/" rel="next" title="6.828 lab3">
                <i class="fa fa-chevron-left"></i> 6.828 lab3
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/11/16/6.828-lab5/" rel="prev" title="6.828 lab5">
                6.828 lab5 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/header.jpg" alt="Hao Yu">
            
              <p class="site-author-name" itemprop="name">Hao Yu</p>
              <p class="site-description motion-element" itemprop="description">Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author</p>
          </div>
          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">351</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>
        	<audio controls="controls" loop="loop" preload="auto" src="/resource/xiaomeihao.mp3">
	        </audio>
	

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yuhao0102" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:yuh18@mails.tsinghua.edu.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#简介"><span class="nav-number">1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Part-A-多处理器支持及协同多任务处理"><span class="nav-number">2.</span> <span class="nav-text">Part A: 多处理器支持及协同多任务处理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#多处理器支持"><span class="nav-number">2.1.</span> <span class="nav-text">多处理器支持</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#引导应用处理器"><span class="nav-number">2.2.</span> <span class="nav-text">引导应用处理器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CPU-状态和初始化"><span class="nav-number">2.3.</span> <span class="nav-text">CPU 状态和初始化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#各处理器中断初始化"><span class="nav-number">2.4.</span> <span class="nav-text">各处理器中断初始化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#锁"><span class="nav-number">2.5.</span> <span class="nav-text">锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#大内核锁的实现"><span class="nav-number">2.5.1.</span> <span class="nav-text">大内核锁的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么要在这几处加大内核锁"><span class="nav-number">2.5.2.</span> <span class="nav-text">为什么要在这几处加大内核锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么要用不同栈"><span class="nav-number">2.5.3.</span> <span class="nav-text">为什么要用不同栈</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#轮询调度"><span class="nav-number">2.6.</span> <span class="nav-text">轮询调度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#系统调用：创建进程"><span class="nav-number">2.7.</span> <span class="nav-text">系统调用：创建进程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Part-B-写时拷贝的-Fork"><span class="nav-number">3.</span> <span class="nav-text">Part B: 写时拷贝的 Fork</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#用户级别的页错误处理"><span class="nav-number">3.1.</span> <span class="nav-text">用户级别的页错误处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#进程的正常栈和异常栈"><span class="nav-number">3.1.1.</span> <span class="nav-text">进程的正常栈和异常栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#用户页错误处理函数"><span class="nav-number">3.1.2.</span> <span class="nav-text">用户页错误处理函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#用户模式页错误入口"><span class="nav-number">3.2.</span> <span class="nav-text">用户模式页错误入口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#实现-Copy-on-Write-Fork"><span class="nav-number">3.2.1.</span> <span class="nav-text">实现 Copy-on-Write Fork</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#UVPT"><span class="nav-number">3.2.2.</span> <span class="nav-text">UVPT</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#fork函数"><span class="nav-number">3.2.3.</span> <span class="nav-text">fork函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#duppage-函数"><span class="nav-number">3.2.4.</span> <span class="nav-text">duppage()函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pgfault-函数"><span class="nav-number">3.2.5.</span> <span class="nav-text">pgfault() 函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Part-C-抢占式多进程处理-amp-进程间通信"><span class="nav-number">4.</span> <span class="nav-text">Part C: 抢占式多进程处理 &amp; 进程间通信</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Part-I-时钟中断以及抢占"><span class="nav-number">4.1.</span> <span class="nav-text">Part I: 时钟中断以及抢占</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Interrupt-discipline"><span class="nav-number">4.1.1.</span> <span class="nav-text">Interrupt discipline</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Handling-Clock-Interrupts"><span class="nav-number">4.1.2.</span> <span class="nav-text">Handling Clock Interrupts</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Part-II-进程间通信-IPC"><span class="nav-number">4.2.</span> <span class="nav-text">Part II: 进程间通信(IPC)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#IPC-in-JOS"><span class="nav-number">4.2.1.</span> <span class="nav-text">IPC in JOS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#发送和接收消息"><span class="nav-number">4.2.2.</span> <span class="nav-text">发送和接收消息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#传递页面"><span class="nav-number">4.2.3.</span> <span class="nav-text">传递页面</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Implementing-IPC"><span class="nav-number">4.2.4.</span> <span class="nav-text">Implementing IPC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lib-部分"><span class="nav-number">4.2.5.</span> <span class="nav-text">lib 部分</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>
  <div id="DvelopmentTarget">     
  </div>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart" aria-hidden="false"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>

  
</div>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_uv"> 
  本站访客数<span id="busuanzi_value_site_uv"></span>人次
</span>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  


  <script type="text/javascript" src="/js/src/love.js"></script>

</body>
</html>
