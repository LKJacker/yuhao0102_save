<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zn-ch">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-center-simple.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="操作系统,">










<meta name="description" content="原文：https://www.dingmos.com/index.php/archives/4/ 实验分为三个部分： 熟悉汇编语言、QEMU x86模拟器、PC上电启动过程 检查我们的6.828内核的boot loader程序，它位于lab的boot目录下。 深入研究6.828内核本身的初始模板，位于kernel目录下。  MIT6.828 实验环境配置使用命令行创建了一个目录~/6.828，在该">
<meta name="keywords" content="操作系统">
<meta property="og:type" content="article">
<meta property="og:title" content="6.828 lab1">
<meta property="og:url" content="http://yoursite.com/2021/11/16/6.828-lab1/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="原文：https://www.dingmos.com/index.php/archives/4/ 实验分为三个部分： 熟悉汇编语言、QEMU x86模拟器、PC上电启动过程 检查我们的6.828内核的boot loader程序，它位于lab的boot目录下。 深入研究6.828内核本身的初始模板，位于kernel目录下。  MIT6.828 实验环境配置使用命令行创建了一个目录~/6.828，在该">
<meta property="og:locale" content="zn-ch">
<meta property="og:updated_time" content="2021-12-01T08:26:35.446Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="6.828 lab1">
<meta name="twitter:description" content="原文：https://www.dingmos.com/index.php/archives/4/ 实验分为三个部分： 熟悉汇编语言、QEMU x86模拟器、PC上电启动过程 检查我们的6.828内核的boot loader程序，它位于lab的boot目录下。 深入研究6.828内核本身的初始模板，位于kernel目录下。  MIT6.828 实验环境配置使用命令行创建了一个目录~/6.828，在该">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2021/11/16/6.828-lab1/">





  <title>6.828 lab1 | Hao Yu's blog</title>
  








 
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zn-ch">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hao Yu's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">The program monkey was eaten by the siege lion.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/resume.pdf" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-mybetterhalf">
          <a href="/mybetterhalf/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>
            
            mybetterhalf
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/11/16/6.828-lab1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">6.828 lab1</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-11-16T14:08:00+08:00">
                2021-11-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>原文：<a href="https://www.dingmos.com/index.php/archives/4/" target="_blank" rel="noopener">https://www.dingmos.com/index.php/archives/4/</a></p>
<h1 id="实验分为三个部分："><a href="#实验分为三个部分：" class="headerlink" title="实验分为三个部分："></a>实验分为三个部分：</h1><ul>
<li>熟悉汇编语言、QEMU x86模拟器、PC上电启动过程</li>
<li>检查我们的6.828内核的boot loader程序，它位于lab的boot目录下。</li>
<li>深入研究6.828内核本身的初始模板，位于kernel目录下。</li>
</ul>
<h1 id="MIT6-828-实验环境配置"><a href="#MIT6-828-实验环境配置" class="headerlink" title="MIT6.828 实验环境配置"></a>MIT6.828 实验环境配置</h1><p>使用命令行创建了一个目录<code>~/6.828</code>，在该目录下初始化一个git仓库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/6.828$ git init</span><br></pre></td></tr></table></figure></p>
<p>把JOS系统源码clone到本地<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/6.828$ git clone https://pdos.csail.mit.edu/6.828/2017/jos.git lab</span><br></pre></td></tr></table></figure></p>
<p>安装QEMU这个仿真器需要先安装包。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libsdl1.2-dev</span><br><span class="line">sudo apt-get install libglib2.0-dev</span><br><span class="line">sudo apt-get install libz-dev</span><br><span class="line">sudo apt-get install libpixman-1-dev</span><br><span class="line">sudo apt-get install libtool*</span><br></pre></td></tr></table></figure></p>
<p>打开qemu所在目录，进行configuration<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./configure --disable-kvm --disable-werror --prefix=$HMOE --target-list=&quot;i386-softmmu x86_64-softmmu&quot;</span><br></pre></td></tr></table></figure></p>
<p>最后进行安装。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo make &amp;&amp; make install</span><br></pre></td></tr></table></figure></p>
<p>安装包时频繁出现依赖问题，把apt-get换成了aptitude无用；最后是换了源解决的，可能是因为在安装中断后更换了源，换回去就好了。</p>
<p>之后又报了Werror。在配置的时候处理werror解决。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./configure --disable-werror --prefix==/usr/local --target-list=&quot;i386-softmmu x86_64-softmmu&quot;</span><br></pre></td></tr></table></figure></p>
<p>QUMU安装好之后，make lab下的代码报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lib/printfmt.c:41: undefined reference to `__udivdi3&apos;</span><br><span class="line">lib/printfmt.c:49: undefined reference to `__umoddi3&apos;</span><br></pre></td></tr></table></figure></p>
<p>ARM是精简指令集，对求余和除法操作基本上不支持。linux内核源码<code>linux/arch/arm/lib/lib1funcs.S</code>实现支持除法、求模操作等操作的库函数。本来应该多研究下，但是发现有现成的解决方案，我开发环境是64gcc，但需要的是32位，所以安装32位gcc解决问题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install gcc-multilib</span><br></pre></td></tr></table></figure></p>
<p>再次进行make，成功！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">~/6.828/lab$ sudo make</span><br><span class="line">+ ld obj/kern/kernel</span><br><span class="line">+ as boot/boot.S</span><br><span class="line">+ cc -Os boot/main.c</span><br><span class="line">+ ld boot/boot</span><br><span class="line">boot block is 390 bytes (max 510)</span><br><span class="line">+ mk obj/kern/kernel.img</span><br></pre></td></tr></table></figure></p>
<p>之后需要<code>make qemu</code>，又报错了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/bin/sh: 1: /home/yuhao/qemu/: Permission denied</span><br><span class="line">/home/yuhao/qemu/ -drive file=obj/kern/kernel.img,index=0,media=disk,format=raw -serial mon:stdio -gdb tcp::26000</span><br><span class="line">make: execvp: /home/yuhao/qemu/: Permission denied</span><br><span class="line">GNUmakefile:156: recipe for target &apos;qemu&apos; failed</span><br><span class="line">make: *** [qemu] Error 127</span><br></pre></td></tr></table></figure></p>
<p>应该是qemu的可执行文件配置错误，改一下<code>env.mk</code>。在执行启动简单映像的命令后，又有错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GLib-WARNING **：21：58：30.131：gmem.c：489：不支持自定义内存分配vtable</span><br><span class="line">(qemu-system-x86_64：23983)：Gtk-WARNING **：21：58：30.175：无法打开显示：</span><br></pre></td></tr></table></figure></p>
<p>出现此问题是因为glib2错误（<a href="https://bugzilla.redhat.com/show_bug.cgi?id=1594304）。" target="_blank" rel="noopener">https://bugzilla.redhat.com/show_bug.cgi?id=1594304）。</a></p>
<p>此问题的另一方面是Red Hat和CentOS存储库包含过时的QEMU版本（最近是4）。</p>
<ol>
<li>用qemu-kvm而不是qemu-system-x86_64：<a href="https://www.tecmint.com/install-manage-virtual-machines-in-centos/" target="_blank" rel="noopener">https://www.tecmint.com/install-manage-virtual-machines-in-centos/</a></li>
<li>从fedora仓库重新安装/更新所有QEMU软件包（<a href="https://copr-be.cloud.fedoraproject.org/results/fcomida/qemu-4/fedora-30-x86_64/00910942-qemu/）`rpm" target="_blank" rel="noopener">https://copr-be.cloud.fedoraproject.org/results/fcomida/qemu-4/fedora-30-x86_64/00910942-qemu/）`rpm</a> -i /path/to/file/file_name.rpm`</li>
<li>自己编译QEMU（<a href="https://www.qemu.org/download/#source）。" target="_blank" rel="noopener">https://www.qemu.org/download/#source）。</a></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">wget https://download.qemu.org/qemu-4.1.0-rc2.tar.xz</span><br><span class="line">tar xvJf qemu-4.1.0-rc2.tar.xz</span><br><span class="line">cd qemu-4.1.0-rc2</span><br><span class="line">sudo ./configure --disable-kvm --disable-werror --prefix=$HMOE --target-list=&quot;i386-softmmu x86_64-softmmu&quot;</span><br><span class="line"></span><br><span class="line">make</span><br><span class="line">OR</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<p>运行成功的话终端就会打印出以下字符：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/home/yuhao/6.828/qemu/i386-softmmu/qemu-system-i386 -drive file=obj/kern/kernel.img,index=0,media=disk,format=raw -serial mon:stdio -gdb tcp::26000 -D qemu.log</span><br><span class="line">VNC server running on 127.0.0.1:5900</span><br><span class="line">6828 decimal is XXX octal!</span><br><span class="line">entering test_backtrace 5</span><br><span class="line">entering test_backtrace 4</span><br><span class="line">entering test_backtrace 3</span><br><span class="line">entering test_backtrace 2</span><br><span class="line">entering test_backtrace 1</span><br><span class="line">entering test_backtrace 0</span><br><span class="line">leaving test_backtrace 0</span><br><span class="line">leaving test_backtrace 1</span><br><span class="line">leaving test_backtrace 2</span><br><span class="line">leaving test_backtrace 3</span><br><span class="line">leaving test_backtrace 4</span><br><span class="line">leaving test_backtrace 5</span><br><span class="line">Welcome to the JOS kernel monitor!</span><br><span class="line">Type &apos;help&apos; for a list of commands.</span><br></pre></td></tr></table></figure></p>
<p>键入kerninfo，值得注意的是，此内核监视器“直接”在模拟PC的“原始（虚拟）硬件”上运行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">K&gt; kerninfo</span><br><span class="line">Special kernel symbols:</span><br><span class="line">  _start                  0010000c (phys)</span><br><span class="line">  entry  f010000c (virt)  0010000c (phys)</span><br><span class="line">  etext  f0101acd (virt)  00101acd (phys)</span><br><span class="line">  edata  f0113060 (virt)  00113060 (phys)</span><br><span class="line">  end    f01136a0 (virt)  001136a0 (phys)</span><br><span class="line">Kernel executable memory footprint: 78KB</span><br></pre></td></tr></table></figure></p>
<p>细节记录</p>
<ul>
<li>PC中BIOS大小为64k, 物理地址范围0x000f0000-0x000fffff</li>
<li>PC 开机首先0xfffff0处执行 jmp [0xf000,0xe05b] 指令。在gdb中使用si(Step Instruction)进行跟踪。</li>
</ul>
<p>使用gdb进行调试<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">$ make gdb</span><br><span class="line">GNU gdb (GDB) 6.8-debian</span><br><span class="line">Copyright (C) 2008 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.  Type &quot;show copying&quot;</span><br><span class="line">and &quot;show warranty&quot; for details.</span><br><span class="line">This GDB was configured as &quot;i486-linux-gnu&quot;.</span><br><span class="line">+ target remote localhost:26000</span><br><span class="line">The target architecture is assumed to be i8086</span><br><span class="line">[f000:fff0] 0xffff0:	ljmp   $0xf000,$0xe05b</span><br><span class="line">0x0000fff0 in ?? ()</span><br><span class="line">+ symbol-file obj/kern/kernel</span><br><span class="line"></span><br><span class="line">(gdb) si</span><br><span class="line">[f000:e05b]    0xfe05b:    cmpw   $0xffc8,%cs:(%esi)   # 比较大小，改变PSW</span><br><span class="line">0x0000e05b in ?? ()</span><br><span class="line">(gdb) si</span><br><span class="line">[f000:e062]    0xfe062:    jne    0xd241d416           # 不相等则跳转</span><br><span class="line">0x0000e062 in ?? ()</span><br><span class="line">(gdb) si</span><br><span class="line">[f000:e066]    0xfe066:    xor    %edx,%edx            # 清零edx</span><br><span class="line">0x0000e066 in ?? ()</span><br><span class="line">(gdb) si</span><br><span class="line">[f000:e068]    0xfe068:    mov    %edx,%ss</span><br><span class="line">0x0000e068 in ?? ()</span><br><span class="line">(gdb) si</span><br><span class="line">[f000:e06a]    0xfe06a:    mov    $0x7000,%sp</span><br><span class="line">0x0000e06a in ?? ()</span><br></pre></td></tr></table></figure></p>
<p>BIOS运行过程中，它设定了中断描述符表，对VGA显示器等设备进行了初始化。在初始化完PCI总线和所有BIOS负责的重要设备后，它就开始搜索软盘、硬盘、或是CD-ROM等可启动的设备。最终，当它找到可引导磁盘时，BIOS从磁盘读取引导加载程序并将控制权转移给它。</p>
<h1 id="Part-2-The-Boot-Loader"><a href="#Part-2-The-Boot-Loader" class="headerlink" title="Part 2: The Boot Loader"></a>Part 2: The Boot Loader</h1><p>机器的物理地址空间有如下布局：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">+------------------+  &lt;- 0xFFFFFFFF (4GB)</span><br><span class="line">|      32-bit      |</span><br><span class="line">|  memory mapped   |</span><br><span class="line">|     devices      |</span><br><span class="line">|                  |</span><br><span class="line">/\/\/\/\/\/\/\/\/\/\</span><br><span class="line"></span><br><span class="line">/\/\/\/\/\/\/\/\/\/\</span><br><span class="line">|                  |</span><br><span class="line">|      Unused      |</span><br><span class="line">|                  |</span><br><span class="line">+------------------+  &lt;- depends on amount of RAM</span><br><span class="line">|                  |</span><br><span class="line">|                  |</span><br><span class="line">| Extended Memory  |</span><br><span class="line">|                  |</span><br><span class="line">|                  |</span><br><span class="line">+------------------+  &lt;- 0x00100000 (1MB)</span><br><span class="line">|     BIOS ROM     |</span><br><span class="line">+------------------+  &lt;- 0x000F0000 (960KB)</span><br><span class="line">|  16-bit devices, |</span><br><span class="line">|  expansion ROMs  |</span><br><span class="line">+------------------+  &lt;- 0x000C0000 (768KB)</span><br><span class="line">|   VGA Display    |</span><br><span class="line">+------------------+  &lt;- 0x000A0000 (640KB)</span><br><span class="line">|                  |</span><br><span class="line">|    Low Memory    |</span><br><span class="line">|                  |</span><br><span class="line">+------------------+  &lt;- 0x00000000</span><br></pre></td></tr></table></figure></p>
<p>对于6.828，我们将使用传统的硬盘启动机制，这意味着我们的boot loader必须满足于512字节。</p>
<p>boot loader由一个汇编语言源文件<code>boot/boot.S</code>和一个C源文件<code>boot/main.c</code>组成。</p>
<h2 id="boot-S"><a href="#boot-S" class="headerlink" title="boot.S"></a>boot.S</h2><p>BIOS将<code>boot.S</code>这段代码从硬盘的第一个扇区load到物理地址为0x7c00的位置，同时CPU工作在real mode。</p>
<p><code>boot.S</code>需要将CPU的工作模式从实模式转换到32位的保护模式， 并且 jump 到 C 语言程序。</p>
<p>源码阅读，知识点：</p>
<ul>
<li>cli (clear interrupt)</li>
<li>cld (clear direction flag)</li>
</ul>
<blockquote>
<p>df: 方向标志位。在串处理指令中，控制每次操作后si，di的增减。（df=0，每次操作后si、di递增；df=1，每次操作后si、di递减）。</p>
</blockquote>
<p>为了向前兼容早期的PC机，A20地址线接地，所以当地址大于1M范围时，会默认回滚到0处。所以在转向32位模式之前，需要使能A20。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">seta20.1:</span><br><span class="line">  inb     $0x64,%al               # Wait for not busy</span><br><span class="line">  testb   $0x2,%al</span><br><span class="line">  jnz     seta20.1</span><br><span class="line"></span><br><span class="line">  movb    $0xd1,%al               # 0xd1 -&gt; port 0x64</span><br><span class="line">  outb    %al,$0x64</span><br><span class="line"></span><br><span class="line">seta20.2:</span><br><span class="line">  inb     $0x64,%al               # Wait for not busy</span><br><span class="line">  testb   $0x2,%al</span><br><span class="line">  jnz     seta20.2</span><br><span class="line"></span><br><span class="line">  movb    $0xdf,%al               # 0xdf -&gt; port 0x60</span><br><span class="line">  outb    %al,$0x60</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>test 逻辑运算指令，对两个操作数进行AND操作，并且修改PSW, test 与 AND 指令唯一不同的地方是，TEST 指令不修改目标操作数。</p>
<ul>
<li><code>test al, 00001001b ;</code>测试位 0 和位 3</li>
</ul>
</li>
<li><p><code>lgdt gdtdesc</code>, 加载全局描述符表，暂时不管全局描述表是如何生成的。</p>
</li>
<li><code>cr0</code>, control register,控制寄存器。<ul>
<li>CR0中包含了6个预定义标志，0位是保护允许位PE(Protedted Enable)，用于启动保护模式，如果PE位置1，则保护模式启动，如果PE=0，则在实模式下运行。</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Switch from real to protected mode, using a bootstrap GDT</span><br><span class="line"># and segment translation that makes virtual addresses</span><br><span class="line"># identical to their physical addresses, so that the</span><br><span class="line"># effective memory map does not change during the switch.</span><br><span class="line">lgdt    gdtdesc</span><br><span class="line">movl    %cr0, %eax</span><br><span class="line">orl     $CR0_PE_ON, %eax</span><br><span class="line">movl    %eax, %cr0</span><br></pre></td></tr></table></figure>
<h2 id="调试boot-S"><a href="#调试boot-S" class="headerlink" title="调试boot.S"></a>调试boot.S</h2><p>设置一个断点在地址0x7c00处，这是boot sector被加载的位置。然后让程序继续运行直到这个断点。跟踪/boot/boot.S文件的每一条指令，同时使用boot.S文件和系统为你反汇编出来的文件obj/boot/boot.asm。你也可以使用GDB的x/i指令来获取去任意一个机器指令的反汇编指令，把源文件boot.S文件和boot.asm文件以及在GDB反汇编出来的指令进行比较。</p>
<p>追踪到bootmain函数中，而且还要具体追踪到<code>readsect()</code>子函数里面。找出和<code>readsect()</code>c语言程序的每一条语句所对应的汇编指令，回到<code>bootmain()</code>，然后找出把内核文件从磁盘读取到内存的那个for循环所对应的汇编语句。找出当循环结束后会执行哪条语句，在那里设置断点，继续运行到断点，然后运行完所有的剩下的语句。</p>
<p>下面我们将分别分析一下这道练习中所涉及到的两个重要文件，它们一起组成了boot loader。分别是<code>/boot/boot.S</code>和<code>/boot/main.c</code>文件。其中前者是一个汇编文件，后者是一个C语言文件。当BIOS运行完成之后，CPU的控制权就会转移到<code>boot.S</code>文件上。所以我们首先看一下<code>boot.S</code>文件。</p>
<p>　　/boot/boot.S：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.globl start</span><br><span class="line">start:</span><br><span class="line">  .code16                # Assemble for 16-bit mode</span><br><span class="line">  cli                    # Disable interrupts</span><br></pre></td></tr></table></figure></p>
<p>这几条指令就是boot.S最开始的几句，其中cli是boot.S，也是boot loader的第一条指令。这条指令用于把所有的中断都关闭。因为在BIOS运行期间有可能打开了中断。此时CPU工作在实模式下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cld                         # String operations increment</span><br></pre></td></tr></table></figure></p>
<p>这条指令用于指定之后发生的串处理操作的指针移动方向。在这里现在对它大致了解就够了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Set up the important data segment registers (DS, ES, SS).</span><br><span class="line">xorw    %ax,%ax             # Segment number zero</span><br><span class="line">movw    %ax,%ds             # -&gt; Data Segment</span><br><span class="line">movw    %ax,%es             # -&gt; Extra Segment</span><br><span class="line">movw    %ax,%ss             # -&gt; Stack Segment</span><br></pre></td></tr></table></figure>
<p>这几条命令主要是在把三个段寄存器，ds，es，ss全部清零，因为经历了BIOS，操作系统不能保证这三个寄存器中存放的是什么数。所以这也是为后面进入保护模式做准备。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> # Enable A20:</span><br><span class="line"> #   For backwards compatibility with the earliest PCs, physical</span><br><span class="line"> #   address line 20 is tied low, so that addresses higher than</span><br><span class="line"> #   1MB wrap around to zero by default.  This code undoes this.</span><br><span class="line">seta20.1:</span><br><span class="line"> inb     $0x64,%al               # Wait for not busy</span><br><span class="line"> testb   $0x2,%al</span><br><span class="line"> jnz     seta20.1</span><br><span class="line"></span><br><span class="line"> movb    $0xd1,%al               # 0xd1 -&gt; port 0x64</span><br><span class="line"> outb    %al,$0x64</span><br><span class="line"></span><br><span class="line">seta20.2:</span><br><span class="line"> inb     $0x64,%al               # Wait for not busy</span><br><span class="line"> testb   $0x2,%al</span><br><span class="line"> jnz     seta20.2</span><br><span class="line"></span><br><span class="line"> movb    $0xdf,%al               # 0xdf -&gt; port 0x60</span><br><span class="line"> outb    %al,$0x60</span><br></pre></td></tr></table></figure>
<p>这部分指令就是在准备把CPU的工作模式从实模式转换为保护模式。我们可以看到其中的指令包括inb，outb这样的IO端口命令。所以这些指令都是在对外部设备进行操作。0x64端口属于键盘控制器804x，名称是控制器读取状态寄存器。</p>
<p>不断的检测bit1。bit1的值代表输入缓冲区是否满了，也就是说CPU传送给控制器的数据，控制器是否已经取走了，如果CPU想向控制器传送新的数据的话，必须先保证这一位为0。所以这三条指令会一直等待这一位变为0，才能继续向后运行。</p>
<p>当0x64端口准备好读入数据后，现在就可以写入数据了，所以19~20这两条指令是把0xd1这条数据写入到0x64端口中。当向0x64端口写入数据时，则代表向键盘控制器804x发送指令。这个指令将会被送给0x60端口。</p>
<p>D1指令代表下一次写入0x60端口的数据将被写入给804x控制器的输出端口。可以理解为下一个写入0x60端口的数据是一个控制指令。</p>
<p>然后21~24号指令又开始再次等待，等待刚刚写入的指令D1，是否已经被读取了。</p>
<p>如果指令被读取了，25~26号指令会向控制器输入新的指令，0xdf。这个指令的含义是，使能A20线，代表可以进入保护模式了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">27   # Switch from real to protected mode, using a bootstrap GDT</span><br><span class="line">28   # and segment translation that makes virtual addresses </span><br><span class="line">29   # identical to their physical addresses, so that the </span><br><span class="line">30   # effective memory map does not change during the switch.</span><br><span class="line">31   lgdt    gdtdesc</span><br><span class="line">32   movl    %cr0, %eax</span><br><span class="line">33   orl     $CR0_PE_ON, %eax</span><br><span class="line">34   movl    %eax, %cr0</span><br></pre></td></tr></table></figure>
<p>首先31号指令<code>lgdt gdtdesc</code>，是把gdtdesc这个标识符的值送入全局映射描述符表寄存器GDTR中。这个GDT表是处理器工作于保护模式下一个非常重要的表。这条指令的功能就是把关于GDT表的一些重要信息存放到CPU的GDTR寄存器中，其中包括GDT表的内存起始地址，以及GDT表的长度。这个寄存器由48位组成，其中低16位表示该表长度，高32位表该表在内存中的起始地址。所以gdtdesc是一个标识符，标识着一个内存地址。从这个内存地址开始之后的6个字节中存放着GDT表的长度和起始地址。我们可以在这个文件的末尾看到gdtdesc，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> 1 # Bootstrap GDT</span><br><span class="line"> 2 .p2align 2                               # force 4 byte alignment</span><br><span class="line"> 3 gdt:</span><br><span class="line"> 4   SEG_NULL                               # null seg</span><br><span class="line"> 5   SEG(STA_X|STA_R, 0x0, 0xffffffff)      # code seg</span><br><span class="line"> 6   SEG(STA_W, 0x0, 0xffffffff)            # data seg</span><br><span class="line"> 7 </span><br><span class="line"> 8 gdtdesc:</span><br><span class="line"> 9   .word   0x17                           # sizeof(gdt) - 1</span><br><span class="line">10   .long   gdt                            # address gdt</span><br></pre></td></tr></table></figure>
<p>其中第3行的gdt是一个标识符，标识从这里开始就是GDT表了。可见这个GDT表中包括三个表项(4,5,6行)，分别代表三个段，null seg，code seg，data seg。由于xv6其实并没有使用分段机制，也就是说数据和代码都是写在一起的，所以数据段和代码段的起始地址都是0x0，大小都是0xffffffff=4GB。</p>
<p>在第4~6行是调用SEG()子程序来构造GDT表项的。这个子函数定义在mmu.h中，形式如下：　　<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">　<span class="meta">#<span class="meta-keyword">define</span> SEG(type,base,lim)                    \</span></span><br><span class="line">.word (((lim) &gt;&gt; <span class="number">12</span>) &amp; <span class="number">0xffff</span>), ((base) &amp; <span class="number">0xffff</span>);    \</span><br><span class="line">.byte (((base) &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>), (<span class="number">0x90</span> | (type)),        \</span><br><span class="line">(<span class="number">0xC0</span> | (((lim) &gt;&gt; <span class="number">28</span>) &amp; <span class="number">0xf</span>)), (((base) &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xff</span>)</span><br></pre></td></tr></table></figure></p>
<p>可见函数需要3个参数，一是type即这个段的访问权限，二是base，这个段的起始地址，三是lim，即这个段的大小界限。gdt表中的每一个表项的结构：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gdt_entry_struct</span> &#123;</span></span><br><span class="line">    limit_low:    resb <span class="number">2</span></span><br><span class="line">    base_low:     resb <span class="number">2</span></span><br><span class="line">    base_middle : resb <span class="number">1</span></span><br><span class="line">    access:       resb <span class="number">1</span></span><br><span class="line">    granularity:  resb <span class="number">1</span></span><br><span class="line">    base_high:    resb <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>每个表项一共8字节，其中<code>limit_low</code>就是limit的低16位。<code>base_low</code>就是base的低16位，依次类推。</p>
<p>然后在<code>gdtdesc</code>处就要存放这个GDT表的信息了，其中0x17是这个表的大小-1 = 0x17 = 23，至于为什么不直接存表的大小24，根据查询是官方规定的。紧接着就是这个表的起始地址gdt。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">27   # Switch from real to protected mode, using a bootstrap GDT</span><br><span class="line">28   # and segment translation that makes virtual addresses </span><br><span class="line">29   # identical to their physical addresses, so that the </span><br><span class="line">30   # effective memory map does not change during the switch.</span><br><span class="line">31   lgdt    gdtdesc</span><br><span class="line">32   movl    %cr0, %eax</span><br><span class="line">33   orl     $CR0_PE_ON, %eax</span><br><span class="line">34   movl    %eax, %cr0</span><br></pre></td></tr></table></figure>
<p>再回到刚才那里，当加载完GDT表的信息到GDTR寄存器之后。紧跟着3个操作，32~34指令。 这几步操作明显是在修改CR0寄存器的内容。CR0寄存器还有CR1~CR3寄存器都是80x86的控制寄存器。其中$CR0_PE的值定义于”mmu.h”文件中，为0x00000001。可见上面的操作是把CR0寄存器的bit0置1，CR0寄存器的bit0是保护模式启动位，把这一位值1代表保护模式启动。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">35  ljmp    $PROT_MODE_CSEG, $protcseg</span><br></pre></td></tr></table></figure>
<p>这只是一个简单的跳转指令，这条指令的目的在于把当前的运行模式切换成32位地址模式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">protcseg:</span><br><span class="line">  # Set up the protected-mode data segment registers</span><br><span class="line">36  movw    $PROT_MODE_DSEG, %ax    # Our data segment selector</span><br><span class="line">37  movw    %ax, %ds                # -&gt; DS: Data Segment</span><br><span class="line">38  movw    %ax, %es                # -&gt; ES: Extra Segment</span><br><span class="line">39  movw    %ax, %fs                # -&gt; FS</span><br><span class="line">40  movw    %ax, %gs                # -&gt; GS</span><br><span class="line">41  movw    %ax, %ss                # -&gt; SS: Stack Segment</span><br></pre></td></tr></table></figure>
<p>修改这些寄存器的值。这些寄存器都是段寄存器，如果刚刚加载完GDTR寄存器我们必须要重新加载所有的段寄存器的值，而其中CS段寄存器必须通过长跳转指令，即23号指令来进行加载。这样才能是GDTR的值生效。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Set up the stack pointer and call into C.</span><br><span class="line">42  movl    $start, %esp</span><br><span class="line">43  call bootmain</span><br></pre></td></tr></table></figure>
<p>接下来的指令就是要设置当前的esp寄存器的值，然后准备正式跳转到main.c文件中的bootmain函数处。我们接下来分析一下这个函数的每一条指令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// read 1st page off disk</span><br><span class="line">1 readseg((uint32_t) ELFHDR, SECTSIZE*8, 0);</span><br></pre></td></tr></table></figure>
<p>这里面调用了一个函数<code>readseg</code>，这个函数在<code>bootmain</code>之后被定义了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void readseg(uchar *pa, uint count, uint offset);</span><br></pre></td></tr></table></figure></p>
<p>它的功能从注释上来理解应该是，把距离内核起始地址offset个偏移量存储单元作为起始，将它和它之后的count字节的数据读出送入以pa为起始地址的内存物理地址处。</p>
<p>所以这条指令是把内核的第一个页(4MB = 4096 = SECTSIZE<em>8 = 512</em>8)的内容读取的内存地址ELFHDR(0x10000)处。其实完成这些后相当于把操作系统映像文件的elf头部读取出来放入内存中。</p>
<p>读取完这个内核的elf头部信息后，需要对这个elf头部信息进行验证，并且也需要通过它获取一些重要信息。</p>
<blockquote>
<p>elf文件：elf是一种文件格式，主要被用来把程序存放到磁盘上。是在程序被编译和链接后被创建出来的。一个elf文件包括多个段。对于一个可执行程序，通常包含存放代码的文本段(text section)，存放全局变量的data段，存放字符串常量的rodata段。elf文件的头部就是用来描述这个elf文件如何在存储器中存储。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> <span class="keyword">if</span> (ELFHDR-&gt;e_magic != ELF_MAGIC)</span><br><span class="line"><span class="number">3</span>        <span class="keyword">goto</span> bad;</span><br></pre></td></tr></table></figure>
<p>elf头部信息的magic字段是整个头部信息的开端。并且如果这个文件是格式是ELF格式的话，文件的elf-&gt;magic域应该是=ELF_MAGIC的，所以这条语句就是判断这个输入文件是否是合法的elf可执行文件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span> ph = (struct Proghdr *) ((<span class="keyword">uint8_t</span> *) ELFHDR + ELFHDR-&gt;e_phoff);</span><br></pre></td></tr></table></figure>
<p>我们知道头部中一定包含Program Header Table。这个表格存放着程序中所有段的信息。通过这个表我们才能找到要执行的代码段，数据段等等。所以我们要先获得这个表。</p>
<p>这条指令就可以完成这一点，首先elf是表头起址，而phoff字段代表Program Header Table距离表头的偏移量。所以ph可以被指定为Program Header Table表头。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span> eph = ph + ELFHDR-&gt;e_phnum;</span><br></pre></td></tr></table></figure>
<p>由于phnum中存放的是Program Header Table表中表项的个数，即段的个数。所以这步操作是吧eph指向该表末尾。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span> <span class="keyword">for</span> (; ph &lt; eph; ph++)</span><br><span class="line">    <span class="comment">// p_pa is the load address of this segment (as well</span></span><br><span class="line">    <span class="comment">// as the physical address)</span></span><br><span class="line"><span class="number">7</span>    readseg(ph-&gt;p_pa, ph-&gt;p_memsz, ph-&gt;p_offset);</span><br></pre></td></tr></table></figure>
<p>这个for循环就是在加载所有的段到内存中。ph-&gt;paddr根据参考文献中的说法指的是这个段在内存中的物理地址。ph-&gt;off字段指的是这一段的开头相对于这个elf文件的开头的偏移量。ph-&gt;filesz字段指的是这个段在elf文件中的大小。ph-&gt;memsz则指的是这个段被实际装入内存后的大小。通常来说memsz一定大于等于filesz，因为段在文件中时许多未定义的变量并没有分配空间给它们。</p>
<p>所以这个循环就是在把操作系统内核的各个段从外存读入内存中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8 ((void (*)(void)) (ELFHDR-&gt;e_entry))();</span><br></pre></td></tr></table></figure>
<p>e_entry字段指向的是这个文件的执行入口地址。所以这里相当于开始运行这个文件。也就是内核文件。 自此就把控制权从boot loader转交给了操作系统的内核。</p>
<p>分析完了程序后，来完成Exercise要求我们做的事情：</p>
<p>在一个terminal中cd到lab目录下，执行<code>make qemu-gdb</code>。再开一个 terminal执行<code>make gdb</code>。</p>
<p>因为BIOS会把boot loader加载到0x7c00的位置，因此设置断点b *0x7c00。再执行c，会看到QUMU终端上显示Booting from hard disk。</p>
<p>执行x/30i 0x7c00就能看到与boot.S中类似的汇编代码了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b *0x7c00</span><br><span class="line">Breakpoint 1 at 0x7c00</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">[   0:7c00] =&gt; 0x7c00:  cli</span><br><span class="line"></span><br><span class="line">Breakpoint 1, 0x00007c00 in ?? ()</span><br><span class="line">(gdb) x/30i 0x7c00</span><br><span class="line">=&gt; 0x7c00:      cli</span><br><span class="line">   0x7c01:      cld</span><br><span class="line">   0x7c02:      xor    %eax,%eax</span><br><span class="line">   0x7c04:      mov    %eax,%ds</span><br><span class="line">   0x7c06:      mov    %eax,%es</span><br><span class="line">   0x7c08:      mov    %eax,%ss</span><br><span class="line">   0x7c0a:      in     $0x64,%al</span><br><span class="line">   0x7c0c:      test   $0x2,%al</span><br><span class="line">   0x7c0e:      jne    0x7c0a</span><br><span class="line">   0x7c10:      mov    $0xd1,%al</span><br><span class="line">   0x7c12:      out    %al,$0x64</span><br><span class="line">   0x7c14:      in     $0x64,%al</span><br><span class="line">   0x7c16:      test   $0x2,%al</span><br><span class="line">   0x7c18:      jne    0x7c14</span><br><span class="line">   0x7c1a:      mov    $0xdf,%al</span><br><span class="line">   0x7c1c:      out    %al,$0x60</span><br><span class="line">   0x7c1e:      lgdtl  (%esi)</span><br><span class="line">   0x7c21:      fs jl  0x7c33</span><br><span class="line">   0x7c24:      and    %al,%al</span><br><span class="line">   0x7c26:      or     $0x1,%ax</span><br><span class="line">   0x7c2a:      mov    %eax,%cr0</span><br><span class="line">   0x7c2d:      ljmp   $0xb866,$0x87c32</span><br><span class="line">   0x7c34:      adc    %al,(%eax)</span><br></pre></td></tr></table></figure></p>
<p>这条gdb指令是把存放在0x7c00以及之后30字节的内存里面的指令反汇编出来，我们可以拿它直接和<code>boot.S</code>以及在<code>obj/boot/boot.asm</code>进行比较，这三者在指令上没有区别，只不过在源代码中，我们指定了很多标识符比如set20.1，.start，这些标识符在被汇编成机器代码后都会被转换成真实物理地址。比如set20.1就被转换为0x7c0a，那么在<code>obj/boot/boot.asm</code>中还把这种对应关系列出来了，但是在真实执行时，即第一种情况中，就看不到set20.1标识符了，完全是真实物理地址。</p>
<h1 id="加载内核"><a href="#加载内核" class="headerlink" title="加载内核"></a>加载内核</h1><p>接下来我们分析boot loader的C语言部分。</p>
<p>首先熟悉以下C指针。 编译运行pointer.c结果。 可以发现 a[],b的地址相差很多，因为两者所存放的段不同。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>: a = <span class="number">0xbfa8bdbc</span>, b = <span class="number">0x9e3a160</span>, c = (nil)</span><br><span class="line"><span class="number">2</span>: a[<span class="number">0</span>] = <span class="number">200</span>, a[<span class="number">1</span>] = <span class="number">101</span>, a[<span class="number">2</span>] = <span class="number">102</span>, a[<span class="number">3</span>] = <span class="number">103</span></span><br><span class="line"><span class="number">3</span>: a[<span class="number">0</span>] = <span class="number">200</span>, a[<span class="number">1</span>] = <span class="number">300</span>, a[<span class="number">2</span>] = <span class="number">301</span>, a[<span class="number">3</span>] = <span class="number">302</span></span><br><span class="line"><span class="number">4</span>: a[<span class="number">0</span>] = <span class="number">200</span>, a[<span class="number">1</span>] = <span class="number">400</span>, a[<span class="number">2</span>] = <span class="number">301</span>, a[<span class="number">3</span>] = <span class="number">302</span></span><br><span class="line"><span class="number">5</span>: a[<span class="number">0</span>] = <span class="number">200</span>, a[<span class="number">1</span>] = <span class="number">128144</span>, a[<span class="number">2</span>] = <span class="number">256</span>, a[<span class="number">3</span>] = <span class="number">302</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// b = a + 4</span></span><br><span class="line"><span class="number">6</span>: a = <span class="number">0xbfa8bdbc</span>, b = <span class="number">0xbfa8bdc0</span>, c = <span class="number">0xbfa8bdbd</span></span><br></pre></td></tr></table></figure></p>
<p>ELF格式非常强大和复杂，但大多数复杂的部分都是为了支持共享库的动态加载，在6.828课程中并不会用到。在本课程中，我们可以把ELF可执行文件简单地看为带有加载信息的标头，后跟几个程序部分，每个程序部分都是一个连续的代码块或数据，其将被加载到指定内存中。</p>
<p>我们所需要关心的Program Section是：</p>
<ul>
<li>.text : 可执行指令</li>
<li>.rodata: 只读数据段,例如字符串常量。（但是，我们不会费心设置硬件来禁止写入。）</li>
<li>.data : 存放已经初始化的数据</li>
<li>.bss ： 存放未初始化的变量， 但是在ELF中只需要记录.bss的起始地址和长度。Loader and program必须自己将.bss段清零。</li>
</ul>
<p>每个程序头的<code>ph-&gt; p_pa</code>字段包含段的目标物理地址（在这种情况下，它实际上是一个物理地址，尽管ELF规范对该字段的实际含义含糊不清）</p>
<p>BIOS会将引导扇区的内容加载到 0x7c00 的位置，引导程序也就从0x7C00的位置开始执行。我们通过-Ttext 0x7C00将链接地址传递给<code>boot / Makefrag</code>中的链接器，因此链接器将在生成的代码中生成正确的内存地址。</p>
<p>除了部分信息之外，ELF头中还有一个对我们很重要的字段，名为<code>e_entry</code>。该字段保存程序中入口点的链接地址：程序应该开始执行的代码段的存储地址。 在反汇编代码中，可以看到最后call 了 0x10018地址。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">((void (*)(void)) (ELFHDR-&gt;e_entry))();</span><br><span class="line">    7d6b:    ff 15 18 00 01 00        call   *0x10018</span><br></pre></td></tr></table></figure></p>
<p>在0x7d6b 打断点后，c 再si一次，发现实际跳转地址位0x10000c<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b *0x7d6b</span><br><span class="line">Breakpoint 3 at 0x7d6b</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">=&gt; 0x7d6b:    call   *0x10018</span><br><span class="line"></span><br><span class="line">Breakpoint 3, 0x00007d6b in ?? ()</span><br><span class="line">(gdb) si</span><br><span class="line">=&gt; 0x10000c:    movw   $0x1234,0x472</span><br></pre></td></tr></table></figure></p>
<p>与实际执行objdump -f kernel的 结果一致。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">../kern/kernel:     file format elf32-i386</span><br><span class="line">architecture: i386, flags 0x00000112:</span><br><span class="line">EXEC_P, HAS_SYMS, D_PAGED</span><br><span class="line">start address 0x0010000c</span><br></pre></td></tr></table></figure></p>
<h1 id="Part3：The-Kernel"><a href="#Part3：The-Kernel" class="headerlink" title="Part3：The Kernel"></a>Part3：The Kernel</h1><p>我们现在将开始更详细地研究JOS内核。（最后你会写一些代码！）。与引导加载程序一样，内核从一些汇编语言代码开始，这些代码设置可以使C语言代码正确执行。</p>
<h2 id="使用虚拟内存来解决位置依赖问题"><a href="#使用虚拟内存来解决位置依赖问题" class="headerlink" title="使用虚拟内存来解决位置依赖问题"></a>使用虚拟内存来解决位置依赖问题</h2><p>操作系统内核通常被链接到非常高的虚拟地址（例如0xf0100000）下运行，以便留下处理器虚拟地址空间的低地址部分供用户程序使用。 在下一个lab中，这种安排的原因将变得更加清晰。</p>
<p>许多机器在地址范围无法达到0xf0100000，因此我们无法指望能够在那里存储内核。相反，我们将使用处理器的内存管理硬件将虚拟地址0xf0100000（内核代码期望运行的链接地址）映射到物理地址0x00100000（引导加载程序将内核加载到物理内存中）。尽管内核的虚拟地址足够高，可以为用户进程留下大量的内存空间，在物理地址中内核将会被加载到1MB的位置，仅次于BIOS。</p>
<p>现在，我们只需映射前4MB的物理内存，这足以让我们启动并运行。 我们使用kern/entrypgdir.c中手写的，静态初始化的页面目录和页表来完成此操作。 现在，你不必了解其工作原理的细节，只需注意其实现的效果。</p>
<p>实现虚拟地址，有一个很重要的寄存器CR0-PG：</p>
<blockquote>
<p>PG：CR0的位31是分页（Paging）标志。当设置该位时即开启了分页机制；当复位时则禁止分页机制，此时所有线性地址等同于物理地址。在开启这个标志之前必须已经或者同时开启PE标志。即若要启用分页机制，那么PE和PG标志都要置位。</p>
</blockquote>
<h2 id="Exercise-7"><a href="#Exercise-7" class="headerlink" title="Exercise 7"></a>Exercise 7</h2><ol>
<li>使用QEMU和GDB跟踪到JOS内核并停在<code>movl %eax，%cr0</code>。 检查内存为0x00100000和0xf0100000。 现在，使用stepi GDB命令单步执行该指令。 再次检查内存为0x00100000和0xf0100000。 确保你了解刚刚发生的事情。</li>
</ol>
<p>注意实验文档上所说的，硬件实现的页表转换机制将0xf0000000等那些f打头的16进制地址转到0x00100000。GDB调试设置断点时，设置的是物理地址，不是逻辑地址，所以断点设置为kernel的入口地址。</p>
<p>b *0x10000c<br>1<br>不知为何，断点设置到0x100000不行，可能是因为代码段中那一段标号和段标识我不认识。</p>
<p>0x100000处的反汇编代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.globl entry</span><br><span class="line">entry:</span><br><span class="line">	movw	$0x1234,0x472			# warm boot</span><br><span class="line">f0100000:	02 b0 ad 1b 00 00    	add    0x1bad(%eax),%dh</span><br><span class="line">f0100006:	00 00                	add    %al,(%eax)</span><br><span class="line">f0100008:	fe 4f 52             	decb   0x52(%edi)</span><br><span class="line">f010000b:	e4                   	.byte 0xe4</span><br><span class="line"></span><br><span class="line">f010000c &lt;entry&gt;:</span><br><span class="line">f010000c:	66 c7 05 72 04 00 00 	movw   $0x1234,0x472</span><br></pre></td></tr></table></figure></p>
<p>执行过程如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">The target architecture is assumed to be i386</span><br><span class="line">=&gt; 0x10000c:    movw   $0x1234,0x472</span><br><span class="line"></span><br><span class="line">Breakpoint 1, 0x0010000c in ?? ()</span><br><span class="line">(gdb) s</span><br><span class="line">Cannot find bounds of current function</span><br><span class="line">(gdb) si</span><br><span class="line">=&gt; 0x100015:    mov    $0x112000,%eax</span><br><span class="line">0x00100015 in ?? ()</span><br><span class="line">(gdb) si</span><br><span class="line">=&gt; 0x10001a:    mov    %eax,%cr3</span><br><span class="line">0x0010001a in ?? ()</span><br><span class="line">(gdb) si</span><br><span class="line">=&gt; 0x10001d:    mov    %cr0,%eax</span><br><span class="line">0x0010001d in ?? ()</span><br><span class="line">(gdb) si</span><br><span class="line">=&gt; 0x100020:    or     $0x80010001,%eax</span><br><span class="line">0x00100020 in ?? ()</span><br><span class="line">(gdb) si</span><br><span class="line">=&gt; 0x100025:    mov    %eax,%cr0</span><br><span class="line">0x00100025 in ?? ()</span><br><span class="line">(gdb) si</span><br><span class="line">=&gt; 0x100028:    mov    $0xf010002f,%eax</span><br><span class="line">0x00100028 in ?? ()</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure></p>
<p>当执行到<code>movl %eax,%cr0</code>时，停下，此时查看两处内存结果如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">=&gt; 0x100025:    mov    %eax,%cr0</span><br><span class="line">0x00100025 in ?? ()</span><br><span class="line">(gdb) x/1x 0x00100000</span><br><span class="line">0x100000:       0x1badb002</span><br><span class="line">(gdb) x/1x 0xf0100000</span><br><span class="line">0xf0100000 &lt;_start+4026531828&gt;: 0x00000000</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure></p>
<p>因为0xf0100000处不是我们真正装载内核的地方，逻辑地址0xf0100000被映射成了0x00100000，所以低地址处有内容，高地址处无内容。</p>
<p>当单步执行完<code>movl %eax,%cr0</code> 时，停下，此时查看两处内存结果如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">=&gt; 0x100028:    mov    $0xf010002f,%eax</span><br><span class="line">0x00100028 in ?? ()</span><br><span class="line">(gdb) x/1x 0x00100000</span><br><span class="line">0x100000:       0x1badb002</span><br><span class="line">(gdb) x/1x 0xf0100000</span><br><span class="line">0xf0100000 &lt;_start+4026531828&gt;: 0x1badb002</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure></p>
<p>可以看到高地址处和低地址处值相同了。</p>
<p>原因其实在实验指导书里写着。</p>
<blockquote>
<p>Once CR0_PG is set, memory references are virtual addresses that get translated by the virtual memory hardware to physical addresses. entry_pgdir translates virtual addresses in the range 0xf0000000 through 0xf0400000 to physical addresses 0x00000000 through 0x00400000, as well as virtual addresses 0x00000000 through 0x00400000 to physical addresses 0x00000000 through 0x00400000.</p>
</blockquote>
<p>首先明确cr0是什么。cr0全称是control register 0.下面是wiki中的解释。</p>
<p>The CR0 register is 32 bits long on the 386 and higher processors. On x86-64 processors in long mode, it (and the other control registers) is 64 bits long. CR0 has various control flags that modify the basic operation of the processor.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Bit</th>
<th>Name</th>
<th>Full Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>PE</td>
<td>Protected Mode Enable</td>
<td>If 1, system is in protected mode, else system is in real mode</td>
</tr>
<tr>
<td>1</td>
<td>MP</td>
<td>Monitor co-processor</td>
<td>Controls interaction of WAIT/FWAIT instructions with TS flag in CR0</td>
</tr>
<tr>
<td>2</td>
<td>EM</td>
<td>Emulation</td>
<td>If set, no x87 floating-point unit present, if clear, x87 FPU present</td>
</tr>
<tr>
<td>3</td>
<td>TS</td>
<td>Task switched</td>
<td>Allows saving x87 task context upon a task switch only after x87 instruction used</td>
</tr>
<tr>
<td>4</td>
<td>ET</td>
<td>Extension type</td>
<td>On the 386, it allowed to specify whether the external math coprocessor was an 80287 or 80387</td>
</tr>
<tr>
<td>5</td>
<td>NE</td>
<td>Numeric error</td>
<td>Enable internal x87 floating point error reporting when set, else enables PC style x87 error detection</td>
</tr>
<tr>
<td>16</td>
<td>WP</td>
<td>Write protect</td>
<td>When set, the CPU can’t write to read-only pages when privilege level is 0</td>
</tr>
<tr>
<td>18</td>
<td>AM</td>
<td>Alignment mask</td>
<td>Alignment check enabled if AM set, AC flag (in EFLAGS register) set, and privilege level is 3</td>
</tr>
<tr>
<td>29</td>
<td>NW</td>
<td>Not-write through</td>
<td>Globally enables/disable write-through caching</td>
</tr>
<tr>
<td>30</td>
<td>CD</td>
<td>Cache disable</td>
<td>Globally enables/disable the memory cache</td>
</tr>
<tr>
<td>31</td>
<td>PG</td>
<td>Paging</td>
<td>If 1, enable paging and use the § CR3 register, else disable paging.</td>
</tr>
</tbody>
</table>
</div>
<p>把eax赋给cr0时，eax=0x80110001，对应上面的标志位就能知道发出了什么控制信息。最关键的是PG，这个信号打开了页表机制，以后都会自动将 0xf0000000 到 0xf0400000 的虚拟（逻辑）地址转成 0x00000000 到 0x00400000 的物理地址。</p>
<p>所以此处会自动把0xf0100000转换成0x00100000，所以两者的值相等。</p>
<p>如果映射机制失败，我觉得<code>jmp *%eax</code>之后会失败。因为此时eax的值是0xf010002f，如果没有地址映射，那会指向这个物理高地址，而不是本应指向的0x100000附近的低地址，就会出错。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">=&gt; 0x100025:    mov    $0xf010002c,%eax</span><br><span class="line">0x00100025 in ?? ()</span><br><span class="line">(gdb) </span><br><span class="line">=&gt; 0x10002a:    jmp    *%eax</span><br><span class="line">0x0010002a in ?? ()</span><br><span class="line">(gdb) </span><br><span class="line">=&gt; 0xf010002c &lt;relocated&gt;:      add    %al,(%eax)</span><br><span class="line">relocated () at kern/entry.S:74</span><br><span class="line">74              movl    $0x0,%ebp                       # nuke frame pointer</span><br><span class="line">(gdb) </span><br><span class="line">Remote connection closed</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure></p>
<p>上面是注释掉<code>movl %eax,%cr0</code>之后的调试结果。果然，跳转之后的第一条指令就报错了。</p>
<p>在entry.S中说：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The kernel (this code) is linked at address ~(KERNBASE + 1 Meg),</span><br></pre></td></tr></table></figure></p>
<p>在程序编译后，被链接到高地址处。在kernel.ld链接脚本文件里指定了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/* Link the kernel at this address: &quot;.&quot; means the current address */</span><br><span class="line">    . = 0xF0100000;</span><br></pre></td></tr></table></figure></p>
<p>但是bootloader 实际把kernel加载到了0x100000的位置</p>
<h2 id="格式化输出到控制台"><a href="#格式化输出到控制台" class="headerlink" title="格式化输出到控制台"></a>格式化输出到控制台</h2><p>激动人心的时刻到了，我们终于到了能对设备进行操作的阶段了。能打印出信息，是实现交互的开始，也是我们之后调试的一个重要途径。</p>
<p>大多数人都把<code>printf()</code>这样的函数认为是理所当然的，有时甚至认为它们是C语言的“原语“。但在OS内核中，我们必须自己实现所有I/O.</p>
<p>阅读<code>kern/printf.c</code>，<code>lib/printfmt.c</code>，<code>kern/console.c</code>三个源代码，理清三者之间的关系。</p>
<p><code>printf.c</code>基于<code>printfmt()</code>和 kernel console’s cputchar()；</p>
<h2 id="Exercise-8"><a href="#Exercise-8" class="headerlink" title="Exercise 8"></a>Exercise 8</h2><p>我们省略了一小段代码 - 使用“％o”形式的模式打印八进制数所需的代码。 查找并填写此代码片段。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">case &apos;o&apos;:</span><br><span class="line">            // Replace this with your code.</span><br><span class="line">            putch(&apos;0&apos;, putdat);</span><br><span class="line">            num = getuint(&amp;ap, lflag);</span><br><span class="line">            base = 8;</span><br><span class="line">            goto number;</span><br></pre></td></tr></table></figure></p>
<p>就是把%u的代码复制一遍，base 改为 8 就差不多了，并不复杂。</p>
<blockquote>
<p>Explain the interface between printf.c and console.c. Specifically, what function does console.c export? How is this function used by printf.c?</p>
</blockquote>
<p><code>printf.c</code>中使用了<code>console.c</code>中的<code>cputchar</code>函数，并封装为<code>putch</code>函数。并以函数形参传递到<code>printfmt.c</code>中的<code>vprintfmt</code>函数，用于向屏幕上输出一个字符。</p>
<blockquote>
<p>解释console.c中的一段代码。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// What is the purpose of this?</span></span><br><span class="line">    <span class="keyword">if</span> (crt_pos &gt;= CRT_SIZE) &#123;</span><br><span class="line">    <span class="comment">// 显示字符数超过CRT一屏可显示的字符数</span></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="comment">// 清除buf中"第一行"的字符</span></span><br><span class="line">        memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * <span class="keyword">sizeof</span>(<span class="keyword">uint16_t</span>));</span><br><span class="line">        <span class="comment">// CRT显示器需要对其用空格擦写才能去掉本来以及显示了的字符。</span></span><br><span class="line">        <span class="keyword">for</span> (i = CRT_SIZE - CRT_COLS; i &lt; CRT_SIZE; i++)</span><br><span class="line">            crt_buf[i] = <span class="number">0x0700</span> | <span class="string">' '</span>;</span><br><span class="line">        <span class="comment">// 显示起点退回到最后一行起始</span></span><br><span class="line">        crt_pos -= CRT_COLS;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>首先理解几个宏定义和函数</p>
<ul>
<li><code>CRT_ROWS</code>，<code>CRT_COLS</code>：CRT显示器行列最大值， 此处是25x80</li>
<li><code>ctr_buf</code>在初始化时指向了显示器I/O地址</li>
</ul>
<p><code>memmove</code>从<code>ctr_buf+CTR_COLS</code>复制到<code>ctr_buf</code>中，就是清除掉第一行的数据，把最后一行给空出来，2~n行的数据（<code>CRT_SIZE - CRT_COLS</code>）个，移动到1~n-1行的位置。</p>
<blockquote>
<p>跟踪执行以下代码，在调用<code>cprintf()</code>时，<code>fmt</code>，<code>ap</code>指向什么？</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">1</span>, y = <span class="number">3</span>, z = <span class="number">4</span>;</span><br><span class="line">cprintf(<span class="string">"x %d, y %x, z %d\n"</span>, x, y, z);</span><br></pre></td></tr></table></figure>
<p>在<code>kern/init.c</code>的<code>i386_init()</code>下加入代码，就可以直接测试；加<code>Lab1_exercise8_3</code>标号的目的是为了在<code>kern/kernel.asm</code>反汇编代码中容易找到添加的代码的位置。可以看到地址在<code>0xf0100080</code>处<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lab1 Exercise_8</span></span><br><span class="line">&#123;</span><br><span class="line">    cprintf(<span class="string">"Lab1_Exercise_8:\n"</span>);</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">1</span>, y = <span class="number">3</span>, z = <span class="number">4</span>;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    Lab1_exercise8_3:</span><br><span class="line">    cprintf(<span class="string">"x %d, y %x, z %d\n"</span>, x, y, z);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0x00646c72</span>;</span><br><span class="line">    cprintf(<span class="string">"H%x Wo%s"</span>, <span class="number">57616</span>, &amp;i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>调试过程fmt=0xf010478d ， ap=0xf0118fc4； fmt指向字符串，ap指向栈顶<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cprintf (fmt=0xf010478d &quot;x %d, y %x, z %d\n&quot;) at kern/printf.c:27</span><br></pre></td></tr></table></figure></p>
<p>可以看到以上地址处就存了字符串</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/s 0xf010478d</span><br><span class="line">0xf010478d:    &quot;x %d, y %x, z %d\n&quot;</span><br><span class="line"></span><br><span class="line">gdb) si</span><br><span class="line">=&gt; 0xf0102f85 &lt;vcprintf&gt;:    push   %ebp</span><br><span class="line">vcprintf (fmt=0xf010478d &quot;x %d, y %x, z %d\n&quot;, ap=0xf0118fc4 &quot;\001&quot;)</span><br><span class="line">    at kern/printf.c:18</span><br><span class="line">18    &#123;</span><br><span class="line"></span><br><span class="line">(gdb) x/16b 0xf0118fc4</span><br><span class="line">0xf0118fc4:    0x01    0x00    0x00    0x00    0x03    0x00    0x00    0x00</span><br><span class="line">0xf0118fcc:    0x04    0x00    0x00    0x00    0x7b    0x47    0x10    0xf0</span><br></pre></td></tr></table></figure>
<p>引用一段Github上大神做的labclpsz/mit-jos-2014的execise8中的一段话。</p>
<blockquote>
<p>从这个练习可以看出来，正是因为C函数调用实参的入栈顺序是从右到左的，才使得调用参数个数可变的函数成为可能(且不用显式地指出参数的个数)。但是必须有一个方式来告诉实际调用时传入的参数到底是几个，这个是在格式化字符串中指出的。如果这个格式化字符串指出的参数个数和实际传入的个数不一致，比如说传入的参数比格式化字符串指出的要少，就可能会使用到栈上错误的内存作为传入的参数，编译器必须检查出这样的错误。</p>
</blockquote>
<p>4.运行以下代码，输出结果是什么。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unsigned int i = 0x00646c72;</span><br><span class="line">cprintf(&quot;H%x Wo%s&quot;, 57616, &amp;i);</span><br></pre></td></tr></table></figure>
<p>调试输出了<code>He110 World</code>。<code>57616</code>的十六进制形式为<code>E110</code>，因为是小端机，<code>i</code>的在内存中为<code>0x72</code>，<code>0x6c</code>，<code>0x64</code>，<code>0x00</code>，对应ASCII为<code>rld\0</code>。</p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>打开文件<code>kern/entry.S</code>，按ctrl+f查找关键字，找找stack这个词出现在哪里，看看每次出现的含义。</p>
<p>77行处将一个宏变量<code>bootstacktop</code>的值赋值给了寄存器<code>esp</code>。而<code>bootstacktop</code>出现在<code>bootstack</code>下，<code>bootstack</code>出现在<code>.data</code>段下，这是数据段。可以肯定，这就是栈了。通过93行<code>.space</code>指令，在<code>bootstack</code>位置处初始化了<code>KSTKSIZE</code>这么多的空间。<code>KSTKSIZE</code>在<code>inc/memlayout.h</code>里面定义，是<code>8*PGSIZE</code>，而<code>PGSIZE</code>在<code>inc/mmu.h</code>中定义，值为4096。</p>
<p>栈在内核入口的汇编代码中初始化，是通过一个汇编指令<code>.space</code>，大小是<code>8 * 4096</code>。接下来看看栈的位置。</p>
<p>查看反汇编代码<code>obj/kern/kernel.asm</code>，<code>bootstacktop</code>的值为<code>0xf010f000</code>。这就是栈的位置，准确来说，是栈顶，栈将向地址值更小的方向生长。</p>
<h2 id="栈的行为"><a href="#栈的行为" class="headerlink" title="栈的行为"></a>栈的行为</h2><p>在正式运行一段代码之前，esp寄存器需要先初始化，正如前文所说。这个初始化可以是手动完成的，如<code>kern/entry.S</code>，也可以是自动完成的，如<code>call</code>指令。程序运行时，esp保存的地址以下的内存，都是栈可以生长，但尚未生长到的。esp表示的是“栈顶地址”stack top。</p>
<p>x86栈指针<code>esp</code>寄存器纸箱栈的最低地址。这个地址之下的都是空闲的。将一个值压入栈需要减小栈指针，同时把值写到栈指针之前指向的地方。在32位机器上，栈只能存储32位的值，<code>esp</code>只能被4整除。</p>
<p>程序“压栈”，就是减小esp，并在刚刚esp指向的位置上写入数据。</p>
<p>还有一个寄存器ebp，意思是base pointer，记录的是当前函数栈的开头。没有指令会自动更新ebp的值，但是任何C编译器都要遵守这个规定，写汇编的程序员也是，调用函数时必须写指令更新ebp寄存器。</p>
<h2 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h2><p>在执行新的函数<code>callee</code>代码之前，先保存旧函数<code>caller</code>的栈的位置。这样一来，<code>callee</code>才可以返回到正确的指令上。通过ebp寄存器的值，Debugger可以迅速找到调用这个函数的函数，一路找到最开始执行这个函数的函数，这种操作称为<code>backtrace</code>。</p>
<p>看到反汇编代码<code>obj/kern/kernel.asm</code>中，所有C函数的第一个指令都是<code>push %ebp</code>，保存了旧的栈地址。第二个指令都是<code>mov %esp, %ebp</code>，将当前栈地址，也就是函数的栈的开头，保存到<code>ebp</code>。</p>
<h2 id="函数返回"><a href="#函数返回" class="headerlink" title="函数返回"></a>函数返回</h2><p>函数返回时，寄存器<code>eip</code>，也就是Instruction Pointer，跳转到调用本函数的<code>call</code>指令的下一个指令，且esp增加。栈是向下增长的，所以这其实是在“弹出”。调用函数时，函数接受的参数都被压栈，故返回时相应弹出。</p>
<h2 id="Exercise-10"><a href="#Exercise-10" class="headerlink" title="Exercise 10"></a>Exercise 10</h2><p>在<code>obj/kern/kernel.asm</code>找到<code>test_backtrace</code>函数，并设置断点。进行调试。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_backtrace</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cprintf(<span class="string">"entering test_backtrace %d\n"</span>, x);</span><br><span class="line">	<span class="keyword">if</span> (x &gt; <span class="number">0</span>)</span><br><span class="line">		test_backtrace(x<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		mon_backtrace(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	cprintf(<span class="string">"leaving test_backtrace %d\n"</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>test_backtrace函数对应的汇编代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">f0100040:	55                   	push   %ebp</span><br><span class="line">f0100041:	89 e5                	mov    %esp,%ebp</span><br><span class="line">f0100043:	56                   	push   %esi</span><br><span class="line">f0100044:	53                   	push   %ebx</span><br><span class="line">f0100045:	e8 5b 01 00 00       	call   f01001a5 &lt;\_\_x86.get_pc_thunk.bx&gt;</span><br><span class="line">f010004a:	81 c3 be 12 01 00    	add    $0x112be,%ebx</span><br><span class="line">f0100050:	8b 75 08             	mov    0x8(%ebp),%esi</span><br><span class="line">f0100053:	83 ec 08             	sub    $0x8,%esp</span><br><span class="line">f0100056:	56                   	push   %esi</span><br><span class="line">f0100057:	8d 83 18 07 ff ff    	lea    -0xf8e8(%ebx),%eax</span><br><span class="line">f010005d:	50                   	push   %eax</span><br><span class="line">f010005e:	e8 cf 09 00 00       	call   f0100a32 &lt;cprintf&gt;</span><br><span class="line">f0100063:	83 c4 10             	add    $0x10,%esp</span><br><span class="line">f0100066:	85 f6                	test   %esi,%esi</span><br><span class="line">f0100068:	7f 2b                	jg     f0100095 &lt;test\_backtrace+0x55&gt;</span><br><span class="line">f010006a:	83 ec 04             	sub    $0x4,%esp</span><br><span class="line">f010006d:	6a 00                	push   $0x0</span><br><span class="line">f010006f:	6a 00                	push   $0x0</span><br><span class="line">f0100071:	6a 00                	push   $0x0</span><br><span class="line">f0100073:	e8 f4 07 00 00       	call   f010086c &lt;mon\_backtrace&gt;</span><br><span class="line">f0100078:	83 c4 10             	add    $0x10,%esp</span><br><span class="line">f010007b:	83 ec 08             	sub    $0x8,%esp</span><br><span class="line">f010007e:	56                   	push   %esi</span><br><span class="line">f010007f:	8d 83 34 07 ff ff    	lea    -0xf8cc(%ebx),%eax</span><br><span class="line">f0100085:	50                   	push   %eax</span><br><span class="line">f0100086:	e8 a7 09 00 00       	call   f0100a32 &lt;cprintf&gt;</span><br><span class="line">&#125;</span><br><span class="line">f010008b:	83 c4 10             	add    $0x10,%esp</span><br><span class="line">f010008e:	8d 65 f8             	lea    -0x8(%ebp),%esp</span><br><span class="line">f0100091:	5b                   	pop    %ebx</span><br><span class="line">f0100092:	5e                   	pop    %esi</span><br><span class="line">f0100093:	5d                   	pop    %ebp</span><br><span class="line">f0100094:	c3                   	ret    </span><br><span class="line">f0100095:	83 ec 0c             	sub    $0xc,%esp</span><br><span class="line">f0100098:	8d 46 ff             	lea    -0x1(%esi),%eax</span><br><span class="line">f010009b:	50                   	push   %eax</span><br><span class="line">f010009c:	e8 9f ff ff ff       	call   f0100040 &lt;test\_backtrace&gt;</span><br><span class="line">f01000a1:	83 c4 10             	add    $0x10,%esp</span><br><span class="line">f01000a4:	eb d5                	jmp    f010007b &lt;test\_backtrace+0x3b&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="观察test-backtrace函数调用栈"><a href="#观察test-backtrace函数调用栈" class="headerlink" title="观察test_backtrace函数调用栈"></a>观察test_backtrace函数调用栈</h2><p>下面开始观察test_backtrace函数的调用栈。%esp存储栈顶的位置，%ebp存储调用者栈顶的位置，%eax存储x的值，这几个寄存器需要重点关注，因此我使用gdb的display命令设置每次运行完成后自动打印它们的值，此外我也设置了自动打印栈内被用到的那段内存的数据，以便清楚观察栈的变化情况。Let’s go.</p>
<p>进入test_backtrace(5)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f01000d1:	c7 04 24 05 00 00 00 	movl   $0x5,(%esp)</span><br><span class="line">f01000d8:	e8 63 ff ff ff       	call   f0100040 &lt;test\_backtrace&gt;</span><br><span class="line">f01000dd:	83 c4 10             	add    $0x10,%esp</span><br></pre></td></tr></table></figure></p>
<p>test_backtrace函数的调用发生在i386_init函数中，传入的参数x=5.我们将从这里开始跟踪栈内数据的变化情况。各寄存器及栈内的数据如下所示。可见，共有两个4字节的整数被压入栈：</p>
<p>输入参数的值（也就是5）。<br>call指令的下一条指令的地址（也就是f01000dd）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">%esp = 0xf010ffdc</span><br><span class="line">%ebp = 0xf010fff8</span><br><span class="line">// stack info</span><br><span class="line">0xf010ffe0: 0x00000005  // 第1次调用时的输入参数：5</span><br><span class="line">0xf010ffdc: 0xf01000dd  // 第1次调用时的返回地址</span><br></pre></td></tr></table></figure></p>
<p>进入test_backtrace函数后，涉及栈内数据修改的指令可以分为三部分：</p>
<ul>
<li>函数开头，将部分寄存器的值压栈，以便函数结束前可以恢复。</li>
<li>调用cprintf前，将输入参数压入栈。</li>
<li>在第2次调用test_backtrace前，将输入参数压入栈。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// function start</span><br><span class="line">f0100040:	55                   	push   %ebp</span><br><span class="line">f0100041:	89 e5                	mov    %esp,%ebp</span><br><span class="line">f0100043:	56                   	push   %esi</span><br><span class="line">f0100044:	53                   	push   %ebx</span><br><span class="line">// call cprintf</span><br><span class="line">f0100053:	83 ec 08             	sub    $0x8,%esp</span><br><span class="line">f0100056:	56                   	push   %esi</span><br><span class="line">f0100057:	8d 83 18 07 ff ff    	lea    -0xf8e8(%ebx),%eax</span><br><span class="line">f010005d:	50                   	push   %eax</span><br><span class="line">f010005e:	e8 cf 09 00 00       	call   f0100a32 &lt;cprintf&gt;</span><br><span class="line">f0100063:	83 c4 10             	add    $0x10,%esp</span><br><span class="line">// call test_backtrace(x-1)</span><br><span class="line">f0100095:	83 ec 0c             	sub    $0xc,%esp</span><br><span class="line">f0100098:	8d 46 ff             	lea    -0x1(%esi),%eax</span><br><span class="line">f010009b:	50                   	push   %eax</span><br><span class="line">f010009c:	e8 9f ff ff ff       	call   f0100040 &lt;test_backtrace&gt;</span><br></pre></td></tr></table></figure>
<p>进入test_backtrace(4)</p>
<p>在即将进入test_backtrace(4)前，栈内数据如下所示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">%esp = 0xf010ffc0</span><br><span class="line">%ebp = 0xf010ffd8</span><br><span class="line">// stack info</span><br><span class="line">0xf010ffe0: 0x00000005  // 第1次调用时的输入参数：5</span><br><span class="line">0xf010ffdc: 0xf01000dd  // 第1次调用时的返回地址</span><br><span class="line">0xf010ffd8: 0xf010fff8  // 第1次调用时寄存器%ebp的值</span><br><span class="line">0xf010ffd4: 0x10094     // 第1次调用时寄存器%esi的值</span><br><span class="line">0xf010ffd0: 0xf0111308  // 第1次调用时寄存器%ebx的值</span><br><span class="line">0xf010ffcc: 0xf010004a  // 残留数据，不需关注</span><br><span class="line">0xf010ffc8: 0x00000000  // 残留数据，不需关注</span><br><span class="line">0xf010ffc4: 0x00000005  // 残留数据，不需关注</span><br><span class="line">0xf010ffc0: 0x00000004  // 第2次调用时的输入参数</span><br></pre></td></tr></table></figure></p>
<p>进入mon_backtrace(0, 0, 0)</p>
<p>在即将进入mon_backtrace(0, 0, 0)前，栈内数据如下所示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">%esp = 0xf010ff20</span><br><span class="line">%ebp = 0xf010ff38</span><br><span class="line">// stack info</span><br><span class="line">0xf010ffe0: 0x00000005  // 第1次调用时的输入参数：5</span><br><span class="line">0xf010ffdc: 0xf01000dd  // 第1次调用时的返回地址</span><br><span class="line">0xf010ffd8: 0xf010fff8  // 第1次调用开始时寄存器%ebp的值</span><br><span class="line">0xf010ffd4: 0x10094     // 第1次调用开始时寄存器%esi的值</span><br><span class="line">0xf010ffd0: 0xf0111308  // 第1次调用开始时寄存器%ebx的值</span><br><span class="line">0xf010ffcc: 0xf010004a  // 预留空间，不需关注</span><br><span class="line">0xf010ffc8: 0x00000000  // 预留空间，不需关注</span><br><span class="line">0xf010ffc4: 0x00000005  // 预留空间，不需关注</span><br><span class="line">0xf010ffc0: 0x00000004  // 第2次调用时的输入参数：4</span><br><span class="line">0xf010ffbc: 0xf01000a1  // 第2次调用时的返回地址</span><br><span class="line">0xf010ffb8: 0xf010ffd8  // 第2次调用开始时寄存器%ebp的值</span><br><span class="line">0xf010ffb4: 0x00000005  // 第2次调用开始时寄存器%esi的值</span><br><span class="line">0xf010ffb0: 0xf0111308  // 第2次调用开始时寄存器%ebx的值</span><br><span class="line">0xf010ffac: 0xf010004a  // 预留空间，不需关注</span><br><span class="line">0xf010ffa8: 0x00000000  // 预留空间，不需关注</span><br><span class="line">0xf010ffa4: 0x00000004  // 预留空间，不需关注</span><br><span class="line">0xf010ffa0: 0x00000003  // 第3次调用时的输入参数：3</span><br><span class="line">0xf010ff9c: 0xf01000a1  // 第3次调用时的返回地址</span><br><span class="line">0xf010ff98: 0xf010ffb8  // 第3次调用开始时寄存器%ebp的值</span><br><span class="line">0xf010ff94: 0x00000004  // 第3次调用开始时寄存器%esi的值</span><br><span class="line">0xf010ff90: 0xf0111308  // 第3次调用开始时寄存器%ebx的值</span><br><span class="line">0xf010ff8c: 0xf010004a  // 预留空间，不需关注</span><br><span class="line">0xf010ff88: 0xf010ffb8  // 预留空间，不需关注</span><br><span class="line">0xf010ff84: 0x00000003  // 预留空间，不需关注</span><br><span class="line">0xf010ff80: 0x00000002  // 第4次调用时的输入参数：2</span><br><span class="line">0xf010ff7c: 0xf01000a1  // 第4次调用时的返回地址</span><br><span class="line">0xf010ff78: 0xf010ff98  // 第4次调用开始时寄存器%ebp的值</span><br><span class="line">0xf010ff74: 0x00000003  // 第4次调用开始时寄存器%esi的值</span><br><span class="line">0xf010ff70: 0xf0111308  // 第4次调用开始时寄存器%ebx的值</span><br><span class="line">0xf010ff6c: 0xf010004a  // 预留空间，不需关注</span><br><span class="line">0xf010ff68: 0xf010ff98  // 预留空间，不需关注</span><br><span class="line">0xf010ff64: 0x00000002  // 预留空间，不需关注</span><br><span class="line">0xf010ff60: 0x00000001  // 第5次调用时的输入参数：1</span><br><span class="line">0xf010ff5c: 0xf01000a1  // 第5次调用时的返回地址</span><br><span class="line">0xf010ff58: 0xf010ff78  // 第5次调用开始时寄存器%ebp的值</span><br><span class="line">0xf010ff54: 0x00000002  // 第5次调用开始时寄存器%esi的值</span><br><span class="line">0xf010ff50: 0xf0111308  // 第5次调用开始时寄存器%ebx的值</span><br><span class="line">0xf010ff4c: 0xf010004a  // 预留空间，不需关注</span><br><span class="line">0xf010ff48: 0xf010ff78  // 预留空间，不需关注</span><br><span class="line">0xf010ff44: 0x00000001  // 预留空间，不需关注</span><br><span class="line">0xf010ff40: 0x00000000  // 第6次调用时的输入参数：0</span><br><span class="line">0xf010ff3c: 0xf01000a1  // 第6次调用时的返回地址</span><br><span class="line">0xf010ff38: 0xf010ff58  // 第6次调用开始时寄存器%ebp的值</span><br><span class="line">0xf010ff34: 0x00000001  // 第6次调用开始时寄存器%esi的值</span><br><span class="line">0xf010ff30: 0xf0111308  // 第6次调用开始时寄存器%ebx的值</span><br><span class="line">0xf010ff2c: 0xf010004a  // 预留空间，不需关注</span><br><span class="line">0xf010ff28: 0x00000000  // 第7次调用时的第1个输入参数：0</span><br><span class="line">0xf010ff24: 0x00000000  // 第7次调用时的第2个输入参数：0</span><br><span class="line">0xf010ff20: 0x00000000  // 第7次调用时的第3个输入参数：0</span><br></pre></td></tr></table></figure></p>
<p>mon_backtrace函数目前内部为空，不需关注。</p>
<p>退出mon_backtrace(0, 0, 0)：通过add $0x10, %esp语句，将输入参数及预留的4字节从栈中清除。此时%esp = 0xf010ff30，%ebp = 0xf010ff38.</p>
<p>退出test_backtrace(0)：连续3个pop语句将ebx, esi和ebp寄存器依次出栈，然后通过ret语句返回。其他1~5的退出过程类似，不再赘述。</p>
<h2 id="实现backtrace"><a href="#实现backtrace" class="headerlink" title="实现backtrace"></a>实现backtrace</h2><p>Lab中的练习要求我们实现一个backtrace函数，能够打印函数调用的地址和传给函数的参数值。其实CLion的Debugger就有这个功能：</p>
<p>我们要实现的函数，就是可以获得函数此时的ebp寄存器的值、返回的地址、和获得参数的值。</p>
<p>查找<code>mon_backtrace</code>，来到已经准备好的一个函数。函数中写了Your code here注释，让我们在这里实现backtrace功能。我的实现如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint32_t</span> ebp = read_ebp();                <span class="comment">// 拿到ebp的值，类型和函数read_ebp的返回类型一致</span></span><br><span class="line"><span class="keyword">int</span> *ebp_base_ptr = (<span class="keyword">int</span> *)ebp;           <span class="comment">// 转化为指针</span></span><br><span class="line"><span class="keyword">uint32_t</span> eip = ebp_base_ptr[<span class="number">1</span>];   		  <span class="comment">// 拿到返回地址</span></span><br><span class="line">cprintf(<span class="string">"ebp %x, eip %x, args "</span>, ebp, eip);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *args = ebp_base_ptr + <span class="number">2</span>;             <span class="comment">// 拿到进入函数之前的栈地址</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;             <span class="comment">// 输出参数</span></span><br><span class="line">    cprintf(<span class="string">"%x "</span>, *(args+i));</span><br><span class="line">&#125;</span><br><span class="line">cprintf(<span class="string">"\n"</span>);</span><br></pre></td></tr></table></figure></p>
<p>我们把读取到的ebp的值转化为了int*类型，这样转化使得对指针的加减法步长和栈中元素长度一致。在x86机器中，地址和int类型同质，长度都是4字节。这样转换之后，无论是加法，还是中括号[]索引，改变的地址都是4字节，而不是1字节，可以恰好改变一个元素的长度。</p>
<p>来看打印得到结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ebp f010ef58, eip f01000a1, args 0 0 0 f010004a f0110308</span><br></pre></td></tr></table></figure></p>
<p>给函数传的3个参数的值均为0，和打印结果一致！</p>
<p>eip的值正是调用完函数mon_backtrace后一个指令的地址，可以查看反汇编代码obj/kern/kernel.asm，调用函数指令如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">		mon_backtrace(0, 0, 0);</span><br><span class="line">f0100093:	83 ec 04             	sub    $0x4,%esp</span><br><span class="line">f0100096:	6a 00                	push   $0x0</span><br><span class="line">f0100098:	6a 00                	push   $0x0</span><br><span class="line">f010009a:	6a 00                	push   $0x0</span><br><span class="line">f010009c:	e8 e1 07 00 00       	call   f0100882 &lt;mon_backtrace&gt;</span><br><span class="line">f01000a1:	83 c4 10             	add    $0x10,%esp</span><br><span class="line">f01000a4:	eb d3                	jmp    f0100079 &lt;test_backtrace+0x39&gt;</span><br></pre></td></tr></table></figure></p>
<p>倒数第二行指令地址正是0xf01000a1！</p>
<h2 id="读取Symbol-Table"><a href="#读取Symbol-Table" class="headerlink" title="读取Symbol Table"></a>读取Symbol Table</h2><p>这个练习要求我们研究函数<code>debuginfo_eip</code>的实现，弄清楚命名为<code>__STAB_*</code>的几个宏的来历和作用，以及将<code>backtrace</code>功能作为命令加入console功能中。</p>
<p>命名为<code>__STAB_*</code>的宏最早在文件<code>kern/kernel.ld</code>中26行出现，<code>__STABSTR_*</code>则在下面一点的34行出现。这个连接器的配置文件，要求连接器生成elf文件时，分配两个segment给到.stab和.stabstr，正如连接器也分配了<code>.data</code>等segment一样。</p>
<p>运行<code>objdump -h obj/kern/kernel</code>查看分配的segment的信息，有关部分如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">obj/kern/kernel:     file format elf32-i386</span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA       LMA       File off  Algn</span><br><span class="line">  0 .text         00001bad  f0100000  00100000  00001000  2**4</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br><span class="line">  1 .rodata       000006f4  f0101bc0  00101bc0  00002bc0  2**5</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  2 .stab         000043b1  f01022b4  001022b4  000032b4  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  3 .stabstr      00001987  f0106665  00106665  00007665  2**0</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  4 .data         00009300  f0108000  00108000  00009000  2**12</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  5 .got          00000008  f0111300  00111300  00012300  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  6 .got.plt      0000000c  f0111308  00111308  00012308  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  7 .data.rel.local 00001000  f0112000  00112000  00013000  2**12</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  8 .data.rel.ro.local 00000044  f0113000  00113000  00014000  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  9 .bss          00000648  f0113060  00113060  00014060  2**5</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line"> 10 .comment      0000002a  00000000  00000000  000146a8  2**0</span><br><span class="line">                  CONTENTS, READONLY</span><br></pre></td></tr></table></figure></p>
<p>运行<code>objdump -G obj/kern/kernel</code>，查看符号列表Symbol Table，得到有关函数和文件的信息，以下粘贴了部分<code>kern/monitor.c</code>文件有关的信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">obj/kern/kernel:     file format elf32-i386</span><br><span class="line"></span><br><span class="line">Contents of .stab section:</span><br><span class="line"></span><br><span class="line">Symnum n_type n_othr n_desc n_value  n_strx String</span><br><span class="line">...  </span><br><span class="line">375    FUN    0      0      f0100882 1790   mon_backtrace:F(0,1)</span><br><span class="line">376    PSYM   0      0      00000008 1603   argc:p(0,1)</span><br><span class="line">377    PSYM   0      0      0000000c 1768   argv:p(0,2)</span><br><span class="line">378    PSYM   0      0      00000010 1780   tf:p(0,5)</span><br><span class="line">379    SLINE  0      59     00000000 0      </span><br><span class="line">380    SOL    0      0      f0100896 601    ./inc/x86.h</span><br><span class="line">381    SLINE  0      214    00000014 0      </span><br><span class="line">382    SOL    0      0      f0100898 1541   kern/monitor.c</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>知道了<code>__STAB_*</code>的来历，看看它们的作用。文件<code>kern/kdebug.c</code>中函数<code>debuginfo_eip</code>142行调用了这几个宏，整个函数和同一个文件里面的另一个函数<code>stab_binsearch</code>的目的是从<code>.stab</code>和<code>.stabstr</code>两个<code>segment</code>中读取出想要的debug信息，装进一个Eipdebuginfo结构体中。</p>
<p>按照提示，我们首先可以调用<code>read_ebp</code>函数来获取当前ebp寄存器的值。ebp寄存器的值实际上是一个指针，指向当前函数的栈帧的底部（而esp寄存器指向当前函数的栈顶）。我们可以把整个调用栈看做一个数组，其中每个元素均为4字节的整数，并以ebp指针的值为数组起始地址，那么<code>ebp[1]</code>存储的就是函数返回地址，也就是题目中要求的eip的值，<code>ebp[2]</code>以后存储的是输入参数的值。由于题目要求打印5个输入参数，因此需要获取<code>ebp[2]</code>～<code>ebp[6]</code>的值。这样第一条栈信息便可打印出来。</p>
<p>那么怎么打印下一条栈信息呢？还得从ebp入手。当前ebp指针存储的恰好是调用者的ebp寄存器的值，因此当前ebp指针又可以看做是一个链表头，我们通过链表头就可以遍历整个链表。举个例子：假设有A、B、C三个函数，A调用B，B调用C，每个函数都对应有一个栈帧，栈帧的底部地址均存储在当时的ebp寄存器中，不妨记为a_ebp, b_ebp和c_ebp，那么将有c_ebp -&gt; b_ebp -&gt; a_ebp，用程序语言表示就是：<code>a_ebp = (uint32_t *)*b_ebp</code>和<code>b_ebp = (uint32_t *)*c_ebp</code>。</p>
<p>还有一个问题：怎么知道遍历何时结束呢？题目中提示可以参考kern/entry.S，于是我打开此文件，果然找打答案：内核初始化时会将ebp设置为0，因此当我们检查到ebp为0后就应该结束了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Clear the frame pointer register (EBP)</span><br><span class="line"># so that once we get into debugging C code,</span><br><span class="line"># stack backtraces will be terminated properly.</span><br><span class="line">movl	$0x0,%ebp			# nuke frame pointer</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mon_backtrace</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, struct Trapframe *tf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> *ebp;</span><br><span class="line"></span><br><span class="line">    ebp = (<span class="keyword">uint32_t</span> *)read_ebp();</span><br><span class="line"></span><br><span class="line">    cprintf(<span class="string">"Stack backtrace:\r\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (ebp)</span><br><span class="line">    &#123;</span><br><span class="line">        cprintf(<span class="string">"  ebp %08x  eip %08x  args %08x %08x %08x %08x %08x\r\n"</span>, </span><br><span class="line">                ebp, ebp[<span class="number">1</span>], ebp[<span class="number">2</span>], ebp[<span class="number">3</span>], ebp[<span class="number">4</span>], ebp[<span class="number">5</span>], ebp[<span class="number">6</span>]);</span><br><span class="line"></span><br><span class="line">        ebp = (<span class="keyword">uint32_t</span> *)*ebp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">6828 decimal is 15254 octal!</span><br><span class="line">entering test_backtrace 5</span><br><span class="line">entering test_backtrace 4</span><br><span class="line">entering test_backtrace 3</span><br><span class="line">entering test_backtrace 2</span><br><span class="line">entering test_backtrace 1</span><br><span class="line">entering test_backtrace 0</span><br><span class="line">Stack backtrace:</span><br><span class="line">  ebp f010ff18  eip f0100078  args 00000000 00000000 00000000 f010004a f0111308</span><br><span class="line">  ebp f010ff38  eip f01000a1  args 00000000 00000001 f010ff78 f010004a f0111308</span><br><span class="line">  ebp f010ff58  eip f01000a1  args 00000001 00000002 f010ff98 f010004a f0111308</span><br><span class="line">  ebp f010ff78  eip f01000a1  args 00000002 00000003 f010ffb8 f010004a f0111308</span><br><span class="line">  ebp f010ff98  eip f01000a1  args 00000003 00000004 00000000 f010004a f0111308</span><br><span class="line">  ebp f010ffb8  eip f01000a1  args 00000004 00000005 00000000 f010004a f0111308</span><br><span class="line">  ebp f010ffd8  eip f01000dd  args 00000005 00001aac f010fff8 f01000bd 00000000</span><br><span class="line">  ebp f010fff8  eip f010003e  args 00000003 00001003 00002003 00003003 00004003</span><br><span class="line">leaving test_backtrace 0</span><br><span class="line">leaving test_backtrace 1</span><br><span class="line">leaving test_backtrace 2</span><br><span class="line">leaving test_backtrace 3</span><br><span class="line">leaving test_backtrace 4</span><br><span class="line">leaving test_backtrace 5</span><br></pre></td></tr></table></figure></p>
<h2 id="debuginfo-eip函数实现根据地址寻找行号的功能"><a href="#debuginfo-eip函数实现根据地址寻找行号的功能" class="headerlink" title="debuginfo_eip函数实现根据地址寻找行号的功能"></a>debuginfo_eip函数实现根据地址寻找行号的功能</h2><p>解决这个问题的关键是熟悉stabs每行记录的含义，我折腾了一两小时才搞清楚。首先，使用<code>objdump -G obj/kern/kernel &gt; output.md</code>将内核的符号表信息输出到<code>output.md</code>文件，在<code>output.md</code>文件中可以看到以下片段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Symnum n_type n_othr n_desc n_value  n_strx String</span><br><span class="line">118    FUN    0      0      f01000a6 2987   i386_init:F(0,25)</span><br><span class="line">119    SLINE  0      24     00000000 0      </span><br><span class="line">120    SLINE  0      34     00000012 0      </span><br><span class="line">121    SLINE  0      36     00000017 0      </span><br><span class="line">122    SLINE  0      39     0000002b 0      </span><br><span class="line">123    SLINE  0      43     0000003a 0</span><br></pre></td></tr></table></figure></p>
<p>这个片段是什么意思呢？首先要理解第一行给出的每列字段的含义：</p>
<ul>
<li><code>Symnum</code>是符号索引，换句话说，整个符号表看作一个数组，Symnum是当前符号在数组中的下标</li>
<li><code>n_type</code>是符号类型，FUN指函数名，SLINE指在text段中的行号</li>
<li><code>n_othr</code>目前没被使用，其值固定为0</li>
<li><code>n_desc</code>表示在文件中的行号</li>
<li><code>n_value</code>表示地址。特别要注意的是，这里只有FUN类型的符号的地址是绝对地址，SLINE符号的地址是偏移量，其实际地址为函数入口地址加上偏移量。比如第3行的含义是地址f01000b8(=0xf01000a6+0x00000012)对应文件第34行。</li>
</ul>
<p>理解stabs每行记录的含义后，调用<code>stab_binsearch</code>便能找到某个地址对应的行号了。由于前面的代码已经找到地址在哪个函数里面以及函数入口地址，将原地址减去函数入口地址即可得到偏移量，再根据偏移量在符号表中的指定区间查找对应的记录即可。代码如下所示：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">stab_binsearch(stabs, &amp;lfun, &amp;rfun, N_SLINE, addr - info-&gt;eip_fn_addr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (lfun &lt;= rfun)</span><br><span class="line">&#123;</span><br><span class="line">    info-&gt;eip_line = stabs[lfun].n_desc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="给内核模拟器增加backtrace命令，并在mon-backtrace中增加打印文件名、函数名和行号"><a href="#给内核模拟器增加backtrace命令，并在mon-backtrace中增加打印文件名、函数名和行号" class="headerlink" title="给内核模拟器增加backtrace命令，并在mon_backtrace中增加打印文件名、函数名和行号"></a>给内核模拟器增加backtrace命令，并在mon_backtrace中增加打印文件名、函数名和行号</h2><p>给内核模拟器增加backtrace命令。很简单，在<code>kern/monitor.c</code>文件中模仿已有命令添加即可。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">Command</span> <span class="title">commands</span>[] = &#123;</span></span><br><span class="line">	&#123; <span class="string">"help"</span>, <span class="string">"Display this list of commands"</span>, mon_help &#125;,</span><br><span class="line">	&#123; <span class="string">"kerninfo"</span>, <span class="string">"Display information about the kernel"</span>, mon_kerninfo &#125;,</span><br><span class="line">	&#123; <span class="string">"backtrace"</span>, <span class="string">"Display a backtrace of the function stack"</span>, mon_backtrace &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="在mon-backtrace中增加打印文件名、函数名和行号"><a href="#在mon-backtrace中增加打印文件名、函数名和行号" class="headerlink" title="在mon_backtrace中增加打印文件名、函数名和行号"></a>在mon_backtrace中增加打印文件名、函数名和行号</h2><p>经过上面的探索，这个问题就很容易解决了。在<code>mon_backtrace</code>中调用<code>debuginfo_eip</code>来获取文件名、函数名和行号即可。注意，返回的<code>Eipdebuginfo</code>结构体的<code>eip_fn_name</code>字段除了函数名外还有一段尾巴，比如<code>test_backtrace:F(0,25)</code>，需要将”:F(0,25)”去掉，可以使用<code>printf(&quot;%.*s&quot;, length, string)</code>来实现。代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mon_backtrace</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, struct Trapframe *tf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> *ebp;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Eipdebuginfo</span> <span class="title">info</span>;</span></span><br><span class="line">    <span class="keyword">int</span> result;</span><br><span class="line">    ebp = (<span class="keyword">uint32_t</span> *)read_ebp();</span><br><span class="line"></span><br><span class="line">    cprintf(<span class="string">"Stack backtrace:\r\n"</span>);</span><br><span class="line">    <span class="keyword">while</span> (ebp)</span><br><span class="line">    &#123;</span><br><span class="line">        cprintf(<span class="string">"  ebp %08x  eip %08x  args %08x %08x %08x %08x %08x\r\n"</span>, ebp, ebp[<span class="number">1</span>], ebp[<span class="number">2</span>], ebp[<span class="number">3</span>], ebp[<span class="number">4</span>], ebp[<span class="number">5</span>], ebp[<span class="number">6</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(&amp;info, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct Eipdebuginfo));</span><br><span class="line"></span><br><span class="line">        result = debuginfo_eip(ebp[<span class="number">1</span>], &amp;info);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> != result)</span><br><span class="line">            cprintf(<span class="string">"failed to get debuginfo for eip %x.\r\n"</span>, ebp[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cprintf(<span class="string">"\t%s:%d: %.*s+%u\r\n"</span>, info.eip_file, info.eip_line, info.eip_fn_namelen, info.eip_fn_name, ebp[<span class="number">1</span>] - info.eip_fn_addr);</span><br><span class="line">        ebp = (<span class="keyword">uint32_t</span> *)*ebp;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果如下：<br><code>Stack backtrace:
  ebp f010ff18  eip f0100078  args 00000000 00000000 00000000 f010004a f0111308
        kern/init.c:16: test_backtrace+56
  ebp f010ff38  eip f01000a1  args 00000000 00000001 f010ff78 f010004a f0111308
        kern/init.c:16: test_backtrace+97
  ebp f010ff58  eip f01000a1  args 00000001 00000002 f010ff98 f010004a f0111308
        kern/init.c:16: test_backtrace+97
  ebp f010ff78  eip f01000a1  args 00000002 00000003 f010ffb8 f010004a f0111308
        kern/init.c:16: test_backtrace+97
  ebp f010ff98  eip f01000a1  args 00000003 00000004 00000000 f010004a f0111308
        kern/init.c:16: test_backtrace+97
  ebp f010ffb8  eip f01000a1  args 00000004 00000005 00000000 f010004a f0111308
        kern/init.c:16: test_backtrace+97
  ebp f010ffd8  eip f01000dd  args 00000005 00001aac f010fff8 f01000bd 00000000
        kern/init.c:43: i386_init+55
  ebp f010fff8  eip f010003e  args 00000003 00001003 00002003 00003003 00004003
        {standard input}:0: &lt;unknown&gt;+0</code>:q</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/操作系统/" rel="tag"># 操作系统</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/11/15/深入浅出分析LSM树/" rel="next" title="深入浅出分析LSM树（日志结构合并树）">
                <i class="fa fa-chevron-left"></i> 深入浅出分析LSM树（日志结构合并树）
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/11/16/6.828-lab2/" rel="prev" title="6.828 lab2">
                6.828 lab2 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/header.jpg" alt="Hao Yu">
            
              <p class="site-author-name" itemprop="name">Hao Yu</p>
              <p class="site-description motion-element" itemprop="description">Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author</p>
          </div>
          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">291</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>
        	<audio controls="controls" loop="loop" preload="auto" src="/resource/xiaomeihao.mp3">
	        </audio>
	

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yuhao0102" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:yuh18@mails.tsinghua.edu.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#实验分为三个部分："><span class="nav-number">1.</span> <span class="nav-text">实验分为三个部分：</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MIT6-828-实验环境配置"><span class="nav-number">2.</span> <span class="nav-text">MIT6.828 实验环境配置</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Part-2-The-Boot-Loader"><span class="nav-number">3.</span> <span class="nav-text">Part 2: The Boot Loader</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#boot-S"><span class="nav-number">3.1.</span> <span class="nav-text">boot.S</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#调试boot-S"><span class="nav-number">3.2.</span> <span class="nav-text">调试boot.S</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#加载内核"><span class="nav-number">4.</span> <span class="nav-text">加载内核</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Part3：The-Kernel"><span class="nav-number">5.</span> <span class="nav-text">Part3：The Kernel</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#使用虚拟内存来解决位置依赖问题"><span class="nav-number">5.1.</span> <span class="nav-text">使用虚拟内存来解决位置依赖问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Exercise-7"><span class="nav-number">5.2.</span> <span class="nav-text">Exercise 7</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#格式化输出到控制台"><span class="nav-number">5.3.</span> <span class="nav-text">格式化输出到控制台</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Exercise-8"><span class="nav-number">5.4.</span> <span class="nav-text">Exercise 8</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#初始化"><span class="nav-number">5.5.</span> <span class="nav-text">初始化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#栈的行为"><span class="nav-number">5.6.</span> <span class="nav-text">栈的行为</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#调用函数"><span class="nav-number">5.7.</span> <span class="nav-text">调用函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数返回"><span class="nav-number">5.8.</span> <span class="nav-text">函数返回</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Exercise-10"><span class="nav-number">5.9.</span> <span class="nav-text">Exercise 10</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#观察test-backtrace函数调用栈"><span class="nav-number">5.10.</span> <span class="nav-text">观察test_backtrace函数调用栈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实现backtrace"><span class="nav-number">5.11.</span> <span class="nav-text">实现backtrace</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#读取Symbol-Table"><span class="nav-number">5.12.</span> <span class="nav-text">读取Symbol Table</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#debuginfo-eip函数实现根据地址寻找行号的功能"><span class="nav-number">5.13.</span> <span class="nav-text">debuginfo_eip函数实现根据地址寻找行号的功能</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#给内核模拟器增加backtrace命令，并在mon-backtrace中增加打印文件名、函数名和行号"><span class="nav-number">5.14.</span> <span class="nav-text">给内核模拟器增加backtrace命令，并在mon_backtrace中增加打印文件名、函数名和行号</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#在mon-backtrace中增加打印文件名、函数名和行号"><span class="nav-number">5.15.</span> <span class="nav-text">在mon_backtrace中增加打印文件名、函数名和行号</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>
  <div id="DvelopmentTarget">     
  </div>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart" aria-hidden="false"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>

  
</div>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_uv"> 
  本站访客数<span id="busuanzi_value_site_uv"></span>人次
</span>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  


  

  


  <script type="text/javascript" src="/js/src/love.js"></script>

</body>
</html>
