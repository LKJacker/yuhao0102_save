<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zn-ch">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-center-simple.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="操作系统,">










<meta name="description" content="Introduction在这次lab中，您将实现spawn，这是一个加载和运行磁盘可执行文件的库调用。然后，您将充实kernel和库操作系统，以在控制台上运行Shell。 文件系统初步JOS文件系统设计相比Linux等系统的文件系统如ext2，ext3等，要简化不少。它不支持用户和权限特性，也不支持硬链接，符号链接，时间戳以及特殊设备文件等。 磁盘文件系统结构大部分Unix文件系统会将磁盘空间分为">
<meta name="keywords" content="操作系统">
<meta property="og:type" content="article">
<meta property="og:title" content="6.828 lab5">
<meta property="og:url" content="http://yoursite.com/2021/11/16/6.828-lab5/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="Introduction在这次lab中，您将实现spawn，这是一个加载和运行磁盘可执行文件的库调用。然后，您将充实kernel和库操作系统，以在控制台上运行Shell。 文件系统初步JOS文件系统设计相比Linux等系统的文件系统如ext2，ext3等，要简化不少。它不支持用户和权限特性，也不支持硬链接，符号链接，时间戳以及特殊设备文件等。 磁盘文件系统结构大部分Unix文件系统会将磁盘空间分为">
<meta property="og:locale" content="zn-ch">
<meta property="og:image" content="http://yoursite.com/img/20211128114300.png">
<meta property="og:image" content="http://yoursite.com/img/20211128114301.png">
<meta property="og:image" content="http://yoursite.com/img/20211128114305.png">
<meta property="og:updated_time" content="2021-12-01T08:27:10.368Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="6.828 lab5">
<meta name="twitter:description" content="Introduction在这次lab中，您将实现spawn，这是一个加载和运行磁盘可执行文件的库调用。然后，您将充实kernel和库操作系统，以在控制台上运行Shell。 文件系统初步JOS文件系统设计相比Linux等系统的文件系统如ext2，ext3等，要简化不少。它不支持用户和权限特性，也不支持硬链接，符号链接，时间戳以及特殊设备文件等。 磁盘文件系统结构大部分Unix文件系统会将磁盘空间分为">
<meta name="twitter:image" content="http://yoursite.com/img/20211128114300.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2021/11/16/6.828-lab5/">





  <title>6.828 lab5 | Hao Yu's blog</title>
  








 
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zn-ch">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hao Yu's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">The program monkey was eaten by the siege lion.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/resume.pdf" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-mybetterhalf">
          <a href="/mybetterhalf/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>
            
            mybetterhalf
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/11/16/6.828-lab5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">6.828 lab5</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-11-16T19:28:00+08:00">
                2021-11-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>在这次lab中，您将实现spawn，这是一个加载和运行磁盘可执行文件的库调用。然后，您将充实kernel和库操作系统，以在控制台上运行Shell。</p>
<h1 id="文件系统初步"><a href="#文件系统初步" class="headerlink" title="文件系统初步"></a>文件系统初步</h1><p>JOS文件系统设计相比Linux等系统的文件系统如ext2，ext3等，要简化不少。它不支持用户和权限特性，也不支持硬链接，符号链接，时间戳以及特殊设备文件等。</p>
<h2 id="磁盘文件系统结构"><a href="#磁盘文件系统结构" class="headerlink" title="磁盘文件系统结构"></a>磁盘文件系统结构</h2><p>大部分Unix文件系统会将磁盘空间分为inode和data两个部分，如linux就是这样的，其中inode用于存储文件的元数据，比如文件类型(常规、目录、符号链接等），权限，文件大小，创建/修改/访问时间，文件数据块信息等，我们运行的<code>ls -l</code>看到的内容，都是存储在inode而不是数据块中的。数据部分通常分为很多数据块，数据块用于存储文件的数据信息以及目录的元数据(目录元数据包括目录下文件的inode，文件名，文件类型等)。</p>
<p>文件和目录在逻辑上都由一系列数据块组成，这些数据块可能分散在整个磁盘中，就像虚拟地址空间的页面可以分散在整个物理内存中一样。文件系统环境隐藏了块布局的细节，提供了用于读取和写入文件内任意偏移量的字节序列的接口。文件系统环境在内部处理对目录的所有修改，作为执行文件创建和删除等操作的一部分。我们的文件系统允许用户环境直接读取目录元数据（例如，使用 read），这意味着用户环境可以自己执行目录扫描操作（例如，实现 ls 程序），而不必依赖到文件系统的特殊系统调用。这种目录扫描方法的缺点，也是大多数现代 UNIX 变体不鼓励它的原因，是它使应用程序依赖于目录元数据的格式，从而很难在不改变或至少改变文件系统的内部布局的情况下重新编译应用程序。</p>
<h2 id="磁盘扇区、数据块"><a href="#磁盘扇区、数据块" class="headerlink" title="磁盘扇区、数据块"></a>磁盘扇区、数据块</h2><p>扇区是磁盘的物理属性，通常一个扇区大小为512字节，而数据块则是操作系统使用磁盘的一个逻辑属性，一个块大小通常是扇区的整数倍，在JOS中一个扇区是512Bytes，一个块大小为4KB，跟我们物理内存的页大小一致。UNIX xv6 文件系统使用 512 字节的块大小，与底层磁盘的扇区大小相同。然而，大多数现代文件系统使用更大的块大小，因为存储空间变得更便宜，并且以更大的粒度管理存储更有效。我们的文件系统将使用 4096 字节的块大小，方便地匹配处理器的页面大小。</p>
<p>文件系统实际上以块为单位分配和使用磁盘存储。注意这两个术语之间的区别：扇区大小是磁盘硬件的属性，而块大小是使用磁盘的操作系统的一个方面。文件系统的块大小必须是底层磁盘扇区大小的倍数。</p>
<h2 id="超级块"><a href="#超级块" class="headerlink" title="超级块"></a>超级块</h2><p>文件系统通常在磁盘上“易于查找”的位置（例如开头或结尾）保留某些磁盘块，以保存描述整个文件系统属性的元数据，例如块大小、磁盘大小、查找根目录所需的任何元数据、文件系统上次挂载的时间、文件系统上次检查错误的时间等。这些特殊块被称为超级块。</p>
<p>我们的文件系统将只有一个超级块，它始终位于磁盘上的块 1。它的布局由<code>inc/fs.h</code>中的<code>struct Super</code>定义。块 0 通常保留用于保存引导加载程序和分区表，因此文件系统通常不使用第一个磁盘块。许多“真正的”文件系统维护多个超级块，在磁盘的多个间隔很宽的区域中复制，因此如果其中一个被损坏或磁盘在该区域出现介质错误，则仍然可以找到其他超级块并用于访问文件系统。</p>
<h2 id="文件元数据"><a href="#文件元数据" class="headerlink" title="文件元数据"></a>文件元数据</h2><p>在我们的文件系统中描述文件的元数据的布局由<code>inc/fs.h</code>中的<code>struct File</code>描述。此元数据包括文件的名称、大小、类型（常规文件或目录）以及指向组成文件的块的指针。如上所述，我们没有<code>inode</code>，因此此元数据存储在磁盘上的目录条目中。与大多数“真实”文件系统不同，为简单起见，我们将使用这种文件结构来表示文件元数据，因为它同时出现在磁盘和内存中。</p>
<p><img src="/img/20211128114300.png" alt></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Super</span> &#123;</span></span><br><span class="line">        <span class="keyword">uint32_t</span> s_magic;               <span class="comment">// Magic number: FS_MAGIC</span></span><br><span class="line">        <span class="keyword">uint32_t</span> s_nblocks;             <span class="comment">// Total number of blocks on disk</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">File</span> <span class="title">s_root</span>;</span>             <span class="comment">// Root directory node</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>struct File</code>中的<code>f_direct</code>数组包含空间来存储文件的前 10 个（NDIRECT）块的块号，我们称之为文件的直接块。对于大小不超过<code>10*4096 = 40KB</code>的小文件，这意味着所有文件块的块号将直接适合文件结构本身。然而，对于较大的文件，我们需要一个地方来保存文件的其余块编号。因此，对于任何大于 40KB 的文件，我们分配一个额外的磁盘块，称为文件的间接块，以容纳多达<code>4096/4 = 1024</code>个额外的块号。因此，我们的文件系统允许文件最大为 1034 个块，或略高于 4 兆字节。为了支持更大的文件，“真正的”文件系统通常也支持双重和三重间接块。</p>
<p><img src="/img/20211128114301.png" alt></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">File</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> f_name[MAXNAMELEN];    <span class="comment">// filename</span></span><br><span class="line">    <span class="keyword">off_t</span> f_size;           <span class="comment">// file size in bytes</span></span><br><span class="line">    <span class="keyword">uint32_t</span> f_type;        <span class="comment">// file type</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Block pointers.</span></span><br><span class="line">    <span class="comment">// A block is allocated iff its value is != 0.</span></span><br><span class="line">    <span class="keyword">uint32_t</span> f_direct[NDIRECT]; <span class="comment">// direct blocks</span></span><br><span class="line">    <span class="keyword">uint32_t</span> f_indirect;        <span class="comment">// indirect block</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Pad out to 256 bytes; must do arithmetic in case we're compiling</span></span><br><span class="line">    <span class="comment">// fsformat on a 64-bit machine.</span></span><br><span class="line">    <span class="keyword">uint8_t</span> f_pad[<span class="number">256</span> - MAXNAMELEN - <span class="number">8</span> - <span class="number">4</span>*NDIRECT - <span class="number">4</span>];</span><br><span class="line">&#125; __attribute__((packed));  <span class="comment">// required only on some 64-bit machines</span></span><br></pre></td></tr></table></figure>
<h2 id="目录与常规文件"><a href="#目录与常规文件" class="headerlink" title="目录与常规文件"></a>目录与常规文件</h2><p>我们文件系统中的 File 结构可以表示一个普通文件或一个目录； 这两种类型的“文件”通过文件结构中的类型字段来区分。文件系统以完全相同的方式管理常规文件和目录文件，除了它根本不解释与常规文件关联的数据块的内容，而文件系统将目录文件的内容解释为一系列 描述目录中的文件和子目录的文件结构。</p>
<p>我们文件系统中的超级块包含一个文件结构（结构 Super 中的根字段），它保存文件系统根目录的元数据。该目录文件的内容是描述位于文件系统根目录中的文件和目录的文件结构序列。根目录中的任何子目录又可能包含更多表示子子目录的文件结构，依此类推。</p>
<h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><h2 id="Disk-Access"><a href="#Disk-Access" class="headerlink" title="Disk Access"></a>Disk Access</h2><p>操作系统中的文件系统环境需要能够访问磁盘，但是我们还没有在内核中实现任何磁盘访问功能。我们没有采用传统的“单片”操作系统策略，即在内核中添加IDE磁盘驱动程序以及允许文件系统访问它的必要的系统调用，而是将IDE磁盘驱动程序实现为用户级文件系统环境的一部分。我们仍然需要稍微修改内核，以便进行设置，使文件系统环境具有实现磁盘访问本身所需的特权。</p>
<p>只要我们依赖于polling(轮询)、基于“programmed I/O”(PIO)的磁盘访问，并且不使用磁盘中断，就很容易在用户空间中实现磁盘访问。也可以在用户模式下实现中断驱动的设备驱动程序(例如，L3和L4内核是这样做的)，但是难度更大，因为内核必须实现设备中断并将它们分派到正确的用户模式环境中。</p>
<p>x86处理器使用EFLAGS寄存器中的IOPL位来确定是否允许保护模式代码执行特殊的设备I/O指令，比如IN和OUT指令。由于我们需要访问的所有IDE磁盘寄存器都位于x86的I/O空间中，而不是内存映射，所以为了允许文件系统访问这些寄存器，我们只需要给文件系统环境提供“I/O privilege”。实际上，EFLAGS寄存器中的IOPL位为内核提供了一个简单的“all-or-nothing”(全有或全无)方法来控制用户模式代码是否可以访问I/O空间。在我们的示例中，我们希望文件系统environment能够访问I/O空间，但是我们根本不希望任何其他environment能够访问I/O空间。</p>
<p>Exercise 1. <code>i386_init</code>通过将类型<code>ENV_TYPE_FS</code>传递给环境创建函数<code>env_create</code>来标识文件系统环境。在<code>env.c</code>中修改<code>env_create</code>，以便它赋予文件系统environment I/O特权，但永远不要将该特权授予任何其他环境。</p>
<p>这个地方代码还是比较简单的，毕竟之前为用户环境开中断也是设置的<code>eflags</code>的<code>FL_IF</code>位，这里就是设置<code>eflags</code>的<code>IOPL</code>位<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">env_create(<span class="keyword">uint8_t</span> *binary, <span class="keyword">size_t</span> size, <span class="keyword">enum</span> EnvType type)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span>;</span></span><br><span class="line">        <span class="keyword">int</span> result = env_alloc(&amp;env, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(result &lt; <span class="number">0</span>)</span><br><span class="line">                panic(<span class="string">"env_create: env_alloc error"</span>);</span><br><span class="line">        load_icode(env, binary, size);</span><br><span class="line">        env-&gt;env_type = type;</span><br><span class="line">        <span class="comment">// If this is the file server (type == ENV_TYPE_FS) give it I/O privileges.</span></span><br><span class="line">        <span class="comment">// LAB 5: Your code here.</span></span><br><span class="line">        <span class="keyword">if</span> (type == ENV_TYPE_FS)</span><br><span class="line">                env-&gt;env_tf.tf_eflags |= FL_IOPL_MASK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Question1.当您随后从一种environment切换到另一种environment时，是否还需要执行其他操作以确保正确保存和恢复此I/O特权设置？ 为什么？</p>
<p>answer：这肯定是不用的，每次切换进程都会保存上下文，切回来的时候恢复上下文。</p>
<h2 id="The-Block-Cache"><a href="#The-Block-Cache" class="headerlink" title="The Block Cache"></a>The Block Cache</h2><p>在我们的文件系统中，我们将借助处理器的虚拟内存系统实现一个简单的“buffer cache”（实际上只是一个block cache）。 block cache的代码在<code>fs/bc.c</code>中。（这里其实就暗示了文件系统读写的单位是一个block而不是扇区）。</p>
<p>我们的文件系统将仅限于处理3GB或更小的磁盘。我们保留文件系统environment的地址空间的一个大的、固定的3GB区域，从<code>0x10000000</code> (<code>DISKMAP</code>)到<code>0xD0000000</code>(<code>DISKMAP+DISKMAX</code>)，作为磁盘的“内存映射”版本。例如，disk block 0映射到虚拟地址<code>0x10000000</code>，disk block 1映射到虚拟地址<code>0x10001000</code>(一个块4KB)，以此类推。<code>fs/bc.c</code>中的<code>diskaddr</code>函数实现了从 disk block numbers到虚拟地址的转换(以及一些完整性(sanity)检查)。</p>
<p>由于我们的文件系统environment具有自己的虚拟地址空间，而与系统中其他environment的虚拟地址空间无关，并且文件系统environment唯一需要做的就是实现文件访问，因此我们以这种方式保留大多数文件系统environment的地址空间。 由于现代磁盘大于3GB，因此在32位计算机上执行真实文件系统会很尴尬。 在具有64位地址空间的机器上，这种buffer cache管理方法仍然是合理的。</p>
<p>当然，将整个磁盘读取到内存中要花很长时间，所以我们以请求分页(demand paging)的形式实现，其中我们只在磁盘映射区域分配页和从磁盘读取相应的块来响应一个在这个地区发生的页面错误。</p>
<p><code>ide_read()</code>的单位是扇区，不是磁盘块，通过<code>outb</code>指令设置读取的扇区数，通过<code>insl</code>指令读取磁盘数据到对应的虚拟地址<code>addr</code>处。<code>bc_pgfault</code>中分配了一页物理页，然后从磁盘中读取出错的addr那一块数据(8个扇区）到分配的物理页中，然后清除分配页的dirty标记，最后调用<code>block_is_free</code>检查对应磁盘块确保磁盘块已经分配。注意这里检查磁盘块是否已经分配要在最后检查，是因为<code>bitmap</code>的值是在<code>fs_init</code>时指定的为<code>diskaddr(2)</code>，即<code>0x10002000</code>，在准备读取第二个磁盘块发生页错误进入<code>bgfault</code>时，此时<code>bitmap</code>对应块还没有从磁盘读取并映射好，所以要在最后检查。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">ide_read(<span class="keyword">uint32_t</span> secno, <span class="keyword">void</span> *dst, <span class="keyword">size_t</span> nsecs)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">int</span> r;</span><br><span class="line"></span><br><span class="line">        assert(nsecs &lt;= <span class="number">256</span>);</span><br><span class="line"></span><br><span class="line">        ide_wait_ready(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        outb(<span class="number">0x1F2</span>, nsecs);</span><br><span class="line">        outb(<span class="number">0x1F3</span>, secno &amp; <span class="number">0xFF</span>);</span><br><span class="line">        outb(<span class="number">0x1F4</span>, (secno &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>);</span><br><span class="line">        outb(<span class="number">0x1F5</span>, (secno &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFF</span>);</span><br><span class="line">        outb(<span class="number">0x1F6</span>, <span class="number">0xE0</span> | ((diskno&amp;<span class="number">1</span>)&lt;&lt;<span class="number">4</span>) | ((secno&gt;&gt;<span class="number">24</span>)&amp;<span class="number">0x0F</span>));</span><br><span class="line">        outb(<span class="number">0x1F7</span>, <span class="number">0x20</span>);      <span class="comment">// CMD 0x20 means read sector</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (; nsecs &gt; <span class="number">0</span>; nsecs--, dst += SECTSIZE) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((r = ide_wait_ready(<span class="number">1</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">return</span> r;</span><br><span class="line">                insl(<span class="number">0x1F0</span>, dst, SECTSIZE/<span class="number">4</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>fs/fs.c</code>中的<code>fs_init</code>函数是如何使用<code>block cache</code>的一个主要示例。在初始化块缓存之后，它简单将指向块缓存的指针存储到<code>super</code>全局变量中的磁盘映射区域。在这之后，我们可以简单地从<code>super structure</code>中读取，就像它们在内存中一样，并且我们的页面错误处理程序将根据需要从磁盘中读取它们。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Initialize the file system</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">fs_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">static_assert</span>(<span class="keyword">sizeof</span>(struct File) == <span class="number">256</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Find a JOS disk.  Use the second IDE disk (number 1) if available.</span></span><br><span class="line">        <span class="keyword">if</span> (ide_probe_disk1())</span><br><span class="line">                ide_set_disk(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                ide_set_disk(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        bc_init();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set "super" to point to the super block.</span></span><br><span class="line">        super = diskaddr(<span class="number">1</span>);</span><br><span class="line">        check_super();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Exercise 2. 在<code>fs/bc.c</code>中实现<code>bc_pgfault</code>和<code>flush_block</code>函数。<code>bc_pgfault</code>是一个页面错误处理程序，就像您在上一个lab中为copy-on-write fork的写的页面处理程序一样，不同之处在于<code>bc_pgfault</code>的工作是响应页面错误从磁盘加载页面。 编写此代码时，请记住，<code>addr</code>可能未与<code>block</code>对齐，并且<code>ide_read</code>在扇区而不是<code>block</code>中操作。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Fault any disk block that is read in to memory by</span></span><br><span class="line"><span class="comment">// loading it from disk.只说从disk又不说disk哪个扇区</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">bc_pgfault(struct UTrapframe *utf)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">void</span> *addr = (<span class="keyword">void</span> *) utf-&gt;utf_fault_va;</span><br><span class="line">	<span class="keyword">uint32_t</span> blockno = ((<span class="keyword">uint32_t</span>)addr - DISKMAP) / BLKSIZE;</span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Check that the fault was within the block cache region</span></span><br><span class="line">	<span class="keyword">if</span> (addr &lt; (<span class="keyword">void</span>*)DISKMAP || addr &gt;= (<span class="keyword">void</span>*)(DISKMAP + DISKSIZE))</span><br><span class="line">		panic(<span class="string">"page fault in FS: eip %08x, va %08x, err %04x"</span>,</span><br><span class="line">		      utf-&gt;utf_eip, addr, utf-&gt;utf_err);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Sanity check the block number.</span></span><br><span class="line">	<span class="keyword">if</span> (super &amp;&amp; blockno &gt;= super-&gt;s_nblocks)</span><br><span class="line">		panic(<span class="string">"reading non-existent block %08x\n"</span>, blockno);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Allocate a page in the disk map region, read the contents</span></span><br><span class="line">	<span class="comment">// of the block from the disk into that page.</span></span><br><span class="line">	<span class="comment">// Hint: first round addr to page boundary. fs/ide.c has code to read</span></span><br><span class="line">	<span class="comment">// the disk.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// LAB 5: you code here:</span></span><br><span class="line">	addr = (<span class="keyword">void</span> *)ROUNDDOWN(addr, BLKSIZE);</span><br><span class="line">	<span class="keyword">if</span>((r=sys_page_alloc(<span class="number">0</span>, addr, PTE_P | PTE_U | PTE_W))&lt;<span class="number">0</span>)</span><br><span class="line">		panic(<span class="string">"in bc_pgfault,out of memory: %e"</span>, r);</span><br><span class="line">	<span class="keyword">if</span>((r=ide_read(blockno*<span class="number">8</span>, addr, BLKSECTS))&lt;<span class="number">0</span>)</span><br><span class="line">		panic(<span class="string">"in bc_pgfault, ide_read: %e"</span>, r);</span><br><span class="line">	<span class="comment">// Clear the dirty bit for the disk block page since we just read the</span></span><br><span class="line">	<span class="comment">// block from disk</span></span><br><span class="line">	<span class="keyword">if</span> ((r = sys_page_map(<span class="number">0</span>, addr, <span class="number">0</span>, addr, uvpt[PGNUM(addr)] &amp; PTE_SYSCALL)) &lt; <span class="number">0</span>)</span><br><span class="line">		panic(<span class="string">"in bc_pgfault, sys_page_map: %e"</span>, r);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Check that the block we read was allocated. (exercise for</span></span><br><span class="line">	<span class="comment">// the reader: why do we do this *after* reading the block</span></span><br><span class="line">	<span class="comment">// in?)</span></span><br><span class="line">	<span class="keyword">if</span> (bitmap &amp;&amp; block_is_free(blockno))</span><br><span class="line">		panic(<span class="string">"reading free block %08x\n"</span>, blockno);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>flush_block()</code>函数用于在写入磁盘数据到块缓存后，调用<code>ide_write()</code>写入块缓存数据到磁盘中。写入完成后，也要通过<code>sys_page_map()</code>清除块缓存的<code>dirty</code>标记(每次写入物理页的时候，处理器会自动标记该页为<code>dirty</code>，即设置<code>PTE_D</code>标记)。注意，在<code>flush_block()</code>中，如果该地址并没有映射或者并没有<code>dirty</code>，则不需要做任何事情。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Flush the contents of the block containing VA out to disk if</span></span><br><span class="line"><span class="comment">// necessary, then clear the PTE_D bit using sys_page_map.</span></span><br><span class="line"><span class="comment">// If the block is not in the block cache or is not dirty, does</span></span><br><span class="line"><span class="comment">// nothing.</span></span><br><span class="line"><span class="comment">// Hint: Use va_is_mapped, va_is_dirty, and ide_write.</span></span><br><span class="line"><span class="comment">// Hint: Use the PTE_SYSCALL constant when calling sys_page_map.</span></span><br><span class="line"><span class="comment">// Hint: Don't forget to round addr down.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">flush_block(<span class="keyword">void</span> *addr)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> blockno = ((<span class="keyword">uint32_t</span>)addr - DISKMAP) / BLKSIZE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (addr &lt; (<span class="keyword">void</span>*)DISKMAP || addr &gt;= (<span class="keyword">void</span>*)(DISKMAP + DISKSIZE))</span><br><span class="line">        panic(<span class="string">"flush_block of bad va %08x"</span>, addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="comment">// LAB 5: Your code here.</span></span><br><span class="line">    addr = ROUNDDOWN(addr, BLKSIZE);</span><br><span class="line">    <span class="keyword">if</span> (va_is_mapped(addr) &amp;&amp; va_is_dirty(addr)) &#123;</span><br><span class="line">        ide_write(blockno*BLKSECTS, addr, BLKSECTS);</span><br><span class="line">        <span class="keyword">if</span> ((r = sys_page_map(<span class="number">0</span>, addr, <span class="number">0</span>, addr, uvpt[PGNUM(addr)]&amp;PTE_SYSCALL)) &lt; <span class="number">0</span>)</span><br><span class="line">            panic(<span class="string">"in flush_block, sys_page_map: %e"</span>, r);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>bc.c</code>中的<code>bc_init</code>用于完成块缓存初始化，它完成下面几件事：</p>
<ol>
<li>设置页错误处理函数为<code>bc_pgfault</code>。</li>
<li>调用check_bc()。</li>
<li>读取磁盘块1的数据到函数局部变量super对应的地址中。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">bc_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Super</span> <span class="title">super</span>;</span></span><br><span class="line">        set_pgfault_handler(bc_pgfault);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// cache the super block by reading it once</span></span><br><span class="line">        memmove(&amp;super, diskaddr(<span class="number">1</span>), <span class="keyword">sizeof</span> super);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="块位图"><a href="#块位图" class="headerlink" title="块位图"></a>块位图</h2><p>在<code>fs_init</code>设置<code>bitmap</code>指针后，可以认为<code>bitmap</code>就是一个位数组，每个块占据一位。可以通过<code>block_is_free</code>检查块位图中的对应块是否空闲，如果为1表示空闲，为0已经使用。JOS中第0，1，2块分别给<code>bootloader</code>，<code>superblock</code>以及<code>bitmap</code>使用了。此外，因为在文件系统中加入了<code>user</code>目录和<code>fs</code>目录的文件，导致JOS文件系统一共用掉了0-110这111个文件块，下一个空闲文件块从111开始。</p>
<p>使用<code>free_block</code>作为模型在<code>fs/fs.c</code>中实现<code>alloc_block</code>。它应该在位图中找到一个空闲磁盘块，标记它该磁盘块已被使用，并返回该磁盘块号。当您分配一个块时，您应该立即使用<code>flush_block</code>将更改后的位图块刷新到磁盘，以保持文件系统的一致性。</p>
<p>使用位图标记一个块是否被使用过。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Mark a block free in the bitmap</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">free_block(<span class="keyword">uint32_t</span> blockno)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Blockno zero is the null pointer of block numbers.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 0 块启动块</span></span><br><span class="line">	<span class="keyword">if</span> (blockno == <span class="number">0</span>)</span><br><span class="line">		panic(<span class="string">"attempt to free zero block"</span>);</span><br><span class="line">	bitmap[blockno/<span class="number">32</span>] |= <span class="number">1</span>&lt;&lt;(blockno%<span class="number">32</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Search the bitmap for a free block and allocate it.  When you</span></span><br><span class="line"><span class="comment">// allocate a block, immediately flush the changed bitmap block</span></span><br><span class="line"><span class="comment">// to disk.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Return block number allocated on success,</span></span><br><span class="line"><span class="comment">// -E_NO_DISK if we are out of blocks.</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">alloc_block(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// The bitmap consists of one or more blocks.  A single bitmap block</span></span><br><span class="line">	<span class="comment">// contains the in-use bits for BLKBITSIZE blocks.  There are</span></span><br><span class="line">	<span class="comment">// super-&gt;s_nblocks blocks in the disk altogether.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// LAB 5: Your code here.</span></span><br><span class="line">	<span class="keyword">size_t</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>; i &lt; super-&gt;s_nblocks; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (block_is_free(i)) &#123;</span><br><span class="line">			bitmap[i/<span class="number">32</span>] &amp;=  ~(<span class="number">1</span>&lt;&lt;(i%<span class="number">32</span>));</span><br><span class="line">            <span class="comment">// 或者</span></span><br><span class="line">            <span class="comment">// bitmap[blockno/32] ^= 1&lt;&lt;(blockno%32);</span></span><br><span class="line">			flush_block(&amp;bitmap[i/<span class="number">32</span>]);</span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// panic("alloc_block not implemented");</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> -E_NO_DISK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><p>在<code>fs/fs.c</code>中有很多文件操作相关的函数，这里的主要几个结构体要说明下：</p>
<ul>
<li><code>struct File</code>用于存储文件元数据，前面提到过。</li>
<li><code>struct Fd</code>用于文件模拟层，类似文件描述符，如文件ID，文件打开模式，文件偏移都存储在Fd中。一个进程同时最多打开 MAXFD(32) 个文件。</li>
</ul>
<p>文件系统进程还维护了一个打开文件的描述符表，即<code>opentab</code>数组，数组元素为<code>struct OpenFile</code>。<code>OpenFile</code>结构体用于存储打开文件信息，包括文件<code>ID</code>，<code>struct File</code>以及<code>struct Fd</code>。JOS同时打开的文件数一共为 MAXOPEN(1024) 个。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">OpenFile</span> &#123;</span>                                                              </span><br><span class="line">    <span class="keyword">uint32_t</span> o_fileid;  <span class="comment">// file id                                             </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">o_file</span>;</span>    <span class="comment">// mapped descriptor for open file                 </span></span><br><span class="line">    <span class="keyword">int</span> o_mode;     <span class="comment">// open mode                                               </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> *<span class="title">o_fd</span>;</span>    <span class="comment">// Fd page                                             </span></span><br><span class="line">&#125;;    </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> fd_dev_id;</span><br><span class="line">    <span class="keyword">off_t</span> fd_offset;</span><br><span class="line">    <span class="keyword">int</span> fd_omode;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="comment">// File server files</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">FdFile</span> <span class="title">fd_file</span>;</span></span><br><span class="line">    &#125;;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>文件操作函数如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file_block_walk(struct File *f, <span class="keyword">uint32_t</span> filebno, <span class="keyword">uint32_t</span> **ppdiskbno, <span class="keyword">bool</span> alloc)</span><br></pre></td></tr></table></figure></p>
<p>这个函数是查找文件第<code>filebno</code>块的数据块的地址，查到的地址存储在<code>ppdiskbno</code>中。注意这里要检查间接块，如果alloc为1且寻址的块号<code>&gt;=NDIRECT</code>，而间接块没有分配的话需要分配一个间接块。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file_get_block(struct File *f, <span class="keyword">uint32_t</span> filebno, <span class="keyword">char</span> **blk)</span><br></pre></td></tr></table></figure>
<p>查找文件第<code>filebno</code>块的块地址，并将块地址在虚拟内存中映射的地址存储在<code>blk</code>中(即将<code>diskaddr(blockno)</code>存到blk中)。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dir_lookup(struct File *dir, <span class="keyword">const</span> <span class="keyword">char</span> *name, struct File **file)</span><br></pre></td></tr></table></figure>
<p>在目录<code>dir</code>中查找名为<code>name</code>的文件，如果找到了设置<code>*file</code>为找到的文件。因为目录的数据块存储的是<code>struct File</code>列表，可以据此来查找文件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file_open(<span class="keyword">const</span> <span class="keyword">char</span> *path, struct File **pf)</span><br></pre></td></tr></table></figure>
<p>打开文件，设置<code>*pf</code>为查找到的文件指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file_create(<span class="keyword">const</span> <span class="keyword">char</span> *path, struct File *pf)</span><br></pre></td></tr></table></figure>
<p>创建路径/文件，在pf存储创建好的文件指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file_read(struct File *f, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count, <span class="keyword">off_t</span> offset)</span><br></pre></td></tr></table></figure>
<p>从文件的<code>offset</code>处开始读取<code>count</code>个字节到<code>buf</code>中，返回实际读取的字节数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file_write(struct File *f, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count, <span class="keyword">off_t</span> offset)</span><br></pre></td></tr></table></figure>
<p>从文件<code>offset</code>处开始写入<code>buf</code>中的<code>count</code>字节，返回实际写入的字节数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file_truncate_blocks(struct File *f, <span class="keyword">off_t</span> newsize);</span><br></pre></td></tr></table></figure>
<p>将文件设置为缩小后的新大小，清空那些被释放的物理块。</p>
<p>Exercise 4：实现<code>file_block_walk</code>函数和<code>file_get_block</code>函数。<br>　　<br>回答：<code>file_block_walk</code>函数寻找一个文件结构<code>f</code>中的第<code>fileno</code>个块指向的磁盘块编号放入<code>ppdiskbno</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">file_block_walk(struct File *f, <span class="keyword">uint32_t</span> filebno, <span class="keyword">uint32_t</span> **ppdiskbno, <span class="keyword">bool</span> alloc)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (filebno &gt;= NDIRECT + NINDIRECT)</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    <span class="keyword">if</span> (filebno &lt; NDIRECT) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ppdiskbno)</span><br><span class="line">            *ppdiskbno = f-&gt;f_direct + filebno;</span><br><span class="line">         <span class="comment">//把f-&gt;f_direct第filebno个槽的地址给它</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!alloc &amp;&amp; !f-&gt;f_indirect)</span><br><span class="line">        <span class="keyword">return</span> -E_NOT_FOUND;</span><br><span class="line">    <span class="keyword">if</span> (!f-&gt;f_indirect) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((r = alloc_block()) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> -E_NO_DISK;</span><br><span class="line">        f-&gt;f_indirect = r;</span><br><span class="line">        <span class="built_in">memset</span>(diskaddr(r), <span class="number">0</span>, BLKSIZE);</span><br><span class="line">        flush_block(diskaddr(r));</span><br><span class="line">        <span class="comment">//每次对磁盘映射区域的块修改后都应该刷新回磁盘</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//捋一下，现在我们要的是存着f第filebno块块号的那个槽的地址</span></span><br><span class="line">	<span class="comment">//即f-&gt;f_indirect与f-&gt;f_direct都是存着块号，而*ppdiskbno要的是存着块号的那个槽的地址</span></span><br><span class="line">	   </span><br><span class="line">    <span class="keyword">if</span> (ppdiskbno)</span><br><span class="line">        *ppdiskbno = (<span class="keyword">uint32_t</span>*)diskaddr(f-&gt;f_indirect) + filebno - NDIRECT;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>file_get_block</code>函数先调用<code>file_walk_block</code>函数找到文件中的目标块，然后将其转换为地址空间中的地址赋值给<code>blk</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">file_get_block(struct File *f, <span class="keyword">uint32_t</span> filebno, <span class="keyword">char</span> **blk)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// LAB 5: Your code here.</span></span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="keyword">uint32_t</span> *ppdiskbno;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((r = file_block_walk(f, filebno, &amp;ppdiskbno, <span class="number">1</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    <span class="comment">//ppdiskbno是f的第filebno块的块号所在的槽的地址</span></span><br><span class="line">	<span class="comment">//blk要的是这个块映射到内存里的地址</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*ppdiskbno == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//就算是直接块也是有可能还未分配</span></span><br><span class="line">        <span class="keyword">if</span> ((r = alloc_block()) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> -E_NO_DISK;</span><br><span class="line">        *ppdiskbno = r;</span><br><span class="line">        <span class="built_in">memset</span>(diskaddr(r), <span class="number">0</span>, BLKSIZE);</span><br><span class="line">        flush_block(diskaddr(r));</span><br><span class="line">        <span class="comment">//每次对磁盘映射区域的块修改后都应该刷新回磁盘</span></span><br><span class="line">    &#125;</span><br><span class="line">    *blk = diskaddr(*ppdiskbno);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="The-file-system-interface"><a href="#The-file-system-interface" class="headerlink" title="The file system interface"></a>The file system interface</h2><p>既然我们已经在文件系统environment本身中拥有了必要的功能，那么我们必须让希望使用文件系统的其他environment也可以访问它。由于其他environment不能直接调用文件系统environment中的函数，所以我们将通过构建在JOS IPC机制之上的remote procedure call(远程过程调用)或者RPC、抽象来公开对文件系统环境的访问。从图形上看，下面是其他environment对 the file system server (比如read)的调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">	  Regular env           FS env</span><br><span class="line">   +---------------+   +---------------+</span><br><span class="line">   |      read     |   |   file_read   |</span><br><span class="line">   |   (lib/fd.c)  |   |   (fs/fs.c)   |</span><br><span class="line">...|.......|.......|...|.......^.......|...............</span><br><span class="line">   |       v       |   |       |       | RPC mechanism</span><br><span class="line">   |  devfile_read |   |  serve_read   |</span><br><span class="line">   |  (lib/file.c) |   |  (fs/serv.c)  |</span><br><span class="line">   |       |       |   |       ^       |</span><br><span class="line">   |       v       |   |       |       |</span><br><span class="line">   |     fsipc     |   |     serve     |</span><br><span class="line">   |  (lib/file.c) |   |  (fs/serv.c)  |</span><br><span class="line">   |       |       |   |       ^       |</span><br><span class="line">   |       v       |   |       |       |</span><br><span class="line">   |   ipc_send    |   |   ipc_recv    |</span><br><span class="line">   |       |       |   |       ^       |</span><br><span class="line">   +-------|-------+   +-------|-------+</span><br><span class="line">           |                   |</span><br><span class="line">           +---------&gt;---------+</span><br></pre></td></tr></table></figure></p>
<p>在虚线下的部分是普通进程如何发送一个读请求到文件系统服务进程的机制。首先<code>read</code>操作文件描述符，分发给合适的设备读函数<code>devfile_read</code>。<code>devfile_read</code>函数实现读取磁盘文件，作为客户端文件操作函数。然后建立请求结构的参数，调用<code>fsipc</code>函数来发送IPC请求并解析返回的结果。</p>
<p>文件系统服务端的代码在<code>fs/serv.c</code>中，服务进程在serve函数中循环，循环等待直到收到1个IPC请求。然后分发给合适的处理函数，最后通过IPC发回结果。对于读请求，服务端会分发给<code>serve_read</code>函数</p>
<p>在JOS实现的IPC机制中，允许进程发送1个32位数和1个页。为了实现发送1个请求从客户端到服务端，我们使用32位数来表示请求类型，存储参数在联合<code>Fsipc</code>位于共享页中。在客户端我们一直共享<code>fsipcbuf</code>所在页，在服务端我们映射请求页到<code>fsreq</code>地址(0x0ffff000)。</p>
<p>服务端也会通过IPC发送结果。我们使用32位数作为函数的返回码。<code>FSREQ_READ</code>和<code>FSREQ_STAT</code>函数也会返回数据，它们将数据写入共享页返回给客户端。不需要在响应 IPC 中发送此页面，因为客户端首先与文件系统服务器共享它。 此外，在其响应中，<code>FSREQ_OPEN</code>与客户端共享一个新的“Fd页面”。 我们将很快返回到文件描述符页面。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> Fsipc &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_open</span> &#123;</span></span><br><span class="line">        <span class="keyword">char</span> req_path[MAXPATHLEN];</span><br><span class="line">        <span class="keyword">int</span> req_omode;</span><br><span class="line">    &#125; open;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_set_size</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> req_fileid;</span><br><span class="line">        <span class="keyword">off_t</span> req_size;</span><br><span class="line">    &#125; set_size;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_read</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> req_fileid;</span><br><span class="line">        <span class="keyword">size_t</span> req_n;</span><br><span class="line">    &#125; read;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Fsret_read</span> &#123;</span></span><br><span class="line">        <span class="keyword">char</span> ret_buf[PGSIZE];</span><br><span class="line">    &#125; readRet;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_write</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> req_fileid;</span><br><span class="line">        <span class="keyword">size_t</span> req_n;</span><br><span class="line">        <span class="keyword">char</span> req_buf[PGSIZE - (<span class="keyword">sizeof</span>(<span class="keyword">int</span>) + <span class="keyword">sizeof</span>(<span class="keyword">size_t</span>))];</span><br><span class="line">    &#125; write;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_stat</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> req_fileid;</span><br><span class="line">    &#125; stat;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Fsret_stat</span> &#123;</span></span><br><span class="line">        <span class="keyword">char</span> ret_name[MAXNAMELEN];</span><br><span class="line">        <span class="keyword">off_t</span> ret_size;</span><br><span class="line">        <span class="keyword">int</span> ret_isdir;</span><br><span class="line">    &#125; statRet;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_flush</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> req_fileid;</span><br><span class="line">    &#125; flush;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_remove</span> &#123;</span></span><br><span class="line">        <span class="keyword">char</span> req_path[MAXPATHLEN];</span><br><span class="line">    &#125; remove;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ensure Fsipc is one page</span></span><br><span class="line">    <span class="keyword">char</span> _pad[PGSIZE];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里需要了解一下<code>union Fsipc</code>，文件系统中客户端和服务端通过IPC进行通信，通信的数据格式就是<code>union Fsipc</code>，它里面的每一个成员对应一种文件系统的操作请求。每次客户端发来请求，都会将参数放入一个<code>union Fsipc</code>映射的物理页到服务端。同时服务端还会将处理后的结果放入到<code>Fsipc</code>内，传递给客户端。文件服务端进行的地址空间布局如下：<br><img src="/img/20211128114305.png" alt></p>
<p><code>OpenFile</code>结构是服务端进程维护的一个映射，它将一个真实文件<code>struct File</code>和用户客户端打开的文件描述符<code>struct Fd</code>对应到一起。每个被打开文件对应的<code>struct Fd</code>都被映射到<code>FILEEVA(0xd0000000)</code>往上的1个物理页，服务端和打开这个文件的客户端进程共享这个物理页。客户端进程和文件系统服务端通信时使用<code>0_fileid</code>来指定要操作的文件。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">OpenFile</span> &#123;</span></span><br><span class="line">        <span class="keyword">uint32_t</span> o_fileid;      <span class="comment">// file id</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">o_file</span>;</span>    <span class="comment">// mapped descriptor for open file</span></span><br><span class="line">        <span class="keyword">int</span> o_mode;             <span class="comment">// open mode</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> *<span class="title">o_fd</span>;</span>        <span class="comment">// Fd page</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>文件系统默认最大同时可以打开的文件个数为1024，所以有1024个<code>strcut Openfile</code>，对应着服务端进程地址空间0xd0000000往上的1024个物理页，用于映射这些对应的<code>struct Fd</code>。</p>
<p><code>struct Fd</code>是1个抽象层，JOS和Linux一样，所有的IO都是文件，所以用户看到的都是<code>Fd</code>代表的文件。但是<code>Fd</code>会记录其对应的具体对象，比如真实文件、Socket和管道等等。现在只用文件，所以union中只有1个<code>FdFile</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> fd_dev_id;</span><br><span class="line">    <span class="keyword">off_t</span> fd_offset;</span><br><span class="line">    <span class="keyword">int</span> fd_omode;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="comment">// File server files</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">FdFile</span> <span class="title">fd_file</span>;</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>Exercise 5.在<code>fs/servlet.c</code>中实现<code>serve_read</code>。<code>serve_read</code>的繁重工作将由<code>fs/fs.c</code>中已经实现的<code>file_read</code>来完成(反过来，它只是对<code>file_get_block</code>的一系列调用)。<code>serve_read</code>只需要提供用于文件读取的RPC接口。查看<code>serve_set_size</code>中的注释和代码，了解应该如何构造<code>server</code>函数。</p>
<p>做这个得弄清楚这些概念:</p>
<ul>
<li><code>regular</code>进程访问文件的整个流程。</li>
<li>在IPC通信过程中，<code>fsipcbuf</code>(客户端)与<code>fsreq</code>(服务端)共享页面。</li>
<li>保存着open file基本信息的<code>Fd page</code>页面(在内存空间0xD0000000以上)</li>
<li>服务端的私有结构体<code>OpenFile</code></li>
<li>设备结构体<code>dev</code>，设备有三种，devfile、devpipe、devcons</li>
<li><code>OpenFile-&gt;o_fileid</code>跟<code>OpenFile-&gt;o_fd-&gt;fd_file.id</code>以及<code>Fsipc-&gt;read-&gt;req_fileid</code>的关系!</li>
</ul>
<p>在<code>devfile_read()</code>里，<code>fsipcbuf.read.req_fileid = fd-&gt;fd_file.id;</code>这是客户端根据在0xD0000000以上的第<code>fdnum</code>个<code>fd page</code>的<code>fd-&gt;fd_file.id</code>告诉服务器端要读的是id为这个的文件。</p>
<p>在<code>serve_open()</code>里，<code>o-&gt;o_fd-&gt;fd_file.id = o-&gt;o_fileid;</code>这是服务器端将open file与它的Fd page对应起来。</p>
<p>首先来看一下整个read的流程<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//inc/fd.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> fd_dev_id;</span><br><span class="line">	<span class="keyword">off_t</span> fd_offset;</span><br><span class="line">	<span class="keyword">int</span> fd_omode;</span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="comment">// File server files</span></span><br><span class="line">		<span class="comment">// 这应该就是目标文件id，在客户端赋值给了fsipcbuf.read.req_fileid</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">FdFile</span> <span class="title">fd_file</span>;</span> <span class="comment">//struct FdFile &#123;int id; &#125;;</span></span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//fs/serv.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">OpenFile</span> &#123;</span> </span><br><span class="line">    <span class="comment">//This memory is kept private to the file server.</span></span><br><span class="line">	<span class="keyword">uint32_t</span> o_fileid;	<span class="comment">// file id。 The client uses file IDs to communicate with the server.</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">o_file</span>;</span>	<span class="comment">// mapped descriptor for open file应该是打开的那个文件的file pointer</span></span><br><span class="line">	<span class="keyword">int</span> o_mode;		<span class="comment">// open mode</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> *<span class="title">o_fd</span>;</span>	<span class="comment">// Fd page是一个专门记录着这个open file的基本信息的页面</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//inc/fs.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">File</span> &#123;</span></span><br><span class="line">	<span class="keyword">char</span> f_name[MAXNAMELEN];	<span class="comment">// filename</span></span><br><span class="line">	<span class="keyword">off_t</span> f_size;			<span class="comment">// file size in bytes</span></span><br><span class="line">	<span class="keyword">uint32_t</span> f_type;		<span class="comment">// file type</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Block pointers.</span></span><br><span class="line">	<span class="comment">// A block is allocated iff its value is != 0.</span></span><br><span class="line">	<span class="comment">// 这里存的是块号还是块的地址？</span></span><br><span class="line">	<span class="keyword">uint32_t</span> f_direct[NDIRECT];	<span class="comment">// direct blocks</span></span><br><span class="line">	<span class="keyword">uint32_t</span> f_indirect;		<span class="comment">// indirect block</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Pad out to 256 bytes; must do arithmetic in case we're compiling</span></span><br><span class="line">	<span class="comment">// fsformat on a 64-bit machine.</span></span><br><span class="line">	<span class="comment">// 扩展到256字节;必须做算术，以防我们在64位机器上编译fsformat。</span></span><br><span class="line">	<span class="keyword">uint8_t</span> f_pad[<span class="number">256</span> - MAXNAMELEN - <span class="number">8</span> - <span class="number">4</span>*NDIRECT - <span class="number">4</span>];</span><br><span class="line">&#125; __attribute__((packed));	<span class="comment">// required only on some 64-bit machines</span></span><br></pre></td></tr></table></figure></p>
<p><code>lib/fd.c/read()</code>根据<code>fdnum</code>在内存空间0xD0000000以上找到一个<code>struct Fd</code>页面命名为<code>fd</code>，页面内保存着一个open file的基本信息。然后根据<code>fd</code>内的<code>fd_dev_id</code>找到对应设备<code>dev</code>，很明显这里是<code>devfile</code>，然后调用<code>(*devfile-&gt;dev_read)(fd, buf, n)</code>。该函数返回读到的字节总数<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> read(<span class="keyword">int</span> fdnum, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Dev</span> *<span class="title">dev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> *<span class="title">fd</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((r = fd_lookup(fdnum, &amp;fd)) &lt; <span class="number">0</span></span><br><span class="line">	    || (r = dev_lookup(fd-&gt;fd_dev_id, &amp;dev)) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	<span class="keyword">if</span> ((fd-&gt;fd_omode &amp; O_ACCMODE) == O_WRONLY) &#123;</span><br><span class="line">		cprintf(<span class="string">"[%08x] read %d -- bad mode\n"</span>, thisenv-&gt;env_id, fdnum);</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!dev-&gt;dev_read)</span><br><span class="line">		<span class="keyword">return</span> -E_NOT_SUPP;</span><br><span class="line">	<span class="keyword">return</span> (*dev-&gt;dev_read)(fd, buf, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>lib/file.c/devfile_read()</code>通过IPC共享的页面上的<code>union Fsipc</code>中存储请求的参数。在客户端，我们总是在<code>fsipcbuf</code>共享页面。设置好<code>fsipcbuf</code>的参数，调用<code>fsipc</code>去向服务器端发送<code>read</code>请求。请求成功后结果也是保存在共享页面<code>fsipcbuf</code>中，然后读到指定的<code>buf</code>就行。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> ssize_t <span class="title">devfile_read</span><span class="params">(struct Fd *fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// Make an FSREQ_READ request to the file system server after</span></span><br><span class="line">	<span class="comment">// filling fsipcbuf.read with the request arguments.  The</span></span><br><span class="line">	<span class="comment">// bytes read will be written back to fsipcbuf by the file</span></span><br><span class="line">	<span class="comment">// system server.</span></span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line"></span><br><span class="line">	fsipcbuf.read.req_fileid = fd-&gt;fd_file.id;</span><br><span class="line">    <span class="comment">//这个id就是指的当前位置？current position？</span></span><br><span class="line">	fsipcbuf.read.req_n = n;</span><br><span class="line">	<span class="keyword">if</span> ((r = fsipc(FSREQ_READ, <span class="literal">NULL</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	assert(r &lt;= n);</span><br><span class="line">	assert(r &lt;= PGSIZE);</span><br><span class="line">	memmove(buf, fsipcbuf.readRet.ret_buf, r);</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>lib/file.c/fsipc()</code>这个函数就是负责跟文件系统<code>server</code>进程间通信的。发送请求并接受结果。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fsipc</span><span class="params">(<span class="keyword">unsigned</span> type, <span class="keyword">void</span> *dstva)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">envid_t</span> fsenv;</span><br><span class="line">	<span class="keyword">if</span> (fsenv == <span class="number">0</span>)</span><br><span class="line">		fsenv = ipc_find_env(ENV_TYPE_FS);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static_assert</span>(<span class="keyword">sizeof</span>(fsipcbuf) == PGSIZE);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (debug)</span><br><span class="line">		cprintf(<span class="string">"[%08x] fsipc %d %08x\n"</span>, thisenv-&gt;env_id, type, *(<span class="keyword">uint32_t</span> *)&amp;fsipcbuf);</span><br><span class="line"></span><br><span class="line">	ipc_send(fsenv, type, &amp;fsipcbuf, PTE_P | PTE_W | PTE_U);</span><br><span class="line">	<span class="keyword">return</span> ipc_recv(<span class="literal">NULL</span>, dstva, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>fs/serv.c/serve()</code>中<code>ipc_recv</code>的返回值是32位字<code>env_ipc_value</code>，即<code>fsipc</code>里<code>ipc_send</code>过来的<code>type</code>，根据这个<code>type</code>判断进入哪个处理函数，这里很明显<code>type==FSREQ_READ</code>。</p>
<ol>
<li>从IPC接受1个请求类型<code>req</code>以及数据页<code>fsreq</code></li>
<li>然后根据<code>req</code>来执行相应的服务端处理函数</li>
<li>将相应服务端函数的执行结果(如果产生了数据也则有pg)通过IPC发送回调用进程</li>
<li>将映射好的物理页<code>fsreq</code>取消映射</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">serve</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">uint32_t</span> req, whom;</span><br><span class="line">	<span class="keyword">int</span> perm, r;</span><br><span class="line">	<span class="keyword">void</span> *pg;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		perm = <span class="number">0</span>;</span><br><span class="line">		req = ipc_recv((<span class="keyword">int32_t</span> *) &amp;whom, fsreq, &amp;perm);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// All requests must contain an argument page</span></span><br><span class="line">		<span class="keyword">if</span> (!(perm &amp; PTE_P)) &#123;</span><br><span class="line">			cprintf(<span class="string">"Invalid request from %08x: no argument page\n"</span>,</span><br><span class="line">				whom);</span><br><span class="line">			<span class="keyword">continue</span>; <span class="comment">// just leave it hanging...</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		pg = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">if</span> (req == FSREQ_OPEN) &#123;</span><br><span class="line">			r = serve_open(whom, (struct Fsreq_open*)fsreq, &amp;pg, &amp;perm);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (req &lt; ARRAY_SIZE(handlers) &amp;&amp; handlers[req]) &#123;</span><br><span class="line">			r = handlers[req](whom, fsreq);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			cprintf(<span class="string">"Invalid request code %d from %08x\n"</span>, req, whom);</span><br><span class="line">			r = -E_INVAL;</span><br><span class="line">		&#125;</span><br><span class="line">		ipc_send(whom, r, pg, perm);</span><br><span class="line">		sys_page_unmap(<span class="number">0</span>, fsreq);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>服务端函数定义在handler数组，通过请求号进行调用。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*fshandler)</span><span class="params">(<span class="keyword">envid_t</span> envid, <span class="keyword">union</span> Fsipc *req)</span></span>;</span><br><span class="line"></span><br><span class="line">fshandler handlers[] = &#123;</span><br><span class="line">    <span class="comment">// Open is handled specially because it passes pages</span></span><br><span class="line">    <span class="comment">/* [FSREQ_OPEN] =       (fshandler)serve_open, */</span></span><br><span class="line">    [FSREQ_READ] =          serve_read,</span><br><span class="line">    [FSREQ_STAT] =          serve_stat,</span><br><span class="line">    [FSREQ_FLUSH] =         (fshandler)serve_flush,</span><br><span class="line">    [FSREQ_WRITE] =         (fshandler)serve_write,</span><br><span class="line">    [FSREQ_SET_SIZE] =      (fshandler)serve_set_size,</span><br><span class="line">    [FSREQ_SYNC] =          serve_sync</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NHANDLERS (sizeof(handlers)/sizeof(handlers[0]))</span></span><br></pre></td></tr></table></figure></p>
<p>这个结构体定义了一些函数指针，做题的时候需要注意。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Dev</span> <span class="title">devfile</span> =</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        .dev_id =       <span class="string">'f'</span>,</span><br><span class="line">        .dev_name =     <span class="string">"file"</span>,</span><br><span class="line">        .dev_read =     devfile_read,</span><br><span class="line">        .dev_close =    devfile_flush,</span><br><span class="line">        .dev_stat =     devfile_stat,</span><br><span class="line">        .dev_write =    devfile_write,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>对于读文件请求，调用<code>serve_read</code>函数来处理。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">serve_read(<span class="keyword">envid_t</span> envid, <span class="keyword">union</span> Fsipc *ipc)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_read</span> *<span class="title">req</span> = &amp;<span class="title">ipc</span>-&gt;<span class="title">read</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Fsret_read</span> *<span class="title">ret</span> = &amp;<span class="title">ipc</span>-&gt;<span class="title">readRet</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (debug)</span><br><span class="line">                cprintf(<span class="string">"serve_read %08x %08x %08x\n"</span>, envid, req-&gt;req_fileid, req-&gt;req_n);</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">OpenFile</span> *<span class="title">o</span>;</span></span><br><span class="line">        <span class="keyword">int</span> r, req_n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((r = openfile_lookup(envid, req-&gt;req_fileid, &amp;o)) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">        req_n = req-&gt;req_n &gt; PGSIZE ? PGSIZE : req-&gt;req_n;</span><br><span class="line">        <span class="keyword">if</span> ((r = file_read(o-&gt;o_file, ret-&gt;ret_buf, req_n, o-&gt;o_fd-&gt;fd_offset)) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">        o-&gt;o_fd-&gt;fd_offset += r;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>先从<code>Fsipc</code>中获取读请求的结构体，然后在<code>openfile</code>中查找<code>fileid</code>对应的<code>Openfile</code>结构体，紧接着从<code>openfile</code>长相的<code>o_file</code>中读取内容到保存返回结果的<code>ret_buf</code>中，并移动文件偏移指针。</p>
<p>然后我们可以看一下用户进程发送读取请求的函数<code>devfile_read</code>，主要操作是封装<code>Fsipc</code>设置请求类型为<code>FSREQ_READ</code>，在接受到返回后，将返回结果拷贝到自己的<code>buf</code>中。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">ssize_t</span></span><br><span class="line">devfile_read(struct Fd *fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">int</span> r;</span><br><span class="line"></span><br><span class="line">        fsipcbuf.read.req_fileid = fd-&gt;fd_file.id;</span><br><span class="line">        fsipcbuf.read.req_n = n;</span><br><span class="line">        <span class="keyword">if</span> ((r = fsipc(FSREQ_READ, <span class="literal">NULL</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">        assert(r &lt;= n);</span><br><span class="line">        assert(r &lt;= PGSIZE);</span><br><span class="line">        memmove(buf, fsipcbuf.readRet.ret_buf, r);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Exercise 6.在<code>fs/server.c</code>中实现<code>serve_write</code>，在<code>lib/file.c</code>中实现<code>devfile_write</code>。实现与read请求类似。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fs/serv.c</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">serve_write(<span class="keyword">envid_t</span> envid, struct Fsreq_write *req)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">if</span> (debug)</span><br><span class="line">                cprintf(<span class="string">"serve_write %08x %08x %08x\n"</span>, envid, req-&gt;req_fileid, req-&gt;req_n);</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">OpenFile</span> *<span class="title">o</span>;</span></span><br><span class="line">        <span class="keyword">int</span> r, req_n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((r = openfile_lookup(envid, req-&gt;req_fileid, &amp;o)) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">        req_n = req-&gt;req_n &gt; PGSIZE ? PGSIZE : req-&gt;req_n;</span><br><span class="line">        <span class="keyword">if</span> ((r = file_write(o-&gt;o_file, req-&gt;req_buf, req_n, o-&gt;o_fd-&gt;fd_offset)) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">        o-&gt;o_fd-&gt;fd_offset += r;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// lib/file.c</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">ssize_t</span></span><br><span class="line">devfile_write(struct Fd *fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">int</span> r;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="keyword">sizeof</span>(fsipcbuf.write.req_buf))</span><br><span class="line">                n = <span class="keyword">sizeof</span>(fsipcbuf.write.req_buf);</span><br><span class="line">        fsipcbuf.write.req_fileid = fd-&gt;fd_file.id;</span><br><span class="line">        fsipcbuf.write.req_n = n;</span><br><span class="line">        memmove(fsipcbuf.write.req_buf, buf, n);</span><br><span class="line">        <span class="keyword">if</span> ((r = fsipc(FSREQ_WRITE, <span class="literal">NULL</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Spawning-Processes-衍生程序，派生程序"><a href="#Spawning-Processes-衍生程序，派生程序" class="headerlink" title="Spawning Processes(衍生程序，派生程序)"></a>Spawning Processes(衍生程序，派生程序)</h2><p>我们已经给出了<code>spawn</code>的代码(参见<code>lib/spawn.c</code>)，它创建一个新环境，从文件系统加载一个程序映像到其中，然后启动运行这个程序的子环境。然后父进程继续独立于子进程运行。<code>spawn</code>函数的作用类似于UNIX中的fork，然后在子进程中立即执行exec。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Spawn a child process from a program image loaded from the file system.</span></span><br><span class="line"><span class="comment">// prog: the pathname of the program to run.</span></span><br><span class="line"><span class="comment">// argv: pointer to null-terminated array of pointers to strings,</span></span><br><span class="line"><span class="comment">//       which will be passed to the child as its command-line arguments.</span></span><br><span class="line"><span class="comment">// Returns child envid on success, &lt; 0 on failure.</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">spawn(<span class="keyword">const</span> <span class="keyword">char</span> *prog, <span class="keyword">const</span> <span class="keyword">char</span> **argv)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> elf_buf[<span class="number">512</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Trapframe</span> <span class="title">child_tf</span>;</span></span><br><span class="line">    <span class="keyword">envid_t</span> child;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd, i, r;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Elf</span> *<span class="title">elf</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Proghdr</span> *<span class="title">ph</span>;</span></span><br><span class="line">    <span class="keyword">int</span> perm;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This code follows this procedure:</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//   - Open the program file.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//   - Read the ELF header, as you have before, and sanity check its</span></span><br><span class="line">    <span class="comment">//     magic number.  (Check out your load_icode!)</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//   - Use sys_exofork() to create a new environment.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//   - Set child_tf to an initial struct Trapframe for the child.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//   - Call the init_stack() function above to set up</span></span><br><span class="line">    <span class="comment">//     the initial stack page for the child environment.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//   - Map all of the program's segments that are of p_type</span></span><br><span class="line">    <span class="comment">//     ELF_PROG_LOAD into the new environment's address space.</span></span><br><span class="line">    <span class="comment">//     Use the p_flags field in the Proghdr for each segment</span></span><br><span class="line">    <span class="comment">//     to determine how to map the segment:</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//      * If the ELF flags do not include ELF_PROG_FLAG_WRITE,</span></span><br><span class="line">    <span class="comment">//    then the segment contains text and read-only data.</span></span><br><span class="line">    <span class="comment">//    Use read_map() to read the contents of this segment,</span></span><br><span class="line">    <span class="comment">//    and map the pages it returns directly into the child</span></span><br><span class="line">    <span class="comment">//    so that multiple instances of the same program</span></span><br><span class="line">    <span class="comment">//    will share the same copy of the program text.</span></span><br><span class="line">    <span class="comment">//    Be sure to map the program text read-only in the child.</span></span><br><span class="line">    <span class="comment">//    Read_map is like read but returns a pointer to the data in</span></span><br><span class="line">    <span class="comment">//    *blk rather than copying the data into another buffer.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//      * If the ELF segment flags DO include ELF_PROG_FLAG_WRITE,</span></span><br><span class="line">    <span class="comment">//    then the segment contains read/write data and bss.</span></span><br><span class="line">    <span class="comment">//    As with load_icode() in Lab 3, such an ELF segment</span></span><br><span class="line">    <span class="comment">//    occupies p_memsz bytes in memory, but only the FIRST</span></span><br><span class="line">    <span class="comment">//    p_filesz bytes of the segment are actually loaded</span></span><br><span class="line">    <span class="comment">//    from the executable file - you must clear the rest to zero.</span></span><br><span class="line">    <span class="comment">//    For each page to be mapped for a read/write segment,</span></span><br><span class="line">    <span class="comment">//    allocate a page in the parent temporarily at UTEMP,</span></span><br><span class="line">    <span class="comment">//    read() the appropriate portion of the file into that page</span></span><br><span class="line">    <span class="comment">//    and/or use memset() to zero non-loaded portions.</span></span><br><span class="line">    <span class="comment">//    (You can avoid calling memset(), if you like, if</span></span><br><span class="line">    <span class="comment">//    page_alloc() returns zeroed pages already.)</span></span><br><span class="line">    <span class="comment">//    Then insert the page mapping into the child.</span></span><br><span class="line">    <span class="comment">//    Look at init_stack() for inspiration.</span></span><br><span class="line">    <span class="comment">//    Be sure you understand why you can't use read_map() here.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//     Note: None of the segment addresses or lengths above</span></span><br><span class="line">    <span class="comment">//     are guaranteed to be page-aligned, so you must deal with</span></span><br><span class="line">    <span class="comment">//     these non-page-aligned values appropriately.</span></span><br><span class="line">    <span class="comment">//     The ELF linker does, however, guarantee that no two segments</span></span><br><span class="line">    <span class="comment">//     will overlap on the same page; and it guarantees that</span></span><br><span class="line">    <span class="comment">//     PGOFF(ph-&gt;p_offset) == PGOFF(ph-&gt;p_va).</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//   - Call sys_env_set_trapframe(child, &amp;child_tf) to set up the</span></span><br><span class="line">    <span class="comment">//     correct initial eip and esp values in the child.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//   - Start the child process running with sys_env_set_status().</span></span><br><span class="line">    <span class="keyword">if</span> ((r = open(prog, O_RDONLY)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    fd = r;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read elf header</span></span><br><span class="line">    elf = (struct Elf*) elf_buf;</span><br><span class="line">    <span class="keyword">if</span> (readn(fd, elf_buf, <span class="keyword">sizeof</span>(elf_buf)) != <span class="keyword">sizeof</span>(elf_buf) || elf-&gt;e_magic != ELF_MAGIC) &#123;</span><br><span class="line">        close(fd);</span><br><span class="line">        cprintf(<span class="string">"elf magic %08x want %08x\n"</span>, elf-&gt;e_magic, ELF_MAGIC);</span><br><span class="line">        <span class="keyword">return</span> -E_NOT_EXEC;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create new child environment</span></span><br><span class="line">    <span class="keyword">if</span> ((r = sys_exofork()) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    child = r;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set up trap frame, including initial stack.</span></span><br><span class="line">    child_tf = envs[ENVX(child)].env_tf;</span><br><span class="line">    child_tf.tf_eip = elf-&gt;e_entry;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((r = init_stack(child, argv, &amp;(child_tf.tf_esp))) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set up program segments as defined in ELF header.</span></span><br><span class="line">    ph = (struct Proghdr*) (elf_buf + elf-&gt;e_phoff);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; elf-&gt;e_phnum; i++, ph++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ph-&gt;p_type != ELF_PROG_LOAD)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        perm = PTE_P | PTE_U;</span><br><span class="line">        <span class="keyword">if</span> (ph-&gt;p_flags &amp; ELF_PROG_FLAG_WRITE)</span><br><span class="line">            perm |= PTE_W;</span><br><span class="line">        <span class="keyword">if</span> ((r = map_segment(child, ph-&gt;p_va, ph-&gt;p_memsz, fd, ph-&gt;p_filesz, ph-&gt;p_offset, perm)) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">    fd = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy shared library state.</span></span><br><span class="line">    <span class="keyword">if</span> ((r = copy_shared_pages(child)) &lt; <span class="number">0</span>)</span><br><span class="line">        panic(<span class="string">"copy_shared_pages: %e"</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((r = sys_env_set_trapframe(child, &amp;child_tf)) &lt; <span class="number">0</span>)</span><br><span class="line">        panic(<span class="string">"sys_env_set_trapframe: %e"</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((r = sys_env_set_status(child, ENV_RUNNABLE)) &lt; <span class="number">0</span>)</span><br><span class="line">        panic(<span class="string">"sys_env_set_status: %e"</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> child;</span><br><span class="line"></span><br><span class="line">error:</span><br><span class="line">    sys_env_destroy(child);</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们实现了<code>spawn</code>而不是unix风格的exec，因为spawn更容易从用户空间以“exokernel fashion”(一种方式)实现，而不需要内核的特殊帮助。考虑一下要在用户空间中实现exec需要做些什么，并确保您理解为什么这么做更难些。</p>
<p>Exercise 7. 依赖于新的系统调用<code>sys_env_set_trapframe</code>来初始化新创建环境的状态的<code>spawn</code>。在<code>kern/syscall.c</code>中实现<code>sys_env_set_trapframe</code>(不要忘记在<code>syscall()</code>中添加新的系统调用的分派)。</p>
<p><code>sys_env_set_trapframe</code>函数实现简单，主要是用来拷贝父进程的寄存器。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sys_env_set_trapframe(<span class="keyword">envid_t</span> envid, struct Trapframe *tf)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((r = envid2env(envid, &amp;e, <span class="literal">true</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">    user_mem_assert(e, tf, <span class="keyword">sizeof</span>(struct Trapframe), PTE_U);</span><br><span class="line">    e-&gt;env_tf = *tf;</span><br><span class="line">    e-&gt;env_tf.tf_cs |= <span class="number">3</span>;</span><br><span class="line">    e-&gt;env_tf.tf_eflags |= FL_IF;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Sharing-library-state-across-fork-and-spawn"><a href="#Sharing-library-state-across-fork-and-spawn" class="headerlink" title="Sharing library state across fork and spawn"></a>Sharing library state across fork and spawn</h2><p>UNIX文件描述符是一个通用的概念，它还包括pipes, console I/O等。在JOS中，每种设备类型都有一个对应的<code>struct Dev</code>，带有指向为该类型实现的read/write等函数的指针。<code>lib/fd.c</code>在此基础上实现了通用的类unix文件描述符接口。每个<code>struct Fd</code>都指示其设备类型，<code>lib/fd.c</code>中的大多数函数只是简单地将操作分派给适当<code>struct Dev</code>中的函数。</p>
<p><code>lib/fd.c</code>还在每个应用程序环境的地址空间中维护从<code>FDTABLE(0xD0000000)</code>开始的 file descriptor table region。在这个区域每个<code>struct Fd</code>都保留着一个页。在任何给定时间，只有在使用相应的文件描述符时才映射特定的文件描述符表页。每个文件描述符在从FILEDATA开始的区域中都有一个可选的“data page”，设备可以使用这些“data page”。</p>
<p>我们希望跨<code>fork</code>和<code>spawn</code>共享文件描述符状态，但是文件描述符状态保存在用户空间内存中。而且在fork时，内存将被标记为copy-on-write，因此状态将被复制而不是共享。(这意味着环境无法在自己没有打开的文件中进行查找，而且管道也不能跨fork工作)。在<code>spawn</code>时，内存将被留在后面，根本不复制。(实际上，派生的环境一开始没有打开的文件描述符)</p>
<p>我们将更改<code>fork</code>，以确定“library operating system”使用的内存区域应该总是共享的。我们将在页表条目中设置一个未使用的位，而不是在某个地方hard-code(硬编码)一个区域列表(就像我们在<code>fork</code>中使用PTE_COW位一样)。</p>
<p>我们在<code>inc/lib.h</code>中定义了一个新的<code>PTE_SHARE</code>位。这个位是三个PTE位之一，在 Intel and AMD manuals中被标记为“available for software use”。我们将建立这样一个约定:如果页表条目设置了这个位，那么PTE应该在<code>fork</code>和<code>spawn</code>时从父环境直接复制到子环境。注意，这与标记为copy-on-write不同：如第一段所述，我们希望确保共享页面的更新。</p>
<p>Exercise 8：改变<code>duppage</code>函数实现上述变化，如果页表入口有设置<code>PTE_SHARE</code>位，那么直接拷贝映射。类似地，实现<code>copy_shared_pages</code>函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">duppage(<span class="keyword">envid_t</span> envid, <span class="keyword">unsigned</span> pn)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> *addr;</span><br><span class="line">    <span class="keyword">pte_t</span> pte;</span><br><span class="line">    <span class="keyword">int</span> perm;</span><br><span class="line"></span><br><span class="line">    addr = (<span class="keyword">void</span> *)((<span class="keyword">uint32_t</span>)pn * PGSIZE);</span><br><span class="line">    pte = uvpt[pn];</span><br><span class="line">    <span class="keyword">if</span> (pte &amp; PTE_SHARE) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((r = sys_page_map(sys_getenvid(), addr, envid, addr, pte &amp; PTE_SYSCALL)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">            panic(<span class="string">"duppage: page mapping failed %e"</span>, r);</span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        perm = PTE_P | PTE_U;</span><br><span class="line">        <span class="keyword">if</span> ((pte &amp; PTE_W) || (pte &amp; PTE_COW))</span><br><span class="line">            perm |= PTE_COW;</span><br><span class="line">        <span class="keyword">if</span> ((r = sys_page_map(thisenv-&gt;env_id, addr, envid, addr, perm)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            panic(<span class="string">"duppage: page remapping failed %e"</span>, r);</span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (perm &amp; PTE_COW) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((r = sys_page_map(thisenv-&gt;env_id, addr, thisenv-&gt;env_id, addr, perm)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                panic(<span class="string">"duppage: page remapping failed %e"</span>, r);</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>copy_shared_pages</code>应该循环遍历当前进程中的所有页表条目(就像fork所做的那样)，将设置了<code>PTE_SHARE</code>位的任何页映射复制到子进程中。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">copy_shared_pages(<span class="keyword">envid_t</span> child)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// LAB 5: Your code here.</span></span><br><span class="line">	<span class="keyword">int</span> r,i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; PGNUM(USTACKTOP); i ++)&#123; </span><br><span class="line">	<span class="comment">// uvpd、uvpt应该是个全局数组变量，</span></span><br><span class="line">    <span class="comment">// 但是数组元素对应的pde、pte具体是什么应该取决于lcr3设置的是哪个环境的内存空间</span></span><br><span class="line">		<span class="keyword">if</span>((uvpd[i/<span class="number">1024</span>] &amp; PTE_P) &amp;&amp; (uvpt[i] &amp; PTE_P) &amp;&amp; (uvpt[i] &amp; PTE_SHARE))&#123; </span><br><span class="line">            <span class="comment">//i跟pte一一对应，而i/1024就是该pte所在的页表</span></span><br><span class="line">			<span class="keyword">if</span> ((r = sys_page_map(<span class="number">0</span>, PGADDR(i/<span class="number">1024</span>, i%<span class="number">1024</span>, <span class="number">0</span>), child, PGADDR(i/<span class="number">1024</span>, i%<span class="number">1024</span>, <span class="number">0</span>), uvpt[i] &amp; PTE_SYSCALL)) &lt; <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">return</span> r;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>要让shell工作，我们需要一种方法来键入它。QEMU一直在显示我们写入到CGA显示器和串行端口的输出，但到目前为止，我们只在内核监视器中接受输入。在QEMU中，在图形化窗口中键入的输入显示为从键盘到JOS的输入，而在控制台中键入的输入显示为串行端口上的字符。<code>kern/console.c</code>已经包含了自lab 1以来内核监视器一直使用的键盘和串行驱动程序，但是现在您需要将它们附加到系统的其他部分。</p>
<p>Exercise 9. 在你的<code>kern/trap.c</code>，调用<code>kbd_intr</code>处理<code>trap IRQ_OFFSET+IRQ_KBD</code>，调用<code>serial_intr</code>处理<code>trap IRQ_OFFSET+IRQ_SERIAL</code>。</p>
<p>我们在<code>lib/console.c</code>中为您实现了控制台输入/输出文件类型。<code>kbd_intr</code>和<code>serial_intr</code>用最近读取的输入填充缓冲区，而控制台文件类型耗尽缓冲区(控制台文件类型默认用于<code>stdin/stdout</code>，除非用户重定向它们)。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//kern/trap.c/trap_dispatch()</span></span><br><span class="line"><span class="keyword">if</span> (tf-&gt;tf_trapno == IRQ_OFFSET + IRQ_KBD)&#123;</span><br><span class="line">	kbd_intr();</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (tf-&gt;tf_trapno == IRQ_OFFSET + IRQ_SERIAL)&#123;</span><br><span class="line">	serial_intr();</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>稍微看一下这两个函数。<code>kbd_proc_data()</code>是从键盘读入character就返回，如果没输入就返回-1<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kbd_intr</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    cons_intr(kbd_proc_data);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//serial_proc_data()很明显就是从串行端口读一个data</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">serial_intr</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (serial_exists)</span><br><span class="line">		cons_intr(serial_proc_data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>两个函数都调用下边这个<code>cons_intr</code>，这个函数就是从键盘读入的一行填充到<code>cons.buf</code>。而<code>cons</code>如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="keyword">uint8_t</span> buf[CONSBUFSIZE];</span><br><span class="line">        <span class="keyword">uint32_t</span> rpos;</span><br><span class="line">        <span class="keyword">uint32_t</span> wpos;</span><br><span class="line">&#125; cons;</span><br></pre></td></tr></table></figure></p>
<p>当函数指针所接收到的数据不为-1时，把收到的数据加入到buf中。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cons_intr</span><span class="params">(<span class="keyword">int</span> (*proc)(<span class="keyword">void</span>))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> c;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> ((c = (*proc)()) != <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		cons.buf[cons.wpos++] = c;</span><br><span class="line">		<span class="keyword">if</span> (cons.wpos == CONSBUFSIZE)</span><br><span class="line">			cons.wpos = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>与<code>kbd_intr</code>有关的是下边这个函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Get data from the keyboard.  If we finish a character, return it.  Else 0.</span></span><br><span class="line"><span class="comment"> * Return -1 if no data.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">kbd_proc_data(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="keyword">uint8_t</span> data;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">uint32_t</span> shift;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((inb(KBSTATP) &amp; KBS_DIB) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    data = inb(KBDATAP);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (data == <span class="number">0xE0</span>) &#123;</span><br><span class="line">        <span class="comment">// E0 escape character</span></span><br><span class="line">        shift |= E0ESC;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data &amp; <span class="number">0x80</span>) &#123;</span><br><span class="line">        <span class="comment">// Key released</span></span><br><span class="line">        data = (shift &amp; E0ESC ? data : data &amp; <span class="number">0x7F</span>);</span><br><span class="line">        shift &amp;= ~(shiftcode[data] | E0ESC);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shift &amp; E0ESC) &#123;</span><br><span class="line">        <span class="comment">// Last character was an E0 escape; or with 0x80</span></span><br><span class="line">        data |= <span class="number">0x80</span>;</span><br><span class="line">        shift &amp;= ~E0ESC;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    shift |= shiftcode[data];</span><br><span class="line">    shift ^= togglecode[data];</span><br><span class="line"></span><br><span class="line">    c = charcode[shift &amp; (CTL | SHIFT)][data];</span><br><span class="line">    <span class="keyword">if</span> (shift &amp; CAPSLOCK) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">'a'</span> &lt;= c &amp;&amp; c &lt;= <span class="string">'z'</span>)</span><br><span class="line">            c += <span class="string">'A'</span> - <span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">'A'</span> &lt;= c &amp;&amp; c &lt;= <span class="string">'Z'</span>)</span><br><span class="line">            c += <span class="string">'a'</span> - <span class="string">'A'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Process special keys</span></span><br><span class="line">    <span class="comment">// Ctrl-Alt-Del: reboot</span></span><br><span class="line">    <span class="keyword">if</span> (!(~shift &amp; (CTL | ALT)) &amp;&amp; c == KEY_DEL) &#123;</span><br><span class="line">        cprintf(<span class="string">"Rebooting!\n"</span>);</span><br><span class="line">        outb(<span class="number">0x92</span>, <span class="number">0x3</span>); <span class="comment">// courtesy of Chris Frost</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="The-Shell"><a href="#The-Shell" class="headerlink" title="The Shell"></a>The Shell</h1><p>运行<code>make run-icode</code>或者<code>make run-icode-nox</code>。这将运行内核并启动<code>user/icode</code>。<code>icode</code>执行<code>init</code>，它将把控制台设置为文件描述符0和1(标准输入和标准输出)。然后它会<code>spawn sh</code>，也就是<code>shell</code>。你应该能够运行以下命令:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> hello world | cat</span><br><span class="line">cat lorem |cat</span><br><span class="line">cat lorem |num</span><br><span class="line">cat lorem |num |num |num |num |num</span><br><span class="line">lsfd</span><br></pre></td></tr></table></figure></p>
<p>注意，用户库例程cprintf直接打印到控制台，而不使用文件描述符代码。这对于调试非常有用，但是对于piping into other programs却不是很有用。要将输出打印到特定的文件描述符(例如，1，标准输出)，请使用fprintf(1, “…”, …)。 printf(“…”, …)是打印到FD 1的捷径。有关示例，请参见user/lsfd.c。</p>
<p>Exercise 10. shell不支持I/O重定向。如果能运行<code>sh &lt;script</code>就更好，而不是像上面那样手工输入<code>script</code>中的所有命令。将<code>&lt;</code>的I/O重定向添加到<code>user/sh.c</code>。通过在shell中键入<code>sh &lt;script</code>测试您的实现</p>
<p>运行<code>make run-testshell</code>来测试您的<code>shell</code>。<code>testshell</code>只是将上面的命令(也可以在<code>fs/testshell.sh</code>中找到)提供给shell，然后检查输出是否匹配<code>fs/testshell.key</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">'&lt;'</span>:	<span class="comment">// Input redirection</span></span><br><span class="line">	<span class="comment">// Grab the filename from the argument list</span></span><br><span class="line">	<span class="keyword">if</span> (gettoken(<span class="number">0</span>, &amp;t) != <span class="string">'w'</span>) &#123;</span><br><span class="line">		cprintf(<span class="string">"syntax error: &lt; not followed by word\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// LAB 5: Your code here.</span></span><br><span class="line">	<span class="keyword">if</span> ((fd = open(t, O_RDONLY)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		cprintf(<span class="string">"open %s for read: %e"</span>, t, fd);</span><br><span class="line">		<span class="built_in">exit</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (fd != <span class="number">0</span>) &#123;</span><br><span class="line">		dup(fd, <span class="number">0</span>); <span class="comment">//应该是让文件描述符0也作为fd对应的那个open file的struct Fd页面</span></span><br><span class="line">		close(fd);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//panic("&lt; redirection not implemented");</span></span><br><span class="line">	<span class="keyword">break</span>;</span><br></pre></td></tr></table></figure></p>
<p>为什么好多函数的<code>envid_t</code>参数总是设成0？在<code>envid2env()</code>函数中有这样如下定义。所以设成0就e就默认是<code>curenv</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If envid is zero, return the current environment.</span></span><br><span class="line">    <span class="keyword">if</span> (envid == <span class="number">0</span>) &#123;</span><br><span class="line">        *env_store = curenv;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>Challenge的要求即为清空掉所有的没有被访问的页面。那么对于单个页面，只需要调用<code>flush_block()</code>，之后通过系统调用<code>unmap</code>就可以了。<code>evict_policy()</code>即对于所有的block做一个便利，清除所有从未被访问过的页面。具体代码内容如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// challenge</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">evict_block(<span class="keyword">void</span> *addr)&#123;</span><br><span class="line">	<span class="keyword">uint32_t</span> blockno = ((<span class="keyword">uint32_t</span>)addr - DISKMAP) / BLKSIZE;</span><br><span class="line">	<span class="keyword">if</span>(addr &lt; (<span class="keyword">void</span>*)DISKMAP || addr &gt;= (<span class="keyword">void</span>*)(DISKMAP + DISKSIZE))</span><br><span class="line">		panic(<span class="string">"evict_block of bad va %08x"</span>, addr);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line">	addr = ROUNDDOWN(addr, BLKSIZE);</span><br><span class="line">	flush_block(addr);</span><br><span class="line">	<span class="keyword">if</span>((r = sys_page_unmap(<span class="number">0</span>, addr)) &lt; <span class="number">0</span>)</span><br><span class="line">		panic(<span class="string">"in evict block, sys_page_unmap: %e"</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">evict_policy()&#123;</span><br><span class="line">	<span class="keyword">uint32_t</span> blockno;</span><br><span class="line">	<span class="keyword">for</span>(blockno = <span class="number">3</span>; blockno &lt; DISKSIZE / BLKSIZE; ++blockno)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!(uvpt[PGNUM(diskaddr(blockno))]&amp;PTE_A))&#123;</span><br><span class="line">			evict_block(diskaddr(blockno));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/操作系统/" rel="tag"># 操作系统</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/11/16/6.828-lab4/" rel="next" title="6.828 lab4">
                <i class="fa fa-chevron-left"></i> 6.828 lab4
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/11/16/6.828-lab6/" rel="prev" title="6.828 lab6">
                6.828 lab6 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/header.jpg" alt="Hao Yu">
            
              <p class="site-author-name" itemprop="name">Hao Yu</p>
              <p class="site-description motion-element" itemprop="description">Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author</p>
          </div>
          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">323</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>
        	<audio controls="controls" loop="loop" preload="auto" src="/resource/xiaomeihao.mp3">
	        </audio>
	

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yuhao0102" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:yuh18@mails.tsinghua.edu.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Introduction"><span class="nav-number">1.</span> <span class="nav-text">Introduction</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#文件系统初步"><span class="nav-number">2.</span> <span class="nav-text">文件系统初步</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#磁盘文件系统结构"><span class="nav-number">2.1.</span> <span class="nav-text">磁盘文件系统结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#磁盘扇区、数据块"><span class="nav-number">2.2.</span> <span class="nav-text">磁盘扇区、数据块</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#超级块"><span class="nav-number">2.3.</span> <span class="nav-text">超级块</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件元数据"><span class="nav-number">2.4.</span> <span class="nav-text">文件元数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#目录与常规文件"><span class="nav-number">2.5.</span> <span class="nav-text">目录与常规文件</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#文件系统"><span class="nav-number">3.</span> <span class="nav-text">文件系统</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Disk-Access"><span class="nav-number">3.1.</span> <span class="nav-text">Disk Access</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#The-Block-Cache"><span class="nav-number">3.2.</span> <span class="nav-text">The Block Cache</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#块位图"><span class="nav-number">3.3.</span> <span class="nav-text">块位图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件操作"><span class="nav-number">3.4.</span> <span class="nav-text">文件操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#The-file-system-interface"><span class="nav-number">3.5.</span> <span class="nav-text">The file system interface</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spawning-Processes-衍生程序，派生程序"><span class="nav-number">3.6.</span> <span class="nav-text">Spawning Processes(衍生程序，派生程序)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Sharing-library-state-across-fork-and-spawn"><span class="nav-number">3.7.</span> <span class="nav-text">Sharing library state across fork and spawn</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#The-Shell"><span class="nav-number">4.</span> <span class="nav-text">The Shell</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>
  <div id="DvelopmentTarget">     
  </div>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart" aria-hidden="false"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>

  
</div>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_uv"> 
  本站访客数<span id="busuanzi_value_site_uv"></span>人次
</span>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  


  

  


  <script type="text/javascript" src="/js/src/love.js"></script>

</body>
</html>
