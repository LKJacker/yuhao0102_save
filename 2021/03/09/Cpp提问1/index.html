<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zn-ch">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-center-simple.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="C++,">










<meta name="description" content="在main执行之前和之后执行的代码可能是什么？main函数执行之前，主要就是初始化系统相关资源：  设置栈指针 初始化静态static变量和global全局变量，即.data段的内容 将未初始化部分的全局变量赋初值：数值型short，int，long等为0，bool为FALSE，指针为NULL等等，即.bss段的内容 全局对象初始化，在main之前调用构造函数，这是可能会执行前的一些代码 将mai">
<meta name="keywords" content="C++">
<meta property="og:type" content="article">
<meta property="og:title" content="《逆袭进大厂》之C++篇 1">
<meta property="og:url" content="http://yoursite.com/2021/03/09/Cpp提问1/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="在main执行之前和之后执行的代码可能是什么？main函数执行之前，主要就是初始化系统相关资源：  设置栈指针 初始化静态static变量和global全局变量，即.data段的内容 将未初始化部分的全局变量赋初值：数值型short，int，long等为0，bool为FALSE，指针为NULL等等，即.bss段的内容 全局对象初始化，在main之前调用构造函数，这是可能会执行前的一些代码 将mai">
<meta property="og:locale" content="zn-ch">
<meta property="og:updated_time" content="2021-03-15T10:30:02.797Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="《逆袭进大厂》之C++篇 1">
<meta name="twitter:description" content="在main执行之前和之后执行的代码可能是什么？main函数执行之前，主要就是初始化系统相关资源：  设置栈指针 初始化静态static变量和global全局变量，即.data段的内容 将未初始化部分的全局变量赋初值：数值型short，int，long等为0，bool为FALSE，指针为NULL等等，即.bss段的内容 全局对象初始化，在main之前调用构造函数，这是可能会执行前的一些代码 将mai">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2021/03/09/Cpp提问1/">





  <title>《逆袭进大厂》之C++篇 1 | Hao Yu's blog</title>
  








 
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zn-ch">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hao Yu's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">The program monkey was eaten by the siege lion.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-mybetterhalf">
          <a href="/mybetterhalf/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>
            
            mybetterhalf
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="Searching..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/09/Cpp提问1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">《逆袭进大厂》之C++篇 1</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-03-09T16:09:00+08:00">
                2021-03-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="在main执行之前和之后执行的代码可能是什么？"><a href="#在main执行之前和之后执行的代码可能是什么？" class="headerlink" title="在main执行之前和之后执行的代码可能是什么？"></a>在main执行之前和之后执行的代码可能是什么？</h1><p>main函数执行之前，主要就是初始化系统相关资源：</p>
<ul>
<li>设置栈指针</li>
<li>初始化静态static变量和global全局变量，即.data段的内容</li>
<li>将未初始化部分的全局变量赋初值：数值型short，int，long等为0，bool为FALSE，指针为NULL等等，即.bss段的内容</li>
<li>全局对象初始化，在main之前调用构造函数，这是可能会执行前的一些代码</li>
<li>将main函数的参数argc，argv等传递给main函数，然后才真正运行main函数</li>
</ul>
<p>main函数执行之后：</p>
<ul>
<li>全局对象的析构函数会在main函数之后执行；</li>
<li>可以用 atexit 注册一个函数，它会在main 之后执行;</li>
</ul>
<h1 id="结构体内存对齐问题？"><a href="#结构体内存对齐问题？" class="headerlink" title="结构体内存对齐问题？"></a>结构体内存对齐问题？</h1><p>结构体内成员按照声明顺序存储，第一个成员地址和整个结构体地址相同。</p>
<p>未特殊说明时，按结构体中size最大的成员对齐（若有double成员，按8字节对齐。）</p>
<h1 id="指针和引用的区别"><a href="#指针和引用的区别" class="headerlink" title="指针和引用的区别"></a>指针和引用的区别</h1><ul>
<li>指针是一个变量，存储的是一个地址，引用跟原来的变量实质上是同一个东西，是原变量的别名</li>
<li>指针可以有多级，引用只有一级</li>
<li>指针可以为空，引用不能为NULL且在定义时必须初始化</li>
<li>指针在初始化后可以改变指向，而引用在初始化之后不可再改变</li>
<li>sizeof指针得到的是本指针的大小，sizeof引用得到的是引用所指向变量的大小</li>
<li>当把指针作为参数进行传递时，也是将实参的一个拷贝传递给形参，两者指向的地址相同，但不是同一个变量，在函数中改变这个变量的指向不影响实参，而引用却可以。</li>
<li>引用只是别名，不占用具体存储空间，只有声明没有定义；指针是具体变量，需要占用存储空间。</li>
<li>引用在声明时必须初始化为另一变量，一旦出现必须为typename refname &amp;varname形式；指针声明和定义可以分开，可以先只声明指针变量而不初始化，等用到时再指向具体变量。</li>
<li>引用一旦初始化之后就不可以再改变（变量可以被引用为多次，但引用只能作为一个变量引用）；指针变量可以重新指向别的变量。</li>
<li>不存在指向空值的引用，必须有具体实体；但是存在指向空值的指针。</li>
</ul>
<p>参考代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">　　<span class="keyword">int</span> a=<span class="number">1</span>;</span><br><span class="line">　　p=&amp;a;</span><br><span class="line">　　<span class="built_in">cout</span>&lt;&lt;p&lt;&lt;<span class="string">" "</span>&lt;&lt;*p&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p=<span class="literal">NULL</span>;</span><br><span class="line">    test(p);</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"指针p为NULL"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果为：</span></span><br><span class="line"><span class="comment">//0x22ff44 1</span></span><br><span class="line"><span class="comment">//指针p为NULL</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testPTR</span><span class="params">(<span class="keyword">int</span>* p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">12</span>;</span><br><span class="line">    p = &amp;a;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testREFF</span><span class="params">(<span class="keyword">int</span>&amp; p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">12</span>;</span><br><span class="line">    p = a;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span>* b = &amp;a;</span><br><span class="line">    testPTR(b);<span class="comment">//改变指针指向，但是没改变指针的所指的内容</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;<span class="comment">// 10</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *b &lt;&lt; <span class="built_in">endl</span>;<span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line">    a = <span class="number">10</span>;</span><br><span class="line">    testREFF(a);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//12</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h1><ul>
<li>申请方式不同：栈由系统自动分配；堆是自己申请和释放的。</li>
<li>申请大小限制不同：栈顶和栈底是之前预设好的，栈是向栈底扩展，大小固定，可以通过ulimit -a查看，由ulimit -s修改；堆向高地址扩展，是不连续的内存区域，大小可以灵活调整。</li>
<li>申请效率不同：栈由系统分配，速度快，不会有碎片；堆由程序员分配，速度慢，且会有碎片。</li>
</ul>
<p>形象的比喻</p>
<p>栈就像我们去饭馆里吃饭，只管点菜（发出申# # 和吃（使用），吃饱了就走，不必理会# 洗菜等准备工作和# 刷锅等扫尾工作，他的好处是快捷，但是自由度小。</p>
<p>堆就象是自己动手做喜欢吃的菜肴，比较麻烦，但是比较符合自己的口味，而且自由度大。</p>
<h1 id="区别以下指针类型？"><a href="#区别以下指针类型？" class="headerlink" title="区别以下指针类型？"></a>区别以下指针类型？</h1><ul>
<li><code>int *p[10]</code></li>
<li><code>int (*p)[10]</code></li>
<li><code>int *p(int)</code></li>
<li><p><code>int (*p)(int)</code></p>
</li>
<li><p><code>int *p[10]</code>表示指针数组，强调数组概念，是一个数组变量，数组大小为10，数组内每个元素都是指向int类型的指针变量。</p>
</li>
<li><code>int (*p)[10]</code>表示数组指针，强调是指针，只有一个变量，是指针类型，不过指向的是一个int类型的数组，这个数组大小是10。</li>
<li><code>int *p(int)</code>是函数声明，函数名是p，参数是int类型的，返回值是int *类型的。</li>
<li><code>int (*p)(int)</code>是函数指针，强调是指针，该指针指向的函数具有int类型参数，并且返回值是int类型的。</li>
</ul>
<h1 id="基类的虚函数表存放在内存的什么区，虚表指针vptr的初始化时间"><a href="#基类的虚函数表存放在内存的什么区，虚表指针vptr的初始化时间" class="headerlink" title="基类的虚函数表存放在内存的什么区，虚表指针vptr的初始化时间"></a>基类的虚函数表存放在内存的什么区，虚表指针vptr的初始化时间</h1><p>首先整理一下虚函数表的特征：</p>
<ul>
<li>虚函数表是全局共享的元素，即全局仅有一个，在编译时就构造完成</li>
<li>虚函数表类似一个数组，类对象中存储vptr指针，指向虚函数表，即虚函数表不是函数，不是程序代码，不可能存储在代码段</li>
<li>虚函数表存储虚函数的地址,即虚函数表的元素是指向类成员函数的指针,而类中虚函数的个数在编译时期可以确定，即虚函数表的大小可以确定,即大小是在编译时期确定的，不必动态分配内存空间存储虚函数表，所以不在堆中</li>
</ul>
<p>根据以上特征，虚函数表类似于类中静态成员变量.静态成员变量也是全局共享，大小确定，因此最有可能存在全局数据区，测试结果显示：</p>
<p>虚函数表vtable在Linux/Unix中存放在可执行文件的只读数据段中(rodata)，这与微软的编译器将虚函数表存放在常量段存在一些差别</p>
<p>由于虚表指针vptr跟虚函数密不可分，对于有虚函数或者继承于拥有虚函数的基类，对该类进行实例化时，在构造函数执行时会对虚表指针进行初始化，并且存在对象内存布局的最前面。</p>
<p>一般分为五个区域：# # 函数区（存放函数体等二进制代# 全局静# 常量区</p>
<p>C++中虚函数表位于只读数据段（.rodata），也就是C++内存模型中的常量区；而虚函数则位于代码段（.text），也就是C++内存模型中的代码区。</p>
<h1 id="new-delete-与-malloc-free的异同"><a href="#new-delete-与-malloc-free的异同" class="headerlink" title="new / delete 与 malloc / free的异同"></a>new / delete 与 malloc / free的异同</h1><p>相同点：都可用于内存的动态申请和释放</p>
<p>不同点：前者是C++运算符，后者是C/C++语言标准库函数</p>
<p>new自动计算要分配的空间大小，malloc需要手工计算</p>
<p>new是类型安全的，malloc不是。例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">float</span>[<span class="number">2</span>]; <span class="comment">//编译错误</span></span><br><span class="line"><span class="keyword">int</span> *p = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="number">2</span> * <span class="keyword">sizeof</span>(<span class="keyword">double</span>));<span class="comment">//编译无错误</span></span><br></pre></td></tr></table></figure></p>
<p>new调用名为operator new的标准库函数分配足够空间并调用相关对象的构造函数，delete对指针所指对象运行适当的析构函数；然后通过调用名为operator delete的标准库函数释放该对象所用内存。后者均没有相关调用</p>
<p>后者需要库文件支持，前者不用</p>
<p>new是封装了malloc，直接free不会报错，但是这只是释放内存，而不会析构对象</p>
<h1 id="new和delete是如何实现的？"><a href="#new和delete是如何实现的？" class="headerlink" title="new和delete是如何实现的？"></a>new和delete是如何实现的？</h1><p>new的实现过程是：首先调用名为operator new的标准库函数，分配足够大的原始为类型化的内存，以保存指定类型的一个对象；接下来运行该类型的一个构造函数，用指定初始化构造对象；最后返回指向新分配并构造后的的对象的指针</p>
<p>delete的实现过程：对指针指向的对象运行适当的析构函数；然后通过调用名为operator delete的标准库函数释放该对象所用内存</p>
<h1 id="malloc和new的区别？"><a href="#malloc和new的区别？" class="headerlink" title="malloc和new的区别？"></a>malloc和new的区别？</h1><p>malloc和free是标准库函数，支持覆盖；new和delete是运算符，并且支持重载。</p>
<p>malloc仅仅分配内存空间，free仅仅回收空间，不具备调用构造函数和析构函数功能，用malloc分配空间存储类的对象存在风险；new和delete除了分配回收功能外，还会调用构造函数和析构函数。</p>
<p>malloc和free返回的是void类型指针（必须进行类型转换），new和delete返回的是具体类型指针。</p>
<p>delete和delete[]区别？</p>
<p>delete只会调用一次析构函数。</p>
<p>delete[]会调用数组中每个元素的析构函数。</p>
<h1 id="宏定义和函数有何区别？"><a href="#宏定义和函数有何区别？" class="headerlink" title="宏定义和函数有何区别？"></a>宏定义和函数有何区别？</h1><p>宏在编译时完成替换，之后被替换的文本参与编译，相当于直接插入了代码，运行时不存在函数调用，执行起来更快；函数调用在运行时需要跳转到具体调用函数。</p>
<p>宏定义属于在结构中插入代码，没有返回值；函数调用具有返回值。</p>
<p>宏定义参数没有类型，不进行类型检查；函数参数具有类型，需要检查类型。</p>
<p>宏定义不要在最后加分号。</p>
<h1 id="宏定义和typedef区别？"><a href="#宏定义和typedef区别？" class="headerlink" title="宏定义和typedef区别？"></a>宏定义和typedef区别？</h1><p>宏主要用于定义常量及书写复杂的内容；typedef主要用于定义类型别名。</p>
<p>宏替换发生在编译阶段之前，属于文本插入替换；typedef是编译的一部分。</p>
<p>宏不检查类型；typedef会检查数据类型。</p>
<p>宏不是语句，不在在最后加分号；typedef是语句，要加分号标识结束。</p>
<p>注意对指针的操作，typedef char <em> p_char和define p_char char </em>区别巨大。</p>
<h1 id="变量声明和定义区别？"><a href="#变量声明和定义区别？" class="headerlink" title="变量声明和定义区别？"></a>变量声明和定义区别？</h1><p>声明仅仅是把变量的声明的位置及类型提供给编译器，并不分配内存空间；定义要在定义的地方为其分配存储空间。</p>
<p>相同变量可以在多处声明（外部变量extern），但只能在一处定义。</p>
<h1 id="哪几种情况必须用到初始化成员列表？"><a href="#哪几种情况必须用到初始化成员列表？" class="headerlink" title="哪几种情况必须用到初始化成员列表？"></a>哪几种情况必须用到初始化成员列表？</h1><p>初始化一个const成员。</p>
<p>初始化一个reference成员。</p>
<p>调用一个基类的构造函数，而该函数有一组参数。</p>
<p>调用一个数据成员对象的构造函数，而该函数有一组参数。</p>
<h1 id="strlen和sizeof区别？"><a href="#strlen和sizeof区别？" class="headerlink" title="strlen和sizeof区别？"></a>strlen和sizeof区别？</h1><p>sizeof是运算符，并不是函数，结果在编译时得到而非运行中获得；strlen是字符处理的库函数。</p>
<p>sizeof参数可以是任何数据的类型或者数据（sizeof参数不退化）；strlen的参数只能是字符指针且结尾是’\0’的字符串。</p>
<p>因为sizeof值在编译时确定，所以不能用来得到动态分配（运行时分配）存储空间的大小。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span>&#123;   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* str = <span class="string">"name"</span>;</span><br><span class="line">    <span class="keyword">sizeof</span>(str); <span class="comment">// 取的是指针str的长度，是8</span></span><br><span class="line">    <span class="built_in">strlen</span>(str); <span class="comment">// 取的是这个字符串的长度，不包含结尾的 \0。大小是4</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="常量指针和指针常量区别？"><a href="#常量指针和指针常量区别？" class="headerlink" title="常量指针和指针常量区别？"></a>常量指针和指针常量区别？</h1><p>常量指针是一个指针，读成常量的指针，指向一个只读变量。如<code>int const *p</code>或<code>const int *p</code>。</p>
<p>指针常量是一个不能给改变指向的指针。指针是个常亮，不能中途改变指向，如<code>int *const p</code>。</p>
<h1 id="a和-amp-a有什么区别？"><a href="#a和-amp-a有什么区别？" class="headerlink" title="a和&amp;a有什么区别？"></a>a和&amp;a有什么区别？</h1><p>假设数组<code>int a[10];</code><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> (*p)[<span class="number">10</span>] = &amp;a;</span><br></pre></td></tr></table></figure></p>
<p>a是数组名，是数组首元素地址，+1表示地址值加上一个int类型的大小，如果a的值是0x00000001，加1操作后变为0x00000005。<code>*(a + 1) = a[1]</code>。</p>
<p>&amp;a是数组的指针，其类型为<code>int (*)[10]</code>（就是前面提到的数组指针），其加1时，系统会认为是数组首地址加上整个数组的偏移（10个int型变量），值为数组a尾元素后一个元素的地址。</p>
<p>若<code>(int *)p</code>，此时输出<code>*p</code>时，其值为<code>a[0]</code>的值，因为被转为<code>int *</code>类型，解引用时按照int类型大小来读取。</p>
<h1 id="数组名和指针（这里为指向数组首元素的指针）区别？"><a href="#数组名和指针（这里为指向数组首元素的指针）区别？" class="headerlink" title="数组名和指针（这里为指向数组首元素的指针）区别？"></a>数组名和指针（这里为指向数组首元素的指针）区别？</h1><p>二者均可通过增减偏移量来访问数组中的元素。</p>
<p>数组名不是真正意义上的指针，可以理解为常指针，所以数组名没有# 自减等操作。</p>
<p>当数组名当做形参传递给调用函数后，就失去了原有特性，退化成一般指针，多了# 自减操作，但sizeof运算符不能再得到原数组的大小了。</p>
<h1 id="野指针和悬空指针"><a href="#野指针和悬空指针" class="headerlink" title="野指针和悬空指针"></a>野指针和悬空指针</h1><p>都是是指向无效内存区域(这里的无效指的是”不安全不可控”)的指针，访问行为将会导致未定义行为。</p>
<p>野指针，指的是没有被初始化过的指针<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123; </span><br><span class="line">  <span class="keyword">int</span> * p;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;*p&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因此，为了防止出错，对于指针初始化时都是赋值为 nullptr，这样在使用时编译器就会直接报错，产生非法内存访问。</p>
<p>悬空指针，指针最初指向的内存已经被释放了的一种指针。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123; </span><br><span class="line">  <span class="keyword">int</span> * p = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">int</span>* p2 = <span class="keyword">new</span> <span class="keyword">int</span>; </span><br><span class="line">  p = p2;</span><br><span class="line">  <span class="keyword">delete</span> p2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此时 p和p2就是悬空指针，指向的内存已经被释放。继续使用这两个指针，行为不可预料。需要设置为p=p2=nullptr。此时再使用，编译器会直接保错。</p>
<p>避免野指针比较简单，但悬空指针比较麻烦。c++引入了智能指针，C++智能指针的本质就是避免悬空指针的产生。</p>
<p>产生原因及解决办法：</p>
<p>野指针：指针变量未及时初始化 =&gt; 定义指针变量及时初始化，要么置空。</p>
<p>悬空指针：指针free或delete之后没有及时置空 =&gt; 释放操作后立即置空。</p>
<h1 id="迭代器失效的情况"><a href="#迭代器失效的情况" class="headerlink" title="迭代器失效的情况"></a>迭代器失效的情况</h1><p>以vector为例：</p>
<p>插入元素：</p>
<ul>
<li>尾后插入：size &lt; capacity时，首迭代器不失效尾迭代失效（未重新分配空间），size == capacity时，所有迭代器均失效（需要重新分配空间）。</li>
<li>中间插入：中间插入：size &lt; capacity时，首迭代器不失效但插入元素之后所有迭代器失效，size == capacity时，所有迭代器均失效。</li>
</ul>
<p>删除元素：</p>
<ul>
<li>尾后删除：只有尾迭代失效。</li>
<li>中间删除：删除位置之后所有迭代失效。</li>
</ul>
<h1 id="C和C-的区别"><a href="#C和C-的区别" class="headerlink" title="C和C++的区别"></a>C和C++的区别</h1><ul>
<li>C++中new和delete是对内存分配的运算符，取代了C中的malloc和free。</li>
<li>标准C++中的字符串类取代了标准C函数库头文件中的字符数组处理函数（C中没有字符串类型）。</li>
<li>C++中用来做控制态输入输出的iostream类库替代了标准C中的stdio函数库。</li>
<li>C++中的try/catch/throw异常处理机制取代了标准C中的setjmp()和longjmp()函数。</li>
<li>在C++中，允许有相同的函数名，不过它们的参数类型不能完全相同，这样这些函数就可以相互区别开来。而这在C语言中是不允许的。也就是C++可以重载，C语言不允许。</li>
<li>C++语言中，允许变量定义语句在程序中的任何地方，只要在是使用它之前就可以；而C语言中，必须要在函数开头部分。而且C++允许重复定义变量，C语言也是做不到这一点的</li>
<li>在C++中，除了值和指针之外，新增了引用。引用型变量是其他变量的一个别名，我们可以认为他们只是名字不相同，其他都是相同的。</li>
<li>C++相对与C增加了一些关键字，如：bo# usi# dynamic_ca# namespace等等</li>
</ul>
<h1 id="C-中struct和class的区别"><a href="#C-中struct和class的区别" class="headerlink" title="C++中struct和class的区别"></a>C++中struct和class的区别</h1><p>相同点：</p>
<ul>
<li>两者都拥有成员# 公有和私有部分</li>
<li>任何可以使用class完成的工作，同样可以使用struct完成</li>
</ul>
<p>不同点</p>
<ul>
<li>两者中如果不对成员不指定公私有，struct默认是公有的，class则默认是私有的</li>
<li>class默认是private继承，而struct模式是public继承</li>
<li>class可以作为模板类型，struct不行</li>
</ul>
<p>引申：C++和C的struct区别</p>
<p>C语言中：struct是用户自定义数据类型（UDT）；C++中struct是抽象数据类型（ADT），支持成员函数的定义，（C++中的struct能继承，能实现多态）</p>
<p>C中struct是没有权限的设置的，且struct中只能是一些变量的集合体，可以封装数据却不可以隐藏数据，而且成员不可以是函数</p>
<p>C++中，struct增加了访问权限，且可以和类一样有成员函数，成员默认访问说明符为public（为了与C兼容）</p>
<p>struct作为类的一种特例是用来自定义数据结构的。一个结构标记声明后，在C中必须在结构标记前加上struct，才能做结构类型名（除：typedef struct class{};）;C++中结构体标记（结构体名）可以直接作为结构体类型名使用，此外结构体struct在C++中被当作类的一种特例</p>
<h1 id="define宏定义和const的区别"><a href="#define宏定义和const的区别" class="headerlink" title="define宏定义和const的区别"></a>define宏定义和const的区别</h1><p>编译阶段</p>
<p>define是在编译的预处理阶段起作用，而const是在# 运行的时候起作用</p>
<p>安全性</p>
<p>define只做替换，不做类型检查和计算，也不求解，容易产生错误，一般最好加上一个大括号包含住全部的内容，要不然很容易出错</p>
<p>const常量有数据类型，编译器可以对其进行类型安全检查</p>
<p>内存占用</p>
<p>define只是将宏名称进行替换，在内存中会产生多分相同的备份。const在程序运行中只有一份备份，且可以执行常量折叠，能将复杂的的表达式计算出结果放入常量表</p>
<p>宏替换发生在编译阶段之前，属于文本插入替换；const作用发生于编译过程中。</p>
<p>宏不检查类型；const会检查数据类型。</p>
<p>宏定义的数据没有分配内存空间，只是插入替换掉；const定义的变量只是值不能改变，但要分配内存空间。</p>
<h1 id="C-中const和static的作用"><a href="#C-中const和static的作用" class="headerlink" title="C++中const和static的作用"></a>C++中const和static的作用</h1><p>static</p>
<p>不考虑类的情况</p>
<p>隐藏。所有不加static的全局变量和函数具有全局可见性，可以在其他文件中使用，加了之后只能在该文件所在的编译模块中使用</p>
<p>默认初始化为0，包括未初始化的全局静态变量与局部静态变量，都存在全局未初始化区</p>
<p>静态变量在函数内定义，始终存在，且只进行一次初始化，具有记忆性，其作用范围与局部变量相同，函数退出后仍然存在，但不能使用</p>
<p>考虑类的情况</p>
<p>static成员变量：只与类关联，不与类的对象关联。定义时要分配空间，不能在类声明中初始化，必须在类定义体外部初始化，初始化时不需要标示为static；可以被非static成员函数任意访问。</p>
<p>static成员函数：不具有this指针，无法访问类对象的非static成员变量和非static成员函数；不能被声明为con# 虚函数和volatile；可以被非static成员函数任意访问</p>
<p>const</p>
<p>不考虑类的情况</p>
<p>const常量在定义时必须初始化，之后无法更改</p>
<p>const形参可以接收const和非const类型的实参，例如<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// i 可以是 int 型或者 const int 型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; i)</span></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>考虑类的情况</p>
<ul>
<li>const成员变量：不能在类定义外部初始化，只能通过构造函数初始化列表进行初始化，并且必须有构造函数；不同类对其const数据成员的值可以不同，所以不能在类中声明时初始化</li>
<li>const成员函数：const对象不可以调用非const成员函数；非const对象都可以调用；不可以改变非mutable（用该关键字声明的变量可以在const成员函数中被修改）数据的值</li>
</ul>
<h1 id="C-的顶层const和底层const"><a href="#C-的顶层const和底层const" class="headerlink" title="C++的顶层const和底层const"></a>C++的顶层const和底层const</h1><p>概念区分</p>
<ul>
<li>顶层const：指的是const修饰的变量本身是一个常量，无法修改，指的是指针，就是 * 号的右边</li>
<li>底层const：指的是const修饰的变量所指向的对象是一个常量，指的是所指变量，就是 * 号的左边</li>
</ul>
<p>举个例子<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span>* <span class="keyword">const</span> b1 = &amp;a;        <span class="comment">//顶层const，b1本身是一个常量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* b2 = &amp;a;        <span class="comment">//底层const，b2本身可变，所指的对象是常量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> b3 = <span class="number">20</span>;            <span class="comment">//顶层const，b3是常量不可变</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* <span class="keyword">const</span> b4 = &amp;a;  <span class="comment">//前一个const为底层，后一个为顶层，b4不可变</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; b5 = a;           <span class="comment">//用于声明引用变量，都是底层const</span></span><br></pre></td></tr></table></figure></p>
<p>区分作用</p>
<ul>
<li>执行对象拷贝时有限制，常量的底层const不能赋值给非常量的底层const</li>
<li>使用命名的强制类型转换函数const_cast时，只能改变运算对象的底层const</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> a;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *a;</span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> a;</span><br></pre></td></tr></table></figure>
<p>int const a和const int a均表示定义常量类型a。</p>
<p><code>const int *a</code>，其中a为指向int型变量的指针，<code>const</code>在<code>*</code>左侧，表示a指向不可变常量。(看成<code>const (*a)</code>，对引用加const)</p>
<p><code>int *const a</code>，依旧是指针类型，表示a为指向整型数据的常指针。(看成const(a)，对指针const)</p>
<h1 id="类的对象存储空间？"><a href="#类的对象存储空间？" class="headerlink" title="类的对象存储空间？"></a>类的对象存储空间？</h1><p>非静态成员的数据类型大小之和。</p>
<p>编译器加入的额外成员变量（如指向虚函数表的指针）。</p>
<p>为了边缘对齐优化加入的padding。</p>
<h1 id="final和override关键字"><a href="#final和override关键字" class="headerlink" title="final和override关键字"></a>final和override关键字</h1><p>override</p>
<p>当在父类中使用了虚函数时候，你可能需要在某个子类中对这个虚函数进行重写，以下方法都可以：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>; <span class="comment">//OK</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>; <span class="comment">// OK</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> override</span>; <span class="comment">//OK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果不使用override，当你手一抖，将foo()写成了foo()会怎么样呢？结果是编译器并不会报错，因为它并不知道你的目的是重写虚函数，而是把它当成了新的函数。如果这个虚函数很重要的话，那就会对整个程序不利。所以，override的作用就出来了，它指定了子类的这个虚函数是重写的父类的，如果你名字不小心打错了的话，编译器是不会编译通过的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f00</span><span class="params">()</span></span>; <span class="comment">//OK，这个函数是B新增的，不是继承的</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f0o</span><span class="params">()</span> override</span>; <span class="comment">//Error, 加了override之后，这个函数一定是继承自A的，A找不到就报错</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>final</p>
<p>当不希望某个类被继承，或不希望某个虚函数被重写，可以在类名和虚函数后添加final关键字，添加final关键字后被继承或重写，编译器会报错。例子如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> final</span>; <span class="comment">// foo 被override并且是最后一个override，在其子类中不可以重写</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="title">final</span> :</span> A <span class="comment">// 指明B是不可以被继承的</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> override</span>; <span class="comment">// Error: 在A中已经被final了</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> B <span class="comment">// Error: B is final</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="拷贝初始化和直接初始化"><a href="#拷贝初始化和直接初始化" class="headerlink" title="拷贝初始化和直接初始化"></a>拷贝初始化和直接初始化</h1><p>当用于类类型对象时，初始化的拷贝形式和直接形式有所不同：直接初始化直接调用与实参匹配的构造函数，拷贝初始化总是调用拷贝构造函数。拷贝初始化首先使用指定构造函数创建一个临时对象，然后用拷贝构造函数将那个临时对象拷贝到正在创建的对象。举例如下</p>
<ul>
<li><code>string str1(&quot;I am a string&quot;);</code>//语句1 直接初始化</li>
<li><code>string str2(str1);</code>//语句2 直接初始化，str1是已经存在的对象，直接调用构造函数对str2进行初始化</li>
<li><code>string str3 = &quot;I am a string&quot;;</code>//语句3 拷贝初始化，先为字符串”I am a string“创建临时对象，再把临时对象作为参数，使用拷贝构造函数构造str3</li>
<li><code>string str4 = str1;</code>//语句4 拷贝初始化，这里相当于隐式调用拷贝构造函数，而不是调用赋值运算符函数</li>
</ul>
<p>为了提高效率，允许编译器跳过创建临时对象这一步，直接调用构造函数构造要创建的对象，这样就完全等价于直接初始化了（语句1和语句3等价）。但是需要辨别两种情况。</p>
<p>当拷贝构造函数为private时：语句3和语句4在编译时会报错</p>
<p>使用explicit修饰构造函数时：如果构造函数存在隐式转换，编译时会报错</p>
<h1 id="初始化和赋值的区别"><a href="#初始化和赋值的区别" class="headerlink" title="初始化和赋值的区别"></a>初始化和赋值的区别</h1><p>对于简单类型来说，初始化和赋值没什么区别</p>
<p>对于类和复杂数据类型来说，这两者的区别就大了，举例如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> num1;</span><br><span class="line">    <span class="keyword">int</span> num2;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A(<span class="keyword">int</span> a=<span class="number">0</span>, <span class="keyword">int</span> b=<span class="number">0</span>):num1(a),num2(b)&#123;&#125;;</span><br><span class="line">    A(<span class="keyword">const</span> A&amp; a)&#123;&#125;;</span><br><span class="line">    <span class="comment">//重载 = 号操作符函数</span></span><br><span class="line">    A&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> A&amp; a)&#123;</span><br><span class="line">        num1 = a.num1 + <span class="number">1</span>;</span><br><span class="line">        num2 = a.num2 + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">A <span class="title">a</span><span class="params">(<span class="number">1</span>,<span class="number">1</span>)</span></span>;</span><br><span class="line">    A a1 = a; <span class="comment">//拷贝初始化操作，调用拷贝构造函数</span></span><br><span class="line">    A b;</span><br><span class="line">    b = a;<span class="comment">//赋值操作，对象a中，num1 = 1，num2 = 1；对象b中，num1 = 2，num2 = 2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="extern”C”的用法"><a href="#extern”C”的用法" class="headerlink" title="extern”C”的用法"></a>extern”C”的用法</h1><p>为了能够正确的在C++代码中调用C语言的代码：在程序中加上extern “C”后，相当于告诉编译器这部分代码是C语言写的，因此要按照C语言进行编译，而不是C++；</p>
<p>哪些情况下使用extern “C”：<br>1.C++代码中调用C语言代码；<br>2.在C++中的头文件中使用；<br>3.在多个人协同开发时，可能有人擅长C语言，而有人擅长C++；</p>
<p>举个例子，C++中调用C代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __MY_HANDLE_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __MY_HANDLE_H__</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="keyword">result_t</span>;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">void</span>* <span class="keyword">my_handle_t</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">my_handle_t</span> create_handle(<span class="keyword">const</span> <span class="keyword">char</span>* name);</span><br><span class="line">    <span class="keyword">result_t</span> operate_on_handle(<span class="keyword">my_handle_t</span> handle);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close_handle</span><span class="params">(<span class="keyword">my_handle_t</span> handle)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>参考的blog中有一篇google code上的文章，专门写extern “C”的，有兴趣的读者不妨去看看</p>
<p>综上，总结出使用方法，在C语言的头文件中，对其外部函数只能指定为extern类型，C语言中不支持extern “C”声明，在.c文件中包含了extern “C”时会出现编译语法错误。所以使用extern “C”全部都放在于cpp程序相关文件或其头文件中。</p>
<p>总结出如下形式：</p>
<p>（1）C++调用C函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//xx.h</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//xx.c</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//xx.cpp</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line">   <span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">"xx.h"</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>（2）C调用C++函数<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//xx.h</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//xx.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//xx.c</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p>
<h1 id="模板函数和模板类的特例化"><a href="#模板函数和模板类的特例化" class="headerlink" title="模板函数和模板类的特例化"></a>模板函数和模板类的特例化</h1><p>引入原因</p>
<p>编写单一的模板，它能适应多种类型的需求，使每种类型都具有相同的功能，但对于某种特定类型，如果要实现其特有的功能，单一模板就无法做到，这时就需要模板特例化</p>
<p>定义</p>
<p>对单一模板提供的一个特殊实例，它将一个或多个模板参数绑定到特定的类型或值上</p>
<p>（1）模板函数特例化</p>
<p>必须为原函数模板的每个模板参数都提供实参，且使用关键字template后跟一个空尖括号对&lt;&gt;，表明将原模板的所有模板参数提供实参，举例如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="comment">//模板函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> T &amp;v1,<span class="keyword">const</span> T &amp;v2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(v1 &gt; v2) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(v2 &gt; v1) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//模板特例化,满足针对字符串特定的比较，要提供所有实参，这里只有一个T</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> &amp;v1,<span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> &amp;v2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(p1,p2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>本质</p>
<p>特例化的本质是实例化一个模板，而非重载它。特例化不影响参数匹配。参数匹配都以最佳匹配为原则。例如，此处如果是compare(3,5)，则调用普通的模板，若为compare(“hi”,”haha”)则调用特例化版本（因为这个cosnt char*相对于T，更匹配实参类型），注意二者函数体的语句不一样了，实现不同功能。</p>
<p>注意</p>
<p>模板及其特例化版本应该声明在同一个头文件中，且所有同名模板的声明应该放在前面，后面放特例化版本。</p>
<p>（2）类模板特例化</p>
<p>原理类似函数模板，不过在类中，我们可以对模板进行特例化，也可以对类进行部分特例化。对类进行特例化时，仍然用template&lt;&gt;表示是一个特例化版本，例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">hash</span>&lt;sales_data&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">size_t</span> <span class="keyword">operator</span>()(sales_data&amp; s);</span><br><span class="line">    <span class="comment">//里面所有T都换成特例化类型版本sales_data</span></span><br><span class="line">    <span class="comment">//按照最佳匹配原则，若T != sales_data，就用普通类模板，否则，就使用含有特定功能的特例化版本。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>类模板的部分特例化</p>
<p>不必为所有模板参数提供实参，可以指定一部分而非所有模板参数，一个类模板的部分特例化本身仍是一个模板，使用它时还必须为其特例化版本中未指定的模板参数提供实参(特例化时类名一定要和原来的模板相同，只是参数类型不同，按最佳匹配原则，哪个最匹配，就用相应的模板)</p>
<p>特例化类中的部分成员</p>
<p>可以特例化类中的部分成员函数而不是整个类，举个例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Bar</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Barst</span><span class="params">(T a)</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">void</span> Foo&lt;<span class="keyword">int</span>&gt;::Bar()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//进行int类型的特例化处理</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"我是int型特例化"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo&lt;<span class="built_in">string</span>&gt; fs;</span><br><span class="line">Foo&lt;<span class="keyword">int</span>&gt; fi;<span class="comment">//使用特例化</span></span><br><span class="line">fs.Bar();<span class="comment">//使用的是普通模板，即Foo&lt;string&gt;::Bar()</span></span><br><span class="line">fi.Bar();<span class="comment">//特例化版本，执行Foo&lt;int&gt;::Bar()</span></span><br><span class="line"><span class="comment">//Foo&lt;string&gt;::Bar()和Foo&lt;int&gt;::Bar()功能不同</span></span><br></pre></td></tr></table></figure></p>
<h1 id="C和C-的类型安全"><a href="#C和C-的类型安全" class="headerlink" title="C和C++的类型安全"></a>C和C++的类型安全</h1><p>什么是类型安全？</p>
<p>类型安全很大程度上可以等价于内存安全，类型安全的代码不会试图访问自己没被授权的内存区域。“类型安全”常被用来形容编程语言，其根据在于该门编程语言是否提供保障类型安全的机制；有的时候也用“类型安全”形容某个程序，判别的标准在于该程序是否隐含类型错误。类型安全的编程语言与类型安全的程序之间，没有必然联系。好的程序员可以使用类型不那么安全的语言写出类型相当安全的程序，相反的，差一点儿的程序员可能使用类型相当安全的语言写出类型不太安全的程序。绝对类型安全的编程语言暂时还没有。</p>
<p>（1）C的类型安全</p>
<p>C只在局部上下文中表现出类型安全，比如试图从一种结构体的指针转换成另一种结构体的指针时，编译器将会报告错误，除非使用显式类型转换。然而，C中相当多的操作是不安全的。以下是两个十分常见的例子：</p>
<p>malloc是C中进行内存分配的函数，它的返回类型是void<em>即空类型指针，常常有这样的用法`char</em> pStr=(char<em>)malloc(100</em>sizeof(char))<code>，这里明显做了显式的类型转换。类型匹配尚且没有问题，但是一旦出现</code>int<em> pInt=(int</em>)malloc(100*sizeof(char))`就很可能带来一些问题，而这样的转换C并不会提示错误。</p>
<p>（2）C++的类型安全</p>
<p>如果C++使用得当，它将远比C更有类型安全性。相比于C语言，C++提供了一些新的机制保障类型安全：</p>
<ul>
<li>操作符new返回的指针类型严格与对象匹配，而不是void*</li>
<li>C中很多以void*为参数的函数可以改写为C++模板函数，而模板是支持类型检查的；</li>
<li>引入const关键字代替define constants，它是有类型有作用域的，define constants只是简单的文本替换</li>
<li>define宏可被改写为inline函数，结合函数的重载，可在类型安全的前提下支持多种类型，当然改写为模板也能保证类型安全</li>
</ul>
<p>C++提供了dynamic_cast关键字，使得转换过程更加安全，因为dynamic_cast比static_cast涉及更多具体的类型检查。</p>
<p>例1：不同类型指针之间转换<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span>&#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child1</span> :</span> <span class="keyword">public</span> Parent</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    Child1(<span class="keyword">int</span> e):i(e)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child2</span> :</span> <span class="keyword">public</span> Parent</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">double</span> d;</span><br><span class="line">    Child2(<span class="keyword">double</span> e):d(e)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Child1 <span class="title">c1</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    <span class="function">Child2 <span class="title">c2</span><span class="params">(<span class="number">4.1</span>)</span></span>;</span><br><span class="line">    Parent* pp;</span><br><span class="line">    Child1* pc1;</span><br><span class="line"></span><br><span class="line">    pp=&amp;c1; </span><br><span class="line">    pc1=(Child1*)pp;  <span class="comment">// 类型向下转换 强制转换，由于类型仍然为Child1*，不造成错误</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;pc1-&gt;i&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//输出：5</span></span><br><span class="line"></span><br><span class="line">    pp=&amp;c2;</span><br><span class="line">    pc1=(Child1*)pp;  <span class="comment">//强制转换，且类型发生变化，将造成错误</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;pc1-&gt;i&lt;&lt;<span class="built_in">endl</span>;<span class="comment">// 输出：1717986918</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面两个例子之所以引起类型不安全的问题，是因为程序员使用不得当。第一个例子用到了空类型指针void<em>，第二个例子则是在两个类型指针之间进行强制转换。因此，想保证程序的类型安全性，应尽量避免使用空类型指针void</em>，尽量不对两种类型指针做强制转换。</p>
<h1 id="为什么析构函数一般写成虚函数"><a href="#为什么析构函数一般写成虚函数" class="headerlink" title="为什么析构函数一般写成虚函数"></a>为什么析构函数一般写成虚函数</h1><p>由于类的多态性，基类指针可以指向派生类的对象，如果删除该基类的指针，就会调用该指针指向的派生类析构函数，而派生类的析构函数又自动调用基类的析构函数，这样整个派生类的对象完全被释放。如果析构函数不被声明成虚函数，则编译器实施静态绑定，在删除基类指针时，只会调用基类的析构函数而不调用派生类析构函数，这样就会造成派生类对象析构不完全，造成内存泄漏。所以将析构函数声明为虚函数是十分必要的。在实现多态时，当用基类操作派生类，在析构时防止只析构基类而不析构派生类的状况发生，要将基类的析构函数声明为虚函数。举个例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Parent()&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Parent construct function"</span>  &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    ~Parent()&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Parent destructor function"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span> <span class="keyword">public</span> Parent&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Son()&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Son construct function"</span>  &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    ~Son()&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Son destructor function"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Parent* p = <span class="keyword">new</span> Son();</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果：</span></span><br><span class="line"><span class="comment">//Parent construct function</span></span><br><span class="line"><span class="comment">//Son construct function</span></span><br><span class="line"><span class="comment">//Parent destructor function</span></span><br></pre></td></tr></table></figure></p>
<p>将基类的析构函数声明为虚函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Parent()&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Parent construct function"</span>  &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">virtual</span> ~Parent()&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Parent destructor function"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span> <span class="keyword">public</span> Parent&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Son()&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Son construct function"</span>  &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    ~Son()&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Son destructor function"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Parent* p = <span class="keyword">new</span> Son();</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果：</span></span><br><span class="line"><span class="comment">//Parent construct function</span></span><br><span class="line"><span class="comment">//Son construct function</span></span><br><span class="line"><span class="comment">//Son destructor function</span></span><br><span class="line"><span class="comment">//Parent destructor function</span></span><br></pre></td></tr></table></figure></p>
<h1 id="构造函数能否声明为虚函数或者纯虚函数，析构函数呢？"><a href="#构造函数能否声明为虚函数或者纯虚函数，析构函数呢？" class="headerlink" title="构造函数能否声明为虚函数或者纯虚函数，析构函数呢？"></a>构造函数能否声明为虚函数或者纯虚函数，析构函数呢？</h1><p>析构函数：</p>
<p>析构函数可以为虚函数，并且一般情况下基类析构函数要定义为虚函数。</p>
<p>只有在基类析构函数定义为虚函数时，调用操作符delete销毁指向对象的基类指针时，才能准确调用派生类的析构函数（从该级向上按序调用虚函数），才能准确销毁数据。</p>
<p>析构函数可以是纯虚函数，含有纯虚函数的类是抽象类，此时不能被实例化。但派生类中可以根据自身需求重新改写基类中的纯虚函数。</p>
<p>构造函数：</p>
<p>构造函数不能定义为虚函数。在构造函数中可以调用虚函数，不过此时调用的是正在构造的类中的虚函数，而不是子类的虚函数，因为此时子类尚未构造好。</p>
<h1 id="C-中的重写（覆盖）和隐藏的区别"><a href="#C-中的重写（覆盖）和隐藏的区别" class="headerlink" title="C++中的重写（覆盖）和隐藏的区别"></a>C++中的重写（覆盖）和隐藏的区别</h1><p>（1）重载（overload）</p>
<p>重载是指在同一范围定义中的同名成员函数才存在重载关系。主要特点是函数名相同，参数类型和数目有所不同，不能出现参数个数和类型均相同，仅仅依靠返回值不同来区分的函数。重载和函数成员是否是虚函数无关。举个例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">fun</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">double</span>, <span class="keyword">double</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">char</span>)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>（2）重写（覆盖）（override）</p>
<p>重写指的是在派生类中覆盖基类中的同名函数，重写就是重写函数体，要求基类函数必须是虚函数且：</p>
<p>与基类的虚函数有相同的参数个数</p>
<p>与基类的虚函数有相同的参数类型</p>
<p>与基类的虚函数有相同的返回值类型</p>
<p>举个例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//重写,一般加override可以确保是重写父类的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> a)</span> override</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>重载与重写的区别：</p>
<p>重写是父类和子类之间的垂直关系，重载是不同函数之间的水平关系</p>
<p>重写要求参数列表相同，重载则要求参数列表不同，返回值不要求</p>
<p>重写关系中，调用方法根据对象类型决定，重载根据调用时实参表与形参表的对应关系来选择函数体</p>
<p>（3）隐藏（hide）</p>
<p>隐藏指的是某些情况下，派生类中的函数屏蔽了基类中的同名函数，包括以下情况：</p>
<p>两个函数参数相同，但是基类函数不是虚函数。和重写的区别在于基类函数是否是虚函数。举个例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"A中的fun函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//隐藏父类的fun函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"B中的fun函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    B b;</span><br><span class="line">    b.fun(<span class="number">2</span>); <span class="comment">//调用的是B中的fun函数</span></span><br><span class="line">    b.A::fun(<span class="number">2</span>); <span class="comment">//调用A中fun函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>两个函数参数不同，无论基类函数是不是虚函数，都会被隐藏。和重载的区别在于两个函数不在同一个类中。举个例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"A中的fun函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//隐藏父类的fun函数</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">char</span>* a)</span></span>&#123;</span><br><span class="line">       <span class="built_in">cout</span> &lt;&lt; <span class="string">"A中的fun函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    B b;</span><br><span class="line">    b.fun(<span class="number">2</span>); <span class="comment">//报错，调用的是B中的fun函数，参数类型不对</span></span><br><span class="line">    b.A::fun(<span class="number">2</span>); <span class="comment">//调用A中fun函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="C-的多态如何实现"><a href="#C-的多态如何实现" class="headerlink" title="C++的多态如何实现"></a>C++的多态如何实现</h1><p>C++的多态性，一言以蔽之就是：</p>
<p>在基类的函数前加上virtual关键字，在派生类中重写该函数，运行时将会根据所指对象的实际类型来调用相应的函数，如果对象类型是派生类，就调用派生类的函数，如果对象类型是基类，就调用基类的函数。</p>
<p>举个例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">" Base::func()"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son1</span> :</span> <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> override</span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">" Son1::func()"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son2</span> :</span> <span class="keyword">public</span> Base&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base* base = <span class="keyword">new</span> Son1;</span><br><span class="line">    base-&gt;fun();</span><br><span class="line">    base = <span class="keyword">new</span> Son2;</span><br><span class="line">    base-&gt;fun();</span><br><span class="line">    <span class="keyword">delete</span> base;</span><br><span class="line">    base = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line"><span class="comment">// Son1::func()</span></span><br><span class="line"><span class="comment">// Base::func()</span></span><br></pre></td></tr></table></figure></p>
<p>例子中，Base为基类，其中的函数为虚函数。子类1继承并重写了基类的函数，子类2继承基类但没有重写基类的函数，从结果分析子类体现了多态性，那么为什么会出现多态性，其底层的原理是什么？这里需要引出虚表和虚基表指针的概念。</p>
<p>虚表：虚函数表的缩写，类中含有virtual关键字修饰的方法时，编译器会自动生成虚表</p>
<p>虚表指针：在含有虚函数的类实例化对象时，对象地址的前四个字节存储的指向虚表的指针</p>
<p>(1)编译器在发现基类中有虚函数时，会自动为每个含有虚函数的类生成一份虚表，该表是一个一维数组，虚表里保存了虚函数的入口地址</p>
<p>(2)编译器会在每个对象的前四个字节中保存一个虚表指针，即vptr，指向对象所属类的虚表。在构造时，根据对象的类型去初始化虚指针vptr，从而让vptr指向正确的虚表，从而在调用虚函数时，能找到正确的函数</p>
<p>(3)所谓的合适时机，在派生类定义对象时，程序运行会自动调用构造函数，在构造函数中创建虚表并对虚表初始化。在构造子类对象时，会先调用父类的构造函数，此时，编译器只“看到了”父类，并为父类对象初始化虚表指针，令它指向父类的虚表；当调用子类的构造函数时，为子类对象初始化虚表指针，令它指向子类的虚表</p>
<p>(4)当派生类对基类的虚函数没有重写时，派生类的虚表指针指向的是基类的虚表；当派生类对基类的虚函数重写时，派生类的虚表指针指向的是自身的虚表；当派生类中有自己的虚函数时，在自己的虚表中将此虚函数地址添加在后面</p>
<p>这样指向派生类的基类指针在运行时，就可以根据派生类对虚函数重写情况动态的进行调用，从而实现多态性。</p>
<h1 id="C-有哪几种的构造函数"><a href="#C-有哪几种的构造函数" class="headerlink" title="C++有哪几种的构造函数"></a>C++有哪几种的构造函数</h1><p>C++中的构造函数可以分为4类：</p>
<ul>
<li>默认构造函数</li>
<li>初始化构造函数（有参数）</li>
<li>拷贝构造函数</li>
<li>移动构造函数（move和右值引用）</li>
<li>委托构造函数</li>
<li>转换构造函数</li>
</ul>
<p>举个例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Student()&#123;<span class="comment">//默认构造函数，没有参数</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;age = <span class="number">20</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;num = <span class="number">1000</span>;</span><br><span class="line">    &#125;;  </span><br><span class="line">    Student(<span class="keyword">int</span> a, <span class="keyword">int</span> n):age(a), num(n)&#123;&#125;; <span class="comment">//初始化构造函数，有参数和参数列表</span></span><br><span class="line">    Student(<span class="keyword">const</span> Student&amp; s)&#123;<span class="comment">//拷贝构造函数，这里与编译器生成的一致</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;age = s.age;</span><br><span class="line">        <span class="keyword">this</span>-&gt;num = s.num;</span><br><span class="line">    &#125;; </span><br><span class="line">    Student(<span class="keyword">int</span> r)&#123;   <span class="comment">//转换构造函数,形参是其他类型变量，且只有一个形参</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;age = r;</span><br><span class="line">        <span class="keyword">this</span>-&gt;num = <span class="number">1002</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    ~Student()&#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Student s1;</span><br><span class="line">    <span class="function">Student <span class="title">s2</span><span class="params">(<span class="number">18</span>,<span class="number">1001</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="function">Student <span class="title">s3</span><span class="params">(a)</span></span>;</span><br><span class="line">    <span class="function">Student <span class="title">s4</span><span class="params">(s3)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"s1 age:%d, num:%d\n"</span>, s1.age, s1.num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"s2 age:%d, num:%d\n"</span>, s2.age, s2.num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"s3 age:%d, num:%d\n"</span>, s3.age, s3.num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"s2 age:%d, num:%d\n"</span>, s4.age, s4.num);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果</span></span><br><span class="line"><span class="comment">//s1 age:20, num:1000</span></span><br><span class="line"><span class="comment">//s2 age:18, num:1001</span></span><br><span class="line"><span class="comment">//s3 age:10, num:1002</span></span><br><span class="line"><span class="comment">//s2 age:10, num:1002</span></span><br></pre></td></tr></table></figure></p>
<p>默认构造函数和初始化构造函数在定义类的对象，完成对象的初始化工作</p>
<p>复制构造函数用于复制本类的对象</p>
<p>转换构造函数用于将其他类型的变量，隐式转换为本类对象</p>
<h1 id="浅拷贝和深拷贝的区别"><a href="#浅拷贝和深拷贝的区别" class="headerlink" title="浅拷贝和深拷贝的区别"></a>浅拷贝和深拷贝的区别</h1><p>浅拷贝</p>
<p>浅拷贝只是拷贝一个指针，并没有新开辟一个地址，拷贝的指针和原来的指针指向同一块地址，如果原来的指针所指向的资源释放了，那么再释放浅拷贝的指针的资源就会出现错误。</p>
<p>深拷贝</p>
<p>深拷贝不仅拷贝值，还开辟出一块新的空间用来存放新的值，即使原先的对象被析构掉，释放内存了也不会影响到深拷贝得到的值。在自己实现拷贝赋值的时候，如果有指针变量的话是需要自己实现深拷贝的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Student()&#123;</span><br><span class="line">        name = <span class="keyword">new</span> <span class="keyword">char</span>(<span class="number">20</span>);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Student"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    ~Student()&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"~Student "</span> &lt;&lt; &amp;name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">delete</span> name;</span><br><span class="line">        name = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    Student(<span class="keyword">const</span> Student &amp;s)&#123;<span class="comment">//拷贝构造函数</span></span><br><span class="line">        <span class="comment">//浅拷贝，当对象的name和传入对象的name指向相同的地址</span></span><br><span class="line">        name = s.name;</span><br><span class="line">        <span class="comment">//深拷贝</span></span><br><span class="line">        <span class="comment">//name = new char(20);</span></span><br><span class="line">        <span class="comment">//memcpy(name, s.name, strlen(s.name));</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"copy Student"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    &#123;<span class="comment">// 花括号让s1和s2变成局部对象，方便测试</span></span><br><span class="line">        Student s1;</span><br><span class="line">        <span class="function">Student <span class="title">s2</span><span class="params">(s1)</span></span>;<span class="comment">// 复制对象</span></span><br><span class="line">    &#125;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//浅拷贝执行结果：</span></span><br><span class="line"><span class="comment">//Student</span></span><br><span class="line"><span class="comment">//copy Student</span></span><br><span class="line"><span class="comment">//~Student 0x7fffed0c3ec0</span></span><br><span class="line"><span class="comment">//~Student 0x7fffed0c3ed0</span></span><br><span class="line"><span class="comment">//*** Error in `/tmp/815453382/a.out': double free or corruption (fasttop): 0x0000000001c82c20 ***</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//深拷贝执行结果：</span></span><br><span class="line"><span class="comment">//Student</span></span><br><span class="line"><span class="comment">//copy Student</span></span><br><span class="line"><span class="comment">//~Student 0x7fffebca9fb0</span></span><br><span class="line"><span class="comment">//~Student 0x7fffebca9fc0</span></span><br></pre></td></tr></table></figure></p>
<p>从执行结果可以看出，浅拷贝在对象的拷贝创建时存在风险，即被拷贝的对象析构释放资源之后，拷贝对象析构时会再次释放一个已经释放的资源，深拷贝的结果是两个对象之间没有任何关系，各自成员地址不同。</p>
<h1 id="内联函数和宏定义的区别"><a href="#内联函数和宏定义的区别" class="headerlink" title="内联函数和宏定义的区别"></a>内联函数和宏定义的区别</h1><p>内联(inline)函数和普通函数相比可以加快程序运行的速度，因为不需要中断调用，在编译的时候内联函数可以直接嵌入到目标代码中。</p>
<p>内联函数适用场景</p>
<p>使用宏定义的地方都可以使用inline函数</p>
<p>作为类成员接口函数来读写类的私有成员或者保护成员，会提高效率</p>
<p>为什么不能把所有的函数写成内联函数</p>
<p>内联函数以代码复杂为代价，它以省去函数调用的开销来提高执行效率。所以一方面如果内联函数体内代码执行时间相比函数调用开销较大，则没有太大的意义；另一方面每一处内联函数的调用都要复制代码，消耗更多的内存空间，因此以下情况不宜使用内联函数：</p>
<p>函数体内的代码比较长，将导致内存消耗代价</p>
<p>函数体内有循环，函数执行时间要比函数调用开销大</p>
<p>主要区别</p>
<ul>
<li>内联函数在编译时展开，宏在预编译时展开</li>
<li>内联函数直接嵌入到目标代码中，宏是简单的做文本替换</li>
<li>内联函数有类型# 语法判断等功能，而宏没有</li>
<li>内联函数是函数，宏不是</li>
</ul>
<p>宏定义时要注意书写（参数要括起来）否则容易出现歧义，内联函数不会产生歧义</p>
<p>内联函数代码是被放到符号表中，使用时像宏一样展开，没有调用的开销，效率很高；</p>
<p>在使用时，宏只做简单字符串替换（编译前）。而内联函数可以进行参数类型检查（编译时），且具有返回值。</p>
<p>内联函数本身是函数，强调函数特性，具有重载等功能。</p>
<p>内联函数可以作为某个类的成员函数，这样可以使用类的保护成员和私有成员，进而提升效率。而当一个表达式涉及到类保护成员或私有成员时，宏就不能实现了。</p>
<h1 id="构造-析构-虚函数可否声明为内联函数"><a href="#构造-析构-虚函数可否声明为内联函数" class="headerlink" title="构造# 析构# 虚函数可否声明为内联函数"></a>构造# 析构# 虚函数可否声明为内联函数</h1><p>首先，将这些函数声明为内联函数，在语法上没有错误。因为inline同register一样，只是个建议，编译器并不一定真正的内联。</p>
<p>register关键字：这个关键字请求编译器尽可能的将变量存在CPU内部寄存器中，而不是通过内存寻址访问，以提高效率</p>
<p>举个例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="title">A</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"inline construct()"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">inline</span> ~A() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"inline destruct()"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">virtual</span> <span class="keyword">void</span>  <span class="title">virtualFun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"inline virtual function"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    a.virtualFun();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="comment">//inline construct()</span></span><br><span class="line"><span class="comment">//inline virtual function</span></span><br><span class="line"><span class="comment">//inline destruct()</span></span><br></pre></td></tr></table></figure></p>
<p>构造函数和析构函数声明为内联函数是没有意义的</p>
<p>《Effective C++》中所阐述的是：将构造函数和析构函数声明为inline是没有什么意义的，即编译器并不真正对声明为inline的构造和析构函数进行内联操作，因为编译器会在构造和析构函数中添加额外的操作（申请/释放内存，构造/析构对象等），致使构造函数/析构函数并不像看上去的那么精简。其次，class中的函数默认是inline型的，编译器也只是有选择性的inline，将构造函数和析构函数声明为内联函数是没有什么意义的。</p>
<p>将虚函数声明为inline，要分情况讨论</p>
<p>有的人认为虚函数被声明为inline，但是编译器并没有对其内联，他们给出的理由是inline是编译期决定的，而虚函数是运行期决定的，即在不知道将要调用哪个函数的情况下，如何将函数内联呢？</p>
<p>上述观点看似正确，其实不然，如果虚函数在编译器就能够决定将要调用哪个函数时，就能够内联，那么什么情况下编译器可以确定要调用哪个函数呢，答案是当用对象调用虚函数（此时不具有多态性）时，就内联展开</p>
<p>综上，当是指向派生类的指针（多态性）调用声明为inline的虚函数时，不会内联展开；当是对象本身调用虚函数时，会内联展开，当然前提依然是函数并不复杂的情况下</p>
<h1 id="auto-decltype和decltype-auto-的用法"><a href="#auto-decltype和decltype-auto-的用法" class="headerlink" title="auto decltype和decltype(auto)的用法"></a>auto decltype和decltype(auto)的用法</h1><p>（1）auto</p>
<p>C++11新标准引入了auto类型说明符，用它就能让编译器替我们去分析表达式所属的类型。和原来那些只对应某种特定的类型说明符(例如 int)不同，</p>
<p>auto 让编译器通过初始值来进行类型推演。从而获得定义变量的类型，所以说 auto 定义的变量必须有初始值。举个例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//普通；类型</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">auto</span> c = a + b;<span class="comment">// c为int型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//const类型</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">auto</span> j = i; <span class="comment">// 变量i是顶层const, 会被忽略, 所以j的类型是int</span></span><br><span class="line"><span class="keyword">auto</span> k = &amp;i; <span class="comment">// 变量i是一个常量, 对常量取地址是一种底层const, 所以b的类型是const int*</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> l = i; <span class="comment">//如果希望推断出的类型是顶层const的, 那么就需要在auto前面加上cosnt</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//引用和指针类型</span></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span>&amp; y = x;</span><br><span class="line"><span class="keyword">auto</span> z = y; <span class="comment">//z是int型不是int&amp; 型</span></span><br><span class="line"><span class="keyword">auto</span>&amp; p1 = y; <span class="comment">//p1是int&amp;型</span></span><br><span class="line"><span class="keyword">auto</span> p2 = &amp;x; <span class="comment">//p2是指针类型int*</span></span><br></pre></td></tr></table></figure></p>
<p>（2）decltype</p>
<p>有的时候我们还会遇到这种情况，我们希望从表达式中推断出要定义变量的类型，但却不想用表达式的值去初始化变量。还有可能是函数的返回类型为某表达式的值类型。在这些时候auto显得就无力了，所以C++11又引入了第二种类型说明符decltype，它的作用是选择并返回操作数的数据类型。在此过程中，编译器只是分析表达式并得到它的类型，却不进行实际的计算表达式的值。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//普通类型</span></span><br><span class="line"><span class="keyword">decltype</span>(func()) sum = <span class="number">5</span>; <span class="comment">// sum的类型是函数func()的返回值的类型int, 但是这时不会实际调用函数func()</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">decltype</span>(a) b = <span class="number">4</span>; <span class="comment">// a的类型是int, 所以b的类型也是int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//不论是顶层const还是底层const, decltype都会保留   </span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> c = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">decltype</span>(c) d = c; <span class="comment">// d的类型和c是一样的, 都是顶层const</span></span><br><span class="line"><span class="keyword">int</span> e = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* f = &amp;e; <span class="comment">// f是底层const</span></span><br><span class="line"><span class="keyword">decltype</span>(f) g = f; <span class="comment">// g也是底层const</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//引用与指针类型</span></span><br><span class="line"><span class="comment">//1. 如果表达式是引用类型, 那么decltype的类型也是引用</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> i = <span class="number">3</span>, &amp;j = i;</span><br><span class="line"><span class="keyword">decltype</span>(j) k = <span class="number">5</span>; <span class="comment">// k的类型是 const int&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 如果表达式是引用类型, 但是想要得到这个引用所指向的类型, 需要修改表达式:</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">3</span>, &amp;r = i;</span><br><span class="line"><span class="keyword">decltype</span>(r + <span class="number">0</span>) t = <span class="number">5</span>; <span class="comment">// 此时是int类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 对指针的解引用操作返回的是引用类型</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">3</span>, j = <span class="number">6</span>, *p = &amp;i;</span><br><span class="line"><span class="keyword">decltype</span>(*p) c = j; <span class="comment">// c是int&amp;类型, c和j绑定在一起</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//4. 如果一个表达式的类型不是引用, 但是我们需要推断出引用, 那么可以加上一对括号, 就变成了引用类型了</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">decltype</span>((i)) j = i; <span class="comment">// 此时j的类型是int&amp;类型, j和i绑定在了一起</span></span><br></pre></td></tr></table></figure></p>
<p>（3）decltype(auto)</p>
<p>decltype(auto)是C++14新增的类型指示符，可以用来声明变量以及指示函数返回类型。在使用时，会将“=”号左边的表达式替换掉auto，再根据decltype的语法规则来确定类型。举个例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> e = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* f = &amp;e; <span class="comment">// f是底层const</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) j = f;<span class="comment">//j的类型是const int* 并且指向的是e</span></span><br></pre></td></tr></table></figure></p>
<h1 id="public，protected和private访问和继承权限-public-protected-private的区别？"><a href="#public，protected和private访问和继承权限-public-protected-private的区别？" class="headerlink" title="public，protected和private访问和继承权限/public/protected/private的区别？"></a>public，protected和private访问和继承权限/public/protected/private的区别？</h1><p>public的变量和函数在类的内部外部都可以访问。</p>
<p>protected的变量和函数只能在类的内部和其派生类中访问。</p>
<p>private修饰的元素只能在类内访问。</p>
<p>（一）访问权限</p>
<p>派生类可以继承基类中除了构造/# 赋值运算符重载函数之外的成员，但是这些成员的访问属性在派生过程中也是可以调整的，三种派生方式的访问权限如下表所示：注意外部访问并不是真正的外部访问，而是在通过派生类的对象对基类成员的访问。</p>
<p>派生类对基类成员的访问形象有如下两种：</p>
<p>内部访问：由派生类中新增的成员函数对从基类继承来的成员的访问</p>
<p>外部访问：在派生类外部，通过派生类的对象对从基类继承来的成员的访问</p>
<p>（二）继承权限</p>
<p>public继承</p>
<p>公有继承的特点是基类的公有成员和保护成员作为派生类的成员时，都保持原有的状态，而基类的私有成员任然是私有的，不能被这个派生类的子类所访问</p>
<p>protected继承</p>
<p>保护继承的特点是基类的所有公有成员和保护成员都成为派生类的保护成员，并且只能被它的派生类成员函数或友元函数访问，基类的私有成员仍然是私有的.</p>
<p>private继承</p>
<p>私有继承的特点是基类的所有公有成员和保护成员都成为派生类的私有成员，并不被它的派生类的子类所访问，基类的成员只能由自己派生类访问，无法再往下继承</p>
<h1 id="如何用代码判断大小端存储"><a href="#如何用代码判断大小端存储" class="headerlink" title="如何用代码判断大小端存储"></a>如何用代码判断大小端存储</h1><p>大端存储：字数据的高字节存储在低地址中</p>
<p>小端存储：字数据的低字节存储在低地址中</p>
<p>例如：32bit的数字0x12345678</p>
<p>所以在Socket编程中，往往需要将操作系统所用的小端存储的IP地址转换为大端存储，这样才能进行网络传输</p>
<p>了解了大小端存储的方式，如何在代码中进行判断呢？下面介绍两种判断方式：</p>
<p>方式一：使用强制类型转换-这种法子不错<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0x1234</span>;</span><br><span class="line">    <span class="comment">//由于int和char的长度不同，借助int型转换成char型，只会留下低地址的部分</span></span><br><span class="line">    <span class="keyword">char</span> c = (<span class="keyword">char</span>)(a);</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0x12</span>)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"big endian"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="number">0x34</span>)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"little endian"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>方式二：巧用union联合体<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//union联合体的重叠式存储，endian联合体占用内存的空间为每个成员字节长度的最大值</span></span><br><span class="line"><span class="keyword">union</span> endian</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    endian value;</span><br><span class="line">    value.a = <span class="number">0x1234</span>;</span><br><span class="line">    <span class="comment">//a和ch共用4字节的内存空间</span></span><br><span class="line">    <span class="keyword">if</span> (value.ch == <span class="number">0x12</span>)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"big endian"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (value.ch == <span class="number">0x34</span>)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"little endian"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="volati-mutable和explicit关键字的用法"><a href="#volati-mutable和explicit关键字的用法" class="headerlink" title="volati# mutable和explicit关键字的用法"></a>volati# mutable和explicit关键字的用法</h1><p>（1）volatile</p>
<p>volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改，比如：操作# 硬件或者其它线程等。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。</p>
<p>当要求使用 volatile 声明的变量的值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。</p>
<p>volatile定义变量的值是易变的，每次用到这个变量的值的时候都要去重新读取这个变量的值，而不是读寄存器内的备份。多线程中被几个任务共享的变量需要定义为volatile类型。</p>
<p>volatile 指针</p>
<p>volatile 指针和 const 修饰词类似，const 有常量指针和指针常量的说法，volatile 也有相应的概念</p>
<p>修饰由指针指向的# 数据是 const 或 volatile 的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* cpch;</span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">char</span>* vpch;</span><br></pre></td></tr></table></figure></p>
<p>指针自身的值——一个代表地址的整数变量，是 const 或 volatile 的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* <span class="keyword">const</span> pchc;</span><br><span class="line"><span class="keyword">char</span>* <span class="keyword">volatile</span> pchv;</span><br></pre></td></tr></table></figure></p>
<p>注意：</p>
<p>可以把一个非volatile int赋给volatile int，但是不能把非volatile对象赋给一个volatile对象。</p>
<p>除了基本类型外，对用户定义类型也可以用volatile类型进行修饰。</p>
<p>C++中一个有volatile标识符的类只能访问它接口的子集，一个由类的实现者控制的子集。用户只能用const_cast来获得对类型接口的完全访问。此外，volatile向const一样会从类传递到它的成员。</p>
<p>多线程下的volatile  </p>
<p>有些变量是用volatile关键字声明的。当两个线程都要用到某一个变量且该变量的值会被改变时，应该用volatile声明，该关键字的作用是防止优化编译器把变量从内存装入CPU寄存器中。如果变量被装入寄存器，那么两个线程有可能一个使用内存中的变量，一个使用寄存器中的变量，这会造成程序的错误执行。volatile的意思是让编译器每次操作该变量时一定要从内存中真正取出，而不是使用已经存在寄存器中的值。</p>
<p>（2）mutable</p>
<p>mutable的中文意思是“可变的，易变的”，跟constant（既C++中的const）是反义词。在C++中，mutable也是为了突破const的限制而设置的。被mutable修饰的变量，将永远处于可变的状态，即使在一个const函数中。我们知道，如果类的成员函数不会改变对象的状态，那么这个成员函数一般会声明成const的。但是，有些时候，我们需要在const函数里面修改一些跟类状态无关的数据成员，那么这个函数就应该被mutable来修饰，并且放在函数后后面关键字位置。</p>
<p>（3）explicit</p>
<p>explicit关键字用来修饰类的构造函数，被修饰的构造函数的类，不能发生相应的隐式类型转换，只能以显示的方式进行类型转换，注意以下几点：</p>
<p>explicit 关键字只能用于类内部的构造函数声明上</p>
<p>explicit 关键字作用于单个参数的构造函数</p>
<p>被explicit修饰的构造函数的类，不能发生相应的隐式类型转换</p>
<h1 id="什么情况下会调用拷贝构造函数"><a href="#什么情况下会调用拷贝构造函数" class="headerlink" title="什么情况下会调用拷贝构造函数"></a>什么情况下会调用拷贝构造函数</h1><p>用类的一个实例化对象去初始化另一个对象的时候</p>
<p>函数的参数是类的对象时（非引用传递）</p>
<p>函数的返回值是函数体内局部对象的类的对象时 ,此时虽然发生（Named return Value优化）NRV优化，但是由于返回方式是值传递，所以会在返回值的地方调用拷贝构造函数</p>
<p>另：第三种情况在Linux g++ 下则不会发生拷贝构造函数，不仅如此即使返回局部对象的引用，依然不会发生拷贝构造函数</p>
<p>总结就是：即使发生NRV优化的情况下，Linux+ g++的环境是不管值返回方式还是引用方式返回的方式都不会发生拷贝构造函数，而Windows + VS2019在值返回的情况下发生拷贝构造函数，引用返回方式则不发生拷贝构造函数。</p>
<p>在c++编译器发生NRV优化，如果是引用返回的形式则不会调用拷贝构造函数，如果是值传递的方式依然会发生拷贝构造函数。</p>
<p>在VS2019下进行下述实验：</p>
<p>举个例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A() &#123;&#125;;</span><br><span class="line">    A(<span class="keyword">const</span> A&amp; a)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"copy constructor is called"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    ~A() &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">useClassA</span><span class="params">(A a)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">A <span class="title">getClassA</span><span class="params">()</span><span class="comment">//此时会发生拷贝构造函数的调用，虽然发生NRV优化，但是依然调用拷贝构造函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//A&amp; getClassA2()//  VS2019下，此时编辑器会进行（Named return Value优化）NRV优化,不调用拷贝构造函数 ，如果是引用传递的方式返回当前函数体内生成的对象时，并不发生拷贝构造函数的调用</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//    A a;</span></span><br><span class="line"><span class="comment">//    return a;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a1, a2,a3,a4;</span><br><span class="line">    A a2 = a1;  <span class="comment">//调用拷贝构造函数,对应情况1</span></span><br><span class="line">    useClassA(a1);<span class="comment">//调用拷贝构造函数，对应情况2</span></span><br><span class="line">    a3 = getClassA();<span class="comment">//发生NRV优化，但是值返回，依然会有拷贝构造函数的调用 情况3</span></span><br><span class="line">    a4 = getClassA2(a1);<span class="comment">//发生NRV优化，且引用返回自身，不会调用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>情况1比较好理解</p>
<p>情况2的实现过程是，调用函数时先根据传入的实参产生临时对象，再用拷贝构造去初始化这个临时对象，在函数中与形参对应，函数调用结束后析构临时对象</p>
<p>情况3在执行return时，理论的执行过程是：产生临时对象，调用拷贝构造函数把返回对象拷贝给临时对象，函数执行完先析构局部变量，再析构临时对象，  依然会调用拷贝构造函数</p>
<h1 id="C-中有几种类型的new"><a href="#C-中有几种类型的new" class="headerlink" title="C++中有几种类型的new"></a>C++中有几种类型的new</h1><p>在C++中，new有三种典型的使用方法：plain new，nothrow new和placement new</p>
<p>（1）plain new</p>
<p>言下之意就是普通的new，就是我们常用的new，在C++中定义如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span>)</span> <span class="title">throw</span><span class="params">(<span class="built_in">std</span>::bad_alloc)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>因此plain new在空间分配失败的情况下，抛出异常<code>std::bad_alloc</code>而不是返回NULL，因此通过判断返回值是否为NULL是徒劳的，举个例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> *p = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">10e11</span>];</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (<span class="keyword">const</span> <span class="built_in">std</span>::bad_alloc &amp;ex)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ex.what() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>//执行结果：bad allocation<br>（2）nothrow new</p>
<p>nothrow new在空间分配失败的情况下是不抛出异常，而是返回NULL，定义如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> * <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span>,<span class="keyword">const</span> <span class="built_in">std</span>::<span class="keyword">nothrow_t</span>&amp;)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>*)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>举个例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *p = <span class="keyword">new</span>(nothrow) <span class="keyword">char</span>[<span class="number">10e11</span>];</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"alloc failed"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>//运行结果：alloc failed<br>（3）placement new</p>
<p>这种new允许在一块已经分配成功的内存上重新构造对象或对象数组。placement new不用担心内存分配失败，因为它根本不分配内存，它做的唯一一件事情就是调用对象的构造函数。定义如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span>,<span class="keyword">void</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>*,<span class="keyword">void</span>*)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>使用placement new需要注意两点：</p>
<p>palcement new的主要用途就是反复使用一块较大的动态分配的内存来构造不同类型的对象或者他们的数组</p>
<p>placement new构造起来的对象数组，要显式的调用他们的析构函数来销毁（析构函数并不释放对象的内存），千万不要使用delete，这是因为placement new构造起来的对象或数组大小并不一定等于原来分配的内存大小，使用delete会造成内存泄漏或者之后释放内存时出现运行时错误。</p>
<p>举个例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ADT</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ADT()&#123;</span><br><span class="line">        i = <span class="number">10</span>;</span><br><span class="line">        j = <span class="number">100</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"ADT construct i="</span> &lt;&lt; i &lt;&lt; <span class="string">"j="</span>&lt;&lt;j &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~ADT()&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"ADT destruct"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *p = <span class="keyword">new</span>(nothrow) <span class="keyword">char</span>[<span class="keyword">sizeof</span> ADT + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"alloc failed"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ADT *q = <span class="keyword">new</span>(p) ADT;  <span class="comment">//placement new:不必担心失败，只要p所指对象的的空间足够ADT创建即可</span></span><br><span class="line">    <span class="comment">//delete q;//错误!不能在此处调用delete q;</span></span><br><span class="line">    q-&gt;ADT::~ADT();<span class="comment">//显示调用析构函数</span></span><br><span class="line">    <span class="keyword">delete</span>[] p;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果：</span></span><br><span class="line"><span class="comment">//ADT construct i=10j=100</span></span><br><span class="line"><span class="comment">//ADT destruct</span></span><br></pre></td></tr></table></figure></p>
<h1 id="C-中NULL和nullptr区别"><a href="#C-中NULL和nullptr区别" class="headerlink" title="C++中NULL和nullptr区别"></a>C++中NULL和nullptr区别</h1><p>算是为了与C语言进行兼容而定义的一个问题吧</p>
<p>NULL来自C语言，一般由宏定义实现，而 nullptr 则是C++11的新增关键字。在C语言中，NULL被定义为(void*)0,而在C++语言中，NULL则被定义为整数0。编译器一般对其实际定义如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NULL 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NULL ((void *)0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>在C++中指针必须有明确的类型定义。但是将NULL定义为0带来的另一个问题是无法与整数的0区分。因为C++中允许有函数重载，所以可以试想如下函数定义情况：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">char</span>* p)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"char*"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"int"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fun(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果：int</span></span><br></pre></td></tr></table></figure></p>
<p>那么在传入NULL参数时，会把NULL当做整数0来看，如果我们想调用参数是指针的函数，该怎么办呢?。nullptr在C++11被引入用于解决这一问题，nullptr可以明确区分整型和指针类型，能够根据环境自动转换成相应的指针类型，但不会被转换为任何整型，所以不会造成参数传递错误。</p>
<p>nullptr的一种实现方式如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">class</span> <span class="title">nullptr_t</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;  <span class="title">inline</span> <span class="title">operator</span> <span class="title">T</span>*() <span class="title">const</span>&#123;</span> <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">C</span>, <span class="title">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">operator</span> <span class="title">T</span> <span class="title">C</span>:</span>:*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>&amp;() <span class="keyword">const</span>;</span><br><span class="line">&#125; <span class="literal">nullptr</span> = &#123;&#125;;</span><br></pre></td></tr></table></figure></p>
<p>以上通过模板类和运算符重载的方式来对不同类型的指针进行实例化从而解决了(void*)指针带来参数类型不明的问题，另外由于nullptr是明确的指针类型，所以不会与整形变量相混淆。但nullptr仍然存在一定问题，例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">char</span>* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; <span class="string">"char* p"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span>* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; <span class="string">"int* p"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; <span class="string">"int p"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fun((<span class="keyword">char</span>*)<span class="literal">nullptr</span>);<span class="comment">//语句1</span></span><br><span class="line">    fun(<span class="literal">nullptr</span>);<span class="comment">//语句2</span></span><br><span class="line">    fun(<span class="literal">NULL</span>);<span class="comment">//语句3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果：</span></span><br><span class="line"><span class="comment">//语句1：char* p</span></span><br><span class="line"><span class="comment">//语句2:报错，有多个匹配</span></span><br><span class="line"><span class="comment">//3：int p</span></span><br></pre></td></tr></table></figure></p>
<p>在这种情况下存在对不同指针类型的函数重载，此时如果传入nullptr指针则仍然存在无法区分应实际调用哪个函数，这种情况下必须显示的指明参数类型。</p>
<h1 id="简要说明C-的内存分区"><a href="#简要说明C-的内存分区" class="headerlink" title="简要说明C++的内存分区"></a>简要说明C++的内存分区</h1><p>C++中的内存分区，分别# # 自由存# 全局/静态存# 常量存储区和代码区。如下图所示</p>
<p>图片</p>
<p>栈：在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限</p>
<p>堆：就是那些由 new分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个new就要对应一个 delete。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收</p>
<p>自由存储区：就是那些由malloc等分配的内存块，它和堆是十分相似的，不过它是用free来结束自己的生命的</p>
<p>全局/静态存储区：全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量和静态变量又分为初始化的和未初始化的，在C++里面没有这个区分了，它们共同占用同一块内存区，在该区定义的变量若没有初始化，则会被自动初始化，例如int型变量自动初始为0</p>
<p>常量存储区：这是一块比较特殊的存储区，这里面存放的是常量，不允许修改</p>
<p>代码区：存放函数体的二进制代码</p>
<p>《C/C++内存管理详解》：</p>
<p><a href="https://chenqx.github.io/2014/09/25/Cpp-Memory-Management/" target="_blank" rel="noopener">https://chenqx.github.io/2014/09/25/Cpp-Memory-Management/</a></p>
<h1 id="C-的异常处理的方法"><a href="#C-的异常处理的方法" class="headerlink" title="C++的异常处理的方法"></a>C++的异常处理的方法</h1><p>在程序执行过程中，由于程序员的疏忽或是系统资源紧张等因素都有可能导致异常，任何程序都无法保证绝对的稳定，常见的异常有：</p>
<p>数组下标越界</p>
<p>除法计算时除数为0</p>
<p>动态分配空间时空间不足</p>
<p>…</p>
<p>如果不及时对这些异常进行处理，程序多数情况下都会崩溃。</p>
<p>（1）t# throw和catch关键字</p>
<p>C++中的异常处理机制主要使用t# throw和catch三个关键字，其在程序中的用法如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> m = <span class="number">1</span>, n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"before dividing."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> - <span class="number">1</span>;  <span class="comment">//抛出int型异常</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (m == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> - <span class="number">1.0</span>;  <span class="comment">//拋出 double 型异常</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; m / n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"after dividing."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (<span class="keyword">double</span> d) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"catch (double)"</span> &lt;&lt; d &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (...) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"catch (...)"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"finished"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果</span></span><br><span class="line"><span class="comment">//before dividing.</span></span><br><span class="line"><span class="comment">//catch (...)</span></span><br><span class="line"><span class="comment">//finished</span></span><br></pre></td></tr></table></figure></p>
<p>代码中，对两个数进行除法计算，其中除数为0。可以看到以上三个关键字，程序的执行流程是先执行try包裹的语句块，如果执行过程中没有异常发生，则不会进入任何catch包裹的语句块。如果发生异常，则使用throw进行异常抛出，再由catch进行捕获，throw可以抛出各种数据类型的信息，代码中使用的是数字，也可以自定义异常class。</p>
<p>catch根据throw抛出的数据类型进行精确捕获（不会出现类型转换），如果匹配不到就直接报错，可以使用catch(…)的方式捕获任何异常（不推荐）。</p>
<p>当然，如果catch了异常，当前函数如果不进行处理，或者已经处理了想通知上一层的调用者，可以在catch里面再throw异常。</p>
<p>（2）函数的异常声明列表</p>
<p>有时候，程序员在定义函数的时候知道函数可能发生的异常，可以在函数声明和定义时，指出所能抛出异常的列表，写法如下：</p>
<p>int fun() throw(int,double,A,B,C){…};<br>这种写法表名函数可能会抛出int,double型或# # C三种类型的异常，如果throw中为空，表明不会抛出任何异常，如果没有throw则可能抛出任何异常</p>
<p>（3）C++标准异常类  exception</p>
<p>bad_typeid：使用typeid运算符，如果其操作数是一个多态类的指针，而该指针的值为 NULL，则会拋出此异常，例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~A();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A* a = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="built_in">cout</span> &lt;&lt; <span class="keyword">typeid</span>(*a).name() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// Error condition</span></span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">catch</span> (bad_typeid)&#123;</span><br><span class="line">          <span class="built_in">cout</span> &lt;&lt; <span class="string">"Object is NULL"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果：bject is NULL</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>bad_cast：在用 dynamic_cast 进行从多态基类对象（或引用）到派生类的引用的强制类型转换时，如果转换是不安全的，则会拋出此异常</li>
<li>bad_alloc：在用 new 运算符进行动态内存分配时，如果没有足够的内存，则会引发此异常</li>
<li>out_of_range:用 vector 或 string的at 成员函数根据下标访问元素时，如果下标越界，则会拋出此异常</li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/C/" rel="tag"># C++</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/03/09/Cpp提问2/" rel="next" title="《逆袭进大厂》之C++篇 2">
                <i class="fa fa-chevron-left"></i> 《逆袭进大厂》之C++篇 2
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/header.jpg" alt="Hao Yu">
            
              <p class="site-author-name" itemprop="name">Hao Yu</p>
              <p class="site-description motion-element" itemprop="description">Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author</p>
          </div>
          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">284</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>
        	<audio controls="controls" loop="loop" preload="auto" src="/resource/xiaomeihao.mp3">
	        </audio>
	

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yuhao0102" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:yuh18@mails.tsinghua.edu.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#在main执行之前和之后执行的代码可能是什么？"><span class="nav-number">1.</span> <span class="nav-text">在main执行之前和之后执行的代码可能是什么？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#结构体内存对齐问题？"><span class="nav-number">2.</span> <span class="nav-text">结构体内存对齐问题？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#指针和引用的区别"><span class="nav-number">3.</span> <span class="nav-text">指针和引用的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#堆和栈的区别"><span class="nav-number">4.</span> <span class="nav-text">堆和栈的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#区别以下指针类型？"><span class="nav-number">5.</span> <span class="nav-text">区别以下指针类型？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#基类的虚函数表存放在内存的什么区，虚表指针vptr的初始化时间"><span class="nav-number">6.</span> <span class="nav-text">基类的虚函数表存放在内存的什么区，虚表指针vptr的初始化时间</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#new-delete-与-malloc-free的异同"><span class="nav-number">7.</span> <span class="nav-text">new / delete 与 malloc / free的异同</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#new和delete是如何实现的？"><span class="nav-number">8.</span> <span class="nav-text">new和delete是如何实现的？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#malloc和new的区别？"><span class="nav-number">9.</span> <span class="nav-text">malloc和new的区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#宏定义和函数有何区别？"><span class="nav-number">10.</span> <span class="nav-text">宏定义和函数有何区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#宏定义和typedef区别？"><span class="nav-number">11.</span> <span class="nav-text">宏定义和typedef区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#变量声明和定义区别？"><span class="nav-number">12.</span> <span class="nav-text">变量声明和定义区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#哪几种情况必须用到初始化成员列表？"><span class="nav-number">13.</span> <span class="nav-text">哪几种情况必须用到初始化成员列表？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#strlen和sizeof区别？"><span class="nav-number">14.</span> <span class="nav-text">strlen和sizeof区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#常量指针和指针常量区别？"><span class="nav-number">15.</span> <span class="nav-text">常量指针和指针常量区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#a和-amp-a有什么区别？"><span class="nav-number">16.</span> <span class="nav-text">a和&amp;a有什么区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#数组名和指针（这里为指向数组首元素的指针）区别？"><span class="nav-number">17.</span> <span class="nav-text">数组名和指针（这里为指向数组首元素的指针）区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#野指针和悬空指针"><span class="nav-number">18.</span> <span class="nav-text">野指针和悬空指针</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#迭代器失效的情况"><span class="nav-number">19.</span> <span class="nav-text">迭代器失效的情况</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C和C-的区别"><span class="nav-number">20.</span> <span class="nav-text">C和C++的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C-中struct和class的区别"><span class="nav-number">21.</span> <span class="nav-text">C++中struct和class的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#define宏定义和const的区别"><span class="nav-number">22.</span> <span class="nav-text">define宏定义和const的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C-中const和static的作用"><span class="nav-number">23.</span> <span class="nav-text">C++中const和static的作用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C-的顶层const和底层const"><span class="nav-number">24.</span> <span class="nav-text">C++的顶层const和底层const</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#类的对象存储空间？"><span class="nav-number">25.</span> <span class="nav-text">类的对象存储空间？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#final和override关键字"><span class="nav-number">26.</span> <span class="nav-text">final和override关键字</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#拷贝初始化和直接初始化"><span class="nav-number">27.</span> <span class="nav-text">拷贝初始化和直接初始化</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#初始化和赋值的区别"><span class="nav-number">28.</span> <span class="nav-text">初始化和赋值的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#extern”C”的用法"><span class="nav-number">29.</span> <span class="nav-text">extern”C”的用法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#模板函数和模板类的特例化"><span class="nav-number">30.</span> <span class="nav-text">模板函数和模板类的特例化</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C和C-的类型安全"><span class="nav-number">31.</span> <span class="nav-text">C和C++的类型安全</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#为什么析构函数一般写成虚函数"><span class="nav-number">32.</span> <span class="nav-text">为什么析构函数一般写成虚函数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#构造函数能否声明为虚函数或者纯虚函数，析构函数呢？"><span class="nav-number">33.</span> <span class="nav-text">构造函数能否声明为虚函数或者纯虚函数，析构函数呢？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C-中的重写（覆盖）和隐藏的区别"><span class="nav-number">34.</span> <span class="nav-text">C++中的重写（覆盖）和隐藏的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C-的多态如何实现"><span class="nav-number">35.</span> <span class="nav-text">C++的多态如何实现</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C-有哪几种的构造函数"><span class="nav-number">36.</span> <span class="nav-text">C++有哪几种的构造函数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#浅拷贝和深拷贝的区别"><span class="nav-number">37.</span> <span class="nav-text">浅拷贝和深拷贝的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#内联函数和宏定义的区别"><span class="nav-number">38.</span> <span class="nav-text">内联函数和宏定义的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#构造-析构-虚函数可否声明为内联函数"><span class="nav-number">39.</span> <span class="nav-text">构造# 析构# 虚函数可否声明为内联函数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#auto-decltype和decltype-auto-的用法"><span class="nav-number">40.</span> <span class="nav-text">auto decltype和decltype(auto)的用法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#public，protected和private访问和继承权限-public-protected-private的区别？"><span class="nav-number">41.</span> <span class="nav-text">public，protected和private访问和继承权限/public/protected/private的区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#如何用代码判断大小端存储"><span class="nav-number">42.</span> <span class="nav-text">如何用代码判断大小端存储</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#volati-mutable和explicit关键字的用法"><span class="nav-number">43.</span> <span class="nav-text">volati# mutable和explicit关键字的用法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#什么情况下会调用拷贝构造函数"><span class="nav-number">44.</span> <span class="nav-text">什么情况下会调用拷贝构造函数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C-中有几种类型的new"><span class="nav-number">45.</span> <span class="nav-text">C++中有几种类型的new</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C-中NULL和nullptr区别"><span class="nav-number">46.</span> <span class="nav-text">C++中NULL和nullptr区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#简要说明C-的内存分区"><span class="nav-number">47.</span> <span class="nav-text">简要说明C++的内存分区</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C-的异常处理的方法"><span class="nav-number">48.</span> <span class="nav-text">C++的异常处理的方法</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>
  <div id="DvelopmentTarget">     
  </div>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart" aria-hidden="false"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>

  
</div>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_uv"> 
  本站访客数<span id="busuanzi_value_site_uv"></span>人次
</span>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  


  <script type="text/javascript" src="/js/src/love.js"></script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
