<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zn-ch">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-center-simple.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="C++,">










<meta name="description" content="在main执行之前和之后执行的代码可能是什么？main函数执行之前，主要就是初始化系统相关资源：  设置栈指针 初始化静态static变量和global全局变量，即.data段的内容 将未初始化部分的全局变量赋初值：数值型short，int，long等为0，bool为FALSE，指针为NULL等等，即.bss段的内容 全局对象初始化，在main之前调用构造函数，这是可能会执行前的一些代码 将mai">
<meta name="keywords" content="C++">
<meta property="og:type" content="article">
<meta property="og:title" content="《逆袭进大厂》之C++篇">
<meta property="og:url" content="http://yoursite.com/2021/03/09/逆袭进大厂的cpp提问/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="在main执行之前和之后执行的代码可能是什么？main函数执行之前，主要就是初始化系统相关资源：  设置栈指针 初始化静态static变量和global全局变量，即.data段的内容 将未初始化部分的全局变量赋初值：数值型short，int，long等为0，bool为FALSE，指针为NULL等等，即.bss段的内容 全局对象初始化，在main之前调用构造函数，这是可能会执行前的一些代码 将mai">
<meta property="og:locale" content="zn-ch">
<meta property="og:updated_time" content="2022-10-01T03:22:02.219Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="《逆袭进大厂》之C++篇">
<meta name="twitter:description" content="在main执行之前和之后执行的代码可能是什么？main函数执行之前，主要就是初始化系统相关资源：  设置栈指针 初始化静态static变量和global全局变量，即.data段的内容 将未初始化部分的全局变量赋初值：数值型short，int，long等为0，bool为FALSE，指针为NULL等等，即.bss段的内容 全局对象初始化，在main之前调用构造函数，这是可能会执行前的一些代码 将mai">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2021/03/09/逆袭进大厂的cpp提问/">





  <title>《逆袭进大厂》之C++篇 | Hao Yu's blog</title>
  








 
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zn-ch">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hao Yu's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">The program monkey was eaten by the siege lion.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/resume.pdf" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-mybetterhalf">
          <a href="/mybetterhalf/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>
            
            mybetterhalf
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/09/逆袭进大厂的cpp提问/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">《逆袭进大厂》之C++篇</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-03-09T16:09:00+08:00">
                2021-03-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="在main执行之前和之后执行的代码可能是什么？"><a href="#在main执行之前和之后执行的代码可能是什么？" class="headerlink" title="在main执行之前和之后执行的代码可能是什么？"></a>在main执行之前和之后执行的代码可能是什么？</h1><p>main函数执行之前，主要就是初始化系统相关资源：</p>
<ul>
<li>设置栈指针</li>
<li>初始化静态static变量和global全局变量，即.data段的内容</li>
<li>将未初始化部分的全局变量赋初值：数值型short，int，long等为0，bool为FALSE，指针为NULL等等，即.bss段的内容</li>
<li>全局对象初始化，在main之前调用构造函数，这是可能会执行前的一些代码</li>
<li>将main函数的参数argc，argv等传递给main函数，然后才真正运行main函数</li>
</ul>
<p>main函数执行之后：</p>
<ul>
<li>全局对象的析构函数会在main函数之后执行；</li>
<li>可以用 atexit 注册一个函数，它会在main 之后执行;</li>
</ul>
<h1 id="结构体内存对齐问题？"><a href="#结构体内存对齐问题？" class="headerlink" title="结构体内存对齐问题？"></a>结构体内存对齐问题？</h1><p>结构体内成员按照声明顺序存储，第一个成员地址和整个结构体地址相同。</p>
<p>未特殊说明时，按结构体中size最大的成员对齐（若有double成员，按8字节对齐。）</p>
<h1 id="指针和引用的区别"><a href="#指针和引用的区别" class="headerlink" title="指针和引用的区别"></a>指针和引用的区别</h1><ul>
<li>指针是一个变量，存储的是一个地址，引用跟原来的变量实质上是同一个东西，是原变量的别名</li>
<li>指针可以有多级，引用只有一级</li>
<li>指针可以为空，引用不能为NULL且在定义时必须初始化</li>
<li>指针在初始化后可以改变指向，而引用在初始化之后不可再改变</li>
<li>当把指针作为参数进行传递时，也是将实参的一个拷贝传递给形参，两者指向的地址相同，但不是同一个变量，在函数中改变这个变量的指向不影响实参，而引用却可以。</li>
<li>引用只是别名，不占用具体存储空间，只有声明没有定义；指针是具体变量，需要占用存储空间。</li>
<li>引用在声明时必须初始化为另一变量，一旦出现必须为typename refname &amp;varname形式；指针声明和定义可以分开，可以先只声明指针变量而不初始化，等用到时再指向具体变量。</li>
<li>引用一旦初始化之后就不可以再改变（变量可以被引用为多次，但引用只能作为一个变量引用）；指针变量可以重新指向别的变量。</li>
<li>不存在指向空值的引用，必须有具体实体；但是存在指向空值的指针。</li>
</ul>
<p>参考代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">　　<span class="keyword">int</span> a=<span class="number">1</span>;</span><br><span class="line">　　p=&amp;a;</span><br><span class="line">　　<span class="built_in">cout</span>&lt;&lt;p&lt;&lt;<span class="string">" "</span>&lt;&lt;*p&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p=<span class="literal">NULL</span>;</span><br><span class="line">    test(p);</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"指针p为NULL"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果为：</span></span><br><span class="line"><span class="comment">//0x22ff44 1</span></span><br><span class="line"><span class="comment">//指针p为NULL</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testPTR</span><span class="params">(<span class="keyword">int</span>* p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">12</span>;</span><br><span class="line">    p = &amp;a;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testREFF</span><span class="params">(<span class="keyword">int</span>&amp; p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">12</span>;</span><br><span class="line">    p = a;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span>* b = &amp;a;</span><br><span class="line">    testPTR(b);<span class="comment">//改变指针指向，但是没改变指针的所指的内容</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;<span class="comment">// 10</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *b &lt;&lt; <span class="built_in">endl</span>;<span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line">    a = <span class="number">10</span>;</span><br><span class="line">    testREFF(a);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//12</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h1><ul>
<li>申请方式不同：栈由系统自动分配；堆是自己申请和释放的。</li>
<li>申请大小限制不同：栈顶和栈底是之前预设好的，栈是向栈底扩展，大小固定，可以通过ulimit -a查看，由ulimit -s修改；堆向高地址扩展，是不连续的内存区域，大小可以灵活调整。</li>
<li>申请效率不同：栈由系统分配，速度快，不会有碎片；堆由程序员分配，速度慢，且会有碎片。</li>
</ul>
<p>形象的比喻</p>
<p>栈就像我们去饭馆里吃饭，只管点菜（发出申# # 和吃（使用），吃饱了就走，不必理会# 洗菜等准备工作和# 刷锅等扫尾工作，他的好处是快捷，但是自由度小。</p>
<p>堆就象是自己动手做喜欢吃的菜肴，比较麻烦，但是比较符合自己的口味，而且自由度大。</p>
<h1 id="区别以下指针类型？"><a href="#区别以下指针类型？" class="headerlink" title="区别以下指针类型？"></a>区别以下指针类型？</h1><ul>
<li><code>int *p[10]</code>表示指针数组，强调数组概念，是一个数组变量，数组大小为10，数组内每个元素都是指向int类型的指针变量。</li>
<li><code>int (*p)[10]</code>表示数组指针，强调是指针，只有一个变量，是指针类型，不过指向的是一个int类型的数组，这个数组大小是10。</li>
<li><code>int *p(int)</code>是函数声明，函数名是p，参数是int类型的，返回值是int *类型的。</li>
<li><code>int (*p)(int)</code>是函数指针，强调是指针，该指针指向的函数具有int类型参数，并且返回值是int类型的。</li>
</ul>
<h1 id="宏定义和typedef区别？"><a href="#宏定义和typedef区别？" class="headerlink" title="宏定义和typedef区别？"></a>宏定义和typedef区别？</h1><p>宏主要用于定义常量及书写复杂的内容；typedef主要用于定义类型别名。</p>
<p>宏替换发生在编译阶段之前，属于文本插入替换；typedef是编译的一部分。</p>
<p>宏不检查类型；typedef会检查数据类型。</p>
<p>宏不是语句，不在在最后加分号；typedef是语句，要加分号标识结束。</p>
<p>注意对指针的操作，typedef char <em> p_char和define p_char char </em>区别巨大。</p>
<h1 id="变量声明和定义区别？"><a href="#变量声明和定义区别？" class="headerlink" title="变量声明和定义区别？"></a>变量声明和定义区别？</h1><p>声明仅仅是把变量的声明的位置及类型提供给编译器，并不分配内存空间；定义要在定义的地方为其分配存储空间。</p>
<p>相同变量可以在多处声明（外部变量extern），但只能在一处定义。</p>
<h1 id="哪几种情况必须用到初始化成员列表？"><a href="#哪几种情况必须用到初始化成员列表？" class="headerlink" title="哪几种情况必须用到初始化成员列表？"></a>哪几种情况必须用到初始化成员列表？</h1><p>初始化一个const成员。</p>
<p>初始化一个reference成员。</p>
<p>调用一个基类的构造函数，而该函数有一组参数。</p>
<p>调用一个数据成员对象的构造函数，而该函数有一组参数。</p>
<h1 id="a和-amp-a有什么区别？"><a href="#a和-amp-a有什么区别？" class="headerlink" title="a和&amp;a有什么区别？"></a>a和&amp;a有什么区别？</h1><p>假设数组<code>int a[10];</code><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> (*p)[<span class="number">10</span>] = &amp;a;</span><br></pre></td></tr></table></figure></p>
<p>a是数组名，是数组首元素地址，+1表示地址值加上一个int类型的大小，如果a的值是0x00000001，加1操作后变为0x00000005。<code>*(a + 1) = a[1]</code>。</p>
<p>&amp;a是数组的指针，其类型为<code>int (*)[10]</code>（就是前面提到的数组指针），其加1时，系统会认为是数组首地址加上整个数组的偏移（10个int型变量），值为数组a尾元素后一个元素的地址。</p>
<p>若<code>(int *)p</code>，此时输出<code>*p</code>时，其值为<code>a[0]</code>的值，因为被转为<code>int *</code>类型，解引用时按照int类型大小来读取。</p>
<h1 id="迭代器失效的情况"><a href="#迭代器失效的情况" class="headerlink" title="迭代器失效的情况"></a>迭代器失效的情况</h1><p>以vector为例：</p>
<p>插入元素：</p>
<ul>
<li>尾后插入：size &lt; capacity时，首迭代器不失效尾迭代失效（未重新分配空间），size == capacity时，所有迭代器均失效（需要重新分配空间）。</li>
<li>中间插入：中间插入：size &lt; capacity时，首迭代器不失效但插入元素之后所有迭代器失效，size == capacity时，所有迭代器均失效。</li>
</ul>
<p>删除元素：</p>
<ul>
<li>尾后删除：只有尾迭代失效。</li>
<li>中间删除：删除位置之后所有迭代失效。</li>
</ul>
<h1 id="C和C-的区别"><a href="#C和C-的区别" class="headerlink" title="C和C++的区别"></a>C和C++的区别</h1><ul>
<li>C++中new和delete是对内存分配的运算符，取代了C中的malloc和free。</li>
<li>标准C++中的字符串类取代了标准C函数库头文件中的字符数组处理函数（C中没有字符串类型）。</li>
<li>C++中用来做控制态输入输出的iostream类库替代了标准C中的stdio函数库。</li>
<li>C++中的try/catch/throw异常处理机制取代了标准C中的setjmp()和longjmp()函数。</li>
<li>在C++中，允许有相同的函数名，不过它们的参数类型不能完全相同，这样这些函数就可以相互区别开来。而这在C语言中是不允许的。也就是C++可以重载，C语言不允许。</li>
<li>C++语言中，允许变量定义语句在程序中的任何地方，只要在是使用它之前就可以；而C语言中，必须要在函数开头部分。而且C++允许重复定义变量，C语言也是做不到这一点的</li>
<li>在C++中，除了值和指针之外，新增了引用。引用型变量是其他变量的一个别名，我们可以认为他们只是名字不相同，其他都是相同的。</li>
<li>C++相对与C增加了一些关键字，如：bo# usi# dynamic_ca# namespace等等</li>
</ul>
<h1 id="C-中struct和class的区别"><a href="#C-中struct和class的区别" class="headerlink" title="C++中struct和class的区别"></a>C++中struct和class的区别</h1><p>相同点：</p>
<ul>
<li>两者都拥有成员# 公有和私有部分</li>
<li>任何可以使用class完成的工作，同样可以使用struct完成</li>
</ul>
<p>不同点</p>
<ul>
<li>两者中如果不对成员不指定公私有，struct默认是公有的，class则默认是私有的</li>
<li>class默认是private继承，而struct模式是public继承</li>
<li>class可以作为模板类型，struct不行</li>
</ul>
<p>引申：C++和C的struct区别</p>
<p>C语言中：struct是用户自定义数据类型（UDT）；C++中struct是抽象数据类型（ADT），支持成员函数的定义，（C++中的struct能继承，能实现多态）</p>
<p>C中struct是没有权限的设置的，且struct中只能是一些变量的集合体，可以封装数据却不可以隐藏数据，而且成员不可以是函数</p>
<p>C++中，struct增加了访问权限，且可以和类一样有成员函数，成员默认访问说明符为public（为了与C兼容）</p>
<p>struct作为类的一种特例是用来自定义数据结构的。一个结构标记声明后，在C中必须在结构标记前加上struct，才能做结构类型名（除：typedef struct class{};）;C++中结构体标记（结构体名）可以直接作为结构体类型名使用，此外结构体struct在C++中被当作类的一种特例</p>
<h1 id="define宏定义和const的区别"><a href="#define宏定义和const的区别" class="headerlink" title="define宏定义和const的区别"></a>define宏定义和const的区别</h1><p>编译阶段</p>
<p>define是在编译的预处理阶段起作用，而const是在# 运行的时候起作用</p>
<p>安全性</p>
<p>define只做替换，不做类型检查和计算，也不求解，容易产生错误，一般最好加上一个大括号包含住全部的内容，要不然很容易出错</p>
<p>const常量有数据类型，编译器可以对其进行类型安全检查</p>
<p>内存占用</p>
<p>define只是将宏名称进行替换，在内存中会产生多分相同的备份。const在程序运行中只有一份备份，且可以执行常量折叠，能将复杂的的表达式计算出结果放入常量表</p>
<p>宏替换发生在编译阶段之前，属于文本插入替换；const作用发生于编译过程中。</p>
<p>宏不检查类型；const会检查数据类型。</p>
<p>宏定义的数据没有分配内存空间，只是插入替换掉；const定义的变量只是值不能改变，但要分配内存空间。</p>
<h1 id="final和override关键字"><a href="#final和override关键字" class="headerlink" title="final和override关键字"></a>final和override关键字</h1><p>override</p>
<p>当在父类中使用了虚函数时候，你可能需要在某个子类中对这个虚函数进行重写，以下方法都可以：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>; <span class="comment">//OK</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>; <span class="comment">// OK</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> override</span>; <span class="comment">//OK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果不使用override，当你手一抖，将foo()写成了foo()会怎么样呢？结果是编译器并不会报错，因为它并不知道你的目的是重写虚函数，而是把它当成了新的函数。如果这个虚函数很重要的话，那就会对整个程序不利。所以，override的作用就出来了，它指定了子类的这个虚函数是重写的父类的，如果你名字不小心打错了的话，编译器是不会编译通过的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f00</span><span class="params">()</span></span>; <span class="comment">//OK，这个函数是B新增的，不是继承的</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f0o</span><span class="params">()</span> override</span>; <span class="comment">//Error, 加了override之后，这个函数一定是继承自A的，A找不到就报错</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>final</p>
<p>当不希望某个类被继承，或不希望某个虚函数被重写，可以在类名和虚函数后添加final关键字，添加final关键字后被继承或重写，编译器会报错。例子如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> final</span>; <span class="comment">// foo 被override并且是最后一个override，在其子类中不可以重写</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="title">final</span> :</span> A <span class="comment">// 指明B是不可以被继承的</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> override</span>; <span class="comment">// Error: 在A中已经被final了</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> B <span class="comment">// Error: B is final</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="拷贝初始化和直接初始化"><a href="#拷贝初始化和直接初始化" class="headerlink" title="拷贝初始化和直接初始化"></a>拷贝初始化和直接初始化</h1><p>当用于类类型对象时，初始化的拷贝形式和直接形式有所不同：直接初始化直接调用与实参匹配的构造函数，拷贝初始化总是调用拷贝构造函数。拷贝初始化首先使用指定构造函数创建一个临时对象，然后用拷贝构造函数将那个临时对象拷贝到正在创建的对象。举例如下</p>
<ul>
<li><code>string str1(&quot;I am a string&quot;);</code>//语句1 直接初始化</li>
<li><code>string str2(str1);</code>//语句2 直接初始化，str1是已经存在的对象，直接调用构造函数对str2进行初始化</li>
<li><code>string str3 = &quot;I am a string&quot;;</code>//语句3 拷贝初始化，先为字符串”I am a string“创建临时对象，再把临时对象作为参数，使用拷贝构造函数构造str3</li>
<li><code>string str4 = str1;</code>//语句4 拷贝初始化，这里相当于隐式调用拷贝构造函数，而不是调用赋值运算符函数</li>
</ul>
<p>为了提高效率，允许编译器跳过创建临时对象这一步，直接调用构造函数构造要创建的对象，这样就完全等价于直接初始化了（语句1和语句3等价）。但是需要辨别两种情况。</p>
<p>当拷贝构造函数为private时：语句3和语句4在编译时会报错</p>
<p>使用explicit修饰构造函数时：如果构造函数存在隐式转换，编译时会报错</p>
<h1 id="初始化和赋值的区别"><a href="#初始化和赋值的区别" class="headerlink" title="初始化和赋值的区别"></a>初始化和赋值的区别</h1><p>对于简单类型来说，初始化和赋值没什么区别</p>
<p>对于类和复杂数据类型来说，这两者的区别就大了，举例如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> num1;</span><br><span class="line">    <span class="keyword">int</span> num2;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A(<span class="keyword">int</span> a=<span class="number">0</span>, <span class="keyword">int</span> b=<span class="number">0</span>):num1(a),num2(b)&#123;&#125;;</span><br><span class="line">    A(<span class="keyword">const</span> A&amp; a)&#123;&#125;;</span><br><span class="line">    <span class="comment">//重载 = 号操作符函数</span></span><br><span class="line">    A&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> A&amp; a)&#123;</span><br><span class="line">        num1 = a.num1 + <span class="number">1</span>;</span><br><span class="line">        num2 = a.num2 + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">A <span class="title">a</span><span class="params">(<span class="number">1</span>,<span class="number">1</span>)</span></span>;</span><br><span class="line">    A a1 = a; <span class="comment">//拷贝初始化操作，调用拷贝构造函数</span></span><br><span class="line">    A b;</span><br><span class="line">    b = a;<span class="comment">//赋值操作，对象a中，num1 = 1，num2 = 1；对象b中，num1 = 2，num2 = 2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="模板函数和模板类的特例化"><a href="#模板函数和模板类的特例化" class="headerlink" title="模板函数和模板类的特例化"></a>模板函数和模板类的特例化</h1><p>引入原因</p>
<p>编写单一的模板，它能适应多种类型的需求，使每种类型都具有相同的功能，但对于某种特定类型，如果要实现其特有的功能，单一模板就无法做到，这时就需要模板特例化</p>
<p>定义</p>
<p>对单一模板提供的一个特殊实例，它将一个或多个模板参数绑定到特定的类型或值上</p>
<p>（1）模板函数特例化</p>
<p>必须为原函数模板的每个模板参数都提供实参，且使用关键字template后跟一个空尖括号对&lt;&gt;，表明将原模板的所有模板参数提供实参，举例如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="comment">//模板函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> T &amp;v1,<span class="keyword">const</span> T &amp;v2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(v1 &gt; v2) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(v2 &gt; v1) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//模板特例化,满足针对字符串特定的比较，要提供所有实参，这里只有一个T</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> &amp;v1,<span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> &amp;v2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(p1,p2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>本质</p>
<p>特例化的本质是实例化一个模板，而非重载它。特例化不影响参数匹配。参数匹配都以最佳匹配为原则。例如，此处如果是compare(3,5)，则调用普通的模板，若为compare(“hi”,”haha”)则调用特例化版本（因为这个cosnt char*相对于T，更匹配实参类型），注意二者函数体的语句不一样了，实现不同功能。</p>
<p>注意</p>
<p>模板及其特例化版本应该声明在同一个头文件中，且所有同名模板的声明应该放在前面，后面放特例化版本。</p>
<p>（2）类模板特例化</p>
<p>原理类似函数模板，不过在类中，我们可以对模板进行特例化，也可以对类进行部分特例化。对类进行特例化时，仍然用template&lt;&gt;表示是一个特例化版本，例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">hash</span>&lt;sales_data&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">size_t</span> <span class="keyword">operator</span>()(sales_data&amp; s);</span><br><span class="line">    <span class="comment">//里面所有T都换成特例化类型版本sales_data</span></span><br><span class="line">    <span class="comment">//按照最佳匹配原则，若T != sales_data，就用普通类模板，否则，就使用含有特定功能的特例化版本。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>类模板的部分特例化</p>
<p>不必为所有模板参数提供实参，可以指定一部分而非所有模板参数，一个类模板的部分特例化本身仍是一个模板，使用它时还必须为其特例化版本中未指定的模板参数提供实参(特例化时类名一定要和原来的模板相同，只是参数类型不同，按最佳匹配原则，哪个最匹配，就用相应的模板)</p>
<p>特例化类中的部分成员</p>
<p>可以特例化类中的部分成员函数而不是整个类，举个例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Bar</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Barst</span><span class="params">(T a)</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">void</span> Foo&lt;<span class="keyword">int</span>&gt;::Bar()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//进行int类型的特例化处理</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"我是int型特例化"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo&lt;<span class="built_in">string</span>&gt; fs;</span><br><span class="line">Foo&lt;<span class="keyword">int</span>&gt; fi;<span class="comment">//使用特例化</span></span><br><span class="line">fs.Bar();<span class="comment">//使用的是普通模板，即Foo&lt;string&gt;::Bar()</span></span><br><span class="line">fi.Bar();<span class="comment">//特例化版本，执行Foo&lt;int&gt;::Bar()</span></span><br><span class="line"><span class="comment">//Foo&lt;string&gt;::Bar()和Foo&lt;int&gt;::Bar()功能不同</span></span><br></pre></td></tr></table></figure></p>
<h1 id="C和C-的类型安全"><a href="#C和C-的类型安全" class="headerlink" title="C和C++的类型安全"></a>C和C++的类型安全</h1><p>什么是类型安全？</p>
<p>类型安全很大程度上可以等价于内存安全，类型安全的代码不会试图访问自己没被授权的内存区域。“类型安全”常被用来形容编程语言，其根据在于该门编程语言是否提供保障类型安全的机制；有的时候也用“类型安全”形容某个程序，判别的标准在于该程序是否隐含类型错误。类型安全的编程语言与类型安全的程序之间，没有必然联系。好的程序员可以使用类型不那么安全的语言写出类型相当安全的程序，相反的，差一点儿的程序员可能使用类型相当安全的语言写出类型不太安全的程序。绝对类型安全的编程语言暂时还没有。</p>
<p>如果C++使用得当，它将远比C更有类型安全性。相比于C语言，C++提供了一些新的机制保障类型安全：</p>
<ul>
<li>操作符new返回的指针类型严格与对象匹配，而不是void*</li>
<li>C中很多以void*为参数的函数可以改写为C++模板函数，而模板是支持类型检查的；</li>
<li>引入const关键字代替define constants，它是有类型有作用域的，define constants只是简单的文本替换</li>
</ul>
<p>C++提供了dynamic_cast关键字，使得转换过程更加安全，因为dynamic_cast比static_cast涉及更多具体的类型检查。</p>
<p>例1：不同类型指针之间转换<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span>&#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child1</span> :</span> <span class="keyword">public</span> Parent</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    Child1(<span class="keyword">int</span> e):i(e)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child2</span> :</span> <span class="keyword">public</span> Parent</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">double</span> d;</span><br><span class="line">    Child2(<span class="keyword">double</span> e):d(e)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Child1 <span class="title">c1</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    <span class="function">Child2 <span class="title">c2</span><span class="params">(<span class="number">4.1</span>)</span></span>;</span><br><span class="line">    Parent* pp;</span><br><span class="line">    Child1* pc1;</span><br><span class="line"></span><br><span class="line">    pp=&amp;c1; </span><br><span class="line">    pc1=(Child1*)pp;  <span class="comment">// 类型向下转换 强制转换，由于类型仍然为Child1*，不造成错误</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;pc1-&gt;i&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//输出：5</span></span><br><span class="line"></span><br><span class="line">    pp=&amp;c2;</span><br><span class="line">    pc1=(Child1*)pp;  <span class="comment">//强制转换，且类型发生变化，将造成错误</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;pc1-&gt;i&lt;&lt;<span class="built_in">endl</span>;<span class="comment">// 输出：1717986918</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面两个例子之所以引起类型不安全的问题，是因为程序员使用不得当。第一个例子用到了空类型指针void<em>，第二个例子则是在两个类型指针之间进行强制转换。因此，想保证程序的类型安全性，应尽量避免使用空类型指针void</em>，尽量不对两种类型指针做强制转换。</p>
<h1 id="C-有哪几种的构造函数"><a href="#C-有哪几种的构造函数" class="headerlink" title="C++有哪几种的构造函数"></a>C++有哪几种的构造函数</h1><p>C++中的构造函数可以分为4类：</p>
<ul>
<li>默认构造函数</li>
<li>初始化构造函数（有参数）</li>
<li>拷贝构造函数</li>
<li>移动构造函数（move和右值引用）</li>
<li>委托构造函数</li>
<li>转换构造函数</li>
</ul>
<p>举个例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Student()&#123;<span class="comment">//默认构造函数，没有参数</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;age = <span class="number">20</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;num = <span class="number">1000</span>;</span><br><span class="line">    &#125;;  </span><br><span class="line">    Student(<span class="keyword">int</span> a, <span class="keyword">int</span> n):age(a), num(n)&#123;&#125;; <span class="comment">//初始化构造函数，有参数和参数列表</span></span><br><span class="line">    Student(<span class="keyword">const</span> Student&amp; s)&#123;<span class="comment">//拷贝构造函数，这里与编译器生成的一致</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;age = s.age;</span><br><span class="line">        <span class="keyword">this</span>-&gt;num = s.num;</span><br><span class="line">    &#125;; </span><br><span class="line">    Student(<span class="keyword">int</span> r)&#123;   <span class="comment">//转换构造函数,形参是其他类型变量，且只有一个形参</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;age = r;</span><br><span class="line">        <span class="keyword">this</span>-&gt;num = <span class="number">1002</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    ~Student()&#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Student s1;</span><br><span class="line">    <span class="function">Student <span class="title">s2</span><span class="params">(<span class="number">18</span>,<span class="number">1001</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="function">Student <span class="title">s3</span><span class="params">(a)</span></span>;</span><br><span class="line">    <span class="function">Student <span class="title">s4</span><span class="params">(s3)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"s1 age:%d, num:%d\n"</span>, s1.age, s1.num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"s2 age:%d, num:%d\n"</span>, s2.age, s2.num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"s3 age:%d, num:%d\n"</span>, s3.age, s3.num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"s2 age:%d, num:%d\n"</span>, s4.age, s4.num);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果</span></span><br><span class="line"><span class="comment">//s1 age:20, num:1000</span></span><br><span class="line"><span class="comment">//s2 age:18, num:1001</span></span><br><span class="line"><span class="comment">//s3 age:10, num:1002</span></span><br><span class="line"><span class="comment">//s2 age:10, num:1002</span></span><br></pre></td></tr></table></figure></p>
<p>默认构造函数和初始化构造函数在定义类的对象，完成对象的初始化工作</p>
<p>复制构造函数用于复制本类的对象</p>
<p>转换构造函数用于将其他类型的变量，隐式转换为本类对象</p>
<h1 id="浅拷贝和深拷贝的区别"><a href="#浅拷贝和深拷贝的区别" class="headerlink" title="浅拷贝和深拷贝的区别"></a>浅拷贝和深拷贝的区别</h1><p>浅拷贝</p>
<p>浅拷贝只是拷贝一个指针，并没有新开辟一个地址，拷贝的指针和原来的指针指向同一块地址，如果原来的指针所指向的资源释放了，那么再释放浅拷贝的指针的资源就会出现错误。</p>
<p>深拷贝</p>
<p>深拷贝不仅拷贝值，还开辟出一块新的空间用来存放新的值，即使原先的对象被析构掉，释放内存了也不会影响到深拷贝得到的值。在自己实现拷贝赋值的时候，如果有指针变量的话是需要自己实现深拷贝的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Student()&#123;</span><br><span class="line">        name = <span class="keyword">new</span> <span class="keyword">char</span>(<span class="number">20</span>);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Student"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    ~Student()&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"~Student "</span> &lt;&lt; &amp;name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">delete</span> name;</span><br><span class="line">        name = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    Student(<span class="keyword">const</span> Student &amp;s)&#123;<span class="comment">//拷贝构造函数</span></span><br><span class="line">        <span class="comment">//浅拷贝，当对象的name和传入对象的name指向相同的地址</span></span><br><span class="line">        name = s.name;</span><br><span class="line">        <span class="comment">//深拷贝</span></span><br><span class="line">        <span class="comment">//name = new char(20);</span></span><br><span class="line">        <span class="comment">//memcpy(name, s.name, strlen(s.name));</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"copy Student"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    &#123;<span class="comment">// 花括号让s1和s2变成局部对象，方便测试</span></span><br><span class="line">        Student s1;</span><br><span class="line">        <span class="function">Student <span class="title">s2</span><span class="params">(s1)</span></span>;<span class="comment">// 复制对象</span></span><br><span class="line">    &#125;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//浅拷贝执行结果：</span></span><br><span class="line"><span class="comment">//Student</span></span><br><span class="line"><span class="comment">//copy Student</span></span><br><span class="line"><span class="comment">//~Student 0x7fffed0c3ec0</span></span><br><span class="line"><span class="comment">//~Student 0x7fffed0c3ed0</span></span><br><span class="line"><span class="comment">//*** Error in `/tmp/815453382/a.out': double free or corruption (fasttop): 0x0000000001c82c20 ***</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//深拷贝执行结果：</span></span><br><span class="line"><span class="comment">//Student</span></span><br><span class="line"><span class="comment">//copy Student</span></span><br><span class="line"><span class="comment">//~Student 0x7fffebca9fb0</span></span><br><span class="line"><span class="comment">//~Student 0x7fffebca9fc0</span></span><br></pre></td></tr></table></figure></p>
<p>从执行结果可以看出，浅拷贝在对象的拷贝创建时存在风险，即被拷贝的对象析构释放资源之后，拷贝对象析构时会再次释放一个已经释放的资源，深拷贝的结果是两个对象之间没有任何关系，各自成员地址不同。</p>
<h1 id="auto-decltype和decltype-auto-的用法"><a href="#auto-decltype和decltype-auto-的用法" class="headerlink" title="auto decltype和decltype(auto)的用法"></a>auto decltype和decltype(auto)的用法</h1><p>（1）auto</p>
<p>C++11新标准引入了auto类型说明符，用它就能让编译器替我们去分析表达式所属的类型。和原来那些只对应某种特定的类型说明符(例如 int)不同，</p>
<p>auto 让编译器通过初始值来进行类型推演。从而获得定义变量的类型，所以说 auto 定义的变量必须有初始值。举个例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//普通；类型</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">auto</span> c = a + b;<span class="comment">// c为int型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//const类型</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">auto</span> j = i; <span class="comment">// 变量i是顶层const, 会被忽略, 所以j的类型是int</span></span><br><span class="line"><span class="keyword">auto</span> k = &amp;i; <span class="comment">// 变量i是一个常量, 对常量取地址是一种底层const, 所以b的类型是const int*</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> l = i; <span class="comment">//如果希望推断出的类型是顶层const的, 那么就需要在auto前面加上cosnt</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//引用和指针类型</span></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span>&amp; y = x;</span><br><span class="line"><span class="keyword">auto</span> z = y; <span class="comment">//z是int型不是int&amp; 型</span></span><br><span class="line"><span class="keyword">auto</span>&amp; p1 = y; <span class="comment">//p1是int&amp;型</span></span><br><span class="line"><span class="keyword">auto</span> p2 = &amp;x; <span class="comment">//p2是指针类型int*</span></span><br></pre></td></tr></table></figure></p>
<p>（2）decltype</p>
<p>有的时候我们还会遇到这种情况，我们希望从表达式中推断出要定义变量的类型，但却不想用表达式的值去初始化变量。还有可能是函数的返回类型为某表达式的值类型。在这些时候auto显得就无力了，所以C++11又引入了第二种类型说明符decltype，它的作用是选择并返回操作数的数据类型。在此过程中，编译器只是分析表达式并得到它的类型，却不进行实际的计算表达式的值。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//普通类型</span></span><br><span class="line"><span class="keyword">decltype</span>(func()) sum = <span class="number">5</span>; <span class="comment">// sum的类型是函数func()的返回值的类型int, 但是这时不会实际调用函数func()</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">decltype</span>(a) b = <span class="number">4</span>; <span class="comment">// a的类型是int, 所以b的类型也是int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//不论是顶层const还是底层const, decltype都会保留   </span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> c = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">decltype</span>(c) d = c; <span class="comment">// d的类型和c是一样的, 都是顶层const</span></span><br><span class="line"><span class="keyword">int</span> e = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* f = &amp;e; <span class="comment">// f是底层const</span></span><br><span class="line"><span class="keyword">decltype</span>(f) g = f; <span class="comment">// g也是底层const</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//引用与指针类型</span></span><br><span class="line"><span class="comment">//1. 如果表达式是引用类型, 那么decltype的类型也是引用</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> i = <span class="number">3</span>, &amp;j = i;</span><br><span class="line"><span class="keyword">decltype</span>(j) k = <span class="number">5</span>; <span class="comment">// k的类型是 const int&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 如果表达式是引用类型, 但是想要得到这个引用所指向的类型, 需要修改表达式:</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">3</span>, &amp;r = i;</span><br><span class="line"><span class="keyword">decltype</span>(r + <span class="number">0</span>) t = <span class="number">5</span>; <span class="comment">// 此时是int类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 对指针的解引用操作返回的是引用类型</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">3</span>, j = <span class="number">6</span>, *p = &amp;i;</span><br><span class="line"><span class="keyword">decltype</span>(*p) c = j; <span class="comment">// c是int&amp;类型, c和j绑定在一起</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//4. 如果一个表达式的类型不是引用, 但是我们需要推断出引用, 那么可以加上一对括号, 就变成了引用类型了</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">decltype</span>((i)) j = i; <span class="comment">// 此时j的类型是int&amp;类型, j和i绑定在了一起</span></span><br></pre></td></tr></table></figure></p>
<p>（3）decltype(auto)</p>
<p>decltype(auto)是C++14新增的类型指示符，可以用来声明变量以及指示函数返回类型。在使用时，会将“=”号左边的表达式替换掉auto，再根据decltype的语法规则来确定类型。举个例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> e = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* f = &amp;e; <span class="comment">// f是底层const</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) j = f;<span class="comment">//j的类型是const int* 并且指向的是e</span></span><br></pre></td></tr></table></figure></p>
<h1 id="C-中NULL和nullptr区别"><a href="#C-中NULL和nullptr区别" class="headerlink" title="C++中NULL和nullptr区别"></a>C++中NULL和nullptr区别</h1><p>算是为了与C语言进行兼容而定义的一个问题吧</p>
<p>NULL来自C语言，一般由宏定义实现，而 nullptr 则是C++11的新增关键字。在C语言中，NULL被定义为(void*)0,而在C++语言中，NULL则被定义为整数0。编译器一般对其实际定义如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NULL 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NULL ((void *)0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>在C++中指针必须有明确的类型定义。但是将NULL定义为0带来的另一个问题是无法与整数的0区分。因为C++中允许有函数重载，所以可以试想如下函数定义情况：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">char</span>* p)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"char*"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"int"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fun(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果：int</span></span><br></pre></td></tr></table></figure></p>
<p>那么在传入NULL参数时，会把NULL当做整数0来看，如果我们想调用参数是指针的函数，该怎么办呢?。nullptr在C++11被引入用于解决这一问题，nullptr可以明确区分整型和指针类型，能够根据环境自动转换成相应的指针类型，但不会被转换为任何整型，所以不会造成参数传递错误。</p>
<p>nullptr的一种实现方式如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">class</span> <span class="title">nullptr_t</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;  <span class="title">inline</span> <span class="title">operator</span> <span class="title">T</span>*() <span class="title">const</span>&#123;</span> <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">C</span>, <span class="title">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">operator</span> <span class="title">T</span> <span class="title">C</span>:</span>:*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>&amp;() <span class="keyword">const</span>;</span><br><span class="line">&#125; <span class="literal">nullptr</span> = &#123;&#125;;</span><br></pre></td></tr></table></figure></p>
<p>以上通过模板类和运算符重载的方式来对不同类型的指针进行实例化从而解决了(void*)指针带来参数类型不明的问题，另外由于nullptr是明确的指针类型，所以不会与整形变量相混淆。但nullptr仍然存在一定问题，例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">char</span>* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; <span class="string">"char* p"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span>* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; <span class="string">"int* p"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; <span class="string">"int p"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fun((<span class="keyword">char</span>*)<span class="literal">nullptr</span>);<span class="comment">//语句1</span></span><br><span class="line">    fun(<span class="literal">nullptr</span>);<span class="comment">//语句2</span></span><br><span class="line">    fun(<span class="literal">NULL</span>);<span class="comment">//语句3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果：</span></span><br><span class="line"><span class="comment">//语句1：char* p</span></span><br><span class="line"><span class="comment">//语句2:报错，有多个匹配</span></span><br><span class="line"><span class="comment">//3：int p</span></span><br></pre></td></tr></table></figure></p>
<p>在这种情况下存在对不同指针类型的函数重载，此时如果传入nullptr指针则仍然存在无法区分应实际调用哪个函数，这种情况下必须显示的指明参数类型。</p>
<h1 id="简要说明C-的内存分区"><a href="#简要说明C-的内存分区" class="headerlink" title="简要说明C++的内存分区"></a>简要说明C++的内存分区</h1><p>C++中的内存分区，分别# # 自由存# 全局/静态存# 常量存储区和代码区。如下图所示</p>
<p>图片</p>
<p>栈：在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限</p>
<p>堆：就是那些由 new分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个new就要对应一个 delete。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收</p>
<p>自由存储区：就是那些由malloc等分配的内存块，它和堆是十分相似的，不过它是用free来结束自己的生命的</p>
<p>全局/静态存储区：全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量和静态变量又分为初始化的和未初始化的，在C++里面没有这个区分了，它们共同占用同一块内存区，在该区定义的变量若没有初始化，则会被自动初始化，例如int型变量自动初始为0</p>
<p>常量存储区：这是一块比较特殊的存储区，这里面存放的是常量，不允许修改</p>
<p>代码区：存放函数体的二进制代码</p>
<p>《C/C++内存管理详解》：</p>
<p><a href="https://chenqx.github.io/2014/09/25/Cpp-Memory-Management/" target="_blank" rel="noopener">https://chenqx.github.io/2014/09/25/Cpp-Memory-Management/</a></p>
<h1 id="C-的异常处理的方法"><a href="#C-的异常处理的方法" class="headerlink" title="C++的异常处理的方法"></a>C++的异常处理的方法</h1><p>在程序执行过程中，由于程序员的疏忽或是系统资源紧张等因素都有可能导致异常，任何程序都无法保证绝对的稳定，常见的异常有：</p>
<p>数组下标越界</p>
<p>除法计算时除数为0</p>
<p>动态分配空间时空间不足</p>
<p>…</p>
<p>如果不及时对这些异常进行处理，程序多数情况下都会崩溃。</p>
<p>（1）t# throw和catch关键字</p>
<p>C++中的异常处理机制主要使用t# throw和catch三个关键字，其在程序中的用法如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> m = <span class="number">1</span>, n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"before dividing."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> - <span class="number">1</span>;  <span class="comment">//抛出int型异常</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (m == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> - <span class="number">1.0</span>;  <span class="comment">//拋出 double 型异常</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; m / n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"after dividing."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (<span class="keyword">double</span> d) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"catch (double)"</span> &lt;&lt; d &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (...) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"catch (...)"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"finished"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果</span></span><br><span class="line"><span class="comment">//before dividing.</span></span><br><span class="line"><span class="comment">//catch (...)</span></span><br><span class="line"><span class="comment">//finished</span></span><br></pre></td></tr></table></figure></p>
<p>代码中，对两个数进行除法计算，其中除数为0。可以看到以上三个关键字，程序的执行流程是先执行try包裹的语句块，如果执行过程中没有异常发生，则不会进入任何catch包裹的语句块。如果发生异常，则使用throw进行异常抛出，再由catch进行捕获，throw可以抛出各种数据类型的信息，代码中使用的是数字，也可以自定义异常class。</p>
<p>catch根据throw抛出的数据类型进行精确捕获（不会出现类型转换），如果匹配不到就直接报错，可以使用catch(…)的方式捕获任何异常（不推荐）。</p>
<p>当然，如果catch了异常，当前函数如果不进行处理，或者已经处理了想通知上一层的调用者，可以在catch里面再throw异常。</p>
<p>（2）函数的异常声明列表</p>
<p>有时候，程序员在定义函数的时候知道函数可能发生的异常，可以在函数声明和定义时，指出所能抛出异常的列表，写法如下：</p>
<p>int fun() throw(int,double,A,B,C){…};<br>这种写法表名函数可能会抛出int,double型或# # C三种类型的异常，如果throw中为空，表明不会抛出任何异常，如果没有throw则可能抛出任何异常</p>
<p>（3）C++标准异常类  exception</p>
<p>bad_typeid：使用typeid运算符，如果其操作数是一个多态类的指针，而该指针的值为 NULL，则会拋出此异常，例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~A();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A* a = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="built_in">cout</span> &lt;&lt; <span class="keyword">typeid</span>(*a).name() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// Error condition</span></span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">catch</span> (bad_typeid)&#123;</span><br><span class="line">          <span class="built_in">cout</span> &lt;&lt; <span class="string">"Object is NULL"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果：bject is NULL</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>bad_cast：在用 dynamic_cast 进行从多态基类对象（或引用）到派生类的引用的强制类型转换时，如果转换是不安全的，则会拋出此异常</li>
<li>bad_alloc：在用 new 运算符进行动态内存分配时，如果没有足够的内存，则会引发此异常</li>
<li>out_of_range:用 vector 或 string的at 成员函数根据下标访问元素时，如果下标越界，则会拋出此异常</li>
</ul>
<h1 id="静态变量什么时候初始化"><a href="#静态变量什么时候初始化" class="headerlink" title="静态变量什么时候初始化"></a>静态变量什么时候初始化</h1><p>1)  初始化只有一次，但是可以多次赋值，在主程序之前，编译器已经为其分配好了内存。</p>
<p>2)  静态局部变量和全局变量一样，数据都存放在全局区域，所以在主程序之前，编译器已经为其分配好了内存，但在C和C++中静态局部变量的初始化节点又有点不太一样。在C中，初始化发生在代码执行之前，编译阶段分配好内存之后，就会进行初始化，所以我们看到在C语言中无法使用变量对静态局部变量进行初始化，在程序运行结束，变量所处的全局内存会被全部回收。</p>
<p>3)  而在C++中，初始化时在执行相关代码时才会进行初始化，主要是由于C++引入对象后，要进行初始化必须执行相应构造函数和析构函数，在构造函数或析构函数中经常会需要进行某些程序中需要进行的特定操作，并非简单地分配内存。所以C++标准定为全局或静态对象是有首次用到时才会进行构造，并通过atexit()来管理。在程序结束，按照构造顺序反方向进行逐个析构。所以在C++中是可以使用变量对静态局部变量进行初始化的。</p>
<h1 id="值传递、指针传递、引用传递的区别和效率"><a href="#值传递、指针传递、引用传递的区别和效率" class="headerlink" title="值传递、指针传递、引用传递的区别和效率"></a>值传递、指针传递、引用传递的区别和效率</h1><ul>
<li>值传递：有一个形参向函数所属的栈拷贝数据的过程，如果值传递的对象是类对象   或是大的结构体对象，将耗费一定的时间和空间。（传值）</li>
<li>指针传递：同样有一个形参向函数所属的栈拷贝数据的过程，但拷贝的数据是一个固定为4字节的地址。（传值，传递的是地址值）</li>
<li>引用传递：同样有上述的数据拷贝过程，但其是针对地址的，相当于为该数据所在的地址起了一个别名。（传地址）</li>
<li>效率上讲，指针传递和引用传递比值传递效率高。一般主张使用引用传递，代码逻辑上更加紧凑、清晰。</li>
</ul>
<h1 id="什么是内存池，如何实现"><a href="#什么是内存池，如何实现" class="headerlink" title="什么是内存池，如何实现"></a>什么是内存池，如何实现</h1><p>内存池（Memory Pool） 是一种内存分配方式。通常我们习惯直接使用new、malloc 等申请内存，这样做的缺点在于：由于所申请内存块的大小不定，当频繁使用时会造成大量的内存碎片并进而降低性能。内存池则是在真正使用内存之前，先申请分配一定数量的、大小相等(一般情况下)的内存块留作备用。当有新的内存需求时，就从内存池中分出一部分内存块， 若内存块不够再继续申请新的内存。这样做的一个显著优点是尽量避免了内存碎片，使得内存分配效率得到提升。</p>
<p>这里简单描述一下《STL源码剖析》中的内存池实现机制：</p>
<p>allocate包装malloc,deallocate包装free</p>
<p>一般是一次20*2个的申请，先用一半，留着一半，为什么也没个说法，侯捷在STL那边书里说好像是C++委员会成员认为20是个比较好的数字，既不大也不小</p>
<p>首先客户端会调用malloc()配置一定数量的区块（固定大小的内存块，通常为8的倍数），假设40个32bytes的区块，其中20个区块（一半）给程序实际使用，1个区块交出，另外19个处于维护状态。剩余20个（一半）留给内存池，此时一共有（20*32byte）</p>
<p>客户端之后有有内存需求，想申请（20<em>64bytes）的空间，这时内存池只有（20</em>32bytes），就先将（10*64bytes)个区块返回，1个区块交出，另外9个处于维护状态，此时内存池空空如也</p>
<p>接下来如果客户端还有内存需求，就必须再调用malloc()配置空间，此时新申请的区块数量会增加一个随着配置次数越来越大的附加量，同样一半提供程序使用，另一半留给内存池。申请内存的时候用永远是先看内存池有无剩余，有的话就用上，然后挂在0-15号某一条链表上，要不然就重新申请。</p>
<p>如果整个堆的空间都不够了，就会在原先已经分配区块中寻找能满足当前需求的区块数量，能满足就返回，不能满足就向客户端报bad_alloc异常</p>
<p>allocator就是用来分配内存的，最重要的两个函数是allocate和deallocate，就是用来申请内存和回收内存的，外部（一般指容器）调用的时候只需要知道这些就够了。内部实现，目前的所有编译器都是直接调用的<code>::operator new()</code>和<code>::operator delete()</code>，说白了就是和直接使用new运算符的效果是一样的，所以老师说它们都没做任何特殊处理。</p>
<p>最开始GC2.9之前：</p>
<p>new和 operator new 的区别：new 是个运算符，编辑器会调用 operator new(0)</p>
<p><code>operator new()</code>里面有调用malloc的操作，那同样的 operator delete()里面有调用的free的操作</p>
<p>GCC2.9的alloc的一个比较好的分配器的实现规则</p>
<p>维护一条0-15号的一共16条链表，其中0表示8 bytes ，1表示 16 bytes,2表示 24bytes。。。。而15 表示 16* 8 = 128bytes，如果在申请时并不是8的倍数，那就找刚好能满足内存大小的那个位置。比如想申请 12，那就是找16了，想申请 20 ，那就找 24 了</p>
<p>但是现在GC4.9及其之后 也还有，变成_pool_alloc这个名字了，不再是默认的了，你需要自己去指定它可以自己指定，比如说<code>vector&lt;string,__gnu_cxx::pool_allocvec;</code>这样来使用它，现在用的又回到以前那种对malloc和free的包装形式了</p>
<h1 id="从汇编层去解释一下引用"><a href="#从汇编层去解释一下引用" class="headerlink" title="从汇编层去解释一下引用"></a>从汇编层去解释一下引用</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">9:      int x = 1;</span><br><span class="line">00401048  mov     dword ptr [ebp-4],1</span><br><span class="line">10:     int &amp;b = x;</span><br><span class="line">0040104F   lea     eax,[ebp-4]</span><br><span class="line">00401052  mov     dword ptr [ebp-8],eax</span><br></pre></td></tr></table></figure>
<p>x的地址为ebp-4，b的地址为ebp-8，因为栈内的变量内存是从高往低进行分配的，所以b的地址比x的低。</p>
<p><code>lea eax,[ebp-4]</code> 这条语句将x的地址ebp-4放入eax寄存器</p>
<p><code>mov dword ptr [ebp-8],eax</code>这条语句将eax的值放入b的地址</p>
<p><code>ebp-8</code>中上面两条汇编的作用即：将x的地址存入变量b中，这不和将某个变量的地址存入指针变量是一样的吗？所以从汇编层次来看，的确引用是通过指针来实现的。</p>
<h1 id="C-模板是什么，你知道底层怎么实现的？"><a href="#C-模板是什么，你知道底层怎么实现的？" class="headerlink" title="C++模板是什么，你知道底层怎么实现的？"></a>C++模板是什么，你知道底层怎么实现的？</h1><p>1)  编译器并不是把函数模板处理成能够处理任意类的函数；编译器从函数模板通过具体类型产生不同的函数；编译器会对函数模板进行两次编译：在声明的地方对模板代码本身进行编译，在调用的地方对参数替换后的代码进行编译。</p>
<p>2)  这是因为函数模板要被实例化后才能成为真正的函数，在使用函数模板的源文件中包含函数模板的头文件，如果该头文件中只有声明，没有定义，那编译器无法实例化该模板，最终导致链接错误。</p>
<h1 id="什么是内存泄露，如何检测与避免"><a href="#什么是内存泄露，如何检测与避免" class="headerlink" title="什么是内存泄露，如何检测与避免"></a>什么是内存泄露，如何检测与避免</h1><h2 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h2><p>一般我们常说的内存泄漏是指堆内存的泄漏。堆内存是指程序从堆中分配的，大小任意的(内存块的大小可以在程序运行期决定)内存块，使用完后必须显式释放的内存。应用程序般使用malloc,、realloc、 new等函数从堆中分配到块内存，使用完后，程序必须负责相应的调用free或delete释放该内存块，否则，这块内存就不能被再次使用，我们就说这块内存泄漏了</p>
<h2 id="避免内存泄露的几种方式"><a href="#避免内存泄露的几种方式" class="headerlink" title="避免内存泄露的几种方式"></a>避免内存泄露的几种方式</h2><ul>
<li>计数法：使用new或者malloc时，让该数+1，delete或free时，该数-1，程序执行完打印这个计数，如果不为0则表示存在内存泄露</li>
<li>一定要将基类的析构函数声明为虚函数</li>
<li>对象数组的释放一定要用delete []</li>
<li>有new就有delete，有malloc就有free，保证它们一定成对出现</li>
</ul>
<h1 id="对象复用的了解，零拷贝的了解"><a href="#对象复用的了解，零拷贝的了解" class="headerlink" title="对象复用的了解，零拷贝的了解"></a>对象复用的了解，零拷贝的了解</h1><h2 id="对象复用"><a href="#对象复用" class="headerlink" title="对象复用"></a>对象复用</h2><p>对象复用其本质是一种设计模式：Flyweight享元模式。</p>
<p>通过将对象存储到“对象池”中实现对象的重复利用，这样可以避免多次创建重复对象的开销，节约系统资源。</p>
<h2 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h2><p>零拷贝就是一种避免 CPU 将数据从一块存储拷贝到另外一块存储的技术。</p>
<p>零拷贝技术可以减少数据拷贝和共享总线操作的次数。</p>
<p>在C++中，vector的一个成员函数emplace_back()很好地体现了零拷贝技术，它跟push_back()函数一样可以将一个元素插入容器尾部，区别在于：使用push_back()函数需要调用拷贝构造函数和转移构造函数，而使用emplace_back()插入的元素原地构造，不需要触发拷贝构造和转移构造，效率更高。举个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">//初始构造函数</span></span><br><span class="line">    Person(<span class="built_in">string</span> p_name, <span class="keyword">int</span> p_age): name(<span class="built_in">std</span>::move(p_name)), age(p_age)</span><br><span class="line">    &#123;</span><br><span class="line">         <span class="built_in">cout</span> &lt;&lt; <span class="string">"I have been constructed"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">//拷贝构造函数</span></span><br><span class="line">     Person(<span class="keyword">const</span> Person&amp; other): name(<span class="built_in">std</span>::move(other.name)), age(other.age)</span><br><span class="line">    &#123;</span><br><span class="line">         <span class="built_in">cout</span> &lt;&lt; <span class="string">"I have been copy constructed"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">//转移构造函数</span></span><br><span class="line">     Person(Person&amp;&amp; other): name(<span class="built_in">std</span>::move(other.name)), age(other.age)</span><br><span class="line">    &#123;</span><br><span class="line">         <span class="built_in">cout</span> &lt;&lt; <span class="string">"I have been moved"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Person&gt; e;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"emplace_back:"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    e.emplace_back(<span class="string">"Jane"</span>, <span class="number">23</span>); <span class="comment">//不用构造类对象</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;Person&gt; p;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"push_back:"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    p.push_back(Person(<span class="string">"Mike"</span>,<span class="number">36</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果：</span></span><br><span class="line"><span class="comment">//emplace_back:</span></span><br><span class="line"><span class="comment">//I have been constructed</span></span><br><span class="line"><span class="comment">//push_back:</span></span><br><span class="line"><span class="comment">//I have been constructed</span></span><br><span class="line"><span class="comment">//I am being moved.</span></span><br></pre></td></tr></table></figure>
<h1 id="解释一下什么是trivial-destructor"><a href="#解释一下什么是trivial-destructor" class="headerlink" title="解释一下什么是trivial destructor"></a>解释一下什么是trivial destructor</h1><p>“trivial destructor”一般是指用户没有自定义析构函数，而由系统生成的，这种析构函数在《STL源码解析》中成为“无关痛痒”的析构函数。</p>
<p>反之，用户自定义了析构函数，则称之为“non-trivial destructor”，这种析构函数如果申请了新的空间一定要显式的释放，否则会造成内存泄露</p>
<p>对于trivial destructor，如果每次都进行调用，显然对效率是一种伤害，如何进行判断呢？《STL源码解析》中给出的说明是：</p>
<p>首先利用<code>value_type()</code>获取所指对象的型别，再利用<strong>type_traits判断该型别的析构函数是否trivial，若是`(</strong>true_type)<code>，则什么也不做，若为</code>(__false_type)`，则去调用destory()函数</p>
<p>也就是说，在实际的应用当中，STL库提供了相关的判断方法__type_traits，感兴趣的读者可以自行查阅使用方式。除了trivial destructor，还有trivial construct、trivial copy construct等，如果能够对是否trivial进行区分，可以采用内存处理函数memcpy()、malloc()等更加高效的完成相关操作，提升效率。</p>
<h1 id="C-中类的数据成员和成员函数内存分布情况"><a href="#C-中类的数据成员和成员函数内存分布情况" class="headerlink" title="C++中类的数据成员和成员函数内存分布情况"></a>C++中类的数据成员和成员函数内存分布情况</h1><p>C++类是由结构体发展得来的，所以他们的成员变量（C语言的结构体只有成员变量）的内存分配机制是一样的。下面我们以类来说明问题，如果类的问题通了，结构体也也就没问题啦。类分为成员变量和成员函数，我们先来讨论成员变量。</p>
<p>一个类对象的地址就是类所包含的这一片内存空间的首地址，这个首地址也就对应具体某一个成员变量的地址。（在定义类对象的同时这些成员变量也就被定义了），举个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age = <span class="number">23</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printAge</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="keyword">this</span>-&gt;age &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Person()&#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person p;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"对象地址："</span>&lt;&lt; &amp;p &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"age地址："</span>&lt;&lt; &amp;(p.age) &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"对象大小："</span>&lt;&lt; <span class="keyword">sizeof</span>(p) &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"age大小："</span>&lt;&lt; <span class="keyword">sizeof</span>(p.age) &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="comment">//对象地址：0x7fffec0f15a8</span></span><br><span class="line"><span class="comment">//age地址：0x7fffec0f15a8</span></span><br><span class="line"><span class="comment">//对象大小：4</span></span><br><span class="line"><span class="comment">//age大小：4</span></span><br></pre></td></tr></table></figure>
<p>从代码运行结果来看，对象的大小和对象中数据成员的大小是一致的，也就是说，成员函数不占用对象的内存。这是因为所有的函数都是存放在代码区的，不管是全局函数，还是成员函数。要是成员函数占用类的对象空间，那么将是多么可怕的事情：定义一次类对象就有成员函数占用一段空间。我们再来补充一下静态成员函数的存放问题：静态成员函数与一般成员函数的唯一区别就是没有this指针，因此不能访问非静态数据成员，就像我前面提到的，所有函数都存放在代码区，静态函数也不例外。所有有人一看到 static 这个单词就主观的认为是存放在全局数据区，那是不对的。</p>
<h1 id="析构函数的作用，如何起作用？"><a href="#析构函数的作用，如何起作用？" class="headerlink" title="析构函数的作用，如何起作用？"></a>析构函数的作用，如何起作用？</h1><p>1)  构造函数只是起初始化值的作用，但实例化一个对象的时候，可以通过实例去传递参数，从主函数传递到其他的函数里面，这样就使其他的函数里面有值了。</p>
<p>规则，只要你一实例化对象，系统自动回调用一个构造函数就是你不写，编译器也自动调用一次。</p>
<p>2)  析构函数与构造函数的作用相反，用于撤销对象的一些特殊任务处理，可以是释放对象分配的内存空间；特点：析构函数与构造函数同名，但该函数前面加~。</p>
<p>析构函数没有参数，也没有返回值，而且不能重载，在一个类中只能有一个析构函数。当撤销对象时，编译器也会自动调用析构函数。</p>
<p>每一个类必须有一个析构函数，用户可以自定义析构函数，也可以是编译器自动生成默认的析构函数。一般析构函数定义为类的公有成员。</p>
<h1 id="构造函数析构函数可否抛出异常"><a href="#构造函数析构函数可否抛出异常" class="headerlink" title="构造函数析构函数可否抛出异常"></a>构造函数析构函数可否抛出异常</h1><p>1)   C++只会析构已经完成的对象，对象只有在其构造函数执行完毕才算是完全构造妥当。在构造函数中发生异常，控制权转出构造函数之外。</p>
<p>因此，在对象b的构造函数中发生异常，对象b的析构函数不会被调用。因此会造成内存泄漏。</p>
<p>2)  用auto_ptr对象来取代指针类成员，便对构造函数做了强化，免除了抛出异常时发生资源泄漏的危机，不再需要在析构函数中手动释放资源；</p>
<p>3)  如果控制权基于异常的因素离开析构函数，而此时正有另一个异常处于作用状态，C++会调用terminate函数让程序结束；</p>
<p>4)  如果异常从析构函数抛出，而且没有在当地进行捕捉，那个析构函数便是执行不全的。如果析构函数执行不全，就是没有完成他应该执行的每一件事情。</p>
<h1 id="类什么时候会析构？"><a href="#类什么时候会析构？" class="headerlink" title="类什么时候会析构？"></a>类什么时候会析构？</h1><p>1)  对象生命周期结束，被销毁时；</p>
<p>2)  delete指向对象的指针时，或delete指向对象的基类类型指针，而其基类虚构函数是虚函数时；</p>
<p>3)  对象i是对象o的成员，o的析构函数被调用时，对象i的析构函数也被调用。</p>
<h1 id="构造函数的几种关键字"><a href="#构造函数的几种关键字" class="headerlink" title="构造函数的几种关键字"></a>构造函数的几种关键字</h1><p>default</p>
<p>default关键字可以显式要求编译器生成合成构造函数，防止在调用时相关构造函数类型没有定义而报错</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CString</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CString() = <span class="keyword">default</span>; <span class="comment">//语句1</span></span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    CString(<span class="keyword">const</span> <span class="keyword">char</span>* pstr) : _str(pstr)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">()</span> </span>= <span class="keyword">delete</span>;<span class="comment">//这样不允许使用new关键字</span></span><br><span class="line">    <span class="comment">//析构函数</span></span><br><span class="line">    ~CString()&#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="built_in">string</span> _str;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">auto</span> a = <span class="keyword">new</span> CString(); <span class="comment">//语句2</span></span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello World"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果</span></span><br><span class="line"><span class="comment">//Hello World</span></span><br></pre></td></tr></table></figure>
<p>如果没有加语句1，语句2会报错，表示找不到参数为空的构造函数，将其设置为default可以解决这个问题</p>
<p>delete</p>
<p>delete关键字可以删除构造函数、赋值运算符函数等，这样在使用的时候会得到友善的提示</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CString</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">()</span> </span>= <span class="keyword">delete</span>;<span class="comment">//这样不允许使用new关键字</span></span><br><span class="line">    <span class="comment">//析构函数</span></span><br><span class="line">    ~CString()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">auto</span> a = <span class="keyword">new</span> CString(); <span class="comment">//语句1</span></span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello World"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在执行语句1时，会提示new方法已经被删除，如果将new设置为私有方法，则会报惨不忍睹的错误，因此使用delete关键字可以更加人性化的删除一些默认方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">=<span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>将虚函数定义为纯虚函数（纯虚函数无需定义，= 0只能出现在类内部虚函数的声明语句处；当然，也可以为纯虚函数提供定义，不过函数体必须定义在类的外部）</p>
<h1 id="C-函数调用的压栈过程"><a href="#C-函数调用的压栈过程" class="headerlink" title="C++函数调用的压栈过程"></a>C++函数调用的压栈过程</h1><p>从代码入手，解释这个过程：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> param1, <span class="keyword">int</span> param2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var1 = param1;</span><br><span class="line">    <span class="keyword">int</span> var2 = param2;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"var1=%d,var2=%d"</span>, f(var1), f(var2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    func(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//var1=1,var2=2</span></span><br></pre></td></tr></table></figure>
<p>当函数从入口函数main函数开始执行时，编译器会将我们操作系统的运行状态，main函数的返回地址、main的参数、mian函数中的变量、进行依次压栈；</p>
<p>当main函数开始调用func()函数时，编译器此时会将main函数的运行状态进行压栈，再将func()函数的返回地址、func()函数的参数从右到左、func()定义变量依次压栈；</p>
<p>当func()调用f()的时候，编译器此时会将func()函数的运行状态进行压栈，再将的返回地址、f()函数的参数从右到左、f()定义变量依次压栈</p>
<p>从代码的输出结果可以看出，函数f(var1)、f(var2)依次入栈，而后先执行f(var2)，再执行f(var1)，最后打印整个字符串，将栈中的变量依次弹出，最后主函数返回。</p>
<h1 id="说说移动构造函数"><a href="#说说移动构造函数" class="headerlink" title="说说移动构造函数"></a>说说移动构造函数</h1><p>1)  我们用对象a初始化对象b，后对象a我们就不在使用了，但是对象a的空间还在呀（在析构之前），既然拷贝构造函数，实际上就是把a对象的内容复制一份到b中，那么为什么我们不能直接使用a的空间呢？这样就避免了新的空间的分配，大大降低了构造的成本。这就是移动构造函数设计的初衷；</p>
<p>2)  拷贝构造函数中，对于指针，我们一定要采用深层复制，而移动构造函数中，对于指针，我们采用浅层复制。浅层复制之所以危险，是因为两个指针共同指向一片内存空间，若第一个指针将其释放，另一个指针的指向就不合法了。</p>
<p>所以我们只要避免第一个指针释放空间就可以了。避免的方法就是将第一个指针（比如a-&gt;value）置为NULL，这样在调用析构函数的时候，由于有判断是否为NULL的语句，所以析构a的时候并不会回收a-&gt;value指向的空间；</p>
<p>3)  移动构造函数的参数和拷贝构造函数不同，拷贝构造函数的参数是一个左值引用，但是移动构造函数的初值是一个右值引用。意味着，移动构造函数的参数是一个右值或者将亡值的引用。也就是说，只用用一个右值，或者将亡值初始化另一个对象的时候，才会调用移动构造函数。而那个move语句，就是将一个左值变成一个将亡值。</p>
<h1 id="C-中将临时变量作为返回值时的处理过程"><a href="#C-中将临时变量作为返回值时的处理过程" class="headerlink" title="C++中将临时变量作为返回值时的处理过程"></a>C++中将临时变量作为返回值时的处理过程</h1><p>首先需要明白一件事情，临时变量，在函数调用过程中是被压到程序进程的栈中的，当函数退出时，临时变量出栈，即临时变量已经被销毁，临时变量占用的内存空间没有被清空，但是可以被分配给其他变量，所以有可能在函数退出时，该内存已经被修改了，对于临时变量来说已经是没有意义的值了</p>
<p>C语言里规定：16bit程序中，返回值保存在ax寄存器中，32bit程序中，返回值保持在eax寄存器中，如果是64bit返回值，edx寄存器保存高32bit，eax寄存器保存低32bit</p>
<p>由此可见，函数调用结束后，返回值被临时存储到寄存器中，并没有放到堆或栈中，也就是说与内存没有关系了。当退出函数的时候，临时变量可能被销毁，但是返回值却被放到寄存器中与临时变量的生命周期没有关系</p>
<p>如果我们需要返回值，一般使用赋值语句就可以了</p>
<h1 id="关于this指针你知道什么？全说出来"><a href="#关于this指针你知道什么？全说出来" class="headerlink" title="关于this指针你知道什么？全说出来"></a>关于this指针你知道什么？全说出来</h1><p>this指针是类的指针，指向对象的首地址。</p>
<p>this指针只能在成员函数中使用，在全局函数、静态成员函数中都不能用this。</p>
<p>this指针只有在成员函数中才有定义，且存储位置会因编译器不同有不同存储位置。</p>
<h2 id="this指针的用处"><a href="#this指针的用处" class="headerlink" title="this指针的用处"></a>this指针的用处</h2><p>一个对象的this指针并不是对象本身的一部分，不会影响sizeof(对象)的结果。this作用域是在类内部，当在类的非静态成员函数中访问类的非静态成员的时候（全局函数，静态函数中不能使用this指针），编译器会自动将对象本身的地址作为一个隐含参数传递给函数。也就是说，即使你没有写上this指针，编译器在编译的时候也是加上this的，它作为非静态成员函数的隐含形参，对各成员的访问均通过this进行</p>
<h2 id="this指针的使用"><a href="#this指针的使用" class="headerlink" title="this指针的使用"></a>this指针的使用</h2><p>一种情况就是，在类的非静态成员函数中返回类对象本身的时候，直接使用 return *this；</p>
<p>另外一种情况是当形参数与成员变量名相同时用于区分，如this-&gt;n = n （不能写成n = n）</p>
<p>类的this指针有以下特点</p>
<p>(1）this只能在成员函数中使用，全局函数、静态函数都不能使用this。实际上，成员函数默认第一个参数为T * const this</p>
<p>如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">其中，func的原型在编译器看来应该是：</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(A * <span class="keyword">const</span> <span class="keyword">this</span>,<span class="keyword">int</span> p)</span></span>;</span><br></pre></td></tr></table></figure>
<p>（2）由此可见，this在成员函数的开始前构造，在成员函数的结束后清除。这个生命周期同任何一个函数的参数是一样的，没有任何区别。当调用一个类的成员函数时，编译器将类的指针作为函数的this参数传递进去。如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A a;</span><br><span class="line">a.func(<span class="number">10</span>);</span><br><span class="line"><span class="comment">//此处，编译器将会编译成：</span></span><br><span class="line">A::func(&amp;a,<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>看起来和静态函数没差别，对吗？不过，区别还是有的。编译器通常会对this指针做一些优化，因此，this指针的传递效率比较高，例如VC通常是通过ecx（计数寄存器）传递this参数的。</p>
<h1 id="几个this指针的易混问题"><a href="#几个this指针的易混问题" class="headerlink" title="几个this指针的易混问题"></a>几个this指针的易混问题</h1><h2 id="this指针是什么时候创建的？"><a href="#this指针是什么时候创建的？" class="headerlink" title="this指针是什么时候创建的？"></a>this指针是什么时候创建的？</h2><p>this在成员函数的开始执行前构造，在成员的执行结束后清除。</p>
<p>但是如果class或者struct里面没有方法的话，它们是没有构造函数的，只能当做C的struct使用。采用TYPE xx的方式定义的话，在栈里分配内存，这时候this指针的值就是这块内存的地址。采用new的方式创建对象的话，在堆里分配内存，new操作符通过eax（累加寄存器）返回分配的地址，然后设置给指针变量。之后去调用构造函数（如果有构造函数的话），这时将这个内存块的地址传给ecx，之后构造函数里面怎么处理请看上面的回答</p>
<h2 id="this指针存放在何处？堆、栈、全局变量，还是其他？"><a href="#this指针存放在何处？堆、栈、全局变量，还是其他？" class="headerlink" title="this指针存放在何处？堆、栈、全局变量，还是其他？"></a>this指针存放在何处？堆、栈、全局变量，还是其他？</h2><p>this指针会因编译器不同而有不同的放置位置。可能是栈，也可能是寄存器，甚至全局变量。在汇编级别里面，一个值只会以3种形式出现：立即数、寄存器值和内存变量值。不是存放在寄存器就是存放在内存中，它们并不是和高级语言变量对应的。</p>
<h2 id="this指针是如何传递类中的函数的？绑定？还是在函数参数的首参数就是this指针？那么，this指针又是如何找到“类实例后函数的”？"><a href="#this指针是如何传递类中的函数的？绑定？还是在函数参数的首参数就是this指针？那么，this指针又是如何找到“类实例后函数的”？" class="headerlink" title="this指针是如何传递类中的函数的？绑定？还是在函数参数的首参数就是this指针？那么，this指针又是如何找到“类实例后函数的”？"></a>this指针是如何传递类中的函数的？绑定？还是在函数参数的首参数就是this指针？那么，this指针又是如何找到“类实例后函数的”？</h2><p>大多数编译器通过ecx（寄数寄存器）寄存器传递this指针。事实上，这也是一个潜规则。一般来说，不同编译器都会遵从一致的传参规则，否则不同编译器产生的obj就无法匹配了。</p>
<p>在call之前，编译器会把对应的对象地址放到eax中。this是通过函数参数的首参来传递的。this指针在调用之前生成，至于“类实例后函数”，没有这个说法。类在实例化时，只分配类中的变量空间，并没有为函数分配空间。自从类的函数定义完成后，它就在那儿，不会跑的</p>
<h2 id="this指针是如何访问类中的变量的？"><a href="#this指针是如何访问类中的变量的？" class="headerlink" title="this指针是如何访问类中的变量的？"></a>this指针是如何访问类中的变量的？</h2><p>如果不是类，而是结构体的话，那么，如何通过结构指针来访问结构中的变量呢？如果你明白这一点的话，就很容易理解这个问题了。</p>
<p>在C++中，类和结构是只有一个区别的：类的成员默认是private，而结构是public。</p>
<p>this是类的指针，如果换成结构体，那this就是结构的指针了。</p>
<h2 id="我们只有获得一个对象后，才能通过对象使用this指针。如果我们知道一个对象this指针的位置，可以直接使用吗？"><a href="#我们只有获得一个对象后，才能通过对象使用this指针。如果我们知道一个对象this指针的位置，可以直接使用吗？" class="headerlink" title="我们只有获得一个对象后，才能通过对象使用this指针。如果我们知道一个对象this指针的位置，可以直接使用吗？"></a>我们只有获得一个对象后，才能通过对象使用this指针。如果我们知道一个对象this指针的位置，可以直接使用吗？</h2><p>this指针只有在成员函数中才有定义。因此，你获得一个对象后，也不能通过对象使用this指针。所以，我们无法知道一个对象的this指针的位置（只有在成员函数里才有this指针的位置）。当然，在成员函数里，你是可以知道this指针的位置的（可以通过&amp;this获得），也可以直接使用它。</p>
<h2 id="每个类编译后，是否创建一个类中函数表保存函数指针，以便用来调用函数？"><a href="#每个类编译后，是否创建一个类中函数表保存函数指针，以便用来调用函数？" class="headerlink" title="每个类编译后，是否创建一个类中函数表保存函数指针，以便用来调用函数？"></a>每个类编译后，是否创建一个类中函数表保存函数指针，以便用来调用函数？</h2><p>普通的类函数（不论是成员函数，还是静态函数）都不会创建一个函数表来保存函数指针。只有虚函数才会被放到函数表中。但是，即使是虚函数，如果编译期就能明确知道调用的是哪个函数，编译器就不会通过函数表中的指针来间接调用，而是会直接调用该函数。正是由于this指针的存在，用来指向不同的对象，从而确保不同对象之间调用相同的函数可以互不干扰</p>
<h1 id="构造函数、拷贝构造函数和赋值操作符的区别"><a href="#构造函数、拷贝构造函数和赋值操作符的区别" class="headerlink" title="构造函数、拷贝构造函数和赋值操作符的区别"></a>构造函数、拷贝构造函数和赋值操作符的区别</h1><p>构造函数</p>
<p>对象不存在，没用别的对象初始化，在创建一个新的对象时调用构造函数</p>
<p>拷贝构造函数</p>
<p>对象不存在，但是使用别的已经存在的对象来进行初始化</p>
<p>赋值运算符</p>
<p>对象存在，用别的对象给它赋值，这属于重载“=”号运算符的范畴，“=”号两侧的对象都是已存在的</p>
<p>举个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"我是构造函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    A(<span class="keyword">const</span> A&amp; a)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"我是拷贝构造函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    A&amp; <span class="keyword">operator</span> = (A&amp; a)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"我是赋值操作符"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~A() &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a1; <span class="comment">//调用构造函数</span></span><br><span class="line">    A a2 = a1; <span class="comment">//调用拷贝构造函数</span></span><br><span class="line">    a2 = a1; <span class="comment">//调用赋值操作符</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="comment">//我是构造函数</span></span><br><span class="line"><span class="comment">//我是拷贝构造函数</span></span><br><span class="line"><span class="comment">//我是赋值操作符</span></span><br></pre></td></tr></table></figure>
<h1 id="静态类型和动态类型以及静态绑定和动态绑定的总结"><a href="#静态类型和动态类型以及静态绑定和动态绑定的总结" class="headerlink" title="静态类型和动态类型以及静态绑定和动态绑定的总结"></a>静态类型和动态类型以及静态绑定和动态绑定的总结</h1><ul>
<li>静态类型：对象在声明时采用的类型，在编译期既已确定；</li>
<li>动态类型：通常是指一个指针或引用目前所指对象的类型，是在运行期决定的；</li>
<li>静态绑定：绑定的是静态类型，所对应的函数或属性依赖于对象的静态类型，发生在编译期；</li>
<li>动态绑定：绑定的是动态类型，所对应的函数或属性依赖于对象的动态类型，发生在运行期；</li>
</ul>
<p>从上面的定义也可以看出，非虚函数一般都是静态绑定，而虚函数都是动态绑定（如此才可实现多态性）。</p>
<h1 id="引用是否能实现动态绑定，为什么可以实现？"><a href="#引用是否能实现动态绑定，为什么可以实现？" class="headerlink" title="引用是否能实现动态绑定，为什么可以实现？"></a>引用是否能实现动态绑定，为什么可以实现？</h1><p>可以。</p>
<p>引用在创建的时候必须初始化，在访问虚函数时，编译器会根据其所绑定的对象类型决定要调用哪个函数。注意只能调用虚函数。</p>
<p>举个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span>  <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"base :: fun()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span>  <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"son :: fun()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"son :: not virtual function"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Son s;</span><br><span class="line">    Base&amp; b = s; <span class="comment">// 基类类型引用绑定已经存在的Son对象，引用必须初始化</span></span><br><span class="line">    s.fun(); <span class="comment">//son::fun()</span></span><br><span class="line">    b.fun(); <span class="comment">//son :: fun()</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要说明的是虚函数才具有动态绑定，上面代码中，Son类中还有一个非虚函数func()，这在b对象中是无法调用的，如果使用基类指针来指向子类也是一样的。</p>
<h1 id="全局变量和局部变量有什么区别？"><a href="#全局变量和局部变量有什么区别？" class="headerlink" title="全局变量和局部变量有什么区别？"></a>全局变量和局部变量有什么区别？</h1><p>生命周期不同：全局变量随主程序创建和创建，随主程序销毁而销毁；局部变量在局部函数内部，甚至局部循环体等内部存在，退出就不存在；</p>
<p>使用方式不同：通过声明后全局变量在程序的各个部分都可以用到；局部变量分配在堆栈区，只能在局部使用。</p>
<p>操作系统和编译器通过内存分配的位置可以区分两者，全局变量分配在全局数据段并且在程序开始运行的时候被加载，局部变量则分配在堆栈里面 。</p>
<h1 id="指针加减计算要注意什么？"><a href="#指针加减计算要注意什么？" class="headerlink" title="指针加减计算要注意什么？"></a>指针加减计算要注意什么？</h1><p>指针加减本质是对其所指地址的移动，移动的步长跟指针的类型是有关系的，因此在涉及到指针加减运算需要十分小心，加多或者减多都会导致指针指向一块未知的内存地址，如果再进行操作就会很危险。</p>
<p>举个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *a, *b, c;</span><br><span class="line">    a = (<span class="keyword">int</span>*)<span class="number">0x500</span>;</span><br><span class="line">    b = (<span class="keyword">int</span>*)<span class="number">0x520</span>;</span><br><span class="line">    c = b - a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, c); <span class="comment">// 8</span></span><br><span class="line">    a += <span class="number">0x020</span>;</span><br><span class="line">    c = b - a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, c); <span class="comment">// -24</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先变量a和b都是以16进制的形式初始化，将它们转成10进制分别是1280（5<em>16\^2=1280）和1312（5</em>16\^2+2*16=1312)， 那么它们的差值为32，也就是说a和b所指向的地址之间间隔32个位，但是考虑到是int类型占4位，所以c的值为32/4=8</p>
<p>a自增16进制0x20之后，其实际地址变为1280 + 2<em>16</em>4 = 1408，（因为一个int占4位，所以要乘4），这样它们的差值就变成了1312 - 1280 = -96，所以c的值就变成了-96/4 = -24</p>
<p>遇到指针的计算，需要明确的是指针每移动一位，它实际跨越的内存间隔是指针类型的长度，建议都转成10进制计算，计算结果除以类型长度取得结果</p>
<h1 id="怎样判断两个浮点数是否相等？"><a href="#怎样判断两个浮点数是否相等？" class="headerlink" title="怎样判断两个浮点数是否相等？"></a>怎样判断两个浮点数是否相等？</h1><p>对两个浮点数判断大小和是否相等不能直接用==来判断，会出错！明明相等的两个数比较反而是不相等！对于两个浮点数比较只能通过相减并与预先设定的精度比较，记得要取绝对值！浮点数与0的比较也应该注意。与浮点数的表示方式有关。</p>
<h1 id="方法调用的原理（栈、汇编）"><a href="#方法调用的原理（栈、汇编）" class="headerlink" title="方法调用的原理（栈、汇编）"></a>方法调用的原理（栈、汇编）</h1><p>1)  机器用栈来传递过程参数、存储返回信息、保存寄存器用于以后恢复，以及本地存储。而为单个过程分配的那部分栈称为帧栈；帧栈可以认为是程序栈的一段，它有两个端点，一个标识起始地址，一个标识着结束地址，两个指针结束地址指针esp，开始地址指针ebp;</p>
<p>2)  由一系列栈帧构成，这些栈帧对应一个过程，而且每一个栈指针+4的位置存储函数返回地址；每一个栈帧都建立在调用者的下方，当被调用者执行完毕时，这一段栈帧会被释放。由于栈帧是向地址递减的方向延伸，因此如果我们将栈指针减去一定的值，就相当于给栈帧分配了一定空间的内存。如果将栈指针加上一定的值，也就是向上移动，那么就相当于压缩了栈帧的长度，也就是说内存被释放了。</p>
<p>3)  过程实现</p>
<ul>
<li>备份原来的帧指针，调整当前的栈帧指针到栈指针位置；</li>
<li>建立起来的栈帧就是为被调用者准备的，当被调用者使用栈帧时，需要给临时变量分配预留内存；</li>
<li>使用建立好的栈帧，比如读取和写入，一般使用mov，push以及pop指令等等。</li>
<li>恢复被调用者寄存器当中的值，这一过程其实是从栈帧中将备份的值再恢复到寄存器，不过此时这些值可能已经不在栈顶了</li>
<li>恢复被调用者寄存器当中的值，这一过程其实是从栈帧中将备份的值再恢复到寄存器，不过此时这些值可能已经不在栈顶了。</li>
<li>释放被调用者的栈帧，释放就意味着将栈指针加大，而具体的做法一般是直接将栈指针指向帧指针，因此会采用类似下面的汇编代码处理。</li>
<li>恢复调用者的栈帧，恢复其实就是调整栈帧两端，使得当前栈帧的区域又回到了原始的位置。</li>
<li>弹出返回地址，跳出当前过程，继续执行调用者的代码。</li>
</ul>
<p>4)  过程调用和返回指令</p>
<ul>
<li>call指令</li>
<li>leave指令</li>
<li>ret指令</li>
</ul>
<h1 id="C-中的指针参数传递和引用参数传递有什么区别？底层原理你知道吗？"><a href="#C-中的指针参数传递和引用参数传递有什么区别？底层原理你知道吗？" class="headerlink" title="C++中的指针参数传递和引用参数传递有什么区别？底层原理你知道吗？"></a>C++中的指针参数传递和引用参数传递有什么区别？底层原理你知道吗？</h1><p>1) 指针参数传递本质上是值传递，它所传递的是一个地址值。</p>
<p>值传递过程中，被调函数的形式参数作为被调函数的局部变量处理，会在栈中开辟内存空间以存放由主调函数传递进来的实参值，从而形成了实参的一个副本（替身）。</p>
<p>值传递的特点是，被调函数对形式参数的任何操作都是作为局部变量进行的，不会影响主调函数的实参变量的值（形参指针变了，实参指针不会变）。</p>
<p>2) 引用参数传递过程中，被调函数的形式参数也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。</p>
<p>被调函数对形参（本体）的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量（根据别名找到主调函数中的本体）。</p>
<p>因此，被调函数对形参的任何操作都会影响主调函数中的实参变量。</p>
<p>3) 引用传递和指针传递是不同的，虽然他们都是在被调函数栈空间上的一个局部变量，但是任何对于引用参数的处理都会通过一个间接寻址的方式操作到主调函数中的相关变量。</p>
<p>而对于指针传递的参数，如果改变被调函数中的指针地址，它将应用不到主调函数的相关变量。如果想通过指针参数传递来改变主调函数中的相关变量（地址），那就得使用指向指针的指针或者指针引用。</p>
<p>4) 从编译的角度来讲，程序在编译时分别将指针和引用添加到符号表上，符号表中记录的是变量名及变量所对应地址。</p>
<p>指针变量在符号表上对应的地址值为指针变量的地址值，而引用在符号表上对应的地址值为引用对象的地址值（与实参名字不同，地址相同）。</p>
<p>符号表生成之后就不会再改，因此指针可以改变其指向的对象（指针变量中的值可以改），而引用对象则不能修改。</p>
<h1 id="类如何实现只能静态分配和只能动态分配"><a href="#类如何实现只能静态分配和只能动态分配" class="headerlink" title="类如何实现只能静态分配和只能动态分配"></a>类如何实现只能静态分配和只能动态分配</h1><p>1)  前者是把new、delete运算符重载为private属性。后者是把构造、析构函数设为protected属性，再用子类来动态创建</p>
<p>2)  建立类的对象有两种方式：</p>
<ul>
<li>静态建立，静态建立一个类对象，就是由编译器为对象在栈空间中分配内存；</li>
<li>动态建立，A *p = new A();动态建立一个类对象，就是使用new运算符为对象在堆空间中分配内存。这个过程分为两步，第一步执行operator new()函数，在堆中搜索一块内存并进行分配；第二步调用类构造函数构造对象；</li>
</ul>
<p>3)  只有使用new运算符，对象才会被建立在堆上，因此只要限制new运算符就可以实现类对象只能建立在栈上，可以将new运算符设为私有。</p>
<h1 id="如果想将某个类用作基类，为什么该类必须定义而非声明？"><a href="#如果想将某个类用作基类，为什么该类必须定义而非声明？" class="headerlink" title="如果想将某个类用作基类，为什么该类必须定义而非声明？"></a>如果想将某个类用作基类，为什么该类必须定义而非声明？</h1><p>派生类中包含并且可以使用它从基类继承而来的成员，为了使用这些成员，派生类必须知道他们是什么。</p>
<h1 id="什么情况会自动生成默认构造函数？"><a href="#什么情况会自动生成默认构造函数？" class="headerlink" title="什么情况会自动生成默认构造函数？"></a>什么情况会自动生成默认构造函数？</h1><ul>
<li>带有默认构造函数的类成员对象，如果一个类没有任何构造函数，但它含有一个成员对象，而后者有默认构造函数，那么编译器就为该类合成出一个默认构造函数。<ul>
<li>不过这个合成操作只有在构造函数真正被需要的时候才会发生；</li>
<li>如果一个类A含有多个成员类对象的话，那么类A的每一个构造函数必须调用每一个成员对象的默认构造函数而且必须按照类对象在类A中的声明顺序进行；</li>
</ul>
</li>
<li>带有默认构造函数的基类，如果一个没有任务构造函数的派生类派生自一个带有默认构造函数基类，那么该派生类会合成一个构造函数调用上一层基类的默认构造函数；</li>
<li>带有一个虚函数的类</li>
<li>带有一个虚基类的类</li>
<li>合成的默认构造函数中，只有基类子对象和成员类对象会被初始化。所有其他的非静态数据成员都不会被初始化。</li>
</ul>
<h1 id="函数指针？"><a href="#函数指针？" class="headerlink" title="函数指针？"></a>函数指针？</h1><ul>
<li>什么是函数指针?</li>
</ul>
<p>函数指针指向的是特殊的数据类型，函数的类型是由其返回的数据类型和其参数列表共同决定的，而函数的名称则不是其类型的一部分。</p>
<p>一个具体函数的名字，如果后面不跟调用符号(即括号)，则该名字就是该函数的指针(注意：大部分情况下，可以这么认为，但这种说法并不很严格)。</p>
<ul>
<li>函数指针的声明方法</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> (*pf)(<span class="keyword">const</span> <span class="keyword">int</span>&amp;, <span class="keyword">const</span> <span class="keyword">int</span>&amp;); (<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>上面的pf就是一个函数指针，指向所有返回类型为int，并带有两个<code>const int&amp;</code>参数的函数。注意*pf两边的括号是必须的，否则上面的定义就变成了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">pf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp;, <span class="keyword">const</span> <span class="keyword">int</span>&amp;)</span></span>; (<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>而这声明了一个函数pf，其返回类型为int *， 带有两个<code>const int&amp;</code>参数。</p>
<ul>
<li>为什么有函数指针</li>
</ul>
<p>函数与数据项相似，函数也有地址。我们希望在同一个函数中通过使用相同的形参在不同的时间使用产生不同的效果。</p>
<ul>
<li><p>一个函数名就是一个指针，它指向函数的代码。一个函数地址是该函数的进入点，也就是调用函数的地址。函数的调用可以通过函数名，也可以通过指向函数的指针来调用。函数指针还允许将函数作为变元传递给其他函数；</p>
</li>
<li><p>两种方法赋值：</p>
</li>
</ul>
<p>指针名 = 函数名； 指针名 = &amp;函数名</p>
<h1 id="函数调用过程栈的变化，返回值和参数变量哪个先入栈？"><a href="#函数调用过程栈的变化，返回值和参数变量哪个先入栈？" class="headerlink" title="函数调用过程栈的变化，返回值和参数变量哪个先入栈？"></a>函数调用过程栈的变化，返回值和参数变量哪个先入栈？</h1><ol>
<li>调用者函数把被调函数所需要的参数按照与被调函数的形参顺序相反的顺序压入栈中,即:从右向左依次把被调函数所需要的参数压入栈;</li>
<li>调用者函数使用call指令调用被调函数,并把call指令的下一条指令的地址当成返回地址压入栈中(这个压栈操作隐含在call指令中);</li>
<li>在被调函数中,被调函数会先保存调用者函数的栈底地址(push ebp),然后再保存调用者函数的栈顶地址,即:当前被调函数的栈底地址(mov ebp,esp);</li>
<li>在被调函数中,从ebp的位置处开始存放被调函数中的局部变量和临时变量,并且这些变量的地址按照定义时的顺序依次减小,即:这些变量的地址是按照栈的延伸方向排列的,先定义的变量先入栈,后定义的变量后入栈;</li>
</ol>
<h1 id="你知道printf函数的实现原理是什么吗？"><a href="#你知道printf函数的实现原理是什么吗？" class="headerlink" title="你知道printf函数的实现原理是什么吗？"></a>你知道printf函数的实现原理是什么吗？</h1><p>在C/C++中，对函数参数的扫描是从后向前的。</p>
<p>C/C++的函数参数是通过压入堆栈的方式来给函数传参数的（堆栈是一种先进后出的数据结构），最先压入的参数最后出来，在计算机的内存中，数据有2块，一块是堆，一块是栈（函数参数及局部变量在这里），而栈是从内存的高地址向低地址生长的，控制生长的就是堆栈指针了，最先压入的参数是在最上面，就是说在所有参数的最后面，最后压入的参数在最下面，结构上看起来是第一个，所以最后压入的参数总是能够被函数找到，因为它就在堆栈指针的上方。</p>
<p>printf的第一个被找到的参数就是那个字符指针，就是被双引号括起来的那一部分，函数通过判断字符串里控制参数的个数来判断参数个数及数据类型，通过这些就可算出数据需要的堆栈指针的偏移量了，下面给出printf(“%d,%d”,a,b);（其中a、b都是int型的）的汇编代码.</p>
<h1 id="说一说你了解的关于lambda函数的全部知识"><a href="#说一说你了解的关于lambda函数的全部知识" class="headerlink" title="说一说你了解的关于lambda函数的全部知识"></a>说一说你了解的关于lambda函数的全部知识</h1><p>1) 利用lambda表达式可以编写内嵌的匿名函数，用以替换独立函数或者函数对象；</p>
<p>2) 每当你定义一个lambda表达式后，编译器会自动生成一个匿名类（这个类当然重载了()运算符），我们称为闭包类型（closure type）。那么在运行时，这个lambda表达式就会返回一个匿名的闭包实例，其实一个右值。所以，我们上面的lambda表达式的结果就是一个个闭包。闭包的一个强大之处是其可以通过传值或者引用的方式捕捉其封装作用域内的变量，前面的方括号就是用来定义捕捉模式以及变量，我们又将其称为lambda捕捉块。</p>
<p>3) lambda表达式的语法定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[capture] （parameters） <span class="keyword">mutable</span> -&gt;<span class="keyword">return</span>-type &#123;statement&#125;;</span><br></pre></td></tr></table></figure>
<p>4) lambda必须使用尾置返回来指定返回类型，可以忽略参数列表和返回值，但必须永远包含捕获列表和函数体；</p>
<h1 id="为什么模板类一般都是放在一个h文件中"><a href="#为什么模板类一般都是放在一个h文件中" class="headerlink" title="为什么模板类一般都是放在一个h文件中"></a>为什么模板类一般都是放在一个h文件中</h1><ul>
<li>模板定义很特殊。由template&lt;…&gt;处理的任何东西都意味着编译器在当时不为它分配存储空间，它一直处于等待状态直到被一个模板实例告知。在编译器和连接器的某一处，有一机制能去掉指定模板的多重定义。</li>
</ul>
<p>所以为了容易使用，几乎总是在头文件中放置全部的模板声明和定义。</p>
<ul>
<li>在分离式编译的环境下，编译器编译某一个.cpp文件时并不知道另一个.cpp文件的存在，也不会去查找（当遇到未决符号时它会寄希望于连接器）。这种模式在没有模板的情况下运行良好，但遇到模板时就傻眼了，因为模板仅在需要的时候才会实例化出来。</li>
</ul>
<p>所以，当编译器只看到模板的声明时，它不能实例化该模板，只能创建一个具有外部连接的符号并期待连接器能够将符号的地址决议出来。</p>
<p>然而当实现该模板的.cpp文件中没有用到模板的实例时，编译器懒得去实例化，所以，整个工程的.obj中就找不到一行模板实例的二进制代码，于是连接器也黔驴技穷了。</p>
<h1 id="cout和printf有什么区别？"><a href="#cout和printf有什么区别？" class="headerlink" title="cout和printf有什么区别？"></a>cout和printf有什么区别？</h1><p>cout&lt;&lt;是一个函数，cout&lt;&lt;后可以跟不同的类型是因为cout&lt;&lt;已存在针对各种类型数据的重载，所以会自动识别数据的类型。输出过程会首先将输出字符放入缓冲区，然后输出到屏幕。</p>
<p>cout是有缓冲输出:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt; &lt; <span class="string">"abc "</span> &lt; &lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt; &lt; <span class="string">"abc\n "</span>;<span class="built_in">cout</span> &lt; &lt;flush; 这两个才是一样的.</span><br></pre></td></tr></table></figure>
<p>flush立即强迫缓冲输出。<br>printf是无缓冲输出。有输出时立即输出</p>
<h1 id="当程序中有函数重载时，函数的匹配原则和顺序是什么？"><a href="#当程序中有函数重载时，函数的匹配原则和顺序是什么？" class="headerlink" title="当程序中有函数重载时，函数的匹配原则和顺序是什么？"></a>当程序中有函数重载时，函数的匹配原则和顺序是什么？</h1><ul>
<li><p>名字查找</p>
</li>
<li><p>确定候选函数</p>
</li>
<li><p>寻找最佳匹配</p>
</li>
</ul>
<h1 id="定义和声明的区别"><a href="#定义和声明的区别" class="headerlink" title="定义和声明的区别"></a>定义和声明的区别</h1><p>如果是指变量的声明和定义<br>从编译原理上来说，声明是仅仅告诉编译器，有个某类型的变量会被使用，但是编译器并不会为它分配任何内存。而定义就是分配了内存。</p>
<p>如果是指函数的声明和定义<br>声明：一般在头文件里，对编译器说：这里我有一个函数叫function() 让编译器知道这个函数的存在。<br>定义：一般在源文件里，具体就是函数的实现过程 写明函数体。</p>
<h1 id="说一下你理解的-ifdef-endif代表着什么？"><a href="#说一下你理解的-ifdef-endif代表着什么？" class="headerlink" title="说一下你理解的 ifdef   endif代表着什么？"></a>说一下你理解的 ifdef   endif代表着什么？</h1><ul>
<li><p>一般情况下，源程序中所有的行都参加编译。但是有时希望对其中一部分内容只在满足一定条件才进行编译，也就是对一部分内容指定编译的条件，这就是“条件编译”。有时，希望当满足某条件时对一组语句进行编译，而当条件不满足时则编译另一组语句。</p>
</li>
<li><p>条件编译命令最常见的形式为：</p>
</li>
</ul>
<p>#ifdef 标识符<br> 程序段1<br> #else<br> 程序段2<br> #endif<br>它的作用是：当标识符已经被定义过(一般是用#define命令定义)，则对程序段1进行编译，否则编译程序段2。<br>其中#else部分也可以没有，即：</p>
<p> #ifdef<br> 程序段1<br> #denif</p>
<ul>
<li>在一个大的软件工程里面，可能会有多个文件同时包含一个头文件，当这些文件编译链接成一个可执行文件上时，就会出现大量“重定义”错误。</li>
</ul>
<p>在头文件中使用#define、#ifndef、#ifdef、#endif能避免头文件重定义。</p>
<h1 id="隐式转换，如何消除隐式转换？"><a href="#隐式转换，如何消除隐式转换？" class="headerlink" title="隐式转换，如何消除隐式转换？"></a>隐式转换，如何消除隐式转换？</h1><p>1、C++的基本类型中并非完全的对立，部分数据类型之间是可以进行隐式转换的。所谓隐式转换，是指不需要用户干预，编译器私下进行的类型转换行为。很多时候用户可能都不知道进行了哪些转换</p>
<p>2、C++面向对象的多态特性，就是通过父类的类型实现对子类的封装。通过隐式转换，你可以直接将一个子类的对象使用父类的类型进行返回。在比如，数值和布尔类型的转换，整数和浮点数的转换等。</p>
<p>某些方面来说，隐式转换给C++程序开发者带来了不小的便捷。C++是一门强类型语言，类型的检查是非常严格的。</p>
<p>3、 基本数据类型 基本数据类型的转换以取值范围的作为转换基础（保证精度不丢失）。隐式转换发生在从小-&gt;大的转换中。比如从char转换为int。从int-&gt;long。自定义对象 子类对象可以隐式的转换为父类对象。</p>
<p>4、 C++中提供了explicit关键字，在构造函数声明的时候加上explicit关键字，能够禁止隐式转换。</p>
<p>5、如果构造函数只接受一个参数，则它实际上定义了转换为此类类型的隐式转换机制。可以通过将构造函数声明为explicit加以制止隐式类型转换，关键字explicit只对一个实参的构造函数有效，需要多个实参的构造函数不能用于执行隐式转换，所以无需将这些构造函数指定为explicit。</p>
<h1 id="迭代器：-it、it-哪个好，为什么"><a href="#迭代器：-it、it-哪个好，为什么" class="headerlink" title="迭代器：++it、it++哪个好，为什么"></a>迭代器：++it、it++哪个好，为什么</h1><ul>
<li>前置返回一个引用，后置返回一个对象</li>
</ul>
<p>// ++i实现代码为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>&amp; <span class="keyword">operator</span>++()</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  *<span class="keyword">this</span> += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>前置不会产生临时对象，后置必须产生临时对象，临时对象会导致效率降低</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//i++实现代码为：                 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">operator</span>++(<span class="keyword">int</span>)                 </span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> temp = *<span class="keyword">this</span>;                   </span><br><span class="line"></span><br><span class="line">   ++*<span class="keyword">this</span>;                       </span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> temp;                  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="C-如何处理多个异常的？"><a href="#C-如何处理多个异常的？" class="headerlink" title="C++如何处理多个异常的？"></a>C++如何处理多个异常的？</h1><ul>
<li><p>C++中的异常情况：<br>  语法错误（编译错误）：比如变量未定义、括号不匹配、关键字拼写错误等等编译器在编译时能发现的错误，这类错误可以及时被编译器发现，而且可以及时知道出错的位置及原因，方便改正。<br>  运行时错误：比如数组下标越界、系统内存不足等等。这类错误不易被程序员发现，它能通过编译且能进入运行，但运行时会出错，导致程序崩溃。为了有效处理程序运行时错误，C++中引入异常处理机制来解决此问题。</p>
</li>
<li><p>C++异常处理机制：<br>  异常处理基本思想：执行一个函数的过程中发现异常，可以不用在本函数内立即进行处理， 而是抛出该异常，让函数的调用者直接或间接处理这个问题。<br>  C++异常处理机制由3个模块组成：try(检查)、throw(抛出)、catch(捕获)<br>  抛出异常的语句格式为：throw 表达式；如果try块中程序段发现了异常则抛出异常。</p>
</li>
</ul>
<p>~cpptry  {  可能抛出异常的语句；（检查）  }  catch（类型名[形参名]）//捕获特定类型的异常  {  //处理1；}  catch（类型名[形参名]）//捕获特定类型的异常  {  //处理2；}  catch（…）//捕获所有类型的异常  {  }~</p>
<h1 id="模板和实现可不可以不写在一个文件里面？为什么？"><a href="#模板和实现可不可以不写在一个文件里面？为什么？" class="headerlink" title="模板和实现可不可以不写在一个文件里面？为什么？"></a>模板和实现可不可以不写在一个文件里面？为什么？</h1><p>因为在编译时模板并不能生成真正的二进制代码，而是在编译调用模板类或函数的CPP文件时才会去找对应的模板声明和实现，在这种情况下编译器是不知道实现模板类或函数的CPP文件的存在，所以它只能找到模板类或函数的声明而找不到实现，而只好创建一个符号寄希望于链接程序找地址。</p>
<p>但模板类或函数的实现并不能被编译成二进制代码，结果链接程序找不到地址只好报错了。<br>《C++编程思想》第15章(第300页)说明了原因：模板定义很特殊。由template&lt;…&gt;处理的任何东西都意味着编译器在当时不为它分配存储空间，</p>
<p>它一直处于等待状态直到被一个模板实例告知。在编译器和连接器的某一处，有一机制能去掉指定模板的多重定义。所以为了容易使用，几乎总是在头文件中放置全部的模板声明和定义。</p>
<h1 id="在成员函数中调用delete-this会出现什么问题？对象还可以使用吗？"><a href="#在成员函数中调用delete-this会出现什么问题？对象还可以使用吗？" class="headerlink" title="在成员函数中调用delete this会出现什么问题？对象还可以使用吗？"></a>在成员函数中调用delete this会出现什么问题？对象还可以使用吗？</h1><p>1、在类对象的内存空间中，只有数据成员和虚函数表指针，并不包含代码内容，类的成员函数单独放在代码段中。在调用成员函数时，隐含传递一个this指针，让成员函数知道当前是哪个对象在调用它。当调用delete this时，类对象的内存空间被释放。在delete this之后进行的其他任何函数调用，只要不涉及到this指针的内容，都能够正常运行。一旦涉及到this指针，如操作数据成员，调用虚函数等，就会出现不可预期的问题。</p>
<p>2、为什么是不可预期的问题？</p>
<p>delete this之后不是释放了类对象的内存空间了么，那么这段内存应该已经还给系统，不再属于这个进程。照这个逻辑来看，应该发生指针错误，无访问权限之类的令系统崩溃的问题才对啊？这个问题牵涉到操作系统的内存管理策略。delete this释放了类对象的内存空间，但是内存空间却并不是马上被回收到系统中，可能是缓冲或者其他什么原因，导致这段内存空间暂时并没有被系统收回。</p>
<p>此时这段内存是可以访问的，你可以加上100，加上200，但是其中的值却是不确定的。当你获取数据成员，可能得到的是一串很长的未初始化的随机数；访问虚函数表，指针无效的可能性非常高，造成系统崩溃。</p>
<p>3、 如果在类的析构函数中调用delete this，会发生什么？</p>
<p>会导致堆栈溢出。原因很简单，delete的本质是“为将被释放的内存调用一个或多个析构函数，然后，释放内存”。显然，delete this会去调用本对象的析构函数，而析构函数中又调用delete this，形成无限递归，造成堆栈溢出，系统崩溃。</p>
<h1 id="如何在不使用额外空间的情况下，交换两个数？你有几种方法"><a href="#如何在不使用额外空间的情况下，交换两个数？你有几种方法" class="headerlink" title="如何在不使用额外空间的情况下，交换两个数？你有几种方法"></a>如何在不使用额外空间的情况下，交换两个数？你有几种方法</h1><ul>
<li>算术</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = x + y;</span><br><span class="line"> y = x - y;</span><br><span class="line"></span><br><span class="line">x = x - y;</span><br></pre></td></tr></table></figure>
<ul>
<li>异或</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = x^y;<span class="comment">// 只能对int,char..</span></span><br><span class="line"> y = x^y;</span><br><span class="line"> x = x^y;</span><br><span class="line"> x ^= y ^= x;</span><br></pre></td></tr></table></figure>
<h1 id="你知道strcpy和memcpy的区别是什么吗？"><a href="#你知道strcpy和memcpy的区别是什么吗？" class="headerlink" title="你知道strcpy和memcpy的区别是什么吗？"></a>你知道strcpy和memcpy的区别是什么吗？</h1><ol>
<li>复制的内容不同。strcpy只能复制字符串，而memcpy可以复制任意内容，例如字符数组、整型、结构体、类等。</li>
<li>复制的方法不同。strcpy不需要指定长度，它遇到被复制字符的串结束符”\0”才结束，所以容易溢出。memcpy则是根据其第3个参数决定复制的长度。</li>
<li>用途不同。通常在复制字符串时用strcpy，而需要复制其他类型数据时则一般用memcpy</li>
</ol>
<h1 id="程序在执行int-main-int-argc-char-argv-时的内存结构，你了解吗？"><a href="#程序在执行int-main-int-argc-char-argv-时的内存结构，你了解吗？" class="headerlink" title="程序在执行int main(int argc, char *argv[])时的内存结构，你了解吗？"></a>程序在执行int main(int argc, char *argv[])时的内存结构，你了解吗？</h1><p>参数的含义是程序在命令行下运行的时候，需要输入argc 个参数，每个参数是以char 类型输入的，依次存在数组里面，数组是 argv[]，所有的参数在指针</p>
<p>char * 指向的内存中，数组的中元素的个数为 argc 个，第一个参数为程序的名称。</p>
<h1 id="你知道const-char-与string之间的关系是什么吗？"><a href="#你知道const-char-与string之间的关系是什么吗？" class="headerlink" title="你知道const char* 与string之间的关系是什么吗？"></a>你知道const char* 与string之间的关系是什么吗？</h1><ul>
<li><p>string 是c++标准库里面其中一个，封装了对字符串的操作，实际操作过程我们可以用const char*给string类初始化</p>
</li>
<li><p>三者的转化关系如下所示：</p>
</li>
</ul>
<p>a)  string转const char* </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s = “abc”; </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* c_s = s.c_str();</span><br></pre></td></tr></table></figure>
<p>b)  const char* 转string，直接赋值即可 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* c_s = “abc”; </span><br><span class="line"> <span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(c_s)</span></span>;</span><br></pre></td></tr></table></figure>
<p>c)  string 转char* </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s = “abc”; </span><br><span class="line"><span class="keyword">char</span>* c; </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> len = s.length(); </span><br><span class="line">c = <span class="keyword">new</span> <span class="keyword">char</span>[len+<span class="number">1</span>]; </span><br><span class="line"><span class="built_in">strcpy</span>(c,s.c_str());</span><br></pre></td></tr></table></figure>
<p>d)  char* 转string </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* c = “abc”; </span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(c)</span></span>;</span><br></pre></td></tr></table></figure>
<p>e)  const char<em> 转char</em> </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* cpc = “abc”; </span><br><span class="line"><span class="keyword">char</span>* pc = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(cpc)+<span class="number">1</span>]; </span><br><span class="line"><span class="built_in">strcpy</span>(pc,cpc);</span><br></pre></td></tr></table></figure>
<p>f)  char<em> 转const char</em>，直接赋值即可 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* pc = “abc”; </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* cpc = pc;</span><br></pre></td></tr></table></figure>
<h1 id="为什么拷贝构造函数必须传引用不能传值？"><a href="#为什么拷贝构造函数必须传引用不能传值？" class="headerlink" title="为什么拷贝构造函数必须传引用不能传值？"></a>为什么拷贝构造函数必须传引用不能传值？</h1><ul>
<li>拷贝构造函数的作用就是用来复制对象的，在使用这个对象的实例来初始化这个对象的一个新的实例。</li>
<li>参数传递过程到底发生了什么？<ul>
<li>将地址传递和值传递统一起来，归根结底还是传递的是”值”(地址也是值，只不过通过它可以找到另一个值)！</li>
</ul>
</li>
<li>值传递:<ul>
<li>对于内置数据类型的传递时，直接赋值拷贝给形参(注意形参是函数内局部变量)；</li>
<li>对于类类型的传递时，需要首先调用该类的拷贝构造函数来初始化形参(局部对象)；</li>
</ul>
</li>
</ul>
<p>如void foo(class_type obj_local){}, 如果调用foo(obj); 首先class_type obj_local(obj) ,这样就定义了局部变量obj_local供函数内部使用</p>
<p>ii)引用传递:<br>  无论对内置类型还是类类型，传递引用或指针最终都是传递的地址值！而地址总是指针类型(属于简单类型), 显然参数传递时，按简单类型的赋值拷贝，而不会有拷贝构造函数的调用(对于类类型).<br>上述1) 2)回答了为什么拷贝构造函数使用值传递会产生无限递归调用，内存溢出。</p>
<p>拷贝构造函数用来初始化一个非引用类类型对象，如果用传值的方式进行传参数，那么构造实参需要调用拷贝构造函数，而拷贝构造函数需要传递实参，所以会一直递归。</p>
<h1 id="你知道空类的大小是多少吗？"><a href="#你知道空类的大小是多少吗？" class="headerlink" title="你知道空类的大小是多少吗？"></a>你知道空类的大小是多少吗？</h1><ul>
<li>C++空类的大小不为0，不同编译器设置不一样，vs设置为1；</li>
<li>C++标准指出，不允许一个对象（当然包括类对象）的大小为0，不同的对象不能具有相同的地址；</li>
<li>带有虚函数的C++类大小不为1，因为每一个对象会有一个vptr指向虚函数表，具体大小根据指针大小确定；</li>
<li>C++中要求对于类的每个实例都必须有独一无二的地址,那么编译器自动为空类分配一个字节大小，这样便保证了每个实例均有独一无二的内存地址。</li>
</ul>
<h1 id="this指针调用成员变量时，堆栈会发生什么变化？"><a href="#this指针调用成员变量时，堆栈会发生什么变化？" class="headerlink" title="this指针调用成员变量时，堆栈会发生什么变化？"></a>this指针调用成员变量时，堆栈会发生什么变化？</h1><p>当在类的非静态成员函数访问类的非静态成员时，编译器会自动将对象的地址传给作为隐含参数传递给函数，这个隐含参数就是this指针。</p>
<p>即使你并没有写this指针，编译器在链接时也会加上this的，对各成员的访问都是通过this的。</p>
<p>例如你建立了类的多个对象时，在调用类的成员函数时，你并不知道具体是哪个对象在调用，此时你可以通过查看this指针来查看具体是哪个对象在调用。This指针首先入栈，然后成员函数的参数从右向左进行入栈，最后函数返回地址入栈。</p>
<h1 id="你知道静态绑定和动态绑定吗？讲讲？"><a href="#你知道静态绑定和动态绑定吗？讲讲？" class="headerlink" title="你知道静态绑定和动态绑定吗？讲讲？"></a>你知道静态绑定和动态绑定吗？讲讲？</h1><ul>
<li><p>对象的静态类型：对象在声明时采用的类型。是在编译期确定的。</p>
</li>
<li><p>对象的动态类型：目前所指对象的类型。是在运行期决定的。对象的动态类型可以更改，但是静态类型无法更改。</p>
</li>
<li><p>静态绑定：绑定的是对象的静态类型，某特性（比如函数依赖于对象的静态类型，发生在编译期。</p>
</li>
<li><p>动态绑定：绑定的是对象的动态类型，某特性（比如函数依赖于对象的动态类型，发生在运行期。</p>
</li>
</ul>
<h1 id="如何设计一个类计算子类的个数？"><a href="#如何设计一个类计算子类的个数？" class="headerlink" title="如何设计一个类计算子类的个数？"></a>如何设计一个类计算子类的个数？</h1><ul>
<li>为类设计一个static静态变量count作为计数器；</li>
<li>类定义结束后初始化count;</li>
<li>在构造函数中对count进行+1;</li>
<li>设计拷贝构造函数，在进行拷贝构造函数中进行count +1，操作；</li>
<li>设计复制构造函数，在进行复制函数中对count+1操作；</li>
<li>在析构函数中对count进行-1；</li>
</ul>
<h1 id="怎么快速定位错误出现的地方"><a href="#怎么快速定位错误出现的地方" class="headerlink" title="怎么快速定位错误出现的地方"></a>怎么快速定位错误出现的地方</h1><p>1、如果是简单的错误，可以直接双击错误列表里的错误项或者生成输出的错误信息中带行号的地方就可以让编辑窗口定位到错误的位置上。</p>
<p>2、对于复杂的模板错误，最好使用生成输出窗口。</p>
<p>多数情况下出发错误的位置是最靠后的引用位置。如果这样确定不了错误，就需要先把自己写的代码里的引用位置找出来，然后逐个分析了。</p>
<h1 id="类对象的大小受哪些因素影响？"><a href="#类对象的大小受哪些因素影响？" class="headerlink" title="类对象的大小受哪些因素影响？"></a>类对象的大小受哪些因素影响？</h1><ul>
<li>类的非静态成员变量大小，静态成员不占据类的空间，成员函数也不占据类的空间大小；</li>
<li>内存对齐另外分配的空间大小，类内的数据也是需要进行内存对齐操作的；</li>
<li>虚函数的话，会在类对象插入vptr指针，加上指针大小；</li>
<li>当该该类是某类的派生类，那么派生类继承的基类部分的数据成员也会存在在派生类中的空间中，也会对派生类进行扩展。</li>
</ul>
<h1 id="移动构造函数听说过吗？说说"><a href="#移动构造函数听说过吗？说说" class="headerlink" title="移动构造函数听说过吗？说说"></a>移动构造函数听说过吗？说说</h1><ul>
<li>有时候我们会遇到这样一种情况，我们用对象a初始化对象b后对象a我们就不在使用了，但是对象a的空间还在呀（在析构之前），既然拷贝构造函数，实际上就是把a对象的内容复制一份到b中，那么为什么我们不能直接使用a的空间呢？这样就避免了新的空间的分配，大大降低了构造的成本。这就是移动构造函数设计的初衷；</li>
<li>拷贝构造函数中，对于指针，我们一定要采用深层复制，而移动构造函数中，对于指针，我们采用浅层复制；</li>
<li>C++引入了移动构造函数，专门处理这种，用a初始化b后，就将a析构的情况；</li>
<li>与拷贝类似，移动也使用一个对象的值设置另一个对象的值。但是，又与拷贝不同的是，移动实现的是对象值真实的转移（源对象到目的对象）：源对象将丢失其内容，其内容将被目的对象占有。移动操作的发生的时候，是当移动值的对象是未命名的对象的时候。</li>
</ul>
<p>这里未命名的对象就是那些临时变量，甚至都不会有名称。典型的未命名对象就是函数的返回值或者类型转换的对象。使用临时对象的值初始化另一个对象值，不会要求对对象的复制：因为临时对象不会有其它使用，因而，它的值可以被移动到目的对象。做到这些，就要使用移动构造函数和移动赋值：当使用一个临时变量对象进行构造初始化的时候，调用移动构造函数。类似的，使用未命名的变量的值赋给一个对象时，调用移动赋值操作；</p>
<p>5)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Example6 (Example6&amp;&amp; x) : ptr(x.ptr) </span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">    x.ptr = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// move assignment</span></span><br><span class="line"></span><br><span class="line">  Example6&amp; <span class="keyword">operator</span>= (Example6&amp;&amp; x) </span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">delete</span> ptr; </span><br><span class="line"></span><br><span class="line">   ptr = x.ptr;</span><br><span class="line"></span><br><span class="line">   x.ptr=<span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="什么时候合成构造函数？都说一说，你知道的都说一下"><a href="#什么时候合成构造函数？都说一说，你知道的都说一下" class="headerlink" title="什么时候合成构造函数？都说一说，你知道的都说一下"></a>什么时候合成构造函数？都说一说，你知道的都说一下</h1><ul>
<li>如果一个类没有任何构造函数，但他含有一个成员对象，该成员对象含有默认构造函数，那么编译器就为该类合成一个默认构造函数，因为不合成一个默认构造函数那么该成员对象的构造函数不能调用；</li>
<li>没有任何构造函数的类派生自一个带有默认构造函数的基类，那么需要为该派生类合成一个构造函数，只有这样基类的构造函数才能被调用；</li>
<li>带有虚函数的类，虚函数的引入需要进入虚表，指向虚表的指针，该指针是在构造函数中初始化的，所以没有构造函数的话该指针无法被初始化；</li>
<li>带有一个虚基类的类</li>
</ul>
<p>还有一点需要注意的是：</p>
<ul>
<li>并不是任何没有构造函数的类都会合成一个构造函数</li>
<li>编译器合成出来的构造函数并不会显示设定类内的每一个成员变量</li>
</ul>
<h1 id="那什么时候需要合成拷贝构造函数呢？"><a href="#那什么时候需要合成拷贝构造函数呢？" class="headerlink" title="那什么时候需要合成拷贝构造函数呢？"></a>那什么时候需要合成拷贝构造函数呢？</h1><p>有三种情况会以一个对象的内容作为另一个对象的初值：</p>
<ul>
<li>对一个对象做显示的初始化操作，X xx = x;</li>
<li>当对象被当做参数交给某个函数时；</li>
<li><p>当函数传回一个类对象时；</p>
</li>
<li><p>如果一个类没有拷贝构造函数，但是含有一个类类型的成员变量，该类型含有拷贝构造函数，此时编译器会为该类合成一个拷贝构造函数；</p>
</li>
<li>如果一个类没有拷贝构造函数，但是该类继承自含有拷贝构造函数的基类，此时编译器会为该类合成一个拷贝构造函数；</li>
<li>如果一个类没有拷贝构造函数，但是该类声明或继承了虚函数，此时编译器会为该类合成一个拷贝构造函数；</li>
<li>如果一个类没有拷贝构造函数，但是该类含有虚基类，此时编译器会为该类合成一个拷贝构造函数；</li>
</ul>
<h1 id="说一说strcpy、sprintf与memcpy这三个函数的不同之处"><a href="#说一说strcpy、sprintf与memcpy这三个函数的不同之处" class="headerlink" title="说一说strcpy、sprintf与memcpy这三个函数的不同之处"></a>说一说strcpy、sprintf与memcpy这三个函数的不同之处</h1><ul>
<li>操作对象不同<ul>
<li>strcpy的两个操作对象均为字符串</li>
<li>sprintf的操作源对象可以是多种数据类型，目的操作对象是字符串</li>
<li>memcpy的两个对象就是两个任意可操作的内存地址，并不限于何种数据类型。</li>
</ul>
</li>
<li>执行效率不同<ul>
<li>memcpy最高，strcpy次之，sprintf的效率最低。</li>
</ul>
</li>
<li>实现功能不同<ul>
<li>strcpy主要实现字符串变量间的拷贝</li>
<li>sprintf主要实现其他数据类型格式到字符串的转化</li>
<li>memcpy主要是内存块间的拷贝。</li>
</ul>
</li>
</ul>
<h1 id="将引用作为函数参数有哪些好处？"><a href="#将引用作为函数参数有哪些好处？" class="headerlink" title="将引用作为函数参数有哪些好处？"></a>将引用作为函数参数有哪些好处？</h1><ul>
<li>传递引用给函数与传递指针的效果是一样的。</li>
</ul>
<p>这时，被调函数的形参就成为原来主调函数中的实参变量或对象的一个别名来使用，所以在被调函数中对形参变量的操作就是对其相应的目标对象（在主调函数中）的操作。</p>
<ul>
<li>使用引用传递函数的参数，在内存中并没有产生实参的副本，它是直接对实参操作；</li>
</ul>
<p>而使用一般变量传递函数的参数，当发生函数调用时，需要给形参分配存储单元，形参变量是实参变量的副本；</p>
<p>如果传递的是对象，还将调用拷贝构造函数。</p>
<p>因此，当参数传递的数据较大时，用引用比用一般变量传递参数的效率和所占空间都好。</p>
<ul>
<li>使用指针作为函数的参数虽然也能达到与使用引用的效果，但是，在被调函数中同样要给形参分配存储单元，且需要重复使用”*指针变量名”的形式进行运算，这很容易产生错误且程序的阅读性较差；</li>
</ul>
<p>另一方面，在主调函数的调用点处，必须用变量的地址作为实参。而引用更容易使用，更清晰。</p>
<h1 id="如何阻止一个类被实例化？有哪些方法？"><a href="#如何阻止一个类被实例化？有哪些方法？" class="headerlink" title="如何阻止一个类被实例化？有哪些方法？"></a>如何阻止一个类被实例化？有哪些方法？</h1><ul>
<li>将类定义为抽象基类或者将构造函数声明为private；</li>
<li>不允许类外部创建类对象，只能在类内部创建对象</li>
</ul>
<h1 id="strcpy函数和strncpy函数的区别？哪个函数更安全？"><a href="#strcpy函数和strncpy函数的区别？哪个函数更安全？" class="headerlink" title="strcpy函数和strncpy函数的区别？哪个函数更安全？"></a>strcpy函数和strncpy函数的区别？哪个函数更安全？</h1><ul>
<li>函数原型</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">strcpy</span><span class="params">(<span class="keyword">char</span>* strDest, <span class="keyword">const</span> <span class="keyword">char</span>* strSrc)</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">strncpy</span><span class="params">(<span class="keyword">char</span>* strDest, <span class="keyword">const</span> <span class="keyword">char</span>* strSrc, <span class="keyword">int</span> pos)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>strcpy函数: 如果参数 dest 所指的内存空间不够大，可能会造成缓冲溢出(buffer Overflow)的错误情况，在编写程序时请特别留意，或者用strncpy()来取代。<br>  strncpy函数：用来复制源字符串的前n个字符，src 和 dest 所指的内存区域不能重叠，且 dest 必须有足够的空间放置n个字符。</p>
</li>
<li><p>如果目标长&gt;指定长&gt;源长，则将源长全部拷贝到目标长，自动加上’\0’<br>  如果指定长&lt;源长，则将源长中按指定长度拷贝到目标字符串，不包括’\0’  如果指定长&gt;目标长，运行时错误 ；</p>
</li>
</ul>
<h1 id="你知道回调函数吗？它的作用？"><a href="#你知道回调函数吗？它的作用？" class="headerlink" title="你知道回调函数吗？它的作用？"></a>你知道回调函数吗？它的作用？</h1><ul>
<li>当发生某种事件时，系统或其他函数将会自动调用你定义的一段函数；</li>
<li>回调函数就相当于一个中断处理函数，由系统在符合你设定的条件时自动调用。为此，你需要做三件事：1，声明；2，定义；3，设置触发条件，就是在你的函数中把你的回调函数名称转化为地址作为一个参数，以便于系统调用；</li>
<li>回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用为调用它所指向的函数时，我们就说这是回调函数；</li>
<li>因为可以把调用者与被调用者分开。调用者不关心谁是被调用者，所有它需知道的，只是存在一个具有某种特定原型、某些限制条件（如返回值为int）的被调用函数。</li>
</ul>
<h1 id="动态编译与静态编译"><a href="#动态编译与静态编译" class="headerlink" title="动态编译与静态编译"></a>动态编译与静态编译</h1><ul>
<li><p>静态编译，编译器在编译可执行文件时，把需要用到的对应动态链接库中的部分提取出来，连接到可执行文件中去，使可执行文件在运行时不需要依赖于动态链接库；</p>
</li>
<li><p>动态编译的可执行文件需要附带一个动态链接库，在执行时，需要调用其对应动态链接库的命令。所以其优点一方面是缩小了执行文件本身的体积，另一方面是加快了编译速度，节省了系统资源。</p>
</li>
</ul>
<p>缺点是哪怕是很简单的程序，只用到了链接库的一两条命令，也需要附带一个相对庞大的链接库；二是如果其他计算机上没有安装对应的运行库，则用动态编译的可执行文件就不能运行。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/C/" rel="tag"># C++</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/01/15/STL源码剖析 笔记5/" rel="next" title="STL 源码剖析 笔记5">
                <i class="fa fa-chevron-left"></i> STL 源码剖析 笔记5
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/03/17/计算机体系结构_量化研究方法 笔记1/" rel="prev" title="计算机体系结构 量化研究方法 笔记1">
                计算机体系结构 量化研究方法 笔记1 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/header.jpg" alt="Hao Yu">
            
              <p class="site-author-name" itemprop="name">Hao Yu</p>
              <p class="site-description motion-element" itemprop="description">Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author</p>
          </div>
          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">247</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>
        	<audio controls="controls" loop="loop" preload="auto" src="/resource/xiaomeihao.mp3">
	        </audio>
	

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yuhao0102" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:yuh18@mails.tsinghua.edu.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#在main执行之前和之后执行的代码可能是什么？"><span class="nav-number">1.</span> <span class="nav-text">在main执行之前和之后执行的代码可能是什么？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#结构体内存对齐问题？"><span class="nav-number">2.</span> <span class="nav-text">结构体内存对齐问题？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#指针和引用的区别"><span class="nav-number">3.</span> <span class="nav-text">指针和引用的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#堆和栈的区别"><span class="nav-number">4.</span> <span class="nav-text">堆和栈的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#区别以下指针类型？"><span class="nav-number">5.</span> <span class="nav-text">区别以下指针类型？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#宏定义和typedef区别？"><span class="nav-number">6.</span> <span class="nav-text">宏定义和typedef区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#变量声明和定义区别？"><span class="nav-number">7.</span> <span class="nav-text">变量声明和定义区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#哪几种情况必须用到初始化成员列表？"><span class="nav-number">8.</span> <span class="nav-text">哪几种情况必须用到初始化成员列表？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#a和-amp-a有什么区别？"><span class="nav-number">9.</span> <span class="nav-text">a和&amp;a有什么区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#迭代器失效的情况"><span class="nav-number">10.</span> <span class="nav-text">迭代器失效的情况</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C和C-的区别"><span class="nav-number">11.</span> <span class="nav-text">C和C++的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C-中struct和class的区别"><span class="nav-number">12.</span> <span class="nav-text">C++中struct和class的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#define宏定义和const的区别"><span class="nav-number">13.</span> <span class="nav-text">define宏定义和const的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#final和override关键字"><span class="nav-number">14.</span> <span class="nav-text">final和override关键字</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#拷贝初始化和直接初始化"><span class="nav-number">15.</span> <span class="nav-text">拷贝初始化和直接初始化</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#初始化和赋值的区别"><span class="nav-number">16.</span> <span class="nav-text">初始化和赋值的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#模板函数和模板类的特例化"><span class="nav-number">17.</span> <span class="nav-text">模板函数和模板类的特例化</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C和C-的类型安全"><span class="nav-number">18.</span> <span class="nav-text">C和C++的类型安全</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C-有哪几种的构造函数"><span class="nav-number">19.</span> <span class="nav-text">C++有哪几种的构造函数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#浅拷贝和深拷贝的区别"><span class="nav-number">20.</span> <span class="nav-text">浅拷贝和深拷贝的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#auto-decltype和decltype-auto-的用法"><span class="nav-number">21.</span> <span class="nav-text">auto decltype和decltype(auto)的用法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C-中NULL和nullptr区别"><span class="nav-number">22.</span> <span class="nav-text">C++中NULL和nullptr区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#简要说明C-的内存分区"><span class="nav-number">23.</span> <span class="nav-text">简要说明C++的内存分区</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C-的异常处理的方法"><span class="nav-number">24.</span> <span class="nav-text">C++的异常处理的方法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#静态变量什么时候初始化"><span class="nav-number">25.</span> <span class="nav-text">静态变量什么时候初始化</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#值传递、指针传递、引用传递的区别和效率"><span class="nav-number">26.</span> <span class="nav-text">值传递、指针传递、引用传递的区别和效率</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#什么是内存池，如何实现"><span class="nav-number">27.</span> <span class="nav-text">什么是内存池，如何实现</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#从汇编层去解释一下引用"><span class="nav-number">28.</span> <span class="nav-text">从汇编层去解释一下引用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C-模板是什么，你知道底层怎么实现的？"><span class="nav-number">29.</span> <span class="nav-text">C++模板是什么，你知道底层怎么实现的？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#什么是内存泄露，如何检测与避免"><span class="nav-number">30.</span> <span class="nav-text">什么是内存泄露，如何检测与避免</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#内存泄露"><span class="nav-number">30.1.</span> <span class="nav-text">内存泄露</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#避免内存泄露的几种方式"><span class="nav-number">30.2.</span> <span class="nav-text">避免内存泄露的几种方式</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#对象复用的了解，零拷贝的了解"><span class="nav-number">31.</span> <span class="nav-text">对象复用的了解，零拷贝的了解</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#对象复用"><span class="nav-number">31.1.</span> <span class="nav-text">对象复用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#零拷贝"><span class="nav-number">31.2.</span> <span class="nav-text">零拷贝</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#解释一下什么是trivial-destructor"><span class="nav-number">32.</span> <span class="nav-text">解释一下什么是trivial destructor</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C-中类的数据成员和成员函数内存分布情况"><span class="nav-number">33.</span> <span class="nav-text">C++中类的数据成员和成员函数内存分布情况</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#析构函数的作用，如何起作用？"><span class="nav-number">34.</span> <span class="nav-text">析构函数的作用，如何起作用？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#构造函数析构函数可否抛出异常"><span class="nav-number">35.</span> <span class="nav-text">构造函数析构函数可否抛出异常</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#类什么时候会析构？"><span class="nav-number">36.</span> <span class="nav-text">类什么时候会析构？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#构造函数的几种关键字"><span class="nav-number">37.</span> <span class="nav-text">构造函数的几种关键字</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C-函数调用的压栈过程"><span class="nav-number">38.</span> <span class="nav-text">C++函数调用的压栈过程</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#说说移动构造函数"><span class="nav-number">39.</span> <span class="nav-text">说说移动构造函数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C-中将临时变量作为返回值时的处理过程"><span class="nav-number">40.</span> <span class="nav-text">C++中将临时变量作为返回值时的处理过程</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#关于this指针你知道什么？全说出来"><span class="nav-number">41.</span> <span class="nav-text">关于this指针你知道什么？全说出来</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#this指针的用处"><span class="nav-number">41.1.</span> <span class="nav-text">this指针的用处</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#this指针的使用"><span class="nav-number">41.2.</span> <span class="nav-text">this指针的使用</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#几个this指针的易混问题"><span class="nav-number">42.</span> <span class="nav-text">几个this指针的易混问题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#this指针是什么时候创建的？"><span class="nav-number">42.1.</span> <span class="nav-text">this指针是什么时候创建的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#this指针存放在何处？堆、栈、全局变量，还是其他？"><span class="nav-number">42.2.</span> <span class="nav-text">this指针存放在何处？堆、栈、全局变量，还是其他？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#this指针是如何传递类中的函数的？绑定？还是在函数参数的首参数就是this指针？那么，this指针又是如何找到“类实例后函数的”？"><span class="nav-number">42.3.</span> <span class="nav-text">this指针是如何传递类中的函数的？绑定？还是在函数参数的首参数就是this指针？那么，this指针又是如何找到“类实例后函数的”？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#this指针是如何访问类中的变量的？"><span class="nav-number">42.4.</span> <span class="nav-text">this指针是如何访问类中的变量的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#我们只有获得一个对象后，才能通过对象使用this指针。如果我们知道一个对象this指针的位置，可以直接使用吗？"><span class="nav-number">42.5.</span> <span class="nav-text">我们只有获得一个对象后，才能通过对象使用this指针。如果我们知道一个对象this指针的位置，可以直接使用吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#每个类编译后，是否创建一个类中函数表保存函数指针，以便用来调用函数？"><span class="nav-number">42.6.</span> <span class="nav-text">每个类编译后，是否创建一个类中函数表保存函数指针，以便用来调用函数？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#构造函数、拷贝构造函数和赋值操作符的区别"><span class="nav-number">43.</span> <span class="nav-text">构造函数、拷贝构造函数和赋值操作符的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#静态类型和动态类型以及静态绑定和动态绑定的总结"><span class="nav-number">44.</span> <span class="nav-text">静态类型和动态类型以及静态绑定和动态绑定的总结</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#引用是否能实现动态绑定，为什么可以实现？"><span class="nav-number">45.</span> <span class="nav-text">引用是否能实现动态绑定，为什么可以实现？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#全局变量和局部变量有什么区别？"><span class="nav-number">46.</span> <span class="nav-text">全局变量和局部变量有什么区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#指针加减计算要注意什么？"><span class="nav-number">47.</span> <span class="nav-text">指针加减计算要注意什么？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#怎样判断两个浮点数是否相等？"><span class="nav-number">48.</span> <span class="nav-text">怎样判断两个浮点数是否相等？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#方法调用的原理（栈、汇编）"><span class="nav-number">49.</span> <span class="nav-text">方法调用的原理（栈、汇编）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C-中的指针参数传递和引用参数传递有什么区别？底层原理你知道吗？"><span class="nav-number">50.</span> <span class="nav-text">C++中的指针参数传递和引用参数传递有什么区别？底层原理你知道吗？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#类如何实现只能静态分配和只能动态分配"><span class="nav-number">51.</span> <span class="nav-text">类如何实现只能静态分配和只能动态分配</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#如果想将某个类用作基类，为什么该类必须定义而非声明？"><span class="nav-number">52.</span> <span class="nav-text">如果想将某个类用作基类，为什么该类必须定义而非声明？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#什么情况会自动生成默认构造函数？"><span class="nav-number">53.</span> <span class="nav-text">什么情况会自动生成默认构造函数？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#函数指针？"><span class="nav-number">54.</span> <span class="nav-text">函数指针？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#函数调用过程栈的变化，返回值和参数变量哪个先入栈？"><span class="nav-number">55.</span> <span class="nav-text">函数调用过程栈的变化，返回值和参数变量哪个先入栈？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#你知道printf函数的实现原理是什么吗？"><span class="nav-number">56.</span> <span class="nav-text">你知道printf函数的实现原理是什么吗？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#说一说你了解的关于lambda函数的全部知识"><span class="nav-number">57.</span> <span class="nav-text">说一说你了解的关于lambda函数的全部知识</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#为什么模板类一般都是放在一个h文件中"><span class="nav-number">58.</span> <span class="nav-text">为什么模板类一般都是放在一个h文件中</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#cout和printf有什么区别？"><span class="nav-number">59.</span> <span class="nav-text">cout和printf有什么区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#当程序中有函数重载时，函数的匹配原则和顺序是什么？"><span class="nav-number">60.</span> <span class="nav-text">当程序中有函数重载时，函数的匹配原则和顺序是什么？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#定义和声明的区别"><span class="nav-number">61.</span> <span class="nav-text">定义和声明的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#说一下你理解的-ifdef-endif代表着什么？"><span class="nav-number">62.</span> <span class="nav-text">说一下你理解的 ifdef   endif代表着什么？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#隐式转换，如何消除隐式转换？"><span class="nav-number">63.</span> <span class="nav-text">隐式转换，如何消除隐式转换？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#迭代器：-it、it-哪个好，为什么"><span class="nav-number">64.</span> <span class="nav-text">迭代器：++it、it++哪个好，为什么</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C-如何处理多个异常的？"><span class="nav-number">65.</span> <span class="nav-text">C++如何处理多个异常的？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#模板和实现可不可以不写在一个文件里面？为什么？"><span class="nav-number">66.</span> <span class="nav-text">模板和实现可不可以不写在一个文件里面？为什么？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#在成员函数中调用delete-this会出现什么问题？对象还可以使用吗？"><span class="nav-number">67.</span> <span class="nav-text">在成员函数中调用delete this会出现什么问题？对象还可以使用吗？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#如何在不使用额外空间的情况下，交换两个数？你有几种方法"><span class="nav-number">68.</span> <span class="nav-text">如何在不使用额外空间的情况下，交换两个数？你有几种方法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#你知道strcpy和memcpy的区别是什么吗？"><span class="nav-number">69.</span> <span class="nav-text">你知道strcpy和memcpy的区别是什么吗？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#程序在执行int-main-int-argc-char-argv-时的内存结构，你了解吗？"><span class="nav-number">70.</span> <span class="nav-text">程序在执行int main(int argc, char *argv[])时的内存结构，你了解吗？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#你知道const-char-与string之间的关系是什么吗？"><span class="nav-number">71.</span> <span class="nav-text">你知道const char* 与string之间的关系是什么吗？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#为什么拷贝构造函数必须传引用不能传值？"><span class="nav-number">72.</span> <span class="nav-text">为什么拷贝构造函数必须传引用不能传值？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#你知道空类的大小是多少吗？"><span class="nav-number">73.</span> <span class="nav-text">你知道空类的大小是多少吗？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#this指针调用成员变量时，堆栈会发生什么变化？"><span class="nav-number">74.</span> <span class="nav-text">this指针调用成员变量时，堆栈会发生什么变化？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#你知道静态绑定和动态绑定吗？讲讲？"><span class="nav-number">75.</span> <span class="nav-text">你知道静态绑定和动态绑定吗？讲讲？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#如何设计一个类计算子类的个数？"><span class="nav-number">76.</span> <span class="nav-text">如何设计一个类计算子类的个数？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#怎么快速定位错误出现的地方"><span class="nav-number">77.</span> <span class="nav-text">怎么快速定位错误出现的地方</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#类对象的大小受哪些因素影响？"><span class="nav-number">78.</span> <span class="nav-text">类对象的大小受哪些因素影响？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#移动构造函数听说过吗？说说"><span class="nav-number">79.</span> <span class="nav-text">移动构造函数听说过吗？说说</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#什么时候合成构造函数？都说一说，你知道的都说一下"><span class="nav-number">80.</span> <span class="nav-text">什么时候合成构造函数？都说一说，你知道的都说一下</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#那什么时候需要合成拷贝构造函数呢？"><span class="nav-number">81.</span> <span class="nav-text">那什么时候需要合成拷贝构造函数呢？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#说一说strcpy、sprintf与memcpy这三个函数的不同之处"><span class="nav-number">82.</span> <span class="nav-text">说一说strcpy、sprintf与memcpy这三个函数的不同之处</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#将引用作为函数参数有哪些好处？"><span class="nav-number">83.</span> <span class="nav-text">将引用作为函数参数有哪些好处？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#如何阻止一个类被实例化？有哪些方法？"><span class="nav-number">84.</span> <span class="nav-text">如何阻止一个类被实例化？有哪些方法？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#strcpy函数和strncpy函数的区别？哪个函数更安全？"><span class="nav-number">85.</span> <span class="nav-text">strcpy函数和strncpy函数的区别？哪个函数更安全？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#你知道回调函数吗？它的作用？"><span class="nav-number">86.</span> <span class="nav-text">你知道回调函数吗？它的作用？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#动态编译与静态编译"><span class="nav-number">87.</span> <span class="nav-text">动态编译与静态编译</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>
  <div id="DvelopmentTarget">     
  </div>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart" aria-hidden="false"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>

  
</div>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_uv"> 
  本站访客数<span id="busuanzi_value_site_uv"></span>人次
</span>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  


  

  


  <script type="text/javascript" src="/js/src/love.js"></script>

</body>
</html>
