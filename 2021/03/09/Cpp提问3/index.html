<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zn-ch">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-center-simple.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="C++,">










<meta name="description" content="什么情况会自动生成默认构造函数？ 带有默认构造函数的类成员对象，如果一个类没有任何构造函数，但它含有一个成员对象，而后者有默认构造函数，那么编译器就为该类合成出一个默认构造函数。 不过这个合成操作只有在构造函数真正被需要的时候才会发生； 如果一个类A含有多个成员类对象的话，那么类A的每一个构造函数必须调用每一个成员对象的默认构造函数而且必须按照类对象在类A中的声明顺序进行；   带有默认构造函数的">
<meta name="keywords" content="C++">
<meta property="og:type" content="article">
<meta property="og:title" content="《逆袭进大厂》之C++篇 3">
<meta property="og:url" content="http://yoursite.com/2021/03/09/Cpp提问3/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="什么情况会自动生成默认构造函数？ 带有默认构造函数的类成员对象，如果一个类没有任何构造函数，但它含有一个成员对象，而后者有默认构造函数，那么编译器就为该类合成出一个默认构造函数。 不过这个合成操作只有在构造函数真正被需要的时候才会发生； 如果一个类A含有多个成员类对象的话，那么类A的每一个构造函数必须调用每一个成员对象的默认构造函数而且必须按照类对象在类A中的声明顺序进行；   带有默认构造函数的">
<meta property="og:locale" content="zn-ch">
<meta property="og:updated_time" content="2021-04-21T05:34:43.237Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="《逆袭进大厂》之C++篇 3">
<meta name="twitter:description" content="什么情况会自动生成默认构造函数？ 带有默认构造函数的类成员对象，如果一个类没有任何构造函数，但它含有一个成员对象，而后者有默认构造函数，那么编译器就为该类合成出一个默认构造函数。 不过这个合成操作只有在构造函数真正被需要的时候才会发生； 如果一个类A含有多个成员类对象的话，那么类A的每一个构造函数必须调用每一个成员对象的默认构造函数而且必须按照类对象在类A中的声明顺序进行；   带有默认构造函数的">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2021/03/09/Cpp提问3/">





  <title>《逆袭进大厂》之C++篇 3 | Hao Yu's blog</title>
  








 
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zn-ch">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hao Yu's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">The program monkey was eaten by the siege lion.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-mybetterhalf">
          <a href="/mybetterhalf/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>
            
            mybetterhalf
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="Searching..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/09/Cpp提问3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">《逆袭进大厂》之C++篇 3</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-03-09T16:09:00+08:00">
                2021-03-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="什么情况会自动生成默认构造函数？"><a href="#什么情况会自动生成默认构造函数？" class="headerlink" title="什么情况会自动生成默认构造函数？"></a>什么情况会自动生成默认构造函数？</h1><ul>
<li>带有默认构造函数的类成员对象，如果一个类没有任何构造函数，但它含有一个成员对象，而后者有默认构造函数，那么编译器就为该类合成出一个默认构造函数。<ul>
<li>不过这个合成操作只有在构造函数真正被需要的时候才会发生；</li>
<li>如果一个类A含有多个成员类对象的话，那么类A的每一个构造函数必须调用每一个成员对象的默认构造函数而且必须按照类对象在类A中的声明顺序进行；</li>
</ul>
</li>
<li>带有默认构造函数的基类，如果一个没有任务构造函数的派生类派生自一个带有默认构造函数基类，那么该派生类会合成一个构造函数调用上一层基类的默认构造函数；</li>
<li>带有一个虚函数的类</li>
<li>带有一个虚基类的类</li>
<li>合成的默认构造函数中，只有基类子对象和成员类对象会被初始化。所有其他的非静态数据成员都不会被初始化。</li>
</ul>
<h1 id="函数指针？"><a href="#函数指针？" class="headerlink" title="函数指针？"></a>函数指针？</h1><ul>
<li>什么是函数指针?</li>
</ul>
<p>函数指针指向的是特殊的数据类型，函数的类型是由其返回的数据类型和其参数列表共同决定的，而函数的名称则不是其类型的一部分。</p>
<p>一个具体函数的名字，如果后面不跟调用符号(即括号)，则该名字就是该函数的指针(注意：大部分情况下，可以这么认为，但这种说法并不很严格)。</p>
<ul>
<li>函数指针的声明方法<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> (*pf)(<span class="keyword">const</span> <span class="keyword">int</span>&amp;, <span class="keyword">const</span> <span class="keyword">int</span>&amp;); (<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>上面的pf就是一个函数指针，指向所有返回类型为int，并带有两个<code>const int&amp;</code>参数的函数。注意*pf两边的括号是必须的，否则上面的定义就变成了：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">pf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp;, <span class="keyword">const</span> <span class="keyword">int</span>&amp;)</span></span>; (<span class="number">2</span>)</span><br></pre></td></tr></table></figure></p>
<p>而这声明了一个函数pf，其返回类型为int *， 带有两个<code>const int&amp;</code>参数。</p>
<ul>
<li>为什么有函数指针</li>
</ul>
<p>函数与数据项相似，函数也有地址。我们希望在同一个函数中通过使用相同的形参在不同的时间使用产生不同的效果。</p>
<ul>
<li><p>一个函数名就是一个指针，它指向函数的代码。一个函数地址是该函数的进入点，也就是调用函数的地址。函数的调用可以通过函数名，也可以通过指向函数的指针来调用。函数指针还允许将函数作为变元传递给其他函数；</p>
</li>
<li><p>两种方法赋值：</p>
</li>
</ul>
<p>指针名 = 函数名； 指针名 = &amp;函数名</p>
<h1 id="使用智能指针管理内存资源，RAII是怎么回事？"><a href="#使用智能指针管理内存资源，RAII是怎么回事？" class="headerlink" title="使用智能指针管理内存资源，RAII是怎么回事？"></a>使用智能指针管理内存资源，RAII是怎么回事？</h1><ul>
<li>RAII全称是“Resource Acquisition is Initialization”，直译过来是“资源获取即初始化”，也就是说在构造函数中申请分配资源，在析构函数中释放资源。</li>
</ul>
<p>因为C++的语言机制保证了，当一个对象创建的时候，自动调用构造函数，当对象超出作用域的时候会自动调用析构函数。所以，在RAII的指导下，我们应该使用类来管理资源，将资源和对象的生命周期绑定。</p>
<ul>
<li>智能指针（std::shared_ptr和std::unique_ptr）即RAII最具代表的实现，使用智能指针，可以实现自动的内存管理，再也不需要担心忘记delete造成的内存泄漏。</li>
</ul>
<p>毫不夸张的来讲，有了智能指针，代码中几乎不需要再出现delete了。</p>
<h1 id="手写实现智能指针类"><a href="#手写实现智能指针类" class="headerlink" title="手写实现智能指针类"></a>手写实现智能指针类</h1><ul>
<li>智能指针是一个数据类型，一般用模板实现，模拟指针行为的同时还提供自动垃圾回收机制。它会自动记录SmartPointer对象的引用计数，一旦T类型对象的引用计数为0，就释放该对象。</li>
</ul>
<p>除了指针对象外，我们还需要一个引用计数的指针设定对象的值，并将引用计数计为1，需要一个构造函数。新增对象还需要一个构造函数，析构函数负责引用计数减少和释放内存。</p>
<p>通过覆写赋值运算符，才能将一个旧的智能指针赋值给另一个指针，同时旧的引用计数减1，新的引用计数加1</p>
<ul>
<li>一个构造函数、拷贝构造函数、复制构造函数、析构函数、移走函数；</li>
</ul>
<h1 id="说一说你理解的内存对齐以及原因"><a href="#说一说你理解的内存对齐以及原因" class="headerlink" title="说一说你理解的内存对齐以及原因"></a>说一说你理解的内存对齐以及原因</h1><ul>
<li>分配内存的顺序是按照声明的顺序。</li>
<li>每个变量相对于起始位置的偏移量必须是该变量类型大小的整数倍，不是整数倍空出内存，直到偏移量是整数倍为止。</li>
<li>最后整个结构体的大小必须是里面变量类型最大值的整数倍。</li>
</ul>
<p>添加了#pragma pack(n)后规则就变成了下面这样：</p>
<ul>
<li>偏移量要是n和当前变量大小中较小值的整数倍</li>
<li>整体大小要是n和最大变量大小中较小值的整数倍</li>
<li>n值必须为1,2,4,8…，为其他值时就按照默认的分配规则</li>
</ul>
<h1 id="结构体变量比较是否相等"><a href="#结构体变量比较是否相等" class="headerlink" title="结构体变量比较是否相等"></a>结构体变量比较是否相等</h1><ul>
<li><p>重载了 “==” 操作符</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">foo</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> a;</span><br><span class="line">  <span class="keyword">int</span> b;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> foo&amp; rhs) *<span class="comment">//* *操作运算符重载*</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span>( a == rhs.a) &amp;&amp; (b == rhs.b);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>元素的话，一个个比；</p>
</li>
<li>指针直接比较，如果保存的是同一个实例地址，则(p1==p2)为真；</li>
</ul>
<h1 id="函数调用过程栈的变化，返回值和参数变量哪个先入栈？"><a href="#函数调用过程栈的变化，返回值和参数变量哪个先入栈？" class="headerlink" title="函数调用过程栈的变化，返回值和参数变量哪个先入栈？"></a>函数调用过程栈的变化，返回值和参数变量哪个先入栈？</h1><ol>
<li>调用者函数把被调函数所需要的参数按照与被调函数的形参顺序相反的顺序压入栈中,即:从右向左依次把被调函数所需要的参数压入栈;</li>
<li>调用者函数使用call指令调用被调函数,并把call指令的下一条指令的地址当成返回地址压入栈中(这个压栈操作隐含在call指令中);</li>
<li>在被调函数中,被调函数会先保存调用者函数的栈底地址(push ebp),然后再保存调用者函数的栈顶地址,即:当前被调函数的栈底地址(mov ebp,esp);</li>
<li>在被调函数中,从ebp的位置处开始存放被调函数中的局部变量和临时变量,并且这些变量的地址按照定义时的顺序依次减小,即:这些变量的地址是按照栈的延伸方向排列的,先定义的变量先入栈,后定义的变量后入栈;</li>
</ol>
<h1 id="define、const、typedef、inline的使用方法？他们之间有什么区别？"><a href="#define、const、typedef、inline的使用方法？他们之间有什么区别？" class="headerlink" title="define、const、typedef、inline的使用方法？他们之间有什么区别？"></a>define、const、typedef、inline的使用方法？他们之间有什么区别？</h1><h2 id="const与-define的区别："><a href="#const与-define的区别：" class="headerlink" title="const与#define的区别："></a>const与#define的区别：</h2><ul>
<li>const定义的常量是变量带类型，而#define定义的只是个常数不带类型；</li>
<li>define只在预处理阶段起作用，简单的文本替换，而const在编译、链接过程中起作用；</li>
<li>define只是简单的字符串替换没有类型检查。而const是有数据类型的，是要进行判断的，可以避免一些低级错误；</li>
<li>define预处理后，占用代码段空间，const占用数据段空间；</li>
<li>const不能重定义，而define可以通过#undef取消某个符号的定义，进行重定义；</li>
<li>define独特功能，比如可以用来防止文件重复引用。</li>
</ul>
<p>二、#define和别名typedef的区别</p>
<ul>
<li>执行时间不同，typedef在编译阶段有效，typedef有类型检查的功能；#define是宏定义，发生在预处理阶段，不进行类型检查；</li>
<li>功能差异，typedef用来定义类型的别名，定义与平台无关的数据类型，与struct的结合使用等。#define不只是可以为类型取别名，还可以定义常量、变量、编译开关等。</li>
<li>作用域不同，#define没有作用域的限制，只要是之前预定义过的宏，在以后的程序中都可以使用。而typedef有自己的作用域。</li>
</ul>
<p>三、define与inline的区别</p>
<ul>
<li>#define是关键字，inline是函数；</li>
<li>宏定义在预处理阶段进行文本替换，inline函数在编译阶段进行替换；</li>
<li>inline函数有类型检查，相比宏定义比较安全；</li>
</ul>
<h1 id="你知道printf函数的实现原理是什么吗？"><a href="#你知道printf函数的实现原理是什么吗？" class="headerlink" title="你知道printf函数的实现原理是什么吗？"></a>你知道printf函数的实现原理是什么吗？</h1><p>在C/C++中，对函数参数的扫描是从后向前的。</p>
<p>C/C++的函数参数是通过压入堆栈的方式来给函数传参数的（堆栈是一种先进后出的数据结构），最先压入的参数最后出来，在计算机的内存中，数据有2块，一块是堆，一块是栈（函数参数及局部变量在这里），而栈是从内存的高地址向低地址生长的，控制生长的就是堆栈指针了，最先压入的参数是在最上面，就是说在所有参数的最后面，最后压入的参数在最下面，结构上看起来是第一个，所以最后压入的参数总是能够被函数找到，因为它就在堆栈指针的上方。</p>
<p>printf的第一个被找到的参数就是那个字符指针，就是被双引号括起来的那一部分，函数通过判断字符串里控制参数的个数来判断参数个数及数据类型，通过这些就可算出数据需要的堆栈指针的偏移量了，下面给出printf(“%d,%d”,a,b);（其中a、b都是int型的）的汇编代码.</p>
<h1 id="说一说你了解的关于lambda函数的全部知识"><a href="#说一说你了解的关于lambda函数的全部知识" class="headerlink" title="说一说你了解的关于lambda函数的全部知识"></a>说一说你了解的关于lambda函数的全部知识</h1><p>1) 利用lambda表达式可以编写内嵌的匿名函数，用以替换独立函数或者函数对象；</p>
<p>2) 每当你定义一个lambda表达式后，编译器会自动生成一个匿名类（这个类当然重载了()运算符），我们称为闭包类型（closure type）。那么在运行时，这个lambda表达式就会返回一个匿名的闭包实例，其实一个右值。所以，我们上面的lambda表达式的结果就是一个个闭包。闭包的一个强大之处是其可以通过传值或者引用的方式捕捉其封装作用域内的变量，前面的方括号就是用来定义捕捉模式以及变量，我们又将其称为lambda捕捉块。</p>
<p>3) lambda表达式的语法定义如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[capture] （parameters） <span class="keyword">mutable</span> -&gt;<span class="keyword">return</span>-type &#123;statement&#125;;</span><br></pre></td></tr></table></figure></p>
<p>4) lambda必须使用尾置返回来指定返回类型，可以忽略参数列表和返回值，但必须永远包含捕获列表和函数体；</p>
<h1 id="将字符串“hello-world”从开始到打印到屏幕上的全过程"><a href="#将字符串“hello-world”从开始到打印到屏幕上的全过程" class="headerlink" title="将字符串“hello world”从开始到打印到屏幕上的全过程?"></a>将字符串“hello world”从开始到打印到屏幕上的全过程?</h1><ul>
<li>用户告诉操作系统执行HelloWorld程序（通过键盘输入等）</li>
<li>操作系统：找到helloworld程序的相关信息，检查其类型是否是可执行文件；并通过程序首部信息，确定代码和数据在可执行文件中的位置并计算出对应的磁盘块地址。</li>
<li>操作系统：创建一个新进程，将HelloWorld可执行文件映射到该进程结构，表示由该进程执行helloworld程序。</li>
<li>操作系统：为helloworld程序设置cpu上下文环境，并跳到程序开始处。</li>
<li>执行helloworld程序的第一条指令，发生缺页异常</li>
<li>操作系统：分配一页物理内存，并将代码从磁盘读入内存，然后继续执行helloworld程序</li>
<li>helloword程序执行puts函数（系统调用），在显示器上写一字符串</li>
<li>操作系统：找到要将字符串送往的显示设备，通常设备是由一个进程控制的，所以，操作系统将要写的字符串送给该进程</li>
<li>操作系统：控制设备的进程告诉设备的窗口系统，它要显示该字符串，窗口系统确定这是一个合法的操作，然后将字符串转换成像素，将像素写入设备的存储映像区</li>
<li>视频硬件将像素转换成显示器可接收和一组控制数据信号</li>
<li>显示器解释信号，激发液晶屏</li>
<li>OK，我们在屏幕上看到了HelloWorld</li>
</ul>
<h1 id="模板类和模板函数的区别是什么？"><a href="#模板类和模板函数的区别是什么？" class="headerlink" title="模板类和模板函数的区别是什么？"></a>模板类和模板函数的区别是什么？</h1><p>函数模板的实例化是由编译程序在处理函数调用时自动完成的，而类模板的实例化必须由程序员在程序中显式地指定。即函数模板允许隐式调用和显式调用而类模板只能显示调用。在使用时类模板必须加，而函数模板不必</p>
<h1 id="为什么模板类一般都是放在一个h文件中"><a href="#为什么模板类一般都是放在一个h文件中" class="headerlink" title="为什么模板类一般都是放在一个h文件中"></a>为什么模板类一般都是放在一个h文件中</h1><ul>
<li>模板定义很特殊。由template&lt;…&gt;处理的任何东西都意味着编译器在当时不为它分配存储空间，它一直处于等待状态直到被一个模板实例告知。在编译器和连接器的某一处，有一机制能去掉指定模板的多重定义。</li>
</ul>
<p>所以为了容易使用，几乎总是在头文件中放置全部的模板声明和定义。</p>
<ul>
<li>在分离式编译的环境下，编译器编译某一个.cpp文件时并不知道另一个.cpp文件的存在，也不会去查找（当遇到未决符号时它会寄希望于连接器）。这种模式在没有模板的情况下运行良好，但遇到模板时就傻眼了，因为模板仅在需要的时候才会实例化出来。</li>
</ul>
<p>所以，当编译器只看到模板的声明时，它不能实例化该模板，只能创建一个具有外部连接的符号并期待连接器能够将符号的地址决议出来。</p>
<p>然而当实现该模板的.cpp文件中没有用到模板的实例时，编译器懒得去实例化，所以，整个工程的.obj中就找不到一行模板实例的二进制代码，于是连接器也黔驴技穷了。</p>
<h1 id="C-中类成员的访问权限和继承权限问题"><a href="#C-中类成员的访问权限和继承权限问题" class="headerlink" title="C++中类成员的访问权限和继承权限问题"></a>C++中类成员的访问权限和继承权限问题</h1><p>三种访问权限</p>
<ul>
<li>public:用该关键字修饰的成员表示公有成员，该成员不仅可以在类内可以被  访问，在类外也是可以被访问的，是类对外提供的可访问接口；</li>
<li>private:用该关键字修饰的成员表示私有成员，该成员仅在类内可以被访问，在类体外是隐藏状态；</li>
<li>protected:用该关键字修饰的成员表示保护成员，保护成员在类体外同样是隐藏状态，但是对于该类的派生类来说，相当于公有成员，在派生类中可以被访问。</li>
</ul>
<p>三种继承方式</p>
<ul>
<li>若继承方式是public，基类成员在派生类中的访问权限保持不变，也就是说，基类中的成员访问权限，在派生类中仍然保持原来的访问权限；</li>
<li>若继承方式是private，基类所有成员在派生类中的访问权限都会变为私有(private)权限；</li>
<li>若继承方式是protected，基类的共有成员和保护成员在派生类中的访问权限都会变为保护(protected)权限，私有成员在派生类中的访问权限仍然是私有(private)权限。</li>
</ul>
<h1 id="cout和printf有什么区别？"><a href="#cout和printf有什么区别？" class="headerlink" title="cout和printf有什么区别？"></a>cout和printf有什么区别？</h1><p>cout&lt;&lt;是一个函数，cout&lt;&lt;后可以跟不同的类型是因为cout&lt;&lt;已存在针对各种类型数据的重载，所以会自动识别数据的类型。输出过程会首先将输出字符放入缓冲区，然后输出到屏幕。</p>
<p>cout是有缓冲输出:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt; &lt; <span class="string">"abc "</span> &lt; &lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p>
<p>或<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt; &lt; <span class="string">"abc\n "</span>;<span class="built_in">cout</span> &lt; &lt;flush; 这两个才是一样的.</span><br></pre></td></tr></table></figure></p>
<p>flush立即强迫缓冲输出。<br>printf是无缓冲输出。有输出时立即输出</p>
<h1 id="你知道重载运算符吗？"><a href="#你知道重载运算符吗？" class="headerlink" title="你知道重载运算符吗？"></a>你知道重载运算符吗？</h1><ul>
<li>我们只能重载已有的运算符，而无权发明新的运算符；对于一个重载的运算符，其优先级和结合律与内置类型一致才可以；不能改变运算符操作数个数；</li>
<li>两种重载方式：成员运算符和非成员运算符，成员运算符比非成员运算符少一个参数；下标运算符、箭头运算符必须是成员运算符；</li>
<li>引入运算符重载，是为了实现类的多态性；</li>
<li>当重载的运算符是成员函数时，this绑定到左侧运算符对象。成员运算符函数的参数数量比运算符对象的数量少一个；至少含有一个类类型的参数；</li>
<li>从参数的个数推断到底定义的是哪种运算符，当运算符既是一元运算符又是二元运算符（+，-，*，&amp;）；</li>
<li>下标运算符必须是成员函数，下标运算符通常以所访问元素的引用作为返回值，同时最好定义下标运算符的常量版本和非常量版本；</li>
<li>箭头运算符必须是类的成员，解引用通常也是类的成员；重载的箭头运算符必须返回类的指针；</li>
</ul>
<h1 id="当程序中有函数重载时，函数的匹配原则和顺序是什么？"><a href="#当程序中有函数重载时，函数的匹配原则和顺序是什么？" class="headerlink" title="当程序中有函数重载时，函数的匹配原则和顺序是什么？"></a>当程序中有函数重载时，函数的匹配原则和顺序是什么？</h1><ul>
<li><p>名字查找</p>
</li>
<li><p>确定候选函数</p>
</li>
<li><p>寻找最佳匹配</p>
</li>
</ul>
<h1 id="定义和声明的区别"><a href="#定义和声明的区别" class="headerlink" title="定义和声明的区别"></a>定义和声明的区别</h1><p>如果是指变量的声明和定义<br>从编译原理上来说，声明是仅仅告诉编译器，有个某类型的变量会被使用，但是编译器并不会为它分配任何内存。而定义就是分配了内存。</p>
<p>如果是指函数的声明和定义<br>声明：一般在头文件里，对编译器说：这里我有一个函数叫function() 让编译器知道这个函数的存在。<br>定义：一般在源文件里，具体就是函数的实现过程 写明函数体。</p>
<h1 id="全局变量和static变量的区别"><a href="#全局变量和static变量的区别" class="headerlink" title="全局变量和static变量的区别"></a>全局变量和static变量的区别</h1><p>1、全局变量（外部变量）的说明之前再冠以static就构成了静态的全局变量。</p>
<p>全局变量本身就是静态存储方式，静态全局变量当然也是静态存储方式。</p>
<p>这两者在存储方式上并无不同。这两者的区别在于非静态全局变量的作用域是整个源程序，当一个源程序由多个原文件组成时，非静态的全局变量在各个源文件中都是有效的。</p>
<p>而静态全局变量则限制了其作用域，即只在定义该变量的源文件内有效，在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其他源文件中引起错误。</p>
<p>static全局变量与普通的全局变量的区别是static全局变量只初始化一次，防止在其他文件单元被引用。</p>
<p>2.static函数与普通函数有什么区别？<br>static函数与普通的函数作用域不同。尽在本文件中。只在当前源文件中使用的函数应该说明为内部函数（static），内部函数应该在当前源文件中说明和定义。</p>
<p>对于可在当前源文件以外使用的函数应该在一个头文件中说明，要使用这些函数的源文件要包含这个头文件。<br>static函数与普通函数最主要区别是static函数在内存中只有一份，普通静态函数在每个被调用中维持一份拷贝程序的局部变量存在于（堆栈）中，全局变量存在于（静态区）中，动态申请数据存在于（堆）</p>
<h1 id="静态成员与普通成员的区别是什么？"><a href="#静态成员与普通成员的区别是什么？" class="headerlink" title="静态成员与普通成员的区别是什么？"></a>静态成员与普通成员的区别是什么？</h1><ul>
<li>生命周期</li>
</ul>
<p>静态成员变量从类被加载开始到类被卸载，一直存在；</p>
<p>普通成员变量只有在类创建对象后才开始存在，对象结束，它的生命期结束；</p>
<ul>
<li>共享方式</li>
</ul>
<p>静态成员变量是全类共享；普通成员变量是每个对象单独享用的；</p>
<ul>
<li>定义位置</li>
</ul>
<p>普通成员变量存储在栈或堆中，而静态成员变量存储在静态全局区；</p>
<ul>
<li>初始化位置</li>
</ul>
<p>普通成员变量在类中初始化；静态成员变量在类外初始化；</p>
<ul>
<li>默认实参</li>
</ul>
<p>可以使用静态成员变量作为默认实参，</p>
<h1 id="说一下你理解的-ifdef-endif代表着什么？"><a href="#说一下你理解的-ifdef-endif代表着什么？" class="headerlink" title="说一下你理解的 ifdef   endif代表着什么？"></a>说一下你理解的 ifdef   endif代表着什么？</h1><ul>
<li><p>一般情况下，源程序中所有的行都参加编译。但是有时希望对其中一部分内容只在满足一定条件才进行编译，也就是对一部分内容指定编译的条件，这就是“条件编译”。有时，希望当满足某条件时对一组语句进行编译，而当条件不满足时则编译另一组语句。</p>
</li>
<li><p>条件编译命令最常见的形式为：</p>
</li>
</ul>
<p>#ifdef 标识符<br> 程序段1<br> #else<br> 程序段2<br> #endif<br>它的作用是：当标识符已经被定义过(一般是用#define命令定义)，则对程序段1进行编译，否则编译程序段2。<br>其中#else部分也可以没有，即：</p>
<p> #ifdef<br> 程序段1<br> #denif</p>
<ul>
<li>在一个大的软件工程里面，可能会有多个文件同时包含一个头文件，当这些文件编译链接成一个可执行文件上时，就会出现大量“重定义”错误。</li>
</ul>
<p>在头文件中使用#define、#ifndef、#ifdef、#endif能避免头文件重定义。</p>
<h1 id="隐式转换，如何消除隐式转换？"><a href="#隐式转换，如何消除隐式转换？" class="headerlink" title="隐式转换，如何消除隐式转换？"></a>隐式转换，如何消除隐式转换？</h1><p>1、C++的基本类型中并非完全的对立，部分数据类型之间是可以进行隐式转换的。所谓隐式转换，是指不需要用户干预，编译器私下进行的类型转换行为。很多时候用户可能都不知道进行了哪些转换</p>
<p>2、C++面向对象的多态特性，就是通过父类的类型实现对子类的封装。通过隐式转换，你可以直接将一个子类的对象使用父类的类型进行返回。在比如，数值和布尔类型的转换，整数和浮点数的转换等。</p>
<p>某些方面来说，隐式转换给C++程序开发者带来了不小的便捷。C++是一门强类型语言，类型的检查是非常严格的。</p>
<p>3、 基本数据类型 基本数据类型的转换以取值范围的作为转换基础（保证精度不丢失）。隐式转换发生在从小-&gt;大的转换中。比如从char转换为int。从int-&gt;long。自定义对象 子类对象可以隐式的转换为父类对象。</p>
<p>4、 C++中提供了explicit关键字，在构造函数声明的时候加上explicit关键字，能够禁止隐式转换。</p>
<p>5、如果构造函数只接受一个参数，则它实际上定义了转换为此类类型的隐式转换机制。可以通过将构造函数声明为explicit加以制止隐式类型转换，关键字explicit只对一个实参的构造函数有效，需要多个实参的构造函数不能用于执行隐式转换，所以无需将这些构造函数指定为explicit。</p>
<h1 id="迭代器：-it、it-哪个好，为什么"><a href="#迭代器：-it、it-哪个好，为什么" class="headerlink" title="迭代器：++it、it++哪个好，为什么"></a>迭代器：++it、it++哪个好，为什么</h1><ul>
<li>前置返回一个引用，后置返回一个对象</li>
</ul>
<p>// ++i实现代码为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>&amp; <span class="keyword">operator</span>++()</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  *<span class="keyword">this</span> += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>前置不会产生临时对象，后置必须产生临时对象，临时对象会导致效率降低<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//i++实现代码为：                 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">operator</span>++(<span class="keyword">int</span>)                 </span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> temp = *<span class="keyword">this</span>;                   </span><br><span class="line"></span><br><span class="line">   ++*<span class="keyword">this</span>;                       </span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> temp;                  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="C-如何处理多个异常的？"><a href="#C-如何处理多个异常的？" class="headerlink" title="C++如何处理多个异常的？"></a>C++如何处理多个异常的？</h1><ul>
<li><p>C++中的异常情况：<br>语法错误（编译错误）：比如变量未定义、括号不匹配、关键字拼写错误等等编译器在编译时能发现的错误，这类错误可以及时被编译器发现，而且可以及时知道出错的位置及原因，方便改正。<br>运行时错误：比如数组下标越界、系统内存不足等等。这类错误不易被程序员发现，它能通过编译且能进入运行，但运行时会出错，导致程序崩溃。为了有效处理程序运行时错误，C++中引入异常处理机制来解决此问题。</p>
</li>
<li><p>C++异常处理机制：<br>异常处理基本思想：执行一个函数的过程中发现异常，可以不用在本函数内立即进行处理， 而是抛出该异常，让函数的调用者直接或间接处理这个问题。<br>C++异常处理机制由3个模块组成：try(检查)、throw(抛出)、catch(捕获)<br>抛出异常的语句格式为：throw 表达式；如果try块中程序段发现了异常则抛出异常。</p>
</li>
</ul>
<p>~cpptry  {  可能抛出异常的语句；（检查）  }  catch（类型名[形参名]）//捕获特定类型的异常  {  //处理1；}  catch（类型名[形参名]）//捕获特定类型的异常  {  //处理2；}  catch（…）//捕获所有类型的异常  {  }~</p>
<h1 id="模板和实现可不可以不写在一个文件里面？为什么？"><a href="#模板和实现可不可以不写在一个文件里面？为什么？" class="headerlink" title="模板和实现可不可以不写在一个文件里面？为什么？"></a>模板和实现可不可以不写在一个文件里面？为什么？</h1><p>因为在编译时模板并不能生成真正的二进制代码，而是在编译调用模板类或函数的CPP文件时才会去找对应的模板声明和实现，在这种情况下编译器是不知道实现模板类或函数的CPP文件的存在，所以它只能找到模板类或函数的声明而找不到实现，而只好创建一个符号寄希望于链接程序找地址。</p>
<p>但模板类或函数的实现并不能被编译成二进制代码，结果链接程序找不到地址只好报错了。<br>《C++编程思想》第15章(第300页)说明了原因：模板定义很特殊。由template&lt;…&gt;处理的任何东西都意味着编译器在当时不为它分配存储空间，</p>
<p>它一直处于等待状态直到被一个模板实例告知。在编译器和连接器的某一处，有一机制能去掉指定模板的多重定义。所以为了容易使用，几乎总是在头文件中放置全部的模板声明和定义。</p>
<h1 id="在成员函数中调用delete-this会出现什么问题？对象还可以使用吗？"><a href="#在成员函数中调用delete-this会出现什么问题？对象还可以使用吗？" class="headerlink" title="在成员函数中调用delete this会出现什么问题？对象还可以使用吗？"></a>在成员函数中调用delete this会出现什么问题？对象还可以使用吗？</h1><p>1、在类对象的内存空间中，只有数据成员和虚函数表指针，并不包含代码内容，类的成员函数单独放在代码段中。在调用成员函数时，隐含传递一个this指针，让成员函数知道当前是哪个对象在调用它。当调用delete this时，类对象的内存空间被释放。在delete this之后进行的其他任何函数调用，只要不涉及到this指针的内容，都能够正常运行。一旦涉及到this指针，如操作数据成员，调用虚函数等，就会出现不可预期的问题。</p>
<p>2、为什么是不可预期的问题？</p>
<p>delete this之后不是释放了类对象的内存空间了么，那么这段内存应该已经还给系统，不再属于这个进程。照这个逻辑来看，应该发生指针错误，无访问权限之类的令系统崩溃的问题才对啊？这个问题牵涉到操作系统的内存管理策略。delete this释放了类对象的内存空间，但是内存空间却并不是马上被回收到系统中，可能是缓冲或者其他什么原因，导致这段内存空间暂时并没有被系统收回。</p>
<p>此时这段内存是可以访问的，你可以加上100，加上200，但是其中的值却是不确定的。当你获取数据成员，可能得到的是一串很长的未初始化的随机数；访问虚函数表，指针无效的可能性非常高，造成系统崩溃。</p>
<p>3、 如果在类的析构函数中调用delete this，会发生什么？</p>
<p>会导致堆栈溢出。原因很简单，delete的本质是“为将被释放的内存调用一个或多个析构函数，然后，释放内存”。显然，delete this会去调用本对象的析构函数，而析构函数中又调用delete this，形成无限递归，造成堆栈溢出，系统崩溃。</p>
<h1 id="如何在不使用额外空间的情况下，交换两个数？你有几种方法"><a href="#如何在不使用额外空间的情况下，交换两个数？你有几种方法" class="headerlink" title="如何在不使用额外空间的情况下，交换两个数？你有几种方法"></a>如何在不使用额外空间的情况下，交换两个数？你有几种方法</h1><ul>
<li><p>算术</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = x + y;</span><br><span class="line"> y = x - y;</span><br><span class="line"></span><br><span class="line">x = x - y;</span><br></pre></td></tr></table></figure>
</li>
<li><p>异或</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = x^y;<span class="comment">// 只能对int,char..</span></span><br><span class="line"> y = x^y;</span><br><span class="line"> x = x^y;</span><br><span class="line"> x ^= y ^= x;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="你知道strcpy和memcpy的区别是什么吗？"><a href="#你知道strcpy和memcpy的区别是什么吗？" class="headerlink" title="你知道strcpy和memcpy的区别是什么吗？"></a>你知道strcpy和memcpy的区别是什么吗？</h1><ol>
<li>复制的内容不同。strcpy只能复制字符串，而memcpy可以复制任意内容，例如字符数组、整型、结构体、类等。</li>
<li>复制的方法不同。strcpy不需要指定长度，它遇到被复制字符的串结束符”\0”才结束，所以容易溢出。memcpy则是根据其第3个参数决定复制的长度。</li>
<li>用途不同。通常在复制字符串时用strcpy，而需要复制其他类型数据时则一般用memcpy</li>
</ol>
<h1 id="程序在执行int-main-int-argc-char-argv-时的内存结构，你了解吗？"><a href="#程序在执行int-main-int-argc-char-argv-时的内存结构，你了解吗？" class="headerlink" title="程序在执行int main(int argc, char *argv[])时的内存结构，你了解吗？"></a>程序在执行int main(int argc, char *argv[])时的内存结构，你了解吗？</h1><p>参数的含义是程序在命令行下运行的时候，需要输入argc 个参数，每个参数是以char 类型输入的，依次存在数组里面，数组是 argv[]，所有的参数在指针</p>
<p>char * 指向的内存中，数组的中元素的个数为 argc 个，第一个参数为程序的名称。</p>
<h1 id="volatile关键字的作用？"><a href="#volatile关键字的作用？" class="headerlink" title="volatile关键字的作用？"></a>volatile关键字的作用？</h1><p>volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改，比如：操作系统、硬件或者其它线程等。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。</p>
<p>声明时语法：int volatile vInt; 当要求使用 volatile 声明的变量的值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。而且读取的数据立刻被保存。</p>
<p>volatile用在如下的几个地方：</p>
<ol>
<li>中断服务程序中修改的供其它程序检测的变量需要加volatile；</li>
<li>多任务环境下各任务间共享的标志应该加volatile；</li>
<li>存储器映射的硬件寄存器通常也要加volatile说明，因为每次对它的读写都可能由不同意义；</li>
</ol>
<h1 id="如果有一个空类，它会默认添加哪些函数？"><a href="#如果有一个空类，它会默认添加哪些函数？" class="headerlink" title="如果有一个空类，它会默认添加哪些函数？"></a>如果有一个空类，它会默认添加哪些函数？</h1><ul>
<li><p>Empty(); // 缺省构造函数//</p>
</li>
<li><p>Empty( const Empty&amp; ); // 拷贝构造函数//</p>
</li>
<li><p>~Empty(); // 析构函数//</p>
</li>
<li><p>Empty&amp; operator=( const Empty&amp; ); // 赋值运算符//</p>
</li>
</ul>
<h1 id="C-中标准库是什么？"><a href="#C-中标准库是什么？" class="headerlink" title="C++中标准库是什么？"></a>C++中标准库是什么？</h1><ul>
<li>C++ 标准库可以分为两部分：</li>
</ul>
<p>标准函数库：这个库是由通用的、独立的、不属于任何类的函数组成的。函数库继承自 C 语言。</p>
<p>面向对象类库：这个库是类及其相关函数的集合。</p>
<ul>
<li><p>输入/输出 I/O、字符串和字符处理、数学、时间、日期和本地化、动态分配、其他、宽字符函数</p>
</li>
<li><p>标准的 C++ I/O 类、String 类、数值类、STL 容器类、STL 算法、STL 函数对象、STL 迭代器、STL 分配器、本地化库、异常处理类、杂项支持库</p>
</li>
</ul>
<h1 id="你知道const-char-与string之间的关系是什么吗？"><a href="#你知道const-char-与string之间的关系是什么吗？" class="headerlink" title="你知道const char* 与string之间的关系是什么吗？"></a>你知道const char* 与string之间的关系是什么吗？</h1><ul>
<li><p>string 是c++标准库里面其中一个，封装了对字符串的操作，实际操作过程我们可以用const char*给string类初始化</p>
</li>
<li><p>三者的转化关系如下所示：</p>
</li>
</ul>
<p>a)  string转const char*<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s = “abc”; </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* c_s = s.c_str();</span><br></pre></td></tr></table></figure></p>
<p>b)  const char* 转string，直接赋值即可<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* c_s = “abc”; </span><br><span class="line"> <span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(c_s)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>c)  string 转char*<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s = “abc”; </span><br><span class="line"><span class="keyword">char</span>* c; </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> len = s.length(); </span><br><span class="line">c = <span class="keyword">new</span> <span class="keyword">char</span>[len+<span class="number">1</span>]; </span><br><span class="line"><span class="built_in">strcpy</span>(c,s.c_str());</span><br></pre></td></tr></table></figure></p>
<p>d)  char* 转string<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* c = “abc”; </span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(c)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>e)  const char<em> 转char</em><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* cpc = “abc”; </span><br><span class="line"><span class="keyword">char</span>* pc = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(cpc)+<span class="number">1</span>]; </span><br><span class="line"><span class="built_in">strcpy</span>(pc,cpc);</span><br></pre></td></tr></table></figure></p>
<p>f)  char<em> 转const char</em>，直接赋值即可<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* pc = “abc”; </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* cpc = pc;</span><br></pre></td></tr></table></figure></p>
<h1 id="为什么拷贝构造函数必须传引用不能传值？"><a href="#为什么拷贝构造函数必须传引用不能传值？" class="headerlink" title="为什么拷贝构造函数必须传引用不能传值？"></a>为什么拷贝构造函数必须传引用不能传值？</h1><ul>
<li>拷贝构造函数的作用就是用来复制对象的，在使用这个对象的实例来初始化这个对象的一个新的实例。</li>
<li>参数传递过程到底发生了什么？<ul>
<li>将地址传递和值传递统一起来，归根结底还是传递的是”值”(地址也是值，只不过通过它可以找到另一个值)！</li>
</ul>
</li>
<li>值传递:<ul>
<li>对于内置数据类型的传递时，直接赋值拷贝给形参(注意形参是函数内局部变量)；</li>
<li>对于类类型的传递时，需要首先调用该类的拷贝构造函数来初始化形参(局部对象)；</li>
</ul>
</li>
</ul>
<p>如void foo(class_type obj_local){}, 如果调用foo(obj); 首先class_type obj_local(obj) ,这样就定义了局部变量obj_local供函数内部使用</p>
<p>ii)引用传递:<br>  无论对内置类型还是类类型，传递引用或指针最终都是传递的地址值！而地址总是指针类型(属于简单类型), 显然参数传递时，按简单类型的赋值拷贝，而不会有拷贝构造函数的调用(对于类类型).<br>上述1) 2)回答了为什么拷贝构造函数使用值传递会产生无限递归调用，内存溢出。</p>
<p>拷贝构造函数用来初始化一个非引用类类型对象，如果用传值的方式进行传参数，那么构造实参需要调用拷贝构造函数，而拷贝构造函数需要传递实参，所以会一直递归。</p>
<h1 id="你知道空类的大小是多少吗？"><a href="#你知道空类的大小是多少吗？" class="headerlink" title="你知道空类的大小是多少吗？"></a>你知道空类的大小是多少吗？</h1><ul>
<li>C++空类的大小不为0，不同编译器设置不一样，vs设置为1；</li>
<li>C++标准指出，不允许一个对象（当然包括类对象）的大小为0，不同的对象不能具有相同的地址；</li>
<li>带有虚函数的C++类大小不为1，因为每一个对象会有一个vptr指向虚函数表，具体大小根据指针大小确定；</li>
<li>C++中要求对于类的每个实例都必须有独一无二的地址,那么编译器自动为空类分配一个字节大小，这样便保证了每个实例均有独一无二的内存地址。</li>
</ul>
<h1 id="this指针调用成员变量时，堆栈会发生什么变化？"><a href="#this指针调用成员变量时，堆栈会发生什么变化？" class="headerlink" title="this指针调用成员变量时，堆栈会发生什么变化？"></a>this指针调用成员变量时，堆栈会发生什么变化？</h1><p>当在类的非静态成员函数访问类的非静态成员时，编译器会自动将对象的地址传给作为隐含参数传递给函数，这个隐含参数就是this指针。</p>
<p>即使你并没有写this指针，编译器在链接时也会加上this的，对各成员的访问都是通过this的。</p>
<p>例如你建立了类的多个对象时，在调用类的成员函数时，你并不知道具体是哪个对象在调用，此时你可以通过查看this指针来查看具体是哪个对象在调用。This指针首先入栈，然后成员函数的参数从右向左进行入栈，最后函数返回地址入栈。</p>
<h1 id="你知道静态绑定和动态绑定吗？讲讲？"><a href="#你知道静态绑定和动态绑定吗？讲讲？" class="headerlink" title="你知道静态绑定和动态绑定吗？讲讲？"></a>你知道静态绑定和动态绑定吗？讲讲？</h1><ul>
<li><p>对象的静态类型：对象在声明时采用的类型。是在编译期确定的。</p>
</li>
<li><p>对象的动态类型：目前所指对象的类型。是在运行期决定的。对象的动态类型可以更改，但是静态类型无法更改。</p>
</li>
<li><p>静态绑定：绑定的是对象的静态类型，某特性（比如函数依赖于对象的静态类型，发生在编译期。</p>
</li>
<li><p>动态绑定：绑定的是对象的动态类型，某特性（比如函数依赖于对象的动态类型，发生在运行期。</p>
</li>
</ul>
<h1 id="如何设计一个类计算子类的个数？"><a href="#如何设计一个类计算子类的个数？" class="headerlink" title="如何设计一个类计算子类的个数？"></a>如何设计一个类计算子类的个数？</h1><ul>
<li>为类设计一个static静态变量count作为计数器；</li>
<li>类定义结束后初始化count;</li>
<li>在构造函数中对count进行+1;</li>
<li>设计拷贝构造函数，在进行拷贝构造函数中进行count +1，操作；</li>
<li>设计复制构造函数，在进行复制函数中对count+1操作；</li>
<li>在析构函数中对count进行-1；</li>
</ul>
<h1 id="怎么快速定位错误出现的地方"><a href="#怎么快速定位错误出现的地方" class="headerlink" title="怎么快速定位错误出现的地方"></a>怎么快速定位错误出现的地方</h1><p>1、如果是简单的错误，可以直接双击错误列表里的错误项或者生成输出的错误信息中带行号的地方就可以让编辑窗口定位到错误的位置上。</p>
<p>2、对于复杂的模板错误，最好使用生成输出窗口。</p>
<p>多数情况下出发错误的位置是最靠后的引用位置。如果这样确定不了错误，就需要先把自己写的代码里的引用位置找出来，然后逐个分析了。</p>
<h1 id="类对象的大小受哪些因素影响？"><a href="#类对象的大小受哪些因素影响？" class="headerlink" title="类对象的大小受哪些因素影响？"></a>类对象的大小受哪些因素影响？</h1><ul>
<li>类的非静态成员变量大小，静态成员不占据类的空间，成员函数也不占据类的空间大小；</li>
<li>内存对齐另外分配的空间大小，类内的数据也是需要进行内存对齐操作的；</li>
<li>虚函数的话，会在类对象插入vptr指针，加上指针大小；</li>
<li>当该该类是某类的派生类，那么派生类继承的基类部分的数据成员也会存在在派生类中的空间中，也会对派生类进行扩展。</li>
</ul>
<h1 id="移动构造函数听说过吗？说说"><a href="#移动构造函数听说过吗？说说" class="headerlink" title="移动构造函数听说过吗？说说"></a>移动构造函数听说过吗？说说</h1><ul>
<li>有时候我们会遇到这样一种情况，我们用对象a初始化对象b后对象a我们就不在使用了，但是对象a的空间还在呀（在析构之前），既然拷贝构造函数，实际上就是把a对象的内容复制一份到b中，那么为什么我们不能直接使用a的空间呢？这样就避免了新的空间的分配，大大降低了构造的成本。这就是移动构造函数设计的初衷；</li>
<li>拷贝构造函数中，对于指针，我们一定要采用深层复制，而移动构造函数中，对于指针，我们采用浅层复制；</li>
<li>C++引入了移动构造函数，专门处理这种，用a初始化b后，就将a析构的情况；</li>
<li>与拷贝类似，移动也使用一个对象的值设置另一个对象的值。但是，又与拷贝不同的是，移动实现的是对象值真实的转移（源对象到目的对象）：源对象将丢失其内容，其内容将被目的对象占有。移动操作的发生的时候，是当移动值的对象是未命名的对象的时候。</li>
</ul>
<p>这里未命名的对象就是那些临时变量，甚至都不会有名称。典型的未命名对象就是函数的返回值或者类型转换的对象。使用临时对象的值初始化另一个对象值，不会要求对对象的复制：因为临时对象不会有其它使用，因而，它的值可以被移动到目的对象。做到这些，就要使用移动构造函数和移动赋值：当使用一个临时变量对象进行构造初始化的时候，调用移动构造函数。类似的，使用未命名的变量的值赋给一个对象时，调用移动赋值操作；</p>
<p>5)<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Example6 (Example6&amp;&amp; x) : ptr(x.ptr) </span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">    x.ptr = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// move assignment</span></span><br><span class="line"></span><br><span class="line">  Example6&amp; <span class="keyword">operator</span>= (Example6&amp;&amp; x) </span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">delete</span> ptr; </span><br><span class="line"></span><br><span class="line">   ptr = x.ptr;</span><br><span class="line"></span><br><span class="line">   x.ptr=<span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="什么时候合成构造函数？都说一说，你知道的都说一下"><a href="#什么时候合成构造函数？都说一说，你知道的都说一下" class="headerlink" title="什么时候合成构造函数？都说一说，你知道的都说一下"></a>什么时候合成构造函数？都说一说，你知道的都说一下</h1><ul>
<li>如果一个类没有任何构造函数，但他含有一个成员对象，该成员对象含有默认构造函数，那么编译器就为该类合成一个默认构造函数，因为不合成一个默认构造函数那么该成员对象的构造函数不能调用；</li>
<li>没有任何构造函数的类派生自一个带有默认构造函数的基类，那么需要为该派生类合成一个构造函数，只有这样基类的构造函数才能被调用；</li>
<li>带有虚函数的类，虚函数的引入需要进入虚表，指向虚表的指针，该指针是在构造函数中初始化的，所以没有构造函数的话该指针无法被初始化；</li>
<li>带有一个虚基类的类</li>
</ul>
<p>还有一点需要注意的是：</p>
<ul>
<li>并不是任何没有构造函数的类都会合成一个构造函数</li>
<li>编译器合成出来的构造函数并不会显示设定类内的每一个成员变量</li>
</ul>
<h1 id="那什么时候需要合成拷贝构造函数呢？"><a href="#那什么时候需要合成拷贝构造函数呢？" class="headerlink" title="那什么时候需要合成拷贝构造函数呢？"></a>那什么时候需要合成拷贝构造函数呢？</h1><p>有三种情况会以一个对象的内容作为另一个对象的初值：</p>
<ul>
<li>对一个对象做显示的初始化操作，X xx = x;</li>
<li>当对象被当做参数交给某个函数时；</li>
<li><p>当函数传回一个类对象时；</p>
</li>
<li><p>如果一个类没有拷贝构造函数，但是含有一个类类型的成员变量，该类型含有拷贝构造函数，此时编译器会为该类合成一个拷贝构造函数；</p>
</li>
<li>如果一个类没有拷贝构造函数，但是该类继承自含有拷贝构造函数的基类，此时编译器会为该类合成一个拷贝构造函数；</li>
<li>如果一个类没有拷贝构造函数，但是该类声明或继承了虚函数，此时编译器会为该类合成一个拷贝构造函数；</li>
<li>如果一个类没有拷贝构造函数，但是该类含有虚基类，此时编译器会为该类合成一个拷贝构造函数；</li>
</ul>
<h1 id="成员初始化列表会在什么时候用到？它的调用过程是什么？"><a href="#成员初始化列表会在什么时候用到？它的调用过程是什么？" class="headerlink" title="成员初始化列表会在什么时候用到？它的调用过程是什么？"></a>成员初始化列表会在什么时候用到？它的调用过程是什么？</h1><ul>
<li>当初始化一个引用成员变量时；</li>
<li>初始化一个const成员变量时；</li>
<li>当调用一个基类的构造函数，而构造函数拥有一组参数时；</li>
<li>当调用一个成员类的构造函数，而他拥有一组参数；</li>
<li>编译器会一一操作初始化列表，以适当顺序在构造函数之内安插初始化操作，并且在任何显示用户代码前。list中的项目顺序是由类中的成员声明顺序决定的，不是初始化列表中的排列顺序决定的。</li>
</ul>
<h1 id="构造函数的执行顺序是什么？"><a href="#构造函数的执行顺序是什么？" class="headerlink" title="构造函数的执行顺序是什么？"></a>构造函数的执行顺序是什么？</h1><ul>
<li>在派生类构造函数中，所有的虚基类及上一层基类的构造函数调用；</li>
<li>对象的vptr被初始化；</li>
<li>如果有成员初始化列表，将在构造函数体内扩展开来，这必须在vptr被设定之后才做；</li>
<li>执行程序员所提供的代码；</li>
</ul>
<h1 id="一个类中的全部构造函数的扩展过程是什么？"><a href="#一个类中的全部构造函数的扩展过程是什么？" class="headerlink" title="一个类中的全部构造函数的扩展过程是什么？"></a>一个类中的全部构造函数的扩展过程是什么？</h1><ul>
<li>记录在成员初始化列表中的数据成员初始化操作会被放在构造函数的函数体内，并与成员的声明顺序为顺序；</li>
<li>如果一个成员并没有出现在成员初始化列表中，但它有一个默认构造函数，那么默认构造函数必须被调用；</li>
<li>如果class有虚表，那么它必须被设定初值；</li>
<li>所有上一层的基类构造函数必须被调用；</li>
<li>所有虚基类的构造函数必须被调用。</li>
</ul>
<h1 id="说一说strcpy、sprintf与memcpy这三个函数的不同之处"><a href="#说一说strcpy、sprintf与memcpy这三个函数的不同之处" class="headerlink" title="说一说strcpy、sprintf与memcpy这三个函数的不同之处"></a>说一说strcpy、sprintf与memcpy这三个函数的不同之处</h1><ul>
<li>操作对象不同<ul>
<li>strcpy的两个操作对象均为字符串</li>
<li>sprintf的操作源对象可以是多种数据类型，目的操作对象是字符串</li>
<li>memcpy的两个对象就是两个任意可操作的内存地址，并不限于何种数据类型。</li>
</ul>
</li>
<li>执行效率不同<ul>
<li>memcpy最高，strcpy次之，sprintf的效率最低。</li>
</ul>
</li>
<li>实现功能不同<ul>
<li>strcpy主要实现字符串变量间的拷贝</li>
<li>sprintf主要实现其他数据类型格式到字符串的转化</li>
<li>memcpy主要是内存块间的拷贝。</li>
</ul>
</li>
</ul>
<h1 id="将引用作为函数参数有哪些好处？"><a href="#将引用作为函数参数有哪些好处？" class="headerlink" title="将引用作为函数参数有哪些好处？"></a>将引用作为函数参数有哪些好处？</h1><ul>
<li>传递引用给函数与传递指针的效果是一样的。</li>
</ul>
<p>这时，被调函数的形参就成为原来主调函数中的实参变量或对象的一个别名来使用，所以在被调函数中对形参变量的操作就是对其相应的目标对象（在主调函数中）的操作。</p>
<ul>
<li>使用引用传递函数的参数，在内存中并没有产生实参的副本，它是直接对实参操作；</li>
</ul>
<p>而使用一般变量传递函数的参数，当发生函数调用时，需要给形参分配存储单元，形参变量是实参变量的副本；</p>
<p>如果传递的是对象，还将调用拷贝构造函数。</p>
<p>因此，当参数传递的数据较大时，用引用比用一般变量传递参数的效率和所占空间都好。</p>
<ul>
<li>使用指针作为函数的参数虽然也能达到与使用引用的效果，但是，在被调函数中同样要给形参分配存储单元，且需要重复使用”*指针变量名”的形式进行运算，这很容易产生错误且程序的阅读性较差；</li>
</ul>
<p>另一方面，在主调函数的调用点处，必须用变量的地址作为实参。而引用更容易使用，更清晰。</p>
<h1 id="你知道数组和指针的区别吗？"><a href="#你知道数组和指针的区别吗？" class="headerlink" title="你知道数组和指针的区别吗？"></a>你知道数组和指针的区别吗？</h1><ul>
<li>数组在内存中是连续存放的，开辟一块连续的内存空间；数组所占存储空间：sizeof（数组名）；数组大小：sizeof(数组名)/sizeof(数组元素数据类型)；</li>
<li>用运算符sizeof 可以计算出数组的容量（字节数）。sizeof(p),p 为指针得到的是一个指针变量的字节数，而不是p 所指的内存容量。</li>
<li>编译器为了简化对数组的支持，实际上是利用指针实现了对数组的支持。具体来说，就是将表达式中的数组元素引用转换为指针加偏移量的引用。</li>
<li>在向函数传递参数的时候，如果实参是一个数组，那用于接受的形参为对应的指针。也就是传递过去是数组的首地址而不是整个数组，能够提高效率；</li>
<li>在使用下标的时候，两者的用法相同，都是原地址加上下标值，不过数组的原地址就是数组首元素的地址是固定的，指针的原地址就不是固定的。</li>
</ul>
<h1 id="如何阻止一个类被实例化？有哪些方法？"><a href="#如何阻止一个类被实例化？有哪些方法？" class="headerlink" title="如何阻止一个类被实例化？有哪些方法？"></a>如何阻止一个类被实例化？有哪些方法？</h1><ul>
<li>将类定义为抽象基类或者将构造函数声明为private；</li>
<li>不允许类外部创建类对象，只能在类内部创建对象</li>
</ul>
<h1 id="main函数的返回值有什么值得考究之处吗？"><a href="#main函数的返回值有什么值得考究之处吗？" class="headerlink" title="main函数的返回值有什么值得考究之处吗？"></a>main函数的返回值有什么值得考究之处吗？</h1><p>程序运行过程入口点main函数，main（）函数返回值类型必须是int，这样返回值才能传递给程序激活者（如操作系统）表示程序正常退出。</p>
<p>main（int args, char **argv） 参数的传递。参数的处理，一般会调用getopt（）函数处理，但实践中，这仅仅是一部分，不会经常用到的技能点。</p>
<h1 id="智能指针出现循环引用怎么解决？"><a href="#智能指针出现循环引用怎么解决？" class="headerlink" title="智能指针出现循环引用怎么解决？"></a>智能指针出现循环引用怎么解决？</h1><p>弱指针用于专门解决shared_ptr循环引用的问题，weak_ptr不会修改引用计数，即其存在与否并不影响对象的引用计数器。循环引用就是：两个对象互相使用一个shared_ptr成员变量指向对方。</p>
<p>弱引用并不对对象的内存进行管理，在功能上类似于普通指针，然而一个比较大的区别是，弱引用能检测到所管理的对象是否已经被释放，从而避免访问非法内存。</p>
<h1 id="strcpy函数和strncpy函数的区别？哪个函数更安全？"><a href="#strcpy函数和strncpy函数的区别？哪个函数更安全？" class="headerlink" title="strcpy函数和strncpy函数的区别？哪个函数更安全？"></a>strcpy函数和strncpy函数的区别？哪个函数更安全？</h1><ul>
<li><p>函数原型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">strcpy</span><span class="params">(<span class="keyword">char</span>* strDest, <span class="keyword">const</span> <span class="keyword">char</span>* strSrc)</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">strncpy</span><span class="params">(<span class="keyword">char</span>* strDest, <span class="keyword">const</span> <span class="keyword">char</span>* strSrc, <span class="keyword">int</span> pos)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>strcpy函数: 如果参数 dest 所指的内存空间不够大，可能会造成缓冲溢出(buffer Overflow)的错误情况，在编写程序时请特别留意，或者用strncpy()来取代。<br>strncpy函数：用来复制源字符串的前n个字符，src 和 dest 所指的内存区域不能重叠，且 dest 必须有足够的空间放置n个字符。</p>
</li>
<li><p>如果目标长&gt;指定长&gt;源长，则将源长全部拷贝到目标长，自动加上’\0’<br>如果指定长&lt;源长，则将源长中按指定长度拷贝到目标字符串，不包括’\0’  如果指定长&gt;目标长，运行时错误 ；</p>
</li>
</ul>
<h1 id="你知道回调函数吗？它的作用？"><a href="#你知道回调函数吗？它的作用？" class="headerlink" title="你知道回调函数吗？它的作用？"></a>你知道回调函数吗？它的作用？</h1><ul>
<li>当发生某种事件时，系统或其他函数将会自动调用你定义的一段函数；</li>
<li>回调函数就相当于一个中断处理函数，由系统在符合你设定的条件时自动调用。为此，你需要做三件事：1，声明；2，定义；3，设置触发条件，就是在你的函数中把你的回调函数名称转化为地址作为一个参数，以便于系统调用；</li>
<li>回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用为调用它所指向的函数时，我们就说这是回调函数；</li>
<li>因为可以把调用者与被调用者分开。调用者不关心谁是被调用者，所有它需知道的，只是存在一个具有某种特定原型、某些限制条件（如返回值为int）的被调用函数。</li>
</ul>
<h1 id="动态编译与静态编译"><a href="#动态编译与静态编译" class="headerlink" title="动态编译与静态编译"></a>动态编译与静态编译</h1><ul>
<li><p>静态编译，编译器在编译可执行文件时，把需要用到的对应动态链接库中的部分提取出来，连接到可执行文件中去，使可执行文件在运行时不需要依赖于动态链接库；</p>
</li>
<li><p>动态编译的可执行文件需要附带一个动态链接库，在执行时，需要调用其对应动态链接库的命令。所以其优点一方面是缩小了执行文件本身的体积，另一方面是加快了编译速度，节省了系统资源。</p>
</li>
</ul>
<p>缺点是哪怕是很简单的程序，只用到了链接库的一两条命令，也需要附带一个相对庞大的链接库；二是如果其他计算机上没有安装对应的运行库，则用动态编译的可执行文件就不能运行。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/C/" rel="tag"># C++</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/01/15/STL源码剖析 笔记5/" rel="next" title="STL 源码剖析 笔记5">
                <i class="fa fa-chevron-left"></i> STL 源码剖析 笔记5
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/03/09/Cpp提问1/" rel="prev" title="《逆袭进大厂》之C++篇 1">
                《逆袭进大厂》之C++篇 1 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/header.jpg" alt="Hao Yu">
            
              <p class="site-author-name" itemprop="name">Hao Yu</p>
              <p class="site-description motion-element" itemprop="description">Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author</p>
          </div>
          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">283</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>
        	<audio controls="controls" loop="loop" preload="auto" src="/resource/xiaomeihao.mp3">
	        </audio>
	

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yuhao0102" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:yuh18@mails.tsinghua.edu.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#什么情况会自动生成默认构造函数？"><span class="nav-number">1.</span> <span class="nav-text">什么情况会自动生成默认构造函数？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#函数指针？"><span class="nav-number">2.</span> <span class="nav-text">函数指针？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#使用智能指针管理内存资源，RAII是怎么回事？"><span class="nav-number">3.</span> <span class="nav-text">使用智能指针管理内存资源，RAII是怎么回事？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#手写实现智能指针类"><span class="nav-number">4.</span> <span class="nav-text">手写实现智能指针类</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#说一说你理解的内存对齐以及原因"><span class="nav-number">5.</span> <span class="nav-text">说一说你理解的内存对齐以及原因</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#结构体变量比较是否相等"><span class="nav-number">6.</span> <span class="nav-text">结构体变量比较是否相等</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#函数调用过程栈的变化，返回值和参数变量哪个先入栈？"><span class="nav-number">7.</span> <span class="nav-text">函数调用过程栈的变化，返回值和参数变量哪个先入栈？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#define、const、typedef、inline的使用方法？他们之间有什么区别？"><span class="nav-number">8.</span> <span class="nav-text">define、const、typedef、inline的使用方法？他们之间有什么区别？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#const与-define的区别："><span class="nav-number">8.1.</span> <span class="nav-text">const与#define的区别：</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#你知道printf函数的实现原理是什么吗？"><span class="nav-number">9.</span> <span class="nav-text">你知道printf函数的实现原理是什么吗？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#说一说你了解的关于lambda函数的全部知识"><span class="nav-number">10.</span> <span class="nav-text">说一说你了解的关于lambda函数的全部知识</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#将字符串“hello-world”从开始到打印到屏幕上的全过程"><span class="nav-number">11.</span> <span class="nav-text">将字符串“hello world”从开始到打印到屏幕上的全过程?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#模板类和模板函数的区别是什么？"><span class="nav-number">12.</span> <span class="nav-text">模板类和模板函数的区别是什么？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#为什么模板类一般都是放在一个h文件中"><span class="nav-number">13.</span> <span class="nav-text">为什么模板类一般都是放在一个h文件中</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C-中类成员的访问权限和继承权限问题"><span class="nav-number">14.</span> <span class="nav-text">C++中类成员的访问权限和继承权限问题</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#cout和printf有什么区别？"><span class="nav-number">15.</span> <span class="nav-text">cout和printf有什么区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#你知道重载运算符吗？"><span class="nav-number">16.</span> <span class="nav-text">你知道重载运算符吗？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#当程序中有函数重载时，函数的匹配原则和顺序是什么？"><span class="nav-number">17.</span> <span class="nav-text">当程序中有函数重载时，函数的匹配原则和顺序是什么？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#定义和声明的区别"><span class="nav-number">18.</span> <span class="nav-text">定义和声明的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#全局变量和static变量的区别"><span class="nav-number">19.</span> <span class="nav-text">全局变量和static变量的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#静态成员与普通成员的区别是什么？"><span class="nav-number">20.</span> <span class="nav-text">静态成员与普通成员的区别是什么？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#说一下你理解的-ifdef-endif代表着什么？"><span class="nav-number">21.</span> <span class="nav-text">说一下你理解的 ifdef   endif代表着什么？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#隐式转换，如何消除隐式转换？"><span class="nav-number">22.</span> <span class="nav-text">隐式转换，如何消除隐式转换？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#迭代器：-it、it-哪个好，为什么"><span class="nav-number">23.</span> <span class="nav-text">迭代器：++it、it++哪个好，为什么</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C-如何处理多个异常的？"><span class="nav-number">24.</span> <span class="nav-text">C++如何处理多个异常的？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#模板和实现可不可以不写在一个文件里面？为什么？"><span class="nav-number">25.</span> <span class="nav-text">模板和实现可不可以不写在一个文件里面？为什么？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#在成员函数中调用delete-this会出现什么问题？对象还可以使用吗？"><span class="nav-number">26.</span> <span class="nav-text">在成员函数中调用delete this会出现什么问题？对象还可以使用吗？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#如何在不使用额外空间的情况下，交换两个数？你有几种方法"><span class="nav-number">27.</span> <span class="nav-text">如何在不使用额外空间的情况下，交换两个数？你有几种方法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#你知道strcpy和memcpy的区别是什么吗？"><span class="nav-number">28.</span> <span class="nav-text">你知道strcpy和memcpy的区别是什么吗？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#程序在执行int-main-int-argc-char-argv-时的内存结构，你了解吗？"><span class="nav-number">29.</span> <span class="nav-text">程序在执行int main(int argc, char *argv[])时的内存结构，你了解吗？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#volatile关键字的作用？"><span class="nav-number">30.</span> <span class="nav-text">volatile关键字的作用？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#如果有一个空类，它会默认添加哪些函数？"><span class="nav-number">31.</span> <span class="nav-text">如果有一个空类，它会默认添加哪些函数？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C-中标准库是什么？"><span class="nav-number">32.</span> <span class="nav-text">C++中标准库是什么？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#你知道const-char-与string之间的关系是什么吗？"><span class="nav-number">33.</span> <span class="nav-text">你知道const char* 与string之间的关系是什么吗？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#为什么拷贝构造函数必须传引用不能传值？"><span class="nav-number">34.</span> <span class="nav-text">为什么拷贝构造函数必须传引用不能传值？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#你知道空类的大小是多少吗？"><span class="nav-number">35.</span> <span class="nav-text">你知道空类的大小是多少吗？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#this指针调用成员变量时，堆栈会发生什么变化？"><span class="nav-number">36.</span> <span class="nav-text">this指针调用成员变量时，堆栈会发生什么变化？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#你知道静态绑定和动态绑定吗？讲讲？"><span class="nav-number">37.</span> <span class="nav-text">你知道静态绑定和动态绑定吗？讲讲？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#如何设计一个类计算子类的个数？"><span class="nav-number">38.</span> <span class="nav-text">如何设计一个类计算子类的个数？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#怎么快速定位错误出现的地方"><span class="nav-number">39.</span> <span class="nav-text">怎么快速定位错误出现的地方</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#类对象的大小受哪些因素影响？"><span class="nav-number">40.</span> <span class="nav-text">类对象的大小受哪些因素影响？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#移动构造函数听说过吗？说说"><span class="nav-number">41.</span> <span class="nav-text">移动构造函数听说过吗？说说</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#什么时候合成构造函数？都说一说，你知道的都说一下"><span class="nav-number">42.</span> <span class="nav-text">什么时候合成构造函数？都说一说，你知道的都说一下</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#那什么时候需要合成拷贝构造函数呢？"><span class="nav-number">43.</span> <span class="nav-text">那什么时候需要合成拷贝构造函数呢？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#成员初始化列表会在什么时候用到？它的调用过程是什么？"><span class="nav-number">44.</span> <span class="nav-text">成员初始化列表会在什么时候用到？它的调用过程是什么？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#构造函数的执行顺序是什么？"><span class="nav-number">45.</span> <span class="nav-text">构造函数的执行顺序是什么？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#一个类中的全部构造函数的扩展过程是什么？"><span class="nav-number">46.</span> <span class="nav-text">一个类中的全部构造函数的扩展过程是什么？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#说一说strcpy、sprintf与memcpy这三个函数的不同之处"><span class="nav-number">47.</span> <span class="nav-text">说一说strcpy、sprintf与memcpy这三个函数的不同之处</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#将引用作为函数参数有哪些好处？"><span class="nav-number">48.</span> <span class="nav-text">将引用作为函数参数有哪些好处？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#你知道数组和指针的区别吗？"><span class="nav-number">49.</span> <span class="nav-text">你知道数组和指针的区别吗？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#如何阻止一个类被实例化？有哪些方法？"><span class="nav-number">50.</span> <span class="nav-text">如何阻止一个类被实例化？有哪些方法？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#main函数的返回值有什么值得考究之处吗？"><span class="nav-number">51.</span> <span class="nav-text">main函数的返回值有什么值得考究之处吗？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#智能指针出现循环引用怎么解决？"><span class="nav-number">52.</span> <span class="nav-text">智能指针出现循环引用怎么解决？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#strcpy函数和strncpy函数的区别？哪个函数更安全？"><span class="nav-number">53.</span> <span class="nav-text">strcpy函数和strncpy函数的区别？哪个函数更安全？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#你知道回调函数吗？它的作用？"><span class="nav-number">54.</span> <span class="nav-text">你知道回调函数吗？它的作用？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#动态编译与静态编译"><span class="nav-number">55.</span> <span class="nav-text">动态编译与静态编译</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>
  <div id="DvelopmentTarget">     
  </div>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart" aria-hidden="false"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>

  
</div>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_uv"> 
  本站访客数<span id="busuanzi_value_site_uv"></span>人次
</span>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  


  <script type="text/javascript" src="/js/src/love.js"></script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
