<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zn-ch">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-center-simple.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="数据库,">










<meta name="description" content="Redis数据库中的每个键值对都是由对象组成的：  数据库键总是一个字符串对象； 数据库键的值可以是字符串对象、列表对象、哈希对象、集合对象、有序集合对象这五种对象中的一种。  数据结构与对象简单动态字符串Redis自己构建了一种名叫“简单动态字符串”（SDS）的类型，当Redis需要的不仅仅是一个字符串字面量，而是一个可以被修改的字符串值时，使用SDS用作默认字符串表示。如果执行了：12redi">
<meta name="keywords" content="数据库">
<meta property="og:type" content="article">
<meta property="og:title" content="redis设计与实现笔记1——数据结构与对象">
<meta property="og:url" content="http://yoursite.com/2020/03/14/redis设计与实现1/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="Redis数据库中的每个键值对都是由对象组成的：  数据库键总是一个字符串对象； 数据库键的值可以是字符串对象、列表对象、哈希对象、集合对象、有序集合对象这五种对象中的一种。  数据结构与对象简单动态字符串Redis自己构建了一种名叫“简单动态字符串”（SDS）的类型，当Redis需要的不仅仅是一个字符串字面量，而是一个可以被修改的字符串值时，使用SDS用作默认字符串表示。如果执行了：12redi">
<meta property="og:locale" content="zn-ch">
<meta property="og:image" content="http://yoursite.com/img/2015-09-13_55f50d7faffa3.png">
<meta property="og:image" content="http://yoursite.com/img/2015-09-13_55f50fb39b6cb.png">
<meta property="og:image" content="http://yoursite.com/img/2015-09-13_55f511fc9428c.png">
<meta property="og:image" content="http://yoursite.com/img/2015-09-13_55f51205335f9.png">
<meta property="og:image" content="http://yoursite.com/img/2015-09-13_55f5120772706.png">
<meta property="og:image" content="http://yoursite.com/img/2015-09-13_55f512c4d7f99.png">
<meta property="og:image" content="http://yoursite.com/img/2015-09-13_55f5130162f2d.png">
<meta property="og:image" content="http://yoursite.com/img/2015-09-13_55f51302b6785.png">
<meta property="og:image" content="http://yoursite.com/img/2015-09-13_55f51309b4775.png">
<meta property="og:image" content="http://yoursite.com/img/2015-09-13_55f5130b2ec57.png">
<meta property="og:image" content="http://yoursite.com/img/2015-09-13_55f51478611a6.png">
<meta property="og:image" content="http://yoursite.com/img/2015-09-13_55f5147ae9c00.png">
<meta property="og:image" content="http://yoursite.com/img/2015-09-13_55f5147c824b8.png">
<meta property="og:image" content="http://yoursite.com/img/202003150001.png">
<meta property="og:image" content="http://yoursite.com/img/202003150002.png">
<meta property="og:image" content="http://yoursite.com/img/1501656384153255.png">
<meta property="og:image" content="http://yoursite.com/img/2015-09-13_55f51ab6dbe72.png">
<meta property="og:image" content="http://yoursite.com/img/2015-09-13_55f51abfde71b.png">
<meta property="og:image" content="http://yoursite.com/img/2015-09-13_55f51ac25b6a0.png">
<meta property="og:image" content="http://yoursite.com/img/2015-09-13_55f51ac353bfa.png">
<meta property="og:image" content="http://yoursite.com/img/2015-09-13_55f51ac466154.png">
<meta property="og:image" content="http://yoursite.com/img/2015-09-13_55f51acae92db.png">
<meta property="og:image" content="http://yoursite.com/img/2015-09-13_55f51bfccbd83.png">
<meta property="og:image" content="http://yoursite.com/img/2015-09-13_55f51bfe2547f.png">
<meta property="og:image" content="http://yoursite.com/img/2015-09-13_55f51fdd42122.png">
<meta property="og:image" content="http://yoursite.com/img/2015-09-13_55f51fde60a02.png">
<meta property="og:image" content="http://yoursite.com/img/20200315234000.jpg">
<meta property="og:image" content="http://yoursite.com/img/20200315235000.jpg">
<meta property="og:image" content="http://yoursite.com/img/2015-09-13_55f52031e8254.png">
<meta property="og:image" content="http://yoursite.com/img/2015-09-13_55f5206caed9d.png">
<meta property="og:image" content="http://yoursite.com/img/2015-09-13_55f5206eae7b1.png">
<meta property="og:image" content="http://yoursite.com/img/20200315235600.jpg">
<meta property="og:image" content="http://yoursite.com/img/2015-09-13_55f520a869916.png">
<meta property="og:image" content="http://yoursite.com/img/2015-09-13_55f5219baa7cc.png">
<meta property="og:image" content="http://yoursite.com/img/2015-09-13_55f5219db9ef5.png">
<meta property="og:updated_time" content="2020-03-17T10:55:23.094Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="redis设计与实现笔记1——数据结构与对象">
<meta name="twitter:description" content="Redis数据库中的每个键值对都是由对象组成的：  数据库键总是一个字符串对象； 数据库键的值可以是字符串对象、列表对象、哈希对象、集合对象、有序集合对象这五种对象中的一种。  数据结构与对象简单动态字符串Redis自己构建了一种名叫“简单动态字符串”（SDS）的类型，当Redis需要的不仅仅是一个字符串字面量，而是一个可以被修改的字符串值时，使用SDS用作默认字符串表示。如果执行了：12redi">
<meta name="twitter:image" content="http://yoursite.com/img/2015-09-13_55f50d7faffa3.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/03/14/redis设计与实现1/">





  <title>redis设计与实现笔记1——数据结构与对象 | Hao Yu's blog</title>
  








 
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zn-ch">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hao Yu's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">The program monkey was eaten by the siege lion.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/resume.pdf" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-mybetterhalf">
          <a href="/mybetterhalf/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>
            
            mybetterhalf
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/14/redis设计与实现1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">redis设计与实现笔记1——数据结构与对象</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-03-14T16:39:00+08:00">
                2020-03-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>Redis数据库中的每个键值对都是由对象组成的：</p>
<ul>
<li>数据库键总是一个字符串对象；</li>
<li>数据库键的值可以是字符串对象、列表对象、哈希对象、集合对象、有序集合对象这五种对象中的一种。</li>
</ul>
<h1 id="数据结构与对象"><a href="#数据结构与对象" class="headerlink" title="数据结构与对象"></a>数据结构与对象</h1><h2 id="简单动态字符串"><a href="#简单动态字符串" class="headerlink" title="简单动态字符串"></a>简单动态字符串</h2><p>Redis自己构建了一种名叫“简单动态字符串”（SDS）的类型，当Redis需要的不仅仅是一个字符串字面量，而是一个可以被修改的字符串值时，使用SDS用作默认字符串表示。如果执行了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET msg &quot;hello world&quot; </span><br><span class="line">OK</span><br></pre></td></tr></table></figure></p>
<p>那么Redis将在数据库中建立一个新的键值对，其中：</p>
<ul>
<li>键值对的键是一个字符串对象，对象底层实现是一个保存着字符串的SDS</li>
<li>键值对的值也是一个字符串对象，对象的底层实现也是一个保存着字符串的SDS</li>
</ul>
<h3 id="sds的定义"><a href="#sds的定义" class="headerlink" title="sds的定义"></a>sds的定义</h3><p>每个 sds.h/sdshdr 结构表示一个 SDS 值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct sdshdr &#123;</span><br><span class="line">    // 记录 buf 数组中已使用字节的数量</span><br><span class="line">    // 等于 SDS 所保存字符串的长度</span><br><span class="line">    int len;</span><br><span class="line"></span><br><span class="line">    // 记录 buf 数组中未使用字节的数量</span><br><span class="line">    int free;</span><br><span class="line"></span><br><span class="line">    // 字节数组，用于保存字符串</span><br><span class="line">    char buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/2015-09-13_55f50d7faffa3.png" alt></p>
<p>free属性的值为0，表示这个SDS没有分配任何未使用空间。<br>len属性的值为5，表示这个SDS保存了一个五字节长的字符串。<br>buf属性是一个char类型的数组，数组的前五个字节分别保存了’R’、’e’、’d’、’i’、’s’五个字符，而最后一个字节则保存了空字符’\0’。</p>
<p>SDS遵循C字符串以空字符结尾的惯例，保存空字符的1字节空间不计算在SDS的len属性里面，并且为空字符分配额外的1字节空间，以及添加空字符到字符串末尾等操作都是由SDS函数自动完成的，所以这个空字符对于SDS的使用者来说是完全透明的。</p>
<h3 id="SDS与C字符串的区别"><a href="#SDS与C字符串的区别" class="headerlink" title="SDS与C字符串的区别"></a>SDS与C字符串的区别</h3><p>C语言使用长度为N+1的字符数组来表示长度为N的字符串，并且字符数组的最后一个元素总是空字符’\0’。C语言使用的这种简单的字符串表示方式，并不能满足Redis对字符串在安全性、效率、以及功能方面的要求。</p>
<p>Redis中使用SDS的优势：</p>
<ul>
<li><strong>常数复杂度获取字符串长度</strong>：因为C字符串并不记录自身的长度信息，所以为了获取一个C字符串的长度，程序必须遍历整个字符串，这个操作的复杂度为O(N)。因为SDS在len属性中记录了SDS本身的长度，所以获取一个SDS长度的复杂度仅为O(1)。设置和更新SDS长度的工作是由SDS的API在执行时自动完成的，使用SDS无须进行任何手动修改长度的工作。</li>
<li><strong>杜绝缓冲区溢出</strong>：<code>strcat</code>函数执行字符串拼接时假定用户在执行这个函数时，已经为dest分配了足够多的内存，可以容纳src字符串中的所有内容，而一旦这个假定不成立时，就会产生缓冲区溢出。与C字符串不同，SDS的空间分配策略完全杜绝了发生缓冲区溢出的可能性：当SDSAPI需要对SDS进行修改时，API会先检查SDS的空间是否满足修改所需的要求，如果不满足的话，API会自动将SDS的空间扩展至执行修改所需的大小，然后才执行实际的修改操作，所以使用SDS既不需要手动修改SDS的空间大小，也不会出现前面所说的缓冲区溢出问题。</li>
<li><strong>减少内存分配次数</strong>，因为C字符串的长度和底层数组的长度之间存在着这种关联性，所以每次增长或者缩短一个C字符串，程序都总要对保存这个C字符串的数组进行一次内存重分配操作：<ul>
<li>如果程序执行的是增长字符串的操作，那么在执行这个操作之前，程序需要先通过内存重分配来扩展底层数组的空间大小——如果忘了这一步就会产生缓冲区溢出。</li>
<li>如果程序执行的是缩短字符串的操作，那么在执行这个操作之后，程序需要通过内存重分配来释放字符串不再使用的那部分空间——如果忘了这一步就会产生内存泄漏。</li>
<li>为了避免C字符串的这种缺陷，<strong>SDS通过未使用空间解除了字符串长度和底层数组长度之间的关联</strong>：在SDS中，buf数组的长度不一定就是字符数量加一，数组里面可以包含未使用的字节，而这些字节的数量就由SDS的free属性记录。通过未使用空间，SDS实现了空间预分配和惰性空间释放两种优化策略。</li>
<li><strong>空间预分配</strong>：空间预分配用于<strong>优化SDS的字符串增长操作</strong>：当SDS的API对一个SDS进行修改，并且需要对SDS进行空间扩展的时候，程序不仅会为SDS分配修改所必须要的空间，还会为SDS分配额外的未使用空间。其中，额外分配的未使用空间数量由以下公式决定：<ul>
<li>如果对SDS进行修改之后，SDS的长度（也即是len属性的值）将小于1MB，那么程序分配和len属性同样大小的未使用空间，这时SDSlen属性的值将和free属性的值相同。</li>
<li>如果对SDS进行修改之后，SDS的长度将大于等于1MB，那么程序会分配1MB的未使用空间。举个例子，如果进行修改之后，SDS的len将变成30MB，那么程序会分配1MB的未使用空间，SDS的buf数组的实际长度将为30MB+1MB+1byte。</li>
</ul>
</li>
<li><strong>惰性空间释放</strong>：惰性空间释放用于<strong>优化SDS的字符串缩短操作</strong>：当SDS的API需要缩短SDS保存的字符串时，程序并不立即使用内存重分配来回收缩短后多出来的字节，而是使用free属性将这些字节的数量记录起来，并等待将来使用。通过惰性空间释放策略，SDS避免了缩短字符串时所需的内存重分配操作，并为将来可能有的增长操作提供了优化。</li>
</ul>
</li>
<li><strong>二进制安全</strong>：虽然数据库一般用于保存文本数据，但使用数据库来保存二进制数据的场景也不少见，因此，为了确保Redis可以适用于各种不同的使用场景，SDS的API都是二进制安全的（binary-safe）：<strong>所有SDS API都会以处理二进制的方式来处理SDS存放在buf数组里的数据</strong>，程序不会对其中的数据做任何限制、过滤、或者假设。</li>
<li><strong>兼容部分C字符串函数</strong>：虽然SDS的API都是二进制安全的，但它们一样遵循C字符串以空字符结尾的惯例：这些API总会将SDS保存的数据的末尾设置为空字符，并且总会在为buf数组分配空间时多分配一个字节来容纳这个空字符，这是为了让那些保存文本数据的SDS可以重用一部分<code>&lt;string.h&gt;</code>库定义的函数。</li>
</ul>
<h3 id="SDS-API"><a href="#SDS-API" class="headerlink" title="SDS API"></a>SDS API</h3><div class="table-container">
<table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>sdsnew</td>
<td>创建一个包含给定 C 字符串的 SDS 。</td>
<td>O(N) ， N 为给定 C 字符串的长度。</td>
</tr>
<tr>
<td>sdsempty</td>
<td>创建一个不包含任何内容的空 SDS 。</td>
<td>O(1)</td>
</tr>
<tr>
<td>sdsfree</td>
<td>释放给定的 SDS 。</td>
<td>O(1)</td>
</tr>
<tr>
<td>sdslen</td>
<td>返回 SDS 的已使用空间字节数。</td>
<td>这个值可以通过读取 SDS 的 len 属性来直接获得， 复杂度为 O(1) 。</td>
</tr>
<tr>
<td>sdsavail</td>
<td>返回 SDS 的未使用空间字节数。</td>
<td>这个值可以通过读取 SDS 的 free 属性来直接获得， 复杂度为 O(1) 。</td>
</tr>
<tr>
<td>sdsdup</td>
<td>创建一个给定 SDS 的副本（copy）。</td>
<td>O(N) ， N 为给定 SDS 的长度。</td>
</tr>
<tr>
<td>sdsclear</td>
<td>清空 SDS 保存的字符串内容。</td>
<td>因为惰性空间释放策略，复杂度为 O(1) 。</td>
</tr>
<tr>
<td>sdscat</td>
<td>将给定 C 字符串拼接到 SDS 字符串的末尾。</td>
<td>O(N) ， N 为被拼接 C 字符串的长度。</td>
</tr>
<tr>
<td>sdscatsds</td>
<td>将给定 SDS 字符串拼接到另一个 SDS 字符串的末尾。</td>
<td>O(N) ， N 为被拼接 SDS 字符串的长度。</td>
</tr>
<tr>
<td>sdscpy</td>
<td>将给定的 C 字符串复制到 SDS 里面， 覆盖 SDS 原有的字符串。</td>
<td>O(N) ， N 为被复制 C 字符串的长度。</td>
</tr>
<tr>
<td>sdsgrowzero</td>
<td>用空字符将 SDS 扩展至给定长度。</td>
<td>O(N) ， N 为扩展新增的字节数。</td>
</tr>
<tr>
<td>sdsrange</td>
<td>保留 SDS 给定区间内的数据， 不在区间内的数据会被覆盖或清除。</td>
<td>O(N) ， N 为被保留数据的字节数。</td>
</tr>
<tr>
<td>sdstrim</td>
<td>接受一个 SDS 和一个 C 字符串作为参数， 从 SDS 左右两端分别移除所有在 C 字符串中出现过的字符。</td>
<td>O(M*N) ， M 为 SDS 的长度， N 为给定C字符串的长度。</td>
</tr>
<tr>
<td>sdscmp</td>
<td>对比两个 SDS 字符串是否相同。</td>
<td>O(N) ， N 为两个 SDS 中较短的那个 SDS 的长度。</td>
</tr>
</tbody>
</table>
</div>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>链表提供了高效的节点重排能力， 以及顺序性的节点访问方式， 并且可以通过增删节点来灵活地调整链表的长度。<br>每个链表节点使用一个 adlist.h/listNode 结构来表示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typedef struct listNode &#123;</span><br><span class="line">    // 前置节点</span><br><span class="line">    struct listNode *prev;</span><br><span class="line"></span><br><span class="line">    // 后置节点</span><br><span class="line">    struct listNode *next;</span><br><span class="line"></span><br><span class="line">    // 节点的值</span><br><span class="line">    void *value;</span><br><span class="line">&#125; listNode;</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/2015-09-13_55f50fb39b6cb.png" alt><br>多个 listNode 可以通过 prev 和 next 指针组成双端链表。虽然仅仅使用多个 listNode 结构就可以组成链表， 但使用 adlist.h/list 来持有链表的话， 操作起来会更方便：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">typedef struct list &#123;</span><br><span class="line">    // 表头节点</span><br><span class="line">    listNode *head;</span><br><span class="line"></span><br><span class="line">    // 表尾节点</span><br><span class="line">    listNode *tail;</span><br><span class="line"></span><br><span class="line">    // 链表所包含的节点数量</span><br><span class="line">    unsigned long len;</span><br><span class="line"></span><br><span class="line">    // 节点值复制函数</span><br><span class="line">    void *(*dup)(void *ptr);</span><br><span class="line"></span><br><span class="line">    // 节点值释放函数</span><br><span class="line">    void (*free)(void *ptr);</span><br><span class="line"></span><br><span class="line">    // 节点值对比函数</span><br><span class="line">    int (*match)(void *ptr, void *key);</span><br><span class="line">&#125; list;</span><br></pre></td></tr></table></figure></p>
<p>list结构为链表提供了表头指针head、表尾指针tail，以及链表长度计数器len，而dup、free和match成员则是用于实现多态链表所需的类型特定函数：</p>
<ul>
<li>dup函数用于复制链表节点所保存的值；</li>
<li>free函数用于释放链表节点所保存的值；</li>
<li>match函数则用于对比链表节点所保存的值和另一个输入值是否相等。</li>
</ul>
<p>Redis的链表实现的特性可以总结如下：</p>
<ul>
<li>双端：链表节点带有prev和next指针，获取某个节点的前置节点和后置节点的复杂度都是O(1)。</li>
<li>无环：表头节点的prev指针和表尾节点的next指针都指向NULL，对链表的访问以NULL为终点。</li>
<li>带表头指针和表尾指针：通过list结构的head指针和tail指针，程序获取链表的表头节点和表尾节点的复杂度为O(1)。</li>
<li>带链表长度计数器：程序使用list结构的len属性来对list持有的链表节点进行计数，程序获取链表中节点数量的复杂度为O(1)。</li>
<li>多态：链表节点使用void*指针来保存节点值，并且可以通过list结构的dup、free、match三个属性为节点值设置类型特定-函数，所以链表可以用于保存各种不同类型的值。</li>
</ul>
<h3 id="Redis-链表和链表节点的-API"><a href="#Redis-链表和链表节点的-API" class="headerlink" title="Redis 链表和链表节点的 API"></a>Redis 链表和链表节点的 API</h3><div class="table-container">
<table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>listSetDupMethod</td>
<td>将给定的函数设置为链表的节点值复制函数。</td>
<td>O(1) 。</td>
</tr>
<tr>
<td>listGetDupMethod</td>
<td>返回链表当前正在使用的节点值复制函数。</td>
<td>复制函数可以通过链表的 dup 属性直接获得， O(1)</td>
</tr>
<tr>
<td>listSetFreeMethod</td>
<td>将给定的函数设置为链表的节点值释放函数。</td>
<td>O(1) 。</td>
</tr>
<tr>
<td>listGetFree</td>
<td>返回链表当前正在使用的节点值释放函数。</td>
<td>释放函数可以通过链表的 free 属性直接获得， O(1)</td>
</tr>
<tr>
<td>listSetMatchMethod</td>
<td>将给定的函数设置为链表的节点值对比函数。</td>
<td>O(1)</td>
</tr>
<tr>
<td>listGetMatchMethod</td>
<td>返回链表当前正在使用的节点值对比函数。</td>
<td>对比函数可以通过链表的 match 属性直接获得，O(1)</td>
</tr>
<tr>
<td>listLength</td>
<td>返回链表的长度（包含了多少个节点）。</td>
<td>链表长度可以通过链表的 len 属性直接获得， O(1) 。</td>
</tr>
<tr>
<td>listFirst</td>
<td>返回链表的表头节点。</td>
<td>表头节点可以通过链表的 head 属性直接获得， O(1) 。</td>
</tr>
<tr>
<td>listLast</td>
<td>返回链表的表尾节点。</td>
<td>表尾节点可以通过链表的 tail 属性直接获得， O(1) 。</td>
</tr>
<tr>
<td>listPrevNode</td>
<td>返回给定节点的前置节点。</td>
<td>前置节点可以通过节点的 prev 属性直接获得， O(1) 。</td>
</tr>
<tr>
<td>listNextNode</td>
<td>返回给定节点的后置节点。</td>
<td>后置节点可以通过节点的 next 属性直接获得， O(1) 。</td>
</tr>
<tr>
<td>listNodeValue</td>
<td>返回给定节点目前正在保存的值。</td>
<td>节点值可以通过节点的 value 属性直接获得， O(1) 。</td>
</tr>
<tr>
<td>listCreate</td>
<td>创建一个不包含任何节点的新链表。</td>
<td>O(1)</td>
</tr>
<tr>
<td>listAddNodeHead</td>
<td>将一个包含给定值的新节点添加到给定链表的表头。</td>
<td>O(1)</td>
</tr>
<tr>
<td>listAddNodeTail</td>
<td>将一个包含给定值的新节点添加到给定链表的表尾。</td>
<td>O(1)</td>
</tr>
<tr>
<td>listInsertNode</td>
<td>将一个包含给定值的新节点添加到给定节点的之前或者之后。</td>
<td>O(1)</td>
</tr>
<tr>
<td>listSearchKey</td>
<td>查找并返回链表中包含给定值的节点。</td>
<td>O(N) ， N 为链表长度。</td>
</tr>
<tr>
<td>listIndex</td>
<td>返回链表在给定索引上的节点。</td>
<td>O(N) ， N 为链表长度。</td>
</tr>
<tr>
<td>listDelNode</td>
<td>从链表中删除给定节点。</td>
<td>O(1) 。</td>
</tr>
<tr>
<td>listRotate</td>
<td>将链表的表尾节点弹出，然后将被弹出的节点插入到链表的表头， 成为新的表头节点。</td>
<td>O(1)</td>
</tr>
<tr>
<td>listDup</td>
<td>复制一个给定链表的副本。</td>
<td>O(N) ， N 为链表长度。</td>
</tr>
<tr>
<td>listRelease</td>
<td>释放给定链表，以及链表中的所有节点。</td>
<td>O(N) ， N 为链表长度。</td>
</tr>
</tbody>
</table>
</div>
<h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>字典， 又称符号表（symbol table）、关联数组（associative array）或者映射（map）， 是一种用于<strong>保存键值对</strong>（key-value pair）的抽象数据结构。</p>
<p>在字典中， 一个键（key）可以和一个值（value）进行关联（或者说将键映射为值）， 这些关联的键和值就被称为键值对。</p>
<p>字典中的每个键都是独一无二的， 程序可以在字典中根据键查找与之关联的值， 或者通过键来更新值， 又或者根据键来删除整个键值对， 等等。</p>
<p>字典经常作为一种数据结构内置在很多高级编程语言里面， 但 Redis 所使用的 C 语言并没有内置这种数据结构， 因此 Redis 构建了自己的字典实现。</p>
<p>字典在 Redis 中的应用相当广泛， 比如 Redis 的数据库就是使用字典来作为底层实现的， 对数据库的增、删、查、改操作也是构建在对字典的操作之上的。</p>
<h3 id="Redis-字典的实现"><a href="#Redis-字典的实现" class="headerlink" title="Redis 字典的实现"></a>Redis 字典的实现</h3><p>Redis 的字典使用哈希表作为底层实现， 一个哈希表里面可以有多个哈希表节点， 而每个哈希表节点就保存了字典中的一个键值对。</p>
<h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><p>Redis 字典所使用的哈希表由 dict.h/dictht 结构定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">typedef struct dictht &#123;</span><br><span class="line">    // 哈希表数组</span><br><span class="line">    dictEntry **table;</span><br><span class="line"></span><br><span class="line">    // 哈希表大小</span><br><span class="line">    unsigned long size;</span><br><span class="line"></span><br><span class="line">    // 哈希表大小掩码，用于计算索引值</span><br><span class="line">    // 总是等于 size - 1</span><br><span class="line">    unsigned long sizemask;</span><br><span class="line"></span><br><span class="line">    // 该哈希表已有节点的数量</span><br><span class="line">    unsigned long used;</span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure></p>
<p>解释如下：</p>
<ul>
<li>table 属性是一个数组， 数组中的每个元素都是一个指向 dict.h/dictEntry 结构的指针， 每个 dictEntry 结构保存着一个键值对。</li>
<li>size 属性记录了哈希表的大小， 也即是 table 数组的大小， 而 used 属性则记录了哈希表目前已有节点（键值对）的数量。</li>
<li>sizemask 属性的值总是等于 size - 1 ， 这个属性和哈希值一起决定一个键应该被放到 table 数组的哪个索引上面。</li>
</ul>
<p><img src="/img/2015-09-13_55f511fc9428c.png" alt></p>
<h4 id="哈希表节点"><a href="#哈希表节点" class="headerlink" title="哈希表节点"></a>哈希表节点</h4><p>哈希表节点使用 dictEntry 结构表示， 每个 dictEntry 结构都保存着一个键值对：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">typedef struct dictEntry &#123;</span><br><span class="line">    // 键</span><br><span class="line">    void *key;</span><br><span class="line"></span><br><span class="line">    // 值</span><br><span class="line">    union &#123;</span><br><span class="line">        void *val;</span><br><span class="line">        uint64_t u64;</span><br><span class="line">        int64_t s64;</span><br><span class="line">    &#125; v;</span><br><span class="line"></span><br><span class="line">    // 指向下个哈希表节点，形成链表</span><br><span class="line">    struct dictEntry *next;</span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure></p>
<p>解释：</p>
<ul>
<li>key 属性保存着键值对中的键， 而 v 属性则保存着键值对中的值， 其中键值对的值可以是一个指针， 或者是一个 uint64_t 整数， 又或者是一个 int64_t 整数。</li>
<li>next 属性是指向另一个哈希表节点的指针， 这个指针可以将多个哈希值相同的键值对连接在一次， 以此来解决键冲突（collision）的问题。</li>
</ul>
<p><img src="/img/2015-09-13_55f51205335f9.png" alt></p>
<h4 id="字典-1"><a href="#字典-1" class="headerlink" title="字典"></a>字典</h4><p>Redis 中的字典由 dict.h/dict 结构表示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">typedef struct dict &#123;</span><br><span class="line">    // 类型特定函数</span><br><span class="line">    dictType *type;</span><br><span class="line"></span><br><span class="line">    // 私有数据</span><br><span class="line">    void *privdata;</span><br><span class="line"></span><br><span class="line">    // 哈希表</span><br><span class="line">    dictht ht[2];</span><br><span class="line"></span><br><span class="line">    // rehash 索引</span><br><span class="line">    // 当 rehash 不在进行时，值为 -1</span><br><span class="line">    int rehashidx; /* rehashing not in progress if rehashidx == -1 */</span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure></p>
<p>type 属性和 privdata 属性是针对不同类型的键值对， 为创建多态字典而设置的：</p>
<ul>
<li>type 属性是一个指向 dictType 结构的指针， 每个 dictType 结构保存了一簇用于操作特定类型键值对的函数， Redis 会为用途不同的字典设置不同的类型特定函数。</li>
<li>privdata 属性则保存了需要传给那些类型特定函数的可选参数。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">typedef struct dictType &#123;</span><br><span class="line">    // 计算哈希值的函数</span><br><span class="line">    unsigned int (*hashFunction)(const void *key);</span><br><span class="line"></span><br><span class="line">    // 复制键的函数</span><br><span class="line">    void *(*keyDup)(void *privdata, const void *key);</span><br><span class="line"></span><br><span class="line">    // 复制值的函数</span><br><span class="line">    void *(*valDup)(void *privdata, const void *obj);</span><br><span class="line"></span><br><span class="line">    // 对比键的函数</span><br><span class="line">    int (*keyCompare)(void *privdata, const void *key1, const void *key2);</span><br><span class="line"></span><br><span class="line">    // 销毁键的函数</span><br><span class="line">    void (*keyDestructor)(void *privdata, void *key);</span><br><span class="line"></span><br><span class="line">    // 销毁值的函数</span><br><span class="line">    void (*valDestructor)(void *privdata, void *obj);</span><br><span class="line">&#125; dictType;</span><br></pre></td></tr></table></figure>
<p>解释：</p>
<ul>
<li>ht 属性是一个包含两个项的数组， 数组中的每个项都是一个 dictht 哈希表， 一般情况下， 字典只使用 ht[0] 哈希表， ht[1] 哈希表只会在对 ht[0] 哈希表进行 rehash 时使用。</li>
<li>另一个和 rehash 有关的属性就是 rehashidx ： 它记录了 rehash 目前的进度， 如果目前没有在进行 rehash ， 那么它的值为 -1 。</li>
</ul>
<p><img src="/img/2015-09-13_55f5120772706.png" alt></p>
<h3 id="Redis-哈希算法"><a href="#Redis-哈希算法" class="headerlink" title="Redis 哈希算法"></a>Redis 哈希算法</h3><p>当要将一个新的键值对添加到字典里面时， 程序需要先根据键值对的键计算出哈希值和索引值， 然后再根据索引值， 将包含新键值对的哈希表节点放到哈希表数组的指定索引上面。</p>
<p>Redis 计算哈希值和索引值的方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 使用字典设置的哈希函数，计算键 key 的哈希值</span><br><span class="line">hash = dict-&gt;type-&gt;hashFunction(key);</span><br><span class="line"></span><br><span class="line"># 使用哈希表的 sizemask 属性和哈希值，计算出索引值</span><br><span class="line"># 根据情况不同， ht[x] 可以是 ht[0] 或者 ht[1]</span><br><span class="line">index = hash &amp; dict-&gt;ht[x].sizemask;</span><br></pre></td></tr></table></figure></p>
<p>如果我们要将一个键值对 k0 和 v0 添加到字典里面， 那么程序会先使用语句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash = dict-&gt;type-&gt;hashFunction(k0);</span><br></pre></td></tr></table></figure></p>
<p>计算键 k0 的哈希值。假设计算得出的哈希值为 8 ， 那么程序会继续使用语句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index = hash &amp; dict-&gt;ht[0].sizemask = 8 &amp; 3 = 0;</span><br></pre></td></tr></table></figure></p>
<p>计算出键 k0 的索引值 0 ， 这表示包含键值对 k0 和 v0 的节点应该被放置到哈希表数组的索引 0 位置上</p>
<h3 id="Redis-解决键冲突"><a href="#Redis-解决键冲突" class="headerlink" title="Redis 解决键冲突"></a>Redis 解决键冲突</h3><p>当有两个或以上数量的键被分配到了哈希表数组的同一个索引上面时， 我们称这些键发生了冲突（collision）。</p>
<p>Redis 的哈希表使用链地址法（separate chaining）来解决键冲突： 每个哈希表节点都有一个 next 指针， 多个哈希表节点可以用 next 指针构成一个单向链表， 被分配到同一个索引上的多个节点可以用这个单向链表连接起来， 这就解决了键冲突的问题。</p>
<p>举个例子， 假设程序要将键值对 k2 和 v2 添加到图 4-6 所示的哈希表里面， 并且计算得出 k2 的索引值为 2 ， 那么键 k1 和 k2 将产生冲突， 而解决冲突的办法就是使用 next 指针将键 k2 和 k1 所在的节点连接起来。</p>
<p><img src="/img/2015-09-13_55f512c4d7f99.png" alt></p>
<h3 id="Redis-rehash"><a href="#Redis-rehash" class="headerlink" title="Redis rehash"></a>Redis rehash</h3><p>为了让哈希表的负载因子（load factor）维持在一个合理的范围之内， 当哈希表保存的键值对数量太多或者太少时， 程序需要对哈希表的大小进行相应的扩展或者收缩。</p>
<p>扩展和收缩哈希表的工作可以通过执行 rehash （重新散列）操作来完成， Redis 对字典的哈希表执行 rehash 的步骤如下：</p>
<ul>
<li>为字典的 ht[1] 哈希表分配空间， 这个哈希表的空间大小取决于要执行的操作， 以及 ht[0] 当前包含的键值对数量 （也即是ht[0].used 属性的值）：<ul>
<li>如果执行的是扩展操作， 那么 ht[1] 的大小为第一个大于等于 ht[0].used * 2 的 2^n （2 的 n 次方幂）；</li>
<li>如果执行的是收缩操作， 那么 ht[1] 的大小为第一个大于等于 ht[0].used 的 2^n 。</li>
</ul>
</li>
<li>将保存在 ht[0] 中的所有键值对 rehash 到 ht[1] 上面： rehash 指的是重新计算键的哈希值和索引值， 然后将键值对放置到 ht[1] 哈希表的指定位置上。</li>
<li>当 ht[0] 包含的所有键值对都迁移到了 ht[1] 之后 （ht[0] 变为空表）， 释放 ht[0] ， 将 ht[1] 设置为 ht[0] ， 并在 ht[1] 新创建一个空白哈希表， 为下一次 rehash 做准备。</li>
</ul>
<p>举个例子， 假设程序要对图 4-8 所示字典的 ht[0] 进行扩展操作， 那么程序将执行以下步骤：</p>
<ul>
<li>ht[0].used 当前的值为 4 ， 4 * 2 = 8 ， 而 8 （2^3）恰好是第一个大于等于 4 的 2 的 n 次方， 所以程序会将 ht[1] 哈希表的大小设置为 8 。 图 4-9 展示了 ht[1] 在分配空间之后， 字典的样子。</li>
<li>将 ht[0] 包含的四个键值对都 rehash 到 ht[1] ， 如图 4-10 所示。</li>
<li>释放 ht[0] ，并将 ht[1] 设置为 ht[0] ，然后为 ht[1] 分配一个空白哈希表，如图 4-11 所示。</li>
<li>至此， 对哈希表的扩展操作执行完毕， 程序成功将哈希表的大小从原来的 4 改为了现在的 8 。</li>
</ul>
<p><img src="/img/2015-09-13_55f5130162f2d.png" alt><br><img src="/img/2015-09-13_55f51302b6785.png" alt><br><img src="/img/2015-09-13_55f51309b4775.png" alt><br><img src="/img/2015-09-13_55f5130b2ec57.png" alt></p>
<p>当以下条件中的任意一个被满足时， 程序会自动开始对哈希表执行扩展操作：</p>
<p>服务器目前没有在执行 BGSAVE 命令或者 BGREWRITEAOF 命令， 并且哈希表的负载因子大于等于 1 ；<br>服务器目前正在执行 BGSAVE 命令或者 BGREWRITEAOF 命令， 并且哈希表的负载因子大于等于 5 ；<br>其中哈希表的负载因子可以通过公式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 负载因子 = 哈希表已保存节点数量 / 哈希表大小</span><br><span class="line">load_factor = ht[0].used / ht[0].size</span><br></pre></td></tr></table></figure></p>
<p>根据 BGSAVE 命令或 BGREWRITEAOF 命令是否正在执行， 服务器执行扩展操作所需的负载因子并不相同， 这是因为在执行 BGSAVE 命令或BGREWRITEAOF 命令的过程中， Redis 需要创建当前服务器进程的子进程， 而大多数操作系统都采用写时复制（copy-on-write）技术来优化子进程的使用效率， 所以在子进程存在期间， 服务器会提高执行扩展操作所需的负载因子， 从而尽可能地避免在子进程存在期间进行哈希表扩展操作， 这可以避免不必要的内存写入操作， 最大限度地节约内存。</p>
<h3 id="Redis-渐进式-rehash"><a href="#Redis-渐进式-rehash" class="headerlink" title="Redis 渐进式 rehash"></a>Redis 渐进式 rehash</h3><p>扩展或收缩哈希表需要将 ht[0] 里面的所有键值对 rehash 到 ht[1] 里面， 但是， 这个 rehash 动作并不是一次性、集中式地完成的， 而是分多次、渐进式地完成的。这样避免了 rehash 对服务器性能造成影响。服务器不是一次性将 ht[0] 里面的所有键值对全部 rehash 到 ht[1] ， 而是分多次、渐进式地将 ht[0] 里面的键值对慢慢地 rehash 到 ht[1] 。</p>
<p>以下是哈希表渐进式 rehash 的详细步骤：</p>
<ul>
<li>为 ht[1] 分配空间， 让字典同时持有 ht[0] 和 ht[1] 两个哈希表。</li>
<li>在字典中维持一个索引计数器变量 rehashidx ， 并将它的值设置为 0 ， 表示 rehash 工作正式开始。</li>
<li>在 rehash 进行期间， 每次对字典执行添加、删除、查找或者更新操作时， 程序除了执行指定的操作以外， 还会顺带将 ht[0] 哈希表在 rehashidx 索引上的所有键值对 rehash 到 ht[1] ， 当 rehash 工作完成之后， 程序将 rehashidx 属性的值增一。</li>
<li>随着字典操作的不断执行， 最终在某个时间点上， ht[0] 的所有键值对都会被 rehash 至 ht[1] ， 这时程序将 rehashidx 属性的值设为 -1 ， 表示 rehash 操作已完成。</li>
</ul>
<p>渐进式 rehash 的好处在于它采取分而治之的方式， 将 rehash 键值对所需的计算工作均滩到对字典的每个添加、删除、查找和更新操作上， 从而避免了集中式 rehash 而带来的庞大计算量。</p>
<p>因为在进行渐进式 rehash 的过程中， 字典会同时使用 ht[0] 和 ht[1] 两个哈希表， 所以在渐进式 rehash 进行期间， 字典的删除（delete）、查找（find）、更新（update）等操作会在两个哈希表上进行： 比如说， 要在字典里面查找一个键的话， 程序会先在 ht[0] 里面进行查找， 如果没找到的话， 就会继续到 ht[1] 里面进行查找， 诸如此类。</p>
<p>另外， 在渐进式 rehash 执行期间， 新添加到字典的键值对一律会被保存到 ht[1] 里面， 而 ht[0] 则不再进行任何添加操作： 这一措施保证了 ht[0] 包含的键值对数量会只减不增， 并随着 rehash 操作的执行而最终变成空表。</p>
<h3 id="Redis-字典-API"><a href="#Redis-字典-API" class="headerlink" title="Redis 字典 API"></a>Redis 字典 API</h3><div class="table-container">
<table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>dictCreate</td>
<td>创建一个新的字典。</td>
<td>O(1)</td>
</tr>
<tr>
<td>dictAdd</td>
<td>将给定的键值对添加到字典里面。</td>
<td>O(1)</td>
</tr>
<tr>
<td>dictReplace</td>
<td>将给定的键值对添加到字典里面， 如果键已经存在于字典，那么用新值取代原有的值。</td>
<td>O(1)</td>
</tr>
<tr>
<td>dictFetchValue</td>
<td>返回给定键的值。</td>
<td>O(1)</td>
</tr>
<tr>
<td>dictGetRandomKey</td>
<td>从字典中随机返回一个键值对。</td>
<td>O(1)</td>
</tr>
<tr>
<td>dictDelete</td>
<td>从字典中删除给定键所对应的键值对。</td>
<td>O(1)</td>
</tr>
<tr>
<td>dictRelease</td>
<td>释放给定字典，以及字典中包含的所有键值对。</td>
<td>O(N) ， N 为字典包含的键值对数量。</td>
</tr>
</tbody>
</table>
</div>
<h2 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h2><p>跳跃表（skiplist）是一种有序数据结构， 它通过在每个节点中维持多个指向其他节点的指针， 从而达到快速访问节点的目的。</p>
<p>跳跃表支持平均 O(logN) 最差 O(N) 复杂度的节点查找， 还可以通过顺序性操作来批量处理节点。</p>
<p>在大部分情况下， 跳跃表的效率可以和平衡树相媲美， 并且因为跳跃表的实现比平衡树要来得更为简单， 所以有不少程序都使用跳跃表来代替平衡树。</p>
<p>Redis 使用跳跃表作为有序集合键的底层实现之一： 如果一个有序集合包含的元素数量比较多， 又或者有序集合中元素的成员（member）是比较长的字符串时， Redis 就会使用跳跃表来作为有序集合键的底层实现。</p>
<h3 id="跳跃表的实现"><a href="#跳跃表的实现" class="headerlink" title="跳跃表的实现"></a>跳跃表的实现</h3><p>Redis 的跳跃表由 redis.h/zskiplistNode 和 redis.h/zskiplist 两个结构定义， 其中 zskiplistNode 结构用于表示跳跃表节点， 而 zskiplist结构则用于保存跳跃表节点的相关信息， 比如节点的数量， 以及指向表头节点和表尾节点的指针， 等等。</p>
<p><img src="/img/2015-09-13_55f51478611a6.png" alt></p>
<p>位于图片最左边的是 zskiplist 结构， 该结构包含以下属性：</p>
<ul>
<li>header ：指向跳跃表的表头节点。</li>
<li>tail ：指向跳跃表的表尾节点。</li>
<li>level ：记录目前跳跃表内，层数最大的那个节点的层数（表头节点的层数不计算在内）。</li>
<li>length ：记录跳跃表的长度，也即是，跳跃表目前包含节点的数量（表头节点不计算在内）。</li>
</ul>
<p>位于 zskiplist 结构右方的是四个 zskiplistNode 结构， 该结构包含以下属性：</p>
<ul>
<li>层（level）：节点中用 L1 、 L2 、 L3 等字样标记节点的各个层， L1 代表第一层， L2 代表第二层，以此类推。每个层都带有两个属性：前进指针和跨度。<strong>前进指针用于访问位于表尾方向的其他节点</strong>，而<strong>跨度则记录了前进指针所指向节点和当前节点的距离</strong>。在上面的图片中，连线上带有数字的箭头就代表前进指针，而那个数字就是跨度。当程序从表头向表尾进行遍历时，访问会沿着层的前进指针进行。</li>
<li>后退（backward）指针：节点中用 BW 字样标记节点的后退指针，它指向位于当前节点的前一个节点。后退指针在程序从表尾向表头遍历时使用。</li>
<li>分值（score）：各个节点中的 1.0 、 2.0 和 3.0 是节点所保存的分值。在跳跃表中，节点按各自所保存的分值从小到大排列。</li>
<li>成员对象（obj）：各个节点中的 o1 、 o2 和 o3 是节点所保存的成员对象。</li>
</ul>
<p>注意表头节点和其他节点的构造是一样的： 表头节点也有后退指针、分值和成员对象， 不过表头节点的这些属性都不会被用到， 所以图中省略了这些部分， 只显示了表头节点的各个层。</p>
<p>跳跃表节点的实现由 redis.h/zskiplistNode 结构定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">typedef struct zskiplistNode &#123;</span><br><span class="line">    // 后退指针</span><br><span class="line">    struct zskiplistNode *backward;</span><br><span class="line"></span><br><span class="line">    // 分值</span><br><span class="line">    double score;</span><br><span class="line"></span><br><span class="line">    // 成员对象</span><br><span class="line">    robj *obj;</span><br><span class="line"></span><br><span class="line">    // 层</span><br><span class="line">    struct zskiplistLevel &#123;</span><br><span class="line"></span><br><span class="line">        // 前进指针</span><br><span class="line">        struct zskiplistNode *forward;</span><br><span class="line"></span><br><span class="line">        // 跨度</span><br><span class="line">        unsigned int span;</span><br><span class="line"></span><br><span class="line">    &#125; level[];</span><br><span class="line"></span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure></p>
<p>跳跃表节点的 level 数组可以包含多个元素， 每个元素都包含一个指向其他节点的指针， 程序可以通过这些层来加快访问其他节点的速度， 一般来说， 层的数量越多， 访问其他节点的速度就越快。</p>
<p>每次创建一个新跳跃表节点的时候， 程序都根据幂次定律 （power law，越大的数出现的概率越小） 随机生成一个介于 1 和 32 之间的值作为 level 数组的大小， 这个大小就是层的“高度”。</p>
<p>图 5-2 分别展示了三个高度为 1 层、 3 层和 5 层的节点， 因为 C 语言的数组索引总是从 0 开始的， 所以节点的第一层是 level[0] ， 而第二层是 level[1] ， 以此类推。</p>
<p><img src="/img/2015-09-13_55f5147ae9c00.png" alt></p>
<p>每个层都有一个指向表尾方向的前进指针（level[i].forward 属性）， 用于从表头向表尾方向访问节点。</p>
<p>图 5-3 用虚线表示出了程序从表头向表尾方向， 遍历跳跃表中所有节点的路径：<br><img src="/img/2015-09-13_55f5147c824b8.png" alt></p>
<p>迭代程序首先访问跳跃表的第一个节点（表头）， 然后从第四层的前进指针移动到表中的第二个节点。<br>在第二个节点时， 程序沿着第二层的前进指针移动到表中的第三个节点。<br>在第三个节点时， 程序同样沿着第二层的前进指针移动到表中的第四个节点。<br>当程序再次沿着第四个节点的前进指针移动时， 它碰到一个 NULL ， 程序知道这时已经到达了跳跃表的表尾， 于是结束这次遍历。</p>
<p>层的跨度（level[i].span 属性）用于记录两个节点之间的距离：</p>
<ul>
<li>两个节点之间的跨度越大， 它们相距得就越远。</li>
<li>指向 NULL 的所有前进指针的跨度都为 0 ， 因为它们没有连向任何节点。<br>初看上去， 很容易以为跨度和遍历操作有关， 但实际上并不是这样 —— 遍历操作只使用前进指针就可以完成了， 跨度实际上是用来计算排位（rank）的： 在查找某个节点的过程中， 将沿途访问过的所有层的跨度累计起来， 得到的结果就是目标节点在跳跃表中的排位。</li>
</ul>
<p>举个例子， 图 5-4 用虚线标记了在跳跃表中查找分值为 3.0 、 成员对象为 o3 的节点时， 沿途经历的层： 查找的过程只经过了一个层， 并且层的跨度为 3 ， 所以目标节点在跳跃表中的排位为 3 。</p>
<p>通过一个zskiplist结构来持有节点，可以更方便的进行处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef struct zskiplist &#123;</span><br><span class="line">    // 表头节点和表尾节点</span><br><span class="line">    struct zskiplistNode *header, *tailer;</span><br><span class="line">    // 表中节点的数量</span><br><span class="line">    unsigned long length;</span><br><span class="line">    // 表中层数最大的节点的层数</span><br><span class="line">    ine level;</span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/202003150001.png" alt></p>
<p><img src="/img/202003150002.png" alt></p>
<h3 id="Redis-跳跃表-API"><a href="#Redis-跳跃表-API" class="headerlink" title="Redis 跳跃表 API"></a>Redis 跳跃表 API</h3><div class="table-container">
<table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>zslCreate</td>
<td>创建一个新的跳跃表。</td>
<td>O(1)</td>
</tr>
<tr>
<td>zslFree</td>
<td>释放给定跳跃表，以及表中包含的所有节点。</td>
<td>O(N) ， N 为跳跃表的长度。</td>
</tr>
<tr>
<td>zslInsert</td>
<td>将包含给定成员和分值的新节点添加到跳跃表中。</td>
<td>平均 O(N) ， N 为跳跃表长度。</td>
</tr>
<tr>
<td>zslDelete</td>
<td>删除跳跃表中包含给定成员和分值的节点。</td>
<td>平均 O(N) ， N 为跳跃表长度。</td>
</tr>
<tr>
<td>zslGetRank</td>
<td>返回包含给定成员和分值的节点在跳跃表中的排位。</td>
<td>平均 O(N) ， N 为跳跃表长度。</td>
</tr>
<tr>
<td>zslGetElementByRank</td>
<td>返回跳跃表在给定排位上的节点。</td>
<td>平均 O(N) ， N 为跳跃表长度。</td>
</tr>
<tr>
<td>zslIsInRange</td>
<td>给定一个分值范围（range）， 比如 0 到 15 ， 20 到 28，诸如此类， 如果给定的分值范围包含在跳跃表的分值范围之内， 那么返回 1 ，否则返回 0 。</td>
<td>通过跳跃表的表头节点和表尾节点， 这个检测可以用 O(1) 复杂度完成。</td>
</tr>
<tr>
<td>zslFirstInRange</td>
<td>给定一个分值范围， 返回跳跃表中第一个符合这个范围的节点。</td>
<td>平均 O(N) 。 N 为跳跃表长度。</td>
</tr>
<tr>
<td>zslLastInRange</td>
<td>给定一个分值范围， 返回跳跃表中最后一个符合这个范围的节点。</td>
<td>平均 O(N) 。 N 为跳跃表长度。</td>
</tr>
<tr>
<td>zslDeleteRangeByScore</td>
<td>给定一个分值范围， 删除跳跃表中所有在这个范围之内的节点。</td>
<td>O(N) ， N 为被删除节点数量。</td>
</tr>
<tr>
<td>zslDeleteRangeByRank</td>
<td>给定一个排位范围， 删除跳跃表中所有在这个范围之内的节点。</td>
<td>O(N) ， N 为被删除节点数量。</td>
</tr>
</tbody>
</table>
</div>
<h2 id="整数集合"><a href="#整数集合" class="headerlink" title="整数集合"></a>整数集合</h2><p>整数集合（intset）是集合键的底层实现之一： 当一个集合只包含整数值元素， 并且这个集合的元素数量不多时， Redis 就会使用整数集合作为集合键的底层实现。</p>
<p>举个例子， 如果我们创建一个只包含五个元素的集合键， 并且集合中的所有元素都是整数值， 那么这个集合键的底层实现就会是整数集合：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SADD numbers 1 3 5 7 9</span><br><span class="line">(integer) 5</span><br><span class="line"></span><br><span class="line">redis&gt; OBJECT ENCODING numbers</span><br><span class="line">&quot;intset&quot;</span><br></pre></td></tr></table></figure></p>
<h3 id="Redis-整数集合的实现"><a href="#Redis-整数集合的实现" class="headerlink" title="Redis 整数集合的实现"></a>Redis 整数集合的实现</h3><p>整数集合（intset）是 Redis 用于保存整数值的集合抽象数据结构， 它可以保存类型为 int16_t 、 int32_t 或者 int64_t 的整数值， 并且保证集合中不会出现重复元素。每个 intset.h/intset 结构表示一个整数集合：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typedef struct intset &#123;</span><br><span class="line">    // 编码方式</span><br><span class="line">    uint32_t encoding;</span><br><span class="line"></span><br><span class="line">    // 集合包含的元素数量</span><br><span class="line">    uint32_t length;</span><br><span class="line"></span><br><span class="line">    // 保存元素的数组</span><br><span class="line">    int8_t contents[];</span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure></p>
<p>解释：</p>
<ul>
<li>contents 数组是整数集合的底层实现： 整数集合的每个元素都是 contents 数组的一个数组项（item）， 各个项在数组中按值的大小从小到大有序地排列， 并且数组中不包含任何重复项。</li>
<li>length 属性记录了整数集合包含的元素数量， 也即是 contents 数组的长度。</li>
</ul>
<p>虽然 intset 结构将 contents 属性声明为 int8_t 类型的数组， 但实际上 contents 数组并不保存任何 int8_t 类型的值 —— contents 数组的真正类型取决于 encoding 属性的值：</p>
<ul>
<li>encoding = INTSET_ENC_INT16 ， contents 是 int16_t 类型的数组（最小值为 -32,768 ，最大值为 32,767 ）。</li>
<li>encoding = INTSET_ENC_INT32 ， contents 是 int32_t 类型的数组（最小值为 -2,147,483,648 ，最大值为 2,147,483,647 ）。</li>
<li>encoding = INTSET_ENC_INT64 ， contents 是 int64_t 类型的数组（最小值为 -9,223,372,036,854,775,808 ，最大值为 9,223,372,036,854,775,807 ）。</li>
</ul>
<h3 id="Redis升级"><a href="#Redis升级" class="headerlink" title="Redis升级"></a>Redis升级</h3><p>每当我们要将一个新元素添加到整数集合里面， 并且新元素的类型比整数集合现有所有元素的类型都要长时， 整数集合需要先进行升级（upgrade）， 然后才能将新元素添加到整数集合里面。</p>
<p>升级整数集合并添加新元素共分为三步进行：</p>
<ul>
<li>根据新元素的类型， 扩展整数集合底层数组的空间大小， 并为新元素分配空间。</li>
<li>将底层数组现有的所有元素都转换成与新元素相同的类型， 并将类型转换后的元素放置到正确的位上， 而且在放置元素的过程中， 需要继续维持底层数组的有序性质不变。</li>
<li><p>将新元素添加到底层数组里面。</p>
<p>假设现在有一个 INTSET_ENC_INT16 编码的整数集合， 集合中包含三个 int16_t 类型的元素， 如图 6-3 所示。<br><img src="/img/1501656384153255.png" alt></p>
</li>
</ul>
<p>因为每个元素都占用 16 位空间， 所以整数集合底层数组的大小为 3 * 16 = 48 位， 图 6-4 展示了整数集合的三个元素在这 48 位里的位置。<br><img src="/img/2015-09-13_55f51ab6dbe72.png" alt></p>
<p>现在， 假设我们要将类型为 int32_t 的整数值 65535 添加到整数集合里面， 因为 65535 的类型 int32_t 比整数集合当前所有元素的类型都要长， 所以在将 65535 添加到整数集合之前， 程序需要先对整数集合进行升级。升级首先要做的是， 根据新类型的长度， 以及集合元素的数量（包括要添加的新元素在内）， 对底层数组进行空间重分配。整数集合目前有三个元素， 再加上新元素 65535 ， 整数集合需要分配四个元素的空间， 因为每个 int32_t 整数值需要占用 32 位空间， 所以在空间重分配之后， 底层数组的大小将是 32 * 4 = 128 位， 如图 6-5 所示。<br><img src="/img/2015-09-13_55f51abfde71b.png" alt></p>
<p>虽然程序对底层数组进行了空间重分配， 但数组原有的三个元素 1 、 2 、 3 仍然是 int16_t 类型， 这些元素还保存在数组的前 48 位里面， 所以程序接下来要做的就是将这三个元素转换成 int32_t 类型， 并将转换后的元素放置到正确的位上面， 而且在放置元素的过程中， 需要维持底层数组的有序性质不变。</p>
<p>首先， 因为元素 3 在 1 、 2 、 3 、 65535 四个元素中排名第三， 所以它将被移动到 contents 数组的索引 2 位置上， 也即是数组 64 位至 95 位的空间内， 如图 6-6 所示。<br><img src="/img/2015-09-13_55f51ac25b6a0.png" alt></p>
<p>接着， 因为元素 2 在 1 、 2 、 3 、 65535 四个元素中排名第二， 所以它将被移动到 contents 数组的索引 1 位置上， 也即是数组的 32位至 63 位的空间内， 如图 6-7 所示。<br><img src="/img/2015-09-13_55f51ac353bfa.png" alt></p>
<p>之后， 因为元素 1 在 1 、 2 、 3 、 65535 四个元素中排名第一， 所以它将被移动到 contents 数组的索引 0 位置上， 也即是数组的 0 位至 31 位的空间内， 如图 6-8 所示。<br><img src="/img/2015-09-13_55f51ac466154.png" alt></p>
<p>然后， 因为元素 65535 在 1 、 2 、 3 、 65535 四个元素中排名第四， 所以它将被添加到 contents 数组的索引 3 位置上， 也即是数组的96 位至 127 位的空间内， 如图 6-9 所示。<br><img src="/img/2015-09-13_55f51acae92db.png" alt></p>
<p>最后， 程序将整数集合 encoding 属性的值从 INTSET_ENC_INT16 改为 INTSET_ENC_INT32 ， 并将 length 属性的值从 3 改为 4 ，因为每次向整数集合添加新元素都可能会引起升级， 而每次升级都需要对底层数组中已有的所有元素进行类型转换， 所以向整数集合添加新元素的时间复杂度为 O(N) 。</p>
<p>其他类型的升级操作， 比如从 INTSET_ENC_INT16 编码升级为 INTSET_ENC_INT64 编码， 或者从 INTSET_ENC_INT32 编码升级为 INTSET_ENC_INT64 编码， 升级的过程都和上面展示的升级过程类似。</p>
<p>因为引发升级的新元素的长度总是比整数集合现有所有元素的长度都大， 所以这个新元素的值要么就大于所有现有元素， 要么就小于所有现有元素：</p>
<ul>
<li>在新元素小于所有现有元素的情况下， 新元素会被放置在底层数组的最开头（索引 0 ）；</li>
<li>在新元素大于所有现有元素的情况下， 新元素会被放置在底层数组的最末尾（索引 length-1 ）。</li>
</ul>
<h3 id="Redis-升级的好处"><a href="#Redis-升级的好处" class="headerlink" title="Redis 升级的好处"></a>Redis 升级的好处</h3><p>整数集合的升级策略有两个好处， 一个是提升整数集合的灵活性， 另一个是尽可能地节约内存。</p>
<ul>
<li>提升灵活性：通常不会将两种不同类型的值放在同一个数据结构里面。但是， 因为整数集合可以通过自动升级底层数组来适应新元素， 所以我们可以随意地将 int16_t 、 int32_t 或者 int64_t 类型的整数添加到集合中， 而不必担心出现类型错误， 这种做法非常灵活。</li>
<li>节约内存：当然， 要让一个数组可以同时保存 int16_t 、 int32_t 、 int64_t 三种类型的值， 最简单的做法就是直接使用 int64_t 类型的数组作为整数集合的底层实现。但是会出现浪费内存的情况。而整数集合现在的做法既可以让集合能同时保存三种不同类型的值， 又可以确保升级操作只会在有需要的时候进行， 这可以尽量节省内存。</li>
</ul>
<h3 id="Redis-降级"><a href="#Redis-降级" class="headerlink" title="Redis 降级"></a>Redis 降级</h3><p>整数集合不支持降级操作， 一旦对数组进行了升级， 编码就会一直保持升级后的状态。</p>
<p>举个例子， 对于一个整数集合来说， 即使我们将集合里唯一一个真正需要使用 int64_t 类型来保存的元素 4294967295 删除了， 整数集合的编码仍然会维持 INTSET_ENC_INT64 ， 底层数组也仍然会是 int64_t 类型的。</p>
<h3 id="Redis-整数集合-API"><a href="#Redis-整数集合-API" class="headerlink" title="Redis 整数集合 API"></a>Redis 整数集合 API</h3><div class="table-container">
<table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>intsetNew</td>
<td>创建一个新的整数集合。</td>
<td>O(1)</td>
</tr>
<tr>
<td>intsetAdd</td>
<td>将给定元素添加到整数集合里面。</td>
<td>O(N)</td>
</tr>
<tr>
<td>intsetRemove</td>
<td>从整数集合中移除给定元素。</td>
<td>O(N)</td>
</tr>
<tr>
<td>intsetFind</td>
<td>检查给定值是否存在于集合。</td>
<td>因为底层数组有序，查找可以通过二分查找法来进行， 所以复杂度为 O(\log N) 。</td>
</tr>
<tr>
<td>intsetRandom</td>
<td>从整数集合中随机返回一个元素。</td>
<td>O(1)</td>
</tr>
<tr>
<td>intsetGet</td>
<td>取出底层数组在给定索引上的元素。</td>
<td>O(1)</td>
</tr>
<tr>
<td>intsetLen</td>
<td>返回整数集合包含的元素个数。</td>
<td>O(1)</td>
</tr>
<tr>
<td>intsetBlobLen</td>
<td>返回整数集合占用的内存字节数。</td>
<td>O(1)</td>
</tr>
</tbody>
</table>
</div>
<h2 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h2><p>压缩列表（ziplist）是列表键和哈希键的底层实现之一。当一个列表键只包含少量列表项， 并且每个列表项要么就是小整数值， 要么就是长度比较短的字符串， 那么 Redis 就会使用压缩列表来做列表键的底层实现。</p>
<p>比如说， 执行以下命令将创建一个压缩列表实现的列表键：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; RPUSH lst 1 3 5 10086 &quot;hello&quot; &quot;world&quot;</span><br><span class="line">(integer) 6</span><br><span class="line"></span><br><span class="line">redis&gt; OBJECT ENCODING lst</span><br><span class="line">&quot;ziplist&quot;</span><br></pre></td></tr></table></figure></p>
<p>因为列表键里面包含的都是 1 、 3 、 5 、 10086 这样的小整数值， 以及 “hello” 、 “world” 这样的短字符串。</p>
<p>另外， 当一个哈希键只包含少量键值对， 并且每个键值对的键和值要么就是小整数值， 要么就是长度比较短的字符串， 那么 Redis 就会使用压缩列表来做哈希键的底层实现。</p>
<p>举个例子， 执行以下命令将创建一个压缩列表实现的哈希键：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; HMSET profile &quot;name&quot; &quot;Jack&quot; &quot;age&quot; 28 &quot;job&quot; &quot;Programmer&quot;</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; OBJECT ENCODING profile</span><br><span class="line">&quot;ziplist&quot;</span><br></pre></td></tr></table></figure></p>
<p>因为哈希键里面包含的所有键和值都是小整数值或者短字符串。</p>
<h3 id="Redis-压缩列表的构成"><a href="#Redis-压缩列表的构成" class="headerlink" title="Redis 压缩列表的构成"></a>Redis 压缩列表的构成</h3><p>压缩列表是 Redis 为了节约内存而开发的， 由一系列特殊编码的连续内存块组成的顺序型（sequential）数据结构。一个压缩列表可以包含任意多个节点（entry）， 每个节点可以保存一个字节数组或者一个整数值。图 7-1 展示了压缩列表的各个组成部分， 表 7-1 则记录了各个组成部分的类型、长度、以及用途。<br><img src="/img/2015-09-13_55f51bfccbd83.png" alt></p>
<p> 压缩列表各个组成部分的详细说明</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>属性</th>
<th>类型</th>
<th>长度</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>zlbytes</td>
<td>uint32_t</td>
<td>4 字节</td>
<td>记录整个压缩列表占用的内存字节数：在对压缩列表进行内存重分配， 或者计算 zlend 的位置时使用。</td>
</tr>
<tr>
<td>zltail</td>
<td>uint32_t</td>
<td>4 字节</td>
<td>记录压缩列表表尾节点距离压缩列表的起始地址有多少字节： 通过这个偏移量，程序无须遍历整个压缩列表就可以确定表尾节点的地址。</td>
</tr>
<tr>
<td>zllen</td>
<td>uint16_t</td>
<td>2 字节</td>
<td>记录了压缩列表包含的节点数量： 当这个属性的值小于 UINT16_MAX （65535）时， 这个属性的值就是压缩列表包含节点的数量； 当这个值等于 UINT16_MAX 时， 节点的真实数量需要遍历整个压缩列表才能计算得出。</td>
</tr>
<tr>
<td>entryX</td>
<td>列表节点</td>
<td>不定</td>
<td>压缩列表包含的各个节点，节点的长度由节点保存的内容决定。</td>
</tr>
<tr>
<td>zlend</td>
<td>uint8_t</td>
<td>1 字节</td>
<td>特殊值 0xFF （十进制 255 ），用于标记压缩列表的末端。</td>
</tr>
</tbody>
</table>
</div>
<p>图 7-2 展示了一个压缩列表示例：</p>
<ul>
<li>列表 zlbytes 属性的值为 0x50 （十进制 80）， 表示压缩列表的总长为 80 字节。</li>
<li>列表 zltail 属性的值为 0x3c （十进制 60）， 这表示如果我们有一个指向压缩列表起始地址的指针 p ， 那么只要用指针 p 加上- 偏移量 60 ， 就可以计算出表尾节点 entry3 的地址。</li>
<li>列表 zllen 属性的值为 0x3 （十进制 3）， 表示压缩列表包含三个节点。</li>
</ul>
<p><img src="/img/2015-09-13_55f51bfe2547f.png" alt></p>
<h3 id="Redis-压缩列表节点的构成"><a href="#Redis-压缩列表节点的构成" class="headerlink" title="Redis 压缩列表节点的构成"></a>Redis 压缩列表节点的构成</h3><p>每个压缩列表节点可以保存一个字节数组或者一个整数值， 其中， 字节数组可以是以下三种长度的其中一种：</p>
<ul>
<li>长度小于等于 63 （2^{6}-1）字节的字节数组；</li>
<li>长度小于等于 16383 （2^{14}-1） 字节的字节数组；</li>
<li>长度小于等于 4294967295 （2^{32}-1）字节的字节数组；</li>
</ul>
<p>而整数值则可以是以下六种长度的其中一种：</p>
<ul>
<li>4 位长，介于 0 至 12 之间的无符号整数；</li>
<li>1 字节长的有符号整数；</li>
<li>3 字节长的有符号整数；</li>
<li>int16_t 类型整数；</li>
<li>int32_t 类型整数；</li>
<li>int64_t 类型整数。</li>
</ul>
<p>每个压缩列表节点都由 previous_entry_length 、 encoding 、 content 三个部分组成。</p>
<p>previous_entry_length：节点的 previous_entry_length 属性以字节为单位， 记录了压缩列表中前一个节点的长度。<br>previous_entry_length 属性的长度可以是 1 字节或者 5 字节；如果前一节点的长度小于 254 字节， 那么 previous_entry_length 属性的长度为 1 字节；前一节点的长度就保存在这一个字节里面。<br>如果前一节点的长度大于等于 254 字节， 那么 previous_entry_length 属性的长度为 5 字节： 其中属性的第一字节会被设置为 0xFE（十进制值 254）， 而之后的四个字节则用于保存前一节点的长度。</p>
<p>压缩列表的从表尾向表头遍历操作就是使用这一原理实现的： 只要我们拥有了一个指向某个节点起始地址的指针， 那么通过这个指针以及这个节点的 previous_entry_length 属性， 程序就可以一直向前一个节点回溯， 最终到达压缩列表的表头节点。</p>
<p>一个从表尾节点向表头节点进行遍历的完整过程：</p>
<ul>
<li>首先，我们拥有指向压缩列表表尾节点 entry4 起始地址的指针 p1 （指向表尾节点的指针可以通过指向压缩列表起始地址的指针加上zltail 属性的值得出）；</li>
<li>通过用 p1 减去 entry4 节点 previous_entry_length 属性的值， 我们得到一个指向 entry4 前一节点 entry3 起始地址的指针 p2 ；</li>
<li>通过用 p2 减去 entry3 节点 previous_entry_length 属性的值， 我们得到一个指向 entry3 前一节点 entry2 起始地址的指针 p3 ；</li>
<li>通过用 p3 减去 entry2 节点 previous_entry_length 属性的值， 我们得到一个指向 entry2 前一节点 entry1 起始地址的指针 p4 ， entry1为压缩列表的表头节点；</li>
<li>最终， 我们从表尾节点向表头节点遍历了整个列表。</li>
</ul>
<p>encoding：节点的 encoding 属性记录了节点的 content 属性所保存数据的类型以及长度：</p>
<ul>
<li>一字节、两字节或者五字节长， 值的最高位为 00 、 01 或者 10 的是字节数组编码： 这种编码表示节点的 content 属性保存着字节数组， 数组的长度由编码除去最高两位之后的其他位记录；</li>
<li>一字节长， 值的最高位以 11 开头的是整数编码： 这种编码表示节点的 content 属性保存着整数值， 整数值的类型和长度由编码除去最高两位之后的其他位记录；</li>
</ul>
<p>content：节点的 content 属性负责保存节点的值， 节点值可以是一个字节数组或者整数， 值的类型和长度由节点的 encoding 属性决定。</p>
<h3 id="Redis-连锁更新"><a href="#Redis-连锁更新" class="headerlink" title="Redis 连锁更新"></a>Redis 连锁更新</h3><p>Redis 将在特殊情况下产生的连续多次空间扩展操作称之为“连锁更新”（cascade update）</p>
<p>除了添加新节点可能会引发连锁更新之外， 删除节点也可能会引发连锁更新。</p>
<p>如果 e1 至 eN 都是大小介于 250 字节至 253 字节的节点， big 节点的长度大于等于 254 字节（需要 5 字节的 previous_entry_length 来保存）， 而 small 节点的长度小于 254 字节（只需要 1 字节的 previous_entry_length 来保存）， 那么当我们将 small 节点从压缩列表中删除之后， 为了让 e1 的 previous_entry_length 属性可以记录 big 节点的长度， 程序将扩展 e1 的空间， 并由此引发之后的连锁更新。</p>
<p>因为连锁更新在最坏情况下需要对压缩列表执行 N 次空间重分配操作， 而每次空间重分配的最坏复杂度为 O(N^2) 。</p>
<p>要注意的是， 尽管连锁更新的复杂度较高， 但它真正造成性能问题的几率是很低的：</p>
<ul>
<li>首先， 压缩列表里要恰好有多个连续的、长度介于 250 字节至 253 字节之间的节点， 连锁更新才有可能被引发， 在实际中， 这种情况并不多见；</li>
<li>其次， 即使出现连锁更新， 但只要被更新的节点数量不多， 就不会对性能造成任何影响： 比如说， 对三五个节点进行连锁更新是绝对不会影响性能的；</li>
</ul>
<p>因为以上原因， ziplistPush 等命令的平均复杂度仅为 O(N) ， 在实际中， 我们可以放心地使用这些函数， 而不必担心连锁更新会影响压缩列表的性能。</p>
<h3 id="Redis-压缩列表-API"><a href="#Redis-压缩列表-API" class="headerlink" title="Redis 压缩列表 API"></a>Redis 压缩列表 API</h3><div class="table-container">
<table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
<th>算法复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>ziplistNew</td>
<td>创建一个新的压缩列表。</td>
<td>O(1)</td>
</tr>
<tr>
<td>ziplistPush</td>
<td>创建一个包含给定值的新节点， 并将这个新节点添加到压缩列表的表头或者表尾。</td>
<td>平均 O(N^2) 。</td>
</tr>
<tr>
<td>ziplistInsert</td>
<td>将包含给定值的新节点插入到给定节点之后。</td>
<td>平均 O(N^2) 。</td>
</tr>
<tr>
<td>ziplistIndex</td>
<td>返回压缩列表给定索引上的节点。</td>
<td>O(N)</td>
</tr>
<tr>
<td>ziplistFind</td>
<td>在压缩列表中查找并返回包含了给定值的节点。</td>
<td>因为节点的值可能是一个字节数组， 所以检查节点值和给定值是否相同的复杂度为 O(N^2) 。</td>
</tr>
<tr>
<td>ziplistNext</td>
<td>返回给定节点的下一个节点。</td>
<td>O(1)</td>
</tr>
<tr>
<td>ziplistPrev</td>
<td>返回给定节点的前一个节点。</td>
<td>O(1)</td>
</tr>
<tr>
<td>ziplistGet</td>
<td>获取给定节点所保存的值。</td>
<td>O(1)</td>
</tr>
<tr>
<td>ziplistDelete</td>
<td>从压缩列表中删除给定的节点。</td>
<td>平均 O(N^2) 。</td>
</tr>
<tr>
<td>ziplistDeleteRange</td>
<td>删除压缩列表在给定索引上的连续多个节点。</td>
<td>平均 O(N^2) 。</td>
</tr>
<tr>
<td>ziplistBlobLen</td>
<td>返回压缩列表目前占用的内存字节数。</td>
<td>O(1)</td>
</tr>
<tr>
<td>ziplistLen</td>
<td>返回压缩列表目前包含的节点数量。</td>
<td>节点数量小于 65535 时 O(N) 。</td>
</tr>
</tbody>
</table>
</div>
<p>因为 ziplistPush 、 ziplistInsert 、 ziplistDelete 和 ziplistDeleteRange 四个函数都有可能会引发连锁更新， 所以它们的最坏复杂度都是 O(N^2) 。</p>
<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>Redis 并没有直接使用上述数据结构来实现键值对数据库， 而是基于这些数据结构创建了一个<strong>对象系统</strong>， 这个系统包含字符串对象、列表对象、哈希对象、集合对象和有序集合对象这五种类型的对象， 每种对象都用到了至少一种我们前面所介绍的数据结构。</p>
<p>通过这五种不同类型的对象， Redis 可以在执行命令之前， <strong>根据对象的类型来判断一个对象是否可以执行给定的命令</strong>。 使用对象的另一个好处是， 我们可以针对不同的使用场景， 为对象设置多种不同的数据结构实现， 从而优化对象在不同场景下的使用效率。</p>
<p>除此之外， Redis 的对象系统还实现了<strong>基于引用计数技术的内存回收机制</strong>： 当程序不再使用某个对象的时候， 这个对象所占用的内存就会被自动释放； 另外， Redis 还通过引用计数技术实现了对象共享机制， 这一机制可以在适当的条件下， 通过让多个数据库键共享同一个对象来节约内存。</p>
<p>最后， Redis 的对象带有<strong>访问时间记录信息</strong>， 该信息可以用于计算数据库键的空转时长， 在服务器启用了 maxmemory 功能的情况下， 空转时长较大的那些键可能会优先被服务器删除。</p>
<h3 id="Redis-对象的类型与编码"><a href="#Redis-对象的类型与编码" class="headerlink" title="Redis 对象的类型与编码"></a>Redis 对象的类型与编码</h3><p>Redis 使用对象来表示数据库中的键和值， 每次当我们在 Redis 的数据库中新创建一个键值对时， 我们至少会创建两个对象， 一个对象用作键值对的键（键对象）， 另一个对象用作键值对的值（值对象）。</p>
<p>Redis 中的每个对象都由一个 redisObject 结构表示， 该结构中和保存数据有关的三个属性分别是 type 属性、 encoding 属性和 ptr 属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typedef struct redisObject &#123;</span><br><span class="line">    // 类型</span><br><span class="line">    unsigned type:4;</span><br><span class="line"></span><br><span class="line">    // 编码</span><br><span class="line">    unsigned encoding:4;</span><br><span class="line"></span><br><span class="line">    // 指向底层实现数据结构的指针</span><br><span class="line">    void *ptr;</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure></p>
<p>对象的 type 属性记录了对象的类型， 这个属性的值可以是表中列出的常量的其中一个。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>类型常量</th>
<th>对象的名称</th>
</tr>
</thead>
<tbody>
<tr>
<td>REDIS_STRING</td>
<td>字符串对象</td>
</tr>
<tr>
<td>REDIS_LIST</td>
<td>列表对象</td>
</tr>
<tr>
<td>REDIS_HASH</td>
<td>哈希对象</td>
</tr>
<tr>
<td>REDIS_SET</td>
<td>集合对象</td>
</tr>
<tr>
<td>REDIS_ZSET</td>
<td>有序集合对象</td>
</tr>
</tbody>
</table>
</div>
<p>对于 Redis 数据库保存的键值对来说， 键总是一个字符串对象， 而值则可以是字符串对象、列表对象、哈希对象、集合对象或者有序集合对象的其中一种， 因此：</p>
<ul>
<li>当我们称呼一个数据库键为“字符串键”时， 我们指的是“这个数据库键所对应的值为字符串对象”；</li>
<li>当我们称呼一个键为“列表键”时， 我们指的是“这个数据库键所对应的值为列表对象”，</li>
</ul>
<p>TYPE 命令的实现方式也与此类似， 当我们对一个数据库键执行 TYPE 命令时， 命令返回的结果为数据库键对应的值对象的类型， 而不是键对象的类型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"># 键为字符串对象，值为字符串对象</span><br><span class="line">redis&gt; SET msg &quot;hello world&quot;</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; TYPE msg</span><br><span class="line">string</span><br><span class="line"></span><br><span class="line"># 键为字符串对象，值为列表对象</span><br><span class="line">redis&gt; RPUSH numbers 1 3 5</span><br><span class="line">(integer) 6</span><br><span class="line"></span><br><span class="line">redis&gt; TYPE numbers</span><br><span class="line">list</span><br><span class="line"></span><br><span class="line"># 键为字符串对象，值为哈希对象</span><br><span class="line">redis&gt; HMSET profile name Tome age 25 career Programmer</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; TYPE profile</span><br><span class="line">hash</span><br><span class="line"></span><br><span class="line"># 键为字符串对象，值为集合对象</span><br><span class="line">redis&gt; SADD fruits apple banana cherry</span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line">redis&gt; TYPE fruits</span><br><span class="line">set</span><br><span class="line"></span><br><span class="line"># 键为字符串对象，值为有序集合对象</span><br><span class="line">redis&gt; ZADD price 8.5 apple 5.0 banana 6.0 cherry</span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line">redis&gt; TYPE price</span><br><span class="line">zset</span><br></pre></td></tr></table></figure></p>
<p>表中列出了 TYPE 命令在面对不同类型的值对象时所产生的输出。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>对象</th>
<th>对象 type 属性的值</th>
<th>TYPE 命令的输出</th>
</tr>
</thead>
<tbody>
<tr>
<td>字符串对象</td>
<td>REDIS_STRING</td>
<td>“string”</td>
</tr>
<tr>
<td>列表对象</td>
<td>REDIS_LIST</td>
<td>“list”</td>
</tr>
<tr>
<td>哈希对象</td>
<td>REDIS_HASH</td>
<td>“hash”</td>
</tr>
<tr>
<td>集合对象</td>
<td>REDIS_SET</td>
<td>“set”</td>
</tr>
<tr>
<td>有序集合对象</td>
<td>REDIS_ZSET</td>
<td>“zset”</td>
</tr>
</tbody>
</table>
</div>
<h4 id="编码和底层实现"><a href="#编码和底层实现" class="headerlink" title="编码和底层实现"></a>编码和底层实现</h4><p>对象的 ptr 指针指向对象的底层实现数据结构， 而这些数据结构由对象的 encoding 属性决定。</p>
<p>encoding 属性记录了对象所使用的编码， 也即是说这个对象使用了什么数据结构作为对象的底层实现， 这个属性的值可以是表 8-3 列出的常量的其中一个。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>编码常量</th>
<th>编码所对应的底层数据结构</th>
</tr>
</thead>
<tbody>
<tr>
<td>REDIS_ENCODING_INT</td>
<td>long 类型的整数</td>
</tr>
<tr>
<td>REDIS_ENCODING_EMBSTR</td>
<td>embstr 编码的简单动态字符串</td>
</tr>
<tr>
<td>REDIS_ENCODING_RAW</td>
<td>简单动态字符串</td>
</tr>
<tr>
<td>REDIS_ENCODING_HT</td>
<td>字典</td>
</tr>
<tr>
<td>REDIS_ENCODING_LINKEDLIST</td>
<td>双端链表</td>
</tr>
<tr>
<td>REDIS_ENCODING_ZIPLIST</td>
<td>压缩列表</td>
</tr>
<tr>
<td>REDIS_ENCODING_INTSET</td>
<td>整数集合</td>
</tr>
<tr>
<td>REDIS_ENCODING_SKIPLIST</td>
<td>跳跃表和字典</td>
</tr>
</tbody>
</table>
</div>
<p>每种类型的对象都至少使用了两种不同的编码， 表中列出了每种类型的对象可以使用的编码。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th>编码</th>
<th>对象</th>
</tr>
</thead>
<tbody>
<tr>
<td>REDIS_STRING</td>
<td>REDIS_ENCODING_INT</td>
<td>使用整数值实现的字符串对象。</td>
</tr>
<tr>
<td>REDIS_STRING</td>
<td>REDIS_ENCODING_EMBSTR</td>
<td>使用 embstr 编码的简单动态字符串实现的字符串对象。</td>
</tr>
<tr>
<td>REDIS_STRING</td>
<td>REDIS_ENCODING_RAW</td>
<td>使用简单动态字符串实现的字符串对象。</td>
</tr>
<tr>
<td>REDIS_LIST</td>
<td>REDIS_ENCODING_ZIPLIST</td>
<td>使用压缩列表实现的列表对象。</td>
</tr>
<tr>
<td>REDIS_LIST</td>
<td>REDIS_ENCODING_LINKEDLIST</td>
<td>使用双端链表实现的列表对象。</td>
</tr>
<tr>
<td>REDIS_HASH</td>
<td>REDIS_ENCODING_ZIPLIST</td>
<td>使用压缩列表实现的哈希对象。</td>
</tr>
<tr>
<td>REDIS_HASH</td>
<td>REDIS_ENCODING_HT</td>
<td>使用字典实现的哈希对象。</td>
</tr>
<tr>
<td>REDIS_SET</td>
<td>REDIS_ENCODING_INTSET</td>
<td>使用整数集合实现的集合对象。</td>
</tr>
<tr>
<td>REDIS_SET</td>
<td>REDIS_ENCODING_HT</td>
<td>使用字典实现的集合对象。</td>
</tr>
<tr>
<td>REDIS_ZSET</td>
<td>REDIS_ENCODING_ZIPLIST</td>
<td>使用压缩列表实现的有序集合对象。</td>
</tr>
<tr>
<td>REDIS_ZSET</td>
<td>REDIS_ENCODING_SKIPLIST</td>
<td>使用跳跃表和字典实现的有序集合对象。</td>
</tr>
</tbody>
</table>
</div>
<p>使用 OBJECT ENCODING 命令可以查看一个数据库键的值对象的编码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET msg &quot;hello wrold&quot;</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; OBJECT ENCODING msg</span><br><span class="line">&quot;embstr&quot;</span><br></pre></td></tr></table></figure></p>
<p>表中列出了不同编码的对象所对应的 OBJECT ENCODING 命令输出。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>对象所使用的底层数据结构</th>
<th>编码常量</th>
<th>OBJECT ENCODING 命令输出</th>
</tr>
</thead>
<tbody>
<tr>
<td>整数</td>
<td>REDIS_ENCODING_INT</td>
<td>“int”</td>
</tr>
<tr>
<td>embstr 编码的简单动态字符串（SDS）</td>
<td>REDIS_ENCODING_EMBSTR</td>
<td>“embstr”</td>
</tr>
<tr>
<td>简单动态字符串</td>
<td>REDIS_ENCODING_RAW</td>
<td>“raw”</td>
</tr>
<tr>
<td>字典</td>
<td>REDIS_ENCODING_HT</td>
<td>“hashtable”</td>
</tr>
<tr>
<td>双端链表</td>
<td>REDIS_ENCODING_LINKEDLIST</td>
<td>“linkedlist”</td>
</tr>
<tr>
<td>压缩列表</td>
<td>REDIS_ENCODING_ZIPLIST</td>
<td>“ziplist”</td>
</tr>
<tr>
<td>整数集合</td>
<td>REDIS_ENCODING_INTSET</td>
<td>“intset”</td>
</tr>
<tr>
<td>跳跃表和字典</td>
<td>REDIS_ENCODING_SKIPLIST</td>
<td>“skiplist”</td>
</tr>
</tbody>
</table>
</div>
<p>通过 encoding 属性来设定对象所使用的编码， 而不是为特定类型的对象关联一种固定的编码， 极大地提升了 Redis 的灵活性和效率， 因为 Redis 可以根据不同的使用场景来为一个对象设置不同的编码， 从而优化对象在某一场景下的效率。</p>
<h3 id="Redis-字符串对象"><a href="#Redis-字符串对象" class="headerlink" title="Redis 字符串对象"></a>Redis 字符串对象</h3><p>字符串对象的编码可以是 <strong>int 、 raw 或者 embstr</strong> 。</p>
<p>如果一个字符串对象保存的是<strong>整数值</strong>， 并且这个整数值可以用 long 类型来表示， 那么字符串对象会将整数值保存在字符串对象结构的 ptr属性里面（将 void<em> 转换成 long ）， 并将字符串对象的编码设置为 <em>*int</em></em> 。</p>
<p>如果字符串对象保存的是一个<strong>字符串值</strong>， 并且这个字符串值的长度<strong>大于 32 字节</strong>， 那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串值， 并将对象的编码设置为 <strong>raw</strong> 。</p>
<p>如果字符串对象保存的是一个<strong>字符串值</strong>， 并且这个字符串值的长度<strong>小于等于 32 字节</strong>， 那么字符串对象将使用<strong> embstr 编码</strong>的方式来保存这个字符串值。</p>
<p>embstr 编码是专门用于<strong>保存短字符串</strong>的一种优化编码方式， 这种编码和 raw 编码一样， 都使用 redisObject 结构和 sdshdr 结构来表示字符串对象， 但 raw 编码会调用两次内存分配函数来分别创建 redisObject 结构和 sdshdr 结构， 而 <strong>embstr 编码则通过调用一次内存分配函数来分配一块连续的空间</strong>， 空间中依次包含 redisObject 和 sdshdr 两个结构。</p>
<p>embstr 编码的字符串对象在执行命令时， 产生的效果和 raw 编码的字符串对象执行命令时产生的效果是相同的， 但使用 embstr 编码的字符串对象来保存短字符串值有以下好处：</p>
<ul>
<li>embstr 编码将创建字符串对象所需的内存分配次数从 raw 编码的两次降低为<strong>一次</strong>。</li>
<li>释放 embstr 编码的字符串对象只需要<strong>调用一次内存释放函数</strong>， 而释放 raw 编码的字符串对象需要调用两次内存释放函数。</li>
<li>因为 embstr 编码的字符串对象的所有数据都<strong>保存在一块连续的内存里面</strong>， 所以这种编码的字符串对象比起 raw 编码的字符串对象能够更好地利用缓存带来的优势。</li>
</ul>
<p>可以用 long double 类型表示的浮点数在 Redis 中也是作为字符串值来保存的： 如果我们要保存一个浮点数到字符串对象里面， 那么程序会先将这个浮点数转换成字符串值， 然后再保存起转换所得的字符串值。  </p>
<p>因为 Redis 没有为 embstr 编码的字符串对象编写任何相应的修改程序 （只有 int 编码的字符串对象和 raw 编码的字符串对象有这些程序）， 所以 embstr 编码的字符串对象实际上是只读的： 当我们对 embstr 编码的字符串对象执行任何修改命令时， 程序会先将对象的编码从 embstr 转换成 raw ， 然后再执行修改命令； 因为这个原因， embstr 编码的字符串对象在执行修改命令之后， 总会变成一个 raw 编码的字符串对象。</p>
<h4 id="字符串命令的实现"><a href="#字符串命令的实现" class="headerlink" title="字符串命令的实现"></a>字符串命令的实现</h4><p>因为字符串键的值为字符串对象， 所以用于字符串键的所有命令都是针对字符串对象来构建的， 表中列举了其中一部分字符串命令， 以及这些命令在不同编码的字符串对象下的实现方法。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>int 编码的实现方法</th>
<th>embstr 编码的实现方法</th>
<th>raw 编码的实现方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>SET</td>
<td>使用 int 编码保存值。</td>
<td>使用 embstr 编码保存值。</td>
<td>使用 raw 编码保存值。</td>
</tr>
<tr>
<td>GET</td>
<td>拷贝对象所保存的整数值， 将这个拷贝转换成字符串值， 然后向客户端返回这个字符串值。</td>
<td>直接向客户端返回字符串值。</td>
<td>直接向客户端返回字符串值。</td>
</tr>
<tr>
<td>APPEND</td>
<td>将对象转换成 raw 编码， 然后按raw 编码的方式执行此操作。</td>
<td>将对象转换成 raw 编码， 然后按raw 编码的方式执行此操作。</td>
<td>调用 sdscatlen 函数， 将给定字符串追加到现有字符串的末尾。</td>
</tr>
<tr>
<td>INCRBYFLOAT</td>
<td>取出整数值并将其转换成 longdouble 类型的浮点数， 对这个浮点数进行加法计算， 然后将得出的浮点数结果保存起来。</td>
<td>取出字符串值并尝试将其转换成long double 类型的浮点数， 对这个浮点数进行加法计算， 然后将得出的浮点数结果保存起来。 如果字符串值不能被转换成浮点数， 那么向客户端返回一个错误。</td>
<td>取出字符串值并尝试将其转换成 longdouble 类型的浮点数， 对这个浮点数进行加法计算， 然后将得出的浮点数结果保存起来。 如果字符串值不能被转换成浮点数， 那么向客户端返回一个错误。</td>
</tr>
<tr>
<td>INCRBY</td>
<td>对整数值进行加法计算， 得出的计算结果会作为整数被保存起来。</td>
<td>embstr 编码不能执行此命令， 向客户端返回一个错误。</td>
<td>raw 编码不能执行此命令， 向客户端返回一个错误。</td>
</tr>
<tr>
<td>DECRBY</td>
<td>对整数值进行减法计算， 得出的计算结果会作为整数被保存起来。</td>
<td>embstr 编码不能执行此命令， 向客户端返回一个错误。</td>
<td>raw 编码不能执行此命令， 向客户端返回一个错误。</td>
</tr>
<tr>
<td>STRLEN</td>
<td>拷贝对象所保存的整数值， 将这个拷贝转换成字符串值， 计算并返回这个字符串值的长度。</td>
<td>调用 sdslen 函数， 返回字符串的长度。</td>
<td>调用 sdslen 函数， 返回字符串的长度。</td>
</tr>
<tr>
<td>SETRANGE</td>
<td>将对象转换成 raw 编码， 然后按raw 编码的方式执行此命令。</td>
<td>将对象转换成 raw 编码， 然后按raw 编码的方式执行此命令。</td>
<td>将字符串特定索引上的值设置为给定的字符。</td>
</tr>
<tr>
<td>GETRANGE</td>
<td>拷贝对象所保存的整数值， 将这个拷贝转换成字符串值， 然后取出并返回字符串指定索引上的字符。</td>
<td>直接取出并返回字符串指定索引上的字符。</td>
<td>直接取出并返回字符串指定索引上的字符。</td>
</tr>
</tbody>
</table>
</div>
<h3 id="Redis-列表对象"><a href="#Redis-列表对象" class="headerlink" title="Redis 列表对象"></a>Redis 列表对象</h3><p>列表对象的编码可以是 ziplist 或者 linkedlist 。ziplist 编码的列表对象使用压缩列表作为底层实现， 每个压缩列表节点（entry）保存了一个列表元素。举个例子， 如果我们执行以下 RPUSH 命令， 那么服务器将创建一个列表对象作为 numbers 键的值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; RPUSH numbers 1 &quot;three&quot; 5</span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure></p>
<p>如果 numbers 键的值对象使用的是 ziplist 编码， 这个这个值对象将会是图 8-5 所展示的样子：<br><img src="/img/2015-09-13_55f51fdd42122.png" alt></p>
<p>另一方面， linkedlist 编码的列表对象使用双端链表作为底层实现， 每个双端链表节点（node）都保存了一个字符串对象， 而每个字符串对象都保存了一个列表元素。举个例子， 如果前面所说的 numbers 键创建的列表对象使用的不是 ziplist 编码， 而是 linkedlist 编码， 那么 numbers 键的值对象将是图 8-6 所示的样子。<br><img src="/img/2015-09-13_55f51fde60a02.png" alt></p>
<p>为了简化字符串对象的表示， 我们在图 8-6 使用了一个带有 StringObject 字样的格子来表示一个字符串对象， 而 StringObject 字样下面的是字符串对象所保存的值。 图 8-7 代表的就是一个包含了字符串值 “three” 的字符串对象， 它是 8-8 的简化表示。<br><img src="/img/20200315234000.jpg" alt></p>
<h4 id="编码转换"><a href="#编码转换" class="headerlink" title="编码转换"></a>编码转换</h4><p>当列表对象可以同时满足以下两个条件时， 列表对象使用 ziplist 编码：</p>
<ul>
<li>列表对象保存的所有字符串元素的长度都小于 64 字节；</li>
<li>列表对象保存的元素数量小于 512 个；</li>
<li>不能满足这两个条件的列表对象需要使用 linkedlist 编码。</li>
</ul>
<p>以上两个条件的上限值是可以修改的， 具体请看配置文件中关于 list-max-ziplist-value 选项和 list-max-ziplist-entries 选项的说明。</p>
<p>对于使用 ziplist 编码的列表对象来说， 当使用 ziplist 编码所需的两个条件的任意一个不能被满足时， 对象的编码转换操作就会被执行： 原本保存在压缩列表里的所有列表元素都会被转移并保存到双端链表里面， 对象的编码也会从 ziplist 变为 linkedlist 。</p>
<p>以下代码展示了列表对象因为保存了长度太大的元素而进行编码转换的情况：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 所有元素的长度都小于 64 字节</span><br><span class="line">redis&gt; RPUSH blah &quot;hello&quot; &quot;world&quot; &quot;again&quot;</span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line">redis&gt; OBJECT ENCODING blah</span><br><span class="line">&quot;ziplist&quot;</span><br><span class="line"></span><br><span class="line"># 将一个 65 字节长的元素推入列表对象中</span><br><span class="line">redis&gt; RPUSH blah &quot;wwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww&quot;</span><br><span class="line">(integer) 4</span><br><span class="line"></span><br><span class="line"># 编码已改变</span><br><span class="line">redis&gt; OBJECT ENCODING blah</span><br><span class="line">&quot;linkedlist&quot;</span><br></pre></td></tr></table></figure></p>
<h4 id="列表命令的实现"><a href="#列表命令的实现" class="headerlink" title="列表命令的实现"></a>列表命令的实现</h4><p>因为列表键的值为列表对象， 所以用于列表键的所有命令都是针对列表对象来构建的， 表 8-8 列出了其中一部分列表键命令， 以及这些命令在不同编码的列表对象下的实现方法。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>ziplist 编码的实现方法</th>
<th>linkedlist 编码的实现方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>LPUSH</td>
<td>调用 ziplistPush 函数， 将新元素推入到压缩列表的表头。</td>
<td>调用 listAddNodeHead 函数， 将新元素推入到双端链表的表头。</td>
</tr>
<tr>
<td>RPUSH</td>
<td>调用 ziplistPush 函数， 将新元素推入到压缩列表的表尾。</td>
<td>调用 listAddNodeTail 函数， 将新元素推入到双端链表的表尾。</td>
</tr>
<tr>
<td>LPOP</td>
<td>调用 ziplistIndex 函数定位压缩列表的表头节点， 在向用户返回节点所保存的元素之后， 调用ziplistDelete 函数删除表头节点。</td>
<td>调用 listFirst 函数定位双端链表的表头节点， 在向用户返回节点所保存的元素之后， 调用 listDelNode 函数删除表头节点。</td>
</tr>
<tr>
<td>RPOP</td>
<td>调用 ziplistIndex 函数定位压缩列表的表尾节点， 在向用户返回节点所保存的元素之后， 调用ziplistDelete 函数删除表尾节点。</td>
<td>调用 listLast 函数定位双端链表的表尾节点， 在向用户返回节点所保存的元素之后， 调用 listDelNode 函数删除表尾节点。</td>
</tr>
<tr>
<td>LINDEX</td>
<td>调用 ziplistIndex 函数定位压缩列表中的指定节点， 然后返回节点所保存的元素。</td>
<td>调用 listIndex 函数定位双端链表中的指定节点， 然后返回节点所保存的元素。</td>
</tr>
<tr>
<td>LLEN</td>
<td>调用 ziplistLen 函数返回压缩列表的长度。</td>
<td>调用 listLength 函数返回双端链表的长度。</td>
</tr>
<tr>
<td>LINSERT</td>
<td>插入新节点到压缩列表的表头或者表尾时， 使用ziplistPush 函数； 插入新节点到压缩列表的其他位置时， 使用 ziplistInsert 函数。</td>
<td>调用 listInsertNode 函数， 将新节点插入到双端链表的指定位置。</td>
</tr>
<tr>
<td>LREM</td>
<td>遍历压缩列表节点， 并调用 ziplistDelete 函数删除包含了给定元素的节点。</td>
<td>遍历双端链表节点， 并调用 listDelNode 函数删除包含了给定元素的节点。</td>
</tr>
<tr>
<td>LTRIM</td>
<td>调用 ziplistDeleteRange 函数， 删除压缩列表中所有不在指定索引范围内的节点。</td>
<td>遍历双端链表节点， 并调用 listDelNode 函数删除链表中所有不在指定索引范围内的节点。</td>
</tr>
<tr>
<td>LSET</td>
<td>调用 ziplistDelete 函数， 先删除压缩列表指定索引上的现有节点， 然后调用 ziplistInsert 函数， 将一个包含给定元素的新节点插入到相同索引上面。</td>
<td>调用 listIndex 函数， 定位到双端链表指定索引上的节点， 然后通过赋值操作更新节点的值。</td>
</tr>
</tbody>
</table>
</div>
<h3 id="Redis-哈希对象"><a href="#Redis-哈希对象" class="headerlink" title="Redis 哈希对象"></a>Redis 哈希对象</h3><p>哈希对象的编码可以是 ziplist 或者 hashtable 。</p>
<p>ziplist 编码的哈希对象使用压缩列表作为底层实现， 每当有新的键值对要加入到哈希对象时， <strong>程序会先将保存了键的压缩列表节点推入到压缩列表表尾， 然后再将保存了值的压缩列表节点推入到压缩列表表尾</strong>， 因此：</p>
<ul>
<li><strong>保存了同一键值对的两个节点总是紧挨在一起</strong>， 保存键的节点在前， 保存值的节点在后；</li>
<li><strong>先添加到哈希对象中的键值对会被放在压缩列表的表头方向， 后添加到哈希对象中的键值对会被放在压缩列表的表尾方向</strong>。</li>
</ul>
<p>如果我们执行以下 HSET 命令， 那么服务器将创建一个列表对象作为 profile 键的值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; HSET profile name &quot;Tom&quot;</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">redis&gt; HSET profile age 25</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">redis&gt; HSET profile career &quot;Programmer&quot;</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure></p>
<p>如果 profile 键的值对象使用的是 ziplist 编码， 那么这个值对象将会是图 8-9 所示的样子， 其中对象所使用的压缩列表如图 8-10 所示。<br><img src="/img/20200315235000.jpg" alt></p>
<p>另一方面， hashtable 编码的哈希对象使用字典作为底层实现， 哈希对象中的每个键值对都使用一个字典键值对来保存：</p>
<ul>
<li>字典的每个键都是一个字符串对象， 对象中保存了键值对的键；</li>
<li>字典的每个值都是一个字符串对象， 对象中保存了键值对的值。</li>
</ul>
<p><img src="/img/2015-09-13_55f52031e8254.png" alt></p>
<p>编码转换：当哈希对象可以同时满足以下两个条件时， 哈希对象使用 ziplist 编码：</p>
<ul>
<li>哈希对象保存的所有键值对的键和值的字符串长度都小于 64 字节；</li>
<li>哈希对象保存的键值对数量小于 512 个；</li>
<li>不能满足这两个条件的哈希对象需要使用 hashtable 编码。</li>
</ul>
<p>对于使用 ziplist 编码的列表对象来说， 当使用 ziplist 编码所需的两个条件的任意一个不能被满足时， 对象的编码转换操作就会被执行： 原本保存在压缩列表里的所有键值对都会被转移并保存到字典里面， 对象的编码也会从 ziplist 变为 hashtable 。</p>
<h3 id="Redis-集合对象"><a href="#Redis-集合对象" class="headerlink" title="Redis 集合对象"></a>Redis 集合对象</h3><p>集合对象的编码可以是 intset 或者 hashtable 。intset 编码的集合对象使用整数集合作为底层实现， 集合对象包含的所有元素都被保存在整数集合里面。举个例子， 以下代码将创建一个如图 8-12 所示的 intset 编码集合对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SADD numbers 1 3 5</span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/2015-09-13_55f5206caed9d.png" alt></p>
<p>另一方面， hashtable 编码的集合对象使用字典作为底层实现， 字典的每个键都是一个字符串对象， 每个字符串对象包含了一个集合元素， 而字典的值则全部被设置为 NULL 。举个例子， 以下代码将创建一个如图 8-13 所示的 hashtable 编码集合对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SADD fruits &quot;apple&quot; &quot;banana&quot; &quot;cherry&quot;</span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/2015-09-13_55f5206eae7b1.png" alt></p>
<p>编码的转换:当集合对象可以同时满足以下两个条件时， 对象使用 intset 编码：</p>
<ul>
<li>集合对象保存的所有元素都是整数值；</li>
<li>集合对象保存的元素数量不超过 512 个；</li>
<li>不能满足这两个条件的集合对象需要使用 hashtable 编码。</li>
</ul>
<p>对于使用 intset 编码的集合对象来说， 当使用 intset 编码所需的两个条件的任意一个不能被满足时， 对象的编码转换操作就会被执行： 原本保存在整数集合中的所有元素都会被转移并保存到字典里面， 并且对象的编码也会从 intset 变为 hashtable 。</p>
<h3 id="Redis-有序集合对象"><a href="#Redis-有序集合对象" class="headerlink" title="Redis 有序集合对象"></a>Redis 有序集合对象</h3><p>有序集合的编码可以是 ziplist 或者 skiplist 。ziplist 编码的有序集合对象使用压缩列表作为底层实现， 每个集合元素使用两个紧挨在一起的压缩列表节点来保存， 第一个节点保存元素的成员（member）， 而第二个元素则保存元素的分值（score）。</p>
<p>压缩列表内的集合元素按分值从小到大进行排序， 分值较小的元素被放置在靠近表头的方向， 而分值较大的元素则被放置在靠近表尾的方向。举个例子， 如果我们执行以下 ZADD 命令， 那么服务器将创建一个有序集合对象作为 price 键的值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; ZADD price 8.5 apple 5.0 banana 6.0 cherry</span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure></p>
<p>如果 price 键的值对象使用的是 ziplist 编码， 那么这个值对象将会是图 8-14 所示的样子， 而对象所使用的压缩列表则会是 8-15 所示的样子。<br><img src="/img/20200315235600.jpg" alt></p>
<p>skiplist 编码的有序集合对象使用<strong>zset</strong>结构作为底层实现， 一个 zset 结构同时包含一个字典和一个跳跃表：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef struct zset &#123;</span><br><span class="line">    zskiplist *zsl;</span><br><span class="line">    dict *dict;</span><br><span class="line">&#125; zset;</span><br></pre></td></tr></table></figure></p>
<p>zset 结构中的 zsl 跳跃表<strong>按分值从小到大保存</strong>了所有集合元素， 每个跳跃表节点都保存了一个集合元素： 跳跃表节点的 object 属性保存了元素的成员， 而跳跃表节点的 score 属性则保存了元素的分值。 通过这个跳跃表， 程序可以对有序集合进行范围型操作， 比如 ZRANK 、ZRANGE 等命令就是基于跳跃表 API 来实现的。</p>
<p>除此之外， zset 结构中的 <strong>dict 字典为有序集合创建了一个从成员到分值的映射</strong>， 字典中的每个键值对都保存了一个集合元素： 字典的键保存了元素的成员， 而字典的值则保存了元素的分值。 通过这个字典， 程序可以用 O(1) 复杂度查找给定成员的分值， ZSCORE 命令就是根据这一特性实现的， 而很多其他有序集合命令都在实现的内部用到了这一特性。</p>
<p>有序集合每个元素的成员都是一个字符串对象， 而每个元素的分值都是一个 double 类型的浮点数。 值得一提的是， 虽然 zset 结构同时使用跳跃表和字典来保存有序集合元素， 但这两种数据结构都会<strong>通过指针来共享相同元素的成员和分值</strong>， 所以同时使用跳跃表和字典来保存集合元素不会产生任何重复成员或者分值， 也不会因此而浪费额外的内存。</p>
<p>为什么有序集合需要同时使用跳跃表和字典来实现？在理论上来说， 有序集合可以单独使用字典或者跳跃表的其中一种数据结构来实现， 但无论单独使用字典还是跳跃表， 在性能上对比起同时使用字典和跳跃表都会有所降低。另一方面， 如果我们只使用跳跃表来实现有序集合， 那么跳跃表执行范围型操作的所有优点都会被保留， 但因为没有了字典， 所以根据成员查找分值这一操作的复杂度将从 O(log N) 。<br><img src="/img/2015-09-13_55f520a869916.png" alt></p>
<h4 id="有序集合命令的实现"><a href="#有序集合命令的实现" class="headerlink" title="有序集合命令的实现"></a>有序集合命令的实现</h4><p>因为有序集合键的值为有序集合对象， 所以用于有序集合键的所有命令都是针对有序集合对象来构建的， 列出了其中一部分有序集合键命令， 以及这些命令在不同编码的有序集合对象下的实现方法。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>ziplist 编码的实现方法</th>
<th>zset 编码的实现方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>ZADD</td>
<td>调用 ziplistInsert 函数， 将成员和分值作为两个节点分别插入到压缩列表。</td>
<td>先调用 zslInsert 函数， 将新元素添加到跳跃表， 然后调用 dictAdd 函数， 将新元素关联到字典。</td>
</tr>
<tr>
<td>ZCARD</td>
<td>调用 ziplistLen 函数， 获得压缩列表包含节点的数量， 将这个数量除以 2 得出集合元素的数量。</td>
<td>访问跳跃表数据结构的 length 属性， 直接返回集合元素的数量。</td>
</tr>
<tr>
<td>ZCOUNT</td>
<td>遍历压缩列表， 统计分值在给定范围内的节点的数量。</td>
<td>遍历跳跃表， 统计分值在给定范围内的节点的数量。</td>
</tr>
<tr>
<td>ZRANGE</td>
<td>从表头向表尾遍历压缩列表， 返回给定索引范围内的所有元素。</td>
<td>从表头向表尾遍历跳跃表， 返回给定索引范围内的所有元素。</td>
</tr>
<tr>
<td>ZREVRANGE</td>
<td>从表尾向表头遍历压缩列表， 返回给定索引范围内的所有元素。</td>
<td>从表尾向表头遍历跳跃表， 返回给定索引范围内的所有元素。</td>
</tr>
<tr>
<td>ZRANK</td>
<td>从表头向表尾遍历压缩列表， 查找给定的成员， 沿途记录经过节点的数量， 当找到给定成员之后， 途经节点的数量就是该成员所对应元素的排名。</td>
<td>从表头向表尾遍历跳跃表， 查找给定的成员， 沿途记录经过节点的数量， 当找到给定成员之后， 途经节点的数量就是该成员所对应元素的排名。</td>
</tr>
<tr>
<td>ZREVRANK</td>
<td>从表尾向表头遍历压缩列表， 查找给定的成员， 沿途记录经过节点的数量， 当找到给定成员之后， 途经节点的数量就是该成员所对应元素的排名。</td>
<td>从表尾向表头遍历跳跃表， 查找给定的成员， 沿途记录经过节点的数量， 当找到给定成员之后， 途经节点的数量就是该成员所对应元素的排名。</td>
</tr>
<tr>
<td>ZREM</td>
<td>遍历压缩列表， 删除所有包含给定成员的节点， 以及被删除成员节点旁边的分值节点。</td>
<td>遍历跳跃表， 删除所有包含了给定成员的跳跃表节点。 并在字典中解除被删除元素的成员和分值的关联。</td>
</tr>
<tr>
<td>ZSCORE</td>
<td>遍历压缩列表， 查找包含了给定成员的节点， 然后取出成员节点旁边的分值节点保存的元素分值。</td>
<td>直接从字典中取出给定成员的分值。</td>
</tr>
</tbody>
</table>
</div>
<h3 id="Redis-类型检查与命令多态"><a href="#Redis-类型检查与命令多态" class="headerlink" title="Redis 类型检查与命令多态"></a>Redis 类型检查与命令多态</h3><p>Redis 中用于操作键的命令基本上可以分为两种类型。其中一种命令可以对任何类型的键执行， 比如说 DEL 命令、 EXPIRE 命令、 RENAME 命令、 TYPE 命令、 OBJECT 命令， 等等。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 字符串键</span><br><span class="line">redis&gt; SET msg &quot;hello&quot;</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"># 列表键</span><br><span class="line">redis&gt; RPUSH numbers 1 2 3</span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line"># 集合键</span><br><span class="line">redis&gt; SADD fruits apple banana cherry</span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line">redis&gt; DEL msg</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">redis&gt; DEL numbers</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">redis&gt; DEL fruits</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure></p>
<p>而另一种命令只能对特定类型的键执行， 比如说：</p>
<ul>
<li>SET 、 GET 、 APPEND 、 STRLEN 等命令只能对字符串键执行；</li>
<li>HDEL 、 HSET 、 HGET 、 HLEN 等命令只能对哈希键执行；</li>
<li>RPUSH 、 LPOP 、 LINSERT 、 LLEN 等命令只能对列表键执行；</li>
<li>SADD 、 SPOP 、 SINTER 、 SCARD 等命令只能对集合键执行；</li>
<li>ZADD 、 ZCARD 、 ZRANK 、 ZSCORE 等命令只能对有序集合键执行；</li>
</ul>
<h4 id="类型检查的实现"><a href="#类型检查的实现" class="headerlink" title="类型检查的实现"></a>类型检查的实现</h4><p>从上面发生类型错误的代码示例可以看出， 为了确保只有指定类型的键可以执行某些特定的命令， 在执行一个类型特定的命令之前， Redis 会先检查输入键的类型是否正确， 然后再决定是否执行给定的命令。</p>
<p>类型特定命令所进行的类型检查是通过 redisObject 结构的 type 属性来实现的：在执行一个类型特定命令之前， 服务器会先检查输入数据库键的值对象是否为执行命令所需的类型， 如果是的话， 服务器就对键执行指定的命令；否则， 服务器将拒绝执行命令， 并向客户端返回一个类型错误。</p>
<h4 id="多态命令的实现"><a href="#多态命令的实现" class="headerlink" title="多态命令的实现"></a>多态命令的实现</h4><p>Redis 除了会根据值对象的类型来判断键是否能够执行指定命令之外， 还会根据值对象的编码方式， 选择正确的命令实现代码来执行命令。举个例子， 在前面介绍列表对象的编码时我们说过， 列表对象有 ziplist 和 linkedlist 两种编码可用， 其中前者使用压缩列表 API 来实现列表命令， 而后者则使用双端链表 API 来实现列表命令。</p>
<p>现在， 考虑这样一个情况， 如果我们对一个键执行 LLEN 命令， 那么服务器除了要确保执行命令的是列表键之外， 还需要根据键的值对象所使用的编码来选择正确的 LLEN 命令实现：</p>
<ul>
<li>如果列表对象的编码为 ziplist ， 那么说明列表对象的实现为压缩列表， 程序将使用 ziplistLen 函数来返回列表的长度；</li>
<li>如果列表对象的编码为 linkedlist ， 那么说明列表对象的实现为双端链表， 程序将使用 listLength 函数来返回双端链表的长度；</li>
</ul>
<h3 id="Redis-内存回收"><a href="#Redis-内存回收" class="headerlink" title="Redis 内存回收"></a>Redis 内存回收</h3><p>因为 C 语言并不具备自动的内存回收功能， 所以 Redis 在自己的对象系统中构建了一个引用计数（reference counting）技术实现的内存回收机制， 通过这一机制， 程序可以通过跟踪对象的引用计数信息， 在适当的时候自动释放对象并进行内存回收。</p>
<p>每个对象的引用计数信息由 redisObject 结构的 refcount 属性记录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef struct redisObject &#123;</span><br><span class="line">    // 引用计数</span><br><span class="line">    int refcount;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure></p>
<p>对象的引用计数信息会随着对象的使用状态而不断变化：</p>
<ul>
<li>在创建一个新对象时， 引用计数的值会被初始化为 1 ；</li>
<li>当对象被一个新程序使用时， 它的引用计数值会被增一；</li>
<li>当对象不再被一个程序使用时， 它的引用计数值会被减一；</li>
<li>当对象的引用计数值变为 0 时， 对象所占用的内存会被释放。</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>incrRefCount</td>
<td>将对象的引用计数值增一。</td>
</tr>
<tr>
<td>decrRefCount</td>
<td>将对象的引用计数值减一， 当对象的引用计数值等于 0 时， 释放对象。</td>
</tr>
<tr>
<td>resetRefCount</td>
<td>将对象的引用计数值设置为 0 ， 但并不释放对象， 这个函数通常在需要重新设置对象的引用计数值时使用。</td>
</tr>
</tbody>
</table>
</div>
<p>对象的整个生命周期可以划分为创建对象、操作对象、释放对象三个阶段。</p>
<p>作为例子， 以下代码展示了一个字符串对象从创建到释放的整个过程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个字符串对象 s ，对象的引用计数为 1</span><br><span class="line">robj *s = createStringObject(...)</span><br><span class="line"></span><br><span class="line">// 对象 s 执行各种操作 ...</span><br><span class="line"></span><br><span class="line">// 将对象 s 的引用计数减一，使得对象的引用计数变为 0</span><br><span class="line">// 导致对象 s 被释放</span><br><span class="line">decrRefCount(s)</span><br></pre></td></tr></table></figure></p>
<p>其他不同类型的对象也会经历类似的过程。</p>
<h3 id="Redis-对象共享"><a href="#Redis-对象共享" class="headerlink" title="Redis 对象共享"></a>Redis 对象共享</h3><p>除了用于实现引用计数内存回收机制之外， 对象的引用计数属性还带有对象共享的作用。举个例子， 假设键 A 创建了一个包含整数值 100 的字符串对象作为值对象， 如图 8-20 所示。<br><img src="/img/2015-09-13_55f5219baa7cc.png" alt></p>
<p>图 8-21 就展示了包含整数值 100 的字符串对象同时被键 A 和键 B 共享之后的样子， 可以看到， 除了对象的引用计数从之前的 1 变成了 2 之外， 其他属性都没有变化。<br><img src="/img/2015-09-13_55f5219db9ef5.png" alt></p>
<p>共享对象机制对于节约内存非常有帮助， 数据库中保存的相同值对象越多， 对象共享机制就能节约越多的内存。</p>
<p>为什么 Redis 不共享包含字符串的对象？验证操作消耗的 CPU 时间会越来越多：</p>
<ul>
<li>如果共享对象是保存整数值的字符串对象， 那么验证操作的复杂度为 O(1) ；</li>
<li>如果共享对象是保存字符串值的字符串对象， 那么验证操作的复杂度为 O(N) ；</li>
</ul>
<p>如果共享对象是包含了多个值（或者对象的）对象， 比如列表对象或者哈希对象， 那么验证操作的复杂度将会是 O(N^2) 。<br>因此， 尽管共享更复杂的对象可以节约更多的内存， 但受到 CPU 时间的限制， Redis 只对包含整数值的字符串对象进行共享。</p>
<h3 id="Redis-对象的空转时长"><a href="#Redis-对象的空转时长" class="headerlink" title="Redis 对象的空转时长"></a>Redis 对象的空转时长</h3><p>除了前面介绍过的 type 、 encoding 、 ptr 和 refcount 四个属性之外， redisObject 结构包含的最后一个属性为 lru 属性， 该属性记录了对象最后一次被命令程序访问的时间：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct redisObject &#123;</span><br><span class="line">    unsigned lru:22;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure></p>
<p>OBJECT IDLETIME 命令可以打印出给定键的空转时长， 这一空转时长就是通过将当前时间减去键的值对象的 lru 时间计算得出的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET msg &quot;hello world&quot;</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"># 等待一小段时间</span><br><span class="line">redis&gt; OBJECT IDLETIME msg</span><br><span class="line">(integer) 20</span><br><span class="line"></span><br><span class="line"># 等待一阵子</span><br><span class="line">redis&gt; OBJECT IDLETIME msg</span><br><span class="line">(integer) 180</span><br><span class="line"></span><br><span class="line"># 访问 msg 键的值</span><br><span class="line">redis&gt; GET msg</span><br><span class="line">&quot;hello world&quot;</span><br><span class="line"></span><br><span class="line"># 键处于活跃状态，空转时长为 0</span><br><span class="line">redis&gt; OBJECT IDLETIME msg</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure></p>
<p>OBJECT IDLETIME 命令的实现是特殊的， 这个命令在访问键的值对象时， 不会修改值对象的 lru 属性。</p>
<p>除了可以被 OBJECT IDLETIME 命令打印出来之外， 键的空转时长还有另外一项作用： 如果服务器打开了 maxmemory 选项， 并且服务器用于回收内存的算法为 volatile-lru 或者 allkeys-lru ， 那么当服务器占用的内存数超过了 maxmemory 选项所设置的上限值时， 空转时长较高的那部分键会优先被服务器释放， 从而回收内存。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/数据库/" rel="tag"># 数据库</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/03/11/100个网络基础知识思维导图/" rel="next" title="100 个网络基础知识 思维导图">
                <i class="fa fa-chevron-left"></i> 100 个网络基础知识 思维导图
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/03/15/跳跃表原理/" rel="prev" title="跳跃表原理">
                跳跃表原理 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/header.jpg" alt="Hao Yu">
            
              <p class="site-author-name" itemprop="name">Hao Yu</p>
              <p class="site-description motion-element" itemprop="description">Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author</p>
          </div>
          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">249</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>
        	<audio controls="controls" loop="loop" preload="auto" src="/resource/xiaomeihao.mp3">
	        </audio>
	

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yuhao0102" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:yuh18@mails.tsinghua.edu.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#数据结构与对象"><span class="nav-number">1.</span> <span class="nav-text">数据结构与对象</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#简单动态字符串"><span class="nav-number">1.1.</span> <span class="nav-text">简单动态字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#sds的定义"><span class="nav-number">1.1.1.</span> <span class="nav-text">sds的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SDS与C字符串的区别"><span class="nav-number">1.1.2.</span> <span class="nav-text">SDS与C字符串的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SDS-API"><span class="nav-number">1.1.3.</span> <span class="nav-text">SDS API</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#链表"><span class="nav-number">1.2.</span> <span class="nav-text">链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-链表和链表节点的-API"><span class="nav-number">1.2.1.</span> <span class="nav-text">Redis 链表和链表节点的 API</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字典"><span class="nav-number">1.3.</span> <span class="nav-text">字典</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-字典的实现"><span class="nav-number">1.3.1.</span> <span class="nav-text">Redis 字典的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#哈希表"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">哈希表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#哈希表节点"><span class="nav-number">1.3.1.2.</span> <span class="nav-text">哈希表节点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#字典-1"><span class="nav-number">1.3.1.3.</span> <span class="nav-text">字典</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-哈希算法"><span class="nav-number">1.3.2.</span> <span class="nav-text">Redis 哈希算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-解决键冲突"><span class="nav-number">1.3.3.</span> <span class="nav-text">Redis 解决键冲突</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-rehash"><span class="nav-number">1.3.4.</span> <span class="nav-text">Redis rehash</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-渐进式-rehash"><span class="nav-number">1.3.5.</span> <span class="nav-text">Redis 渐进式 rehash</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-字典-API"><span class="nav-number">1.3.6.</span> <span class="nav-text">Redis 字典 API</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#跳跃表"><span class="nav-number">1.4.</span> <span class="nav-text">跳跃表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#跳跃表的实现"><span class="nav-number">1.4.1.</span> <span class="nav-text">跳跃表的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-跳跃表-API"><span class="nav-number">1.4.2.</span> <span class="nav-text">Redis 跳跃表 API</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#整数集合"><span class="nav-number">1.5.</span> <span class="nav-text">整数集合</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-整数集合的实现"><span class="nav-number">1.5.1.</span> <span class="nav-text">Redis 整数集合的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis升级"><span class="nav-number">1.5.2.</span> <span class="nav-text">Redis升级</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-升级的好处"><span class="nav-number">1.5.3.</span> <span class="nav-text">Redis 升级的好处</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-降级"><span class="nav-number">1.5.4.</span> <span class="nav-text">Redis 降级</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-整数集合-API"><span class="nav-number">1.5.5.</span> <span class="nav-text">Redis 整数集合 API</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#压缩列表"><span class="nav-number">1.6.</span> <span class="nav-text">压缩列表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-压缩列表的构成"><span class="nav-number">1.6.1.</span> <span class="nav-text">Redis 压缩列表的构成</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-压缩列表节点的构成"><span class="nav-number">1.6.2.</span> <span class="nav-text">Redis 压缩列表节点的构成</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-连锁更新"><span class="nav-number">1.6.3.</span> <span class="nav-text">Redis 连锁更新</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-压缩列表-API"><span class="nav-number">1.6.4.</span> <span class="nav-text">Redis 压缩列表 API</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对象"><span class="nav-number">1.7.</span> <span class="nav-text">对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-对象的类型与编码"><span class="nav-number">1.7.1.</span> <span class="nav-text">Redis 对象的类型与编码</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#编码和底层实现"><span class="nav-number">1.7.1.1.</span> <span class="nav-text">编码和底层实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-字符串对象"><span class="nav-number">1.7.2.</span> <span class="nav-text">Redis 字符串对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#字符串命令的实现"><span class="nav-number">1.7.2.1.</span> <span class="nav-text">字符串命令的实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-列表对象"><span class="nav-number">1.7.3.</span> <span class="nav-text">Redis 列表对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#编码转换"><span class="nav-number">1.7.3.1.</span> <span class="nav-text">编码转换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#列表命令的实现"><span class="nav-number">1.7.3.2.</span> <span class="nav-text">列表命令的实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-哈希对象"><span class="nav-number">1.7.4.</span> <span class="nav-text">Redis 哈希对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-集合对象"><span class="nav-number">1.7.5.</span> <span class="nav-text">Redis 集合对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-有序集合对象"><span class="nav-number">1.7.6.</span> <span class="nav-text">Redis 有序集合对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#有序集合命令的实现"><span class="nav-number">1.7.6.1.</span> <span class="nav-text">有序集合命令的实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-类型检查与命令多态"><span class="nav-number">1.7.7.</span> <span class="nav-text">Redis 类型检查与命令多态</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#类型检查的实现"><span class="nav-number">1.7.7.1.</span> <span class="nav-text">类型检查的实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#多态命令的实现"><span class="nav-number">1.7.7.2.</span> <span class="nav-text">多态命令的实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-内存回收"><span class="nav-number">1.7.8.</span> <span class="nav-text">Redis 内存回收</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-对象共享"><span class="nav-number">1.7.9.</span> <span class="nav-text">Redis 对象共享</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-对象的空转时长"><span class="nav-number">1.7.10.</span> <span class="nav-text">Redis 对象的空转时长</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>
  <div id="DvelopmentTarget">     
  </div>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart" aria-hidden="false"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>

  
</div>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_uv"> 
  本站访客数<span id="busuanzi_value_site_uv"></span>人次
</span>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  


  

  


  <script type="text/javascript" src="/js/src/love.js"></script>

</body>
</html>
