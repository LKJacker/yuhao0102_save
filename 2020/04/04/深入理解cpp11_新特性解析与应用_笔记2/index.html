<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zn-ch">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-center-simple.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="C++,">










<meta name="description" content="新手易学，老兵易用右尖括号&amp;gt;的改进在C++98中，有一条需要规避的规则：如果在实例化模板的时候出现了连续的两个右尖括号&amp;gt;，那么它们之间需要一个空格来进行分隔，以避免发生编译时的错误。示例如下：123456789// 示例1：嵌套的模板标识template &amp;lt;int i&amp;gt;  class X &amp;#123;&amp;#125;;template &amp;lt;class T&amp;gt; class">
<meta name="keywords" content="C++">
<meta property="og:type" content="article">
<meta property="og:title" content="深入理解C++11_新特性解析与应用 笔记2">
<meta property="og:url" content="http://yoursite.com/2020/04/04/深入理解cpp11_新特性解析与应用_笔记2/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="新手易学，老兵易用右尖括号&amp;gt;的改进在C++98中，有一条需要规避的规则：如果在实例化模板的时候出现了连续的两个右尖括号&amp;gt;，那么它们之间需要一个空格来进行分隔，以避免发生编译时的错误。示例如下：123456789// 示例1：嵌套的模板标识template &amp;lt;int i&amp;gt;  class X &amp;#123;&amp;#125;;template &amp;lt;class T&amp;gt; class">
<meta property="og:locale" content="zn-ch">
<meta property="og:image" content="http://yoursite.com/img/20200405175700.jpg">
<meta property="og:image" content="http://yoursite.com/img/20200405204600.jpg">
<meta property="og:image" content="http://yoursite.com/img/20200405211800.jpg">
<meta property="og:image" content="http://yoursite.com/img/20200405215200.jpg">
<meta property="og:updated_time" content="2020-04-05T13:42:36.445Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="深入理解C++11_新特性解析与应用 笔记2">
<meta name="twitter:description" content="新手易学，老兵易用右尖括号&amp;gt;的改进在C++98中，有一条需要规避的规则：如果在实例化模板的时候出现了连续的两个右尖括号&amp;gt;，那么它们之间需要一个空格来进行分隔，以避免发生编译时的错误。示例如下：123456789// 示例1：嵌套的模板标识template &amp;lt;int i&amp;gt;  class X &amp;#123;&amp;#125;;template &amp;lt;class T&amp;gt; class">
<meta name="twitter:image" content="http://yoursite.com/img/20200405175700.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/04/04/深入理解cpp11_新特性解析与应用_笔记2/">





  <title>深入理解C++11_新特性解析与应用 笔记2 | Hao Yu's blog</title>
  








 
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zn-ch">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hao Yu's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">The program monkey was eaten by the siege lion.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/resume.pdf" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-mybetterhalf">
          <a href="/mybetterhalf/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>
            
            mybetterhalf
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/04/深入理解cpp11_新特性解析与应用_笔记2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">深入理解C++11_新特性解析与应用 笔记2</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-04-04T16:21:00+08:00">
                2020-04-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="新手易学，老兵易用"><a href="#新手易学，老兵易用" class="headerlink" title="新手易学，老兵易用"></a>新手易学，老兵易用</h1><h2 id="右尖括号-gt-的改进"><a href="#右尖括号-gt-的改进" class="headerlink" title="右尖括号&gt;的改进"></a>右尖括号&gt;的改进</h2><p>在C++98中，有一条需要规避的规则：如果在实例化模板的时候出现了连续的两个右尖括号&gt;，那么它们之间需要一个空格来进行分隔，以避免发生编译时的错误。示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 示例1：嵌套的模板标识</span><br><span class="line">template &lt;int i&gt;  class X &#123;&#125;;</span><br><span class="line">template &lt;class T&gt; class Y &#123;&#125;;</span><br><span class="line">Y&lt;X&lt;1&gt; &gt; x1; // 编译成功</span><br><span class="line">Y&lt;X&lt;1&gt;&gt; x2;  // 编译失败</span><br><span class="line"></span><br><span class="line">// 示例2：强制转换</span><br><span class="line">const vector&lt;int&gt; v = static_cast&lt;vector&lt;int&gt; &gt;(v); // 编译成功</span><br><span class="line">const vector&lt;int&gt; v = static_cast&lt;vector&lt;int&gt;&gt;(v);  // 编译失败</span><br></pre></td></tr></table></figure></p>
<p>如此的限制，在C++11新标准中被取消了。但是，这些“智能”的判断也会带来一些与C++98的有趣的不兼容性。比如用户只是想让&gt;&gt;在模板的实例化中表示的是真正的右移，但是C++11会把它解析为模板参数界定符。示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">template &lt;int i&gt; class X &#123;&#125;; </span><br><span class="line">X &lt; 1 &gt;&gt; 5 &gt; x; // 编译失败</span><br><span class="line">X &lt;(1 &gt;&gt; 5)&gt; x; // 编译成功</span><br></pre></td></tr></table></figure></p>
<p>使用C++98标准进行编译的话，这个例子会编译通过。因为编译器认为X<1>&gt;5&gt;x;中的双尖括号是一个位移操作，那么最终可以得到一个形如X<0>x的模板实例。如果使用C++11标准进行编译，那么程序员会得到一个编译错误的警告，因为编译器优先将双尖括号中的第一个&gt;与X之后的&lt;进行了配对。</0></1></p>
<p>虽然很少有人在模板实例化时同时进行位移操作，但是从语法上来说，C++98和C++11确实在这一点上不兼容。要避免这样的不兼容性也很简单，使用圆括号将“1&gt;&gt;5”括起来（如示例中编译成功的写法），保证右移操作优先，就不会出现类似问题了。</p>
<h2 id="auto类型推导"><a href="#auto类型推导" class="headerlink" title="auto类型推导"></a>auto类型推导</h2><h3 id="静态类型、动态类型与类型推导"><a href="#静态类型、动态类型与类型推导" class="headerlink" title="静态类型、动态类型与类型推导"></a>静态类型、动态类型与类型推导</h3><p>静态类型和动态类型的主要区别在于对变量进行类型检查的时间点：</p>
<ul>
<li>静态类型，类型检查主要发生在编译阶段；</li>
<li>动态类型，类型检查主要发生在运行阶段。</li>
</ul>
<p>auto声明的变量必须被初始化，以使编译器能够从其初始化表达式中推导出其类型。从这个意义上来讲，auto并非一种“类型”声明，而是一个类型声明时的“占位符”，编译器在编译时期会将auto替代为变量实际的类型。</p>
<h3 id="auto的优势"><a href="#auto的优势" class="headerlink" title="auto的优势"></a>auto的优势</h3><ul>
<li>auto推导的一个最大优势就是在拥有初始化表达式的复杂类型变量声明时简化代码。</li>
<li>可以免除程序员在一些类型声明时的麻烦，或者避免一些在类型声明时的错误。</li>
<li>就是其“自适应”特性能够在一定程度上支持泛型的编程。</li>
<li>auto还会在一些情况下取得意想不到的好效果。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define MAX1(a, b) ((a) &gt; (b)) ? (a) : (b)</span><br><span class="line">#define MAX2(a, b, max) &#123; \</span><br><span class="line">    auto _a = (a); \</span><br><span class="line">    auto _b = (b); \</span><br><span class="line">    max = (_a &gt; _b) ? _a : _b; &#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int m1 = MAX1(1 * 2 * 3 * 4, 5 + 6 + 7 + 8);</span><br><span class="line">    cout &lt;&lt; m1 &lt;&lt; endl;  // 26</span><br><span class="line">    int m2 = 0;</span><br><span class="line">    MAX2(1 * 2 * 3 * 4, 5 + 6 + 7 + 8, m2);</span><br><span class="line">    cout &lt;&lt; m2 &lt;&lt; endl;  // 26</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义了两种类型的宏Max1和Max2。两者作用相同，都是求a和b中较大者并返回。前者采用传统的三元运算符表达式，这可能会带来一定的性能问题。因为，a或b在三元运算符中都出现了两次，那么，无论是取a还是取b，其中之一都会被运算两次。而在Max2中，我们将a和b都先算出来，再使用三元运算符进行比较，就不会存在这样的问题了。在传统的C++98标准中，由于a和b的类型无法获得，所以我们无法定义Max2这样高性能的宏。而新的标准中的auto则提供了这种可行性。</p>
<h3 id="auto的应用细则"><a href="#auto的应用细则" class="headerlink" title="auto的应用细则"></a>auto的应用细则</h3><p>（1）auto可以与指针和引用结合起来使用。示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int x; </span><br><span class="line">int* y = &amp;x; </span><br><span class="line">double foo();</span><br><span class="line">int&amp; bar();</span><br><span class="line">auto* a = &amp;x;  // int* </span><br><span class="line">auto &amp; b = x;  // int&amp; </span><br><span class="line">auto c = y;    // int* </span><br><span class="line">auto * d = y;  // int* </span><br><span class="line">auto * e = &amp;foo(); // 编译失败, 指针不能指向一个临时变量</span><br><span class="line">auto &amp; f = foo();  // 编译失败, nonconst的左值引用不能和一个临时变量绑定 </span><br><span class="line">auto g = bar();    // int</span><br><span class="line">auto &amp; h = bar();  // int&amp;</span><br></pre></td></tr></table></figure></p>
<p>（2）auto可以与cv限制符一起使用，不过声明为auto的变量并不能从其初始化表达式中“带走”cv限制符。volatile和const代表了变量的两种不同的属性：易失的和常量的。在C++标准中，它们常常被一起叫作cv限制符（cv-qualifier）。示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">double foo() &#123;&#125;;</span><br><span class="line">float* bar() &#123;&#125;;</span><br><span class="line">const auto a = foo();      // a: const double </span><br><span class="line">const auto &amp; b = foo();    // b: const double&amp; </span><br><span class="line">volatile auto * c = bar(); // c: volatile float * </span><br><span class="line">auto d = a;                // d: double</span><br><span class="line">auto &amp; e = a;              // e: const double &amp;</span><br><span class="line">auto f = c;                // f: float * volatile</span><br><span class="line">auto &amp; g = c;              // g: volatile float * &amp;</span><br></pre></td></tr></table></figure></p>
<p>可以通过非cv限制的类型初始化一个cv限制的类型，如变量a、b、c所示。不过通过auto声明的变量d、f却无法带走a和f的常量性或者易失性。这里的例外还是引用，可以看出，声明为引用的变量e、g都保持了其引用的对象相同的属性（事实上，指针也是一样的）。</p>
<p>（3）同一个赋值语句中，auto可以用来声明多个变量的类型，不过这些变量的类型必须相同。如果这些变量的类型不相同，编译器则会报错。事实上，用auto来声明多个变量类型时，只有第一个变量用于auto的类型推导，然后推导出来的数据类型被作用于其他的变量。所以不允许这些变量的类型不相同。示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">auto x = 1, y = 2;  // x和y的类型均为int </span><br><span class="line">// m是一个指向const int类型变量的指针, n是一个int类型的变量 </span><br><span class="line">const auto* m = &amp;x, n = 1;</span><br><span class="line">auto i = 1, j = 3. 14f;      // 编译失败</span><br><span class="line">auto o = 1, &amp;p = o, *q = &amp;p; // 从左向右推导</span><br></pre></td></tr></table></figure></p>
<p>auto的类型推导是按照从左往右，而且类似于字面替换的方式进行。</p>
<p>（4）初始化列表，以及new，都可以使用auto关键字。示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;initializer_list&gt;</span><br><span class="line">auto x = 1;</span><br><span class="line">auto x1(1);</span><br><span class="line">auto y &#123;1&#125;;           // 用于初始化列表的auto</span><br><span class="line">auto z = new auto(1); // 用于new</span><br></pre></td></tr></table></figure></p>
<p>auto可以保证使用初始化列表仍然可以正确推导。</p>
<p>auto也有使用上的限制：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void fun(auto x =1)&#123;&#125;  // 1: auto函数参数，无法通过编译</span><br><span class="line"></span><br><span class="line">struct str&#123;</span><br><span class="line">    auto var = 10;   // 2: auto非静态成员变量，无法通过编译</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    char x[3];</span><br><span class="line">    auto y = x;</span><br><span class="line">    auto z[3] = x; // 3: auto数组，无法通过编译</span><br><span class="line"></span><br><span class="line">    // 4: auto模板参数（实例化时），无法通过编译</span><br><span class="line">    vector&lt;auto&gt; x = &#123;1&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>4种不能推导的情况：</p>
<ul>
<li>对于函数fun来说，auto不能是其形参类型。auto是不能做形参的类型的。如果程序员需要泛型的参数，还是需要求助于模板。</li>
<li>对于结构体来说，非静态成员变量的类型不能是auto的。编译器阻止auto对结构体中的非静态成员进行推导，即使成员拥有初始值。</li>
<li>声明auto数组。我们可以看到，main中的x是一个数组，y的类型是可以推导的，而声明auto z[3]这样的数组同样会被编译器禁止。</li>
<li>在实例化模板的时候使用auto作为模板参数，如main中我们声明的<code>vector&lt;auto&gt; v</code>，虽然读者可能认为这里一眼而知是int类型，但编译器却阻止了编译。</li>
</ul>
<h2 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h2><h3 id="typeid与decltype"><a href="#typeid与decltype" class="headerlink" title="typeid与decltype"></a>typeid与decltype</h3><p>C++98对动态类型支持就是C++中的运行时类型识别（RTTI）。RTTI的机制是为每个类型产生一个type_info类型的数据，可以在程序中使用typeid随时查询一个变量的类型，typeid就会返回变量相应的type_info数据。type_info的name成员函数可以返回类型的名字。而在C++11中，又增加了hash_code这个成员函数，<strong>返回该类型唯一的哈希值</strong>，以供程序员对变量的类型随时进行比较。应用示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt; </span><br><span class="line">#include &lt;typeinfo&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class White &#123;&#125;;</span><br><span class="line">class Black &#123;&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    White a;</span><br><span class="line">    Black b;</span><br><span class="line">    cout &lt;&lt; typeid(a).name() &lt;&lt; endl; // class White</span><br><span class="line">    cout &lt;&lt; typeid(b).name() &lt;&lt; endl; // class Black</span><br><span class="line">    White c; </span><br><span class="line">    bool a_b_sametype = (typeid(a).hash_code() == typeid(b).hash_code());</span><br><span class="line">    bool a_c_sametype = (typeid(a).hash_code() == typeid(c).hash_code()); </span><br><span class="line">    cout &lt;&lt; &quot;Same type? &quot; &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;A and B? &quot; &lt;&lt; (int)a_b_sametype &lt;&lt; endl; // 0</span><br><span class="line">    cout &lt;&lt; &quot;A and C? &quot; &lt;&lt; (int)a_c_sametype &lt;&lt; endl; // 1</span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*运行结果</span><br><span class="line">class White</span><br><span class="line">class Black</span><br><span class="line">Same type?</span><br><span class="line">A and B? 0</span><br><span class="line">A and C? 1</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></p>
<p>值得注意一点：相比于is_same模板函数的成员类型value在编译时得到信息，hash_code是运行时得到的信息。除了typeid以外，RTT i还包括了C++中的dynamic_cast等特性。</p>
<p>与auto类似地，decltype也能进行类型推导。下面分析两者的异同：</p>
<p>[1] decltype与auto的不同点：使用方式有一定的区别。示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;typeinfo&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    decltype(i) j = 0;</span><br><span class="line">    cout &lt;&lt; typeid(j).name() &lt;&lt; endl; // int</span><br><span class="line">    float a;</span><br><span class="line">    double b;</span><br><span class="line">    decltype(a + b) c;</span><br><span class="line">    cout &lt;&lt; typeid(c).name() &lt;&lt; endl; // double</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*运行结果</span><br><span class="line">int</span><br><span class="line">double</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></p>
<p>看到变量j的类型由decltype(i)进行声明，表示j的类型跟i相同（或者准确地说，跟i这个表达式返回的类型相同）。而c的类型则跟(a+b)这个表达式返回的类型相同。由于a+b加法表达式返回的类型为double（a会被扩展为double类型与b相加），所以c的类型被decltype推导为double。</p>
<p>从这个例子中可以看到，decltype的类型推导并不是像auto一样是从变量声明的初始化表达式获得变量的类型，decltype总是以一个普通的表达式为参数，返回该表达式的类型。</p>
<p>[2] decltype与auto的相同点：作为一个类型指示符，decltype也可以将获得的类型来定义另外一个变量；decltype类型推导也是在编译时进行的。</p>
<h3 id="decltype的应用"><a href="#decltype的应用" class="headerlink" title="decltype的应用"></a>decltype的应用</h3><p>在C++11中，使用decltype推导类型是非常常见。</p>
<p>（1）decltype与typdef/using的合用。示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">using size_t = decltype(sizeof(0));</span><br><span class="line">using ptrdiff_t = decltype((int*)0 - (int*)0);</span><br><span class="line">using nullptr_t = decltype(nullptr);</span><br></pre></td></tr></table></figure></p>
<p>（2）decltype在某些场景下，可以极大地增加代码的可读性。定义了vector的iterator的类型，这个类型还可以在main函数中宠用，利用decltype和typedef/using组合将其转换为一个其他的表达式。示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() </span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;int&gt; vec;</span><br><span class="line">    typedef decltype(vec.begin()) vectype;</span><br><span class="line">    for (vectype i = vec.begin(); i &lt; vec.end(); ++i) </span><br><span class="line">    &#123; </span><br><span class="line">        // TODO...</span><br><span class="line">    &#125; </span><br><span class="line">    for (decltype(vec)::iterator i = vec. begin(); i &lt; vec. end(); ++i)</span><br><span class="line">    &#123; </span><br><span class="line">        // TODO...</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>（3）重用匿名类型的利器。这里使用了三种匿名类型。示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">enum &#123;K1, K2, K3 &#125; anon_e; // 匿名的枚举</span><br><span class="line"></span><br><span class="line">union</span><br><span class="line">&#123; </span><br><span class="line">    decltype(anon_e) key; </span><br><span class="line">    char* name;</span><br><span class="line">&#125; anon_u; // 匿名的union联合体</span><br><span class="line"></span><br><span class="line">struct </span><br><span class="line">&#123; </span><br><span class="line">    int d; </span><br><span class="line">    decltype(anon_u) id;</span><br><span class="line">&#125; anon_s[100];  // 匿名的struct数组</span><br><span class="line"></span><br><span class="line">int main() </span><br><span class="line">&#123;</span><br><span class="line">    decltype(anon_s) as;</span><br><span class="line">    as[0].id.key = decltype(anon_e)::K1; // 引用匿名类型枚举中的值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>（4）扩大模板泛型的能力。增加了类型为decltype(t1+t2)的s作为参数，而函数本身不返回任何值，这样一来函数的使用范围就增加了，返回类型不限于单一的double，而是根据t1+t2推导。示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T1, typename T2&gt;</span><br><span class="line">void Sum(T1&amp; t1, T2&amp; t2, decltype(t1 + t2)&amp; s)</span><br><span class="line">&#123;</span><br><span class="line">    s = t1 + t2; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a = 3;</span><br><span class="line">    long b = 5;</span><br><span class="line">    float c = 1.0f, d = 2.3f;</span><br><span class="line">    long e;</span><br><span class="line">    float f;</span><br><span class="line">    Sum(a, b, e);  // s的类型被推导为long</span><br><span class="line">    Sum(c, d, f);  // s的类型被推导为float</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>（5）实例化模板。通过decltype(hash(nullptr))确定哈希值的类型。示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int getHash(char*);</span><br><span class="line"></span><br><span class="line">map&lt;char*, decltype(getHash)&gt; dict_key;             // 编译失败</span><br><span class="line">map&lt;char*, decltype(getHash(nullptr)) &gt; dict_key1;  // 编译成功</span><br><span class="line"></span><br><span class="line">double getValue(int* p = nullptr);</span><br><span class="line">map&lt;int*, decltype(getValue())&gt; dict_key3;          // 编译成功</span><br></pre></td></tr></table></figure></p>
<p>（6）在标准库中的一些应用。示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;type_traits&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef double (*func)();</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123; </span><br><span class="line">    result_of&lt;func()&gt;::type f;  // 由func()推导其结果类型</span><br><span class="line">&#125;</span><br><span class="line">result_of的可能实现是:</span><br><span class="line">template&lt;class F, class... ArgTypes&gt;</span><br><span class="line">struct result_of&lt;F(ArgTypes)&gt; &#123;</span><br><span class="line">    typedef decltype(</span><br><span class="line">        std::declval&lt;F&gt;()(std::declval&lt;ArgTypes&gt;()...)</span><br><span class="line">    ) type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>decltype推导规则：</p>
<ul>
<li>e是没有带括号的标记符表达式或者类成员访问表达式，那么decltype(e)就是e的实体类型。则推导原类型<ul>
<li>写法decltype(e)</li>
<li>注意当e为表达式（函数）时，其函数不能重载，否则编译失败</li>
</ul>
</li>
<li>e带括号时：<ul>
<li>写法decltype((e))</li>
<li>推导如下：<ul>
<li>若e的值为将亡值，则decltype结果为T&amp;&amp;</li>
<li>若e的值为左值，则decltype结果为T&amp;</li>
<li>若e的值为纯右值，则decltype结果为T</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;typeinfo&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int i = 4;</span><br><span class="line">int arr[5] = &#123;0&#125;;</span><br><span class="line">int *ptr = arr;</span><br><span class="line"></span><br><span class="line">struct S &#123; double d; &#125; s;</span><br><span class="line"></span><br><span class="line">void Overloaded(int);</span><br><span class="line">void Overloaded(char);      // 重载的函数</span><br><span class="line"></span><br><span class="line">int &amp;&amp; RvalRef();</span><br><span class="line"></span><br><span class="line">const bool Func(int);</span><br><span class="line"></span><br><span class="line">// 规则1: 单个标记符表达式以及访问类成员，推导为本类型</span><br><span class="line">decltype(arr) var1;            // int[5], 标记符表达式</span><br><span class="line">decltype(ptr) var2;            // int*, 标记符表达式</span><br><span class="line">decltype(s.d) var4;            // double, 成员访问表达式</span><br><span class="line">decltype(Overloaded) var5;     // 无法通过编译，是个重载的函数</span><br><span class="line"></span><br><span class="line">// 规则2: 将亡值，推导为类型的右值引用</span><br><span class="line">decltype(RvalRef()) var6 = 1;  // int&amp;&amp;</span><br><span class="line"></span><br><span class="line">// 规则3: 左值，推导为类型的引用</span><br><span class="line">decltype(true ? i : i) var7 = i;    // int&amp;, 三元运算符，这里返回一个i的左值</span><br><span class="line">decltype((i)) var8 = i;             // int&amp;, 带圆括号的左值 </span><br><span class="line">decltype(++i) var9 = i;             // int&amp;, ++i返回i的左值</span><br><span class="line">decltype(arr[3]) var10 = i;         // int&amp; []操作返回左值</span><br><span class="line">decltype(*ptr)  var11 = i;          // int&amp; *操作返回左值</span><br><span class="line">decltype(&quot;lval&quot;) var12 = &quot;lval&quot;;    // const char(&amp;)[9], 字符串字面常量为左值</span><br><span class="line"></span><br><span class="line">// 规则4：以上都不是，推导为本类型</span><br><span class="line">decltype(1) var13;              // int, 除字符串外字面常量为右值</span><br><span class="line">decltype(i++) var14;            // int, i++返回右值</span><br><span class="line">decltype((Func(1))) var15;      // const bool, 圆括号可以忽略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>增加了一些模板类，帮助进行推导结果的识别：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;type_traits&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int i = 4;</span><br><span class="line">int arr[5] = &#123;0&#125;;</span><br><span class="line">int *ptr = arr;</span><br><span class="line"></span><br><span class="line">int &amp;&amp; RvalRef();</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    cout &lt;&lt; is_rvalue_reference&lt;decltype(RvalRef())&gt;::value &lt;&lt; endl;    // 1</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; is_lvalue_reference&lt;decltype(true ? i : i)&gt;::value &lt;&lt; endl; // 1</span><br><span class="line">    cout &lt;&lt; is_lvalue_reference&lt;decltype((i))&gt;::value &lt;&lt; endl;          // 1</span><br><span class="line">    cout &lt;&lt; is_lvalue_reference&lt;decltype(++i)&gt;::value &lt;&lt; endl;          // 1</span><br><span class="line">    cout &lt;&lt; is_lvalue_reference&lt;decltype(arr[3])&gt;::value &lt;&lt; endl;       // 1</span><br><span class="line">    cout &lt;&lt; is_lvalue_reference&lt;decltype(*ptr)&gt;::value &lt;&lt; endl;         // 1</span><br><span class="line">    cout &lt;&lt; is_lvalue_reference&lt;decltype(&quot;lval&quot;)&gt;::value &lt;&lt; endl;       // 1</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; is_lvalue_reference&lt;decltype(i++)&gt;::value &lt;&lt; endl;          // 0</span><br><span class="line">    cout &lt;&lt; is_rvalue_reference&lt;decltype(i++)&gt;::value &lt;&lt; endl;          // 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>与auto不同点：auto类型推导时不能“带走”cv限制符不同。decltype是能够“带走”表达式的cv限制符的。但是，如果对象的定义中有const或volatile限制符，使用decltype进行推导时，其成员变量不会继承const或volatile限制符。示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;type_traits&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int ic = 0;</span><br><span class="line">volatile int iv;</span><br><span class="line"></span><br><span class="line">struct S &#123; int i; &#125;;</span><br><span class="line"></span><br><span class="line">const S a = &#123;0&#125;;</span><br><span class="line">volatile S b;</span><br><span class="line">volatile S* p = &amp;b;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    cout &lt;&lt; is_const&lt;decltype(ic)&gt;::value &lt;&lt; endl;      // 1</span><br><span class="line">    cout &lt;&lt; is_volatile&lt;decltype(iv)&gt;::value &lt;&lt; endl;   // 1</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; is_const&lt;decltype(a)&gt;::value &lt;&lt; endl;       // 1</span><br><span class="line">    cout &lt;&lt; is_volatile&lt;decltype(b)&gt;::value &lt;&lt; endl;    // 1</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; is_const&lt;decltype(a.i)&gt;::value &lt;&lt; endl;     // 0, 成员不是const</span><br><span class="line">    cout &lt;&lt; is_volatile&lt;decltype(p-&gt;i)&gt;::value &lt;&lt; endl; // 0, 成员不是volatile</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>与auto相同点：decltype从表达式推导出类型后，进行类型定义时，也会允许一些冗余的符号，比如cv限制符以及引用符号&amp;。但是，通常情况下，如果推导出的类型已经有了这些属性，冗余的符号则会被忽略。示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;type_traits&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int i = 1;</span><br><span class="line">int &amp; j = i;</span><br><span class="line">int * p = &amp;i;</span><br><span class="line">const int k = 1;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    decltype(i) &amp; var1 = i; </span><br><span class="line">    decltype(j) &amp; var2 = i;     // 冗余的&amp;, 被忽略 </span><br><span class="line">        </span><br><span class="line">    cout &lt;&lt; is_lvalue_reference&lt;decltype(var1)&gt;::value &lt;&lt; endl;     // 1, 是左值引用</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; is_rvalue_reference&lt;decltype(var2)&gt;::value &lt;&lt; endl;     // 0, 不是右值引用</span><br><span class="line">    cout &lt;&lt; is_lvalue_reference&lt;decltype(var2)&gt;::value &lt;&lt; endl;     // 1, 只是左值引用</span><br><span class="line"></span><br><span class="line">    //decltype(p)* var3 = &amp;i;     // 无法通过编译</span><br><span class="line">    decltype(p)* var3 = &amp;p;     // var3的类型是int**</span><br><span class="line"></span><br><span class="line">    auto* v3 = p;               // v3的类型是int*</span><br><span class="line">    v3 = &amp;i;</span><br><span class="line"></span><br><span class="line">    const decltype(k) var4 = 1; // 冗余的const，被忽略 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意<code>decltype(p)*</code>，在定义var3的时候，由于p的类型是<code>int*</code>，因此var3被定义为<code>int**</code>，这跟auto中<code>*</code>会被忽略不同，在decltype后的<code>*</code>，并不会被忽略。</p>
<h2 id="追踪返回类型"><a href="#追踪返回类型" class="headerlink" title="追踪返回类型"></a>追踪返回类型</h2><h3 id="追踪返回类型的引入"><a href="#追踪返回类型的引入" class="headerlink" title="追踪返回类型的引入"></a>追踪返回类型的引入</h3><p>由编译器来推导函数模板的返回类型。最直观的写法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T1, typename T2&gt;</span><br><span class="line">decltype(t1+t2) Sum(T1 &amp; t1, T2 &amp; t2) &#123;</span><br><span class="line">    return t1 + t2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是t1和t2在使用的时候尚未声明。因此使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T1, typename T2&gt;</span><br><span class="line">auto Sum(T1 &amp; t1, T2 &amp; t2) -&gt; decltype(t1+t2) &#123;</span><br><span class="line">    return t1 + t2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="使用追踪返回类型的函数"><a href="#使用追踪返回类型的函数" class="headerlink" title="使用追踪返回类型的函数"></a>使用追踪返回类型的函数</h3><p>追踪返回类型的函数与普通函数的最大区别在于返回类型后置。也不用写作用域了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class OuterType</span><br><span class="line"> &#123;</span><br><span class="line">     struct InnerType &#123; int i; &#125;;</span><br><span class="line">     InnerType GetInner();</span><br><span class="line">     InnerType it;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> // 可以不写OuterType::InnerType</span><br><span class="line"> auto OuterType::GetInner()-&gt;InnerType</span><br><span class="line"> &#123;</span><br><span class="line">     return it;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>返回类型后置，使模板类中的一些类型推导成为可能，编译器会进行合理的推导：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template&lt;typename T1, typename T2&gt;</span><br><span class="line">auto Sum(const T1 &amp; t1, const T2 &amp; t2) -&gt; decltype(t1 + t2)&#123;</span><br><span class="line">    return t1 + t2; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">template &lt;typename T1, typename T2&gt;</span><br><span class="line">auto Mul(const T1 &amp; t1, const T2 &amp; t2) -&gt; decltype(t1 * t2)&#123;</span><br><span class="line">    return t1 * t2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    auto a = 3;</span><br><span class="line">    auto b = 4L;</span><br><span class="line">    auto pi = 3.14;</span><br><span class="line">    </span><br><span class="line">    auto c = Mul(Sum(a, b), pi);</span><br><span class="line">    cout &lt;&lt; c &lt;&lt; endl;  // 21.98</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>追踪返回类型的另一个优势是简化函数的定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;type_traits&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">// 有的时候，你会发现这是面试题</span><br><span class="line">int (*(*pf())())() &#123;</span><br><span class="line">    return nullptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// auto (*)() -&gt; int(*) () 一个返回函数指针的函数(假设为a函数)</span><br><span class="line">// auto pf1() -&gt; auto (*)() -&gt; int (*)() 一个返回a函数的指针的函数</span><br><span class="line">auto pf1() -&gt; auto (*)() -&gt; int (*)() &#123;</span><br><span class="line">    return nullptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    cout &lt;&lt; is_same&lt;decltype(pf), decltype(pf1)&gt;::value &lt;&lt; endl;    // 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>定义了两个类型完全一样的函数pf和pf1，返回的都是一个函数指针，而该函数指针又指向一个返回函数指针的函数。跟踪返回类型只需要依照从左往右的方式，就可将嵌套的声明解析出来。</p>
<p>跟踪返回类型还可用在函数指针上，其声明方式和追踪返回类型的函数比起来，并没有太大区别：<code>auto (*fp)()</code>和<code>int (*fp)()</code>的函数指针声明是等价的。</p>
<h2 id="基于范围的for"><a href="#基于范围的for" class="headerlink" title="基于范围的for"></a>基于范围的for</h2><p>C++标准库中，利用模板库std::for_each写法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int action1(int &amp; e)&#123; e *= 2; &#125;</span><br><span class="line">int action2(int &amp; e)&#123; cout &lt;&lt; e &lt;&lt; &apos;\t&apos;; &#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int arr[5] = &#123; 1, 2, 3, 4, 5&#125;;</span><br><span class="line">    for_each(arr, arr + sizeof(arr)/sizeof(arr[0]), action1);</span><br><span class="line">    for_each(arr, arr + sizeof(arr)/sizeof(arr[0]), action2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>for_each使用了迭代器的概念，其迭代器就是指针。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int arr[5] = &#123; 1, 2, 3, 4, 5 &#125;;</span><br><span class="line">    for (int &amp; e: arr)</span><br><span class="line">        e *= 2;</span><br><span class="line"></span><br><span class="line">    for (int &amp; e: arr)</span><br><span class="line">        cout &lt;&lt; e &lt;&lt; &apos;\t&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>是否能够使用基于范围的for循环，必须：</p>
<ul>
<li>for循环迭代的范围是可确定的，对于类来说必须是有begin和end的，对于数组，就是数组的第一个和最后一个元素之间的范围。</li>
<li>其次基于范围的for循环，要求迭代对象实现++和==操作。</li>
</ul>
<p>数组大小不定的情况是不能用的，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int func(int a[]) &#123;</span><br><span class="line"></span><br><span class="line">    for (auto e: a) // 编译失败</span><br><span class="line">        cout &lt;&lt; e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int arr[] = &#123;1, 2, 3, 4, 5&#125;;</span><br><span class="line">    func(arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="提高类型安全"><a href="#提高类型安全" class="headerlink" title="提高类型安全"></a>提高类型安全</h1><h2 id="强类型枚举"><a href="#强类型枚举" class="headerlink" title="强类型枚举"></a>强类型枚举</h2><p>枚举要定义一个类别，并穷举同一类别下的个体以供代码中使用。比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enum Gender &#123;Male, Female&#125;;</span><br></pre></td></tr></table></figure></p>
<p>定义了Gender类型，默认为Male赋值为0，为Female赋值为1。可以定义匿名枚举<code>enum {Male, Female};</code>，其中的Male和Female都是编译时期的名字。</p>
<p>不过更受推荐的是静态常量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const static int Male = 0;</span><br><span class="line">const static int Female = 1;</span><br></pre></td></tr></table></figure></p>
<p>编译器可能为静态常量在目标代码中产生实际的数据，这会增加一些存储空间。</p>
<p>由于枚举存在一些缺陷，通常对枚举类型进行一些封装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Type &#123;</span><br><span class="line">public:</span><br><span class="line">    enum type &#123; general, light, medium, heavy &#125;;</span><br><span class="line">    type val;</span><br><span class="line">public:</span><br><span class="line">    Type(type t): val(t)&#123;&#125;</span><br><span class="line">    bool operator &gt;= (const Type &amp; t) &#123; return val &gt;= t.val; &#125;</span><br><span class="line">    static const Type General, Light, Medium, Heavy;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">const Type Type::General(Type::general);</span><br><span class="line">const Type Type::Light(Type::light);</span><br><span class="line">const Type Type::Medium(Type::medium);</span><br><span class="line">const Type Type::Heavy(Type::heavy);</span><br><span class="line"></span><br><span class="line">class Category &#123;</span><br><span class="line">public:</span><br><span class="line">    enum category &#123; pistol, machineGun, cannon &#125;;</span><br><span class="line">    category val;</span><br><span class="line">public:</span><br><span class="line">    Category(category c): val(c) &#123;&#125;</span><br><span class="line">    bool operator &gt;= (const Category &amp; c) &#123; return val &gt;= c.val; &#125;</span><br><span class="line">    static const Category Pistol, MachineGun, Cannon;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const Category Category::Pistol(Category::pistol);</span><br><span class="line">const Category Category::MachineGun(Category::machineGun);</span><br><span class="line">const Category Category::Cannon(Category::cannon);</span><br><span class="line"></span><br><span class="line">struct Killer &#123;</span><br><span class="line">    Killer(Type t, Category c) : type(t), category(c)&#123;&#125;</span><br><span class="line">    Type type;</span><br><span class="line">    Category category;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    // 使用类型包装后的enum</span><br><span class="line">    Killer notCool(Type::General, Category::MachineGun);</span><br><span class="line">    // ...</span><br><span class="line">    // ...其它很多代码...</span><br><span class="line">    // ...</span><br><span class="line">    if (notCool.type &gt;= Type::General)   // 可以通过编译</span><br><span class="line">        cout &lt;&lt; &quot;It is not general&quot; &lt;&lt; endl;</span><br><span class="line">#if 0</span><br><span class="line">    if (notCool.type &gt;= Category::Pistol)   // 该句无法编译通过</span><br><span class="line">        cout &lt;&lt; &quot;It is not a pistol&quot; &lt;&lt; endl;</span><br><span class="line">#endif</span><br><span class="line">    // ...</span><br><span class="line">    cout &lt;&lt; is_pod&lt;Type&gt;::value &lt;&lt; endl;        // 0</span><br><span class="line">    cout &lt;&lt; is_pod&lt;Category&gt;::value &lt;&lt; endl;    // 0</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>封装即是将枚举成员成为class的静态成员，避免被转换为整型数据，枚举成员也不会污染全局命名空间了，必须加上类名才能使用。但是枚举类型所占用的空间大小也是不确定的，这是基于编译器的具体实现。下边这个例子普通的枚举使用4字节的内存，当需要的时候会扩展到8字节，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">enum C &#123; C1 = 1, C2 = 2&#125;;</span><br><span class="line">enum D &#123; D1 = 1, D2 = 2, Dbig = 0xFFFFFFF0U &#125;;</span><br><span class="line">enum E &#123; E1 = 1, E2 = 2, Ebig = 0xFFFFFFFFFLL&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    cout &lt;&lt; sizeof(C1) &lt;&lt; endl;   // 4</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; Dbig &lt;&lt; endl;   // 编译器输出不同,GCC：4294967280</span><br><span class="line">    cout &lt;&lt; sizeof(D1) &lt;&lt; endl;     // 4</span><br><span class="line">    cout &lt;&lt; sizeof(Dbig) &lt;&lt; endl;   // 4</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; Ebig &lt;&lt; endl;   // 68719476735</span><br><span class="line">    cout &lt;&lt; sizeof(E1) &lt;&lt; endl; // 8</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为了避免引入枚举类的隐式类型转换，C++引入了<strong>强类型枚举</strong>。声明时只需要在enum后加上class：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enum class Type &#123; General, Light, Medium, Heavy &#125;;</span><br></pre></td></tr></table></figure></p>
<p>强类型枚举有以下几点优势：</p>
<ul>
<li>强作用域。强类型枚举成员的名称不会被输出到其父作用域，所以不同枚举类型定义同名枚举成员编译不会出现重定义错误。</li>
<li>使用枚举类型的枚举成员时，必须指明所属范围，单独的枚举成员名则不再具有意义。</li>
<li>限制转换。强类型枚举成员的值不可以与整型发生相互隐式转换。</li>
<li>可以指定底层类型。强类型枚举默认的底层类型是int，但也可以显式地指定底层类型。<code>enum class Type: char { General, Light, Medium, Heavy };</code>，避免了不可移植性。</li>
<li>不可声明匿名强类型枚举。由于强类型枚举是强类型作用域的，故匿名的enum class可能什么都做不了，匿名强类型枚举会编译报错。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">enum class Type &#123; General, Light, Medium, Heavy &#125;;</span><br><span class="line">enum class Category &#123; General = 1, Pistol, MachineGun, Cannon &#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    Type t = Type::Light;</span><br><span class="line">    t = General;                    // 编译失败，必须使用强类型名称</span><br><span class="line">    if (t == Category::General)     // 编译失败，必须使用Type中的General</span><br><span class="line">        cout &lt;&lt; &quot;General Weapon&quot; &lt;&lt; endl;</span><br><span class="line">    if (t &gt; Type::General)          // 通过编译</span><br><span class="line">        cout &lt;&lt; &quot;Not General Weapon&quot; &lt;&lt; endl;</span><br><span class="line">    if (t &gt; 0)                      // 编译失败，无法转换为int类型</span><br><span class="line">        cout &lt;&lt; &quot;Not General Weapon&quot; &lt;&lt; endl;</span><br><span class="line">    if ((int)t &gt; 0)                 // 通过编译</span><br><span class="line">        cout &lt;&lt; &quot;Not General Weapon&quot; &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; is_pod&lt;Type&gt;::value &lt;&lt; endl;        // 1</span><br><span class="line">    cout &lt;&lt; is_pod&lt;Category&gt;::value &lt;&lt; endl;    // 1</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>枚举类型之间也可以进行比较，但不能够隐式地转为int型。如果将强类型枚举转化为其他类型必须进行显式转换。而且Type和Category都是POD类型，不会像class封装版本一样被视为结构体。此外，由于可以指定底层基于的基本类型，可以避免不可移植性和节省内存空间：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">enum class C : char &#123; C1 = 1, C2 = 2&#125;;</span><br><span class="line">enum class D : unsigned int &#123; D1 = 1, D2 = 2, Dbig = 0xFFFFFFF0U &#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    cout &lt;&lt; sizeof(C::C1) &lt;&lt; endl;   // 1</span><br><span class="line">    cout &lt;&lt; (unsigned int)D::Dbig &lt;&lt; endl;   // 编译器输出一致,4294967280</span><br><span class="line">    cout &lt;&lt; sizeof(D::D1) &lt;&lt; endl;     // 4</span><br><span class="line">    cout &lt;&lt; sizeof(D::Dbig) &lt;&lt; endl;   // 4</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>C++11对传统枚举类型进行了扩展：</p>
<ul>
<li><p>可指定底层基本类型。如char类型枚举，应用比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enum Type : char &#123; Low, Middle, High &#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>从C++11后，枚举类型的成员可以在枚举类型的作用域内有效。比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">enum Type &#123; Low, Middle, High &#125;;</span><br><span class="line">Type type1 = Middle;</span><br><span class="line">Type type2 = Type::Middle;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>其中Middle与Type::Middle都是合法的使用形式。</p>
<h2 id="堆内存管理：智能指针与垃圾回收"><a href="#堆内存管理：智能指针与垃圾回收" class="headerlink" title="堆内存管理：智能指针与垃圾回收"></a>堆内存管理：智能指针与垃圾回收</h2><h3 id="显式内存管理"><a href="#显式内存管理" class="headerlink" title="显式内存管理"></a>显式内存管理</h3><p>从语言层面来讲，我们可以将堆内存的分配与释放归纳为以下一些问题。</p>
<ul>
<li>野指针：一些内存单元已被释放，之前指向它的指针却还在被使用。这些内存有可能被运行时系统重新分配给程序使用，从而导致了无法预测的错误。</li>
<li>重复释放：程序试图去释放已经被释放过的内存单元，或者释放已经被重新分配过的内存单元，就会导致重复释放错误。</li>
<li>内存泄漏：不再需要使用的内存单元如果没有被释放就会导致内存泄漏。如果程序不断地重复进行这类操作，将会导致内存占用剧增。</li>
</ul>
<p>在C++11新标准中，智能指针被进行了改进，以更加适应实际的应用需求。而进一步地，标准库还提供了所谓“最小垃圾回收”的支持。C++11标准中改用unique_ptr，shared_ptr及weak_ptr等智能指针来自动回收堆分配的对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;memory&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    unique_ptr&lt;int&gt; up1(new int(11));   // 无法复制的unique_ptr</span><br><span class="line">    unique_ptr&lt;int&gt; up2 = up1;          // 不能通过编译</span><br><span class="line">    cout &lt;&lt; *up1 &lt;&lt; endl;   // 11</span><br><span class="line"></span><br><span class="line">    unique_ptr&lt;int&gt; up3 = move(up1);    // 现在p3是数据的唯一的unique_ptr</span><br><span class="line">     </span><br><span class="line">    cout &lt;&lt; *up3 &lt;&lt; endl;   // 11</span><br><span class="line">    cout &lt;&lt; *up1 &lt;&lt; endl;   // 运行时错误</span><br><span class="line">    up3.reset();            // 显式释放内存</span><br><span class="line">    up1.reset();            // 不会导致运行时错误</span><br><span class="line">    cout &lt;&lt; *up3 &lt;&lt; endl;   // 运行时错误</span><br><span class="line"></span><br><span class="line">    shared_ptr&lt;int&gt; sp1(new int(22));</span><br><span class="line">    shared_ptr&lt;int&gt; sp2 = sp1;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; *sp1 &lt;&lt; endl;   // 22</span><br><span class="line">    cout &lt;&lt; *sp2 &lt;&lt; endl;   // 22</span><br><span class="line"></span><br><span class="line">    sp1.reset();</span><br><span class="line">    cout &lt;&lt; *sp2 &lt;&lt; endl;   // 22</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码中使用了unique_ptr和shared_ptr自动释放堆对象的内存，由于每个指针都重载了<code>*</code>操作符，可以使用<code>*up1</code>访问所分配的内存。直观来看，unique_ptr与所指对象的内存绑定紧密，不能与其他unique_ptr类型的指针对象共享所指对象的内存，这种所有权只能通过move函数转移。unique_ptr是一个删除了拷贝构造函数、保留了移动构造函数的指针封装类型。</p>
<p>shared_ptr允许多个智能指针共享地拥有同一堆分配对象的内存。只有在引用计数归零的时候，shared_ptr才会真正释放所占用的堆内存的空间。weak_ptr可以指向shared_ptr指针指向的对象内存，却并不拥有该内存。而使用weak_ptr成员lock，则可返回其指向内存的一个shared_ptr指针，且在其指向的内存无效时返回NULL。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;memory&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void Check(weak_ptr&lt;int&gt; &amp; wp) &#123;</span><br><span class="line">    shared_ptr&lt;int&gt; sp = wp.lock(); // 转换为shared_ptr&lt;int&gt;</span><br><span class="line">    if (sp != nullptr)</span><br><span class="line">        cout &lt;&lt; &quot;still &quot; &lt;&lt; *sp &lt;&lt; endl;</span><br><span class="line">    else</span><br><span class="line">        cout &lt;&lt; &quot;pointer is invalid.&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    shared_ptr&lt;int&gt; sp1(new int(22));</span><br><span class="line">    shared_ptr&lt;int&gt; sp2 = sp1;</span><br><span class="line">    weak_ptr&lt;int&gt; wp = sp1; // 指向shared_ptr&lt;int&gt;所指对象</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; *sp1 &lt;&lt; endl;   // 22</span><br><span class="line">    cout &lt;&lt; *sp2 &lt;&lt; endl;   // 22</span><br><span class="line">    Check(wp);              // still 22</span><br><span class="line"></span><br><span class="line">    sp1.reset();</span><br><span class="line">    cout &lt;&lt; *sp2 &lt;&lt; endl;   // 22</span><br><span class="line">    Check(wp);              // still 22</span><br><span class="line"></span><br><span class="line">    sp2.reset();</span><br><span class="line">    Check(wp);              // pointer is invalid</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="垃圾回收的分类"><a href="#垃圾回收的分类" class="headerlink" title="垃圾回收的分类"></a>垃圾回收的分类</h3><p>垃圾回收的方式很多，但主要分为以下几种：</p>
<ul>
<li>基于引用计数（reference counting garbage collector）的垃圾回收器<ul>
<li>简单地说，引用计数主要是使用系统记录对象被引用（引用、指针）的次数。当对象被引用的次数变为0时，该对象即可被视作“垃圾”而回收。使用引用计数做垃圾回收的算法的一个优点是实现很简单，与其他垃圾回收算法相比，该方法不会造成程序暂停，因为计数的增减与对象的使用是紧密结合的。</li>
<li>此外，引用计数也不会对系统的缓存或者交换空间造成冲击，因此被认为“副作用”较小。</li>
<li>但是这种方法比较难处理“环形引用”问题，此外由于计数带来的额外开销也并不小，所以在实用上也有一定的限制。</li>
</ul>
</li>
<li>基于跟踪处理（tracing garbage collector）的垃圾回收器<ul>
<li>相比于引用计数，跟踪处理的圾回收机制被更为广泛地应用。其基本方法是产生跟踪对象的关系图，然后进行垃圾回收。使用跟踪方式的垃圾回收算法主要有以下几种：<ul>
<li>标记——清除（Mark-Sweep）：顾名思义，这个算法可以分为两个过程。首先该算法将程序中正在使用的对象视为“根对象”，从根对象开始查找它们所引用的堆空间，并在这些堆空间上做标记。当标记结束后，所有被标记的对象就是可达对象（ReachableObject）或活对象（LiveObject），而没有被标记的对象就被认为是垃圾，在第二步的清扫（Sweep）阶段会被回收掉。这种方法的特点是活的对象不会被移动，但是其存在会出现大量的内存碎片的问题。</li>
<li>标记——整理（Mark-Compact）：这个算法标记的方法和标记．清除方法一样，但是标记完之后，不再遍历所有对象清扫垃圾了，而是将活的对象向“左”靠齐，这就解决了内存碎片的问题。标记——整理的方法有个特点就是移动活的对象，因此相应的，程序中所有对堆内存的引用都必须更新。</li>
<li>标记——拷贝（Mark-Copy）：这种算法将堆空间分为两个部分：From和To。刚开始系统只从From的堆空间里面分配内存，当From分配满了之后，开始垃圾回收，从From找出所有活着的，拷贝到To里，这样From就剩下死的了，To里的对象都是紧密排列的。From和To交换角色，从新的From里开始分配。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="C-与垃圾回收"><a href="#C-与垃圾回收" class="headerlink" title="C++与垃圾回收"></a>C++与垃圾回收</h3><p>C++11新标准为做到最小垃圾回收支持，首先对“安全”的指针进行了定义，<strong>安全派生</strong>的指针，安全派生的指针是指向由new分配的对象或其子对象指向的指针，操作包括：</p>
<ul>
<li>在解引用基础上的引用，如<code>&amp;*p</code>；</li>
<li>定义明确的指针操作，如<code>p+1</code>；</li>
<li>定义明确的指针转换，如<code>static_cast&lt;void*&gt;(p)</code>；</li>
<li>指针和整型之间的reinterpret_cast，比如<code>reinterpret_cast&lt;intptr_t&gt;(p)</code>；</li>
</ul>
<p>如果代码中出现了指针不安全使用的状况，C++11允许程序员通过API通知垃圾回收器不得回收该内存，需声明该内存为<strong>可到达</strong>的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void declare_reachable(void* p)</span><br><span class="line">template &lt;class T&gt; T *undeclare_reachable(T *p) noexcept</span><br></pre></td></tr></table></figure></p>
<p>declare_reachable显式地通知垃圾回收器一个对象应该是可达的。undeclare_reachable则取消这种声明。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;memory&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int *p = new int;</span><br><span class="line">    declare_reachable(p);   // 在p被隐藏之前声明为可达的</span><br><span class="line">    int *q = (int*)((long long)p ^ 2012); </span><br><span class="line">    // 解除可达声明</span><br><span class="line">    q = undeclare_reachable&lt;int&gt;((int*)((long long)q ^ 2012));    </span><br><span class="line">    *q = 10;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，我们在p指针被不安全派生（隐藏）之前使用declare_reachable声明其是可达的。这样一来，它会被垃圾回收器忽略而不会被回收。而在我们通过可逆的异或运算使得q指针指向p所指对象时，我们则使用了undeclare_reachable来取消可达声明。注意undeclare_reachable不是通知垃圾回收器p所指对象已经可以回收。实际上，declare_reachable和undeclare_reachable只是确立了一个代码范围，即在两者之间的代码运行中，p所指对象不会被垃圾回收器所回收。</p>
<p>有的时候程序员会选择在一大片连续的堆内存上进行指针式操作，为了让垃圾回收器不关心该区域，也可以使用declare_no_pointers及undeclare_no_pointers函数来告诉垃圾回收器该内存区域不存在有效的指针。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void declare_no_pointers(char *p, size_t n) noexcept;</span><br><span class="line">void undeclare_no_pointers(char *p, size_t n) noexcept;</span><br></pre></td></tr></table></figure></p>
<p>其使用方式与declare_reachable及undeclare_reachable类似，不过指定的是从p开始的连续n的内存。</p>
<h1 id="提高性能及操作硬件的能力"><a href="#提高性能及操作硬件的能力" class="headerlink" title="提高性能及操作硬件的能力"></a>提高性能及操作硬件的能力</h1><h2 id="常量表达式"><a href="#常量表达式" class="headerlink" title="常量表达式"></a>常量表达式</h2><h3 id="运行时常量性和编译时常量性"><a href="#运行时常量性和编译时常量性" class="headerlink" title="运行时常量性和编译时常量性"></a>运行时常量性和编译时常量性</h3><p>常量表示该值不可修改，通常通过const关键字来修饰的。const还可以修饰函数参数、函数返回值、函数本身、类等，都表示在运行时数据的不可变更性。有的时候需要<strong>编译时期的常量性</strong>，const修饰的函数返回值只能保证在运行时期内其值是不可更改的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const int GetConst() &#123; return 1; &#125;</span><br><span class="line"></span><br><span class="line">void Constless(int cond) &#123;</span><br><span class="line">     int arr[GetConst()] = &#123;0&#125;;     // 无法通过编译</span><br><span class="line">     enum &#123; e1 = GetConst(), e2 &#125;;  // 无法通过编译</span><br><span class="line">     switch (cond) &#123;</span><br><span class="line">         case GetConst():           // 无法通过编译</span><br><span class="line">             break;</span><br><span class="line">         default:</span><br><span class="line">             break;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>C++11中对编译时期常量的回答是<strong>constexpr</strong>，即常量表达式，编译器会在编译时期对GetConst进行计算，从而将其视为一个编译时期的常量。</p>
<h3 id="常量表达式函数"><a href="#常量表达式函数" class="headerlink" title="常量表达式函数"></a>常量表达式函数</h3><p>大概有以下几种：</p>
<ul>
<li>函数中只能有一条语句，且为return语句。但是不会产生实际作用的，比如using、static_assert等都可以有。</li>
<li>函数必须返回值，不能是返回void</li>
<li>在使用前必须已有定义，不能只是声明</li>
<li>return返回语句表达式中不能使用非常量表达式的函数、全局数据。因为其return表达式语句不能包含运行时才确定返回值的函数。</li>
</ul>
<h3 id="常量表达式值"><a href="#常量表达式值" class="headerlink" title="常量表达式值"></a>常量表达式值</h3><p>常量表达式值必须被一个常量表达式赋值，而跟常量表达式函数一样，常量表达式值必须在使用前被初始化。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const int i = 1;</span><br><span class="line">constexpr int j = 1;</span><br></pre></td></tr></table></figure></p>
<p>两者在大多数情况下是没有区别的。但是如果i在全局名字空间中，编译器一定会为i产生数据；如果不是有代码显式地使用了它的地址，编译器可以选择不为它生成数据，而仅将其当做编译时期的值。在C++11中，编译时的浮点数常量表达式值还是被允许的。标准要求编译时的浮点常量表达式值的精度要至少等于（或者高于）运行时的浮点数常量的精度。</p>
<p>C++11标准中，constexpr关键字是不能用于修饰自定义类型的定义的。比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">constexpr struct MyType &#123; int i; &#125;;</span><br><span class="line">Constexpr MyType mt = &#123;0&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在C++11中，就是无法通过编译的。正确地做法是，定义自定义常量构造函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct MyType &#123;</span><br><span class="line">    constexpr MyType(int x): i(x)&#123;&#125;</span><br><span class="line">    int i; </span><br><span class="line">&#125;;</span><br><span class="line">constexpr MyType mt = &#123;0&#125;;</span><br></pre></td></tr></table></figure></p>
<p>常量表达式的构造函数：函数体必须为空，且初始化列表只能由常量表达式来赋值。</p>
<p>使用常量表达式支持递归：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">constexpr int Fibonacci(int n) &#123;</span><br><span class="line">    return (n == 1) ? 1 : ((n == 2) ? 1 : Fibonacci(n - 1) + Fibonacci(n - 2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int fib[] = &#123; </span><br><span class="line">        Fibonacci(11), Fibonacci(12), </span><br><span class="line">        Fibonacci(13), Fibonacci(14), </span><br><span class="line">        Fibonacci(15), Fibonacci(16) </span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    for (int i : fib) cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>改成使用模板元编程的方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template &lt;long num&gt;</span><br><span class="line">struct Fibonacci&#123;</span><br><span class="line">    static const long val = Fibonacci&lt;num - 1&gt;::val + Fibonacci&lt;num - 2&gt;::val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template &lt;&gt; struct Fibonacci&lt;2&gt; &#123; static const long val = 1; &#125;;</span><br><span class="line">template &lt;&gt; struct Fibonacci&lt;1&gt; &#123; static const long val = 1; &#125;;</span><br><span class="line">template &lt;&gt; struct Fibonacci&lt;0&gt; &#123; static const long val = 0; &#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int fib[] = &#123; </span><br><span class="line">        Fibonacci&lt;11&gt;::val, Fibonacci&lt;12&gt;::val, </span><br><span class="line">        Fibonacci&lt;13&gt;::val, Fibonacci&lt;14&gt;::val, </span><br><span class="line">        Fibonacci&lt;15&gt;::val, Fibonacci&lt;16&gt;::val, </span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    for (int i : fib) cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们定义了一个非类型参数的模板Fibonacci。该模板类定义了一个静态变量val，而val的定义方式是递归的。因此模板将会递归地进行推导。此外，我们还通过偏特化定义了模板推导的边界条件，即斐波那契的初始值。那么模板在推导到边界条件的时候就会终止推导。通过这样的方法，我们同样可以在编译时进行值计算，从而生成数组的值。</p>
<p>任何程序中需要表达的计算，都可以通过constexpr元编程的方式来表达。由于constexpr支持浮点数运算（模板元编程只支持整型），支持三元表达式、逗号表达式，所以很多人认为constexpr元编程将会比模板元编程更加强大。从这个角度讲，constexpr元编程将非常让人期待。</p>
<p><strong>并不是使用了constexpr，编译器就一定会在编译时期对常量表达式函数进行值计算</strong>。如果用g++的默认优化级别来编译，我们实验机上会产生调用<br>Fibonacci函数的代码（clang++在-O0级别也会有这样的效果）。在C++11标准中，我们也没有看到要求编译器一定要对常量表达式进行编译时期的值计算。标准只是定义了可以用于编译时进行值运算的常量表达式的定义，却没有强制要求编译器一定在编译时进行值运算。</p>
<h2 id="变长模板"><a href="#变长模板" class="headerlink" title="变长模板"></a>变长模板</h2><h3 id="变长函数和变长的模板参数"><a href="#变长函数和变长的模板参数" class="headerlink" title="变长函数和变长的模板参数"></a>变长函数和变长的模板参数</h3><p>通过使用变长函数（variadic funciton），printf的实现能够接受任何长度的参数列表。不过无论是宏，还是变长参数，整个机制的设计上，没有任何一<br>个对于传递参数的类型是了解的。我们可以看看变长函数的例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdarg.h&gt;</span><br><span class="line"> </span><br><span class="line">double SumOfFloat(int count, ...) &#123;</span><br><span class="line">    va_list ap;</span><br><span class="line">    double sum = 0;</span><br><span class="line">    va_start(ap, count);            // 获得变长列表的句柄ap</span><br><span class="line">    for(int i = 0; i &lt; count; i++)</span><br><span class="line">        sum += va_arg(ap, double);  // 每次获得一个参数</span><br><span class="line">    va_end(ap);</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    printf(&quot;%f\n&quot;, SumOfFloat(3, 1.2f, 3.4, 5.6));  // 10.200000</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们声明了一个名为SumOfFloat变长函数。变长函数的第一个参数count表示的是变长参数的个数，这必须由SumOfFloat的调用者传递进来。而在被调用<br>者中，则需要通过一个类型为<code>valist</code>的数据结构ap来辅助地获得参数。可以看到，这里代码首先使用<code>va_start</code>函数对ap进行初始化，使得ap成为被传递的变长参数的一个“句柄”，而后代码再使用<code>va_arg</code>数从ap中将参数一一取出用于运算。</p>
<p>下图显示了一种变长函数的可能的实现方式<br><img src="/img/20200405175700.jpg" alt></p>
<p>在本例中，只有使用表达式va_arg(ap,double)的时候，我们才按照类型（实际是按类型长度）去变长参数列表中获得指定参数。而如何打印则得益于传递在字符串中的形如”%s”、”%d”这样的转义字，以及传递的count参数。这样会导致一些问题，引入<strong>变长模板</strong></p>
<h3 id="变长模板：模板参数包和函数参数包"><a href="#变长模板：模板参数包和函数参数包" class="headerlink" title="变长模板：模板参数包和函数参数包"></a>变长模板：模板参数包和函数参数包</h3><p>使用以下代码声明tuple是一个变长类模板，<code>template&lt;typename... Elements&gt; class tuple</code>，三个点代表Elements是一个<strong>模板参数包</strong>，类模板tuple可以接受任意多个参数作为模板参数，对于<code>tuple&lt;int, char, double&gt;</code>将多个模板参数打包成为单个的模板参数包。为了使用模板参数包，总是需要将其<strong>解包</strong>，通过<strong>包扩展</strong>实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename... A&gt; class Template: private B&lt;A...&gt;&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里的A就是一个包扩展，参数包会在包扩展的位置展开多个参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T1, typename T2&gt; class B&#123;&#125;;</span><br><span class="line">template&lt;typename... A&gt; class Template: private B&lt;A...&gt;&#123;&#125;;</span><br><span class="line">Template&lt;X, Y&gt; xy;</span><br></pre></td></tr></table></figure></p>
<p>声明了基类为<code>B&lt;X, Y&gt;</code>的模板类<code>Template&lt;X, Y&gt;</code>的对象xy。</p>
<p>下边是用变长模板实现tuple的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename... Elements&gt; class tuple;        // 变长模板的声明</span><br><span class="line"></span><br><span class="line">template&lt;typename Head, typename... Tail&gt;           // 递归的偏特化定义</span><br><span class="line">class tuple&lt;Head, Tail...&gt; : private tuple&lt;Tail...&gt; &#123;</span><br><span class="line">    Head head;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;&gt; class tuple&lt;&gt; &#123;&#125;;                        // 边界条件</span><br></pre></td></tr></table></figure></p>
<p>声明了变长模板类tuple，其只包含一个模板参数，即Elements模板参数包。此外，我们又<strong>偏特化</strong>地定义了一个双参数的的版本。该偏特化版本的tuple包含了两个参数，一个是类型模板参数Head，另一个则是模板参数包Tail，在实现中，我们将Head型的数据作为<code>tuple&lt;Head,Tail...&gt;</code>的第一个成员，而<br>将使用了包扩展表达式的模板类<code>tuple&lt;Tail..&gt;</code>作为<code>tuple&lt;Head，Tail...&gt;</code>的私有基类。这样一来会引起基类的递归构造，在tuple的参数包为0个的时候会结束。</p>
<p>实现C++11中新的printf的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stdexcept&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void Printf(const char* s) &#123;</span><br><span class="line">    while (*s) &#123;</span><br><span class="line">        if (*s == &apos;%&apos; &amp;&amp; *++s != &apos;%&apos;)</span><br><span class="line">            throw runtime_error(&quot;invalid format string: missing arguments&quot;);</span><br><span class="line">                cout &lt;&lt; *s++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename T, typename... Args&gt;</span><br><span class="line">void Printf(const char* s, T value, Args... args) &#123;</span><br><span class="line">    while (*s) &#123;</span><br><span class="line">        if (*s == &apos;%&apos; &amp;&amp; *++s != &apos;%&apos;) &#123;</span><br><span class="line">            cout &lt;&lt; value;</span><br><span class="line">            return Printf(++s, args...);</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; *s++;</span><br><span class="line">    &#125;</span><br><span class="line">    throw runtime_error(&quot;extra arguments provided to Printf&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    Printf(&quot;hello %s\n&quot;, string(&quot;world&quot;));  // hello world</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>C++标准定义了以下7种参数包可以展开的位置：</p>
<ul>
<li>表达式</li>
<li>初始化列表</li>
<li>基类描述列表</li>
<li>类成员初始化列表</li>
<li>模板参数列表</li>
<li>通用属性列表</li>
<li>lambda函数的捕捉列表</li>
</ul>
<p>我们还可以声明一些有趣的包扩展表达式。比如声明了Arg为参数包，那么我们可以使用<code>Arg&amp;&amp;...</code>这样的包扩展表达式，其解包后等价于<code>Arg1&amp;&amp;, ... ,Argn&amp;&amp;</code>。一个更为有趣的包扩展表达式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename... A&gt; class T: private B&lt;A&gt;...&#123;&#125;;</span><br></pre></td></tr></table></figure></p>
<p>注意这个包扩展跟下面的类模板声明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename... A&gt; class T: private B&lt;A...&gt;&#123;&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在解包后是不同的，对于同样的实例化<code>T&lt;X，Y&gt;</code>，前者会解包为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class T&lt;X, Y&gt;: private B&lt;X&gt;, private B&lt;Y&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure></p>
<p>即多重继承的派生类，而后者则会解包为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class T&lt;X, Y&gt;: private B&lt;X, Y&gt;&#123;&#125;;</span><br></pre></td></tr></table></figure></p>
<p>即派生于多参数的模板类的派生类，这点存在着本质的不同。</p>
<p><code>sizeof...</code>用于计算参数包中参数的个数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cassert&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template&lt;class...A&gt; void Print(A...arg) &#123;</span><br><span class="line">    assert(false);  // 非6参数偏特化版本都会默认assert(false)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 偏特化6参数的版本</span><br><span class="line">void Print(int a1, int a2, int a3, int a4, int a5, int a6) &#123;</span><br><span class="line">    cout &lt;&lt; a1 &lt;&lt; &quot;, &quot; &lt;&lt; a2 &lt;&lt; &quot;, &quot; &lt;&lt; a3 &lt;&lt; &quot;, &quot;</span><br><span class="line">        &lt;&lt; a4 &lt;&lt; &quot;, &quot; &lt;&lt; a5 &lt;&lt; &quot;, &quot; &lt;&lt; a6 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class...A&gt; int Vaargs(A...args)&#123;</span><br><span class="line">    int size = sizeof...(A);    // 计算变长包的长度</span><br><span class="line"></span><br><span class="line">    switch(size)&#123;</span><br><span class="line">        case 0: Print(99, 99, 99, 99, 99, 99);</span><br><span class="line">                break;</span><br><span class="line">        case 1: Print(99, 99, args..., 99, 99, 99);</span><br><span class="line">                break;</span><br><span class="line">        case 2: Print(99, 99, args..., 99, 99);</span><br><span class="line">                break;</span><br><span class="line">        case 3: Print(args..., 99, 99, 99);</span><br><span class="line">                break;</span><br><span class="line">        case 4: Print(99, args..., 99);</span><br><span class="line">                break;</span><br><span class="line">        case 5: Print(99, args...);</span><br><span class="line">                break;</span><br><span class="line">        case 6: Print(args...);</span><br><span class="line">                break;</span><br><span class="line">        default:</span><br><span class="line">                Print(0, 0, 0, 0, 0, 0);</span><br><span class="line">    &#125;</span><br><span class="line">    return size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)&#123;</span><br><span class="line">    Vaargs();   // 99, 99, 99, 99, 99, 99</span><br><span class="line">    Vaargs(1);  // 99, 99, 1, 99, 99, 99</span><br><span class="line">    Vaargs(1, 2);   // 99, 99, 1, 2, 99, 99</span><br><span class="line">    Vaargs(1, 2, 3);    // 1, 2, 3, 99, 99, 99</span><br><span class="line">    Vaargs(1, 2, 3, 4); // 99, 1, 2, 3, 4, 99</span><br><span class="line">    Vaargs(1, 2, 3, 4, 5);  // 99, 1, 2, 3, 4, 5</span><br><span class="line">    Vaargs(1, 2, 3, 4, 5, 6);   // 1, 2, 3, 4, 5, 6</span><br><span class="line">    Vaargs(1, 2, 3, 4, 5, 6, 7);    // 0, 0, 0, 0, 0, 0</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>变长模板参数和完美转发的结合：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct A &#123;</span><br><span class="line">    A()&#123;&#125;</span><br><span class="line">    A(const A&amp; a) &#123; cout &lt;&lt; &quot;Copy Constructed &quot; &lt;&lt; __func__ &lt;&lt; endl; &#125;</span><br><span class="line">    A(A&amp;&amp; a) &#123; cout &lt;&lt; &quot;Move Constructed &quot; &lt;&lt; __func__ &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct B &#123;</span><br><span class="line">    B()&#123;&#125;</span><br><span class="line">    B(const B&amp; b) &#123; cout &lt;&lt; &quot;Copy Constructed &quot; &lt;&lt; __func__ &lt;&lt; endl; &#125;</span><br><span class="line">    B(B&amp;&amp; b) &#123; cout &lt;&lt; &quot;Move Constructed &quot; &lt;&lt; __func__ &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 变长模板的定义</span><br><span class="line">template &lt;typename... T&gt; struct MultiTypes;</span><br><span class="line">template &lt;typename T1, typename... T&gt; </span><br><span class="line">struct MultiTypes&lt;T1, T...&gt; : public MultiTypes&lt;T...&gt;&#123;</span><br><span class="line">    T1 t1;</span><br><span class="line">    MultiTypes&lt;T1, T...&gt;(T1 a, T... b):</span><br><span class="line">        t1(a), MultiTypes&lt;T...&gt;(b...) &#123; </span><br><span class="line">            cout &lt;&lt; &quot;MultiTypes&lt;T1, T...&gt;(T1 a, T... b)&quot; &lt;&lt; endl; </span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line">template &lt;&gt; struct MultiTypes&lt;&gt; &#123;</span><br><span class="line">    MultiTypes&lt;&gt;()&#123; cout &lt;&lt; &quot;MultiTypes&lt;&gt;()&quot; &lt;&lt; endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 完美转发的变长模板</span><br><span class="line">template &lt;template &lt;typename...&gt; class VariadicType, typename... Args&gt;</span><br><span class="line">VariadicType&lt;Args...&gt; Build(Args&amp;&amp;... args)</span><br><span class="line">&#123;</span><br><span class="line">    return VariadicType&lt;Args...&gt;(std::forward&lt;Args&gt;(args)...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    A a;</span><br><span class="line">    B b;</span><br><span class="line">    </span><br><span class="line">    Build&lt;MultiTypes&gt;(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h2><p>原子操作通过<strong>互斥</strong>访问保证。如果想做到粗粒度的互斥，则借助POSIX的pthread库中的互斥锁可以实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">static long long total = 0;</span><br><span class="line">pthread_mutex_t m = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line">void* func(void *) &#123;</span><br><span class="line">    long long i;</span><br><span class="line">    for(i = 0; i &lt; 100000000LL;i++) &#123;   </span><br><span class="line">        pthread_mutex_lock(&amp;m);</span><br><span class="line">        total += i;</span><br><span class="line">        pthread_mutex_unlock(&amp;m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    pthread_t thread1, thread2;</span><br><span class="line">    if (pthread_create(&amp;thread1, NULL, &amp;func, NULL))&#123;</span><br><span class="line">        throw;</span><br><span class="line">    &#125;</span><br><span class="line">    if (pthread_create(&amp;thread2, NULL, &amp;func, NULL))&#123;</span><br><span class="line">        throw;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_join(thread1, NULL);</span><br><span class="line">    pthread_join(thread2, NULL);</span><br><span class="line">    cout &lt;&lt; total &lt;&lt; endl;  // 9999999900000000</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在C++11上，实现同样的功能：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;atomic&gt;</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">atomic_llong total &#123;0&#125;;     // 原子数据类型</span><br><span class="line"> </span><br><span class="line">void func(int) &#123;</span><br><span class="line">    for(long long i = 0; i &lt; 100000000LL; ++i) &#123;</span><br><span class="line">        total += i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    thread t1(func, 0);</span><br><span class="line">    thread t2(func, 0);</span><br><span class="line">    </span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line">    cout &lt;&lt; total &lt;&lt; endl;  // 9999999900000000</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>将total定义为一个原子数据类型，类型长度等同于C++11中的内置类型long long。在C++11中，程序员不需要为原子数据类型显式地声明互斥锁或调用加锁、解锁的API，线程就能够对变量total互斥地进行访问。这里我们定义了C++11的线程<code>std::thread</code>变量t1及t2，它们都执行同样的函数func，并类似于pthread_t，调用了<code>std::thread</code>成员函数join加人程序的执行。由于C++11支持原子类型，因此我们可以简单地通过<code>#include&lt;cstdatomic&gt;</code>头文件中来使用对应于<code>&lt;cstdatomic&gt;</code>中包含的原子类型，定义如表<br><img src="/img/20200405204600.jpg" alt></p>
<p>可以使用<code>std::atomic&lt;T&gt; t</code>模板类型声明一个类型为T的原子类型变量t。对于线程而言，原子类型通常属于“资源型”的数据，这意味着多个线程通常只能访问单个原子类型的拷贝。因此在c++11中，原子类型只能从其模板参数类型中进行构造，标准不允许原子类型进行拷贝构造、移动构造，以及使用operator=等，以防止发生意外。对大多数原子类型而言，都可以执行读read、写store、交换exchange、比较并交换compare_exchange_weak等操作。如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">atomic&lt;int&gt; a;</span><br><span class="line">a = 1;</span><br><span class="line">int b = a;</span><br></pre></td></tr></table></figure></p>
<p><code>a = 1</code>相当于<code>a.store(1)</code>，<code>b = a</code>就相当于<code>b=a.load()</code>，这些接口封装了平台上的实现。</p>
<h3 id="内存模型、顺序一致性、memory-order"><a href="#内存模型、顺序一致性、memory-order" class="headerlink" title="内存模型、顺序一致性、memory_order"></a>内存模型、顺序一致性、memory_order</h3><p>要了解顺序一致性喝内存模型，先看代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;thread&gt;</span><br><span class="line">#include &lt;atomic&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">atomic&lt;int&gt; a &#123;0&#125;;</span><br><span class="line">atomic&lt;int&gt; b &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">int ValueSet(int) &#123;</span><br><span class="line">    int t = 1;</span><br><span class="line">    a = t;</span><br><span class="line">    b = 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Observer(int) &#123;</span><br><span class="line">    cout &lt;&lt; &quot;(&quot; &lt;&lt; a &lt;&lt; &quot;, &quot; &lt;&lt; b &lt;&lt; &quot;)&quot; &lt;&lt; endl;   // 可能有多种输出</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    thread t1(ValueSet, 0);</span><br><span class="line">    thread t2(Observer, 0);</span><br><span class="line"></span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line">    cout &lt;&lt; &quot;Got (&quot; &lt;&lt; a &lt;&lt; &quot;, &quot; &lt;&lt; b &lt;&lt; &quot;)&quot; &lt;&lt; endl;   // Got (1, 2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>两个线程t1、t2分别执行ValueSet喝Ovserver函数，在线程结束后再打印a和b的值总会得到(1,2)的结果。<br><img src="/img/20200405211800.jpg" alt></p>
<p>如果编译器认定a和b的赋值语句执行顺序对输出结果没有影响的话，则可以将指令重排以提高性能，如果假定所有执行的顺序无关紧要，则在多线程下会发生错误，默认情况下，原子类型的变量总是再线程中保持顺序执行的特性，称为<strong>顺序一致</strong>的。即代码再线程中运行的顺序与程序猿看到的代码顺序一致，最大程度保证程序的正确性。对于C++11的内存模型，要做到代码的顺序一致性，必须：</p>
<ul>
<li>编译器保证原子操作的指令间顺序不变，保证产生的读写原子类型的变量的机器指令与代码编写者看到的是一致的。</li>
<li>处理器对原子操作的汇编指令的执行顺序不变。</li>
</ul>
<p>如前文所述，在C++11中，原子类型的成员函数（原子操作）总是保证了顺序一致性。这对于x86这样的平台来说，禁止了编译器对原子类型变量间的重排序优化；而对于powerpc这样的平台来说，则不仅禁止了编译器的优化，还插人了大量的内存栅栏。这对于意图是提高性能的多线程程序而言，无疑是一种性能伤害。在C++11中，设计者给出的解决方式是让程序员为原子操作指定所谓的内存顺序：memory_order。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;thread&gt;</span><br><span class="line">#include &lt;atomic&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">atomic&lt;int&gt; a &#123;0&#125;;</span><br><span class="line">atomic&lt;int&gt; b &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">int ValueSet(int) &#123;</span><br><span class="line">    int t = 1;</span><br><span class="line">    a.store(t, memory_order_relaxed);</span><br><span class="line">    b.store(2, memory_order_relaxed);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Observer(int) &#123;</span><br><span class="line">    cout &lt;&lt; &quot;(&quot; &lt;&lt; a &lt;&lt; &quot;, &quot; &lt;&lt; b &lt;&lt; &quot;)&quot; &lt;&lt; endl;   // 可能有多种输出</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    thread t1(ValueSet, 0);</span><br><span class="line">    thread t2(Observer, 0);</span><br><span class="line"></span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line">    cout &lt;&lt; &quot;Got (&quot; &lt;&lt; a &lt;&lt; &quot;, &quot; &lt;&lt; b &lt;&lt; &quot;)&quot; &lt;&lt; endl;   // Got (1, 2)</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述代码表示使用松散的内存模型，该指令可以任由编译器重排或由处理器乱序执行。C++标准定义了7种memory_order枚举值：<br><img src="/img/20200405215200.jpg" alt></p>
<h2 id="线程局部存储"><a href="#线程局部存储" class="headerlink" title="线程局部存储"></a>线程局部存储</h2><p>线程局部存储TLS就是拥有线程生命周期及线程可见性的变量。线程局部存储实际上是由单线程程序中的全局/静态变量被应用到多线程程序中被线程共享而来。在g++中：<code>_thread int errCode</code>，即为将变量声明为TLS变量。每个线程拥有独立的errCode拷贝，一个线程中对errCode的读写并不会影响另外一个线程中errCode的数据。</p>
<h2 id="快速退出quick-exit"><a href="#快速退出quick-exit" class="headerlink" title="快速退出quick_exit"></a>快速退出quick_exit</h2><p>terminate函数实际上是异常处理的一部分，没有捕捉到的异常会引起terminate的调用，，abort不会调用任何析构函数，会向合乎POSIX标准的系统抛出了一个信号SIGABRT；exit属于正常退出，自动调用变量的析构函数。</p>
<p>有的时候，main或者使用exit函数调用结束程序的方式也不那么令人满意。有的时候，代码中会有很多的类，这些类在堆空间上分配了大量的零散的内存（直接从堆里分配，并没有优化的策略），而main或者exit函数调用会导致类的析构函数依次将这些零散的内存还给操作系统。这是一件费时的工作，而实际上，这些堆内存将在进程结束时由操作系统统一回收（事实上这相当快，操作系统除了释放一些进程相关的数据结构外，只是将一些物理内存标记为未使用就可以了）。如果这些堆内存对其他程序不产生任何影响，那么在程序结束时释放堆内存的析构过程往往是毫无意义的。因此，在这种情况下，我们常常需要能够更快地退出程序。</p>
<p>为此，在C++11中，标准引人了quick_exit函数，该数并不执行析构数而只是使程序终止。与abort不同的是，abort的结果通常是异常退出（可能系统还会进行core dump等以辅助程序员进行问题分析)。而quick_exit与exit同属于正常退出。此外，使用at_qutck_exit注册的函数也可以在quick_exit的时候被调用。这样一来，我们同样可以像exit一样做一些清理的工作（这与很多平台上使用exit函数直接正常退出还是有不同的）。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/C/" rel="tag"># C++</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/04/01/深入理解cpp11_新特性解析与应用_笔记1/" rel="next" title="深入理解C++11_新特性解析与应用 笔记1">
                <i class="fa fa-chevron-left"></i> 深入理解C++11_新特性解析与应用 笔记1
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/04/06/深入理解cpp11_新特性解析与应用_笔记3/" rel="prev" title="深入理解C++11_新特性解析与应用 笔记3">
                深入理解C++11_新特性解析与应用 笔记3 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/header.jpg" alt="Hao Yu">
            
              <p class="site-author-name" itemprop="name">Hao Yu</p>
              <p class="site-description motion-element" itemprop="description">Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author</p>
          </div>
          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">320</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>
        	<audio controls="controls" loop="loop" preload="auto" src="/resource/xiaomeihao.mp3">
	        </audio>
	

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yuhao0102" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:yuh18@mails.tsinghua.edu.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#新手易学，老兵易用"><span class="nav-number">1.</span> <span class="nav-text">新手易学，老兵易用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#右尖括号-gt-的改进"><span class="nav-number">1.1.</span> <span class="nav-text">右尖括号&gt;的改进</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#auto类型推导"><span class="nav-number">1.2.</span> <span class="nav-text">auto类型推导</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#静态类型、动态类型与类型推导"><span class="nav-number">1.2.1.</span> <span class="nav-text">静态类型、动态类型与类型推导</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#auto的优势"><span class="nav-number">1.2.2.</span> <span class="nav-text">auto的优势</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#auto的应用细则"><span class="nav-number">1.2.3.</span> <span class="nav-text">auto的应用细则</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#decltype"><span class="nav-number">1.3.</span> <span class="nav-text">decltype</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#typeid与decltype"><span class="nav-number">1.3.1.</span> <span class="nav-text">typeid与decltype</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#decltype的应用"><span class="nav-number">1.3.2.</span> <span class="nav-text">decltype的应用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#追踪返回类型"><span class="nav-number">1.4.</span> <span class="nav-text">追踪返回类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#追踪返回类型的引入"><span class="nav-number">1.4.1.</span> <span class="nav-text">追踪返回类型的引入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用追踪返回类型的函数"><span class="nav-number">1.4.2.</span> <span class="nav-text">使用追踪返回类型的函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基于范围的for"><span class="nav-number">1.5.</span> <span class="nav-text">基于范围的for</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#提高类型安全"><span class="nav-number">2.</span> <span class="nav-text">提高类型安全</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#强类型枚举"><span class="nav-number">2.1.</span> <span class="nav-text">强类型枚举</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#堆内存管理：智能指针与垃圾回收"><span class="nav-number">2.2.</span> <span class="nav-text">堆内存管理：智能指针与垃圾回收</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#显式内存管理"><span class="nav-number">2.2.1.</span> <span class="nav-text">显式内存管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#垃圾回收的分类"><span class="nav-number">2.2.2.</span> <span class="nav-text">垃圾回收的分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-与垃圾回收"><span class="nav-number">2.2.3.</span> <span class="nav-text">C++与垃圾回收</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#提高性能及操作硬件的能力"><span class="nav-number">3.</span> <span class="nav-text">提高性能及操作硬件的能力</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#常量表达式"><span class="nav-number">3.1.</span> <span class="nav-text">常量表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#运行时常量性和编译时常量性"><span class="nav-number">3.1.1.</span> <span class="nav-text">运行时常量性和编译时常量性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常量表达式函数"><span class="nav-number">3.1.2.</span> <span class="nav-text">常量表达式函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常量表达式值"><span class="nav-number">3.1.3.</span> <span class="nav-text">常量表达式值</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#变长模板"><span class="nav-number">3.2.</span> <span class="nav-text">变长模板</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#变长函数和变长的模板参数"><span class="nav-number">3.2.1.</span> <span class="nav-text">变长函数和变长的模板参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#变长模板：模板参数包和函数参数包"><span class="nav-number">3.2.2.</span> <span class="nav-text">变长模板：模板参数包和函数参数包</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#原子操作"><span class="nav-number">3.3.</span> <span class="nav-text">原子操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#内存模型、顺序一致性、memory-order"><span class="nav-number">3.3.1.</span> <span class="nav-text">内存模型、顺序一致性、memory_order</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程局部存储"><span class="nav-number">3.4.</span> <span class="nav-text">线程局部存储</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#快速退出quick-exit"><span class="nav-number">3.5.</span> <span class="nav-text">快速退出quick_exit</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>
  <div id="DvelopmentTarget">     
  </div>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart" aria-hidden="false"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>

  
</div>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_uv"> 
  本站访客数<span id="busuanzi_value_site_uv"></span>人次
</span>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  


  <script type="text/javascript" src="/js/src/love.js"></script>

</body>
</html>
