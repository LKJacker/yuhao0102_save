<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zn-ch">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-center-simple.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="C++,">










<meta name="description" content="新手易学，老兵易用右尖括号&amp;gt;的改进在C++98中，有一条需要规避的规则：如果在实例化模板的时候出现了连续的两个右尖括号&amp;gt;，那么它们之间需要一个空格来进行分隔，以避免发生编译时的错误。示例如下：123456789// 示例1：嵌套的模板标识template &amp;lt;int i&amp;gt;  class X &amp;#123;&amp;#125;;template &amp;lt;class T&amp;gt; class">
<meta name="keywords" content="C++">
<meta property="og:type" content="article">
<meta property="og:title" content="深入理解C++11_新特性解析与应用 笔记2">
<meta property="og:url" content="http://yoursite.com/2020/04/04/深入理解cpp11_新特性解析与应用_笔记2/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="新手易学，老兵易用右尖括号&amp;gt;的改进在C++98中，有一条需要规避的规则：如果在实例化模板的时候出现了连续的两个右尖括号&amp;gt;，那么它们之间需要一个空格来进行分隔，以避免发生编译时的错误。示例如下：123456789// 示例1：嵌套的模板标识template &amp;lt;int i&amp;gt;  class X &amp;#123;&amp;#125;;template &amp;lt;class T&amp;gt; class">
<meta property="og:locale" content="zn-ch">
<meta property="og:image" content="http://yoursite.com/img/20200405215200.jpg">
<meta property="og:updated_time" content="2020-04-05T13:35:28.181Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="深入理解C++11_新特性解析与应用 笔记2">
<meta name="twitter:description" content="新手易学，老兵易用右尖括号&amp;gt;的改进在C++98中，有一条需要规避的规则：如果在实例化模板的时候出现了连续的两个右尖括号&amp;gt;，那么它们之间需要一个空格来进行分隔，以避免发生编译时的错误。示例如下：123456789// 示例1：嵌套的模板标识template &amp;lt;int i&amp;gt;  class X &amp;#123;&amp;#125;;template &amp;lt;class T&amp;gt; class">
<meta name="twitter:image" content="http://yoursite.com/img/20200405215200.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/04/04/深入理解cpp11_新特性解析与应用_笔记2/">





  <title>深入理解C++11_新特性解析与应用 笔记2 | Hao Yu's blog</title>
  








 
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zn-ch">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hao Yu's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">The program monkey was eaten by the siege lion.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-mybetterhalf">
          <a href="/mybetterhalf/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>
            
            mybetterhalf
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="Searching..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/04/深入理解cpp11_新特性解析与应用_笔记2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">深入理解C++11_新特性解析与应用 笔记2</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-04-04T16:21:00+08:00">
                2020-04-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="新手易学，老兵易用"><a href="#新手易学，老兵易用" class="headerlink" title="新手易学，老兵易用"></a>新手易学，老兵易用</h1><h2 id="右尖括号-gt-的改进"><a href="#右尖括号-gt-的改进" class="headerlink" title="右尖括号&gt;的改进"></a>右尖括号&gt;的改进</h2><p>在C++98中，有一条需要规避的规则：如果在实例化模板的时候出现了连续的两个右尖括号&gt;，那么它们之间需要一个空格来进行分隔，以避免发生编译时的错误。示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 示例1：嵌套的模板标识</span><br><span class="line">template &lt;int i&gt;  class X &#123;&#125;;</span><br><span class="line">template &lt;class T&gt; class Y &#123;&#125;;</span><br><span class="line">Y&lt;X&lt;1&gt; &gt; x1; // 编译成功</span><br><span class="line">Y&lt;X&lt;1&gt;&gt; x2;  // 编译失败</span><br><span class="line"></span><br><span class="line">// 示例2：强制转换</span><br><span class="line">const vector&lt;int&gt; v = static_cast&lt;vector&lt;int&gt; &gt;(v); // 编译成功</span><br><span class="line">const vector&lt;int&gt; v = static_cast&lt;vector&lt;int&gt;&gt;(v);  // 编译失败</span><br></pre></td></tr></table></figure></p>
<p>如此的限制，在C++11新标准中被取消了。但是，这些“智能”的判断也会带来一些与C++98的有趣的不兼容性。比如用户只是想让&gt;&gt;在模板的实例化中表示的是真正的右移，但是C++11会把它解析为模板参数界定符。示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">template &lt;int i&gt; class X &#123;&#125;; </span><br><span class="line">X &lt; 1 &gt;&gt; 5 &gt; x; // 编译失败</span><br><span class="line">X &lt;(1 &gt;&gt; 5)&gt; x; // 编译成功</span><br></pre></td></tr></table></figure></p>
<p>使用C++98标准进行编译的话，这个例子会编译通过。因为编译器认为X<1>&gt;5&gt;x;中的双尖括号是一个位移操作，那么最终可以得到一个形如X<0>x的模板实例。如果使用C++11标准进行编译，那么程序员会得到一个编译错误的警告，因为编译器优先将双尖括号中的第一个&gt;与X之后的&lt;进行了配对。</0></1></p>
<p>虽然很少有人在模板实例化时同时进行位移操作，但是从语法上来说，C++98和C++11确实在这一点上不兼容。要避免这样的不兼容性也很简单，使用圆括号将“1&gt;&gt;5”括起来（如示例中编译成功的写法），保证右移操作优先，就不会出现类似问题了。</p>
<h2 id="auto类型推导"><a href="#auto类型推导" class="headerlink" title="auto类型推导"></a>auto类型推导</h2><h3 id="静态类型、动态类型与类型推导"><a href="#静态类型、动态类型与类型推导" class="headerlink" title="静态类型、动态类型与类型推导"></a>静态类型、动态类型与类型推导</h3><p>静态类型和动态类型的主要区别在于对变量进行类型检查的时间点：</p>
<ul>
<li>静态类型，类型检查主要发生在编译阶段；</li>
<li>动态类型，类型检查主要发生在运行阶段。</li>
</ul>
<p>auto声明的变量必须被初始化，以使编译器能够从其初始化表达式中推导出其类型。从这个意义上来讲，auto并非一种“类型”声明，而是一个类型声明时的“占位符”，编译器在编译时期会将auto替代为变量实际的类型。</p>
<h3 id="auto的优势"><a href="#auto的优势" class="headerlink" title="auto的优势"></a>auto的优势</h3><ul>
<li>auto推导的一个最大优势就是在拥有初始化表达式的复杂类型变量声明时简化代码。</li>
<li>可以免除程序员在一些类型声明时的麻烦，或者避免一些在类型声明时的错误。</li>
<li>就是其“自适应”特性能够在一定程度上支持泛型的编程。</li>
<li>auto还会在一些情况下取得意想不到的好效果。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define MAX1(a, b) ((a) &gt; (b)) ? (a) : (b)</span><br><span class="line">#define MAX2(a, b, max) &#123; \</span><br><span class="line">    auto _a = (a); \</span><br><span class="line">    auto _b = (b); \</span><br><span class="line">    max = (_a &gt; _b) ? _a : _b; &#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int m1 = MAX1(1 * 2 * 3 * 4, 5 + 6 + 7 + 8);</span><br><span class="line">    cout &lt;&lt; m1 &lt;&lt; endl;  // 26</span><br><span class="line">    int m2 = 0;</span><br><span class="line">    MAX2(1 * 2 * 3 * 4, 5 + 6 + 7 + 8, m2);</span><br><span class="line">    cout &lt;&lt; m2 &lt;&lt; endl;  // 26</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义了两种类型的宏Max1和Max2。两者作用相同，都是求a和b中较大者并返回。前者采用传统的三元运算符表达式，这可能会带来一定的性能问题。因为，a或b在三元运算符中都出现了两次，那么，无论是取a还是取b，其中之一都会被运算两次。而在Max2中，我们将a和b都先算出来，再使用三元运算符进行比较，就不会存在这样的问题了。在传统的C++98标准中，由于a和b的类型无法获得，所以我们无法定义Max2这样高性能的宏。而新的标准中的auto则提供了这种可行性。</p>
<h3 id="auto的应用细则"><a href="#auto的应用细则" class="headerlink" title="auto的应用细则"></a>auto的应用细则</h3><p>（1）auto可以与指针和引用结合起来使用。示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int x; </span><br><span class="line">int* y = &amp;x; </span><br><span class="line">double foo();</span><br><span class="line">int&amp; bar();</span><br><span class="line">auto* a = &amp;x;  // int* </span><br><span class="line">auto &amp; b = x;  // int&amp; </span><br><span class="line">auto c = y;    // int* </span><br><span class="line">auto * d = y;  // int* </span><br><span class="line">auto * e = &amp;foo(); // 编译失败, 指针不能指向一个临时变量</span><br><span class="line">auto &amp; f = foo();  // 编译失败, nonconst的左值引用不能和一个临时变量绑定 </span><br><span class="line">auto g = bar();    // int</span><br><span class="line">auto &amp; h = bar();  // int&amp;</span><br></pre></td></tr></table></figure></p>
<p>（2）auto可以与cv限制符一起使用，不过声明为auto的变量并不能从其初始化表达式中“带走”cv限制符。volatile和const代表了变量的两种不同的属性：易失的和常量的。在C++标准中，它们常常被一起叫作cv限制符（cv-qualifier）。示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">double foo() &#123;&#125;;</span><br><span class="line">float* bar() &#123;&#125;;</span><br><span class="line">const auto a = foo();      // a: const double </span><br><span class="line">const auto &amp; b = foo();    // b: const double&amp; </span><br><span class="line">volatile auto * c = bar(); // c: volatile float * </span><br><span class="line">auto d = a;                // d: double</span><br><span class="line">auto &amp; e = a;              // e: const double &amp;</span><br><span class="line">auto f = c;                // f: float * volatile</span><br><span class="line">auto &amp; g = c;              // g: volatile float * &amp;</span><br></pre></td></tr></table></figure></p>
<p>可以通过非cv限制的类型初始化一个cv限制的类型，如变量a、b、c所示。不过通过auto声明的变量d、f却无法带走a和f的常量性或者易失性。这里的例外还是引用，可以看出，声明为引用的变量e、g都保持了其引用的对象相同的属性（事实上，指针也是一样的）。</p>
<p>（3）同一个赋值语句中，auto可以用来声明多个变量的类型，不过这些变量的类型必须相同。如果这些变量的类型不相同，编译器则会报错。事实上，用auto来声明多个变量类型时，只有第一个变量用于auto的类型推导，然后推导出来的数据类型被作用于其他的变量。所以不允许这些变量的类型不相同。示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">auto x = 1, y = 2;  // x和y的类型均为int </span><br><span class="line">// m是一个指向const int类型变量的指针, n是一个int类型的变量 </span><br><span class="line">const auto* m = &amp;x, n = 1;</span><br><span class="line">auto i = 1, j = 3. 14f;      // 编译失败</span><br><span class="line">auto o = 1, &amp;p = o, *q = &amp;p; // 从左向右推导</span><br></pre></td></tr></table></figure></p>
<p>auto的类型推导是按照从左往右，而且类似于字面替换的方式进行。</p>
<p>（4）初始化列表，以及new，都可以使用auto关键字。示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;initializer_list&gt;</span><br><span class="line">auto x = 1;</span><br><span class="line">auto x1(1);</span><br><span class="line">auto y &#123;1&#125;;           // 用于初始化列表的auto</span><br><span class="line">auto z = new auto(1); // 用于new</span><br></pre></td></tr></table></figure></p>
<p>auto可以保证使用初始化列表仍然可以正确推导。</p>
<p>auto也有使用上的限制：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void fun(auto x =1)&#123;&#125;  // 1: auto函数参数，无法通过编译</span><br><span class="line"></span><br><span class="line">struct str&#123;</span><br><span class="line">    auto var = 10;   // 2: auto非静态成员变量，无法通过编译</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    char x[3];</span><br><span class="line">    auto y = x;</span><br><span class="line">    auto z[3] = x; // 3: auto数组，无法通过编译</span><br><span class="line"></span><br><span class="line">    // 4: auto模板参数（实例化时），无法通过编译</span><br><span class="line">    vector&lt;auto&gt; x = &#123;1&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>4种不能推导的情况：</p>
<ul>
<li>对于函数fun来说，auto不能是其形参类型。auto是不能做形参的类型的。如果程序员需要泛型的参数，还是需要求助于模板。</li>
<li>对于结构体来说，非静态成员变量的类型不能是auto的。编译器阻止auto对结构体中的非静态成员进行推导，即使成员拥有初始值。</li>
<li>声明auto数组。我们可以看到，main中的x是一个数组，y的类型是可以推导的，而声明auto z[3]这样的数组同样会被编译器禁止。</li>
<li>在实例化模板的时候使用auto作为模板参数，如main中我们声明的<code>vector&lt;auto&gt; v</code>，虽然读者可能认为这里一眼而知是int类型，但编译器却阻止了编译。</li>
</ul>
<h2 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h2><h3 id="typeid与decltype"><a href="#typeid与decltype" class="headerlink" title="typeid与decltype"></a>typeid与decltype</h3><p>C++98对动态类型支持就是C++中的运行时类型识别（RTTI）。RTTI的机制是为每个类型产生一个type_info类型的数据，可以在程序中使用typeid随时查询一个变量的类型，typeid就会返回变量相应的type_info数据。type_info的name成员函数可以返回类型的名字。而在C++11中，又增加了hash_code这个成员函数，<strong>返回该类型唯一的哈希值</strong>，以供程序员对变量的类型随时进行比较。应用示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt; </span><br><span class="line">#include &lt;typeinfo&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class White &#123;&#125;;</span><br><span class="line">class Black &#123;&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    White a;</span><br><span class="line">    Black b;</span><br><span class="line">    cout &lt;&lt; typeid(a).name() &lt;&lt; endl; // class White</span><br><span class="line">    cout &lt;&lt; typeid(b).name() &lt;&lt; endl; // class Black</span><br><span class="line">    White c; </span><br><span class="line">    bool a_b_sametype = (typeid(a).hash_code() == typeid(b).hash_code());</span><br><span class="line">    bool a_c_sametype = (typeid(a).hash_code() == typeid(c).hash_code()); </span><br><span class="line">    cout &lt;&lt; &quot;Same type? &quot; &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;A and B? &quot; &lt;&lt; (int)a_b_sametype &lt;&lt; endl; // 0</span><br><span class="line">    cout &lt;&lt; &quot;A and C? &quot; &lt;&lt; (int)a_c_sametype &lt;&lt; endl; // 1</span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*运行结果</span><br><span class="line">class White</span><br><span class="line">class Black</span><br><span class="line">Same type?</span><br><span class="line">A and B? 0</span><br><span class="line">A and C? 1</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></p>
<p>值得注意一点：相比于is_same模板函数的成员类型value在编译时得到信息，hash_code是运行时得到的信息。除了typeid以外，RTT i还包括了C++中的dynamic_cast等特性。</p>
<p>与auto类似地，decltype也能进行类型推导。下面分析两者的异同：</p>
<p>[1] decltype与auto的不同点：使用方式有一定的区别。示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;typeinfo&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    decltype(i) j = 0;</span><br><span class="line">    cout &lt;&lt; typeid(j).name() &lt;&lt; endl; // int</span><br><span class="line">    float a;</span><br><span class="line">    double b;</span><br><span class="line">    decltype(a + b) c;</span><br><span class="line">    cout &lt;&lt; typeid(c).name() &lt;&lt; endl; // double</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*运行结果</span><br><span class="line">int</span><br><span class="line">double</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></p>
<p>看到变量j的类型由decltype(i)进行声明，表示j的类型跟i相同（或者准确地说，跟i这个表达式返回的类型相同）。而c的类型则跟(a+b)这个表达式返回的类型相同。由于a+b加法表达式返回的类型为double（a会被扩展为double类型与b相加），所以c的类型被decltype推导为double。</p>
<p>从这个例子中可以看到，decltype的类型推导并不是像auto一样是从变量声明的初始化表达式获得变量的类型，decltype总是以一个普通的表达式为参数，返回该表达式的类型。</p>
<p>[2] decltype与auto的相同点：作为一个类型指示符，decltype也可以将获得的类型来定义另外一个变量；decltype类型推导也是在编译时进行的。</p>
<h3 id="decltype的应用"><a href="#decltype的应用" class="headerlink" title="decltype的应用"></a>decltype的应用</h3><p>在C++11中，使用decltype推导类型是非常常见。</p>
<p>（1）decltype与typdef/using的合用。示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">using size_t = decltype(sizeof(0));</span><br><span class="line">using ptrdiff_t = decltype((int*)0 - (int*)0);</span><br><span class="line">using nullptr_t = decltype(nullptr);</span><br></pre></td></tr></table></figure></p>
<p>（2）decltype在某些场景下，可以极大地增加代码的可读性。定义了vector的iterator的类型，这个类型还可以在main函数中宠用，利用decltype和typedef/using组合将其转换为一个其他的表达式。示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() </span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;int&gt; vec;</span><br><span class="line">    typedef decltype(vec.begin()) vectype;</span><br><span class="line">    for (vectype i = vec.begin(); i &lt; vec.end(); ++i) </span><br><span class="line">    &#123; </span><br><span class="line">        // TODO...</span><br><span class="line">    &#125; </span><br><span class="line">    for (decltype(vec)::iterator i = vec. begin(); i &lt; vec. end(); ++i)</span><br><span class="line">    &#123; </span><br><span class="line">        // TODO...</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>（3）重用匿名类型的利器。这里使用了三种匿名类型。示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">enum &#123;K1, K2, K3 &#125; anon_e; // 匿名的枚举</span><br><span class="line"></span><br><span class="line">union</span><br><span class="line">&#123; </span><br><span class="line">    decltype(anon_e) key; </span><br><span class="line">    char* name;</span><br><span class="line">&#125; anon_u; // 匿名的union联合体</span><br><span class="line"></span><br><span class="line">struct </span><br><span class="line">&#123; </span><br><span class="line">    int d; </span><br><span class="line">    decltype(anon_u) id;</span><br><span class="line">&#125; anon_s[100];  // 匿名的struct数组</span><br><span class="line"></span><br><span class="line">int main() </span><br><span class="line">&#123;</span><br><span class="line">    decltype(anon_s) as;</span><br><span class="line">    as[0].id.key = decltype(anon_e)::K1; // 引用匿名类型枚举中的值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>（4）扩大模板泛型的能力。增加了类型为decltype(t1+t2)的s作为参数，而函数本身不返回任何值，这样一来函数的使用范围就增加了，返回类型不限于单一的double，而是根据t1+t2推导。示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T1, typename T2&gt;</span><br><span class="line">void Sum(T1&amp; t1, T2&amp; t2, decltype(t1 + t2)&amp; s)</span><br><span class="line">&#123;</span><br><span class="line">    s = t1 + t2; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a = 3;</span><br><span class="line">    long b = 5;</span><br><span class="line">    float c = 1.0f, d = 2.3f;</span><br><span class="line">    long e;</span><br><span class="line">    float f;</span><br><span class="line">    Sum(a, b, e);  // s的类型被推导为long</span><br><span class="line">    Sum(c, d, f);  // s的类型被推导为float</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>（5）实例化模板。通过decltype(hash(nullptr))确定哈希值的类型。示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int getHash(char*);</span><br><span class="line"></span><br><span class="line">map&lt;char*, decltype(getHash)&gt; dict_key;             // 编译失败</span><br><span class="line">map&lt;char*, decltype(getHash(nullptr)) &gt; dict_key1;  // 编译成功</span><br><span class="line"></span><br><span class="line">double getValue(int* p = nullptr);</span><br><span class="line">map&lt;int*, decltype(getValue())&gt; dict_key3;          // 编译成功</span><br></pre></td></tr></table></figure></p>
<p>（6）在标准库中的一些应用。示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;type_traits&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef double (*func)();</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123; </span><br><span class="line">    result_of&lt;func()&gt;::type f;  // 由func()推导其结果类型</span><br><span class="line">&#125;</span><br><span class="line">result_of的可能实现是:</span><br><span class="line">template&lt;class F, class... ArgTypes&gt;</span><br><span class="line">struct result_of&lt;F(ArgTypes)&gt; &#123;</span><br><span class="line">    typedef decltype(</span><br><span class="line">        std::declval&lt;F&gt;()(std::declval&lt;ArgTypes&gt;()...)</span><br><span class="line">    ) type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>decltype推导规则：</p>
<ul>
<li>e是没有带括号的标记符表达式或者类成员访问表达式，那么decltype(e)就是e的实体类型。则推导原类型<ul>
<li>写法decltype(e)</li>
<li>注意当e为表达式（函数）时，其函数不能重载，否则编译失败</li>
</ul>
</li>
<li>e带括号时：<ul>
<li>写法decltype((e))</li>
<li>推导如下：<ul>
<li>若e的值为将亡值，则decltype结果为T&amp;&amp;</li>
<li>若e的值为左值，则decltype结果为T&amp;</li>
<li>若e的值为纯右值，则decltype结果为T</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;typeinfo&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int i = 4;</span><br><span class="line">int arr[5] = &#123;0&#125;;</span><br><span class="line">int *ptr = arr;</span><br><span class="line"></span><br><span class="line">struct S &#123; double d; &#125; s;</span><br><span class="line"></span><br><span class="line">void Overloaded(int);</span><br><span class="line">void Overloaded(char);      // 重载的函数</span><br><span class="line"></span><br><span class="line">int &amp;&amp; RvalRef();</span><br><span class="line"></span><br><span class="line">const bool Func(int);</span><br><span class="line"></span><br><span class="line">// 规则1: 单个标记符表达式以及访问类成员，推导为本类型</span><br><span class="line">decltype(arr) var1;            // int[5], 标记符表达式</span><br><span class="line">decltype(ptr) var2;            // int*, 标记符表达式</span><br><span class="line">decltype(s.d) var4;            // double, 成员访问表达式</span><br><span class="line">decltype(Overloaded) var5;     // 无法通过编译，是个重载的函数</span><br><span class="line"></span><br><span class="line">// 规则2: 将亡值，推导为类型的右值引用</span><br><span class="line">decltype(RvalRef()) var6 = 1;  // int&amp;&amp;</span><br><span class="line"></span><br><span class="line">// 规则3: 左值，推导为类型的引用</span><br><span class="line">decltype(true ? i : i) var7 = i;    // int&amp;, 三元运算符，这里返回一个i的左值</span><br><span class="line">decltype((i)) var8 = i;             // int&amp;, 带圆括号的左值 </span><br><span class="line">decltype(++i) var9 = i;             // int&amp;, ++i返回i的左值</span><br><span class="line">decltype(arr[3]) var10 = i;         // int&amp; []操作返回左值</span><br><span class="line">decltype(*ptr)  var11 = i;          // int&amp; *操作返回左值</span><br><span class="line">decltype(&quot;lval&quot;) var12 = &quot;lval&quot;;    // const char(&amp;)[9], 字符串字面常量为左值</span><br><span class="line"></span><br><span class="line">// 规则4：以上都不是，推导为本类型</span><br><span class="line">decltype(1) var13;              // int, 除字符串外字面常量为右值</span><br><span class="line">decltype(i++) var14;            // int, i++返回右值</span><br><span class="line">decltype((Func(1))) var15;      // const bool, 圆括号可以忽略</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line">增加了一些模板类，帮助进行推导结果的识别：</span><br></pre></td></tr></table></figure></p>
<p>#include &lt;type_traits&gt;</p>
<p>#include <iostream><br>using namespace std;</iostream></p>
<p>int i = 4;<br>int arr[5] = {0};<br>int *ptr = arr;</p>
<p>int &amp;&amp; RvalRef();</p>
<p>int main(){<br>    cout &lt;&lt; is_rvalue_reference&lt;decltype(RvalRef())&gt;::value &lt;&lt; endl;    // 1</p>
<pre><code>cout &lt;&lt; is_lvalue_reference&lt;decltype(true ? i : i)&gt;::value &lt;&lt; endl; // 1
cout &lt;&lt; is_lvalue_reference&lt;decltype((i))&gt;::value &lt;&lt; endl;          // 1
cout &lt;&lt; is_lvalue_reference&lt;decltype(++i)&gt;::value &lt;&lt; endl;          // 1
cout &lt;&lt; is_lvalue_reference&lt;decltype(arr[3])&gt;::value &lt;&lt; endl;       // 1
cout &lt;&lt; is_lvalue_reference&lt;decltype(*ptr)&gt;::value &lt;&lt; endl;         // 1
cout &lt;&lt; is_lvalue_reference&lt;decltype(&quot;lval&quot;)&gt;::value &lt;&lt; endl;       // 1

cout &lt;&lt; is_lvalue_reference&lt;decltype(i++)&gt;::value &lt;&lt; endl;          // 0
cout &lt;&lt; is_rvalue_reference&lt;decltype(i++)&gt;::value &lt;&lt; endl;          // 0
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">与auto不同点：auto类型推导时不能“带走”cv限制符不同。decltype是能够“带走”表达式的cv限制符的。但是，如果对象的定义中有const或volatile限制符，使用decltype进行推导时，其成员变量不会继承const或volatile限制符。示例如下：</span><br></pre></td></tr></table></figure></p>
<p>#include &lt;type_traits&gt;</p>
<p>#include <iostream><br>using namespace std;</iostream></p>
<p>const int ic = 0;<br>volatile int iv;</p>
<p>struct S { int i; };</p>
<p>const S a = {0};<br>volatile S b;<br>volatile S* p = &b;</p>
<p>int main() {<br>    cout &lt;&lt; is_const&lt;decltype(ic)&gt;::value &lt;&lt; endl;      // 1<br>    cout &lt;&lt; is_volatile&lt;decltype(iv)&gt;::value &lt;&lt; endl;   // 1</p>
<pre><code>cout &lt;&lt; is_const&lt;decltype(a)&gt;::value &lt;&lt; endl;       // 1
cout &lt;&lt; is_volatile&lt;decltype(b)&gt;::value &lt;&lt; endl;    // 1

cout &lt;&lt; is_const&lt;decltype(a.i)&gt;::value &lt;&lt; endl;     // 0, 成员不是const
cout &lt;&lt; is_volatile&lt;decltype(p-&gt;i)&gt;::value &lt;&lt; endl; // 0, 成员不是volatile
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">与auto相同点：decltype从表达式推导出类型后，进行类型定义时，也会允许一些冗余的符号，比如cv限制符以及引用符号&amp;。但是，通常情况下，如果推导出的类型已经有了这些属性，冗余的符号则会被忽略。示例如下：</span><br></pre></td></tr></table></figure></p>
<p>#include &lt;type_traits&gt;</p>
<p>#include <iostream><br>using namespace std;</iostream></p>
<p>int i = 1;<br>int &amp; j = i;<br>int * p = &i;<br>const int k = 1;</p>
<p>int main() {<br>    decltype(i) &amp; var1 = i;<br>    decltype(j) &amp; var2 = i;     // 冗余的&amp;, 被忽略 </p>
<pre><code>cout &lt;&lt; is_lvalue_reference&lt;decltype(var1)&gt;::value &lt;&lt; endl;     // 1, 是左值引用

cout &lt;&lt; is_rvalue_reference&lt;decltype(var2)&gt;::value &lt;&lt; endl;     // 0, 不是右值引用
cout &lt;&lt; is_lvalue_reference&lt;decltype(var2)&gt;::value &lt;&lt; endl;     // 1, 只是左值引用

//decltype(p)* var3 = &amp;i;     // 无法通过编译
decltype(p)* var3 = &amp;p;     // var3的类型是int**

auto* v3 = p;               // v3的类型是int*
v3 = &amp;i;

const decltype(k) var4 = 1; // 冗余的const，被忽略 
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">注意`decltype(p)*`，在定义var3的时候，由于p的类型是`int*`，因此var3被定义为`int**`，这跟auto中`*`会被忽略不同，在decltype后的`*`，并不会被忽略。</span><br><span class="line"></span><br><span class="line">## 追踪返沪类型</span><br><span class="line">### 追踪返回类型的引入</span><br><span class="line">由编译器来推导函数模板的返回类型。最直观的写法：</span><br></pre></td></tr></table></figure></p>
<p>template<typename t1, typename t2><br>decltype(t1+t2) Sum(T1 &amp; t1, T2 &amp; t2) {<br>    return t1 + t2;<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">但是t1和t2在使用的时候尚未声明。因此使用：</span><br></pre></td></tr></table></figure></typename></p>
<p>template<typename t1, typename t2><br>auto Sum(T1 &amp; t1, T2 &amp; t2) -&gt; decltype(t1+t2) {<br>    return t1 + t2;<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 使用追踪返回类型的函数</span><br><span class="line">追踪返回类型的函数与普通函数的最大区别在于返回类型后置。也不用写作用域了：</span><br></pre></td></tr></table></figure></typename></p>
<p>class OuterType<br> {<br>     struct InnerType { int i; };<br>     InnerType GetInner();<br>     InnerType it;<br> };</p>
<p> // 可以不写OuterType::InnerType<br> auto OuterType::GetInner()-&gt;InnerType<br> {<br>     return it;<br> }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">返回类型后置，使模板类中的一些类型推导成为可能，编译器会进行合理的推导：</span><br></pre></td></tr></table></figure></p>
<p>#include <iostream><br>using namespace std;</iostream></p>
<p>template<typename t1, typename t2><br>auto Sum(const T1 &amp; t1, const T2 &amp; t2) -&gt; decltype(t1 + t2){<br>    return t1 + t2;<br>} </typename></p>
<p>template <typename t1, typename t2><br>auto Mul(const T1 &amp; t1, const T2 &amp; t2) -&gt; decltype(t1 <em> t2){<br>    return t1 </em> t2;<br>}</typename></p>
<p>int main() {<br>    auto a = 3;<br>    auto b = 4L;<br>    auto pi = 3.14;</p>
<pre><code>auto c = Mul(Sum(a, b), pi);
cout &lt;&lt; c &lt;&lt; endl;  // 21.98
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">追踪返回类型的另一个优势是简化函数的定义：</span><br></pre></td></tr></table></figure></p>
<p>#include &lt;type_traits&gt;</p>
<p>#include <iostream><br>using namespace std;</iostream></p>
<p>// 有的时候，你会发现这是面试题<br>int (<em>(</em>pf())())() {<br>    return nullptr;<br>}</p>
<p>// auto (<em>)() -&gt; int(</em>) () 一个返回函数指针的函数(假设为a函数)<br>// auto pf1() -&gt; auto (<em>)() -&gt; int (</em>)() 一个返回a函数的指针的函数<br>auto pf1() -&gt; auto (<em>)() -&gt; int (</em>)() {<br>    return nullptr;<br>}</p>
<p>int main() {<br>    cout &lt;&lt; is_same&lt;decltype(pf), decltype(pf1)&gt;::value &lt;&lt; endl;    // 1<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">定义了两个类型完全一样的函数pf和pf1，返回的都是一个函数指针，而该函数指针又指向一个返回函数指针的函数。跟踪返回类型只需要依照从左往右的方式，就可将嵌套的声明解析出来。</span><br><span class="line"></span><br><span class="line">跟踪返回类型还可用在函数指针上，其声明方式和追踪返回类型的函数比起来，并没有太大区别：`auto (*fp)()`和`int (*fp)()`的函数指针声明是等价的。</span><br><span class="line"></span><br><span class="line">## 基于范围的for</span><br><span class="line">C++标准库中，利用模板库std::for_each写法：</span><br></pre></td></tr></table></figure></p>
<p>#include <algorithm></algorithm></p>
<p>#include <iostream><br>using namespace std;</iostream></p>
<p>int action1(int &amp; e){ e *= 2; }<br>int action2(int &amp; e){ cout &lt;&lt; e &lt;&lt; ‘\t’; }</p>
<p>int main() {<br>    int arr[5] = { 1, 2, 3, 4, 5};<br>    for_each(arr, arr + sizeof(arr)/sizeof(arr[0]), action1);<br>    for_each(arr, arr + sizeof(arr)/sizeof(arr[0]), action2);<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for_each使用了迭代器的概念，其迭代器就是指针。</span><br></pre></td></tr></table></figure></p>
<p>#include <iostream><br>using namespace std;</iostream></p>
<p>int main() {<br>    int arr[5] = { 1, 2, 3, 4, 5 };<br>    for (int &amp; e: arr)<br>        e *= 2;</p>
<pre><code>for (int &amp; e: arr)
    cout &lt;&lt; e &lt;&lt; &apos;\t&apos;;
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">是否能够使用基于范围的for循环，必须：</span><br><span class="line">- for循环迭代的范围是可确定的，对于类来说必须是有begin和end的，对于数组，就是数组的第一个和最后一个元素之间的范围。</span><br><span class="line">- 其次基于范围的for循环，要求迭代对象实现++和==操作。</span><br><span class="line"></span><br><span class="line">数组大小不定的情况是不能用的，比如：</span><br></pre></td></tr></table></figure></p>
<p>#include <iostream><br>using namespace std;</iostream></p>
<p>int func(int a[]) {</p>
<pre><code>for (auto e: a) // 编译失败
    cout &lt;&lt; e;
</code></pre><p>}</p>
<p>int main() {<br>    int arr[] = {1, 2, 3, 4, 5};<br>    func(arr);<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 提高类型安全</span><br><span class="line">## 强类型枚举</span><br><span class="line">枚举要定义一个类别，并穷举同一类别下的个体以供代码中使用。比如：</span><br></pre></td></tr></table></figure></p>
<p>enum Gender {Male, Female};<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">定义了Gender类型，默认为Male赋值为0，为Female赋值为1。可以定义匿名枚举`enum &#123;Male, Female&#125;;`，其中的Male和Female都是编译时期的名字。</span><br><span class="line"></span><br><span class="line">不过更受推荐的是静态常量：</span><br></pre></td></tr></table></figure></p>
<p>const static int Male = 0;<br>const static int Female = 1;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">编译器可能为静态常量在目标代码中产生实际的数据，这会增加一些存储空间。</span><br><span class="line"></span><br><span class="line">由于枚举存在一些缺陷，通常对枚举类型进行一些封装：</span><br></pre></td></tr></table></figure></p>
<p>#include <iostream><br>using namespace std;</iostream></p>
<p>class Type {<br>public:<br>    enum type { general, light, medium, heavy };<br>    type val;<br>public:<br>    Type(type t): val(t){}<br>    bool operator &gt;= (const Type &amp; t) { return val &gt;= t.val; }<br>    static const Type General, Light, Medium, Heavy;<br>}; </p>
<p>const Type Type::General(Type::general);<br>const Type Type::Light(Type::light);<br>const Type Type::Medium(Type::medium);<br>const Type Type::Heavy(Type::heavy);</p>
<p>class Category {<br>public:<br>    enum category { pistol, machineGun, cannon };<br>    category val;<br>public:<br>    Category(category c): val(c) {}<br>    bool operator &gt;= (const Category &amp; c) { return val &gt;= c.val; }<br>    static const Category Pistol, MachineGun, Cannon;<br>};</p>
<p>const Category Category::Pistol(Category::pistol);<br>const Category Category::MachineGun(Category::machineGun);<br>const Category Category::Cannon(Category::cannon);</p>
<p>struct Killer {<br>    Killer(Type t, Category c) : type(t), category(c){}<br>    Type type;<br>    Category category;<br>};</p>
<p>int main() {<br>    // 使用类型包装后的enum<br>    Killer notCool(Type::General, Category::MachineGun);<br>    // …<br>    // …其它很多代码…<br>    // …<br>    if (notCool.type &gt;= Type::General)   // 可以通过编译<br>        cout &lt;&lt; “It is not general” &lt;&lt; endl;</p>
<p>#if 0<br>    if (notCool.type &gt;= Category::Pistol)   // 该句无法编译通过<br>        cout &lt;&lt; “It is not a pistol” &lt;&lt; endl;</p>
<p>#endif<br>    // …<br>    cout &lt;&lt; is_pod<type>::value &lt;&lt; endl;        // 0<br>    cout &lt;&lt; is_pod<category>::value &lt;&lt; endl;    // 0<br>    return 0;<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">封装即是将枚举成员成为class的静态成员，避免被转换为整型数据，枚举成员也不会污染全局命名空间了，必须加上类名才能使用。但是枚举类型所占用的空间大小也是不确定的，这是基于编译器的具体实现。下边这个例子普通的枚举使用4字节的内存，当需要的时候会扩展到8字节，</span><br></pre></td></tr></table></figure></category></type></p>
<p>#include <iostream><br>using namespace std;</iostream></p>
<p>enum C { C1 = 1, C2 = 2};<br>enum D { D1 = 1, D2 = 2, Dbig = 0xFFFFFFF0U };<br>enum E { E1 = 1, E2 = 2, Ebig = 0xFFFFFFFFFLL};<br>int main() {<br>    cout &lt;&lt; sizeof(C1) &lt;&lt; endl;   // 4</p>
<pre><code>cout &lt;&lt; Dbig &lt;&lt; endl;   // 编译器输出不同,GCC：4294967280
cout &lt;&lt; sizeof(D1) &lt;&lt; endl;     // 4
cout &lt;&lt; sizeof(Dbig) &lt;&lt; endl;   // 4

cout &lt;&lt; Ebig &lt;&lt; endl;   // 68719476735
cout &lt;&lt; sizeof(E1) &lt;&lt; endl; // 8
return 0;
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">为了避免引入枚举类的隐式类型转换，C++引入了**强类型枚举**。声明时只需要在enum后加上class：</span><br></pre></td></tr></table></figure></p>
<p>enum class Type { General, Light, Medium, Heavy };<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">强类型枚举有以下几点优势：</span><br><span class="line">- 强作用域。强类型枚举成员的名称不会被输出到其父作用域，所以不同枚举类型定义同名枚举成员编译不会出现重定义错误。</span><br><span class="line">- 使用枚举类型的枚举成员时，必须指明所属范围，单独的枚举成员名则不再具有意义。</span><br><span class="line">- 限制转换。强类型枚举成员的值不可以与整型发生相互隐式转换。</span><br><span class="line">- 可以指定底层类型。强类型枚举默认的底层类型是int，但也可以显式地指定底层类型。`enum class Type: char &#123; General, Light, Medium, Heavy &#125;;`，避免了不可移植性。</span><br><span class="line">- 不可声明匿名强类型枚举。由于强类型枚举是强类型作用域的，故匿名的enum class可能什么都做不了，匿名强类型枚举会编译报错。</span><br></pre></td></tr></table></figure></p>
<p>#include <iostream><br>using namespace std;</iostream></p>
<p>enum class Type { General, Light, Medium, Heavy };<br>enum class Category { General = 1, Pistol, MachineGun, Cannon };</p>
<p>int main() {<br>    Type t = Type::Light;<br>    t = General;                    // 编译失败，必须使用强类型名称<br>    if (t == Category::General)     // 编译失败，必须使用Type中的General<br>        cout &lt;&lt; “General Weapon” &lt;&lt; endl;<br>    if (t &gt; Type::General)          // 通过编译<br>        cout &lt;&lt; “Not General Weapon” &lt;&lt; endl;<br>    if (t &gt; 0)                      // 编译失败，无法转换为int类型<br>        cout &lt;&lt; “Not General Weapon” &lt;&lt; endl;<br>    if ((int)t &gt; 0)                 // 通过编译<br>        cout &lt;&lt; “Not General Weapon” &lt;&lt; endl;<br>    cout &lt;&lt; is_pod<type>::value &lt;&lt; endl;        // 1<br>    cout &lt;&lt; is_pod<category>::value &lt;&lt; endl;    // 1<br>    return 0;<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">枚举类型之间也可以进行比较，但不能够隐式地转为int型。如果将强类型枚举转化为其他类型必须进行显式转换。而且Type和Category都是POD类型，不会像class封装版本一样被视为结构体。此外，由于可以指定底层基于的基本类型，可以避免不可移植性和节省内存空间：</span><br></pre></td></tr></table></figure></category></type></p>
<p>#include <iostream><br>using namespace std;</iostream></p>
<p>enum class C : char { C1 = 1, C2 = 2};<br>enum class D : unsigned int { D1 = 1, D2 = 2, Dbig = 0xFFFFFFF0U };</p>
<p>int main() {<br>    cout &lt;&lt; sizeof(C::C1) &lt;&lt; endl;   // 1<br>    cout &lt;&lt; (unsigned int)D::Dbig &lt;&lt; endl;   // 编译器输出一致,4294967280<br>    cout &lt;&lt; sizeof(D::D1) &lt;&lt; endl;     // 4<br>    cout &lt;&lt; sizeof(D::Dbig) &lt;&lt; endl;   // 4<br>    return 0;<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">C++11对传统枚举类型进行了扩展：</span><br><span class="line">- 可指定底层基本类型。如char类型枚举，应用比如：</span><br></pre></td></tr></table></figure></p>
<p>enum Type : char { Low, Middle, High };<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- 从C++11后，枚举类型的成员可以在枚举类型的作用域内有效。比如：</span><br></pre></td></tr></table></figure></p>
<p>enum Type { Low, Middle, High };<br>Type type1 = Middle;<br>Type type2 = Type::Middle;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">其中Middle与Type::Middle都是合法的使用形式。</span><br><span class="line"></span><br><span class="line">## 堆内存管理：智能指针与垃圾回收</span><br><span class="line">### 显式内存管理</span><br><span class="line">从语言层面来讲，我们可以将堆内存的分配与释放归纳为以下一些问题。</span><br><span class="line">- 野指针：一些内存单元已被释放，之前指向它的指针却还在被使用。这些内存有可能被运行时系统重新分配给程序使用，从而导致了无法预测的错误。</span><br><span class="line">- 重复释放：程序试图去释放已经被释放过的内存单元，或者释放已经被重新分配过的内存单元，就会导致重复释放错误。</span><br><span class="line">- 内存泄漏：不再需要使用的内存单元如果没有被释放就会导致内存泄漏。如果程序不断地重复进行这类操作，将会导致内存占用剧增。</span><br><span class="line"></span><br><span class="line">在C++11新标准中，智能指针被进行了改进，以更加适应实际的应用需求。而进一步地，标准库还提供了所谓“最小垃圾回收”的支持。C++11标准中改用unique_ptr，shared_ptr及weak_ptr等智能指针来自动回收堆分配的对象。</span><br></pre></td></tr></table></figure></p>
<p>#include <memory></memory></p>
<p>#include <iostream><br>using namespace std;</iostream></p>
<p>int main() {<br>    unique_ptr<int> up1(new int(11));   // 无法复制的unique_ptr<br>    unique_ptr<int> up2 = up1;          // 不能通过编译<br>    cout &lt;&lt; *up1 &lt;&lt; endl;   // 11</int></int></p>
<pre><code>unique_ptr&lt;int&gt; up3 = move(up1);    // 现在p3是数据的唯一的unique_ptr

cout &lt;&lt; *up3 &lt;&lt; endl;   // 11
cout &lt;&lt; *up1 &lt;&lt; endl;   // 运行时错误
up3.reset();            // 显式释放内存
up1.reset();            // 不会导致运行时错误
cout &lt;&lt; *up3 &lt;&lt; endl;   // 运行时错误

shared_ptr&lt;int&gt; sp1(new int(22));
shared_ptr&lt;int&gt; sp2 = sp1;

cout &lt;&lt; *sp1 &lt;&lt; endl;   // 22
cout &lt;&lt; *sp2 &lt;&lt; endl;   // 22

sp1.reset();
cout &lt;&lt; *sp2 &lt;&lt; endl;   // 22
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">代码中使用了unique_ptr和shared_ptr自动释放堆对象的内存，由于每个指针都重载了`*`操作符，可以使用`*up1`访问所分配的内存。直观来看，unique_ptr与所指对象的内存绑定紧密，不能与其他unique_ptr类型的指针对象共享所指对象的内存，这种所有权只能通过move函数转移。unique_ptr是一个删除了拷贝构造函数、保留了移动构造函数的指针封装类型。</span><br><span class="line"></span><br><span class="line">shared_ptr允许多个智能指针共享地拥有同一堆分配对象的内存。只有在引用计数归零的时候，shared_ptr才会真正释放所占用的堆内存的空间。weak_ptr可以指向shared_ptr指针指向的对象内存，却并不拥有该内存。而使用weak_ptr成员lock，则可返回其指向内存的一个shared_ptr指针，且在其指向的内存无效时返回NULL。</span><br></pre></td></tr></table></figure></p>
<p>#include <memory></memory></p>
<p>#include <iostream><br>using namespace std;</iostream></p>
<p>void Check(weak_ptr<int> &amp; wp) {<br>    shared_ptr<int> sp = wp.lock(); // 转换为shared_ptr<int><br>    if (sp != nullptr)<br>        cout &lt;&lt; “still “ &lt;&lt; *sp &lt;&lt; endl;<br>    else<br>        cout &lt;&lt; “pointer is invalid.” &lt;&lt; endl;<br>}</int></int></int></p>
<p>int main() {<br>    shared_ptr<int> sp1(new int(22));<br>    shared_ptr<int> sp2 = sp1;<br>    weak_ptr<int> wp = sp1; // 指向shared_ptr<int>所指对象</int></int></int></int></p>
<pre><code>cout &lt;&lt; *sp1 &lt;&lt; endl;   // 22
cout &lt;&lt; *sp2 &lt;&lt; endl;   // 22
Check(wp);              // still 22

sp1.reset();
cout &lt;&lt; *sp2 &lt;&lt; endl;   // 22
Check(wp);              // still 22

sp2.reset();
Check(wp);              // pointer is invalid
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 垃圾回收的分类</span><br><span class="line">垃圾回收的方式很多，但主要分为以下几种：</span><br><span class="line">- 基于引用计数（reference counting garbage collector）的垃圾回收器</span><br><span class="line">    - 简单地说，引用计数主要是使用系统记录对象被引用（引用、指针）的次数。当对象被引用的次数变为0时，该对象即可被视作“垃圾”而回收。使用引用计数做垃圾回收的算法的一个优点是实现很简单，与其他垃圾回收算法相比，该方法不会造成程序暂停，因为计数的增减与对象的使用是紧密结合的。</span><br><span class="line">    - 此外，引用计数也不会对系统的缓存或者交换空间造成冲击，因此被认为“副作用&quot;较小。</span><br><span class="line">    - 但是这种方法比较难处理“环形引用”问题，此外由于计数带来的额外开销也并不小，所以在实用上也有一定的限制。</span><br><span class="line">- 基于跟踪处理（tracing garbage collector）的垃圾回收器</span><br><span class="line">    - 相比于引用计数，跟踪处理的圾回收机制被更为广泛地应用。其基本方法是产生跟踪对象的关系图，然后进行垃圾回收。使用跟踪方式的垃圾回收算法主要有以下几种：</span><br><span class="line">        - 标记——清除（Mark-Sweep）：顾名思义，这个算法可以分为两个过程。首先该算法将程序中正在使用的对象视为“根对象”，从根对象开始查找它们所引用的堆空间，并在这些堆空间上做标记。当标记结束后，所有被标记的对象就是可达对象（ReachableObject）或活对象（LiveObject），而没有被标记的对象就被认为是垃圾，在第二步的清扫（Sweep）阶段会被回收掉。这种方法的特点是活的对象不会被移动，但是其存在会出现大量的内存碎片的问题。</span><br><span class="line">        - 标记——整理（Mark-Compact）：这个算法标记的方法和标记．清除方法一样，但是标记完之后，不再遍历所有对象清扫垃圾了，而是将活的对象向“左”靠齐，这就解决了内存碎片的问题。标记——整理的方法有个特点就是移动活的对象，因此相应的，程序中所有对堆内存的引用都必须更新。</span><br><span class="line">        - 标记——拷贝（Mark-Copy）：这种算法将堆空间分为两个部分：From和To。刚开始系统只从From的堆空间里面分配内存，当From分配满了之后，开始垃圾回收，从From找出所有活着的，拷贝到To里，这样From就剩下死的了，To里的对象都是紧密排列的。From和To交换角色，从新的From里开始分配。</span><br><span class="line"></span><br><span class="line">### C++与垃圾回收</span><br><span class="line">C++11新标准为做到最小垃圾回收支持，首先对“安全”的指针进行了定义，**安全派生**的指针，安全派生的指针是指向由new分配的对象或其子对象指向的指针，操作包括：</span><br><span class="line">- 在解引用基础上的引用，如`&amp;*p`；</span><br><span class="line">- 定义明确的指针操作，如`p+1`；</span><br><span class="line">- 定义明确的指针转换，如`static_cast&lt;void*&gt;(p)`；</span><br><span class="line">- 指针和整型之间的reinterpret_cast，比如`reinterpret_cast&lt;intptr_t&gt;(p)`；</span><br><span class="line"></span><br><span class="line">如果代码中出现了指针不安全使用的状况，C++11允许程序员通过API通知垃圾回收器不得回收该内存，需声明该内存为**可到达**的：</span><br></pre></td></tr></table></figure></p>
<p>void declare_reachable(void<em> p)<br>template <class t> T </class></em>undeclare_reachable(T *p) noexcept<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">declare_reachable显式地通知垃圾回收器一个对象应该是可达的。undeclare_reachable则取消这种声明。</span><br></pre></td></tr></table></figure></p>
<p>#include <memory><br>using namespace std;</memory></p>
<p>int main() {<br>    int <em>p = new int;<br>    declare_reachable(p);   // 在p被隐藏之前声明为可达的<br>    int </em>q = (int<em>)((long long)p ^ 2012);<br>    // 解除可达声明<br>    q = undeclare_reachable<int>((int</int></em>)((long long)q ^ 2012));<br>    *q = 10;<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这里，我们在p指针被不安全派生（隐藏）之前使用declare_reachable声明其是可达的。这样一来，它会被垃圾回收器忽略而不会被回收。而在我们通过可逆的异或运算使得q指针指向p所指对象时，我们则使用了undeclare_reachable来取消可达声明。注意undeclare_reachable不是通知垃圾回收器p所指对象已经可以回收。实际上，declare_reachable和undeclare_reachable只是确立了一个代码范围，即在两者之间的代码运行中，p所指对象不会被垃圾回收器所回收。</span><br><span class="line"></span><br><span class="line">有的时候程序员会选择在一大片连续的堆内存上进行指针式操作，为了让垃圾回收器不关心该区域，也可以使用declare_no_pointers及undeclare_no_pointers函数来告诉垃圾回收器该内存区域不存在有效的指针。</span><br></pre></td></tr></table></figure></p>
<p>void declare_no_pointers(char <em>p, size_t n) noexcept;<br>void undeclare_no_pointers(char </em>p, size_t n) noexcept;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">其使用方式与declare_reachable及undeclare_reachable类似，不过指定的是从p开始的连续n的内存。</span><br><span class="line"></span><br><span class="line"># 提高性能及操作硬件的能力</span><br><span class="line">## 常量表达式</span><br><span class="line">### 运行时常量性和编译时常量性</span><br><span class="line">常量表示该值不可修改，通常通过const关键字来修饰的。const还可以修饰函数参数、函数返回值、函数本身、类等，都表示在运行时数据的不可变更性。有的时候需要**编译时期的常量性**，const修饰的函数返回值只能保证在运行时期内其值是不可更改的。</span><br></pre></td></tr></table></figure></p>
<p>const int GetConst() { return 1; }</p>
<p>void Constless(int cond) {<br>     int arr[GetConst()] = {0};     // 无法通过编译<br>     enum { e1 = GetConst(), e2 };  // 无法通过编译<br>     switch (cond) {<br>         case GetConst():           // 无法通过编译<br>             break;<br>         default:<br>             break;<br>     }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">C++11中对编译时期常量的回答是**constexpr**，即常量表达式，编译器会在编译时期对GetConst进行计算，从而将其视为一个编译时期的常量。</span><br><span class="line"></span><br><span class="line">### 常量表达式函数</span><br><span class="line">大概有以下几种：</span><br><span class="line">- 函数中只能有一条语句，且为return语句。但是不会产生实际作用的，比如using、static_assert等都可以有。</span><br><span class="line">- 函数必须返回值，不能是返回void</span><br><span class="line">- 在使用前必须已有定义，不能只是声明</span><br><span class="line">- return返回语句表达式中不能使用非常量表达式的函数、全局数据。因为其return表达式语句不能包含运行时才确定返回值的函数。</span><br><span class="line"></span><br><span class="line">### 常量表达式值</span><br><span class="line">常量表达式值必须被一个常量表达式赋值，而跟常量表达式函数一样，常量表达式值必须在使用前被初始化。</span><br></pre></td></tr></table></figure></p>
<p>const int i = 1;<br>constexpr int j = 1;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">两者在大多数情况下是没有区别的。但是如果i在全局名字空间中，编译器一定会为i产生数据；如果不是有代码显式地使用了它的地址，编译器可以选择不为它生成数据，而仅将其当做编译时期的值。在C++11中，编译时的浮点数常量表达式值还是被允许的。标准要求编译时的浮点常量表达式值的精度要至少等于（或者高于）运行时的浮点数常量的精度。</span><br><span class="line"></span><br><span class="line">C++11标准中，constexpr关键字是不能用于修饰自定义类型的定义的。比如：</span><br></pre></td></tr></table></figure></p>
<p>constexpr struct MyType { int i; };<br>Constexpr MyType mt = {0};<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在C++11中，就是无法通过编译的。正确地做法是，定义自定义常量构造函数：</span><br></pre></td></tr></table></figure></p>
<p>struct MyType {<br>    constexpr MyType(int x): i(x){}<br>    int i;<br>};<br>constexpr MyType mt = {0};<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">常量表达式的构造函数：函数体必须为空，且初始化列表只能由常量表达式来赋值。</span><br><span class="line"></span><br><span class="line">使用常量表达式支持递归：</span><br></pre></td></tr></table></figure></p>
<p>#include <iostream><br>using namespace std;</iostream></p>
<p>constexpr int Fibonacci(int n) {<br>    return (n == 1) ? 1 : ((n == 2) ? 1 : Fibonacci(n - 1) + Fibonacci(n - 2));<br>}</p>
<p>int main() {<br>    int fib[] = {<br>        Fibonacci(11), Fibonacci(12),<br>        Fibonacci(13), Fibonacci(14),<br>        Fibonacci(15), Fibonacci(16)<br>    };</p>
<pre><code>for (int i : fib) cout &lt;&lt; i &lt;&lt; endl;
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">改成使用模板元编程的方式：</span><br></pre></td></tr></table></figure></p>
<p>#include <iostream><br>using namespace std;</iostream></p>
<p>template <long num><br>struct Fibonacci{<br>    static const long val = Fibonacci<num 1 ->::val + Fibonacci<num 2 ->::val;<br>};</num></num></long></p>
<p>template &lt;&gt; struct Fibonacci<2> { static const long val = 1; };<br>template &lt;&gt; struct Fibonacci<1> { static const long val = 1; };<br>template &lt;&gt; struct Fibonacci<0> { static const long val = 0; };</0></1></2></p>
<p>int main() {<br>    int fib[] = {<br>        Fibonacci<11>::val, Fibonacci<12>::val,<br>        Fibonacci<13>::val, Fibonacci<14>::val,<br>        Fibonacci<15>::val, Fibonacci<16>::val,<br>    };</16></15></14></13></12></11></p>
<pre><code>for (int i : fib) cout &lt;&lt; i &lt;&lt; endl;
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">我们定义了一个非类型参数的模板Fibonacci。该模板类定义了一个静态变量val，而val的定义方式是递归的。因此模板将会递归地进行推导。此外，我们还通过偏特化定义了模板推导的边界条件，即斐波那契的初始值。那么模板在推导到边界条件的时候就会终止推导。通过这样的方法，我们同样可以在编译时进行值计算，从而生成数组的值。</span><br><span class="line"></span><br><span class="line">任何程序中需要表达的计算，都可以通过constexpr元编程的方式来表达。由于constexpr支持浮点数运算（模板元编程只支持整型），支持三元表达式、逗号表达式，所以很多人认为constexpr元编程将会比模板元编程更加强大。从这个角度讲，constexpr元编程将非常让人期待。</span><br><span class="line"></span><br><span class="line">**并不是使用了constexpr，编译器就一定会在编译时期对常量表达式函数进行值计算**。如果用g++的默认优化级别来编译，我们实验机上会产生调用</span><br><span class="line">Fibonacci函数的代码（clang++在-O0级别也会有这样的效果）。在C++11标准中，我们也没有看到要求编译器一定要对常量表达式进行编译时期的值计算。标准只是定义了可以用于编译时进行值运算的常量表达式的定义，却没有强制要求编译器一定在编译时进行值运算。</span><br><span class="line"></span><br><span class="line">## 变长模板</span><br><span class="line">### 变长函数和变长的模板参数</span><br><span class="line">通过使用变长函数（variadic funciton），printf的实现能够接受任何长度的参数列表。不过无论是宏，还是变长参数，整个机制的设计上，没有任何一</span><br><span class="line">个对于传递参数的类型是了解的。我们可以看看变长函数的例子。</span><br></pre></td></tr></table></figure></p>
<p>#include &lt;stdio.h&gt;</p>
<p>#include &lt;stdarg.h&gt;</p>
<p>double SumOfFloat(int count, …) {<br>    va_list ap;<br>    double sum = 0;<br>    va_start(ap, count);            // 获得变长列表的句柄ap<br>    for(int i = 0; i &lt; count; i++)<br>        sum += va_arg(ap, double);  // 每次获得一个参数<br>    va_end(ap);<br>    return sum;<br>}</p>
<p>int main() {<br>    printf(“%f\n”, SumOfFloat(3, 1.2f, 3.4, 5.6));  // 10.200000<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">我们声明了一个名为SumOfFloat变长函数。变长函数的第一个参数count表示的是变长参数的个数，这必须由SumOfFloat的调用者传递进来。而在被调用</span><br><span class="line">者中，则需要通过一个类型为`valist`的数据结构ap来辅助地获得参数。可以看到，这里代码首先使用`va_start`函数对ap进行初始化，使得ap成为被传递的变长参数的一个“句柄”，而后代码再使用`va_arg`数从ap中将参数一一取出用于运算。</span><br><span class="line"></span><br><span class="line">下图显示了一种变长函数的可能的实现方式</span><br><span class="line">![](/img/20200405175700.jpg)</span><br><span class="line"></span><br><span class="line">在本例中，只有使用表达式va_arg(ap,double)的时候，我们才按照类型（实际是按类型长度）去变长参数列表中获得指定参数。而如何打印则得益于传递在字符串中的形如&quot;%s”、&quot;%d”这样的转义字，以及传递的count参数。这样会导致一些问题，引入**变长模板**</span><br><span class="line"></span><br><span class="line">### 变长模板：模板参数包和函数参数包</span><br><span class="line">使用以下代码声明tuple是一个变长类模板，`template&lt;typename... Elements&gt; class tuple`，三个点代表Elements是一个**模板参数包**，类模板tuple可以接受任意多个参数作为模板参数，对于`tuple&lt;int, char, double&gt;`将多个模板参数打包成为单个的模板参数包。为了使用模板参数包，总是需要将其**解包**，通过**包扩展**实现：</span><br></pre></td></tr></table></figure></p>
<p>template&lt;typename… A&gt; class Template: private B&lt;A…&gt;{}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这里的A就是一个包扩展，参数包会在包扩展的位置展开多个参数：</span><br></pre></td></tr></table></figure></p>
<p>template<typename t1, typename t2> class B{};<br>template&lt;typename… A&gt; class Template: private B&lt;A…&gt;{};<br>Template&lt;X, Y&gt; xy;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">声明了基类为`B&lt;X, Y&gt;`的模板类`Template&lt;X, Y&gt;`的对象xy。</span><br><span class="line"></span><br><span class="line">下边是用变长模板实现tuple的例子：</span><br></pre></td></tr></table></figure></typename></p>
<p>template &lt;typename… Elements&gt; class tuple;        // 变长模板的声明</p>
<p>template<typename head, typename... tail>           // 递归的偏特化定义<br>class tuple&lt;Head, Tail…&gt; : private tuple&lt;Tail…&gt; {<br>    Head head;<br>};</typename></p>
<p>template&lt;&gt; class tuple&lt;&gt; {};                        // 边界条件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">声明了变长模板类tuple，其只包含一个模板参数，即Elements模板参数包。此外，我们又**偏特化**地定义了一个双参数的的版本。该偏特化版本的tuple包含了两个参数，一个是类型模板参数Head，另一个则是模板参数包Tail，在实现中，我们将Head型的数据作为`tuple&lt;Head,Tail...&gt;`的第一个成员，而</span><br><span class="line">将使用了包扩展表达式的模板类`tuple&lt;Tail..&gt;`作为`tuple&lt;Head，Tail...&gt;`的私有基类。这样一来会引起基类的递归构造，在tuple的参数包为0个的时候会结束。</span><br><span class="line"></span><br><span class="line">实现C++11中新的printf的例子：</span><br></pre></td></tr></table></figure></p>
<p>#include <iostream></iostream></p>
<p>#include <stdexcept><br>using namespace std;</stdexcept></p>
<p>void Printf(const char<em> s) {<br>    while (</em>s) {<br>        if (<em>s == ‘%’ &amp;&amp; </em>++s != ‘%’)<br>            throw runtime_error(“invalid format string: missing arguments”);<br>                cout &lt;&lt; *s++;<br>    }<br>}</p>
<p>template<typename t, typename... args><br>void Printf(const char<em> s, T value, Args… args) {<br>    while (</em>s) {<br>        if (<em>s == ‘%’ &amp;&amp; </em>++s != ‘%’) {<br>            cout &lt;&lt; value;<br>            return Printf(++s, args…);<br>        }<br>        cout &lt;&lt; *s++;<br>    }<br>    throw runtime_error(“extra arguments provided to Printf”);<br>}</typename></p>
<p>int main() {<br>    Printf(“hello %s\n”, string(“world”));  // hello world<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">C++标准定义了以下7种参数包可以展开的位置：</span><br><span class="line">- 表达式</span><br><span class="line">- 初始化列表</span><br><span class="line">- 基类描述列表</span><br><span class="line">- 类成员初始化列表</span><br><span class="line">- 模板参数列表</span><br><span class="line">- 通用属性列表</span><br><span class="line">- lambda函数的捕捉列表</span><br><span class="line"></span><br><span class="line">我们还可以声明一些有趣的包扩展表达式。比如声明了Arg为参数包，那么我们可以使用`Arg&amp;&amp;...`这样的包扩展表达式，其解包后等价于`Arg1&amp;&amp;, ... ,Argn&amp;&amp;`。一个更为有趣的包扩展表达式如下：</span><br></pre></td></tr></table></figure></p>
<p>template&lt;typename… A&gt; class T: private B<a>…{};<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意这个包扩展跟下面的类模板声明：</span><br></pre></td></tr></table></figure></a></p>
<p>template&lt;typename… A&gt; class T: private B&lt;A…&gt;{};<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在解包后是不同的，对于同样的实例化`T&lt;X，Y&gt;`，前者会解包为：</span><br></pre></td></tr></table></figure></p>
<p>class T&lt;X, Y&gt;: private B<x>, private B<y> {};<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">即多重继承的派生类，而后者则会解包为：</span><br></pre></td></tr></table></figure></y></x></p>
<p>class T&lt;X, Y&gt;: private B&lt;X, Y&gt;{};<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">即派生于多参数的模板类的派生类，这点存在着本质的不同。</span><br><span class="line"></span><br><span class="line">`sizeof...`用于计算参数包中参数的个数：</span><br></pre></td></tr></table></figure></p>
<p>#include <cassert></cassert></p>
<p>#include <iostream><br>using namespace std;</iostream></p>
<p>template&lt;class…A&gt; void Print(A…arg) {<br>    assert(false);  // 非6参数偏特化版本都会默认assert(false)<br>}</p>
<p>// 偏特化6参数的版本<br>void Print(int a1, int a2, int a3, int a4, int a5, int a6) {<br>    cout &lt;&lt; a1 &lt;&lt; “, “ &lt;&lt; a2 &lt;&lt; “, “ &lt;&lt; a3 &lt;&lt; “, “<br>        &lt;&lt; a4 &lt;&lt; “, “ &lt;&lt; a5 &lt;&lt; “, “ &lt;&lt; a6 &lt;&lt; endl;<br>}</p>
<p>template&lt;class…A&gt; int Vaargs(A…args){<br>    int size = sizeof…(A);    // 计算变长包的长度</p>
<pre><code>switch(size){
    case 0: Print(99, 99, 99, 99, 99, 99);
            break;
    case 1: Print(99, 99, args..., 99, 99, 99);
            break;
    case 2: Print(99, 99, args..., 99, 99);
            break;
    case 3: Print(args..., 99, 99, 99);
            break;
    case 4: Print(99, args..., 99);
            break;
    case 5: Print(99, args...);
            break;
    case 6: Print(args...);
            break;
    default:
            Print(0, 0, 0, 0, 0, 0);
}
return size;
</code></pre><p>}</p>
<p>int main(void){<br>    Vaargs();   // 99, 99, 99, 99, 99, 99<br>    Vaargs(1);  // 99, 99, 1, 99, 99, 99<br>    Vaargs(1, 2);   // 99, 99, 1, 2, 99, 99<br>    Vaargs(1, 2, 3);    // 1, 2, 3, 99, 99, 99<br>    Vaargs(1, 2, 3, 4); // 99, 1, 2, 3, 4, 99<br>    Vaargs(1, 2, 3, 4, 5);  // 99, 1, 2, 3, 4, 5<br>    Vaargs(1, 2, 3, 4, 5, 6);   // 1, 2, 3, 4, 5, 6<br>    Vaargs(1, 2, 3, 4, 5, 6, 7);    // 0, 0, 0, 0, 0, 0<br>    return 0;<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">变长模板参数和完美转发的结合：</span><br></pre></td></tr></table></figure></p>
<p>#include <iostream><br>using namespace std;</iostream></p>
<p>struct A {<br>    A(){}<br>    A(const A&amp; a) { cout &lt;&lt; “Copy Constructed “ &lt;&lt; <strong>func</strong> &lt;&lt; endl; }<br>    A(A&amp;&amp; a) { cout &lt;&lt; “Move Constructed “ &lt;&lt; <strong>func</strong> &lt;&lt; endl; }<br>};</p>
<p>struct B {<br>    B(){}<br>    B(const B&amp; b) { cout &lt;&lt; “Copy Constructed “ &lt;&lt; <strong>func</strong> &lt;&lt; endl; }<br>    B(B&amp;&amp; b) { cout &lt;&lt; “Move Constructed “ &lt;&lt; <strong>func</strong> &lt;&lt; endl; }<br>};</p>
<p>// 变长模板的定义<br>template &lt;typename… T&gt; struct MultiTypes;<br>template <typename t1, typename... t><br>struct MultiTypes&lt;T1, T…&gt; : public MultiTypes&lt;T…&gt;{<br>    T1 t1;<br>    MultiTypes&lt;T1, T…&gt;(T1 a, T… b):<br>        t1(a), MultiTypes&lt;T…&gt;(b…) {<br>            cout &lt;&lt; “MultiTypes&lt;T1, T…&gt;(T1 a, T… b)” &lt;&lt; endl;<br>        }<br>};<br>template &lt;&gt; struct MultiTypes&lt;&gt; {<br>    MultiTypes&lt;&gt;(){ cout &lt;&lt; “MultiTypes&lt;&gt;()” &lt;&lt; endl;}<br>};</typename></p>
<p>// 完美转发的变长模板<br>template &lt;template &lt;typename…&gt; class VariadicType, typename… Args&gt;<br>VariadicType&lt;Args…&gt; Build(Args&amp;&amp;… args)<br>{<br>    return VariadicType&lt;Args…&gt;(std::forward<args>(args)…);<br>}</args></p>
<p>int main() {<br>    A a;<br>    B b;</p>
<pre><code>Build&lt;MultiTypes&gt;(a, b);
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 原子操作</span><br><span class="line">原子操作通过**互斥**访问保证。如果想做到粗粒度的互斥，则借助POSIX的pthread库中的互斥锁可以实现：</span><br></pre></td></tr></table></figure></p>
<p>#include &lt;pthread.h&gt;</p>
<p>#include <iostream><br>using namespace std;</iostream></p>
<p>static long long total = 0;<br>pthread_mutex_t m = PTHREAD_MUTEX_INITIALIZER;</p>
<p>void<em> func(void </em>) {<br>    long long i;<br>    for(i = 0; i &lt; 100000000LL;i++) {<br>        pthread_mutex_lock(&amp;m);<br>        total += i;<br>        pthread_mutex_unlock(&amp;m);<br>    }<br>}</p>
<p>int main() {<br>    pthread_t thread1, thread2;<br>    if (pthread_create(&amp;thread1, NULL, &amp;func, NULL)){<br>        throw;<br>    }<br>    if (pthread_create(&amp;thread2, NULL, &amp;func, NULL)){<br>        throw;<br>    }<br>    pthread_join(thread1, NULL);<br>    pthread_join(thread2, NULL);<br>    cout &lt;&lt; total &lt;&lt; endl;  // 9999999900000000<br>    return 0;<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在C++11上，实现同样的功能：</span><br></pre></td></tr></table></figure></p>
<p>#include <atomic></atomic></p>
<p>#include <thread></thread></p>
<p>#include <iostream><br>using namespace std;</iostream></p>
<p>atomic_llong total {0};     // 原子数据类型</p>
<p>void func(int) {<br>    for(long long i = 0; i &lt; 100000000LL; ++i) {<br>        total += i;<br>    }<br>}</p>
<p>int main() {<br>    thread t1(func, 0);<br>    thread t2(func, 0);</p>
<pre><code>t1.join();
t2.join();
cout &lt;&lt; total &lt;&lt; endl;  // 9999999900000000
return 0;
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">将total定义为一个原子数据类型，类型长度等同于C++11中的内置类型long long。在C++11中，程序员不需要为原子数据类型显式地声明互斥锁或调用加锁、解锁的API，线程就能够对变量total互斥地进行访问。这里我们定义了C++11的线程`std::thread`变量t1及t2，它们都执行同样的函数func，并类似于pthread_t，调用了`std::thread`成员函数join加人程序的执行。由于C++11支持原子类型，因此我们可以简单地通过`#include&lt;cstdatomic&gt;`头文件中来使用对应于`&lt;cstdatomic&gt;`中包含的原子类型，定义如表</span><br><span class="line">![](/img/20200405204600.jpg)</span><br><span class="line"></span><br><span class="line">可以使用`std::atomic&lt;T&gt; t`模板类型声明一个类型为T的原子类型变量t。对于线程而言，原子类型通常属于“资源型”的数据，这意味着多个线程通常只能访问单个原子类型的拷贝。因此在c++11中，原子类型只能从其模板参数类型中进行构造，标准不允许原子类型进行拷贝构造、移动构造，以及使用operator=等，以防止发生意外。对大多数原子类型而言，都可以执行读read、写store、交换exchange、比较并交换compare_exchange_weak等操作。如:</span><br></pre></td></tr></table></figure></p>
<p>atomic<int> a;<br>a = 1;<br>int b = a;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">`a = 1`相当于`a.store(1)`，`b = a`就相当于`b=a.load()`，这些接口封装了平台上的实现。</span><br><span class="line"></span><br><span class="line">### 内存模型、顺序一致性、memory_order</span><br><span class="line">要了解顺序一致性喝内存模型，先看代码：</span><br></pre></td></tr></table></figure></int></p>
<p>#include <thread></thread></p>
<p>#include <atomic></atomic></p>
<p>#include <iostream><br>using namespace std;</iostream></p>
<p>atomic<int> a {0};<br>atomic<int> b {0};</int></int></p>
<p>int ValueSet(int) {<br>    int t = 1;<br>    a = t;<br>    b = 2;<br>}</p>
<p>int Observer(int) {<br>    cout &lt;&lt; “(“ &lt;&lt; a &lt;&lt; “, “ &lt;&lt; b &lt;&lt; “)” &lt;&lt; endl;   // 可能有多种输出<br>}</p>
<p>int main() {<br>    thread t1(ValueSet, 0);<br>    thread t2(Observer, 0);</p>
<pre><code>t1.join();
t2.join();
cout &lt;&lt; &quot;Got (&quot; &lt;&lt; a &lt;&lt; &quot;, &quot; &lt;&lt; b &lt;&lt; &quot;)&quot; &lt;&lt; endl;   // Got (1, 2)
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">两个线程t1、t2分别执行ValueSet喝Ovserver函数，在线程结束后再打印a和b的值总会得到(1,2)的结果。</span><br><span class="line">![](/img/20200405211800.jpg)</span><br><span class="line"></span><br><span class="line">如果编译器认定a和b的赋值语句执行顺序对输出结果没有影响的话，则可以将指令重排以提高性能，如果假定所有执行的顺序无关紧要，则在多线程下会发生错误，默认情况下，原子类型的变量总是再线程中保持顺序执行的特性，称为**顺序一致**的。即代码再线程中运行的顺序与程序猿看到的代码顺序一致，最大程度保证程序的正确性。对于C++11的内存模型，要做到代码的顺序一致性，必须：</span><br><span class="line">- 编译器保证原子操作的指令间顺序不变，保证产生的读写原子类型的变量的机器指令与代码编写者看到的是一致的。</span><br><span class="line">- 处理器对原子操作的汇编指令的执行顺序不变。</span><br><span class="line"></span><br><span class="line">如前文所述，在C++11中，原子类型的成员函数（原子操作）总是保证了顺序一致性。这对于x86这样的平台来说，禁止了编译器对原子类型变量间的重排序优化；而对于powerpc这样的平台来说，则不仅禁止了编译器的优化，还插人了大量的内存栅栏。这对于意图是提高性能的多线程程序而言，无疑是一种性能伤害。在C++11中，设计者给出的解决方式是让程序员为原子操作指定所谓的内存顺序：memory_order。</span><br></pre></td></tr></table></figure></p>
<p>#include <thread></thread></p>
<p>#include <atomic></atomic></p>
<p>#include <iostream><br>using namespace std;</iostream></p>
<p>atomic<int> a {0};<br>atomic<int> b {0};</int></int></p>
<p>int ValueSet(int) {<br>    int t = 1;<br>    a.store(t, memory_order_relaxed);<br>    b.store(2, memory_order_relaxed);<br>}</p>
<p>int Observer(int) {<br>    cout &lt;&lt; “(“ &lt;&lt; a &lt;&lt; “, “ &lt;&lt; b &lt;&lt; “)” &lt;&lt; endl;   // 可能有多种输出<br>}</p>
<p>int main() {<br>    thread t1(ValueSet, 0);<br>    thread t2(Observer, 0);</p>
<pre><code>t1.join();
t2.join();
cout &lt;&lt; &quot;Got (&quot; &lt;&lt; a &lt;&lt; &quot;, &quot; &lt;&lt; b &lt;&lt; &quot;)&quot; &lt;&lt; endl;   // Got (1, 2)
return 0;
</code></pre><p>}<br><code>`</code><br>上述代码表示使用松散的内存模型，该指令可以任由编译器重排或由处理器乱序执行。C++标准定义了7种memory_order枚举值：<br><img src="/img/20200405215200.jpg" alt></p>
<h2 id="线程局部存储"><a href="#线程局部存储" class="headerlink" title="线程局部存储"></a>线程局部存储</h2><p>线程局部存储TLS就是拥有线程生命周期及线程可见性的变量。线程局部存储实际上是由单线程程序中的全局/静态变量被应用到多线程程序中被线程共享而来。在g++中：<code>_thread int errCode</code>，即为将变量声明为TLS变量。每个线程拥有独立的errCode拷贝，一个线程中对errCode的读写并不会影响另外一个线程中errCode的数据。</p>
<h2 id="快速退出quick-exit"><a href="#快速退出quick-exit" class="headerlink" title="快速退出quick_exit"></a>快速退出quick_exit</h2><p>terminate函数实际上是异常处理的一部分，没有捕捉到的异常会引起terminate的调用，，abort不会调用任何析构函数，会向合乎POSIX标准的系统抛出了一个信号SIGABRT；exit属于正常退出，自动调用变量的析构函数。</p>
<p>有的时候，main或者使用exit函数调用结束程序的方式也不那么令人满意。有的时候，代码中会有很多的类，这些类在堆空间上分配了大量的零散的内存（直接从堆里分配，并没有优化的策略），而main或者exit函数调用会导致类的析构函数依次将这些零散的内存还给操作系统。这是一件费时的工作，而实际上，这些堆内存将在进程结束时由操作系统统一回收（事实上这相当快，操作系统除了释放一些进程相关的数据结构外，只是将一些物理内存标记为未使用就可以了）。如果这些堆内存对其他程序不产生任何影响，那么在程序结束时释放堆内存的析构过程往往是毫无意义的。因此，在这种情况下，我们常常需要能够更快地退出程序。</p>
<p>为此，在C++11中，标准引人了quick_exit函数，该数并不执行析构数而只是使程序终止。与abort不同的是，abort的结果通常是异常退出（可能系统还会进行core dump等以辅助程序员进行问题分析)。而quick_exit与exit同属于正常退出。此外，使用at_qutck_exit注册的函数也可以在quick_exit的时候被调用。这样一来，我们同样可以像exit一样做一些清理的工作（这与很多平台上使用exit函数直接正常退出还是有不同的）。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/C/" rel="tag"># C++</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/04/01/深入理解cpp11_新特性解析与应用_笔记1/" rel="next" title="深入理解C++11_新特性解析与应用 笔记1">
                <i class="fa fa-chevron-left"></i> 深入理解C++11_新特性解析与应用 笔记1
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/header.jpg" alt="Hao Yu">
            
              <p class="site-author-name" itemprop="name">Hao Yu</p>
              <p class="site-description motion-element" itemprop="description">Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author</p>
          </div>
          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">294</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>
        	<audio controls="controls" loop="loop" preload="auto" src="/resource/xiaomeihao.mp3">
	        </audio>
			<div itemscope itemtype="https://schema.org/Person"><a itemprop="sameAs" content="https://orcid.org/0000-0003-0709-8947" href="https://orcid.org/0000-0003-0709-8947" target="orcid.widget" rel="me noopener noreferrer"><img src="https://orcid.org/sites/default/files/images/orcid_16x16.png" style="width:1em;margin-right:.5em;" alt="ORCID iD icon">https://orcid.org/0000-0003-0709-8947</a></div>
	

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yuhao0102" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:yuh18@mails.tsinghua.edu.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#新手易学，老兵易用"><span class="nav-number">1.</span> <span class="nav-text">新手易学，老兵易用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#右尖括号-gt-的改进"><span class="nav-number">1.1.</span> <span class="nav-text">右尖括号&gt;的改进</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#auto类型推导"><span class="nav-number">1.2.</span> <span class="nav-text">auto类型推导</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#静态类型、动态类型与类型推导"><span class="nav-number">1.2.1.</span> <span class="nav-text">静态类型、动态类型与类型推导</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#auto的优势"><span class="nav-number">1.2.2.</span> <span class="nav-text">auto的优势</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#auto的应用细则"><span class="nav-number">1.2.3.</span> <span class="nav-text">auto的应用细则</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#decltype"><span class="nav-number">1.3.</span> <span class="nav-text">decltype</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#typeid与decltype"><span class="nav-number">1.3.1.</span> <span class="nav-text">typeid与decltype</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#decltype的应用"><span class="nav-number">1.3.2.</span> <span class="nav-text">decltype的应用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程局部存储"><span class="nav-number">1.4.</span> <span class="nav-text">线程局部存储</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#快速退出quick-exit"><span class="nav-number">1.5.</span> <span class="nav-text">快速退出quick_exit</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>
  <div id="DvelopmentTarget">     
  </div>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart" aria-hidden="false"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  


  <script type="text/javascript" src="/js/src/love.js"></script>

</body>
</html>
