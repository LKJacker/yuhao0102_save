<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zn-ch">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-center-simple.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Leetcode,">










<meta name="description" content="Leetcode1002. Find Common CharactersGiven an array A of strings made only from lowercase letters, return a list of all characters that show up in all strings within the list (including duplicates).  F">
<meta name="keywords" content="Leetcode">
<meta property="og:type" content="article">
<meta property="og:title" content="Leetcode1001 - 1050">
<meta property="og:url" content="http://yoursite.com/2020/04/27/Leetcode1001_1050/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="Leetcode1002. Find Common CharactersGiven an array A of strings made only from lowercase letters, return a list of all characters that show up in all strings within the list (including duplicates).  F">
<meta property="og:locale" content="zn-ch">
<meta property="og:image" content="http://yoursite.com/img/20190813007.png">
<meta property="og:image" content="http://yoursite.com/img/sum-of-root-to-leaf-binary-numbers.png">
<meta property="og:image" content="http://yoursite.com/img/2whqcep.jpg">
<meta property="og:image" content="http://yoursite.com/img/20190506tree.png">
<meta property="og:updated_time" content="2020-08-01T04:51:13.060Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Leetcode1001 - 1050">
<meta name="twitter:description" content="Leetcode1002. Find Common CharactersGiven an array A of strings made only from lowercase letters, return a list of all characters that show up in all strings within the list (including duplicates).  F">
<meta name="twitter:image" content="http://yoursite.com/img/20190813007.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/04/27/Leetcode1001_1050/">





  <title>Leetcode1001 - 1050 | Hao Yu's blog</title>
  








 
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zn-ch">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hao Yu's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">The program monkey was eaten by the siege lion.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-mybetterhalf">
          <a href="/mybetterhalf/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>
            
            mybetterhalf
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="Searching..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/27/Leetcode1001_1050/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Leetcode1001 - 1050</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-04-27T16:26:00+08:00">
                2020-04-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Leetcode1002-Find-Common-Characters"><a href="#Leetcode1002-Find-Common-Characters" class="headerlink" title="Leetcode1002. Find Common Characters"></a>Leetcode1002. Find Common Characters</h1><p>Given an array A of strings made only from lowercase letters, return a list of all characters that show up in all strings within the list (including duplicates).  For example, if a character occurs 3 times in all strings but not 4 times, you need to include that character three times in the final answer.</p>
<p>You may return the answer in any order.</p>
<p>Example 1:</p>
<p>Input: [“bella”,”label”,”roller”]<br>Output: [“e”,”l”,”l”]<br>Example 2:</p>
<p>Input: [“cool”,”lock”,”cook”]<br>Output: [“c”,”o”]</p>
<p>Note:</p>
<p>1 &lt;= A.length &lt;= 100<br>1 &lt;= A[i].length &lt;= 100<br><code>A[i][j]</code> is a lowercase letter</p>
<p>这个打表要二维打表，第一次的时候没有注意，用了一维的，所以错了。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; commonChars(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; A) &#123;</span><br><span class="line">        <span class="built_in">string</span> s;</span><br><span class="line">        <span class="keyword">int</span> vis[<span class="number">102</span>][<span class="number">27</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;A.size();i++)&#123;</span><br><span class="line">            s = A[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;A[i].length();j++)&#123;</span><br><span class="line">                vis[i][s[j]-<span class="string">'a'</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 打表，记下来每个string中每个字母出现的次数</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> minn=<span class="number">1000</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;A.size();j++)</span><br><span class="line">		    &#123;</span><br><span class="line">			    <span class="keyword">if</span>(vis[j][i]&lt;minn)</span><br><span class="line">				    minn=vis[j][i];</span><br><span class="line">    	    &#125;</span><br><span class="line">    	    <span class="comment">//看这个字母在每个string中出现的最少次数，</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;minn;j++)&#123;</span><br><span class="line">		        <span class="built_in">string</span> s1;</span><br><span class="line">		        s1+=<span class="keyword">char</span>(<span class="string">'a'</span>+i);</span><br><span class="line">                res.push_back(s1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1005-Maximize-Sum-Of-Array-After-K-Negations"><a href="#Leetcode1005-Maximize-Sum-Of-Array-After-K-Negations" class="headerlink" title="Leetcode1005. Maximize Sum Of Array After K Negations"></a>Leetcode1005. Maximize Sum Of Array After K Negations</h1><p>Given an array A of integers, we must modify the array in the following way: we choose an i and replace A[i] with -A[i], and we repeat this process K times in total.  (We may choose the same index i multiple times.) Return the largest possible sum of the array after modifying it in this way.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [4,2,3], K = 1</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: Choose indices (1,) and A becomes [4,-2,3].</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [3,-1,0,2], K = 3</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: Choose indices (1, 2, 2) and A becomes [3,1,0,2].</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [2,-3,-1,5,-4], K = 2</span><br><span class="line">Output: 13</span><br><span class="line">Explanation: Choose indices (1, 4) and A becomes [2,3,-1,5,4].</span><br></pre></td></tr></table></figure></p>
<p>题目的意思是将A中的数进行取反（正变负，负变正）K次，可以重复对一个元素取反，最后求A中元素总和的最大值。取反可以分为两种情况：当A中都是正数的时候，比如{1,2,4,6}，如果K是偶数，那么可以不用进行取反操作，因为负负得正；如果K是奇数，则只需要对最小的数取反一次即可。当A中有正数也有负数的时候，比如{-4,-3,-1,2,5}，此时对负数元素进行取反操作，直到当前元素大于0或者K次转换已用完，此时针对K中剩余的转换次数，又可以细分为两种情况：</p>
<ol>
<li>K中剩余的转换次数为偶数，即A中元素全是正数，依据负负得正，不用再进行额外的转换了。</li>
<li>K中剩余的转换次数为奇数，即还需要再将某个元素转换一次，而为了元素总和最大，需要比较当前元素（正数）和前一个元素（负数）的绝对值大小，对较小的元素进行取反。</li>
</ol>
<p>最后使用一个for循环，计算A中所有元素总和。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestSumAfterKNegations</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>, s = <span class="number">0</span>, length = A.size();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">        sort(A.begin(), A.end());</span><br><span class="line">        <span class="keyword">if</span>(A[<span class="number">0</span>] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(K % <span class="number">2</span>)</span><br><span class="line">                A[<span class="number">0</span>] = -A[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; length &amp;&amp; A[i] &lt; <span class="number">0</span> &amp;&amp; K --) &#123;</span><br><span class="line">                A[i] = -A[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (K &gt; <span class="number">0</span> &amp;&amp; K%<span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                 <span class="built_in">abs</span>(A[i]) &lt; <span class="built_in">abs</span>(A[i<span class="number">-1</span>]) ? A[i] = -A[i] : A[i<span class="number">-1</span>] = -A[i<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; length; i ++)</span><br><span class="line">            sum += A[i];</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1008-Construct-Binary-Search-Tree-from-Preorder-Traversal"><a href="#Leetcode1008-Construct-Binary-Search-Tree-from-Preorder-Traversal" class="headerlink" title="Leetcode1008. Construct Binary Search Tree from Preorder Traversal"></a>Leetcode1008. Construct Binary Search Tree from Preorder Traversal</h1><p>Return the root node of a binary search tree that matches the given preorder traversal.</p>
<p>(Recall that a binary search tree is a binary tree where for every node, any descendant of node.left has a value &lt; node.val, and any descendant of node.right has a value &gt; node.val.  Also recall that a preorder traversal displays the value of the node first, then traverses node.left, then traverses node.right.)</p>
<p>Example 1:</p>
<p>Input: [8,5,1,7,10,12]<br>Output: [8,5,10,1,7,null,12]</p>
<p><img src="/img/20190813007.png" alt></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode* <span class="title">build</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=j)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> temp=preorder[i];</span><br><span class="line">        <span class="keyword">int</span> ii;</span><br><span class="line">        <span class="keyword">for</span>(ii=i+<span class="number">1</span>;ii&lt;j;ii++)</span><br><span class="line">            <span class="keyword">if</span>(temp&lt;preorder[ii])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(preorder[i]);</span><br><span class="line">        root-&gt;left = build(preorder,i+<span class="number">1</span>,ii);</span><br><span class="line">        root-&gt;right = build(preorder,ii,j);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="function">TreeNode* <span class="title">bstFromPreorder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preorder.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> build(preorder,<span class="number">0</span>,preorder.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>一道简单的中序遍历题竟然做了这么久。。。</p>
<h1 id="Leetcode1009-Complement-of-Base-10-Integer"><a href="#Leetcode1009-Complement-of-Base-10-Integer" class="headerlink" title="Leetcode1009. Complement of Base 10 Integer"></a>Leetcode1009. Complement of Base 10 Integer</h1><p>Every non-negative integer N has a binary representation.  For example, 5 can be represented as “101” in binary, 11 as “1011” in binary, and so on.  Note that except for N = 0, there are no leading zeroes in any binary representation.</p>
<p>The complement of a binary representation is the number in binary you get when changing every 1 to a 0 and 0 to a 1.  For example, the complement of “101” in binary is “010” in binary.</p>
<p>For a given number N in base-10, return the complement of it’s binary representation as a base-10 integer.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 5</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: 5 is &quot;101&quot; in binary, with complement &quot;010&quot; in binary, which is 2 in base-10.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 7</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: 7 is &quot;111&quot; in binary, with complement &quot;000&quot; in binary, which is 0 in base-10.</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 10</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: 10 is &quot;1010&quot; in binary, with complement &quot;0101&quot; in binary, which is 5 in base-10.</span><br></pre></td></tr></table></figure></p>
<p>将十进制变成二进制然后取反加和<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">bitwiseComplement</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(N == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(N == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; re;</span><br><span class="line">        <span class="keyword">while</span>(N) &#123;</span><br><span class="line">            re.push_back(N &amp; <span class="number">1</span>);</span><br><span class="line">            N = N &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(re.begin(), re.end());</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; re.size(); i ++) &#123;</span><br><span class="line">            res = res * <span class="number">2</span> + (~re[i] &amp; <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>方法二，利用位运算直接取反。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">bitwiseComplement</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(!N)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(N &gt; <span class="built_in">pow</span>(<span class="number">2</span>, i))</span><br><span class="line">            i ++;</span><br><span class="line">        <span class="keyword">return</span> (~N) &amp; ((<span class="keyword">int</span>)<span class="built_in">pow</span>(<span class="number">2</span>, i) - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1010-Pairs-of-Songs-With-Total-Durations-Divisible-by-60"><a href="#Leetcode1010-Pairs-of-Songs-With-Total-Durations-Divisible-by-60" class="headerlink" title="Leetcode1010. Pairs of Songs With Total Durations Divisible by 60"></a>Leetcode1010. Pairs of Songs With Total Durations Divisible by 60</h1><p>In a list of songs, the i-th song has a duration of time[i] seconds. </p>
<p>Return the number of pairs of songs for which their total duration in seconds is divisible by 60.  Formally, we want the number of indices i, j such that i &lt; j with (time[i] + time[j]) % 60 == 0.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: [30,20,150,100,40]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: Three pairs have a total duration divisible by 60:</span><br><span class="line">(time[0] = 30, time[2] = 150): total duration 180</span><br><span class="line">(time[1] = 20, time[3] = 100): total duration 120</span><br><span class="line">(time[1] = 20, time[4] = 40): total duration 60</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [60,60,60]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: All three pairs have a total duration of 120, which is divisible by 60.</span><br></pre></td></tr></table></figure></p>
<p>一开始的思路，是暴力枚举，枚举第一首歌，然后第二首歌是枚举在第一首歌之后的所有情况，判断条件成立就 ans++ 。但这样子的时间复杂度是 O(n^2) 。题目中，数组长度 n&lt;=6e+4，所以时间复杂度是 3.6e+9，这样子会超时。</p>
<p>因此上述暴力枚举的方法行不通。</p>
<p>如果两首歌时间之和要能被60整除，说明余数为0，那么假设第一首歌对60的余数是 a ，那么另一首歌的对60的余数为 60-a 才行。所以我们可以用一个长度为60的数组，下标刚好对应求余后的数，每次找到一个新的歌余数为 a，就看它前面对应余数为 60-a 的有多少首歌，即可以匹配为多少对。最后这首歌的余数对应的下标数组值 ++。</p>
<p>这样解决之后，我们只用遍历一次数组即可，所以时间复杂度是 O(n) ，但是需要了额外的空间开销。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numPairsDivisibleBy60</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = time.size();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; yushu(<span class="number">60</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i ++) &#123;</span><br><span class="line">            res += yushu[(<span class="number">60</span> - time[i]%<span class="number">60</span>)%<span class="number">60</span>];</span><br><span class="line">            yushu[ time[i]%<span class="number">60</span> ] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1013-Partition-Array-Into-Three-Parts-With-Equal-Sum"><a href="#Leetcode1013-Partition-Array-Into-Three-Parts-With-Equal-Sum" class="headerlink" title="Leetcode1013. Partition Array Into Three Parts With Equal Sum"></a>Leetcode1013. Partition Array Into Three Parts With Equal Sum</h1><p>Given an array A of integers, return true if and only if we can partition the array into three non-empty parts with equal sums.</p>
<p>Formally, we can partition the array if we can find indexes i+1 &lt; j with (A[0] + A[1] + … + A[i] == A[i+1] + A[i+2] + … + A[j-1] == A[j] + A[j-1] + … + A[A.length - 1])</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [0,2,1,-6,6,-7,9,1,2,0,1]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: 0 + 2 + 1 = -6 + 6 - 7 + 9 + 1 = 2 + 0 + 1</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [0,2,1,-6,6,7,9,-1,2,0,1]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [3,3,6,5,-2,2,5,1,-9,4]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: 3 + 3 = 6 = 5 - 2 + 2 + 5 + 1 - 9 + 4</span><br></pre></td></tr></table></figure></p>
<p>1、检查总数是否能被3整除;<br>2、循环遍历数组A，计算和的一部分;如果找到平均值，则将该部分重置为0，并增加计数器;<br>3、到最后，如果平均可以看到至少3次，返回true;否则返回假。<br>注意:如果在数组结束前找到2次平均值(sum / 3)，那么剩下的部分也等于平均值。因此，计数器达到3后无需继续。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canThreePartsEqualSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>, part_sum = <span class="number">0</span>, i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size(); i ++) </span><br><span class="line">            sum += A[i];</span><br><span class="line">        <span class="keyword">if</span>(sum % <span class="number">3</span> != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        sum /= <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; A.size(); i ++) &#123;</span><br><span class="line">            part_sum += A[i];</span><br><span class="line">            <span class="keyword">if</span>(part_sum == sum)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(part_sum = <span class="number">0</span>, i = i + <span class="number">1</span>; i &lt; A.size(); i++) &#123;</span><br><span class="line">            part_sum += A[i];</span><br><span class="line">            <span class="keyword">if</span>(part_sum == sum)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; A.size() - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1018-Binary-Prefix-Divisible-By-5"><a href="#Leetcode1018-Binary-Prefix-Divisible-By-5" class="headerlink" title="Leetcode1018. Binary Prefix Divisible By 5"></a>Leetcode1018. Binary Prefix Divisible By 5</h1><p>Given an array A of 0s and 1s, consider N_i: the i-th subarray from A[0] to A[i] interpreted as a binary number (from most-significant-bit to least-significant-bit.)</p>
<p>Return a list of booleans answer, where answer[i] is true if and only if N_i is divisible by 5.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [0,1,1]</span><br><span class="line">Output: [true,false,false]</span><br><span class="line">Explanation: The input numbers in binary are 0, 01, 011; which are 0, 1, and 3 in base-10.  Only the first number is divisible by 5, so answer[0] is true.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,1,1]</span><br><span class="line">Output: [false,false,false]</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [0,1,1,1,1,1]</span><br><span class="line">Output: [true,false,false,false,true,false]</span><br></pre></td></tr></table></figure></p>
<p>Example 4:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,1,1,0,1]</span><br><span class="line">Output: [false,false,false,false,false]</span><br></pre></td></tr></table></figure></p>
<p>假设当前访问 A[i - 1], 表示的数为 old_number, 那么当访问 A[i] 时, 所表示的数 new_number = old_number * 2 + A[];</p>
<ul>
<li>如果直接判断 new_number 是否能被 5 整除, 容易出现溢出的问题, 因为按照上面遍历的方式, C++ 只能保存 32-bit 的数据, 但是题目中说明 1 &lt;= A.length &lt;= 30000.</li>
<li>我们不需要知道具体的 new_number 数值大小, 而只需要它与 5 的余数;<br>-发现一个数学公式: (a<em>b + c) % d = ((a%d)</em>(b%d) + c%d) % d, 因此 new_number % 5 可以表示为 ((old_number % 5) * 2 + A[i]) % 5.</li>
<li>由第 4 点, 可以将 number % 5 作为一个整体, 更新公式为 a = (a * 2 + A[i]) % 5.</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; prefixesDivBy5(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; res;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, temp = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size(); i ++) &#123;</span><br><span class="line">            ans = ((ans * <span class="number">2</span>)%<span class="number">5</span> + A[i])%<span class="number">5</span>;</span><br><span class="line">            <span class="keyword">if</span>(ans % <span class="number">5</span> == <span class="number">0</span>)</span><br><span class="line">                res.push_back(<span class="literal">true</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                res.push_back(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode1021-Remove-Outermost-Parentheses"><a href="#Leetcode1021-Remove-Outermost-Parentheses" class="headerlink" title="Leetcode1021. Remove Outermost Parentheses"></a>Leetcode1021. Remove Outermost Parentheses</h1><p>A valid parentheses string is either empty (“”), “(“ + A + “)”, or A + B, where A and B are valid parentheses strings, and + represents string concatenation.  For example, “”, “()”, “(())()”, and “(()(()))” are all valid parentheses strings.</p>
<p>A valid parentheses string S is primitive if it is nonempty, and there does not exist a way to split it into S = A+B, with A and B nonempty valid parentheses strings.</p>
<p>Given a valid parentheses string S, consider its primitive decomposition: S = P_1 + P_2 + … + P_k, where P_i are primitive valid parentheses strings.</p>
<p>Return S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;(()())(())&quot;</span><br><span class="line">Output: &quot;()()()&quot;</span><br><span class="line">Explanation: </span><br><span class="line">The input string is &quot;(()())(())&quot;, with primitive decomposition &quot;(()())&quot; + &quot;(())&quot;.</span><br><span class="line">After removing outer parentheses of each part, this is &quot;()()&quot; + &quot;()&quot; = &quot;()()()&quot;.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;(()())(())(()(()))&quot;</span><br><span class="line">Output: &quot;()()()()(())&quot;</span><br><span class="line">Explanation: </span><br><span class="line">The input string is &quot;(()())(())(()(()))&quot;, with primitive decomposition &quot;(()())&quot; + &quot;(())&quot; + &quot;(()(()))&quot;.</span><br><span class="line">After removing outer parentheses of each part, this is &quot;()()&quot; + &quot;()&quot; + &quot;()(())&quot; = &quot;()()()()(())&quot;.</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;()()&quot;</span><br><span class="line">Output: &quot;&quot;</span><br><span class="line">Explanation: </span><br><span class="line">The input string is &quot;()()&quot;, with primitive decomposition &quot;()&quot; + &quot;()&quot;.</span><br><span class="line">After removing outer parentheses of each part, this is &quot;&quot; + &quot;&quot; = &quot;&quot;.</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ol>
<li>S.length &lt;= 10000</li>
<li>S[i] is “(“ or “)”</li>
<li>S is a valid parentheses string</li>
</ol>
<p>比较简单，把最外边的一层括号移走，可以用栈，也可以用计数器。如果遇到左括号且栈不空说明这个左括号不是外边的括号，加到结果中，再把这个左括号压栈；如果是右括号，就先弹出栈，再判断如果栈不空则说明这个右括号也不是外边的括号，加到结果中。</p>
<p>不知道为啥我这个这么慢，反正过了就行。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">removeOuterParentheses</span><span class="params">(<span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> result=<span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> length = S.length();</span><br><span class="line">        <span class="keyword">int</span> ss=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(S[i]==<span class="string">'('</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(ss!=<span class="number">0</span>)</span><br><span class="line">                    result=result+<span class="string">'('</span>;</span><br><span class="line">                ss++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(S[i]==<span class="string">')'</span>)&#123;</span><br><span class="line">                ss--;</span><br><span class="line">                <span class="keyword">if</span>(ss!=<span class="number">0</span>)</span><br><span class="line">                    result=result+<span class="string">")"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode1022-Sum-of-Root-To-Leaf-Binary-Numbers"><a href="#Leetcode1022-Sum-of-Root-To-Leaf-Binary-Numbers" class="headerlink" title="Leetcode1022. Sum of Root To Leaf Binary Numbers"></a>Leetcode1022. Sum of Root To Leaf Binary Numbers</h1><p>Given a binary tree, each node has value 0 or 1.  Each root-to-leaf path represents a binary number starting with the most significant bit.  For example, if the path is 0 -&gt; 1 -&gt; 1 -&gt; 0 -&gt; 1, then this could represent 01101 in binary, which is 13.</p>
<p>For all leaves in the tree, consider the numbers represented by the path from the root to that leaf.</p>
<p>Return the sum of these numbers.</p>
<p><img src="/img/sum-of-root-to-leaf-binary-numbers.png" alt></p>
<p>深度优先遍历一波，因为好久没写dsf了，所以特地写一写。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> result;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root ,<span class="keyword">int</span> now)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right)&#123;</span><br><span class="line">            result += (now&lt;&lt;<span class="number">1</span>) + root-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> val = (now&lt;&lt;<span class="number">1</span>) + root-&gt;val;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left)</span><br><span class="line">            dfs(root-&gt;left, val);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right)</span><br><span class="line">            dfs(root-&gt;right, val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumRootToLeaf</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        result=<span class="number">0</span>;</span><br><span class="line">        dfs(root,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1023-Camelcase-Matching"><a href="#Leetcode1023-Camelcase-Matching" class="headerlink" title="Leetcode1023. Camelcase Matching"></a>Leetcode1023. Camelcase Matching</h1><p>A query word matches a given pattern if we can insert lowercase letters to the pattern word so that it equals the query. (We may insert each character at any position, and may insert 0 characters.)</p>
<p>Given a list of queries, and a pattern, return an answer list of booleans, where answer[i] is true if and only if queries[i] matches the pattern.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: queries = [&quot;FooBar&quot;,&quot;FooBarTest&quot;,&quot;FootBall&quot;,&quot;FrameBuffer&quot;,&quot;ForceFeedBack&quot;], pattern = &quot;FB&quot;</span><br><span class="line">Output: [true,false,true,true,false]</span><br><span class="line">Explanation: </span><br><span class="line">&quot;FooBar&quot; can be generated like this &quot;F&quot; + &quot;oo&quot; + &quot;B&quot; + &quot;ar&quot;.</span><br><span class="line">&quot;FootBall&quot; can be generated like this &quot;F&quot; + &quot;oot&quot; + &quot;B&quot; + &quot;all&quot;.</span><br><span class="line">&quot;FrameBuffer&quot; can be generated like this &quot;F&quot; + &quot;rame&quot; + &quot;B&quot; + &quot;uffer&quot;.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: queries = [&quot;FooBar&quot;,&quot;FooBarTest&quot;,&quot;FootBall&quot;,&quot;FrameBuffer&quot;,&quot;ForceFeedBack&quot;], pattern = &quot;FoBa&quot;</span><br><span class="line">Output: [true,false,true,false,false]</span><br><span class="line">Explanation: </span><br><span class="line">&quot;FooBar&quot; can be generated like this &quot;Fo&quot; + &quot;o&quot; + &quot;Ba&quot; + &quot;r&quot;.</span><br><span class="line">&quot;FootBall&quot; can be generated like this &quot;Fo&quot; + &quot;ot&quot; + &quot;Ba&quot; + &quot;ll&quot;.</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: queries = [&quot;FooBar&quot;,&quot;FooBarTest&quot;,&quot;FootBall&quot;,&quot;FrameBuffer&quot;,&quot;ForceFeedBack&quot;], pattern = &quot;FoBaT&quot;</span><br><span class="line">Output: [false,true,false,false,false]</span><br><span class="line">Explanation: </span><br><span class="line">&quot;FooBarTest&quot; can be generated like this &quot;Fo&quot; + &quot;o&quot; + &quot;Ba&quot; + &quot;r&quot; + &quot;T&quot; + &quot;est&quot;.</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<p>1 &lt;= queries.length &lt;= 100<br>1 &lt;= queries[i].length &lt;= 100<br>1 &lt;= pattern.length &lt;= 100<br>All strings consists only of lower and upper case English letters.</p>
<p>给一个字符串和一个模式串，看能不能在模式串里加小写字母来转换成字符串，比较简单。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; camelMatch(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; queries, <span class="built_in">string</span> pattern) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;queries.size();i++)&#123;</span><br><span class="line">            <span class="keyword">bool</span> succ=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;queries[i].size();j++)&#123;</span><br><span class="line">                <span class="keyword">while</span>(<span class="built_in">islower</span>(queries[i][j])&amp;&amp; pattern[index]!=queries[i][j])&#123;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(pattern[index]==queries[i][j])</span><br><span class="line">                    index++;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    succ=<span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            </span><br><span class="line">            &#125;</span><br><span class="line">            ans.push_back(succ);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>我的代码比较慢，可以看看大佬们怎么写的。</p>
<p>Solution 1, Find<br>For each query, find all letters in pattern left-to-right. If we found all pattern letters, check that the rest of the letters is in the lower case.</p>
<p>对每个查询，从左到右找pattern里的字幕，如果找到了，检查剩余的是否是小写字母。感觉跟我的类似。</p>
<p>For simplicity, we can replace the found pattern letter in query with a lowercase ‘a’.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; camelMatch(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; qs, <span class="built_in">string</span> pattern, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; res = &#123;&#125;) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; qs.size(); ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> p = <span class="number">-1</span>, j = <span class="number">0</span>; j &lt; pattern.size(); ++j) &#123;</span><br><span class="line">      p = qs[i].find(pattern[j], p + <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (p == <span class="built_in">string</span>::npos) &#123;</span><br><span class="line">        res.push_back(<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      qs[i][p] = <span class="string">'a'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (res.size() &lt;= i) res.push_back(all_of(begin(qs[i]), end(qs[i]), [](<span class="keyword">char</span> ch) &#123; <span class="keyword">return</span> <span class="built_in">islower</span>(ch); &#125;));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Solution 2, Simple Scan<br>Instead of using the find function, we can just check all characters in the query. If a character matches the pattern pointer (pattern[p]), we advance that pointer (++p). Otherwise, we check that the query character is in the lower case.</p>
<p>检查查询的字符串，如果一个字符与pattern[p]匹配了，就继续，如果不匹配，看是不是小些</p>
<p>With this solution, it’s also easer to realize that the complexity is O(n), where n is the total number of query characters.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; camelMatch(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; qs, <span class="built_in">string</span> pattern, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; res = &#123;&#125;) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>, j = <span class="number">0</span>, p = <span class="number">0</span>; i &lt; qs.size(); ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>, p = <span class="number">0</span>; j &lt; qs[i].size(); ++j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (p &lt; pattern.size() &amp;&amp; qs[i][j] == pattern[p]) ++p;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">islower</span>(qs[i][j])) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    res.push_back(j == qs[i].size() &amp;&amp; p == pattern.size());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Complexity Analysis<br>Runtime: O(n), where n is all letters in all queries. We process each letter only once.<br>Memory: O(m), where m is the number of queries (to store the result).<br>时间复杂度O(n)，空间复杂度O(m)</p>
<h1 id="Leetcode1024-Video-Stitching"><a href="#Leetcode1024-Video-Stitching" class="headerlink" title="Leetcode1024. Video Stitching"></a>Leetcode1024. Video Stitching</h1><p>You are given a series of video clips from a sporting event that lasted T seconds.  These video clips can be overlapping with each other and have varied lengths.</p>
<p>Each video clip clips[i] is an interval: it starts at time clips[i][0] and ends at time clips[i][1].  We can cut these clips into segments freely: for example, a clip [0, 7] can be cut into segments [0, 1] + [1, 3] + [3, 7].</p>
<p>Return the minimum number of clips needed so that we can cut the clips into segments that cover the entire sporting event ([0, T]).  If the task is impossible, return -1.</p>
<p>寻找最少的可以覆盖[0, T]区间的区间数量，一开始没搞定，看答案搞定的。总体思路就是一开始先排序，并且记下来两个end，一个是当前的end，一个是之前一次的end，如果现在这个小区间的end比之前的pre_end还小，直接不考虑了。我做的时候忽略了这一点，如果不记下来之前的per_end的话，可能有区间是重复的（现在这个小区间如果加进去了，就跟上次加进去的那个小区间有重复的部分或者重合）</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: clips = [[0,2],[4,6],[8,10],[1,9],[1,5],[5,9]], T = 10</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: </span><br><span class="line">We take the clips [0,2], [8,10], [1,9]; a total of 3 clips.</span><br><span class="line">Then, we can reconstruct the sporting event as follows:</span><br><span class="line">We cut [1,9] into segments [1,2] + [2,8] + [8,9].</span><br><span class="line">Now we have segments [0,2] + [2,8] + [8,10] which cover the sporting event [0, 10].</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: clips = [[0,1],[1,2]], T = 5</span><br><span class="line">Output: -1</span><br><span class="line">Explanation: </span><br><span class="line">We can&apos;t cover [0,5] with only [0,1] and [0,2].</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: clips = [[0,1],[6,8],[0,2],[5,6],[0,4],[0,3],[6,7],[1,3],[4,7],[1,4],[2,5],[2,6],[3,4],[4,5],[5,7],[6,9]], T = 9</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: </span><br><span class="line">We can take clips [0,4], [4,7], and [6,9].</span><br></pre></td></tr></table></figure></p>
<p>Example 4:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: clips = [[0,4],[2,8]], T = 5</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: </span><br><span class="line">Notice you can have extra video after the event ends.</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<p>1 &lt;= clips.length &lt;= 100<br>0 &lt;= clips[i][0], clips[i][1] &lt;= 100<br>0 &lt;= T &lt;= 100</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">comp</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[<span class="number">0</span>]==b[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">1</span>] &gt; b[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">videoStitching</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; clips, <span class="keyword">int</span> T)</span> </span>&#123;</span><br><span class="line">        sort(clips.begin(), clips.end(), comp);</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>, cur_end=<span class="number">0</span>, pre_end=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clips.size(); i ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(clips[i][<span class="number">1</span>] &lt;= cur_end)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(clips[i][<span class="number">0</span>] &gt; cur_end)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span>(clips[i][<span class="number">0</span>] &gt; pre_end)&#123;</span><br><span class="line">                pre_end = cur_end;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            cur_end = clips[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(cur_end &gt;= T)</span><br><span class="line">                <span class="keyword">return</span> count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode1025-Divisor-Game"><a href="#Leetcode1025-Divisor-Game" class="headerlink" title="Leetcode1025. Divisor Game"></a>Leetcode1025. Divisor Game</h1><p>Alice and Bob take turns playing a game, with Alice starting first.</p>
<p>Initially, there is a number N on the chalkboard.  On each player’s turn, that player makes a move consisting of:</p>
<p>Choosing any x with 0 &lt; x &lt; N and N % x == 0.<br>Replacing the number N on the chalkboard with N - x.<br>Also, if a player cannot make a move, they lose the game.</p>
<p>Return True if and only if Alice wins the game, assuming both players play optimally.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 2</span><br><span class="line">Output: true</span><br><span class="line">Explanation: Alice chooses 1, and Bob has no more moves.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 3</span><br><span class="line">Output: false</span><br><span class="line">Explanation: Alice chooses 1, Bob chooses 1, and Alice has no more moves.</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<p>1 &lt;= N &lt;= 1000</p>
<p>两个人玩游戏，给一个数字N，先轮到A走，A选一个数字x使得<code>0 &lt; x &lt; N</code>且<code>N % x == 0</code>，之后N变为N-x，如果谁选不出来x，那就输了，A遇见偶数赢，奇数输。</p>
<p>如果A看见偶数，就选x=1，则N变成奇数，B只能再选一个奇数，又把N变成偶数，由于1是奇数且1没法再选，故A遇见偶数一定赢，反之则输。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">divisorGame</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (N%<span class="number">2</span>)==<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode1026-Maximum-Difference-Between-Node-and-Ancestor"><a href="#Leetcode1026-Maximum-Difference-Between-Node-and-Ancestor" class="headerlink" title="Leetcode1026. Maximum Difference Between Node and Ancestor"></a>Leetcode1026. Maximum Difference Between Node and Ancestor</h1><p>Given the root of a binary tree, find the maximum value V for which there exists different nodes A and B where V = |A.val - B.val| and A is an ancestor of B.</p>
<p>(A node A is an ancestor of B if either: any child of A is equal to B, or any child of A is an ancestor of B.)</p>
<p>Example 1:<br><img src="/img/2whqcep.jpg" alt><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: [8,3,10,1,6,null,14,null,null,4,7,13]</span><br><span class="line">Output: 7</span><br><span class="line">Explanation: </span><br><span class="line">We have various ancestor-node differences, some of which are given below :</span><br><span class="line">|8 - 3| = 5</span><br><span class="line">|3 - 7| = 4</span><br><span class="line">|8 - 1| = 7</span><br><span class="line">|10 - 13| = 3</span><br><span class="line">Among all possible differences, the maximum value of 7 is obtained by |8 - 1| = 7.</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<p>The number of nodes in the tree is between 2 and 5000.<br>Each node will have value between 0 and 100000.</p>
<p>给一棵树，找到最大值v，这个v是节点和祖先的值的差的绝对值。dfs里一定要有一个最大一个最小，这样才能算出来绝对值最大的一个，之前考虑只放一个值，没有搞定。<br>一个dfs<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> val=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root,<span class="keyword">int</span> maxval,<span class="keyword">int</span> minval)</span></span>&#123;</span><br><span class="line">        val = max(val, <span class="built_in">abs</span>(root-&gt;val - maxval));</span><br><span class="line">        val = max(val, <span class="built_in">abs</span>(root-&gt;val - minval));</span><br><span class="line">        maxval = max(maxval, root-&gt;val);</span><br><span class="line">        minval = min(minval, root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right) dfs(root-&gt;right,maxval,minval);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left) dfs(root-&gt;left,maxval,minval);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxAncestorDiff</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        dfs(root,root-&gt;val,root-&gt;val);</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1029-Two-City-Scheduling"><a href="#Leetcode1029-Two-City-Scheduling" class="headerlink" title="Leetcode1029. Two City Scheduling"></a>Leetcode1029. Two City Scheduling</h1><p>There are 2N people a company is planning to interview. The cost of flying the i-th person to city A is costs[i][0], and the cost of flying the i-th person to city B is costs[i][1].</p>
<p>Return the minimum cost to fly every person to a city such that exactly N people arrive in each city.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: [[10,20],[30,200],[400,50],[30,20]]</span><br><span class="line">Output: 110</span><br><span class="line">Explanation: </span><br><span class="line">The first person goes to city A for a cost of 10.</span><br><span class="line">The second person goes to city A for a cost of 30.</span><br><span class="line">The third person goes to city B for a cost of 50.</span><br><span class="line">The fourth person goes to city B for a cost of 20.</span><br></pre></td></tr></table></figure></p>
<p>The total minimum cost is 10 + 30 + 50 + 20 = 110 to have half the people interviewing in each city.</p>
<p>Note:</p>
<p>1 &lt;= costs.length &lt;= 100<br>It is guaranteed that costs.length is even.<br>1 &lt;= costs[i][0], costs[i][1] &lt;= 1000</p>
<p>公司计划面试 2N 人。第 i 人飞往 A 市的费用为 costs[i][0]，飞往 B 市的费用为 costs[i][1]。<br>返回将每个人都飞到某座城市的最低费用，要求每个城市都有 N 人抵达。</p>
<p>由于人数是偶数个，一半的人去A,一半的人去B，换个角度，每个人要么去A，要么去B。如果他去A比去B的路程短，而且，这个节省的路程比一半的人还多，那么他就去A。所以，以去A和去B的路程差作为Key进行升序排序，前面一半人去A，后面去B。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">comp</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>]-a[<span class="number">1</span>] &lt; b[<span class="number">0</span>]-b[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">twoCitySchedCost</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; costs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(costs.size()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        sort(costs.begin(), costs.end(), comp);</span><br><span class="line">        <span class="keyword">int</span> ii=costs.size();</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;ii/<span class="number">2</span>;i++)</span><br><span class="line">            result += costs[i][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(;i&lt;ii;i++)</span><br><span class="line">            result+=costs[i][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode1030-Matrix-Cells-in-Distance-Order"><a href="#Leetcode1030-Matrix-Cells-in-Distance-Order" class="headerlink" title="Leetcode1030. Matrix Cells in Distance Order"></a>Leetcode1030. Matrix Cells in Distance Order</h1><p>We are given a matrix with R rows and C columns has cells with integer coordinates (r, c), where 0 &lt;= r &lt; R and 0 &lt;= c &lt; C.</p>
<p>Additionally, we are given a cell in that matrix with coordinates (r0, c0).</p>
<p>Return the coordinates of all cells in the matrix, sorted by their distance from (r0, c0) from smallest distance to largest distance.  Here, the distance between two cells (r1, c1) and (r2, c2) is the Manhattan distance, |r1 - r2| + |c1 - c2|.  (You may return the answer in any order that satisfies this condition.)</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: R = 1, C = 2, r0 = 0, c0 = 0</span><br><span class="line">Output: [[0,0],[0,1]]</span><br><span class="line">Explanation: The distances from (r0, c0) to other cells are: [0,1]</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: R = 2, C = 2, r0 = 0, c0 = 1</span><br><span class="line">Output: [[0,1],[0,0],[1,1],[1,0]]</span><br><span class="line">Explanation: The distances from (r0, c0) to other cells are: [0,1,1,2]</span><br><span class="line">The answer [[0,1],[1,1],[0,0],[1,0]] would also be accepted as correct.</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: R = 2, C = 3, r0 = 1, c0 = 2</span><br><span class="line">Output: [[1,2],[0,2],[1,1],[0,1],[1,0],[0,0]]</span><br><span class="line">Explanation: The distances from (r0, c0) to other cells are: [0,1,1,2,2,3]</span><br><span class="line">There are other answers that would also be accepted as correct, such as [[1,2],[1,1],[0,2],[1,0],[0,1],[0,0]].</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<p>1 &lt;= R &lt;= 100<br>1 &lt;= C &lt;= 100<br>0 &lt;= r0 &lt; R<br>0 &lt;= c0 &lt; C</p>
<p>根据与给定的点的顺序排序。</p>
<p>看到一种比较辣鸡的做法，就是先把所有点都加进去，再排序，顺便学习了一个新的写法，如下的lambda表达式：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">      </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; allCellsDistOrder(<span class="keyword">int</span> R, <span class="keyword">int</span> C, <span class="keyword">int</span> r0, <span class="keyword">int</span> c0) &#123;</span><br><span class="line">        <span class="keyword">auto</span> comp = [r0,c0](<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;b)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">abs</span>(a[<span class="number">0</span>]-r0) + <span class="built_in">abs</span>(a[<span class="number">1</span>]-c0) &lt; <span class="built_in">abs</span>(b[<span class="number">0</span>]-r0) + <span class="built_in">abs</span>(b[<span class="number">1</span>]-c0);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;R;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;C;j++)</span><br><span class="line">                res.push_back(&#123;i,j&#125;);</span><br><span class="line">        </span><br><span class="line">        sort(res.begin(),res.end(),comp);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>用bfs做也行：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; allCellsDistOrder(<span class="keyword">int</span> R, <span class="keyword">int</span> C, <span class="keyword">int</span> r0, <span class="keyword">int</span> c0) &#123;</span><br><span class="line">        <span class="keyword">int</span> visit[R][C];</span><br><span class="line">        <span class="built_in">memset</span>(visit,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*R*C);</span><br><span class="line">        <span class="keyword">int</span> direction[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;&#125;;</span><br><span class="line">        <span class="built_in">queue</span>&lt; pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; qu;</span><br><span class="line">        <span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; res;</span><br><span class="line">        qu.push(&#123;r0,c0&#125;);</span><br><span class="line">        <span class="keyword">while</span>(!qu.empty())&#123;</span><br><span class="line">            pair&lt;<span class="keyword">int</span> ,<span class="keyword">int</span>&gt; temp = qu.front();</span><br><span class="line">            qu.pop();</span><br><span class="line">            <span class="keyword">int</span> x = temp.first;</span><br><span class="line">            <span class="keyword">int</span> y = temp.second;</span><br><span class="line">            <span class="keyword">if</span>(visit[x][y]==<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            res.push_back(&#123;x,y&#125;);</span><br><span class="line">            visit[x][y]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> xx = x + direction[i][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> yy = y + direction[i][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> ( xx&gt;= <span class="number">0</span> &amp;&amp; xx &lt; R &amp;&amp; yy &gt;=<span class="number">0</span> &amp;&amp; yy &lt; C &amp;&amp; visit[xx][yy] == <span class="number">0</span>)&#123;</span><br><span class="line">                     qu.push(&#123;xx,yy&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>更新一种做法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">comp</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">2</span>] &lt; b[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; allCellsDistOrder(<span class="keyword">int</span> R, <span class="keyword">int</span> C, <span class="keyword">int</span> r0, <span class="keyword">int</span> c0) &#123;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; v(R*C, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">3</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; R; i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; C; j ++) &#123;</span><br><span class="line">                v[k][<span class="number">0</span>] = i;</span><br><span class="line">                v[k][<span class="number">1</span>] = j;</span><br><span class="line">                v[k][<span class="number">2</span>] = <span class="built_in">abs</span>(i - r0) + <span class="built_in">abs</span>(j - c0);</span><br><span class="line">                k ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(v.begin(), v.end(), comp);</span><br><span class="line">	        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> kk = <span class="number">0</span>; kk &lt; R*C; kk ++) &#123;</span><br><span class="line">            v[kk].pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1033-Moving-Stones-Until-Consecutive"><a href="#Leetcode1033-Moving-Stones-Until-Consecutive" class="headerlink" title="Leetcode1033. Moving Stones Until Consecutive"></a>Leetcode1033. Moving Stones Until Consecutive</h1><p>Three stones are on a number line at positions a, b, and c. Each turn, you pick up a stone at an endpoint (ie., either the lowest or highest position stone), and move it to an unoccupied position between those endpoints.  Formally, let’s say the stones are currently at positions x, y, z with x &lt; y &lt; z.  You pick up the stone at either position x or position z, and move that stone to an integer position k, with x &lt; k &lt; z and k != y. The game ends when you cannot make any more moves, ie. the stones are in consecutive positions.</p>
<p>When the game ends, what is the minimum and maximum number of moves that you could have made?  Return the answer as an length 2 array: answer = [minimum_moves, maximum_moves]</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: a = 1, b = 2, c = 5</span><br><span class="line">Output: [1,2]</span><br><span class="line">Explanation: Move the stone from 5 to 3, or move the stone from 5 to 4 to 3.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: a = 4, b = 3, c = 2</span><br><span class="line">Output: [0,0]</span><br><span class="line">Explanation: We cannot make any moves.</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: a = 3, b = 5, c = 1</span><br><span class="line">Output: [1,2]</span><br><span class="line">Explanation: Move the stone from 1 to 4; or move the stone from 1 to 2 to 4.</span><br></pre></td></tr></table></figure></p>
<p>a,b,c表示三个位置，在三个位置上各有一个石头。现在要移动三个石头中的若干个，每次移动都必须选两端石头的里面的位置，最终使得它们三个放在连续的位置。问最少需要多少次移动，最多需要多少次移动。</p>
<p>如果三个石头本来就连续，则不用移动。例：1，2，3</p>
<p>如果三个石头本来不连续，则：<br>最少移动次数：</p>
<ol>
<li>有两个石头之间的距离小于等于2，则最少只需要一次移动。例：1，2，4，把4移动到3即可；或者例1，3，5，把5移到2即可。</li>
<li>所有石头之间的最小距离&gt;2，则最少需要移动两个石头。例：1，4，7，需要把两个石头移动到另一个的旁边。</li>
</ol>
<p>最多移动次数：<br>题目说了，只能像两端石头里面的那些位置上放，所以最多移动的次数就是本来两端石头中间包含的点（并且去掉中间的石头），策略是每次向内移动一步。例：1，3，5，在1和5中间之间共有2个可以放的点（分别为2，4），所以最多只能有max_ - min_ - 2次移动。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numMovesStones(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum_ = a + b + c;</span><br><span class="line">        <span class="keyword">int</span> min_ = min(a, min(b, c));</span><br><span class="line">        <span class="keyword">int</span> max_ = max(a, max(b, c));</span><br><span class="line">        <span class="keyword">int</span> mid_ = sum_ - min_ - max_;</span><br><span class="line">	        </span><br><span class="line">        <span class="keyword">if</span> (max_ - min_ == <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">	        </span><br><span class="line">        <span class="keyword">int</span> min_move = min(mid_ - min_, max_ - mid_) &lt;= <span class="number">2</span> ? <span class="number">1</span> : <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> max_move = max_ - min_ - <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> &#123;min_move, max_move&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode1037-Valid-Boomerang"><a href="#Leetcode1037-Valid-Boomerang" class="headerlink" title="Leetcode1037. Valid Boomerang"></a>Leetcode1037. Valid Boomerang</h1><p>A boomerang is a set of 3 points that are all distinct and not in a straight line. Given a list of three points in the plane, return whether these points are a boomerang.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,1],[2,3],[3,2]]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,1],[2,2],[3,3]]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<p>points.length == 3<br>points[i].length == 2<br>0 &lt;=<code>points[i][j]</code>&lt;= 100</p>
<p>判断三个点是不是互异且不共线的，简单<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBoomerang</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;points.size();i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;points.size();j++)</span><br><span class="line">                <span class="keyword">if</span>(points[i][<span class="number">0</span>]==points[j][<span class="number">0</span>] &amp;&amp; points[i][<span class="number">1</span>]==points[j][<span class="number">1</span>])</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> dx1 = points[<span class="number">1</span>][<span class="number">0</span>] - points[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> dx2 = points[<span class="number">1</span>][<span class="number">1</span>] - points[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> dx3 = points[<span class="number">2</span>][<span class="number">0</span>] - points[<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> dx4 = points[<span class="number">2</span>][<span class="number">1</span>] - points[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(dx1*dx4-dx2*dx3==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1038-Binary-Search-Tree-to-Greater-Sum-Tree"><a href="#Leetcode1038-Binary-Search-Tree-to-Greater-Sum-Tree" class="headerlink" title="Leetcode1038. Binary Search Tree to Greater Sum Tree"></a>Leetcode1038. Binary Search Tree to Greater Sum Tree</h1><p>Given the root of a binary search tree with distinct values, modify it so that every node has a new value equal to the sum of the values of the original tree that are greater than or equal to node.val.</p>
<p>As a reminder, a binary search tree is a tree that satisfies these constraints:</p>
<p>The left subtree of a node contains only nodes with keys less than the node’s key.<br>The right subtree of a node contains only nodes with keys greater than the node’s key.<br>Both the left and right subtrees must also be binary search trees.</p>
<p>Example 1:</p>
<p><img src="/img/20190506tree.png" alt></p>
<p>Input: [4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]<br>Output: [30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]</p>
<p>典型的中序遍历，先遍历右子树，再把root赋值，最后看左子树</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">houxu</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right)</span><br><span class="line">            houxu(root-&gt;right);</span><br><span class="line">        sum+=root-&gt;val;</span><br><span class="line">        root-&gt;val = sum;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left)</span><br><span class="line">            houxu(root-&gt;left);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">bstToGst</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        houxu(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode1042-Flower-Planting-With-No-Adjacent"><a href="#Leetcode1042-Flower-Planting-With-No-Adjacent" class="headerlink" title="Leetcode1042. Flower Planting With No Adjacent"></a>Leetcode1042. Flower Planting With No Adjacent</h1><p>You have N gardens, labelled 1 to N.  In each garden, you want to plant one of 4 types of flowers. paths[i] = [x, y] describes the existence of a bidirectional path from garden x to garden y. Also, there is no garden that has more than 3 paths coming into or leaving it.</p>
<p>Your task is to choose a flower type for each garden such that, for any two gardens connected by a path, they have different types of flowers.</p>
<p>Return any such a choice as an array answer, where answer[i] is the type of flower planted in the (i+1)-th garden.  The flower types are denoted 1, 2, 3, or 4.  It is guaranteed an answer exists.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: N = 3, paths = [[1,2],[2,3],[3,1]]</span><br><span class="line">Output: [1,2,3]</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: N = 4, paths = [[1,2],[3,4]]</span><br><span class="line">Output: [1,2,1,2]</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: N = 4, paths = [[1,2],[2,3],[3,4],[4,1],[1,3],[2,4]]</span><br><span class="line">Output: [1,2,3,4]</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>1 &lt;= N &lt;= 10000</li>
<li>0 &lt;= paths.size &lt;= 20000</li>
<li>No garden has 4 or more paths coming into or leaving it.</li>
<li>It is guaranteed an answer exists.</li>
</ul>
<p>有 N 个花园，按从 1 到 N 标记。在每个花园中，你打算种下四种花之一。 paths[i] = [x, y] 描述了花园 x 到花园 y 的双向路径。另外，没有花园有 3 条以上的路径可以进入或者离开。你需要为每个花园选择一种花，使得通过路径相连的任何两个花园中的花的种类互不相同。以数组形式返回选择的方案作为答案 answer，其中 answer[i] 为在第 (i+1) 个花园中种植的花的种类。花的种类用  1, 2, 3, 4 表示。保证存在答案。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; gardenNoAdj(<span class="keyword">int</span> N, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; paths) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(N, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; graph(N);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; paths.size(); i ++) &#123;</span><br><span class="line">            graph[paths[i][<span class="number">0</span>]<span class="number">-1</span>].push_back(paths[i][<span class="number">1</span>]<span class="number">-1</span>);</span><br><span class="line">            graph[paths[i][<span class="number">1</span>]<span class="number">-1</span>].push_back(paths[i][<span class="number">0</span>]<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;      </span><br><span class="line">            <span class="keyword">int</span> mask = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; j : graph[i])</span><br><span class="line">                mask |= (<span class="number">1</span> &lt;&lt; res[j]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">1</span>; c &lt;= <span class="number">4</span> &amp;&amp; res[i] == <span class="number">0</span>; ++c)</span><br><span class="line">                <span class="keyword">if</span> (!(mask &amp; (<span class="number">1</span> &lt;&lt; c))) res[i] = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1046-Last-Stone-Weight"><a href="#Leetcode1046-Last-Stone-Weight" class="headerlink" title="Leetcode1046. Last Stone Weight"></a>Leetcode1046. Last Stone Weight</h1><p>We have a collection of stones, each stone has a positive integer weight.</p>
<p>Each turn, we choose the two heaviest stones and smash them together.  Suppose the stones have weights x and y with x &lt;= y.  The result of this smash is:</p>
<ul>
<li>If x == y, both stones are totally destroyed;</li>
<li>If x != y, the stone of weight x is totally destroyed, and the stone of weight y has new weight y-x.</li>
<li>At the end, there is at most 1 stone left.  Return the weight of this stone (or 0 if there are no stones left.)</li>
</ul>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,7,4,1,8,1]</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: </span><br><span class="line">We combine 7 and 8 to get 1 so the array converts to [2,4,1,1,1] then,</span><br><span class="line">we combine 2 and 4 to get 2 so the array converts to [2,1,1,1] then,</span><br><span class="line">we combine 2 and 1 to get 1 so the array converts to [1,1,1] then,</span><br><span class="line">we combine 1 and 1 to get 0 so the array converts to [1] then that&apos;s the value of last stone.</span><br></pre></td></tr></table></figure></p>
<p>堆排序解法，主要是看看人家的堆排序怎么写。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lastStoneWeight</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p, q;</span><br><span class="line">        <span class="keyword">if</span>(stones.size() == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> stones[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">while</span>(stones.size() &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">            heapsort(stones);</span><br><span class="line">            p = stones.back(); stones.pop_back();</span><br><span class="line">            q = stones.back(); stones.pop_back();</span><br><span class="line">            <span class="keyword">int</span> diff = p - q;</span><br><span class="line">            <span class="keyword">if</span>(diff)    stones.push_back(diff);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(stones.empty())   </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> stones[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">heapsort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stones.size() &lt;= <span class="number">1</span>)  <span class="keyword">return</span>;</span><br><span class="line">        build_heap(stones);</span><br><span class="line">        <span class="keyword">int</span> heap_size = stones.size();</span><br><span class="line">        <span class="keyword">while</span>(heap_size &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">            swap(stones[<span class="number">0</span>], stones[heap_size - <span class="number">1</span>]);</span><br><span class="line">            heap_size --;</span><br><span class="line">            max_heapify(stones, <span class="number">0</span>, heap_size);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build_heap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=stones.size()/<span class="number">2</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            max_heapify(stones, i, stones.size());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">max_heapify</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; stones, <span class="keyword">int</span> i, <span class="keyword">int</span> heap_size)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> large = i;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">2</span>*i+<span class="number">1</span>&lt;heap_size &amp;&amp; stones[i]&lt;stones[<span class="number">2</span>*i+<span class="number">1</span>])  large = <span class="number">2</span>*i+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">2</span>*i+<span class="number">2</span>&lt;heap_size &amp;&amp; stones[large]&lt;stones[<span class="number">2</span>*i+<span class="number">2</span>])  large = <span class="number">2</span>*i+<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(large != i)&#123;</span><br><span class="line">            swap(stones[i], stones[large]);</span><br><span class="line">            max_heapify(stones, large, heap_size);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        temp = a; a = b; b = temp;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1047-Remove-All-Adjacent-Duplicates-In-String"><a href="#Leetcode1047-Remove-All-Adjacent-Duplicates-In-String" class="headerlink" title="Leetcode1047. Remove All Adjacent Duplicates In String"></a>Leetcode1047. Remove All Adjacent Duplicates In String</h1><p>Given a string S of lowercase letters, a duplicate removal consists of choosing two adjacent and equal letters, and removing them.</p>
<p>We repeatedly make duplicate removals on S until we no longer can.</p>
<p>Return the final string after all such duplicate removals have been made.  It is guaranteed the answer is unique.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;abbaca&quot;</span><br><span class="line">Output: &quot;ca&quot;</span><br><span class="line">Explanation: </span><br><span class="line">For example, in &quot;abbaca&quot; we could remove &quot;bb&quot; since the letters are adjacent and equal, and this is the only possible move.  The result of this move is that the string is &quot;aaca&quot;, of which only &quot;aa&quot; is possible, so the final string is &quot;ca&quot;.</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<p>1 &lt;= S.length &lt;= 20000<br>S consists only of English lowercase letters.</p>
<p>借用了栈的思想，但是这么做会超内存。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=S.length()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!st.empty() &amp;&amp; st.top()==S[i])&#123;</span><br><span class="line">                st.pop();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                st.push(S[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">while</span>(!st.empty())&#123;</span><br><span class="line">            res = res + st.top();</span><br><span class="line">            st.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>借鉴了大佬的做法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> res = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span>&amp; c : S)</span><br><span class="line">        <span class="keyword">if</span> (res.size() &amp;&amp; c == res.back())</span><br><span class="line">            res.pop_back();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            res.push_back(c);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> a;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; c : S) </span><br><span class="line">            <span class="keyword">if</span> (a.size() &amp;&amp; a.back() == c) a.pop_back();</span><br><span class="line">            <span class="keyword">else</span> a.push_back(c);</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里a.size()是返回字符数量，a.back()返回最后一个字符，pop_back和push_back和vector一样了。</p>
<p>把我自己的超时的代码改了一下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res=<span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> S_len = S.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;S_len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>( len&gt;<span class="number">0</span> &amp;&amp; res[len<span class="number">-1</span>]==S[i])&#123;</span><br><span class="line">                res.pop_back();</span><br><span class="line">                len--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                res += S[i];</span><br><span class="line">                len++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">	    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Leetcode/" rel="tag"># Leetcode</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/04/27/Leetcode1251_1300/" rel="next" title="Leetcode1251 - 1300">
                <i class="fa fa-chevron-left"></i> Leetcode1251 - 1300
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/05/05/Leetcode151_200/" rel="prev" title="Leetcode151 - 200">
                Leetcode151 - 200 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/header.jpg" alt="Hao Yu">
            
              <p class="site-author-name" itemprop="name">Hao Yu</p>
              <p class="site-description motion-element" itemprop="description">Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author</p>
          </div>
          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">286</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>
        	<audio controls="controls" loop="loop" preload="auto" src="/resource/xiaomeihao.mp3">
	        </audio>
	

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yuhao0102" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:yuh18@mails.tsinghua.edu.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1002-Find-Common-Characters"><span class="nav-number">1.</span> <span class="nav-text">Leetcode1002. Find Common Characters</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1005-Maximize-Sum-Of-Array-After-K-Negations"><span class="nav-number">2.</span> <span class="nav-text">Leetcode1005. Maximize Sum Of Array After K Negations</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1008-Construct-Binary-Search-Tree-from-Preorder-Traversal"><span class="nav-number">3.</span> <span class="nav-text">Leetcode1008. Construct Binary Search Tree from Preorder Traversal</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1009-Complement-of-Base-10-Integer"><span class="nav-number">4.</span> <span class="nav-text">Leetcode1009. Complement of Base 10 Integer</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1010-Pairs-of-Songs-With-Total-Durations-Divisible-by-60"><span class="nav-number">5.</span> <span class="nav-text">Leetcode1010. Pairs of Songs With Total Durations Divisible by 60</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1013-Partition-Array-Into-Three-Parts-With-Equal-Sum"><span class="nav-number">6.</span> <span class="nav-text">Leetcode1013. Partition Array Into Three Parts With Equal Sum</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1018-Binary-Prefix-Divisible-By-5"><span class="nav-number">7.</span> <span class="nav-text">Leetcode1018. Binary Prefix Divisible By 5</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1021-Remove-Outermost-Parentheses"><span class="nav-number">8.</span> <span class="nav-text">Leetcode1021. Remove Outermost Parentheses</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1022-Sum-of-Root-To-Leaf-Binary-Numbers"><span class="nav-number">9.</span> <span class="nav-text">Leetcode1022. Sum of Root To Leaf Binary Numbers</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1023-Camelcase-Matching"><span class="nav-number">10.</span> <span class="nav-text">Leetcode1023. Camelcase Matching</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1024-Video-Stitching"><span class="nav-number">11.</span> <span class="nav-text">Leetcode1024. Video Stitching</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1025-Divisor-Game"><span class="nav-number">12.</span> <span class="nav-text">Leetcode1025. Divisor Game</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1026-Maximum-Difference-Between-Node-and-Ancestor"><span class="nav-number">13.</span> <span class="nav-text">Leetcode1026. Maximum Difference Between Node and Ancestor</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1029-Two-City-Scheduling"><span class="nav-number">14.</span> <span class="nav-text">Leetcode1029. Two City Scheduling</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1030-Matrix-Cells-in-Distance-Order"><span class="nav-number">15.</span> <span class="nav-text">Leetcode1030. Matrix Cells in Distance Order</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1033-Moving-Stones-Until-Consecutive"><span class="nav-number">16.</span> <span class="nav-text">Leetcode1033. Moving Stones Until Consecutive</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1037-Valid-Boomerang"><span class="nav-number">17.</span> <span class="nav-text">Leetcode1037. Valid Boomerang</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1038-Binary-Search-Tree-to-Greater-Sum-Tree"><span class="nav-number">18.</span> <span class="nav-text">Leetcode1038. Binary Search Tree to Greater Sum Tree</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1042-Flower-Planting-With-No-Adjacent"><span class="nav-number">19.</span> <span class="nav-text">Leetcode1042. Flower Planting With No Adjacent</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1046-Last-Stone-Weight"><span class="nav-number">20.</span> <span class="nav-text">Leetcode1046. Last Stone Weight</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1047-Remove-All-Adjacent-Duplicates-In-String"><span class="nav-number">21.</span> <span class="nav-text">Leetcode1047. Remove All Adjacent Duplicates In String</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>
  <div id="DvelopmentTarget">     
  </div>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart" aria-hidden="false"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>

  
</div>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_uv"> 
  本站访客数<span id="busuanzi_value_site_uv"></span>人次
</span>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  


  <script type="text/javascript" src="/js/src/love.js"></script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
