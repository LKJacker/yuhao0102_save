<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zn-ch">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-center-simple.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Leetcode,">










<meta name="description" content="Leetcode1002. Find Common CharactersGiven an array A of strings made only from lowercase letters, return a list of all characters that show up in all strings within the list (including duplicates).  F">
<meta name="keywords" content="Leetcode">
<meta property="og:type" content="article">
<meta property="og:title" content="Leetcode1001 - 1050">
<meta property="og:url" content="http://yoursite.com/2020/04/27/Leetcode1001_1050/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="Leetcode1002. Find Common CharactersGiven an array A of strings made only from lowercase letters, return a list of all characters that show up in all strings within the list (including duplicates).  F">
<meta property="og:locale" content="zn-ch">
<meta property="og:image" content="http://yoursite.com/img/20211116215700.png">
<meta property="og:image" content="http://yoursite.com/img/20190813007.png">
<meta property="og:image" content="http://yoursite.com/img/sum-of-root-to-leaf-binary-numbers.png">
<meta property="og:image" content="http://yoursite.com/img/2whqcep.jpg">
<meta property="og:image" content="http://yoursite.com/img/20190506tree.png">
<meta property="og:updated_time" content="2022-05-28T02:30:26.939Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Leetcode1001 - 1050">
<meta name="twitter:description" content="Leetcode1002. Find Common CharactersGiven an array A of strings made only from lowercase letters, return a list of all characters that show up in all strings within the list (including duplicates).  F">
<meta name="twitter:image" content="http://yoursite.com/img/20211116215700.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/04/27/Leetcode1001_1050/">





  <title>Leetcode1001 - 1050 | Hao Yu's blog</title>
  








 
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zn-ch">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hao Yu's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">The program monkey was eaten by the siege lion.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/resume.pdf" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-mybetterhalf">
          <a href="/mybetterhalf/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>
            
            mybetterhalf
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/27/Leetcode1001_1050/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Leetcode1001 - 1050</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-04-27T16:26:00+08:00">
                2020-04-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Leetcode1002-Find-Common-Characters"><a href="#Leetcode1002-Find-Common-Characters" class="headerlink" title="Leetcode1002. Find Common Characters"></a>Leetcode1002. Find Common Characters</h1><p>Given an array A of strings made only from lowercase letters, return a list of all characters that show up in all strings within the list (including duplicates).  For example, if a character occurs 3 times in all strings but not 4 times, you need to include that character three times in the final answer.</p>
<p>You may return the answer in any order.</p>
<p>Example 1:</p>
<p>Input: [“bella”,”label”,”roller”]<br>Output: [“e”,”l”,”l”]<br>Example 2:</p>
<p>Input: [“cool”,”lock”,”cook”]<br>Output: [“c”,”o”]</p>
<p>Note:</p>
<ul>
<li>1 &lt;= A.length &lt;= 100</li>
<li>1 &lt;= A[i].length &lt;= 100</li>
<li><code>A[i][j]</code> is a lowercase letter</li>
</ul>
<p>这个打表要二维打表，第一次的时候没有注意，用了一维的，所以错了。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; commonChars(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; A) &#123;</span><br><span class="line">        <span class="built_in">string</span> s;</span><br><span class="line">        <span class="keyword">int</span> vis[<span class="number">102</span>][<span class="number">27</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;A.size();i++)&#123;</span><br><span class="line">            s = A[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;A[i].length();j++)&#123;</span><br><span class="line">                vis[i][s[j]-<span class="string">'a'</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 打表，记下来每个string中每个字母出现的次数</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> minn=<span class="number">1000</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;A.size();j++)</span><br><span class="line">		    &#123;</span><br><span class="line">			    <span class="keyword">if</span>(vis[j][i]&lt;minn)</span><br><span class="line">				    minn=vis[j][i];</span><br><span class="line">    	    &#125;</span><br><span class="line">    	    <span class="comment">//看这个字母在每个string中出现的最少次数，</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;minn;j++)&#123;</span><br><span class="line">		        <span class="built_in">string</span> s1;</span><br><span class="line">		        s1+=<span class="keyword">char</span>(<span class="string">'a'</span>+i);</span><br><span class="line">                res.push_back(s1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1003-Check-If-Word-Is-Valid-After-Substitutions"><a href="#Leetcode1003-Check-If-Word-Is-Valid-After-Substitutions" class="headerlink" title="Leetcode1003. Check If Word Is Valid After Substitutions"></a>Leetcode1003. Check If Word Is Valid After Substitutions</h1><p>We are given that the string “abc” is valid.</p>
<p>From any valid string V, we may split V into two pieces X and Y such that X + Y (X concatenated with Y) is equal to V. (X or Y may be empty.) Then, X + “abc” + Y is also valid.</p>
<p>If for example S = “abc”, then examples of valid strings are: “abc”, “aabcbc”, “abcabc”, “abcabcababcc”. Examples of invalid strings are: “abccba”, “ab”, “cababc”, “bac”.</p>
<p>Return true if and only if the given string S is valid.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;aabcbc&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: </span><br><span class="line">We start with the valid string &quot;abc&quot;.</span><br><span class="line">Then we can insert another &quot;abc&quot; between &quot;a&quot; and &quot;bc&quot;, resulting in &quot;a&quot; + &quot;abc&quot; + &quot;bc&quot; which is &quot;aabcbc&quot;.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;abcabcababcc&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: </span><br><span class="line">&quot;abcabcabc&quot; is valid after consecutive insertings of &quot;abc&quot;.</span><br><span class="line">Then we can insert &quot;abc&quot; before the last letter, resulting in &quot;abcabcab&quot; + &quot;abc&quot; + &quot;c&quot; which is &quot;abcabcababcc&quot;.</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;abccba&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></p>
<p>Example 4:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;cababc&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>1 &lt;= S.length &lt;= 20000</li>
<li>S[i] is ‘a’, ‘b’, or ‘c’</li>
</ul>
<p>使用 vector 来模拟栈, 当遍历访问到 c 时, 需要判断 stack 中是否已经有 a 和 b 的存在.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; v;</span><br><span class="line">        v.resize(<span class="number">20000</span>);</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'c'</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!(p &gt; <span class="number">0</span> &amp;&amp; v[p<span class="number">-1</span>] == <span class="string">'b'</span>) || !(p &gt; <span class="number">1</span> &amp;&amp; v[p<span class="number">-2</span>] == <span class="string">'a'</span>))  </span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                p -= <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                v[p] = c;</span><br><span class="line">                p ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; st;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">'c'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(st.empty() || st.top() != <span class="string">'b'</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                st.pop();</span><br><span class="line">                <span class="keyword">if</span>(st.empty() || st.top() != <span class="string">'a'</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                st.pop();   </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i] == <span class="string">'b'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(st.empty() || st.top() != <span class="string">'a'</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                st.push(s[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                st.push(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> st.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode1004-Max-Consecutive-Ones-III"><a href="#Leetcode1004-Max-Consecutive-Ones-III" class="headerlink" title="Leetcode1004. Max Consecutive Ones III"></a>Leetcode1004. Max Consecutive Ones III</h1><p>Given an array A of 0s and 1s, we may change up to K values from 0 to 1.</p>
<p>Return the length of the longest (contiguous) subarray that contains only 1s.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [1,1,1,0,0,0,1,1,1,1,0], K = 2</span><br><span class="line">Output: 6</span><br><span class="line">Explanation:</span><br><span class="line">[1,1,1,0,0,1,1,1,1,1,1]</span><br><span class="line">Bolded numbers were flipped from 0 to 1.  The longest subarray is underlined.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], K = 3</span><br><span class="line">Output: 10</span><br><span class="line">Explanation:</span><br><span class="line">[0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]</span><br><span class="line">Bolded numbers were flipped from 0 to 1.  The longest subarray is underlined.</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>1 &lt;= A.length &lt;= 20000</li>
<li>0 &lt;= K &lt;= A.length</li>
<li>A[i] is 0 or 1</li>
</ul>
<p>一个由0和1组成的数组，最多反转k个元素，问能够形成的最长的1序列是多长。这个是滑动窗口的题。对数组进行遍历，如果遇到0，就先把它反转，统计被反转的0的个数，如果反转了0之后，发现反转多了，就移动窗口（left++），直到反转的0小于等于k个，再计算窗口的大小。</p>
<p>用个变量 cnt 记录当前将0变为1的个数，在遍历数组的时候，若遇到了0，则 cnt 自增1。若此时 cnt 大于K了，说明该缩小窗口了，用个 while 循环，若左边界为0，移除之后，此时 cnt 应该自减1，left 自增1，每次用窗口大小更新结果 res 即可<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestOnes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>, res = <span class="number">0</span>, len = nums.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == <span class="number">0</span>)</span><br><span class="line">                cnt ++;</span><br><span class="line">            <span class="keyword">while</span>(cnt &gt; k) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[left] == <span class="number">0</span>)</span><br><span class="line">                    cnt --;</span><br><span class="line">                left ++;</span><br><span class="line">            &#125;</span><br><span class="line">            res = max(res, i - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>我们也可以写的更简洁一些，不用 while 循环，但是还是用的滑动窗口的思路，其中i表示左边界，j为右边界。在遍历的时候，若遇到0，则K自减1，若K小于0了，且 A[i] 为0，则K自增1，且i自增1，最后返回窗口的大小即可，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestOnes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.size(), i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[j] == <span class="number">0</span>) --K;</span><br><span class="line">            <span class="keyword">if</span> (K &lt; <span class="number">0</span> &amp;&amp; A[i++] == <span class="number">0</span>) ++K;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> j - i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1005-Maximize-Sum-Of-Array-After-K-Negations"><a href="#Leetcode1005-Maximize-Sum-Of-Array-After-K-Negations" class="headerlink" title="Leetcode1005. Maximize Sum Of Array After K Negations"></a>Leetcode1005. Maximize Sum Of Array After K Negations</h1><p>Given an array A of integers, we must modify the array in the following way: we choose an i and replace A[i] with -A[i], and we repeat this process K times in total.  (We may choose the same index i multiple times.) Return the largest possible sum of the array after modifying it in this way.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [4,2,3], K = 1</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: Choose indices (1,) and A becomes [4,-2,3].</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [3,-1,0,2], K = 3</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: Choose indices (1, 2, 2) and A becomes [3,1,0,2].</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [2,-3,-1,5,-4], K = 2</span><br><span class="line">Output: 13</span><br><span class="line">Explanation: Choose indices (1, 4) and A becomes [2,3,-1,5,4].</span><br></pre></td></tr></table></figure></p>
<p>题目的意思是将A中的数进行取反（正变负，负变正）K次，可以重复对一个元素取反，最后求A中元素总和的最大值。取反可以分为两种情况：当A中都是正数的时候，比如{1,2,4,6}，如果K是偶数，那么可以不用进行取反操作，因为负负得正；如果K是奇数，则只需要对最小的数取反一次即可。当A中有正数也有负数的时候，比如{-4,-3,-1,2,5}，此时对负数元素进行取反操作，直到当前元素大于0或者K次转换已用完，此时针对K中剩余的转换次数，又可以细分为两种情况：</p>
<ol>
<li>K中剩余的转换次数为偶数，即A中元素全是正数，依据负负得正，不用再进行额外的转换了。</li>
<li>K中剩余的转换次数为奇数，即还需要再将某个元素转换一次，而为了元素总和最大，需要比较当前元素（正数）和前一个元素（负数）的绝对值大小，对较小的元素进行取反。</li>
</ol>
<p>最后使用一个for循环，计算A中所有元素总和。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestSumAfterKNegations</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>, s = <span class="number">0</span>, length = A.size();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">        sort(A.begin(), A.end());</span><br><span class="line">        <span class="keyword">if</span>(A[<span class="number">0</span>] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(K % <span class="number">2</span>)</span><br><span class="line">                A[<span class="number">0</span>] = -A[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; length &amp;&amp; A[i] &lt; <span class="number">0</span> &amp;&amp; K --) &#123;</span><br><span class="line">                A[i] = -A[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (K &gt; <span class="number">0</span> &amp;&amp; K%<span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                 <span class="built_in">abs</span>(A[i]) &lt; <span class="built_in">abs</span>(A[i<span class="number">-1</span>]) ? A[i] = -A[i] : A[i<span class="number">-1</span>] = -A[i<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; length; i ++)</span><br><span class="line">            sum += A[i];</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1006-Clumsy-Factorial"><a href="#Leetcode1006-Clumsy-Factorial" class="headerlink" title="Leetcode1006. Clumsy Factorial"></a>Leetcode1006. Clumsy Factorial</h1><p>Normally, the factorial of a positive integer n is the product of all positive integers less than or equal to n.  For example, factorial(10) = 10 <em> 9 </em> 8 <em> 7 </em> 6 <em> 5 </em> 4 <em> 3 </em> 2 * 1.</p>
<p>We instead make a  clumsy factorial:  using the integers in decreasing order, we swap out the multiply operations for a fixed rotation of operations: multiply (*), divide (/), add (+) and subtract (-) in this order.</p>
<p>For example, clumsy(10) = 10 <em> 9 / 8 + 7 - 6 </em> 5 / 4 + 3 - 2 * 1.  However, these operations are still applied using the usual order of operations of arithmetic: we do all multiplication and division steps before any addition or subtraction steps, and multiplication and division steps are processed left to right.</p>
<p>Additionally, the division that we use is  floor division  such that 10 * 9 / 8 equals 11.  This guarantees the result is an integer.</p>
<p>Implement the clumsy function as defined above: given an integer N, it returns the clumsy factorial of N.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 4</span><br><span class="line">Output: 7</span><br><span class="line">Explanation: 7 = 4 * 3 / 2 + 1</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Input: 10 Output: 12 Explanation: 12 = 10 * 9 / 8 + 7 - 6 * 5 / 4 + 3 - 2 * 1</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>1 &lt;= N &lt;= 10000</li>
<li>-2^31 &lt;= answer &lt;= 2^31 - 1  (The answer is guaranteed to fit within a 32-bit integer.)</li>
</ul>
<p>这道题定义了一种笨拙的阶乘，与正常的连续相乘不同的是，这里按顺序使用乘除加减号来计算，这里要保持乘除的优先级，现在给了一个正整数N，让求这种笨拙的阶乘是多少。由于需要保持乘除的优先级，使得问题变的稍微复杂了一些，否则直接按顺序一个个的计算就好。根据题目中的例子2分析，刚开始的乘和除可以直接计算，紧跟其后的加法，也可以直接累加，但是之后的减号，就不能直接计算，而是要先计算后面的乘和除，所以遇到了减号，是需要特殊处理一下的。</p>
<p>把算式进行分割，注意到算符是循环的，除了第一组是<code>+、*、/、+</code>以外，其他的<code>-、*、/、+</code>，所以用一个临时变量来记下当前组的符号即可，剩下的就按照循环来做。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">clumsy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>, i = n, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i != n)</span><br><span class="line">                tmp = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">4</span> &amp;&amp; i &gt; <span class="number">0</span>; j ++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">0</span>) tmp *= (i --);</span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">1</span>) tmp *= (i --);</span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">2</span>) tmp /= (i --);</span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">3</span>) tmp += (i --);</span><br><span class="line">            &#125;</span><br><span class="line">            sum += tmp;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>其他的做法：用个变量j来循环遍历这个数组，从而知道当前该做什么操作。还需要一个变量 cur 来计算乘和除优先级的计算，初始化为N，此时从 N-1 遍历到1，若遇到乘号，则 cur 直接乘以当前数字，若遇到除号，cur 直接除以当前数字，若遇到加号，可以直接把当前数字加到结果 res 中，若遇到减号，此时需要判断一下，因为只有第一个乘和除后的结果是要加到 res 中的，后面的都是要减去的，所以要判断一下若当前数字等于 N-4 的时候，加上 cur，否者都是减去 cur，然后 cur 更新为当前数字，因为减号的优先级小于乘除，不能立马运算。之后j自增1并对4取余，最终返回的时候也需要做个判断，因为有可能数字比较小，减号还没有出来，且此时的最后面的乘除结果还保存在 cur 中，那么是加是减还需要看N的大小，若小于等于4，则加上 cur，反之则减去 cur，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">clumsy</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, cur = N, j = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; ops&#123;<span class="string">'*'</span>, <span class="string">'/'</span>, <span class="string">'+'</span>, <span class="string">'-'</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = N - <span class="number">1</span>; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ops[j] == <span class="string">'*'</span>) &#123;</span><br><span class="line">                cur *= i;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ops[j] == <span class="string">'/'</span>) &#123;</span><br><span class="line">                cur /= i;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ops[j] == <span class="string">'+'</span>) &#123;</span><br><span class="line">                res += i;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res += (i == N - <span class="number">4</span>) ? cur : -cur;</span><br><span class="line">                cur = i;</span><br><span class="line">            &#125;</span><br><span class="line">            j = (j + <span class="number">1</span>) % <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res + ((N &lt;= <span class="number">4</span>) ? cur : -cur);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>再来看一种比较简洁的写法，由于每次遇到减号时，优先级会被改变，而前面的乘除加是可以提前计算的，所以可以每次处理四个数字，即首先处理 N, N-1, N-2, N-3 这四个数字，这里希望每次可以得到乘法计算时的第一个数字，可以通过<code>N - i*4</code>得到，这里需要满足<code>i*4 &lt; N</code>，知道了这个数字，然后可以立马算出乘除的结果，只要其大于等于3。然后需要将乘除之后的结果更新到 res 中，还是需要判断一下，若是第一个乘除的结果，需要加上，后面的都是减去。乘除后面跟的是加号，所以要加上 num-3 这个数字，前提是 num 大于3，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">clumsy</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i * <span class="number">4</span> &lt; N; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> num = N - i * <span class="number">4</span>, t = num;</span><br><span class="line">            <span class="keyword">if</span> (num &gt;= <span class="number">3</span>) t = num * (num - <span class="number">1</span>) / (num - <span class="number">2</span>);</span><br><span class="line">            res += (i == <span class="number">0</span>) ? t : -t;</span><br><span class="line">            <span class="keyword">if</span> (num &gt; <span class="number">3</span>) res += (num - <span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode1007-Minimum-Domino-Rotations-For-Equal-Row"><a href="#Leetcode1007-Minimum-Domino-Rotations-For-Equal-Row" class="headerlink" title="Leetcode1007. Minimum Domino Rotations For Equal Row"></a>Leetcode1007. Minimum Domino Rotations For Equal Row</h1><p>In a row of dominoes, tops[i] and bottoms[i] represent the top and bottom halves of the ith domino. (A domino is a tile with two numbers from 1 to 6 - one on each half of the tile.)</p>
<p>We may rotate the ith domino, so that tops[i] and bottoms[i] swap values.</p>
<p>Return the minimum number of rotations so that all the values in tops are the same, or all the values in bottoms are the same.</p>
<p>If it cannot be done, return -1.</p>
<p>Example 1:<br><img src="/img/20211116215700.png" alt></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: tops = [2,1,2,4,2,2], bottoms = [5,2,6,2,3,2]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: </span><br><span class="line">The first figure represents the dominoes as given by tops and bottoms: before we do any rotations.</span><br><span class="line">If we rotate the second and fourth dominoes, we can make every value in the top row equal to 2, as indicated by the second figure.</span><br></pre></td></tr></table></figure>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: tops = [3,5,1,2,3], bottoms = [3,6,3,3,4]</span><br><span class="line">Output: -1</span><br><span class="line">Explanation: </span><br><span class="line">In this case, it is not possible to rotate the dominoes to make one row of values equal.</span><br></pre></td></tr></table></figure></p>
<p>Constraints:</p>
<ul>
<li>2 &lt;= tops.length &lt;= 2 * 104</li>
<li>bottoms.length == tops.length</li>
<li>1 &lt;= tops[i], bottoms[i] &lt;= 6</li>
</ul>
<p>这道题说是有长度相等的两个数组A和B，分别表示一排多米诺的上边数字和下边数字，多米诺的个数和数组的长度相同，数字为1到6之间，问最少旋转多少次多米诺，可以使得上边或下边的数字全部相同。例子1中给了图解，很好的帮我们理解题意，实际上出现次数越多的数字越可能就是最终全部相同的数字，所以统计A和B中每个数字出现的次数就变的很重要了，由于A和B中有可能相同位置上的是相同的数字，则不用翻转，要使得同一行变为相同的数字，翻转的地方必须是不同的数字，如何才能知道翻转后可以使同一行完全相同呢？需要某个数字在A中出现的次数加上在B中出现的次数减去A和B中相同位置出现的次数后正好等于数组的长度，这里就需要用三个数组 cntA，cntB，和 same 来分别记录某个数字在A中，B中，A和B相同位置上出现的个数，然后遍历1到6，只要符合上面提到的条件，就可以直接返回数组长度减去该数字在A和B中出现的次数中的较大值。</p>
<p>总结就是：tops中某种大小的个数，加上bottoms中某种大小的个数，减去tops和bottoms里这种大小相同的个数，需要等于总个数，这样才能实现一排相同的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDominoRotations</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; tops, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; bottoms)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = tops.size(), res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cnt1(<span class="number">7</span>, <span class="number">0</span>), cnt2(<span class="number">7</span>, <span class="number">0</span>), same(<span class="number">7</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">            cnt1[tops[i]] ++;</span><br><span class="line">            cnt2[bottoms[i]] ++;</span><br><span class="line">            <span class="keyword">if</span> (tops[i] == bottoms[i])</span><br><span class="line">                same[tops[i]] ++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">7</span>; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt1[i] + cnt2[i] - same[i] == n)</span><br><span class="line">                <span class="keyword">return</span> n - max(cnt1[i], cnt2[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode1008-Construct-Binary-Search-Tree-from-Preorder-Traversal"><a href="#Leetcode1008-Construct-Binary-Search-Tree-from-Preorder-Traversal" class="headerlink" title="Leetcode1008. Construct Binary Search Tree from Preorder Traversal"></a>Leetcode1008. Construct Binary Search Tree from Preorder Traversal</h1><p>Return the root node of a binary search tree that matches the given preorder traversal.</p>
<p>(Recall that a binary search tree is a binary tree where for every node, any descendant of node.left has a value &lt; node.val, and any descendant of node.right has a value &gt; node.val.  Also recall that a preorder traversal displays the value of the node first, then traverses node.left, then traverses node.right.)</p>
<p>Example 1:</p>
<p>Input: [8,5,1,7,10,12]<br>Output: [8,5,10,1,7,null,12]</p>
<p><img src="/img/20190813007.png" alt></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode* <span class="title">build</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=j)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> temp=preorder[i];</span><br><span class="line">        <span class="keyword">int</span> ii;</span><br><span class="line">        <span class="keyword">for</span>(ii=i+<span class="number">1</span>;ii&lt;j;ii++)</span><br><span class="line">            <span class="keyword">if</span>(temp&lt;preorder[ii])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(preorder[i]);</span><br><span class="line">        root-&gt;left = build(preorder,i+<span class="number">1</span>,ii);</span><br><span class="line">        root-&gt;right = build(preorder,ii,j);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="function">TreeNode* <span class="title">bstFromPreorder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preorder.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> build(preorder,<span class="number">0</span>,preorder.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>一道简单的中序遍历题竟然做了这么久。。。</p>
<h1 id="Leetcode1009-Complement-of-Base-10-Integer"><a href="#Leetcode1009-Complement-of-Base-10-Integer" class="headerlink" title="Leetcode1009. Complement of Base 10 Integer"></a>Leetcode1009. Complement of Base 10 Integer</h1><p>Every non-negative integer N has a binary representation.  For example, 5 can be represented as “101” in binary, 11 as “1011” in binary, and so on.  Note that except for N = 0, there are no leading zeroes in any binary representation.</p>
<p>The complement of a binary representation is the number in binary you get when changing every 1 to a 0 and 0 to a 1.  For example, the complement of “101” in binary is “010” in binary.</p>
<p>For a given number N in base-10, return the complement of it’s binary representation as a base-10 integer.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 5</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: 5 is &quot;101&quot; in binary, with complement &quot;010&quot; in binary, which is 2 in base-10.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 7</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: 7 is &quot;111&quot; in binary, with complement &quot;000&quot; in binary, which is 0 in base-10.</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 10</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: 10 is &quot;1010&quot; in binary, with complement &quot;0101&quot; in binary, which is 5 in base-10.</span><br></pre></td></tr></table></figure></p>
<p>将十进制变成二进制然后取反加和<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">bitwiseComplement</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(N == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(N == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; re;</span><br><span class="line">        <span class="keyword">while</span>(N) &#123;</span><br><span class="line">            re.push_back(N &amp; <span class="number">1</span>);</span><br><span class="line">            N = N &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(re.begin(), re.end());</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; re.size(); i ++) &#123;</span><br><span class="line">            res = res * <span class="number">2</span> + (~re[i] &amp; <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>方法二，利用位运算直接取反。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">bitwiseComplement</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(!N)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(N &gt; <span class="built_in">pow</span>(<span class="number">2</span>, i))</span><br><span class="line">            i ++;</span><br><span class="line">        <span class="keyword">return</span> (~N) &amp; ((<span class="keyword">int</span>)<span class="built_in">pow</span>(<span class="number">2</span>, i) - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1010-Pairs-of-Songs-With-Total-Durations-Divisible-by-60"><a href="#Leetcode1010-Pairs-of-Songs-With-Total-Durations-Divisible-by-60" class="headerlink" title="Leetcode1010. Pairs of Songs With Total Durations Divisible by 60"></a>Leetcode1010. Pairs of Songs With Total Durations Divisible by 60</h1><p>In a list of songs, the i-th song has a duration of time[i] seconds. </p>
<p>Return the number of pairs of songs for which their total duration in seconds is divisible by 60.  Formally, we want the number of indices i, j such that i &lt; j with (time[i] + time[j]) % 60 == 0.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: [30,20,150,100,40]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: Three pairs have a total duration divisible by 60:</span><br><span class="line">(time[0] = 30, time[2] = 150): total duration 180</span><br><span class="line">(time[1] = 20, time[3] = 100): total duration 120</span><br><span class="line">(time[1] = 20, time[4] = 40): total duration 60</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [60,60,60]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: All three pairs have a total duration of 120, which is divisible by 60.</span><br></pre></td></tr></table></figure></p>
<p>一开始的思路，是暴力枚举，枚举第一首歌，然后第二首歌是枚举在第一首歌之后的所有情况，判断条件成立就 ans++ 。但这样子的时间复杂度是 O(n^2) 。题目中，数组长度 n&lt;=6e+4，所以时间复杂度是 3.6e+9，这样子会超时。</p>
<p>因此上述暴力枚举的方法行不通。</p>
<p>如果两首歌时间之和要能被60整除，说明余数为0，那么假设第一首歌对60的余数是 a ，那么另一首歌的对60的余数为 60-a 才行。所以我们可以用一个长度为60的数组，下标刚好对应求余后的数，每次找到一个新的歌余数为 a，就看它前面对应余数为 60-a 的有多少首歌，即可以匹配为多少对。最后这首歌的余数对应的下标数组值 ++。</p>
<p>这样解决之后，我们只用遍历一次数组即可，所以时间复杂度是 O(n) ，但是需要了额外的空间开销。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numPairsDivisibleBy60</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = time.size();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; yushu(<span class="number">60</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i ++) &#123;</span><br><span class="line">            res += yushu[(<span class="number">60</span> - time[i]%<span class="number">60</span>)%<span class="number">60</span>];</span><br><span class="line">            yushu[ time[i]%<span class="number">60</span> ] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1011-Capacity-To-Ship-Packages-Within-D-Days"><a href="#Leetcode1011-Capacity-To-Ship-Packages-Within-D-Days" class="headerlink" title="Leetcode1011. Capacity To Ship Packages Within D Days"></a>Leetcode1011. Capacity To Ship Packages Within D Days</h1><p>A conveyor belt has packages that must be shipped from one port to another within D days.</p>
<p>The ith package on the conveyor belt has a weight of weights[i]. Each day, we load the ship with packages on the conveyor belt (in the order given by weights). We may not load more weight than the maximum weight capacity of the ship.</p>
<p>Return the least weight capacity of the ship that will result in all the packages on the conveyor belt being shipped within D days.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: weights = [1,2,3,4,5,6,7,8,9,10], D = 5</span><br><span class="line">Output: 15</span><br><span class="line">Explanation: A ship capacity of 15 is the minimum to ship all the packages in 5 days like this:</span><br><span class="line">1st day: 1, 2, 3, 4, 5</span><br><span class="line">2nd day: 6, 7</span><br><span class="line">3rd day: 8</span><br><span class="line">4th day: 9</span><br><span class="line">5th day: 10</span><br></pre></td></tr></table></figure></p>
<p>Note that the cargo must be shipped in the order given, so using a ship of capacity 14 and splitting the packages into parts like (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) is not allowed.</p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: weights = [3,2,2,4,1,4], D = 3</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: A ship capacity of 6 is the minimum to ship all the packages in 3 days like this:</span><br><span class="line">1st day: 3, 2</span><br><span class="line">2nd day: 2, 4</span><br><span class="line">3rd day: 1, 4</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: weights = [1,2,3,1,1], D = 4</span><br><span class="line">Output: 3</span><br><span class="line">Explanation:</span><br><span class="line">1st day: 1</span><br><span class="line">2nd day: 2</span><br><span class="line">3rd day: 3</span><br><span class="line">4th day: 1, 1</span><br></pre></td></tr></table></figure></p>
<p>Constraints:</p>
<ul>
<li>1 &lt;= D &lt;= weights.length &lt;= 5 * 104</li>
<li>1 &lt;= weights[i] &lt;= 500</li>
</ul>
<p>这道题说是有一条传送带在运送包裹货物，每个包裹有各自的重量，每天要把若干包裹运送到货轮上，货轮有特定的承载量，要求在给定的D天内将所有货物装上货轮，问船的最小载重量是多少。</p>
<p>首先来分析，由于船的载重量是固定的，而包裹在传送带上又只能按照顺序上传，并不能挑拣，所以一旦加上当前包裹超过了船的载重量，则必须要放弃这个包裹，比较极端的例子就是，假如船的载重量是 50，现在船上已经装了一个重量为1的包裹，而下一个包裹重量是 50，那么这个包裹只能装在下一条船上。知道了这一点后，再来分析一下，船的载重量的范围，先来分析一下最小值，由于所有的包裹都要上船，所以最小的船载重量至少应该是最重的那个包裹，不然上不了船了，而最大的载重量就是包裹的总重量，一条船就能拉走了。所以正确的答案就在这两个边界范围之内，挨个遍历的话实在有些太不高效了。</p>
<p>这里就要祭出二分搜索法了，当算出了中间值 mid 后，利用这个载重量去算需要多少天能运完，然后去和D做比较，如果大于D，说明需要增加载重量，否则减少载重量，最终会终止到正确的结果。具体来看代码，left 初始化为最大的包裹重量，right 初始化为所有的包裹重量总和。然后进行 while 循环，求出 mid，同时使用两个变量 cnt 和 cur，分别用来计算需要的天数，和当前货物的重量，其中 cnt 初始化为1，至少需要一天来运货物。然后遍历所有的包裹重量，每次加到 cur，若此时 cur 大于 mid 了，说明当前包裹不能加了，将 cur 重置为当前包裹重量，为下条船做准备，然后 cnt 自增1。遍历完了之后，判断若 cnt 大于D，则 left 赋值为 mid+1，否则 right 赋值为 mid，最终返回 left 即可，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">shipWithinDays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; weights, <span class="keyword">int</span> days)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>, size = weights.size(), max_val = <span class="number">-1</span>, need;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i ++) &#123;</span><br><span class="line">            max_val = max(max_val, weights[i]);</span><br><span class="line">            sum += weights[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = max_val, right = sum, mid;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">            mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">            need = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i ++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cur + weights[i] &gt; mid) &#123;</span><br><span class="line">                    need ++;</span><br><span class="line">                    cur = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                cur += weights[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (need &gt; days)</span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1013-Partition-Array-Into-Three-Parts-With-Equal-Sum"><a href="#Leetcode1013-Partition-Array-Into-Three-Parts-With-Equal-Sum" class="headerlink" title="Leetcode1013. Partition Array Into Three Parts With Equal Sum"></a>Leetcode1013. Partition Array Into Three Parts With Equal Sum</h1><p>Given an array A of integers, return true if and only if we can partition the array into three non-empty parts with equal sums.</p>
<p>Formally, we can partition the array if we can find indexes i+1 &lt; j with (A[0] + A[1] + … + A[i] == A[i+1] + A[i+2] + … + A[j-1] == A[j] + A[j-1] + … + A[A.length - 1])</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [0,2,1,-6,6,-7,9,1,2,0,1]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: 0 + 2 + 1 = -6 + 6 - 7 + 9 + 1 = 2 + 0 + 1</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [0,2,1,-6,6,7,9,-1,2,0,1]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [3,3,6,5,-2,2,5,1,-9,4]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: 3 + 3 = 6 = 5 - 2 + 2 + 5 + 1 - 9 + 4</span><br></pre></td></tr></table></figure></p>
<p>1、检查总数是否能被3整除;<br>2、循环遍历数组A，计算和的一部分;如果找到平均值，则将该部分重置为0，并增加计数器;<br>3、到最后，如果平均可以看到至少3次，返回true;否则返回假。<br>注意:如果在数组结束前找到2次平均值(sum / 3)，那么剩下的部分也等于平均值。因此，计数器达到3后无需继续。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canThreePartsEqualSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>, part_sum = <span class="number">0</span>, i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size(); i ++) </span><br><span class="line">            sum += A[i];</span><br><span class="line">        <span class="keyword">if</span>(sum % <span class="number">3</span> != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        sum /= <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; A.size(); i ++) &#123;</span><br><span class="line">            part_sum += A[i];</span><br><span class="line">            <span class="keyword">if</span>(part_sum == sum)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(part_sum = <span class="number">0</span>, i = i + <span class="number">1</span>; i &lt; A.size(); i++) &#123;</span><br><span class="line">            part_sum += A[i];</span><br><span class="line">            <span class="keyword">if</span>(part_sum == sum)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; A.size() - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1014-Best-Sightseeing-Pair"><a href="#Leetcode1014-Best-Sightseeing-Pair" class="headerlink" title="Leetcode1014. Best Sightseeing Pair"></a>Leetcode1014. Best Sightseeing Pair</h1><p>Given an array A of positive integers, A[i] represents the value of the i-th sightseeing spot, and two sightseeing spots i and j have distance j - i between them.</p>
<p>The  score  of a pair (i &lt; j) of sightseeing spots is (A[i] + A[j] + i - j) : the sum of the values of the sightseeing spots, minus the distance between them.</p>
<p>Return the maximum score of a pair of sightseeing spots.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [8,1,5,2,6]</span><br><span class="line">Output: 11</span><br><span class="line">Explanation: i = 0, j = 2, A[i] + A[j] + i - j = 8 + 5 + 0 - 2 = 11</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>2 &lt;= A.length &lt;= 50000</li>
<li>1 &lt;= A[i] &lt;= 1000</li>
</ul>
<p>这道题给了一个正整数的数组A，定义了一种两个数字对儿的记分方式，为<code>A[i] + A[j] + i - j</code>，现在让找出最大的那组的分数。利用加法的分配律，可以得到<code>A[i] + i + A[j] - j</code>，为了使这个表达式最大化，<code>A[i] + i</code>自然是越大越好，这里可以使用一个变量 mx 来记录之前出现过的<code>A[i] + i</code>的最大值，则当前的数字就可以当作数对儿中的另一个数字，其减去当前坐标值再加上 mx 就可以更新结果 res 了，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxScoreSightseeingPair</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; values)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxx = INT_MIN, res = INT_MIN;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; values.size(); i ++) &#123;</span><br><span class="line">            res = max(res, maxx + values[i] - i);</span><br><span class="line">            maxx = max(maxx, values[i] + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1015-Smallest-Integer-Divisible-by-K"><a href="#Leetcode1015-Smallest-Integer-Divisible-by-K" class="headerlink" title="Leetcode1015. Smallest Integer Divisible by K"></a>Leetcode1015. Smallest Integer Divisible by K</h1><p>Given a positive integer K, you need to find the length of the smallest positive integer N such that N is divisible by K, and N only contains the digit 1.</p>
<p>Return <em>the length of </em>N. If there is no such N, return -1.</p>
<p>Note: N may not fit in a 64-bit signed integer.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: K = 1</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: The smallest answer is N = 1, which has length 1.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: K = 2</span><br><span class="line">Output: -1</span><br><span class="line">Explanation: There is no such positive integer N divisible by 2.</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: K = 3</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The smallest answer is N = 111, which has length 3.</span><br></pre></td></tr></table></figure></p>
<p>Constraints:</p>
<ul>
<li>1 &lt;= K &lt;= 105</li>
</ul>
<p>这道题说是给了一个正整数K，让找到一个长度最短且只由1组成的正整数N，可以整除K，问最短的长度是多少，若没有，则返回 -1。关于整除的一些性质，博主记得小学就应该学过，比如能被2整除的数字必须是偶数，能被3整除的数字各个位加起来必须能被3整除，能被5整除的数字的末尾数字必须是0或者5。由于N都是由1组成的，所以一定不可能整除2或者5，所以只要K中包含2或者5，直接返回 -1。其实有一个定理，若K不能被2或5整除，则一定有一个长度小于等于K且均由1组成的数，可以整除K。这里只要找到那个最短的长度即可。</p>
<p>从1开始检查，每次乘以 10 再加1，就可以得到下一个数字，但是由于K可能很大，则N就会超出整型数的范围，就算是长整型也不一定 hold 的住，所以不能一直变大，而是每次累加后都要对 K 取余，若余数为0，则直接返回当前长度，若不为0，则用余数乘以 10 再加1。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">smallestRepunitDivByK</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k % <span class="number">2</span> == <span class="number">0</span> || k % <span class="number">5</span> == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i ++) &#123;</span><br><span class="line">            r = r * <span class="number">10</span> + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (r % k == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            r = r % k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1016-Binary-String-With-Substrings-Representing-1-To-N"><a href="#Leetcode1016-Binary-String-With-Substrings-Representing-1-To-N" class="headerlink" title="Leetcode1016. Binary String With Substrings Representing 1 To N"></a>Leetcode1016. Binary String With Substrings Representing 1 To N</h1><p>Given a binary string S (a string consisting only of ‘0’ and ‘1’s) and a positive integer N, return true if and only if for every integer X from 1 to N, the binary representation of X is a substring of S.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: S = &quot;0110&quot;, N = 3</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: S = &quot;0110&quot;, N = 4</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>1 &lt;= S.length &lt;= 1000</li>
<li>1 &lt;= N &lt;= 10^9</li>
</ul>
<p>这道题给了一个二进制的字符串S，和一个正整数N，问从1到N的所有整数的二进制数的字符串是否都是S的子串。</p>
<p>验证从N到1之间所有的数字，先求出其二进制数的字符串，在 C++ 中可以利用 bitset 来做，将其转为字符串即可。由于定义了 32 位的 bitset，转为字符串后可能会有许多 leading zeros，所以首先要移除这些0，通过在字符串中查找第一个1，然后通过取子串的函数就可以去除所有的起始0了。然后在S中查找是否存在这个二进制字符串，若不存在，直接返回 false，遍历完成后返回 true 即可，参见代码如下：</p>
<p>学到了，<code>bitset</code>还可以这么用，转成二进制字符串确实很方便。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">queryString</span><span class="params">(<span class="built_in">string</span> S, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = N; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="built_in">string</span> b = <span class="built_in">bitset</span>&lt;<span class="number">32</span>&gt;(i).to_string();</span><br><span class="line">            <span class="keyword">if</span> (S.find(b.substr(b.find(<span class="string">"1"</span>))) == <span class="built_in">string</span>::npos) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1017-Convert-to-Base-2"><a href="#Leetcode1017-Convert-to-Base-2" class="headerlink" title="Leetcode1017. Convert to Base -2"></a>Leetcode1017. Convert to Base -2</h1><p>Given an integer n, return a binary string representing its representation in base -2.</p>
<p>Note that the returned string should not have leading zeros unless the string is “0”.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 2</span><br><span class="line">Output: &quot;110&quot;</span><br><span class="line">Explantion: (-2)2 + (-2)1 = 2</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 3</span><br><span class="line">Output: &quot;111&quot;</span><br><span class="line">Explantion: (-2)2 + (-2)1 + (-2)0 = 3</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 4</span><br><span class="line">Output: &quot;100&quot;</span><br><span class="line">Explantion: (-2)2 = 4</span><br></pre></td></tr></table></figure></p>
<p>这道题给了一个十进制的非负数N，让转为以负二进制的数。我们对于十进制数转二进制的数字应该比较熟悉，就是每次<code>N%2</code>或者<code>N&amp;1</code>，然后再将N右移一位，即相当于除以2，直到N为0为止。对于转为负二进制的数字，也是同样的做法，唯一不同的是，每次要除以 -2，即将N右移一位之后，要变为相反数，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">baseNeg2</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">while</span> (N != <span class="number">0</span>) &#123;</span><br><span class="line">            res = to_string(N &amp; <span class="number">1</span>) + res;</span><br><span class="line">            N = -(N &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res == <span class="string">""</span> ? <span class="string">"0"</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>由于转二进制数是要对2取余，则转负二进制就要对 -2 取余，然后N要除以 -2，但是有个问题是，取余操作可能会得到负数，但我们希望只得到0或1，这样就需要做些小调整，使其变为正数，变化方法是，余数加2，N加1，证明方法如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-1 = (-2) * 0 + (-1)</span><br><span class="line">-1 = (-2) * 0 + (-2) + (-1) - (-2)</span><br><span class="line">-1 = (-2) * (0 + 1) + (-1) - (-2)</span><br></pre></td></tr></table></figure></p>
<p>先加上一个 -2，再减去一个 -2，合并后就是N加1，余数加2，这样就可以把余数加到结果字符串中了，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">baseNeg2</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">while</span> (N != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> rem = N % (<span class="number">-2</span>);</span><br><span class="line">            N /= <span class="number">-2</span>;</span><br><span class="line">            <span class="keyword">if</span> (rem &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                rem += <span class="number">2</span>;</span><br><span class="line">                N += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res = to_string(rem) + res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res == <span class="string">""</span> ? <span class="string">"0"</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode1018-Binary-Prefix-Divisible-By-5"><a href="#Leetcode1018-Binary-Prefix-Divisible-By-5" class="headerlink" title="Leetcode1018. Binary Prefix Divisible By 5"></a>Leetcode1018. Binary Prefix Divisible By 5</h1><p>Given an array A of 0s and 1s, consider N_i: the i-th subarray from A[0] to A[i] interpreted as a binary number (from most-significant-bit to least-significant-bit.)</p>
<p>Return a list of booleans answer, where answer[i] is true if and only if N_i is divisible by 5.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [0,1,1]</span><br><span class="line">Output: [true,false,false]</span><br><span class="line">Explanation: The input numbers in binary are 0, 01, 011; which are 0, 1, and 3 in base-10.  Only the first number is divisible by 5, so answer[0] is true.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,1,1]</span><br><span class="line">Output: [false,false,false]</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [0,1,1,1,1,1]</span><br><span class="line">Output: [true,false,false,false,true,false]</span><br></pre></td></tr></table></figure></p>
<p>Example 4:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,1,1,0,1]</span><br><span class="line">Output: [false,false,false,false,false]</span><br></pre></td></tr></table></figure></p>
<p>假设当前访问 A[i - 1], 表示的数为 old_number, 那么当访问 A[i] 时, 所表示的数 new_number = old_number * 2 + A[i];</p>
<ul>
<li>如果直接判断 new_number 是否能被 5 整除, 容易出现溢出的问题, 因为按照上面遍历的方式, C++ 只能保存 32-bit 的数据, 但是题目中说明 1 &lt;= A.length &lt;= 30000.</li>
<li>我们不需要知道具体的 new_number 数值大小, 而只需要它与 5 的余数;<br>-发现一个数学公式: <code>(a*b + c) % d = ((a%d)*(b%d) + c%d) % d</code>, 因此 <code>new_number % 5</code> 可以表示为 <code>((old_number % 5) * 2 + A[i]) % 5</code>.</li>
<li>由第 4 点, 可以将 number % 5 作为一个整体, 更新公式为 <code>a = (a * 2 + A[i]) % 5</code>.</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; prefixesDivBy5(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; res;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, temp = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size(); i ++) &#123;</span><br><span class="line">            ans = ((ans * <span class="number">2</span>)%<span class="number">5</span> + A[i])%<span class="number">5</span>;</span><br><span class="line">            <span class="keyword">if</span>(ans % <span class="number">5</span> == <span class="number">0</span>)</span><br><span class="line">                res.push_back(<span class="literal">true</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                res.push_back(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode1019-Next-Greater-Node-In-Linked-List"><a href="#Leetcode1019-Next-Greater-Node-In-Linked-List" class="headerlink" title="Leetcode1019. Next Greater Node In Linked List"></a>Leetcode1019. Next Greater Node In Linked List</h1><p>You are given the head of a linked list with n nodes.</p>
<p>For each node in the list, find the value of the next greater node. That is, for each node, find the value of the first node that is next to it and has a strictly larger value than it.</p>
<p>Return an integer array answer where answer[i] is the value of the next greater node of the ith node (1-indexed). If the ith node does not have a next greater node, set answer[i] = 0.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: head = [2,1,5]</span><br><span class="line">Output: [5,5,0]</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: head = [2,7,4,3,5]</span><br><span class="line">Output: [7,0,5,5,0]</span><br></pre></td></tr></table></figure></p>
<p>这道题给了一个链表，让找出每个结点值的下一个较大的结点值，跟之前的 Next Greater Element I，Next Greater Element II，和 Next Greater Element III 很类似，不同的是这里不是数组，而是链表，就稍稍的增加了一些难度，因为链表无法直接根据下标访问元素，在遍历链表之前甚至不知道总共有多少个结点。基本上来说，为了达到线性的时间复杂度，这里需要维护一个单调递减的栈，若当前的数字小于等于栈顶元素，则加入栈，若当前数字大于栈顶元素，非常棒，说明栈顶元素的下一个较大数字找到了，标记上，且把栈顶元素移除，继续判断下一个栈顶元素和当前元素的关系，直到当前数字小于等于栈顶元素为止。通过这种方法，就可以在线性的时间内找出所有数字的下一个较大的数字了。</p>
<p>这里新建两个数组，res 和 nums 分别保存要求的结果和链表的所有结点值，还需要一个栈 st 和一个变量 cnt（记录当前的数组坐标），然后开始遍历链表，首先把当前结点值加入数组 nums，然后开始循环，若栈不空，且当前结点值大于栈顶元素（注意这里单调栈存的并不是结点值，而是该值在 nums 数组中的坐标值，这是为了更好的在结果 res 中定位），此时用该结点值来更新结果 res 中的对应的位置，然后将栈顶元素移除，继续循环直到条件不满足位置。然后把当前的坐标加入栈中，此时还要更新结果 res 的大小，因为由于链表的大小未知，无法直接初始化 res 的大小，当然我们可以在开头的时候先遍历一遍链表，得到结点的个数也是可以的，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nextLargerNodes(ListNode* head) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur) &#123;</span><br><span class="line">            cnt ++;</span><br><span class="line">            res.push_back(cur-&gt;val);</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res2(cnt, <span class="number">0</span>);</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(head != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!s.empty() &amp;&amp; res[s.top()] &lt; head-&gt;val) &#123;</span><br><span class="line">                res2[s.top()] = head-&gt;val;</span><br><span class="line">                s.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            s.push(cnt);</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            cnt ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这个人写的方法需要经常resize，不一定更快。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nextLargerNodes(ListNode* head) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res, nums;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (head) &#123;</span><br><span class="line">            nums.push_back(head-&gt;val);</span><br><span class="line">            <span class="keyword">while</span> (!st.empty() &amp;&amp; head-&gt;val &gt; nums[st.top()]) &#123;</span><br><span class="line">                res[st.top()] = head-&gt;val;</span><br><span class="line">                st.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            st.push(cnt);</span><br><span class="line">            res.resize(++cnt);</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>再看一种方法，首先把链表反转，也是用单调栈的方法。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* newHead = reverseList(head-&gt;next);</span><br><span class="line">        head-&gt;next-&gt;next = head;</span><br><span class="line">        head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nextLargerNodes(ListNode* head) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        ListNode* revHead = reverseList(head);</span><br><span class="line">        ListNode* curr = revHead;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (st.empty())</span><br><span class="line">            &#123;</span><br><span class="line">                result.push_back(<span class="number">0</span>);</span><br><span class="line">                st.push(curr-&gt;val);</span><br><span class="line">                curr = curr-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span> (!st.empty() &amp;&amp; curr-&gt;val &gt;= st.top())</span><br><span class="line">                    st.pop();</span><br><span class="line">                <span class="keyword">if</span> (!st.empty())</span><br><span class="line">                    result.push_back(st.top());</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    result.push_back(<span class="number">0</span>);</span><br><span class="line">                st.push(curr-&gt;val);</span><br><span class="line">                curr = curr-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::reverse(result.begin(), result.end());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1020-Number-of-Enclaves"><a href="#Leetcode1020-Number-of-Enclaves" class="headerlink" title="Leetcode1020. Number of Enclaves"></a>Leetcode1020. Number of Enclaves</h1><p>Given a 2D array A, each cell is 0 (representing sea) or 1 (representing land)</p>
<p>A move consists of walking from one land square 4-directionally to another land square, or off the boundary of the grid.</p>
<p>Return the number of land squares in the grid for which we cannot walk off the boundary of the grid in any number of moves.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [[0,0,0,0],[1,0,1,0],[0,1,1,0],[0,0,0,0]]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation:</span><br><span class="line">There are three 1s that are enclosed by 0s, and one 1 that isn&apos;t enclosed because its on the boundary.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [[0,1,1,0],[0,0,1,0],[0,0,1,0],[0,0,0,0]]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation:</span><br><span class="line">All 1s are either on the boundary or can reach the boundary.</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>1 &lt;= A.length &lt;= 500</li>
<li>1 &lt;= A[i].length &lt;= 500</li>
<li>0 &lt;= A[i][j] &lt;= 1</li>
<li>All rows have the same size.</li>
</ul>
<p>这道题给了一个只有0和1的二维数组A，其中0表示海洋，1表示陆地，每次只能从一块陆地走到和其相连的另一块陆地上，问有多少块陆地可以不用走到边界上。其实这道题就是让找出被0完全包围的1的个数，反过来想，如果有1在边界上，那么和其相连的所有1都是不符合题意的，所以只要以边界上的1为起点，遍历所有和其相连的1，并且标记，则剩下的1一定就是被0完全包围的。遍历的方法可以用 BFS 或者 DFS，先来看 BFS 的解法，使用一个队列 queue，遍历数组A，现将所有1的个数累加到结果 res，然后将边界上的1的坐标加入队列中。然后开始 while 循环，去除队首元素，若越界了，或者对应的值不为1，直接跳过。否则标记当前位置值为0，并且 res 自减1，然后将周围四个位置都排入队列中，最后返回结果 res 即可，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numEnclaves</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.size(), n = grid[<span class="number">0</span>].size(), num1 = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i ++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j ++) &#123;</span><br><span class="line">                num1 += grid[i][j];</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> || i == m<span class="number">-1</span> || j == <span class="number">0</span> || j == n<span class="number">-1</span>)</span><br><span class="line">                    q.push(make_pair(i, j));</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = q.front().first, y = q.front().second;</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= m || y &lt; <span class="number">0</span> || y &gt;= n || grid[x][y] != <span class="number">1</span>) </span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (grid[x][y] == <span class="number">1</span>) &#123;</span><br><span class="line">                grid[x][y] = <span class="number">0</span>;</span><br><span class="line">                num1 --;</span><br><span class="line">            &#125;</span><br><span class="line">            q.push(make_pair(x, y+<span class="number">1</span>));</span><br><span class="line">            q.push(make_pair(x, y<span class="number">-1</span>));</span><br><span class="line">            q.push(make_pair(x+<span class="number">1</span>, y));</span><br><span class="line">            q.push(make_pair(x<span class="number">-1</span>, y));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>用深度优先确实能快一点点<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= grid.size() || j &lt; <span class="number">0</span> || j &gt;= grid[<span class="number">0</span>].size() || grid[i][j] != <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        grid[i][j] = <span class="number">0</span>;</span><br><span class="line">        dfs(grid, i, j+<span class="number">1</span>);</span><br><span class="line">        dfs(grid, i, j<span class="number">-1</span>);</span><br><span class="line">        dfs(grid, i+<span class="number">1</span>, j);</span><br><span class="line">        dfs(grid, i<span class="number">-1</span>, j);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numEnclaves</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.size(), n = grid[<span class="number">0</span>].size(), num1 = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][<span class="number">0</span>] == <span class="number">1</span>)</span><br><span class="line">                dfs(grid, i, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (grid[i][n<span class="number">-1</span>] == <span class="number">1</span>)</span><br><span class="line">                dfs(grid, i, n<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[<span class="number">0</span>][i] == <span class="number">1</span>)</span><br><span class="line">                dfs(grid, <span class="number">0</span>, i);</span><br><span class="line">            <span class="keyword">if</span> (grid[m<span class="number">-1</span>][i] == <span class="number">1</span>)</span><br><span class="line">                dfs(grid, m<span class="number">-1</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i ++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j ++)</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>)</span><br><span class="line">                    num1 ++;</span><br><span class="line">        <span class="keyword">return</span> num1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1021-Remove-Outermost-Parentheses"><a href="#Leetcode1021-Remove-Outermost-Parentheses" class="headerlink" title="Leetcode1021. Remove Outermost Parentheses"></a>Leetcode1021. Remove Outermost Parentheses</h1><p>A valid parentheses string is either empty (“”), “(“ + A + “)”, or A + B, where A and B are valid parentheses strings, and + represents string concatenation.  For example, “”, “()”, “(())()”, and “(()(()))” are all valid parentheses strings.</p>
<p>A valid parentheses string S is primitive if it is nonempty, and there does not exist a way to split it into S = A+B, with A and B nonempty valid parentheses strings.</p>
<p>Given a valid parentheses string S, consider its primitive decomposition: S = P_1 + P_2 + … + P_k, where P_i are primitive valid parentheses strings.</p>
<p>Return S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;(()())(())&quot;</span><br><span class="line">Output: &quot;()()()&quot;</span><br><span class="line">Explanation: </span><br><span class="line">The input string is &quot;(()())(())&quot;, with primitive decomposition &quot;(()())&quot; + &quot;(())&quot;.</span><br><span class="line">After removing outer parentheses of each part, this is &quot;()()&quot; + &quot;()&quot; = &quot;()()()&quot;.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;(()())(())(()(()))&quot;</span><br><span class="line">Output: &quot;()()()()(())&quot;</span><br><span class="line">Explanation: </span><br><span class="line">The input string is &quot;(()())(())(()(()))&quot;, with primitive decomposition &quot;(()())&quot; + &quot;(())&quot; + &quot;(()(()))&quot;.</span><br><span class="line">After removing outer parentheses of each part, this is &quot;()()&quot; + &quot;()&quot; + &quot;()(())&quot; = &quot;()()()()(())&quot;.</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;()()&quot;</span><br><span class="line">Output: &quot;&quot;</span><br><span class="line">Explanation: </span><br><span class="line">The input string is &quot;()()&quot;, with primitive decomposition &quot;()&quot; + &quot;()&quot;.</span><br><span class="line">After removing outer parentheses of each part, this is &quot;&quot; + &quot;&quot; = &quot;&quot;.</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ol>
<li>S.length &lt;= 10000</li>
<li>S[i] is “(“ or “)”</li>
<li>S is a valid parentheses string</li>
</ol>
<p>比较简单，把最外边的一层括号移走，可以用栈，也可以用计数器。如果遇到左括号且栈不空说明这个左括号不是外边的括号，加到结果中，再把这个左括号压栈；如果是右括号，就先弹出栈，再判断如果栈不空则说明这个右括号也不是外边的括号，加到结果中。</p>
<p>不知道为啥我这个这么慢，反正过了就行。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">removeOuterParentheses</span><span class="params">(<span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> result=<span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> length = S.length();</span><br><span class="line">        <span class="keyword">int</span> ss=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(S[i]==<span class="string">'('</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(ss!=<span class="number">0</span>)</span><br><span class="line">                    result=result+<span class="string">'('</span>;</span><br><span class="line">                ss++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(S[i]==<span class="string">')'</span>)&#123;</span><br><span class="line">                ss--;</span><br><span class="line">                <span class="keyword">if</span>(ss!=<span class="number">0</span>)</span><br><span class="line">                    result=result+<span class="string">")"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode1022-Sum-of-Root-To-Leaf-Binary-Numbers"><a href="#Leetcode1022-Sum-of-Root-To-Leaf-Binary-Numbers" class="headerlink" title="Leetcode1022. Sum of Root To Leaf Binary Numbers"></a>Leetcode1022. Sum of Root To Leaf Binary Numbers</h1><p>Given a binary tree, each node has value 0 or 1.  Each root-to-leaf path represents a binary number starting with the most significant bit.  For example, if the path is 0 -&gt; 1 -&gt; 1 -&gt; 0 -&gt; 1, then this could represent 01101 in binary, which is 13.</p>
<p>For all leaves in the tree, consider the numbers represented by the path from the root to that leaf.</p>
<p>Return the sum of these numbers.</p>
<p><img src="/img/sum-of-root-to-leaf-binary-numbers.png" alt></p>
<p>深度优先遍历一波，因为好久没写dsf了，所以特地写一写。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> result;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root ,<span class="keyword">int</span> now)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right)&#123;</span><br><span class="line">            result += (now&lt;&lt;<span class="number">1</span>) + root-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> val = (now&lt;&lt;<span class="number">1</span>) + root-&gt;val;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left)</span><br><span class="line">            dfs(root-&gt;left, val);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right)</span><br><span class="line">            dfs(root-&gt;right, val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumRootToLeaf</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        result=<span class="number">0</span>;</span><br><span class="line">        dfs(root,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1023-Camelcase-Matching"><a href="#Leetcode1023-Camelcase-Matching" class="headerlink" title="Leetcode1023. Camelcase Matching"></a>Leetcode1023. Camelcase Matching</h1><p>A query word matches a given pattern if we can insert lowercase letters to the pattern word so that it equals the query. (We may insert each character at any position, and may insert 0 characters.)</p>
<p>Given a list of queries, and a pattern, return an answer list of booleans, where answer[i] is true if and only if queries[i] matches the pattern.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: queries = [&quot;FooBar&quot;,&quot;FooBarTest&quot;,&quot;FootBall&quot;,&quot;FrameBuffer&quot;,&quot;ForceFeedBack&quot;], pattern = &quot;FB&quot;</span><br><span class="line">Output: [true,false,true,true,false]</span><br><span class="line">Explanation: </span><br><span class="line">&quot;FooBar&quot; can be generated like this &quot;F&quot; + &quot;oo&quot; + &quot;B&quot; + &quot;ar&quot;.</span><br><span class="line">&quot;FootBall&quot; can be generated like this &quot;F&quot; + &quot;oot&quot; + &quot;B&quot; + &quot;all&quot;.</span><br><span class="line">&quot;FrameBuffer&quot; can be generated like this &quot;F&quot; + &quot;rame&quot; + &quot;B&quot; + &quot;uffer&quot;.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: queries = [&quot;FooBar&quot;,&quot;FooBarTest&quot;,&quot;FootBall&quot;,&quot;FrameBuffer&quot;,&quot;ForceFeedBack&quot;], pattern = &quot;FoBa&quot;</span><br><span class="line">Output: [true,false,true,false,false]</span><br><span class="line">Explanation: </span><br><span class="line">&quot;FooBar&quot; can be generated like this &quot;Fo&quot; + &quot;o&quot; + &quot;Ba&quot; + &quot;r&quot;.</span><br><span class="line">&quot;FootBall&quot; can be generated like this &quot;Fo&quot; + &quot;ot&quot; + &quot;Ba&quot; + &quot;ll&quot;.</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: queries = [&quot;FooBar&quot;,&quot;FooBarTest&quot;,&quot;FootBall&quot;,&quot;FrameBuffer&quot;,&quot;ForceFeedBack&quot;], pattern = &quot;FoBaT&quot;</span><br><span class="line">Output: [false,true,false,false,false]</span><br><span class="line">Explanation: </span><br><span class="line">&quot;FooBarTest&quot; can be generated like this &quot;Fo&quot; + &quot;o&quot; + &quot;Ba&quot; + &quot;r&quot; + &quot;T&quot; + &quot;est&quot;.</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>1 &lt;= queries.length &lt;= 100</li>
<li>1 &lt;= queries[i].length &lt;= 100</li>
<li>1 &lt;= pattern.length &lt;= 100</li>
<li>All strings consists only of lower and upper case English letters.</li>
</ul>
<p>给一个字符串和一个模式串，看能不能在模式串里加小写字母来转换成字符串，比较简单。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; camelMatch(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; queries, <span class="built_in">string</span> pattern) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;queries.size();i++)&#123;</span><br><span class="line">            <span class="keyword">bool</span> succ=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;queries[i].size();j++)&#123;</span><br><span class="line">                <span class="keyword">while</span>(<span class="built_in">islower</span>(queries[i][j])&amp;&amp; pattern[index]!=queries[i][j])&#123;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(pattern[index]==queries[i][j])</span><br><span class="line">                    index++;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    succ=<span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            </span><br><span class="line">            &#125;</span><br><span class="line">            ans.push_back(succ);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>我的代码比较慢，可以看看大佬们怎么写的。</p>
<p>Solution 1, Find<br>For each query, find all letters in pattern left-to-right. If we found all pattern letters, check that the rest of the letters is in the lower case.</p>
<p>对每个查询，从左到右找pattern里的字幕，如果找到了，检查剩余的是否是小写字母。感觉跟我的类似。</p>
<p>For simplicity, we can replace the found pattern letter in query with a lowercase ‘a’.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; camelMatch(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; qs, <span class="built_in">string</span> pattern, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; res = &#123;&#125;) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; qs.size(); ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> p = <span class="number">-1</span>, j = <span class="number">0</span>; j &lt; pattern.size(); ++j) &#123;</span><br><span class="line">      p = qs[i].find(pattern[j], p + <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (p == <span class="built_in">string</span>::npos) &#123;</span><br><span class="line">        res.push_back(<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      qs[i][p] = <span class="string">'a'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (res.size() &lt;= i) res.push_back(all_of(begin(qs[i]), end(qs[i]), [](<span class="keyword">char</span> ch) &#123; <span class="keyword">return</span> <span class="built_in">islower</span>(ch); &#125;));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Solution 2, Simple Scan<br>Instead of using the find function, we can just check all characters in the query. If a character matches the pattern pointer (pattern[p]), we advance that pointer (++p). Otherwise, we check that the query character is in the lower case.</p>
<p>检查查询的字符串，如果一个字符与pattern[p]匹配了，就继续，如果不匹配，看是不是小些</p>
<p>With this solution, it’s also easer to realize that the complexity is O(n), where n is the total number of query characters.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; camelMatch(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; qs, <span class="built_in">string</span> pattern, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; res = &#123;&#125;) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>, j = <span class="number">0</span>, p = <span class="number">0</span>; i &lt; qs.size(); ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>, p = <span class="number">0</span>; j &lt; qs[i].size(); ++j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (p &lt; pattern.size() &amp;&amp; qs[i][j] == pattern[p]) ++p;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">islower</span>(qs[i][j])) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    res.push_back(j == qs[i].size() &amp;&amp; p == pattern.size());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Complexity Analysis</p>
<ul>
<li>Runtime: O(n), where n is all letters in all queries. We process each letter only once.</li>
<li>Memory: O(m), where m is the number of queries (to store the result).</li>
<li>时间复杂度O(n)，空间复杂度O(m)</li>
</ul>
<h1 id="Leetcode1024-Video-Stitching"><a href="#Leetcode1024-Video-Stitching" class="headerlink" title="Leetcode1024. Video Stitching"></a>Leetcode1024. Video Stitching</h1><p>You are given a series of video clips from a sporting event that lasted T seconds.  These video clips can be overlapping with each other and have varied lengths.</p>
<p>Each video clip clips[i] is an interval: it starts at time clips[i][0] and ends at time clips[i][1].  We can cut these clips into segments freely: for example, a clip [0, 7] can be cut into segments [0, 1] + [1, 3] + [3, 7].</p>
<p>Return the minimum number of clips needed so that we can cut the clips into segments that cover the entire sporting event ([0, T]).  If the task is impossible, return -1.</p>
<p>寻找最少的可以覆盖[0, T]区间的区间数量，一开始没搞定，看答案搞定的。总体思路就是一开始先排序，并且记下来两个end，一个是当前的end，一个是之前一次的end，如果现在这个小区间的end比之前的pre_end还小，直接不考虑了。我做的时候忽略了这一点，如果不记下来之前的per_end的话，可能有区间是重复的（现在这个小区间如果加进去了，就跟上次加进去的那个小区间有重复的部分或者重合）</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: clips = [[0,2],[4,6],[8,10],[1,9],[1,5],[5,9]], T = 10</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: </span><br><span class="line">We take the clips [0,2], [8,10], [1,9]; a total of 3 clips.</span><br><span class="line">Then, we can reconstruct the sporting event as follows:</span><br><span class="line">We cut [1,9] into segments [1,2] + [2,8] + [8,9].</span><br><span class="line">Now we have segments [0,2] + [2,8] + [8,10] which cover the sporting event [0, 10].</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: clips = [[0,1],[1,2]], T = 5</span><br><span class="line">Output: -1</span><br><span class="line">Explanation: </span><br><span class="line">We can&apos;t cover [0,5] with only [0,1] and [0,2].</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: clips = [[0,1],[6,8],[0,2],[5,6],[0,4],[0,3],[6,7],[1,3],[4,7],[1,4],[2,5],[2,6],[3,4],[4,5],[5,7],[6,9]], T = 9</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: </span><br><span class="line">We can take clips [0,4], [4,7], and [6,9].</span><br></pre></td></tr></table></figure></p>
<p>Example 4:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: clips = [[0,4],[2,8]], T = 5</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: </span><br><span class="line">Notice you can have extra video after the event ends.</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<p>1 &lt;= clips.length &lt;= 100<br>0 &lt;= clips[i][0], clips[i][1] &lt;= 100<br>0 &lt;= T &lt;= 100</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">comp</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[<span class="number">0</span>]==b[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">1</span>] &gt; b[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">videoStitching</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; clips, <span class="keyword">int</span> T)</span> </span>&#123;</span><br><span class="line">        sort(clips.begin(), clips.end(), comp);</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>, cur_end=<span class="number">0</span>, pre_end=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clips.size(); i ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(clips[i][<span class="number">1</span>] &lt;= cur_end)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(clips[i][<span class="number">0</span>] &gt; cur_end)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span>(clips[i][<span class="number">0</span>] &gt; pre_end)&#123;</span><br><span class="line">                pre_end = cur_end;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            cur_end = clips[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(cur_end &gt;= T)</span><br><span class="line">                <span class="keyword">return</span> count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode1025-Divisor-Game"><a href="#Leetcode1025-Divisor-Game" class="headerlink" title="Leetcode1025. Divisor Game"></a>Leetcode1025. Divisor Game</h1><p>Alice and Bob take turns playing a game, with Alice starting first.</p>
<p>Initially, there is a number N on the chalkboard.  On each player’s turn, that player makes a move consisting of:</p>
<p>Choosing any x with 0 &lt; x &lt; N and N % x == 0.<br>Replacing the number N on the chalkboard with N - x.<br>Also, if a player cannot make a move, they lose the game.</p>
<p>Return True if and only if Alice wins the game, assuming both players play optimally.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 2</span><br><span class="line">Output: true</span><br><span class="line">Explanation: Alice chooses 1, and Bob has no more moves.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 3</span><br><span class="line">Output: false</span><br><span class="line">Explanation: Alice chooses 1, Bob chooses 1, and Alice has no more moves.</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>1 &lt;= N &lt;= 1000</li>
</ul>
<p>两个人玩游戏，给一个数字N，先轮到A走，A选一个数字x使得<code>0 &lt; x &lt; N</code>且<code>N % x == 0</code>，之后N变为N-x，如果谁选不出来x，那就输了，A遇见偶数赢，奇数输。</p>
<p>如果A看见偶数，就选x=1，则N变成奇数，B只能再选一个奇数，又把N变成偶数，由于1是奇数且1没法再选，故A遇见偶数一定赢，反之则输。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">divisorGame</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (N%<span class="number">2</span>)==<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode1026-Maximum-Difference-Between-Node-and-Ancestor"><a href="#Leetcode1026-Maximum-Difference-Between-Node-and-Ancestor" class="headerlink" title="Leetcode1026. Maximum Difference Between Node and Ancestor"></a>Leetcode1026. Maximum Difference Between Node and Ancestor</h1><p>Given the root of a binary tree, find the maximum value V for which there exists different nodes A and B where V = |A.val - B.val| and A is an ancestor of B.</p>
<p>(A node A is an ancestor of B if either: any child of A is equal to B, or any child of A is an ancestor of B.)</p>
<p>Example 1:<br><img src="/img/2whqcep.jpg" alt><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: [8,3,10,1,6,null,14,null,null,4,7,13]</span><br><span class="line">Output: 7</span><br><span class="line">Explanation: </span><br><span class="line">We have various ancestor-node differences, some of which are given below :</span><br><span class="line">|8 - 3| = 5</span><br><span class="line">|3 - 7| = 4</span><br><span class="line">|8 - 1| = 7</span><br><span class="line">|10 - 13| = 3</span><br><span class="line">Among all possible differences, the maximum value of 7 is obtained by |8 - 1| = 7.</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>The number of nodes in the tree is between 2 and 5000.</li>
<li>Each node will have value between 0 and 100000.</li>
</ul>
<p>给一棵树，找到最大值v，这个v是节点和祖先的值的差的绝对值。dfs里一定要有一个最大一个最小，这样才能算出来绝对值最大的一个，之前考虑只放一个值，没有搞定。</p>
<p>一个dfs<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> val=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root,<span class="keyword">int</span> maxval,<span class="keyword">int</span> minval)</span></span>&#123;</span><br><span class="line">        val = max(val, <span class="built_in">abs</span>(root-&gt;val - maxval));</span><br><span class="line">        val = max(val, <span class="built_in">abs</span>(root-&gt;val - minval));</span><br><span class="line">        maxval = max(maxval, root-&gt;val);</span><br><span class="line">        minval = min(minval, root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right) dfs(root-&gt;right,maxval,minval);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left) dfs(root-&gt;left,maxval,minval);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxAncestorDiff</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        dfs(root,root-&gt;val,root-&gt;val);</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1027-Longest-Arithmetic-Sequence"><a href="#Leetcode1027-Longest-Arithmetic-Sequence" class="headerlink" title="Leetcode1027. Longest Arithmetic Sequence"></a>Leetcode1027. Longest Arithmetic Sequence</h1><p>Given an array A of integers, return the length of the longest arithmetic subsequence in A.</p>
<p>Recall that a  subsequence  of A is a list A[i_1], A[i_2], …, A[i_k] with 0 &lt;= i_1 &lt; i_2 &lt; … &lt; i_k &lt;= A.length - 1, and that a sequence B is  arithmetic  if B[i+1] - B[i] are all the same value (for 0 &lt;= i &lt; B.length - 1).</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [3,6,9,12]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation:</span><br><span class="line">The whole array is an arithmetic sequence with steps of length = 3.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [9,4,7,2,10]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation:</span><br><span class="line">The longest arithmetic subsequence is [4,7,10].</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [20,1,15,3,10,5,8]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation:</span><br><span class="line">The longest arithmetic subsequence is [20,15,10,5].</span><br></pre></td></tr></table></figure></p>
<p>Constraints:</p>
<ul>
<li>2 &lt;= A.length &lt;= 1000</li>
<li>0 &lt;= A[i] &lt;= 500</li>
</ul>
<p>这道题给了一个数组，让找最长的等差数列的长度，首先来考虑如何定义 DP 数组，最直接的就是用一个一维数组，其中<code>dp[i]</code>表示区间 [0, i] 中的最长等差数列的长度，但是这样定义的话，很难找出状态转移方程。因为有些隐藏信息被我们忽略了，就是等差数列的相等的差值，不同的等差数列的差值可以是不同的，所以不包括这个信息的话将很难更新 dp 值。所以这里就需要一个二维数组，<code>dp[i][j]</code>表示在区间 [0, i] 中的差值为j的最长等差数列的长度减1，这里减1是因为起始的数字并没有被算进去，不过不要紧，最后再加回来就行了。</p>
<p>还有一个需要注意的地方，由于等差数列的差值有可能是负数，而数组的下标不能是负数，所以需要处理一下，题目中限定了数组中的数字范围为0到 500 之间，所以差值的范围就是 -500 到 500 之间，可以给差值加上个 1000，这样差值范围就是 500 到 1500 了，二维 dp 数组的大小可以初始化为 nx2000。更新 dp 值的时候，先遍历一遍数组，对于每个遍历到的数字，再遍历一遍前面的所有数字，算出差值 diff，再加上 1000，然后此时的<code>dp[i][diff]</code>可以赋值为<code>dp[j][diff]+1</code>，然后用这个新的 dp 值来更新结果 res，最后别忘了 res 加1后返回，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestArithSeqLength</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, n = A.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2000</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                <span class="keyword">int</span> diff = A[i] - A[j] + <span class="number">1000</span>;</span><br><span class="line">                dp[i][diff] = dp[j][diff] + <span class="number">1</span>;</span><br><span class="line">                res = max(res, dp[i][diff]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1028-Recover-a-Tree-From-Preorder-Traversal"><a href="#Leetcode1028-Recover-a-Tree-From-Preorder-Traversal" class="headerlink" title="Leetcode1028. Recover a Tree From Preorder Traversal"></a>Leetcode1028. Recover a Tree From Preorder Traversal</h1><p>We run a preorder depth-first search (DFS) on the root of a binary tree.</p>
<p>At each node in this traversal, we output D dashes (where D is the depth of this node), then we output the value of this node.  If the depth of a node is D, the depth of its immediate child is D + 1.  The depth of the root node is 0.</p>
<p>If a node has only one child, that child is guaranteed to be the left child.</p>
<p>Given the output traversal of this traversal, recover the tree and return its root.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: traversal = &quot;1-2--3--4-5--6--7&quot;</span><br><span class="line">Output: [1,2,5,3,4,6,7]</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: traversal = &quot;1-2--3---4-5--6---7&quot;</span><br><span class="line">Output: [1,2,5,3,null,6,null,4,null,7]</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: traversal = &quot;1-401--349---90--88&quot;</span><br><span class="line">Output: [1,401,null,349,88,90]</span><br></pre></td></tr></table></figure></p>
<p>这道题让我们根据一棵二叉树的先序遍历的结果来重建这棵二叉树。这里为了能够只根据先序遍历的结果来唯一的重建出二叉树，提供了每个结点值的深度，用短杠的个数来表示，根结点的深度为0，前方没有短杠，后面的数字前方只有一个短杠的就是根结点的左右子结点，然后紧跟在一个短杠后面的两个短杠的数字就是根结点左子结点的左子结点，以此类推。</p>
<p>遍历输入字符串，先提取短杠的个数，因为除了根结点之外，所有的深度值都是在结点值前面的，所有用一个 for 循环先提取出短杠的个数 level，然后提取结点值，也是用一个 for 循环，因为结点值可能是个多位数，有了结点值之后我们就可以新建一个结点了。下一步就比较 tricky 了，因为先序遍历跟 DFS 搜索一样有一个回到先前位置的过程，比如例子1中，当我们遍历到结点5的时候，此时是从叶结点4回到了根结点的右子结点5，现在栈中有4个结点，而当前深度为1的结点5是要连到根结点的，所以栈中的无关结点就要移除，需要把结点 2，3，4 都移除，就用一个 while 循环，假如栈中元素个数大于当前的深度 level，就移除栈顶元素。那么此时栈中就只剩根结点了，就可以连接了。此时我们的连接策略是，假如栈顶元素的左子结点为空，则连在左子结点上，否则连在右子结点上，因为题目中说了，假如只有一个子结点，一定是左子结点。然后再把当前结点压入栈即可，字符串遍历结束后，栈中只会留有一个结点（题目中限定了树不为空），就是根结点，直接返回即可，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">recoverFromPreorder</span><span class="params">(<span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt; st;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, level = <span class="number">0</span>, val = <span class="number">0</span>, n = S.size();</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">            <span class="keyword">for</span> (level = <span class="number">0</span>; i &lt; n &amp;&amp; S[i] == <span class="string">'-'</span>; ++i) &#123;</span><br><span class="line">                ++level;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (val = <span class="number">0</span>; i &lt; n &amp;&amp; S[i] != <span class="string">'-'</span>; ++i) &#123;</span><br><span class="line">                val = <span class="number">10</span> * val + (S[i] - <span class="string">'0'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            TreeNode *node = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">            <span class="keyword">while</span> (st.size() &gt; level) st.pop_back();</span><br><span class="line">            <span class="keyword">if</span> (!st.empty()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!st.back()-&gt;left) st.back()-&gt;left = node;</span><br><span class="line">                <span class="keyword">else</span> st.back()-&gt;right = node;</span><br><span class="line">            &#125;</span><br><span class="line">            st.push_back(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> st[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>我自己的方法是根据-的数量得到层数，判断这是到第几层了，如果超过了当前的层数，就说明到底了，返回就行。但是不知道为什么很慢。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">dfs</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span>&amp; cur, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == s.length())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> i = cur, len = s.length();</span><br><span class="line">        <span class="keyword">while</span>(i &lt; len &amp;&amp; i &lt; cur+depth) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] != <span class="string">'-'</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            i ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i != cur+depth)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; len)</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">'0'</span> &lt;= s[i] &amp;&amp; s[i] &lt;= <span class="string">'9'</span>)</span><br><span class="line">                val = val * <span class="number">10</span> + s[i++] - <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        TreeNode* res = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">        </span><br><span class="line">        cur = i;</span><br><span class="line">        res-&gt;left = dfs(s, cur, depth+<span class="number">1</span>);</span><br><span class="line">        res-&gt;right = dfs(s, cur, depth+<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode* <span class="title">recoverFromPreorder</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> dfs(s, pos, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1029-Two-City-Scheduling"><a href="#Leetcode1029-Two-City-Scheduling" class="headerlink" title="Leetcode1029. Two City Scheduling"></a>Leetcode1029. Two City Scheduling</h1><p>There are 2N people a company is planning to interview. The cost of flying the i-th person to city A is costs[i][0], and the cost of flying the i-th person to city B is costs[i][1].</p>
<p>Return the minimum cost to fly every person to a city such that exactly N people arrive in each city.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: [[10,20],[30,200],[400,50],[30,20]]</span><br><span class="line">Output: 110</span><br><span class="line">Explanation: </span><br><span class="line">The first person goes to city A for a cost of 10.</span><br><span class="line">The second person goes to city A for a cost of 30.</span><br><span class="line">The third person goes to city B for a cost of 50.</span><br><span class="line">The fourth person goes to city B for a cost of 20.</span><br></pre></td></tr></table></figure></p>
<p>The total minimum cost is 10 + 30 + 50 + 20 = 110 to have half the people interviewing in each city.</p>
<p>Note:</p>
<ul>
<li>1 &lt;= costs.length &lt;= 100</li>
<li>It is guaranteed that costs.length is even.</li>
<li>1 &lt;= costs[i][0], costs[i][1] &lt;= 1000</li>
</ul>
<p>公司计划面试 2N 人。第 i 人飞往 A 市的费用为 costs[i][0]，飞往 B 市的费用为 costs[i][1]。<br>返回将每个人都飞到某座城市的最低费用，要求每个城市都有 N 人抵达。</p>
<p>由于人数是偶数个，一半的人去A,一半的人去B，换个角度，每个人要么去A，要么去B。如果他去A比去B的路程短，而且，这个节省的路程比一半的人还多，那么他就去A。所以，以去A和去B的路程差作为Key进行升序排序，前面一半人去A，后面去B。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">comp</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>]-a[<span class="number">1</span>] &lt; b[<span class="number">0</span>]-b[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">twoCitySchedCost</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; costs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(costs.size()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        sort(costs.begin(), costs.end(), comp);</span><br><span class="line">        <span class="keyword">int</span> ii=costs.size();</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;ii/<span class="number">2</span>;i++)</span><br><span class="line">            result += costs[i][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(;i&lt;ii;i++)</span><br><span class="line">            result+=costs[i][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode1030-Matrix-Cells-in-Distance-Order"><a href="#Leetcode1030-Matrix-Cells-in-Distance-Order" class="headerlink" title="Leetcode1030. Matrix Cells in Distance Order"></a>Leetcode1030. Matrix Cells in Distance Order</h1><p>We are given a matrix with R rows and C columns has cells with integer coordinates (r, c), where 0 &lt;= r &lt; R and 0 &lt;= c &lt; C.</p>
<p>Additionally, we are given a cell in that matrix with coordinates (r0, c0).</p>
<p>Return the coordinates of all cells in the matrix, sorted by their distance from (r0, c0) from smallest distance to largest distance.  Here, the distance between two cells (r1, c1) and (r2, c2) is the Manhattan distance, |r1 - r2| + |c1 - c2|.  (You may return the answer in any order that satisfies this condition.)</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: R = 1, C = 2, r0 = 0, c0 = 0</span><br><span class="line">Output: [[0,0],[0,1]]</span><br><span class="line">Explanation: The distances from (r0, c0) to other cells are: [0,1]</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: R = 2, C = 2, r0 = 0, c0 = 1</span><br><span class="line">Output: [[0,1],[0,0],[1,1],[1,0]]</span><br><span class="line">Explanation: The distances from (r0, c0) to other cells are: [0,1,1,2]</span><br><span class="line">The answer [[0,1],[1,1],[0,0],[1,0]] would also be accepted as correct.</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: R = 2, C = 3, r0 = 1, c0 = 2</span><br><span class="line">Output: [[1,2],[0,2],[1,1],[0,1],[1,0],[0,0]]</span><br><span class="line">Explanation: The distances from (r0, c0) to other cells are: [0,1,1,2,2,3]</span><br><span class="line">There are other answers that would also be accepted as correct, such as [[1,2],[1,1],[0,2],[1,0],[0,1],[0,0]].</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>1 &lt;= R &lt;= 100</li>
<li>1 &lt;= C &lt;= 100</li>
<li>0 &lt;= r0 &lt; R</li>
<li>0 &lt;= c0 &lt; C</li>
</ul>
<p>根据与给定的点的顺序排序。</p>
<p>看到一种比较辣鸡的做法，就是先把所有点都加进去，再排序，顺便学习了一个新的写法，如下的lambda表达式：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">      </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; allCellsDistOrder(<span class="keyword">int</span> R, <span class="keyword">int</span> C, <span class="keyword">int</span> r0, <span class="keyword">int</span> c0) &#123;</span><br><span class="line">        <span class="keyword">auto</span> comp = [r0,c0](<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;b)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">abs</span>(a[<span class="number">0</span>]-r0) + <span class="built_in">abs</span>(a[<span class="number">1</span>]-c0) &lt; <span class="built_in">abs</span>(b[<span class="number">0</span>]-r0) + <span class="built_in">abs</span>(b[<span class="number">1</span>]-c0);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;R;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;C;j++)</span><br><span class="line">                res.push_back(&#123;i,j&#125;);</span><br><span class="line">        </span><br><span class="line">        sort(res.begin(),res.end(),comp);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>用bfs做也行：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; allCellsDistOrder(<span class="keyword">int</span> R, <span class="keyword">int</span> C, <span class="keyword">int</span> r0, <span class="keyword">int</span> c0) &#123;</span><br><span class="line">        <span class="keyword">int</span> visit[R][C];</span><br><span class="line">        <span class="built_in">memset</span>(visit,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*R*C);</span><br><span class="line">        <span class="keyword">int</span> direction[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;&#125;;</span><br><span class="line">        <span class="built_in">queue</span>&lt; pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; qu;</span><br><span class="line">        <span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; res;</span><br><span class="line">        qu.push(&#123;r0,c0&#125;);</span><br><span class="line">        <span class="keyword">while</span>(!qu.empty())&#123;</span><br><span class="line">            pair&lt;<span class="keyword">int</span> ,<span class="keyword">int</span>&gt; temp = qu.front();</span><br><span class="line">            qu.pop();</span><br><span class="line">            <span class="keyword">int</span> x = temp.first;</span><br><span class="line">            <span class="keyword">int</span> y = temp.second;</span><br><span class="line">            <span class="keyword">if</span>(visit[x][y]==<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            res.push_back(&#123;x,y&#125;);</span><br><span class="line">            visit[x][y]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> xx = x + direction[i][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> yy = y + direction[i][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> ( xx&gt;= <span class="number">0</span> &amp;&amp; xx &lt; R &amp;&amp; yy &gt;=<span class="number">0</span> &amp;&amp; yy &lt; C &amp;&amp; visit[xx][yy] == <span class="number">0</span>)&#123;</span><br><span class="line">                     qu.push(&#123;xx,yy&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>更新一种做法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">comp</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">2</span>] &lt; b[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; allCellsDistOrder(<span class="keyword">int</span> R, <span class="keyword">int</span> C, <span class="keyword">int</span> r0, <span class="keyword">int</span> c0) &#123;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; v(R*C, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">3</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; R; i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; C; j ++) &#123;</span><br><span class="line">                v[k][<span class="number">0</span>] = i;</span><br><span class="line">                v[k][<span class="number">1</span>] = j;</span><br><span class="line">                v[k][<span class="number">2</span>] = <span class="built_in">abs</span>(i - r0) + <span class="built_in">abs</span>(j - c0);</span><br><span class="line">                k ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(v.begin(), v.end(), comp);</span><br><span class="line">	        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> kk = <span class="number">0</span>; kk &lt; R*C; kk ++) &#123;</span><br><span class="line">            v[kk].pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1031-Maximum-Sum-of-Two-Non-Overlapping-Subarrays"><a href="#Leetcode1031-Maximum-Sum-of-Two-Non-Overlapping-Subarrays" class="headerlink" title="Leetcode1031. Maximum Sum of Two Non-Overlapping Subarrays"></a>Leetcode1031. Maximum Sum of Two Non-Overlapping Subarrays</h1><p>Given an integer array nums and two integers firstLen and secondLen, return the maximum sum of elements in two non-overlapping subarrays with lengths firstLen and secondLen.</p>
<p>The array with length firstLen could occur before or after the array with length secondLen, but they have to be non-overlapping.</p>
<p>A subarray is a contiguous part of an array.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [0,6,5,2,2,5,1,9,4], firstLen = 1, secondLen = 2</span><br><span class="line">Output: 20</span><br><span class="line">Explanation: One choice of subarrays is [9] with length 1, and [6,5] with length 2.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [3,8,1,3,2,1,8,9,0], firstLen = 3, secondLen = 2</span><br><span class="line">Output: 29</span><br><span class="line">Explanation: One choice of subarrays is [3,8,1] with length 3, and [8,9] with length 2.</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [2,1,5,6,0,9,5,0,3,8], firstLen = 4, secondLen = 3</span><br><span class="line">Output: 31</span><br><span class="line">Explanation: One choice of subarrays is [5,6,0,9] with length 4, and [3,8] with length 3.</span><br></pre></td></tr></table></figure></p>
<p>题意：给你一个数组，再给你一个L，M，求在这个数组里面，两个不重合的长度分别为L，M的最的最大和。</p>
<p>思路：先预处理一个<code>dp[i][2]</code>，<code>dp[i][0]</code>表示以i为开头，长度为L的值；<code>dp[i][1]</code>表示以i为开头，长度为M的值。再两层for，遍历i，j分别表示两个数组的头，只要两个数组不重合，就是合适的数组。最后求个最大值就好了。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSumTwoNoOverlap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> l, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size(), res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sum(n, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; l &amp;&amp; i+j &lt; n; j ++)</span><br><span class="line">                dp[i][<span class="number">0</span>] += nums[i+j];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m &amp;&amp; i+j &lt; n; j ++)</span><br><span class="line">                dp[i][<span class="number">1</span>] += nums[i+j];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j ++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i + l &lt;= j)</span><br><span class="line">                    res = max(res, dp[i][<span class="number">0</span>]+dp[j][<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">if</span> (j + m &lt;= i)</span><br><span class="line">                    res = max(res, dp[i][<span class="number">0</span>]+dp[j][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这道题给了一个非负数组A，还有两个长度L和M，说是要分别找出不重叠且长度分别为L和M的两个子数组，前后顺序无所谓，问两个子数组最大的数字之和是多少。来看论坛上的高分解法吧，首先建立累加和数组，这里可以直接覆盖A数组，然后定义<code>Lmax</code>为在最后M个数字之前的长度为L的子数组的最大数字之和，同理，<code>Mmax</code>表示在最后L个数字之前的长度为M的子数组的最大数字之和。结果<code>res</code>初始化为前 L+M 个数字之和，然后遍历数组，从 L+M 开始遍历，先更新<code>Lmax</code>和<code>Mmax</code>，其中<code>Lmax</code>用<code>A[i - M] - A[i - M - L]</code>来更新，<code>Mmax</code>用<code>A[i - L] - A[i - M - L]</code>来更新。然后取<code>Lmax + A[i] - A[i - M]</code>和<code>Mmax + A[i] - A[i - L]</code>之间的较大值来更新结果 res 即可，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSumTwoNoOverlap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> L, <span class="keyword">int</span> M)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; A.size(); ++i) &#123;</span><br><span class="line">            A[i] += A[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = A[L + M - <span class="number">1</span>], Lmax = A[L - <span class="number">1</span>], Mmax = A[M - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = L + M; i &lt; A.size(); ++i) &#123;</span><br><span class="line">            Lmax = max(Lmax, A[i - M] - A[i - M - L]);</span><br><span class="line">            Mmax = max(Mmax, A[i - L] - A[i - M - L]);</span><br><span class="line">            res = max(res, max(Lmax + A[i] - A[i - M], Mmax + A[i] - A[i - L]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1033-Moving-Stones-Until-Consecutive"><a href="#Leetcode1033-Moving-Stones-Until-Consecutive" class="headerlink" title="Leetcode1033. Moving Stones Until Consecutive"></a>Leetcode1033. Moving Stones Until Consecutive</h1><p>Three stones are on a number line at positions a, b, and c. Each turn, you pick up a stone at an endpoint (ie., either the lowest or highest position stone), and move it to an unoccupied position between those endpoints.  Formally, let’s say the stones are currently at positions x, y, z with x &lt; y &lt; z.  You pick up the stone at either position x or position z, and move that stone to an integer position k, with x &lt; k &lt; z and k != y. The game ends when you cannot make any more moves, ie. the stones are in consecutive positions.</p>
<p>When the game ends, what is the minimum and maximum number of moves that you could have made?  Return the answer as an length 2 array: answer = [minimum_moves, maximum_moves]</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: a = 1, b = 2, c = 5</span><br><span class="line">Output: [1,2]</span><br><span class="line">Explanation: Move the stone from 5 to 3, or move the stone from 5 to 4 to 3.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: a = 4, b = 3, c = 2</span><br><span class="line">Output: [0,0]</span><br><span class="line">Explanation: We cannot make any moves.</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: a = 3, b = 5, c = 1</span><br><span class="line">Output: [1,2]</span><br><span class="line">Explanation: Move the stone from 1 to 4; or move the stone from 1 to 2 to 4.</span><br></pre></td></tr></table></figure></p>
<p>a,b,c表示三个位置，在三个位置上各有一个石头。现在要移动三个石头中的若干个，每次移动都必须选两端石头的里面的位置，最终使得它们三个放在连续的位置。问最少需要多少次移动，最多需要多少次移动。</p>
<p>如果三个石头本来就连续，则不用移动。例：1，2，3</p>
<p>如果三个石头本来不连续，则：<br>最少移动次数：</p>
<ol>
<li>有两个石头之间的距离小于等于2，则最少只需要一次移动。例：1，2，4，把4移动到3即可；或者例1，3，5，把5移到2即可。</li>
<li>所有石头之间的最小距离&gt;2，则最少需要移动两个石头。例：1，4，7，需要把两个石头移动到另一个的旁边。</li>
</ol>
<p>最多移动次数：<br>题目说了，只能像两端石头里面的那些位置上放，所以最多移动的次数就是本来两端石头中间包含的点（并且去掉中间的石头），策略是每次向内移动一步。例：1，3，5，在1和5中间之间共有2个可以放的点（分别为2，4），所以最多只能有max_ - min_ - 2次移动。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numMovesStones(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum_ = a + b + c;</span><br><span class="line">        <span class="keyword">int</span> min_ = min(a, min(b, c));</span><br><span class="line">        <span class="keyword">int</span> max_ = max(a, max(b, c));</span><br><span class="line">        <span class="keyword">int</span> mid_ = sum_ - min_ - max_;</span><br><span class="line">	        </span><br><span class="line">        <span class="keyword">if</span> (max_ - min_ == <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">	        </span><br><span class="line">        <span class="keyword">int</span> min_move = min(mid_ - min_, max_ - mid_) &lt;= <span class="number">2</span> ? <span class="number">1</span> : <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> max_move = max_ - min_ - <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> &#123;min_move, max_move&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode1034-Coloring-A-Border"><a href="#Leetcode1034-Coloring-A-Border" class="headerlink" title="Leetcode1034. Coloring A Border"></a>Leetcode1034. Coloring A Border</h1><p>Given a 2-dimensional grid of integers, each value in the grid represents the color of the grid square at that location.</p>
<p>Two squares belong to the same  connected component  if and only if they have the same color and are next to each other in any of the 4 directions.</p>
<p>The  border  of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).</p>
<p>Given a square at location (r0, c0) in the grid and a color, color the border of the connected component of that square with the given color, and return the final grid.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: grid = [[1,1],[1,2]], r0 = 0, c0 = 0, color = 3</span><br><span class="line">Output: [[3, 3], [3, 2]]</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: grid = [[1,2,2],[2,3,2]], r0 = 0, c0 = 1, color = 3</span><br><span class="line">Output: [[1, 3, 3], [2, 3, 3]]</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: grid = [[1,1,1],[1,1,1],[1,1,1]], r0 = 1, c0 = 1, color = 2</span><br><span class="line">Output: [[2, 2, 2], [2, 1, 2], [2, 2, 2]]</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>1 &lt;= grid.length &lt;= 50</li>
<li>1 &lt;= grid[0].length &lt;= 50</li>
<li>1 &lt;= grid[i][j] &lt;= 1000</li>
<li>0 &lt;= r0 &lt; grid.length</li>
<li>0 &lt;= c0 &lt; grid[0].length</li>
<li>1 &lt;= color &lt;= 1000</li>
</ul>
<p>这道题给了一个二维数组 grid，和一个起始位置 (r0, c0)，格子里的数字代表不同的颜色，又给了一个新的颜色 color，现在让给起始位置所在的连通区域的边缘填充这种新的颜色。这道题的难点就是如何找出连通区域的边缘，找连通区域并不难，因为有了起始点，可以用 DFS 或者 BFS 来找出所有相连的位置，而边缘位置需要进一步判断，一种情况是当前位置是二维矩阵的边缘，那么其一定也是连通区域的边缘，另一种情况是若四个相邻位置有其他的颜色，则当前位置也一定是边缘。下面先来看 BFS 的解法，主体还是经典的 BFS 写法不变，使用队列 queue，和一个 TreeSet 来记录已经遍历过的位置。将起始位置先放入 queue 和 visited 集合，然后进行 while 循环，取出队首元素，然后判断当前位置是否是二维数组的边缘，是的话直接将颜色更新 color。然后遍历周围四个位置，若越界了或者访问过了直接跳过，然后看若颜色和起始位置的颜色相同，则加入 visited 和 queue，否则将当前位置的颜色更新为 color，因为周围有不同的颜色了，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; colorBorder(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> color) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.size(), n = grid[<span class="number">0</span>].size(), ori_color = grid[row][col];</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; visited(m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dirs&#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;&#125;  ;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        q.push(row*n + col);</span><br><span class="line">        visited[row][col] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = q.front() / n;</span><br><span class="line">            <span class="keyword">int</span> y = q.front() % n;</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span> (x == <span class="number">0</span> || x == m<span class="number">-1</span> || y == <span class="number">0</span> || y == n<span class="number">-1</span>)</span><br><span class="line">                grid[x][y] = color;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++) &#123;</span><br><span class="line">                <span class="keyword">int</span> xx = x + dirs[i][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> yy = y + dirs[i][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (xx &lt; <span class="number">0</span> || xx &gt;= m || yy &lt; <span class="number">0</span> || yy &gt;= n || visited[xx][yy] == <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (grid[xx][yy] == ori_color) &#123;</span><br><span class="line">                    q.push(xx * n + yy);</span><br><span class="line">                    visited[xx][yy] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    grid[x][y] = color;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> grid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1035-Uncrossed-Lines"><a href="#Leetcode1035-Uncrossed-Lines" class="headerlink" title="Leetcode1035. Uncrossed Lines"></a>Leetcode1035. Uncrossed Lines</h1><p>We write the integers of A and B (in the order they are given) on two separate horizontal lines.</p>
<p>Now, we may draw  connecting lines : a straight line connecting two numbers A[i] and B[j] such that:<code>A[i] == B[j];</code></p>
<p>The line we draw does not intersect any other connecting (non-horizontal) line.</p>
<p>Note that a connecting lines cannot intersect even at the endpoints: each number can only belong to one connecting line.</p>
<p>Return the maximum number of connecting lines we can draw in this way.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [1,4,2], B = [1,2,4]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: We can draw 2 uncrossed lines as in the diagram.</span><br><span class="line">We cannot draw 3 uncrossed lines, because the line from A[1]=4 to B[2]=4 will intersect the line from A[2]=2 to B[1]=2.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [2,5,1,2,5], B = [10,5,2,1,5,2]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [1,3,7,1,7,5], B = [1,9,2,5,1]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>1 &lt;= A.length &lt;= 500</li>
<li>1 &lt;= B.length &lt;= 500</li>
<li>1 &lt;= A[i], B[i] &lt;= 2000</li>
</ul>
<p>这道题给了A和B两个数字数组，并且上下并列排放，说是可以用线来连接相同的数字，问最多能连多少根线而且不会发生重叠。首先来想一下，什么情况下两条连线会相交，可以观察下例子1给的图，发现若把4和2分别连上会交叉，这是因为在A数组中是 4，2，而且在B数组中是 2，4，顺序不一样。再来看例子2，分别连 5，1，2 或者 2，1，2，或者 5，2，5 都是可以的，仔细观察，可以发现这些其实就是最长公共子序列 Longest Common Subsequence。使用一个二维数组<code>dp</code>，其中<code>dp[i][j]</code>表示数组A的前i个数字和数组B的前j个数字的最长相同的子序列的数字个数，这里大小初始化为 (m+1)x(n+1)，这里的m和n分别是数组A和数组B的长度。接下来就要找状态转移方程了，如何来更新<code>dp[i][j]</code>，若二者对应位置的字符相同，表示当前的 LCS 又增加了一位，所以可以用<code>dp[i-1][j-1] + 1</code>来更新<code>dp[i][j]</code>。否则若对应位置的字符不相同，由于是子序列，还可以错位比较，可以分别从数组A或者数组B去掉一个当前数字，那么其<code>dp</code>值就是<code>dp[i-1][j]</code>和<code>dp[i][j-1]</code>，取二者中的较大值来更新<code>dp[i][j]</code>即可，最终的结果保存在了<code>dp[m][n]</code>中，参见代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxUncrossedLines</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = A.size(), n = B.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (A[i - <span class="number">1</span>] == B[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1037-Valid-Boomerang"><a href="#Leetcode1037-Valid-Boomerang" class="headerlink" title="Leetcode1037. Valid Boomerang"></a>Leetcode1037. Valid Boomerang</h1><p>A boomerang is a set of 3 points that are all distinct and not in a straight line. Given a list of three points in the plane, return whether these points are a boomerang.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,1],[2,3],[3,2]]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,1],[2,2],[3,3]]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<p>points.length == 3<br>points[i].length == 2<br>0 &lt;=<code>points[i][j]</code>&lt;= 100</p>
<p>判断三个点是不是互异且不共线的，简单<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBoomerang</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;points.size();i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;points.size();j++)</span><br><span class="line">                <span class="keyword">if</span>(points[i][<span class="number">0</span>]==points[j][<span class="number">0</span>] &amp;&amp; points[i][<span class="number">1</span>]==points[j][<span class="number">1</span>])</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> dx1 = points[<span class="number">1</span>][<span class="number">0</span>] - points[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> dx2 = points[<span class="number">1</span>][<span class="number">1</span>] - points[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> dx3 = points[<span class="number">2</span>][<span class="number">0</span>] - points[<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> dx4 = points[<span class="number">2</span>][<span class="number">1</span>] - points[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(dx1*dx4-dx2*dx3==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1038-Binary-Search-Tree-to-Greater-Sum-Tree"><a href="#Leetcode1038-Binary-Search-Tree-to-Greater-Sum-Tree" class="headerlink" title="Leetcode1038. Binary Search Tree to Greater Sum Tree"></a>Leetcode1038. Binary Search Tree to Greater Sum Tree</h1><p>Given the root of a binary search tree with distinct values, modify it so that every node has a new value equal to the sum of the values of the original tree that are greater than or equal to node.val.</p>
<p>As a reminder, a binary search tree is a tree that satisfies these constraints:</p>
<p>The left subtree of a node contains only nodes with keys less than the node’s key.<br>The right subtree of a node contains only nodes with keys greater than the node’s key.<br>Both the left and right subtrees must also be binary search trees.</p>
<p>Example 1:</p>
<p><img src="/img/20190506tree.png" alt></p>
<p>Input: [4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]<br>Output: [30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]</p>
<p>典型的中序遍历，先遍历右子树，再把root赋值，最后看左子树</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">houxu</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right)</span><br><span class="line">            houxu(root-&gt;right);</span><br><span class="line">        sum+=root-&gt;val;</span><br><span class="line">        root-&gt;val = sum;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left)</span><br><span class="line">            houxu(root-&gt;left);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">bstToGst</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        houxu(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode1039-Minimum-Score-Triangulation-of-Polygon"><a href="#Leetcode1039-Minimum-Score-Triangulation-of-Polygon" class="headerlink" title="Leetcode1039. Minimum Score Triangulation of Polygon"></a>Leetcode1039. Minimum Score Triangulation of Polygon</h1><p>You have a convex n-sided polygon where each vertex has an integer value. You are given an integer array values where values[i] is the value of the ith vertex (i.e., clockwise order).</p>
<p>You will triangulate the polygon into n - 2 triangles. For each triangle, the value of that triangle is the product of the values of its vertices, and the total score of the triangulation is the sum of these values over all n - 2 triangles in the triangulation.</p>
<p>Return  the smallest possible total score that you can achieve with some triangulation of the polygon.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: values = [1,2,3]</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: The polygon is already triangulated, and the score of the only triangle is 6.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: values = [3,7,4,5]</span><br><span class="line">Output: 144</span><br><span class="line">Explanation: There are two triangulations, with possible scores: 3*7*5 + 4*5*7 = 245, or 3*4*5 + 3*4*7 = 144.</span><br><span class="line">The minimum score is 144.</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: values = [1,3,1,4,1,5]</span><br><span class="line">Output: 13</span><br><span class="line">Explanation: The minimum score triangulation has score 1*1*3 + 1*1*4 + 1*1*5 + 1*1*1 = 13.</span><br></pre></td></tr></table></figure></p>
<p>Constraints:</p>
<ul>
<li>n == values.length</li>
<li>3 &lt;= n &lt;= 50</li>
<li>1 &lt;= values[i] &lt;= 100</li>
</ul>
<p>这道题说有一个N边形，让我们连接不相邻的顶点，从而划分出三角形，最多可以划分出 N-2 个三角形，每划分出一个三角形，得分是三个顶点的乘积，问最小的得分是多少。首先要来定义 DP 数组，这里一维数组肯定是不够用的，因为需要保存区间信息，所以这里用个二维数组，其中<code>dp[i][j]</code>表示从顶点i到顶点j为三角形的一条边，可以组成的所有的三角形的最小得分。接下来推导状态转移方程，由于三角形的一条边已经确定了，接下来就要找另一个顶点的位置，这里需要遍历所有的情况，使用一个变量k，遍历区间 (i, j) 中的所有的顶点，由顶点i，j，和k组成的三角形的得分是<code>A[i] * A[k] * A[j]</code>可以直接算出来，这个三角形将整个区间分割成了两部分，分别是 (i, k) 和 (k, j)，这两个区间的最小得分值可以直接从 dp 数组中取得，分别是<code>dp[i][k]</code>和<code>dp[k][j]</code>，这样状态转移方程就有了，用<code>dp[i][k] + A[i] * A[k] * A[j] + dp[k][j]</code>来更新<code>dp[i][j]</code>，为了防止整型越界，不能直接将 dp 数组都初始化为整型最大值<code>INT_MAX</code>，而是在更新的时候，判断若<code>dp[i][j]</code>为0时，用<code>INT_MAX</code>，否则用其本身值，最终的结果保存在<code>dp[0][n-1]</code>中，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minScoreTriangulation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = i + <span class="number">1</span>; k &lt; j; ++k) &#123;</span><br><span class="line">                    dp[i][j] = min(dp[i][j] == <span class="number">0</span> ? INT_MAX : dp[i][j], dp[i][k] + A[i] * A[k] * A[j] + dp[k][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>再来看一种同样的 DP 解法，和上面的区别是 dp 数组更新的顺序不同，之前说过了更新大区间的 dp 值需要用到小区间的 dp 值，这里是按照区间的大小来更新的，从2更新到n，然后确定区间 (i, j) 的大小为 len，再遍历中间所有的k，状态转移方程还是跟上面一样的。这种更新方法在其他的题目也有用到，最典型的就是那道 Burst Balloons，参见代码如下：</p>
<p>解法二：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minScoreTriangulation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">2</span>; len &lt; n; ++len) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i + len &lt; n; ++i) &#123;</span><br><span class="line">                <span class="keyword">int</span> j = i + len;</span><br><span class="line">                dp[i][j] = INT_MAX;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = i + <span class="number">1</span>; k &lt; j; ++k) &#123;</span><br><span class="line">                    dp[i][j] = min(dp[i][j], dp[i][k] + A[i] * A[k] * A[j] + dp[k][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1041-Robot-Bounded-In-Circle"><a href="#Leetcode1041-Robot-Bounded-In-Circle" class="headerlink" title="Leetcode1041. Robot Bounded In Circle"></a>Leetcode1041. Robot Bounded In Circle</h1><p>On an infinite plane, a robot initially stands at (0, 0) and faces north. The robot can receive one of three instructions:</p>
<ul>
<li>“G”: go straight 1 unit;</li>
<li>“L”: turn 90 degrees to the left;</li>
<li>“R”: turn 90 degrees to the right.</li>
</ul>
<p>The robot performs the instructions given in order, and repeats them forever.</p>
<p>Return true if and only if there exists a circle in the plane such that the robot never leaves the circle.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: instructions = &quot;GGLLGG&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: The robot moves from (0,0) to (0,2), turns 180 degrees, and then returns to (0,0).</span><br><span class="line">When repeating these instructions, the robot remains in the circle of radius 2 centered at the origin.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: instructions = &quot;GG&quot;</span><br><span class="line">Output: false</span><br><span class="line">Explanation: The robot moves north indefinitely.</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: instructions = &quot;GL&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: The robot moves from (0, 0) -&gt; (0, 1) -&gt; (-1, 1) -&gt; (-1, 0) -&gt; (0, 0) -&gt; ...</span><br></pre></td></tr></table></figure></p>
<p>Constraints:</p>
<ul>
<li>1 &lt;= instructions.length &lt;= 100</li>
<li>instructions[i] is ‘G’, ‘L’ or, ‘R’.</li>
</ul>
<p>这道题说是在一个无限大的区域，有个机器人初始化站在原点 (0, 0) 的位置，面朝北方。该机器人有三种指令可以执行，G表示朝当前方向前进一步，L表示向左转 90 度，R表示向右转 90 度，现在给了一些连续的这样的指令，若一直重复的按顺序循环执行下去，问机器人是否会在一个固定的圆圈路径中循环。首先我们需要执行一遍所有的指令，然后根据最后的状态（包括位置和朝向）来分析机器人是否之后会一直走循环路线。若执行过一遍所有指令之后机器人还在原点上，则一定是在一个圆圈路径上（即便是机器人可能就没移动过，一个点也可以看作是圆圈路径）。若机器人偏离了起始位置，只要看此时机器人的朝向，只要不是向北，则其最终一定会回到起点。</p>
<p>知道了最终状态和循环路径的关系，现在就是如何执行这些指令了。也不难，用一个变量表示当前的方向，0表示北，1为东，2为南，3为西，按这个顺序写出偏移量数组 dirs，就是在迷宫遍历的时候经常用到的那个数组。然后记录当前位置 cur，初始化为 (0, 0)，然后就可以执行指令了，若遇到G指令，根据 idx 从 dirs 数组中取出偏移量加到 cur 上即可。若遇到L指令，idx 是要减1的，为了避免负数，先加上个4，再减1，再对4取余。同理，若遇到R指令，idx 加1之后对4取余。最后判断若还在原点，或者朝向不为北的时候，返回 true 即可，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isRobotBounded</span><span class="params">(<span class="built_in">string</span> instructions)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dirs&#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span> xx = <span class="number">0</span>, yy = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> direction = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; instructions.size(); i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (instructions[i] == <span class="string">'G'</span>) &#123;</span><br><span class="line">                xx += dirs[direction][<span class="number">0</span>];</span><br><span class="line">                yy += dirs[direction][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (instructions[i] == <span class="string">'L'</span>)</span><br><span class="line">                direction = (direction + <span class="number">1</span> ) % <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (instructions[i] == <span class="string">'R'</span>)</span><br><span class="line">                direction = (direction + <span class="number">4</span> - <span class="number">1</span>) % <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (xx == <span class="number">0</span> &amp;&amp; yy == <span class="number">0</span>) || direction != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1042-Flower-Planting-With-No-Adjacent"><a href="#Leetcode1042-Flower-Planting-With-No-Adjacent" class="headerlink" title="Leetcode1042. Flower Planting With No Adjacent"></a>Leetcode1042. Flower Planting With No Adjacent</h1><p>You have N gardens, labelled 1 to N.  In each garden, you want to plant one of 4 types of flowers. paths[i] = [x, y] describes the existence of a bidirectional path from garden x to garden y. Also, there is no garden that has more than 3 paths coming into or leaving it.</p>
<p>Your task is to choose a flower type for each garden such that, for any two gardens connected by a path, they have different types of flowers.</p>
<p>Return any such a choice as an array answer, where answer[i] is the type of flower planted in the (i+1)-th garden.  The flower types are denoted 1, 2, 3, or 4.  It is guaranteed an answer exists.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: N = 3, paths = [[1,2],[2,3],[3,1]]</span><br><span class="line">Output: [1,2,3]</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: N = 4, paths = [[1,2],[3,4]]</span><br><span class="line">Output: [1,2,1,2]</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: N = 4, paths = [[1,2],[2,3],[3,4],[4,1],[1,3],[2,4]]</span><br><span class="line">Output: [1,2,3,4]</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>1 &lt;= N &lt;= 10000</li>
<li>0 &lt;= paths.size &lt;= 20000</li>
<li>No garden has 4 or more paths coming into or leaving it.</li>
<li>It is guaranteed an answer exists.</li>
</ul>
<p>有 N 个花园，按从 1 到 N 标记。在每个花园中，你打算种下四种花之一。 paths[i] = [x, y] 描述了花园 x 到花园 y 的双向路径。另外，没有花园有 3 条以上的路径可以进入或者离开。你需要为每个花园选择一种花，使得通过路径相连的任何两个花园中的花的种类互不相同。以数组形式返回选择的方案作为答案 answer，其中 answer[i] 为在第 (i+1) 个花园中种植的花的种类。花的种类用  1, 2, 3, 4 表示。保证存在答案。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; gardenNoAdj(<span class="keyword">int</span> N, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; paths) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(N, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; graph(N);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; paths.size(); i ++) &#123;</span><br><span class="line">            graph[paths[i][<span class="number">0</span>]<span class="number">-1</span>].push_back(paths[i][<span class="number">1</span>]<span class="number">-1</span>);</span><br><span class="line">            graph[paths[i][<span class="number">1</span>]<span class="number">-1</span>].push_back(paths[i][<span class="number">0</span>]<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;      </span><br><span class="line">            <span class="keyword">int</span> mask = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; j : graph[i])</span><br><span class="line">                mask |= (<span class="number">1</span> &lt;&lt; res[j]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">1</span>; c &lt;= <span class="number">4</span> &amp;&amp; res[i] == <span class="number">0</span>; ++c)</span><br><span class="line">                <span class="keyword">if</span> (!(mask &amp; (<span class="number">1</span> &lt;&lt; c))) res[i] = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1043-Partition-Array-for-Maximum-Sum"><a href="#Leetcode1043-Partition-Array-for-Maximum-Sum" class="headerlink" title="Leetcode1043. Partition Array for Maximum Sum"></a>Leetcode1043. Partition Array for Maximum Sum</h1><p>Given an integer array arr, you should partition the array into (contiguous) subarrays of length at most k. After partitioning, each subarray has their values changed to become the maximum value of that subarray.</p>
<p>Return  the largest sum of the given array after partitioning.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: arr = [1,15,7,9,2,5,10], k = 3</span><br><span class="line">Output: 84</span><br><span class="line">Explanation: arr becomes [15,15,15,9,10,10,10]</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: arr = [1,4,1,5,7,3,6,1,9,9,3], k = 4</span><br><span class="line">Output: 83</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: arr = [1], k = 1</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure></p>
<p>Constraints:</p>
<ul>
<li>1 &lt;= arr.length &lt;= 500</li>
<li>0 &lt;= arr[i] &lt;= 109</li>
<li>1 &lt;= k &lt;= arr.length</li>
</ul>
<p>这道题给了一个数组 arr，和一个正整数k，说是将数组分成若干个长度不超过k的子数组，分割后的子数组所有的数字都变成该子数组中的最大值，让求分割后的所有子数组数字之和。由于分割的子数组长度不固定，用暴力搜索的话将会有很多很多种情况，不出意外的话会超时。对于这种玩子数组，又是求极值的题，刷题老司机们应该立马就能想到用动态规划 Dynamic Programming 来做。先来定义 dp 数组，先从最简单的考虑，使用一个一维的 dp 数组，其中<code>dp[i]</code>就表示分割数组中的前i个数字组成的数组可以得到的最大的数字之和。下面来考虑状态转移方程怎么求，对于<code>dp[i]</code>来说，若把最后k个数字分割出来，那么前i个数字就被分成了两个部分，前 i-k 个数字，其数字之和可以直接由<code>dp[i-k]</code>来取得，后面的k个数字，则需要求出其中最大的数字，然后乘以k，用这两部分之和来更新<code>dp[i]</code>即可。由于题目中说了分割的长度不超过k，那么就是说小于k的也是可以的，则需要遍历 [1, k] 区间所有的长度，均进行分割。接下来看代码，建立一个大小为 n+1 的 dp 数组，然后i从1遍历到n，此时新建一个变量 curMax 记录当前的最大值，然后用j从1遍历到k，同时要保证 i-j 是大于等于0的，因为需要前半部分存在，实际上这是从第i个数字开始往前找j个数字，然后记录其中最大的数字 curMax，并且不断用<code>dp[i-j] + curMax * j</code>来更新<code>dp[i]</code>即可，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSumAfterPartitioning</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> curMax = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k &amp;&amp; i - j &gt;= <span class="number">0</span>; ++j) &#123;</span><br><span class="line">                curMax = max(curMax, arr[i - j]);</span><br><span class="line">                dp[i] = max(dp[i], dp[i - j] + curMax * j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1046-Last-Stone-Weight"><a href="#Leetcode1046-Last-Stone-Weight" class="headerlink" title="Leetcode1046. Last Stone Weight"></a>Leetcode1046. Last Stone Weight</h1><p>We have a collection of stones, each stone has a positive integer weight.</p>
<p>Each turn, we choose the two heaviest stones and smash them together.  Suppose the stones have weights x and y with x &lt;= y.  The result of this smash is:</p>
<ul>
<li>If x == y, both stones are totally destroyed;</li>
<li>If x != y, the stone of weight x is totally destroyed, and the stone of weight y has new weight y-x.</li>
<li>At the end, there is at most 1 stone left.  Return the weight of this stone (or 0 if there are no stones left.)</li>
</ul>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,7,4,1,8,1]</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: </span><br><span class="line">We combine 7 and 8 to get 1 so the array converts to [2,4,1,1,1] then,</span><br><span class="line">we combine 2 and 4 to get 2 so the array converts to [2,1,1,1] then,</span><br><span class="line">we combine 2 and 1 to get 1 so the array converts to [1,1,1] then,</span><br><span class="line">we combine 1 and 1 to get 0 so the array converts to [1] then that&apos;s the value of last stone.</span><br></pre></td></tr></table></figure></p>
<p>堆排序解法，主要是看看人家的堆排序怎么写。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lastStoneWeight</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p, q;</span><br><span class="line">        <span class="keyword">if</span>(stones.size() == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> stones[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">while</span>(stones.size() &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">            heapsort(stones);</span><br><span class="line">            p = stones.back(); stones.pop_back();</span><br><span class="line">            q = stones.back(); stones.pop_back();</span><br><span class="line">            <span class="keyword">int</span> diff = p - q;</span><br><span class="line">            <span class="keyword">if</span>(diff)    stones.push_back(diff);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(stones.empty())   </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> stones[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">heapsort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stones.size() &lt;= <span class="number">1</span>)  <span class="keyword">return</span>;</span><br><span class="line">        build_heap(stones);</span><br><span class="line">        <span class="keyword">int</span> heap_size = stones.size();</span><br><span class="line">        <span class="keyword">while</span>(heap_size &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">            swap(stones[<span class="number">0</span>], stones[heap_size - <span class="number">1</span>]);</span><br><span class="line">            heap_size --;</span><br><span class="line">            max_heapify(stones, <span class="number">0</span>, heap_size);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build_heap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=stones.size()/<span class="number">2</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            max_heapify(stones, i, stones.size());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">max_heapify</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; stones, <span class="keyword">int</span> i, <span class="keyword">int</span> heap_size)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> large = i;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">2</span>*i+<span class="number">1</span>&lt;heap_size &amp;&amp; stones[i]&lt;stones[<span class="number">2</span>*i+<span class="number">1</span>])  large = <span class="number">2</span>*i+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">2</span>*i+<span class="number">2</span>&lt;heap_size &amp;&amp; stones[large]&lt;stones[<span class="number">2</span>*i+<span class="number">2</span>])  large = <span class="number">2</span>*i+<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(large != i)&#123;</span><br><span class="line">            swap(stones[i], stones[large]);</span><br><span class="line">            max_heapify(stones, large, heap_size);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        temp = a; a = b; b = temp;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1047-Remove-All-Adjacent-Duplicates-In-String"><a href="#Leetcode1047-Remove-All-Adjacent-Duplicates-In-String" class="headerlink" title="Leetcode1047. Remove All Adjacent Duplicates In String"></a>Leetcode1047. Remove All Adjacent Duplicates In String</h1><p>Given a string S of lowercase letters, a duplicate removal consists of choosing two adjacent and equal letters, and removing them.</p>
<p>We repeatedly make duplicate removals on S until we no longer can.</p>
<p>Return the final string after all such duplicate removals have been made.  It is guaranteed the answer is unique.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;abbaca&quot;</span><br><span class="line">Output: &quot;ca&quot;</span><br><span class="line">Explanation: </span><br><span class="line">For example, in &quot;abbaca&quot; we could remove &quot;bb&quot; since the letters are adjacent and equal, and this is the only possible move.  The result of this move is that the string is &quot;aaca&quot;, of which only &quot;aa&quot; is possible, so the final string is &quot;ca&quot;.</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>1 &lt;= S.length &lt;= 20000</li>
<li>S consists only of English lowercase letters.</li>
</ul>
<p>借用了栈的思想，但是这么做会超内存。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=S.length()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!st.empty() &amp;&amp; st.top()==S[i])&#123;</span><br><span class="line">                st.pop();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                st.push(S[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">while</span>(!st.empty())&#123;</span><br><span class="line">            res = res + st.top();</span><br><span class="line">            st.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>借鉴了大佬的做法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> res = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span>&amp; c : S)</span><br><span class="line">        <span class="keyword">if</span> (res.size() &amp;&amp; c == res.back())</span><br><span class="line">            res.pop_back();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            res.push_back(c);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> a;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; c : S) </span><br><span class="line">            <span class="keyword">if</span> (a.size() &amp;&amp; a.back() == c) a.pop_back();</span><br><span class="line">            <span class="keyword">else</span> a.push_back(c);</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里a.size()是返回字符数量，a.back()返回最后一个字符，pop_back和push_back和vector一样了。</p>
<p>把我自己的超时的代码改了一下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res=<span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> S_len = S.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;S_len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>( len&gt;<span class="number">0</span> &amp;&amp; res[len<span class="number">-1</span>]==S[i])&#123;</span><br><span class="line">                res.pop_back();</span><br><span class="line">                len--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                res += S[i];</span><br><span class="line">                len++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1048-Longest-String-Chain"><a href="#Leetcode1048-Longest-String-Chain" class="headerlink" title="Leetcode1048. Longest String Chain"></a>Leetcode1048. Longest String Chain</h1><p>Given a list of words, each word consists of English lowercase letters.</p>
<p>Let’s say word1 is a predecessor of word2 if and only if we can add exactly one letter anywhere in word1 to make it equal to word2.  For example, “abc” is a predecessor of “abac”.</p>
<p>A <em>word chain </em>is a sequence of words [word_1, word_2, …, word_k] with k &gt;= 1, where word_1 is a predecessor of word_2, word_2 is a predecessor of word_3, and so on.</p>
<p>Return the longest possible length of a word chain with words chosen from the given list of words.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: words = [&quot;a&quot;,&quot;b&quot;,&quot;ba&quot;,&quot;bca&quot;,&quot;bda&quot;,&quot;bdca&quot;]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: One of the longest word chain is &quot;a&quot;,&quot;ba&quot;,&quot;bda&quot;,&quot;bdca&quot;.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: words = [&quot;xbc&quot;,&quot;pcxbcf&quot;,&quot;xb&quot;,&quot;cxbc&quot;,&quot;pcxbc&quot;]</span><br><span class="line">Output: 5</span><br></pre></td></tr></table></figure></p>
<p>Constraints:</p>
<ul>
<li>1 &lt;= words.length &lt;= 1000</li>
<li>1 &lt;= words[i].length &lt;= 16</li>
<li>words[i] only consists of English lowercase letters.</li>
</ul>
<p>这道题给了一个单词数组，定义了一种前任关系，说是假如在 word1 中任意位置加上一个字符，能变成 word2 的话，那么 word1 就是 word2 的前任，实际上 word1 就是 word2 的一个子序列。现在问在整个数组中最长的前任链有多长，暴力搜索的话会有很多种情况，会产生大量的重复计算，所以会超时。这种玩数组求极值的题十有八九都是用动态规划 Dynamic Programming 来做的，这道题其实跟之前那道 Longest Arithmetic Subsequence 求最长的等差数列的思路是很像的。首先来定义 dp 数组，这里用一个一维的数组就行了，其中 dp[i] 表示 [0, i] 区间的单词的最长的前任链。下面来推导状态转移方程，对于当前位置的单词，需要遍历前面所有的单词，这里需要先给单词按长度排个序，因为只有长度小1的单词才有可能是前任，所以只需要遍历之前所有长度正好小1的单词，若是前任关系，则用其 dp 值加1来更新当前 dp 值即可。判断前任关系可以放到一个子数组中来做，其实就是检测是否是子序列，没啥太大的难度，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestStrChain</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = words.size(), res = <span class="number">1</span>;</span><br><span class="line">        sort(words.begin(), words.end(), [](<span class="built_in">string</span>&amp; a, <span class="built_in">string</span> &amp;b)&#123;</span><br><span class="line">            <span class="keyword">return</span> a.size() &lt; b.size();</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (words[j].size() + <span class="number">1</span> &lt; words[i].size()) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (words[j].size() == words[i].size()) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (helper(words[j], words[i])) &#123;</span><br><span class="line">                    dp[i] = max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">                    res = max(res, dp[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(<span class="built_in">string</span> word1, <span class="built_in">string</span> word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = word1.size(), n = word2.size(), i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (word2[j] == word1[i]) ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i == m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>论坛上的高分解法在检验是否是前任时用了一种更好的方法，不是检测子序列，而是将当前的单词，按顺序每次去掉一个字符，然后看剩下的字符串是否在之前出现过，是的话就说明有前任，用其 dp 值加1来更新当前 dp 值，这是一种更巧妙且简便的方法。这里由于要快速判断前任是否存在，所以不是用的 dp 数组，而是用了个 HashMap，对于每个遍历到的单词，按顺序移除掉每个字符，若剩余的部分在 HashMap 中，则更新 dp 值和结果 res，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestStrChain</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = words.size(), res = <span class="number">1</span>;</span><br><span class="line">        sort(words.begin(), words.end(), [](<span class="built_in">string</span>&amp; a, <span class="built_in">string</span>&amp; b)&#123; <span class="keyword">return</span> a.size() &lt; b.size(); &#125;);</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; dp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">string</span> word : words) &#123;</span><br><span class="line">            dp[word] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.size(); ++i) &#123;</span><br><span class="line">                <span class="built_in">string</span> pre = word.substr(<span class="number">0</span>, i) + word.substr(i + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (dp.count(pre)) &#123;</span><br><span class="line">                    dp[word] = max(dp[word], dp[pre] + <span class="number">1</span>);</span><br><span class="line">                    res = max(res, dp[word]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode1049-Last-Stone-Weight-II"><a href="#Leetcode1049-Last-Stone-Weight-II" class="headerlink" title="Leetcode1049. Last Stone Weight II"></a>Leetcode1049. Last Stone Weight II</h1><p>You are given an array of integers stones where stones[i] is the weight of the ith stone.</p>
<p>We are playing a game with the stones. On each turn, we choose any two stones and smash them together. Suppose the stones have weights x and y with x &lt;= y. The result of this smash is:</p>
<p>If x == y, both stones are destroyed, and<br>If x != y, the stone of weight x is destroyed, and the stone of weight y has new weight y - x.<br>At the end of the game, there is at most one stone left.</p>
<p>Return  the smallest possible weight of the left stone. If there are no stones left, return 0.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: stones = [2,7,4,1,8,1]</span><br><span class="line">Output: 1</span><br><span class="line">Explanation:</span><br><span class="line">We can combine 2 and 4 to get 2, so the array converts to [2,7,1,8,1] then,</span><br><span class="line">we can combine 7 and 8 to get 1, so the array converts to [2,1,1,1] then,</span><br><span class="line">we can combine 2 and 1 to get 1, so the array converts to [1,1,1] then,</span><br><span class="line">we can combine 1 and 1 to get 0, so the array converts to [1], then that&apos;s the optimal value.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: stones = [31,26,33,21,40]</span><br><span class="line">Output: 5</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: stones = [1,2]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure></p>
<p>Constraints:</p>
<ul>
<li>1 &lt;= stones.length &lt;= 30</li>
<li>1 &lt;= stones[i] &lt;= 100</li>
</ul>
<p>这道题是之前那道 Last Stone Weight 的拓展，之前那道题说是每次取两个最大的进行碰撞，问最后剩下的重量。而这里是可以任意取两个石头进行碰撞，并且需要最后剩余的重量最小，这种玩数组求极值的题十有八九都是用动态规划 Dynamic Programming 来做的。首先来考虑 dp 数组该如何定义，若是直接用 dp[i] 来表示区间 [0, i] 内的石头碰撞后剩余的最小重量，状态转移方程将十分难推导，因为石子是任意选的，当前的 dp 值和之前的没有太大的联系。这里需要重新考虑 dp 数组的定义，这道题的解法其实挺难想的，需要转换一下思维，虽说是求碰撞后剩余的重量，但实际上可以看成是要将石子分为两堆，且尽可能让二者的重量之和最接近。若分为的两堆重量相等，则相互碰撞后最终将直接湮灭，剩余为0；若不相等，则剩余的重量就是两堆石子的重量之差。这道题给的数据范围是石子个数不超过 30 个，每个的重量不超过 100，这样的话总共的石子重量不超过 3000，分为两堆的话，每堆的重量不超过 1500。我们应该将 dp[i] 定义为数组中的石子是否能组成重量为i的一堆，数组大小设为 1501 即可，且 dp[0] 初始化为 true。这里的状态转移的思路跟之前那道 Coin Change 是很相似的，遍历每个石头，累加当前石头重量到 sum，然后从 1500 和 sum 中的较小值开始遍历（因为每堆的总重量不超过 1500），且i要大于 stone，小于当前石头的i不需要更新，由于当前的石头重量 stone 知道了，那么假如 i-stone 的 dp 值为 true 的话，则 dp[i] 也一定为 true。更新完成之后，从 sum/2 开始遍历，假如其 dp 值为 true，则用总重量 sum 减去当前重量的2倍，就是二堆石头重量的差值了，也就是碰撞后的剩余重量了，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lastStoneWeightII</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; dp(<span class="number">1501</span>);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> stone : stones) &#123;</span><br><span class="line">            sum += stone;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = min(<span class="number">1500</span>, sum); i &gt;= stone; --i) &#123;</span><br><span class="line">                dp[i] = dp[i] || dp[i - stone];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = sum / <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[i]) <span class="keyword">return</span> sum - <span class="number">2</span> * i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Leetcode/" rel="tag"># Leetcode</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/04/27/Leetcode1251_1300/" rel="next" title="Leetcode1251 - 1300">
                <i class="fa fa-chevron-left"></i> Leetcode1251 - 1300
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/04/29/Leetcode451_500/" rel="prev" title="Leetcode451 - 500">
                Leetcode451 - 500 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/header.jpg" alt="Hao Yu">
            
              <p class="site-author-name" itemprop="name">Hao Yu</p>
              <p class="site-description motion-element" itemprop="description">Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author</p>
          </div>
          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">289</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>
        	<audio controls="controls" loop="loop" preload="auto" src="/resource/xiaomeihao.mp3">
	        </audio>
	

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yuhao0102" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:yuh18@mails.tsinghua.edu.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1002-Find-Common-Characters"><span class="nav-number">1.</span> <span class="nav-text">Leetcode1002. Find Common Characters</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1003-Check-If-Word-Is-Valid-After-Substitutions"><span class="nav-number">2.</span> <span class="nav-text">Leetcode1003. Check If Word Is Valid After Substitutions</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1004-Max-Consecutive-Ones-III"><span class="nav-number">3.</span> <span class="nav-text">Leetcode1004. Max Consecutive Ones III</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1005-Maximize-Sum-Of-Array-After-K-Negations"><span class="nav-number">4.</span> <span class="nav-text">Leetcode1005. Maximize Sum Of Array After K Negations</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1006-Clumsy-Factorial"><span class="nav-number">5.</span> <span class="nav-text">Leetcode1006. Clumsy Factorial</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1007-Minimum-Domino-Rotations-For-Equal-Row"><span class="nav-number">6.</span> <span class="nav-text">Leetcode1007. Minimum Domino Rotations For Equal Row</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1008-Construct-Binary-Search-Tree-from-Preorder-Traversal"><span class="nav-number">7.</span> <span class="nav-text">Leetcode1008. Construct Binary Search Tree from Preorder Traversal</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1009-Complement-of-Base-10-Integer"><span class="nav-number">8.</span> <span class="nav-text">Leetcode1009. Complement of Base 10 Integer</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1010-Pairs-of-Songs-With-Total-Durations-Divisible-by-60"><span class="nav-number">9.</span> <span class="nav-text">Leetcode1010. Pairs of Songs With Total Durations Divisible by 60</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1011-Capacity-To-Ship-Packages-Within-D-Days"><span class="nav-number">10.</span> <span class="nav-text">Leetcode1011. Capacity To Ship Packages Within D Days</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1013-Partition-Array-Into-Three-Parts-With-Equal-Sum"><span class="nav-number">11.</span> <span class="nav-text">Leetcode1013. Partition Array Into Three Parts With Equal Sum</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1014-Best-Sightseeing-Pair"><span class="nav-number">12.</span> <span class="nav-text">Leetcode1014. Best Sightseeing Pair</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1015-Smallest-Integer-Divisible-by-K"><span class="nav-number">13.</span> <span class="nav-text">Leetcode1015. Smallest Integer Divisible by K</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1016-Binary-String-With-Substrings-Representing-1-To-N"><span class="nav-number">14.</span> <span class="nav-text">Leetcode1016. Binary String With Substrings Representing 1 To N</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1017-Convert-to-Base-2"><span class="nav-number">15.</span> <span class="nav-text">Leetcode1017. Convert to Base -2</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1018-Binary-Prefix-Divisible-By-5"><span class="nav-number">16.</span> <span class="nav-text">Leetcode1018. Binary Prefix Divisible By 5</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1019-Next-Greater-Node-In-Linked-List"><span class="nav-number">17.</span> <span class="nav-text">Leetcode1019. Next Greater Node In Linked List</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1020-Number-of-Enclaves"><span class="nav-number">18.</span> <span class="nav-text">Leetcode1020. Number of Enclaves</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1021-Remove-Outermost-Parentheses"><span class="nav-number">19.</span> <span class="nav-text">Leetcode1021. Remove Outermost Parentheses</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1022-Sum-of-Root-To-Leaf-Binary-Numbers"><span class="nav-number">20.</span> <span class="nav-text">Leetcode1022. Sum of Root To Leaf Binary Numbers</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1023-Camelcase-Matching"><span class="nav-number">21.</span> <span class="nav-text">Leetcode1023. Camelcase Matching</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1024-Video-Stitching"><span class="nav-number">22.</span> <span class="nav-text">Leetcode1024. Video Stitching</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1025-Divisor-Game"><span class="nav-number">23.</span> <span class="nav-text">Leetcode1025. Divisor Game</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1026-Maximum-Difference-Between-Node-and-Ancestor"><span class="nav-number">24.</span> <span class="nav-text">Leetcode1026. Maximum Difference Between Node and Ancestor</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1027-Longest-Arithmetic-Sequence"><span class="nav-number">25.</span> <span class="nav-text">Leetcode1027. Longest Arithmetic Sequence</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1028-Recover-a-Tree-From-Preorder-Traversal"><span class="nav-number">26.</span> <span class="nav-text">Leetcode1028. Recover a Tree From Preorder Traversal</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1029-Two-City-Scheduling"><span class="nav-number">27.</span> <span class="nav-text">Leetcode1029. Two City Scheduling</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1030-Matrix-Cells-in-Distance-Order"><span class="nav-number">28.</span> <span class="nav-text">Leetcode1030. Matrix Cells in Distance Order</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1031-Maximum-Sum-of-Two-Non-Overlapping-Subarrays"><span class="nav-number">29.</span> <span class="nav-text">Leetcode1031. Maximum Sum of Two Non-Overlapping Subarrays</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1033-Moving-Stones-Until-Consecutive"><span class="nav-number">30.</span> <span class="nav-text">Leetcode1033. Moving Stones Until Consecutive</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1034-Coloring-A-Border"><span class="nav-number">31.</span> <span class="nav-text">Leetcode1034. Coloring A Border</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1035-Uncrossed-Lines"><span class="nav-number">32.</span> <span class="nav-text">Leetcode1035. Uncrossed Lines</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1037-Valid-Boomerang"><span class="nav-number">33.</span> <span class="nav-text">Leetcode1037. Valid Boomerang</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1038-Binary-Search-Tree-to-Greater-Sum-Tree"><span class="nav-number">34.</span> <span class="nav-text">Leetcode1038. Binary Search Tree to Greater Sum Tree</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1039-Minimum-Score-Triangulation-of-Polygon"><span class="nav-number">35.</span> <span class="nav-text">Leetcode1039. Minimum Score Triangulation of Polygon</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1041-Robot-Bounded-In-Circle"><span class="nav-number">36.</span> <span class="nav-text">Leetcode1041. Robot Bounded In Circle</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1042-Flower-Planting-With-No-Adjacent"><span class="nav-number">37.</span> <span class="nav-text">Leetcode1042. Flower Planting With No Adjacent</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1043-Partition-Array-for-Maximum-Sum"><span class="nav-number">38.</span> <span class="nav-text">Leetcode1043. Partition Array for Maximum Sum</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1046-Last-Stone-Weight"><span class="nav-number">39.</span> <span class="nav-text">Leetcode1046. Last Stone Weight</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1047-Remove-All-Adjacent-Duplicates-In-String"><span class="nav-number">40.</span> <span class="nav-text">Leetcode1047. Remove All Adjacent Duplicates In String</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1048-Longest-String-Chain"><span class="nav-number">41.</span> <span class="nav-text">Leetcode1048. Longest String Chain</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1049-Last-Stone-Weight-II"><span class="nav-number">42.</span> <span class="nav-text">Leetcode1049. Last Stone Weight II</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>
  <div id="DvelopmentTarget">     
  </div>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart" aria-hidden="false"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>

  
</div>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_uv"> 
  本站访客数<span id="busuanzi_value_site_uv"></span>人次
</span>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  


  

  


  <script type="text/javascript" src="/js/src/love.js"></script>

</body>
</html>
