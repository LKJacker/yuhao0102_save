<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zn-ch">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-center-simple.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Leetcode,">










<meta name="description" content="Leetcode451. Sort Characters By FrequencyGiven a string s, sort it in decreasing order based on the frequency of characters, and return the sorted string. Example 1:1234Input: s = &amp;quot;tree&amp;quot;Outp">
<meta name="keywords" content="Leetcode">
<meta property="og:type" content="article">
<meta property="og:title" content="Leetcode451 - 500">
<meta property="og:url" content="http://yoursite.com/2020/04/29/Leetcode451_500/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="Leetcode451. Sort Characters By FrequencyGiven a string s, sort it in decreasing order based on the frequency of characters, and return the sorted string. Example 1:1234Input: s = &amp;quot;tree&amp;quot;Outp">
<meta property="og:locale" content="zn-ch">
<meta property="og:image" content="http://yoursite.com/img/20200617105700.png">
<meta property="og:image" content="http://yoursite.com/img/20210710152100.jpg">
<meta property="og:updated_time" content="2021-07-11T06:52:25.720Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Leetcode451 - 500">
<meta name="twitter:description" content="Leetcode451. Sort Characters By FrequencyGiven a string s, sort it in decreasing order based on the frequency of characters, and return the sorted string. Example 1:1234Input: s = &amp;quot;tree&amp;quot;Outp">
<meta name="twitter:image" content="http://yoursite.com/img/20200617105700.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/04/29/Leetcode451_500/">





  <title>Leetcode451 - 500 | Hao Yu's blog</title>
  








 
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zn-ch">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hao Yu's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">The program monkey was eaten by the siege lion.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/resume.pdf" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-mybetterhalf">
          <a href="/mybetterhalf/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>
            
            mybetterhalf
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/29/Leetcode451_500/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Leetcode451 - 500</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-04-29T21:23:31+08:00">
                2020-04-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Leetcode451-Sort-Characters-By-Frequency"><a href="#Leetcode451-Sort-Characters-By-Frequency" class="headerlink" title="Leetcode451. Sort Characters By Frequency"></a>Leetcode451. Sort Characters By Frequency</h1><p>Given a string s, sort it in decreasing order based on the frequency of characters, and return the sorted string.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;tree&quot;</span><br><span class="line">Output: &quot;eert&quot;</span><br><span class="line">Explanation: &apos;e&apos; appears twice while &apos;r&apos; and &apos;t&apos; both appear once.</span><br><span class="line">So &apos;e&apos; must appear before both &apos;r&apos; and &apos;t&apos;. Therefore &quot;eetr&quot; is also a valid answer.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;cccaaa&quot;</span><br><span class="line">Output: &quot;aaaccc&quot;</span><br><span class="line">Explanation: Both &apos;c&apos; and &apos;a&apos; appear three times, so &quot;aaaccc&quot; is also a valid answer.</span><br><span class="line">Note that &quot;cacaca&quot; is incorrect, as the same characters must be together.</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;Aabb&quot;</span><br><span class="line">Output: &quot;bbAa&quot;</span><br><span class="line">Explanation: &quot;bbaA&quot; is also a valid answer, but &quot;Aabb&quot; is incorrect.</span><br><span class="line">Note that &apos;A&apos; and &apos;a&apos; are treated as two different characters.</span><br></pre></td></tr></table></figure></p>
<p>竟然还要区分大小写，还要排序，那map等结构就不能用了，直接用数组。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">comp</span><span class="params">(pair&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;&amp; a, pair&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.second &gt; b.second || a.second == b.second &amp;&amp; a.first &lt; b.first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">frequencySort</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s) </span><br><span class="line">            count[c] ++;</span><br><span class="line">        sort(s.begin(), s.end(), [&amp;](<span class="keyword">char</span> a, <span class="keyword">char</span> b)&#123;</span><br><span class="line">            <span class="keyword">return</span> count[a] &gt; count[b] || count[a] == count[b] &amp;&amp; a &lt; b;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode452-Minimum-Number-of-Arrows-to-Burst-Balloons"><a href="#Leetcode452-Minimum-Number-of-Arrows-to-Burst-Balloons" class="headerlink" title="Leetcode452. Minimum Number of Arrows to Burst Balloons"></a>Leetcode452. Minimum Number of Arrows to Burst Balloons</h1><p>There are some spherical balloons spread in two-dimensional space. For each balloon, provided input is the start and end coordinates of the horizontal diameter. Since it’s horizontal, y-coordinates don’t matter, and hence the x-coordinates of start and end of the diameter suffice. The start is always smaller than the end.</p>
<p>An arrow can be shot up exactly vertically from different points along the x-axis. A balloon with xstart and xend bursts by an arrow shot at x if xstart ≤ x ≤ xend. There is no limit to the number of arrows that can be shot. An arrow once shot keeps traveling up infinitely.</p>
<p>Given an array points where points[i] = [xstart, xend], return the minimum number of arrows that must be shot to burst all balloons.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: points = [[10,16],[2,8],[1,6],[7,12]]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: One way is to shoot one arrow for example at x = 6 (bursting the balloons [2,8] and [1,6]) and another arrow at x = 11 (bursting the other two balloons).</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: points = [[1,2],[3,4],[5,6],[7,8]]</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: points = [[1,2],[2,3],[3,4],[4,5]]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode452-Minimum-Number-of-Arrows-to-Burst-Balloons-1"><a href="#Leetcode452-Minimum-Number-of-Arrows-to-Burst-Balloons-1" class="headerlink" title="Leetcode452. Minimum Number of Arrows to Burst Balloons"></a>Leetcode452. Minimum Number of Arrows to Burst Balloons</h1><p>There are a number of spherical balloons spread in two-dimensional space. For each balloon, provided input is the start and end coordinates of the horizontal diameter. Since it’s horizontal, y-coordinates don’t matter and hence the x-coordinates of start and end of the diameter suffice. Start is always smaller than end. There will be at most 104 balloons.</p>
<p>An arrow can be shot up exactly vertically from different points along the x-axis. A balloon with xstart and xend bursts by an arrow shot at x if xstart ≤ x ≤ xend. There is no limit to the number of arrows that can be shot. An arrow once shot keeps travelling up infinitely. The problem is to find the minimum number of arrows that must be shot to burst all balloons.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: points = [[10,16],[2,8],[1,6],[7,12]]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: One way is to shoot one arrow for example at x = 6 (bursting the balloons [2,8] and [1,6]) and another arrow at x = 11 (bursting the other two balloons).</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: points = [[1,2],[3,4],[5,6],[7,8]]</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: points = [[1,2],[2,3],[3,4],[4,5]]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure></p>
<p>这道题给了我们一堆大小不等的气球，用区间范围来表示气球的大小，可能会有重叠区间。然后我们用最少的箭数来将所有的气球打爆。那么这道题是典型的用贪婪算法来做的题，因为局部最优解就等于全局最优解，我们首先给区间排序，我们不用特意去写排序比较函数，因为默认的对于pair的排序，就是按第一个数字升序排列，如果第一个数字相同，那么按第二个数字升序排列，这个就是我们需要的顺序，所以直接用即可。然后我们将res初始化为1，因为气球数量不为0，所以怎么也得先来一发啊，然后这一箭能覆盖的最远位置就是第一个气球的结束点，用变量end来表示。然后我们开始遍历剩下的气球，如果当前气球的开始点小于等于end，说明跟之前的气球有重合，之前那一箭也可以照顾到当前的气球，此时我们要更新end的位置，end更新为两个气球结束点之间较小的那个，这也是当前气球和之前气球的重合点，然后继续看后面的气球；如果某个气球的起始点大于end了，说明前面的箭无法覆盖到当前的气球，那么就得再来一发，既然又来了一发，那么我们此时就要把end设为当前气球的结束点了，这样贪婪算法遍历结束后就能得到最少的箭数了，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">comp</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMinArrowShots</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        sort(points.begin(), points.end(), comp);</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>, end = points[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; points.size(); i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (end &gt;= points[i][<span class="number">0</span>])</span><br><span class="line">                end = min(end, points[i][<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                res ++;</span><br><span class="line">                end = points[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode453-Minimum-Moves-to-Equal-Array-Elements"><a href="#Leetcode453-Minimum-Moves-to-Equal-Array-Elements" class="headerlink" title="Leetcode453. Minimum Moves to Equal Array Elements"></a>Leetcode453. Minimum Moves to Equal Array Elements</h1><p>Given a non-empty integer array of size n, find the minimum number of moves required to make all array elements equal, where a move is incrementing n - 1 elements by 1.</p>
<p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[1,2,3]</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">Only three moves are needed (remember each move increments two elements):</span><br><span class="line">	[1,2,3]  =&gt;  [2,3,3]  =&gt;  [3,4,3]  =&gt;  [4,4,4]</span><br></pre></td></tr></table></figure></p>
<p>这道题给了我们一个长度为n的数组，说是每次可以对 n-1 个数字同时加1，问最少需要多少次这样的操作才能让数组中所有的数字相等。那么想，为了快速的缩小差距，该选择哪些数字加1呢，不难看出每次需要给除了数组最大值的所有数字加1，这样能快速的到达平衡状态。但是这道题如果老老实实的每次找出最大值，然后给其他数字加1，再判断是否平衡，思路是正确，但是 OJ 不答应。正确的解法相当的巧妙，需要换一个角度来看问题，其实给 n-1 个数字加1，效果等同于给那个未被选中的数字减1，比如数组 [1，2，3]，给除去最大值的其他数字加1，变为 [2，3，3]，全体减1，并不影响数字间相对差异，变为 [1，2，2]，这个结果其实就是原始数组的最大值3自减1，那么问题也可能转化为，将所有数字都减小到最小值，这样难度就大大降低了，只要先找到最小值，然后累加每个数跟最小值之间的差值即可。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minMoves</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> minn = INT_MAX, res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : nums)</span><br><span class="line">            minn = min(minn, i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : nums) </span><br><span class="line">            res += (i - minn);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode454-4Sum-II"><a href="#Leetcode454-4Sum-II" class="headerlink" title="Leetcode454. 4Sum II"></a>Leetcode454. 4Sum II</h1><p>Given four integer arrays nums1, nums2, nums3, and nums4 all of length n, return the number of tuples (i, j, k, l) such that:</p>
<ul>
<li>0 &lt;= i, j, k, l &lt; n</li>
<li>nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0</li>
</ul>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure></p>
<p>Explanation: The two tuples are:</p>
<ol>
<li>(0, 0, 0, 1) -&gt; nums1[0] + nums2[0] + nums3[0] + nums4[1] = 1 + (-2) + (-1) + 2 = 0</li>
<li>(1, 1, 0, 0) -&gt; nums1[1] + nums2[1] + nums3[0] + nums4[0] = 2 + (-1) + (-1) + 0 = 0</li>
</ol>
<p>这道题是之前那道 4Sum 的延伸，让我们在四个数组中各取一个数字，使其和为0。如果把A和B的两两之和都求出来，在 HashMap 中建立两数之和跟其出现次数之间的映射，那么再遍历C和D中任意两个数之和，只要看哈希表存不存在这两数之和的相反数就行了。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fourSumCount</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums3, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums4)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums1.size();</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mab, mcd;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j ++) &#123;</span><br><span class="line">                mab[nums1[i]+nums2[j]] ++;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j ++) &#123;</span><br><span class="line">                res += mab[-nums3[i]-nums4[j]];</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>用两个 HashMap 分别记录 AB 和 CB 的两两之和出现次数，然后遍历其中一个 HashMap，并在另一个 HashMap 中找和的相反数出现的次数，更方便，但更慢。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fourSumCount</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums3, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums4)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums1.size();</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mab, mcd;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j ++) &#123;</span><br><span class="line">                mab[nums1[i]+nums2[j]] ++;</span><br><span class="line">                mcd[nums3[i]+nums4[j]] ++;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : mab)</span><br><span class="line">            res += (i.second * mcd[-i.first]);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fourSumCount</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums3, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums4)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; index1,index2,index3;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; index4;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; nums4.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            index1[nums1[i]]++;</span><br><span class="line">            index2[nums2[i]]++;</span><br><span class="line">            index3[nums3[i]]++;</span><br><span class="line">            index4[nums4[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; sums;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;&amp; it3 : index3)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;&amp; it4 : index4)</span><br><span class="line">                sums[it3.first+it4.first] += it3.second*it4.second;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it1 = index1.begin(); it1 != index1.end(); ++it1)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> it2 = index2.begin(); it2 != index2.end(); ++it2)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">long</span> t2 =  (<span class="keyword">long</span>) it1-&gt;first + (<span class="keyword">long</span>) it2-&gt;first;</span><br><span class="line">                <span class="keyword">int</span> ct2 =  it1-&gt;second * it2-&gt;second;</span><br><span class="line">                <span class="keyword">auto</span> pos = sums.find(-t2);</span><br><span class="line">                <span class="keyword">if</span> (pos == sums.end()) <span class="keyword">continue</span>;</span><br><span class="line">                count += pos-&gt;second*ct2;    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode455-Assign-Cookies"><a href="#Leetcode455-Assign-Cookies" class="headerlink" title="Leetcode455. Assign Cookies"></a>Leetcode455. Assign Cookies</h1><p>Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie. Each child i has a greed factor gi, which is the minimum size of a cookie that the child will be content with; and each cookie j has a size sj. If sj &gt;= gi, we can assign the cookie j to the child i, and the child i will be content. Your goal is to maximize the number of your content children and output the maximum number.</p>
<p>Note:<br>You may assume the greed factor is always positive.<br>You cannot assign more than one cookie to one child.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3], [1,1]</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: You have 3 children and 2 cookies. The greed factors of 3 children are 1, 2, 3. </span><br><span class="line">And even though you have 2 cookies, since their size is both 1, you could only make the child whose greed factor is 1 content.</span><br><span class="line">You need to output 1.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2], [1,2,3]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: You have 2 children and 3 cookies. The greed factors of 2 children are 1, 2. </span><br><span class="line">You have 3 cookies and their sizes are big enough to gratify all of the children, </span><br><span class="line">	You need to output 2.</span><br></pre></td></tr></table></figure></p>
<p>有一堆饼干和一堆孩子，每个饼干大小为s[j]，每个孩子想要的大小为g[i]，求这堆饼干能满足至多多少个孩子？<br>很容易想到，每个孩子尽量拿到和他想要的大小差距最小的饼干，就能保证不会“浪费”大块饼干。因此把g和s排序后，把最相邻的饼干分给刚刚好满足的孩子，就能得到最大的满足数量了。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findContentChildren</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; g, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        sort(g.begin(), g.end());</span><br><span class="line">        sort(s.begin(), s.end());</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; g.size() &amp;&amp; j &lt; s.size(); j ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[j] &gt;= g[i]) &#123;</span><br><span class="line">                count ++;</span><br><span class="line">                i ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode456-132-Pattern"><a href="#Leetcode456-132-Pattern" class="headerlink" title="Leetcode456. 132 Pattern"></a>Leetcode456. 132 Pattern</h1><p>Given an array of n integers nums, a 132 pattern is a subsequence of three integers nums[i], nums[j] and nums[k] such that i &lt; j &lt; k and nums[i] &lt; nums[k] &lt; nums[j].</p>
<p>Return true if there is a 132 pattern in nums, otherwise, return false.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,2,3,4]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: There is no 132 pattern in the sequence.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [3,1,4,2]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: There is a 132 pattern in the sequence: [1, 4, 2].</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [-1,3,2,0]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: There are three 132 patterns in the sequence: [-1, 3, 2], [-1, 3, 0] and [-1, 2, 0].</span><br></pre></td></tr></table></figure></p>
<p>思路是维护一个栈和一个变量 third，其中 third 就是第三个数字，也是 pattern 132 中的2，初始化为整型最小值，栈里面按顺序放所有大于 third 的数字，也是 pattern 132 中的3，那么在遍历的时候，如果当前数字小于 third，即 pattern 132 中的1找到了，直接返回 true 即可，因为已经找到了，注意应该从后往前遍历数组。如果当前数字大于栈顶元素，那么将栈顶数字取出，赋值给 third，然后将该数字压入栈，这样保证了栈里的元素仍然都是大于 third 的，想要的顺序依旧存在，进一步来说，栈里存放的都是可以维持坐标 second &gt; third 的 second 值，其中的任何一个值都是大于当前的 third 值，如果有更大的值进来，那就等于形成了一个更优的 second &gt; third 的这样一个组合，并且这时弹出的 third 值比以前的 third 值更大，为什么要保证 third 值更大，因为这样才可以更容易的满足当前的值 first 比 third 值小这个条件，举个例子来说吧，比如 [2, 4, 2, 3, 5]，由于是从后往前遍历，所以后三个数都不会进入 while 循环，那么栈中的数字为 5, 3, 2（其中2为栈顶元素），此时 third 还是整型最小，那么当遍历到4的时候，终于4大于栈顶元素2了，那么 third 赋值为2，且2出栈。此时继续 while 循环，因为4还是大于新栈顶元素3，此时 third 赋值为3，且3出栈。现在栈顶元素是5，那么 while 循环结束，将4压入栈。下一个数字2，小于 third，则找到符合要求的序列 [2, 4, 3]，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">find132pattern</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size(), third = INT_MIN;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i --) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; third)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">while</span>(!s.empty() &amp;&amp; nums[i] &gt; s.top()) &#123;</span><br><span class="line">                third = s.top(); s.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            s.push(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode459-Repeated-Substring-Pattern"><a href="#Leetcode459-Repeated-Substring-Pattern" class="headerlink" title="Leetcode459. Repeated Substring Pattern"></a>Leetcode459. Repeated Substring Pattern</h1><p>Given a non-empty string check if it can be constructed by taking a substring of it and appending multiple copies of the substring together. You may assume the given string consists of lowercase English letters only and its length will not exceed 10000.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;abab&quot;</span><br><span class="line">Output: True</span><br><span class="line">Explanation: It&apos;s the substring &quot;ab&quot; twice.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;aba&quot;</span><br><span class="line">Output: False</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;abcabcabcabc&quot;</span><br><span class="line">Output: True</span><br><span class="line">Explanation: It&apos;s the substring &quot;abc&quot; four times. (And the substring &quot;abcabc&quot; twice.)</span><br></pre></td></tr></table></figure></p>
<p>传统方法，挨个子字符串对比<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">repeatedSubstringPattern</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> temp;</span><br><span class="line">        <span class="keyword">int</span> length = s.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= length/<span class="number">2</span>; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(length % i)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            temp = s.substr(<span class="number">0</span>, i);</span><br><span class="line">            temp = gen(temp, length/i);</span><br><span class="line">            <span class="keyword">if</span>(temp == s)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">gen</span><span class="params">(<span class="built_in">string</span> temp, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> ans = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">while</span>(i--)</span><br><span class="line">            ans += temp;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>另一种做法，用dp。维护的一位数组dp[i]表示，到位置i-1为止的重复字符串的字符个数，不包括被重复的那个字符串，什么意思呢，我们举个例子，比如”abcabc”的dp数组为[0 0 0 0 1 2 3]，dp数组长度要比原字符串长度多一个。那么我们看最后一个位置数字为3，就表示重复的字符串的字符数有3个。如果是”abcabcabc”，那么dp数组为[0 0 0 0 1 2 3 4 5 6]，我们发现最后一个数字为6，那么表示重复的字符串为“abcabc”，有6个字符。那么怎么通过最后一个数字来知道原字符串是否由重复的子字符串组成的呢，首先当然是最后一个数字不能为0，而且还要满足dp[n] % (n - dp[n]) == 0才行，因为n - dp[n]是一个子字符串的长度，那么重复字符串的长度和肯定是一个子字符串的整数倍。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">repeatedSubstringPattern</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == s[j])</span><br><span class="line">                dp[++i] = ++j;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j == <span class="number">0</span>)</span><br><span class="line">                i ++;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                j = dp[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n] &amp;&amp; (dp[n] % (n - dp[n]) == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode461-Hamming-Distance"><a href="#Leetcode461-Hamming-Distance" class="headerlink" title="Leetcode461. Hamming Distance"></a>Leetcode461. Hamming Distance</h1><p>The Hamming distance between two integers is the number of positions at which the corresponding bits are different. Given two integers x and y, calculate the Hamming distance.</p>
<p>Note:<br>0 ≤ x, y &lt; 231.</p>
<p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: x = 1, y = 4</span><br><span class="line">Output: 2</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">1   (0 0 0 1)</span><br><span class="line">4   (0 1 0 0)</span><br><span class="line">      ↑   ↑</span><br></pre></td></tr></table></figure></p>
<p>The above arrows point to positions where the corresponding bits are different.</p>
<p>求两个数的海明距离，就是判断其二进制有多少不一样的位<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = x ^ y;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=temp;i&gt;<span class="number">0</span>;i=i&gt;&gt;<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span>(i&amp;<span class="number">1</span>) res++;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode462-Minimum-Moves-to-Equal-Array-Elements-II"><a href="#Leetcode462-Minimum-Moves-to-Equal-Array-Elements-II" class="headerlink" title="Leetcode462. Minimum Moves to Equal Array Elements II"></a>Leetcode462. Minimum Moves to Equal Array Elements II</h1><p>Given an integer array nums of size n, return the minimum number of moves required to make all array elements equal.</p>
<p>In one move, you can increment or decrement an element of the array by 1.</p>
<p>Test cases are designed so that the answer will fit in a 32-bit integer.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,2,3]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation:</span><br><span class="line">Only two moves are needed (remember each move increments or decrements one element):</span><br><span class="line">[1,2,3]  =&gt;  [2,2,3]  =&gt;  [2,2,2]</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,10,2,9]</span><br><span class="line">Output: 16</span><br></pre></td></tr></table></figure></p>
<p>这道题每次对任意一个数字加1或者减1，让我们用最少的次数让数组所有值相等。首先给数组排序，最终需要变成的相等的数字就是中间的数，如果数组有奇数个，那么就是最中间的那个数字；如果是偶数个，那么就是中间两个数的区间中的任意一个数字。而两端的数字变成中间的一个数字需要的步数实际上就是两端数字的距离。参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minMoves2</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, i = <span class="number">0</span>, j = (<span class="keyword">int</span>)nums.size() - <span class="number">1</span>;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            res += nums[j--] - nums[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>既然有了上面的分析，我们知道实际上最后相等的数字就是数组的最中间的那个数字，那么我们在给数组排序后，直接利用坐标定位到中间的数字，然后算数组中每个数组与其的差的绝对值累加即可，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minMoves2</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, mid = nums[nums.size() / <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            res += <span class="built_in">abs</span>(num - mid);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>上面的两种方法都给整个数组排序了，时间复杂度是O(nlgn)，其实我们并不需要给所有的数字排序，我们只关系最中间的数字，那么这个stl中自带的函数<code>nth_element</code>就可以完美的发挥其作用了，我们只要给出我们想要数字的位置，它就能在O(n)的时间内返回正确的数字，然后算数组中每个数组与其的差的绝对值累加即可，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minMoves2</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, n = nums.size(), mid = n / <span class="number">2</span>;</span><br><span class="line">        nth_element(nums.begin(), nums.begin() + mid, nums.end());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            res += <span class="built_in">abs</span>(nums[i] - nums[mid]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode463-Island-Perimeter"><a href="#Leetcode463-Island-Perimeter" class="headerlink" title="Leetcode463. Island Perimeter"></a>Leetcode463. Island Perimeter</h1><p>You are given a map in form of a two-dimensional integer grid where 1 represents land and 0 represents water.</p>
<p>Grid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells).</p>
<p>The island doesn’t have “lakes” (water inside that isn’t connected to the water around the island). One cell is a square with side length 1. The grid is rectangular, width and height don’t exceed 100. Determine the perimeter of the island.</p>
<p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[[0,1,0,0],</span><br><span class="line"> [1,1,1,0],</span><br><span class="line"> [0,1,0,0],</span><br><span class="line"> [1,1,0,0]]</span><br><span class="line"></span><br><span class="line">Output: 16</span><br></pre></td></tr></table></figure></p>
<p>Explanation: The perimeter is the 16 yellow stripes in the image below:<br><img src="/img/20200617105700.png" alt></p>
<p>看一共有几条边，对每个格子进行遍历。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">islandPerimeter</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.size(), n = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, temp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j ++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(!grid[i][j])</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                temp = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(j == <span class="number">0</span> || (j &gt; <span class="number">0</span> &amp;&amp; !grid[i][j<span class="number">-1</span>])) temp ++;</span><br><span class="line">                <span class="keyword">if</span>(j == n<span class="number">-1</span> || (j &lt; n<span class="number">-1</span> &amp;&amp; !grid[i][j+<span class="number">1</span>])) temp ++;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span> || (i &gt; <span class="number">0</span> &amp;&amp; !grid[i<span class="number">-1</span>][j])) temp ++;</span><br><span class="line">                <span class="keyword">if</span>(i == m<span class="number">-1</span> || (i &lt; m<span class="number">-1</span> &amp;&amp; !grid[i+<span class="number">1</span>][j])) temp ++;</span><br><span class="line">                </span><br><span class="line">                ans += temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode468-Validate-IP-Address"><a href="#Leetcode468-Validate-IP-Address" class="headerlink" title="Leetcode468. Validate IP Address"></a>Leetcode468. Validate IP Address</h1><p>Given a string IP, return “IPv4” if IP is a valid IPv4 address, “IPv6” if IP is a valid IPv6 address or “Neither” if IP is not a correct IP of any type.</p>
<p>A valid IPv4 address is an IP in the form “x1.x2.x3.x4” where 0 &lt;= xi &lt;= 255 and xi cannot contain leading zeros. For example, “192.168.1.1” and “192.168.1.0” are valid IPv4 addresses but “192.168.01.1”, while “192.168.1.00” and “<a href="mailto:192.168@1.1" target="_blank" rel="noopener">192.168@1.1</a>“ are invalid IPv4 addresses.</p>
<p>A valid IPv6 address is an IP in the form “x1:x2:x3:x4:x5:x6:x7:x8” where:</p>
<ul>
<li>1 &lt;= xi.length &lt;= 4</li>
<li>xi is a hexadecimal string which may contain digits, lower-case English letter (‘a’ to ‘f’) and upper-case English letters (‘A’ to ‘F’).</li>
<li>Leading zeros are allowed in xi.</li>
</ul>
<p>For example, “2001:0db8:85a3:0000:0000:8a2e:0370:7334” and “2001:db8:85a3:0:0:8A2E:0370:7334” are valid IPv6 addresses, while “2001:0db8:85a3::8A2E:037j:7334” and “02001:0db8:85a3:0000:0000:8a2e:0370:7334” are invalid IPv6 addresses.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: IP = &quot;172.16.254.1&quot;</span><br><span class="line">Output: &quot;IPv4&quot;</span><br><span class="line">Explanation: This is a valid IPv4 address, return &quot;IPv4&quot;.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: IP = &quot;2001:0db8:85a3:0:0:8A2E:0370:7334&quot;</span><br><span class="line">Output: &quot;IPv6&quot;</span><br><span class="line">Explanation: This is a valid IPv6 address, return &quot;IPv6&quot;.</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: IP = &quot;256.256.256.256&quot;</span><br><span class="line">Output: &quot;Neither&quot;</span><br><span class="line">Explanation: This is neither a IPv4 address nor a IPv6 address.</span><br></pre></td></tr></table></figure></p>
<p>Example 4:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: IP = &quot;2001:0db8:85a3:0:0:8A2E:0370:7334:&quot;</span><br><span class="line">Output: &quot;Neither&quot;</span><br></pre></td></tr></table></figure></p>
<p>巨难搞，就跟判断一个数是不是合法一样。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">is_number</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="string">'0'</span> &lt;= c &amp;&amp; c &lt;= <span class="string">'9'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">is_char</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="string">'A'</span> &lt;= c &amp;&amp; c &lt;= <span class="string">'F'</span>) || (<span class="string">'a'</span> &lt;= c &amp;&amp; c &lt;= <span class="string">'f'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">validIPAddress</span><span class="params">(<span class="built_in">string</span> IP)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isv4(IP))</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"IPv4"</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (isv6(IP))</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"IPv6"</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Neither"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isv4</span><span class="params">(<span class="built_in">string</span> IP)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = IP.length();</span><br><span class="line">        <span class="keyword">int</span> num_points = <span class="number">0</span>, number = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> is_begin = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (number &gt; <span class="number">255</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (IP[i] == <span class="string">'.'</span>) &#123;</span><br><span class="line">                num_points ++;</span><br><span class="line">                number = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (is_begin)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                is_begin = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!is_number(IP[i]))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &lt; len<span class="number">-1</span> &amp;&amp; is_begin &amp;&amp; IP[i+<span class="number">1</span>] != <span class="string">'.'</span> &amp;&amp; IP[i] == <span class="string">'0'</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                is_begin = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; IP[i] == <span class="string">'0'</span> &amp;&amp; IP[i<span class="number">-1</span>] == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                number = number * <span class="number">10</span> + IP[i] - <span class="string">'0'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (number &gt; <span class="number">255</span> || num_points != <span class="number">3</span> || IP[len<span class="number">-1</span>] == <span class="string">'.'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isv6</span><span class="params">(<span class="built_in">string</span> IP)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = IP.length();</span><br><span class="line">        <span class="keyword">int</span> num_points = <span class="number">0</span>, number = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> is_begin = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (IP[i] == <span class="string">':'</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (number &gt; <span class="number">4</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                num_points ++;</span><br><span class="line">                number = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (is_begin)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                is_begin = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                is_begin = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (!(is_number(IP[i]) || is_char(IP[i])) )</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                number ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (num_points != <span class="number">7</span> || number &gt; <span class="number">4</span> || IP[len<span class="number">-1</span>] == <span class="string">':'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>内存占用最小的提交：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"Ofast"</span>)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> _ = [] () &#123;ios_base::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);<span class="keyword">return</span> <span class="number">0</span>;&#125;();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">validIPAddress</span><span class="params">(<span class="built_in">string</span> <span class="keyword">const</span>&amp; IP)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> isV6 = IP.find(<span class="string">':'</span>) != <span class="built_in">string</span>::npos;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (isV6) &#123;  <span class="comment">// Try to parse ipv6 </span></span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>, segments = <span class="number">0</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">auto</span> isValidHex = [](<span class="keyword">char</span> c) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">isdigit</span>(c) ||</span><br><span class="line">                    (<span class="string">'a'</span> &lt;= c &amp;&amp; c &lt;= <span class="string">'f'</span>) ||</span><br><span class="line">                    (<span class="string">'A'</span> &lt;= c &amp;&amp; c &lt;= <span class="string">'F'</span>);</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> ptr = <span class="number">-1</span>, size = IP.size();</span><br><span class="line">            <span class="keyword">while</span> (ptr &lt; size &amp;&amp; segments &lt; <span class="number">8</span>) &#123;</span><br><span class="line">                ++ptr; <span class="comment">// skip leading ':'</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">while</span> (ptr &lt; size &amp;&amp; IP[ptr] != <span class="string">':'</span>)</span><br><span class="line">                <span class="keyword">if</span> (isValidHex(IP[ptr]))</span><br><span class="line">                    ++ptr, ++count;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="string">"Neither"</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (count == <span class="number">0</span> || count &gt; <span class="number">4</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">"Neither"</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    count = <span class="number">0</span>,</span><br><span class="line">                    ++segments;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (ptr == IP.size() &amp;&amp; segments == <span class="number">8</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"IPv6"</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="string">"Neither"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// Try to parse ipv4 </span></span><br><span class="line">            <span class="keyword">int</span> segments = <span class="number">0</span>, number = <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> ptr = <span class="number">-1</span>, size = IP.size();</span><br><span class="line">            <span class="keyword">while</span> (ptr &lt; size &amp;&amp; segments &lt; <span class="number">4</span>) &#123;</span><br><span class="line">                ++ptr; <span class="comment">// skip initial dot</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (ptr &lt; size &amp;&amp; IP[ptr] == <span class="string">'0'</span>) &#123;</span><br><span class="line">                    ++segments;</span><br><span class="line">                    ++ptr;</span><br><span class="line">                    <span class="keyword">if</span> (ptr == size || IP[ptr] == <span class="string">'.'</span>)</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="string">"Neither"</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (ptr &lt; size &amp;&amp; IP[ptr] != <span class="string">'.'</span>)</span><br><span class="line">                    <span class="keyword">if</span> (number &lt; <span class="number">250</span> &amp;&amp; <span class="built_in">isdigit</span>(IP[ptr])) &#123;</span><br><span class="line">                        ++count;</span><br><span class="line">                        number *= <span class="number">10</span>;</span><br><span class="line">                        number += IP[ptr] - <span class="string">'0'</span>;</span><br><span class="line">                        ++ptr;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="string">"Neither"</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (<span class="number">1</span> &lt;= count &amp;&amp; count &lt;= <span class="number">4</span> &amp;&amp; <span class="number">1</span> &lt;= number &amp;&amp; number &lt;= <span class="number">255</span>) &#123;</span><br><span class="line">                    count = <span class="number">0</span>;</span><br><span class="line">                    number = <span class="number">0</span>;</span><br><span class="line">                    ++segments;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">"Neither"</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (ptr == IP.size() &amp;&amp; segments == <span class="number">4</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"IPv4"</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="string">"Neither"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Neither"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode467-Unique-Substrings-in-Wraparound-String"><a href="#Leetcode467-Unique-Substrings-in-Wraparound-String" class="headerlink" title="Leetcode467. Unique Substrings in Wraparound String"></a>Leetcode467. Unique Substrings in Wraparound String</h1><p>Consider the string s to be the infinite wraparound string of “abcdefghijklmnopqrstuvwxyz”, so s will look like this: “…zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd….”.</p>
<p>Now we have another string p. Your job is to find out how many unique non-empty substrings of p are present in s. In particular, your input is the string p and you need to output the number of different non-empty substrings of p in the string s.</p>
<p>Note: p consists of only lowercase English letters and the size of p might be over 10000.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;a&quot;</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: Only the substring &quot;a&quot; of string &quot;a&quot; is in the string s.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;cac&quot;</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: There are two substrings &quot;a&quot;, &quot;c&quot; of string &quot;cac&quot; in the string s.</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;zab&quot;</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: There are six substrings &quot;z&quot;, &quot;a&quot;, &quot;b&quot;, &quot;za&quot;, &quot;ab&quot;, &quot;zab&quot; of string &quot;zab&quot; in the string s.</span><br></pre></td></tr></table></figure></p>
<p>这道题说有一个无限长的封装字符串，然后又给了我们另一个字符串p，问我们p有多少非空子字符串在封装字符串中。我们通过观察题目中的例子可以发现，由于封装字符串是26个字符按顺序无限循环组成的，那么满足题意的p的子字符串要么是单一的字符，要么是按字母顺序的子字符串。这道题遍历p的所有子字符串会TLE，因为如果p很大的话，子字符串很多，会有大量的满足题意的重复子字符串，必须要用到trick，而所谓技巧就是一般来说你想不到的方法。我们看abcd这个字符串，以d结尾的子字符串有abcd, bcd, cd, d，那么我们可以发现bcd或者cd这些以d结尾的字符串的子字符串都包含在abcd中，那么我们知道以某个字符结束的最大字符串包含其他以该字符结束的字符串的所有子字符串，说起来很拗口，但是理解了我上面举的例子就行。那么题目就可以转换为分别求出以每个字符(a-z)为结束字符的最长连续字符串就行了，我们用一个数组cnt记录下来，最后在求出数组cnt的所有数字之和就是我们要的结果啦，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findSubstringInWraproundString</span><span class="params">(<span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cnt(<span class="number">26</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; (p[i] == p[i - <span class="number">1</span>] + <span class="number">1</span> || p[i - <span class="number">1</span>] - p[i] == <span class="number">25</span>)) &#123;</span><br><span class="line">                ++len;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                len = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cnt[p[i] - <span class="string">'a'</span>] = max(cnt[p[i] - <span class="string">'a'</span>], len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> accumulate(cnt.begin(), cnt.end(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode470-Implement-Rand10-Using-Rand7"><a href="#Leetcode470-Implement-Rand10-Using-Rand7" class="headerlink" title="Leetcode470. Implement Rand10() Using Rand7()"></a>Leetcode470. Implement Rand10() Using Rand7()</h1><p>Given the API rand7() that generates a uniform random integer in the range [1, 7], write a function rand10() that generates a uniform random integer in the range [1, 10]. You can only call the API rand7(), and you shouldn’t call any other API. Please do not use a language’s built-in random API.</p>
<p>Each test case will have one internal argument n, the number of times that your implemented function rand10() will be called while testing. Note that this is not an argument passed to rand10().</p>
<p>Follow up:</p>
<ul>
<li>What is the expected value for the number of calls to rand7() function?</li>
<li>Could you minimize the number of calls to rand7()?</li>
</ul>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 1</span><br><span class="line">Output: [2]</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 2</span><br><span class="line">Output: [2,8]</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 3</span><br><span class="line">Output: [3,8,10]</span><br></pre></td></tr></table></figure></p>
<p>这道题给了我们一个随机生成 [1, 7] 内数字的函数<code>rand7()</code>，需要利用其来生成一个能随机生成 [1, 10] 内数字的函数<code>rand10()</code>，注意这里的随机生成的意思是等概率生成范围内的数字。这是一道很有意思的题目，由于<code>rand7()</code>只能生成1到7之间的数字，所以 8，9，10 这三个没法生成，那么怎么办？</p>
<p>大多数人可能第一个想法就是，再用一个呗，然后把两次的结果加起来，范围不就扩大了么，扩大成了 [2, 14] 之间，然后如果再减去1，范围不就是 [1, 13] 了么。想法不错，但是有个问题，这个范围内的每个数字生成的概率不是都相等的，为啥这么说呢，我们来举个简单的例子看下，就比如说<code>rand2()</code>，我们知道其可以生成两个数字1和2，且每个的概率都是 1/2。那么对于<code>(rand2() - 1) +</code>rand2()<code></code>呢，看一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rand2() - 1 + rand()2  =   ?</span><br><span class="line">   1            1          1</span><br><span class="line">   1            2          2</span><br><span class="line">   2            1          2</span><br><span class="line">   2            2          3</span><br></pre></td></tr></table></figure></p>
<p>我们发现，生成数字范围 [1, 3] 之间的数字并不是等概率大，其中2出现的概率为 1/2，1和3分别为 1/4。这就不随机了。问题出在哪里了呢，如果直接相加，不同组合可能会产生相同的数字，比如 1+2 和 2+1 都是3。所以需要给第一个<code>rand2()</code>升一个维度，让其乘上一个数字，再相加。比如对于<code>(rand2() - 1) * 2 +</code>rand2()<code></code>，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">（rand2() - 1） * 2 + rand()2  =   ?</span><br><span class="line">     1                  1         1</span><br><span class="line">     1                  2         2</span><br><span class="line">     2                  1         3</span><br><span class="line">     2                  2         4</span><br></pre></td></tr></table></figure></p>
<p>这时右边生成的 1，2，3，4 就是等概率出现的了。这样就通过使用<code>rand2()</code>，来生成<code>rand4()</code>了。那么反过来想一下，可以通过<code>rand4()</code>来生成<code>rand2()</code>，其实更加简单，我们只需通过<code>rand4() % 2 + 1</code>即可，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rand4() % 2 + 1 =  ?</span><br><span class="line">   1               2</span><br><span class="line">   2               1</span><br><span class="line">   3               2</span><br><span class="line">   4               1</span><br></pre></td></tr></table></figure></p>
<p>同理，我们也可以通过<code>rand6()</code>来生成<code>rand2()</code>，我们只需通过<code>rand6() % 2 + 1</code>即可，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rand6() % 2 + 1 =  ?</span><br><span class="line">  1               2</span><br><span class="line">  2               1</span><br><span class="line">  3               2</span><br><span class="line">  4               1</span><br><span class="line">  5               2</span><br><span class="line">  6               1</span><br></pre></td></tr></table></figure></p>
<p>所以，回到这道题，我们可以先凑出<code>rand10*N()</code>，然后再通过<code>rand10*N() % 10 + 1</code>来获得<code>rand10()</code>。那么，只需要将<code>rand7()</code>转化为<code>rand10*N()</code>即可，根据前面的讲解，我们转化也必须要保持等概率，那么就可以变化为<code>(rand7() - 1) * 7 + rand7()</code>，就转为了<code>rand49()</code>。但是 49 不是 10 的倍数，不过 49 包括好几个 10 的倍数，比如 40，30，20，10 等。这里，我们需要把<code>rand49()</code>转为<code>rand40()</code>，需要用到<strong>拒绝采样</strong>Rejection Sampling。这种采样方法就是随机到需要的数字就接受，不是需要的就拒绝，并重新采样，这样还能保持等概率。</p>
<p>当用 <code>rand49()</code>生成一个 [1, 49] 范围内的随机数，如果其在 [1, 40] 范围内，我们就将其转为<code>rand10()</code>范围内的数字，直接对 10 去余并加1，返回即可。如果不是，则继续循环即可，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rand10</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> num = (rand7() - <span class="number">1</span>) * <span class="number">7</span> + rand7();</span><br><span class="line">            <span class="keyword">if</span> (num &lt;= <span class="number">40</span>) <span class="keyword">return</span> num % <span class="number">10</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>我们可以不用 while 循环，而采用调用递归函数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rand10</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = (rand7() - <span class="number">1</span>) * <span class="number">7</span> + rand7();</span><br><span class="line">        <span class="keyword">return</span> (num &lt;= <span class="number">40</span>) ? (num % <span class="number">10</span> + <span class="number">1</span>) : rand10();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode472-Concatenated-Words"><a href="#Leetcode472-Concatenated-Words" class="headerlink" title="Leetcode472. Concatenated Words"></a>Leetcode472. Concatenated Words</h1><p>Given an array of strings words (without duplicates), return all the concatenated words in the given list of words.</p>
<p>A concatenated word is defined as a string that is comprised entirely of at least two shorter words in the given array.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: words = [&quot;cat&quot;,&quot;cats&quot;,&quot;catsdogcats&quot;,&quot;dog&quot;,&quot;dogcatsdog&quot;,&quot;hippopotamuses&quot;,&quot;rat&quot;,&quot;ratcatdogcat&quot;]</span><br><span class="line">Output: [&quot;catsdogcats&quot;,&quot;dogcatsdog&quot;,&quot;ratcatdogcat&quot;]</span><br><span class="line">Explanation: &quot;catsdogcats&quot; can be concatenated by &quot;cats&quot;, &quot;dog&quot; and &quot;cats&quot;; </span><br><span class="line">&quot;dogcatsdog&quot; can be concatenated by &quot;dog&quot;, &quot;cats&quot; and &quot;dog&quot;; </span><br><span class="line">&quot;ratcatdogcat&quot; can be concatenated by &quot;rat&quot;, &quot;cat&quot;, &quot;dog&quot; and &quot;cat&quot;.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: words = [&quot;cat&quot;,&quot;dog&quot;,&quot;catdog&quot;]</span><br><span class="line">Output: [&quot;catdog&quot;]</span><br></pre></td></tr></table></figure></p>
<p>这道题给了一个由单词组成的数组，某些单词是可能由其他的单词组成的，让我们找出所有这样的单词。我们首先把所有单词都放到一个unordered_set中，这样可以快速找到某个单词是否在数组中存在。对于当前要判断的单词，我们先将其从set中删去，然后调用之前的Word Break的解法。如果是可以拆分，那么我们就存入结果res中，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; findAllConcatenatedWordsInADict(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words) &#123;</span><br><span class="line">        <span class="keyword">if</span> (words.size() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; dict(words.begin(), words.end());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.size(); i ++) &#123;</span><br><span class="line">            dict.erase(words[i]);</span><br><span class="line">            <span class="keyword">int</span> len = words[i].size();</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; flag(len+<span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line">            flag[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= len; j ++) </span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; j; k ++)</span><br><span class="line">                    <span class="keyword">if</span> (flag[k] &amp;&amp; dict.count(words[i].substr(k, j-k))) &#123;</span><br><span class="line">                        flag[j] = <span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag[len])</span><br><span class="line">                res.push_back(words[i]);</span><br><span class="line">            dict.insert(words[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode473-Matchsticks-to-Square"><a href="#Leetcode473-Matchsticks-to-Square" class="headerlink" title="Leetcode473. Matchsticks to Square"></a>Leetcode473. Matchsticks to Square</h1><p>Remember the story of Little Match Girl? By now, you know exactly what matchsticks the little match girl has, please find out a way you can make one square by using up all those matchsticks. You should not break any stick, but you can link them up, and each matchstick must be used exactly one time.</p>
<p>Your input will be several matchsticks the girl has, represented with their stick length. Your output will either be true or false, to represent whether you could make one square using all the matchsticks the little match girl has.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,1,2,2,2]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: You can form a square with length 2, one side of the square came two sticks with length 1.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,3,3,3,4]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: You cannot find a way to form a square with all the matchsticks.</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>The length sum of the given matchsticks is in the range of 0 to 10^9.</li>
<li>The length of the given matchstick array will not exceed 15.</li>
</ul>
<p>这道题让我们用数组中的数字来摆出一个正方形。这道题实际上是让我们将一个数组分成四个和相等的子数组。可以用优化过的递归来解，递归的方法基本上等于brute force。先给数组从大到小的顺序排序，这样大的数字先加，如果超过target了，就直接跳过了后面的再次调用递归的操作，效率会提高不少。我们建立一个长度为4的数组sums来保存每个边的长度和，我们希望每条边都等于target，数组总和的四分之一。然后我们遍历sums中的每条边，我们判断如果加上数组中的当前数字大于target，那么我们跳过，如果没有，我们就加上这个数字，然后对数组中下一个位置调用递归，如果返回为真，我们返回true，否则我们再从sums中对应位置将这个数字减去继续循环，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">makesquare</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.empty() || nums.size() &lt; <span class="number">4</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = accumulate(nums.begin(), nums.end(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (sum % <span class="number">4</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sums(<span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line">        sort(nums.rbegin(), nums.rend());</span><br><span class="line">        <span class="keyword">return</span> helper(nums, sums, <span class="number">0</span>, sum / <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; sums, <span class="keyword">int</span> pos, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pos &gt;= nums.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> sums[<span class="number">0</span>] == target &amp;&amp; sums[<span class="number">1</span>] == target &amp;&amp; sums[<span class="number">2</span>] == target;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sums[i] + nums[pos] &gt; target) <span class="keyword">continue</span>;</span><br><span class="line">            sums[i] += nums[pos];</span><br><span class="line">            <span class="keyword">if</span> (helper(nums, sums, pos + <span class="number">1</span>, target)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            sums[i] -= nums[pos];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode474-Ones-and-Zeroes"><a href="#Leetcode474-Ones-and-Zeroes" class="headerlink" title="Leetcode474. Ones and Zeroes"></a>Leetcode474. Ones and Zeroes</h1><p>In the computer world, use restricted resource you have to generate maximum benefit is what we always want to pursue.</p>
<p>For now, suppose you are a dominator of m 0s and n 1s respectively. On the other hand, there is an array with strings consisting of only 0s and 1s.</p>
<p>Now your task is to find the maximum number of strings that you can form with given m 0s and n 1s. Each 0 and 1 can be used at most once.</p>
<p>Note:</p>
<ul>
<li>The given numbers of 0s and 1s will both not exceed 100</li>
<li>The size of given string array won’t exceed 600.</li>
</ul>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: Array = &#123;&quot;10&quot;, &quot;0001&quot;, &quot;111001&quot;, &quot;1&quot;, &quot;0&quot;&#125;, m = 5, n = 3</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: This are totally 4 strings can be formed by the using of 5 0s and 3 1s, which are “10,”0001”,”1”,”0”</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: Array = &#123;&quot;10&quot;, &quot;0&quot;, &quot;1&quot;&#125;, m = 1, n = 1</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: You could form &quot;10&quot;, but then you&apos;d have nothing left. Better form &quot;0&quot; and &quot;1&quot;.</span><br></pre></td></tr></table></figure></p>
<p>这道题是一道典型的应用DP来解的题，我们需要建立一个二维的DP数组，其中<code>dp[i][j]</code>表示有i个0和j个1时能组成的最多字符串的个数，而对于当前遍历到的字符串，我们统计出其中0和1的个数为zeros和ones，然后<code>dp[i - zeros][j - ones]</code>表示当前的i和j减去zeros和ones之前能拼成字符串的个数，那么加上当前的zeros和ones就是当前<code>dp[i][j]</code>可以达到的个数，我们跟其原有数值对比取较大值即可，所以递推式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = max(dp[i][j], dp[i - zeros][j - ones] + 1);</span><br></pre></td></tr></table></figure></p>
<p>有了递推式，我们就可以很容易的写出代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMaxForm</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">string</span> str : strs) &#123;</span><br><span class="line">            <span class="keyword">int</span> zeros = <span class="number">0</span>, ones = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> c : str) (c == <span class="string">'0'</span>) ? ++zeros : ++ones;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = m; i &gt;= zeros; --i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = n; j &gt;= ones; --j) &#123;</span><br><span class="line">                    dp[i][j] = max(dp[i][j], dp[i - zeros][j - ones] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode475-Heaters"><a href="#Leetcode475-Heaters" class="headerlink" title="Leetcode475. Heaters"></a>Leetcode475. Heaters</h1><p>Winter is coming! Your first job during the contest is to design a standard heater with fixed warm radius to warm all the houses.</p>
<p>Now, you are given positions of houses and heaters on a horizontal line, find out minimum radius of heaters so that all houses could be covered by those heaters.</p>
<p>So, your input will be the positions of houses and heaters seperately, and your expected output will be the minimum radius standard of heaters.</p>
<p>Note:</p>
<ul>
<li>Numbers of houses and heaters you are given are non-negative and will not exceed 25000.</li>
<li>Positions of houses and heaters you are given are non-negative and will not exceed 10^9.</li>
<li>As long as a house is in the heaters’ warm radius range, it can be warmed.</li>
<li>All the heaters follow your radius standard and the warm radius will the same.</li>
</ul>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3],[2]</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: The only heater was placed in the position 2, and if we use the radius 1 standard, then all the houses can be warmed.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3,4],[1,4]</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: The two heater was placed in the position 1 and 4. We need to use radius 1 standard, then all the houses can be warmed.</span><br></pre></td></tr></table></figure></p>
<p>思路：</p>
<ol>
<li>先对houses和heaters排序，result记录全局最小温暖半径，temp记录当前house的最小温暖半径。</li>
<li>依次为每个house查找最小的温暖半径（显然，每个house的最小半径只需考虑其左边最近的heaters和右边最近的heaters）。</li>
<li>对每一个house先查找位置不小于其位置的第一个heater，其位置为j。</li>
<li>若未找到，则当前house的最小温暖半径由左边最近的heaters决定。</li>
<li>若第一个heater的位置就不小于当前house的位置，则当前house的最小温暖半径由右边最近的heaters决定。</li>
<li>若找到的位置不小于当前house位置的第一个heater的位置大于当前house位置（若等于，则当前house的最小温暖半径等于0），则当前house的最小温暖半径是其与左边最近的heaters的距离和其与右边最近的heaters的距离的较小值。</li>
<li>若当前house的最小温暖半径大于全局result，则更新result。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findRadius</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; houses, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; heaters)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        sort(houses.begin(), houses.end());</span><br><span class="line">        sort(heaters.begin(), heaters.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> house = <span class="number">0</span>, heater = <span class="number">0</span>; house &lt; houses.size(); house ++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(heater &lt; heaters.size() &amp;&amp; heaters[heater] &lt; houses[house])</span><br><span class="line">                heater ++;</span><br><span class="line">            <span class="keyword">if</span>(heater == heaters.size())</span><br><span class="line">                temp = houses[house] - heaters[heaters.size() - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(heater == <span class="number">0</span>)</span><br><span class="line">                temp = heaters[<span class="number">0</span>] - houses[house];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(heaters[heater] &gt; houses[house])</span><br><span class="line">                temp = min(heaters[heater] - houses[house], houses[house] - heaters[heater<span class="number">-1</span>]);</span><br><span class="line">            <span class="keyword">if</span>(temp &gt; res)</span><br><span class="line">                res = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode476-Number-Complement"><a href="#Leetcode476-Number-Complement" class="headerlink" title="Leetcode476. Number Complement"></a>Leetcode476. Number Complement</h1><p>Given a positive integer num, output its complement number. The complement strategy is to flip the bits of its binary representation.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: num = 5</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: num = 1</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So you need to output 0.</span><br></pre></td></tr></table></figure></p>
<p>给定一个正整数，对该数的二进制表示形式，从最高位的1开始向后按位取反。如果我们能知道该数最高位的1所在的位置，就可以构造一个长度和该数据所占位置一样长的一个掩码mask，然后概述和mask进行异或即可。例如：5的二进制是101，我们的构造的掩码为mask=111，两者异或则为010，即是所要的结果。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findComplement</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> mask = <span class="number">1</span>, temp = num;</span><br><span class="line">        <span class="keyword">while</span>(temp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            mask = mask &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            temp = temp &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num^(mask<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode477-Total-Hamming-Distance"><a href="#Leetcode477-Total-Hamming-Distance" class="headerlink" title="Leetcode477. Total Hamming Distance"></a>Leetcode477. Total Hamming Distance</h1><p>The Hamming distance between two integers is the number of positions at which the corresponding bits are different.</p>
<p>Given an integer array nums, return the sum of Hamming distances between all the pairs of the integers in nums.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [4,14,2]</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: In binary representation, the 4 is 0100, 14 is 1110, and 2 is 0010 (just</span><br><span class="line">showing the four bits relevant in this case).</span><br><span class="line">The answer will be:</span><br><span class="line">HammingDistance(4, 14) + HammingDistance(4, 2) + HammingDistance(14, 2) = 2 + 2 + 2 = 6.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [4,14,4]</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure></p>
<p>这道题是之前那道 Hamming Distance 的拓展，由于有之前那道题的经验，我们知道需要用异或来求每个位上的情况，那么需要来找出某种规律来，比如看下面这个例子，4，14，2 和1：</p>
<p>4:     0 1 0 0</p>
<p>14:   1 1 1 0</p>
<p>2:     0 0 1 0</p>
<p>1:     0 0 0 1</p>
<p>先看最后一列，有三个0和一个1，那么它们之间相互的汉明距离就是3，即1和其他三个0分别的距离累加，然后在看第三列，累加汉明距离为4，因为每个1都会跟两个0产生两个汉明距离，同理第二列也是4，第一列是3。仔细观察累计汉明距离和0跟1的个数，可以发现其实就是0的个数乘以1的个数，发现了这个重要的规律，那么整道题就迎刃而解了，只要统计出每一位的1的个数即可，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">totalHammingDistance</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, n = nums.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">                <span class="keyword">if</span> (num &amp; (<span class="number">1</span> &lt;&lt; i)) ++cnt;</span><br><span class="line">            &#125;</span><br><span class="line">            res += cnt * (n - cnt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode478-Generate-Random-Point-in-a-Circle-生成圆中的随机点"><a href="#Leetcode478-Generate-Random-Point-in-a-Circle-生成圆中的随机点" class="headerlink" title="Leetcode478. Generate Random Point in a Circle 生成圆中的随机点"></a>Leetcode478. Generate Random Point in a Circle 生成圆中的随机点</h1><p>Given the radius and x-y positions of the center of a circle, write a function randPoint which generates a uniform random point in the circle.</p>
<p>Note:</p>
<ul>
<li>input and output values are in floating-point.</li>
<li>radius and x-y position of the center of the circle is passed into the class constructor.</li>
<li>a point on the circumference of the circle is considered to be in the circle.</li>
<li>randPoint returns a size 2 array containing x-position and y-position of the random point, in that order.</li>
</ul>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">[&quot;Solution&quot;,&quot;randPoint&quot;,&quot;randPoint&quot;,&quot;randPoint&quot;]</span><br><span class="line">[[1,0,0],[],[],[]]</span><br><span class="line">Output: [null,[-0.72939,-0.65505],[-0.78502,-0.28626],[-0.83119,-0.19803]]</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">[&quot;Solution&quot;,&quot;randPoint&quot;,&quot;randPoint&quot;,&quot;randPoint&quot;]</span><br><span class="line">[[10,5,-7.5],[],[],[]]</span><br><span class="line">Output: [null,[11.52438,-8.33273],[2.46992,-16.21705],[11.13430,-12.42337]]</span><br></pre></td></tr></table></figure></p>
<p>Explanation of Input Syntax:</p>
<ul>
<li>The input is two lists: the subroutines called and their arguments. Solution’s constructor has three arguments, the radius, x-position of the center, and y-position of the center of the circle. randPoint has no arguments. Arguments are always wrapped with a list, even if there aren’t any.</li>
</ul>
<p>这道题给了我们一个圆，包括中点位置和半径，让随机生成圆中的任意一个点。这里说明了圆上也当作是圆中，而且这里的随机意味着要等概率。</p>
<p>圆的方程表示为<code>(x - a) ^ 2 + (y - b) ^ 2 = r ^ 2</code>，这里的<code>(a, b)</code>是圆心位置，r为半径。那么如何生成圆中的任意位置呢，如果用这种方式来生成，先随机出一个x，随机出y的时候还要考虑其是否在圆中间，比较麻烦。继续回到高中时代，模糊的记忆中飘来了三个字，极坐标。是的，圆还可以用极坐标的形式来表示，只需随机出一个角度 theta，再随机出一个小于半径的长度，这样就可以得到圆中的坐标位置了。</p>
<p>先来生成 theta吧，由于一圈是 360 度，即 2pi，所以随机出一个 [0, 1] 中的小数，再乘以 2pi，就可以了。然后就是随机小于半径的长度，这里有个问题需要注意一下，这里并不是直接随机出一个 [0, 1] 中的小数再乘以半径r，而是要对随机出的 [0, 1] 中的小数取个平方根再乘以半径r。这是为啥呢，简单来说，是为了保证等概率。如果不用平方根的话，那么表示圆的时候<code>(len * cos(theta)) ^ 2 + (len * sin(theta) ^ 2</code>，这里就相当于对随机出的 [0, 1] 中的小数平方了，那么其就不是等概率的了，因为两个小于1的小数相乘了，其会更加靠近0，这就是为啥要平方一下的原因。最后在求点位置的时候要加上圆心的偏移即可，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Solution(<span class="keyword">double</span> radius, <span class="keyword">double</span> x_center, <span class="keyword">double</span> y_center) &#123;</span><br><span class="line">        r = radius; centerX = x_center; centerY = y_center;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; randPoint() &#123;</span><br><span class="line">        <span class="keyword">double</span> theta = <span class="number">2</span> * M_PI * ((<span class="keyword">double</span>)rand() / RAND_MAX);</span><br><span class="line">        <span class="keyword">double</span> len = <span class="built_in">sqrt</span>((<span class="keyword">double</span>)rand() / RAND_MAX) * r;</span><br><span class="line">        <span class="keyword">return</span> &#123;centerX + len * <span class="built_in">cos</span>(theta), centerY + len * <span class="built_in">sin</span>(theta)&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> r, centerX, centerY;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这其实就是拒绝采样的经典应用，在一个正方形中有均匀分布的点，随机出其内切圆中的一个点，那么就是随机出x和y之后，然后算其平方和，如果小于等于r平方，说明其在圆内，可以返回其坐标，记得加上圆心偏移，否则重新进行采样。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Solution(<span class="keyword">double</span> radius, <span class="keyword">double</span> x_center, <span class="keyword">double</span> y_center) &#123;</span><br><span class="line">        r = radius; centerX = x_center; centerY = y_center;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; randPoint() &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">double</span> x = (<span class="number">2</span> * (<span class="keyword">double</span>)rand() / RAND_MAX - <span class="number">1.0</span>) * r;</span><br><span class="line">            <span class="keyword">double</span> y = (<span class="number">2</span> * (<span class="keyword">double</span>)rand() / RAND_MAX - <span class="number">1.0</span>) * r;</span><br><span class="line">            <span class="keyword">if</span> (x * x + y * y &lt;= r * r) <span class="keyword">return</span> &#123;centerX + x, centerY + y&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> r, centerX, centerY;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode481-Magical-String"><a href="#Leetcode481-Magical-String" class="headerlink" title="Leetcode481. Magical String"></a>Leetcode481. Magical String</h1><p>A magical string S consists of only ‘1’ and ‘2’ and obeys the following rules:</p>
<p>The string S is magical because concatenating the number of contiguous occurrences of characters ‘1’ and ‘2’ generates the string S itself.</p>
<p>The first few elements of string S is the following: S = “1221121221221121122……”</p>
<p>If we group the consecutive ‘1’s and ‘2’s in S, it will be:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 22 11 2 1 22 1 22 11 2 11 22 ……</span><br></pre></td></tr></table></figure></p>
<p>and the occurrences of ‘1’s or ‘2’s in each group are:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2 2 1 1 2 1 2 2 1 2 2 ……</span><br></pre></td></tr></table></figure></p>
<p>You can see that the occurrence sequence above is the S itself.</p>
<p>Given an integer N as input, return the number of ‘1’s in the first N number in the magical string S.</p>
<p>Note: N will not exceed 100,000.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 6</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The first 6 elements of magical string S is &quot;12211&quot; and it contains three 1&apos;s, so return 3.</span><br></pre></td></tr></table></figure></p>
<p>这道题介绍了一种神奇字符串，只由1和2组成，通过计数1组和2组的个数，又能生成相同的字符串。而让我们求前n个数字中1的个数。让我们按规律生成这个神奇字符串，只有生成了字符串的前n个字符，才能统计出1的个数。其实这道题的难点就是在于找到规律来生成字符串。</p>
<p>根据第三个数字2开始往后生成数字，此时生成两个1，然后根据第四个数字1，生成一个2，再根据第五个数字1，生成一个1，以此类推，生成的数字1或2可能通过异或3来交替生成，在生成的过程中同时统计1的个数即可，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">magicalString</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">3</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>, head = <span class="number">2</span>, tail = <span class="number">3</span>, num = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        <span class="keyword">while</span> (tail &lt; n) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v[head]; ++i) &#123;</span><br><span class="line">                v.push_back(num);</span><br><span class="line">                <span class="keyword">if</span> (num == <span class="number">1</span> &amp;&amp; tail &lt; n) ++res;</span><br><span class="line">                ++tail;</span><br><span class="line">            &#125;</span><br><span class="line">            num ^= <span class="number">3</span>;</span><br><span class="line">            ++head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode482-License-Key-Formatting"><a href="#Leetcode482-License-Key-Formatting" class="headerlink" title="Leetcode482. License Key Formatting"></a>Leetcode482. License Key Formatting</h1><p>You are given a license key represented as a string S which consists only alphanumeric character and dashes. The string is separated into N+1 groups by N dashes.</p>
<p>Given a number K, we would want to reformat the strings such that each group contains exactly K characters, except for the first group which could be shorter than K, but still must contain at least one character. Furthermore, there must be a dash inserted between two groups and all lowercase letters should be converted to uppercase.</p>
<p>Given a non-empty string S and a number K, format the string according to the rules described above.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: S = &quot;5F3Z-2e-9-w&quot;, K = 4</span><br><span class="line">Output: &quot;5F3Z-2E9W&quot;</span><br><span class="line">Explanation: The string S has been split into two parts, each part has 4 characters.</span><br><span class="line">Note that the two extra dashes are not needed and can be removed.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: S = &quot;2-5g-3-J&quot;, K = 2</span><br><span class="line">Output: &quot;2-5G-3J&quot;</span><br><span class="line">Explanation: The string S has been split into three parts, each part has 2 characters except the first part as it could be shorter as mentioned above.</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>The length of string S will not exceed 12,000, and K is a positive integer.</li>
<li>String S consists only of alphanumerical characters (a-z and/or A-Z and/or 0-9) and dashes(-).</li>
<li>String S is non-empty.</li>
</ul>
<p>繁琐的字符串拼接题。。。。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">licenseKeyFormatting</span><span class="params">(<span class="built_in">string</span> S, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> tmp, res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = S.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(S[i] == <span class="string">'-'</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            tmp = (<span class="keyword">char</span>) <span class="built_in">toupper</span>(S[i]) + tmp;</span><br><span class="line">            <span class="keyword">if</span>(tmp.length() == K) &#123;</span><br><span class="line">                res.insert(<span class="number">0</span>, <span class="string">"-"</span> + tmp);</span><br><span class="line">                tmp.clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tmp.empty() &amp;&amp; !res.empty()) <span class="keyword">return</span> res.substr(<span class="number">1</span>);</span><br><span class="line">        res = tmp + res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode485-Max-Consecutive-Ones"><a href="#Leetcode485-Max-Consecutive-Ones" class="headerlink" title="Leetcode485. Max Consecutive Ones"></a>Leetcode485. Max Consecutive Ones</h1><p>Given a binary array, find the maximum number of consecutive 1s in this array.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,1,0,1,1,1]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The first two digits or the last three digits are consecutive 1s.</span><br><span class="line">    The maximum number of consecutive 1s is 3.</span><br></pre></td></tr></table></figure></p>
<p>计算最长的连续1<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMaxConsecutiveOnes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, count = <span class="number">0</span>;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                res = count &gt; res ? count : res;</span><br><span class="line">                count = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                count ++;</span><br><span class="line">        &#125;</span><br><span class="line">        res = count &gt; res ? count : res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode486-Predict-the-Winner"><a href="#Leetcode486-Predict-the-Winner" class="headerlink" title="Leetcode486. Predict the Winner"></a>Leetcode486. Predict the Winner</h1><p>Given an array of scores that are non-negative integers. Player 1 picks one of the numbers from either end of the array followed by the player 2 and then player 1 and so on. Each time a player picks a number, that number will not be available for the next player. This continues until all the scores have been chosen. The player with the maximum score wins.</p>
<p>Given an array of scores, predict whether player 1 is the winner. You can assume each player plays to maximize his score.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: [1, 5, 2]</span><br><span class="line">Output: False</span><br><span class="line">Explanation: Initially, player 1 can choose between 1 and 2.   </span><br><span class="line">If he chooses 2 (or 1), then player 2 can choose from 1 (or 2) and 5. If player 2 chooses 5, then player 1 will be left with 1 (or 2).   </span><br><span class="line">So, final score of player 1 is 1 + 2 = 3, and player 2 is 5.   </span><br><span class="line">Hence, player 1 will never be the winner and you need to return False.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [1, 5, 233, 7]</span><br><span class="line">Output: True</span><br><span class="line">Explanation: Player 1 first chooses 1. Then player 2 have to choose between 5 and 7. No matter which number player 2 choose, player 1 can choose 233.  </span><br><span class="line">Finally, player 1 has more score (234) than player 2 (12), so you need to return True representing player1 can win.</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>1 &lt;= length of the array &lt;= 20.</li>
<li>Any scores in the given array are non-negative integers and will not exceed 10,000,000.</li>
<li>If the scores of both players are equal, then player 1 is still the winner.</li>
</ul>
<p>这道题给了一个小游戏，有一个数组，两个玩家轮流取数，说明了只能从开头或结尾取，问我们第一个玩家能赢吗。而且当前玩家赢返回 true 的条件就是递归调用下一个玩家输返回 false。这里需要一个变量来标记当前是第几个玩家，还需要两个变量来分别记录两个玩家的当前数字和，在递归函数里面，如果当前数组为空了，直接比较两个玩家的当前得分即可，如果数组中只有一个数字了，根据玩家标识来将这个数字加给某个玩家并进行比较总得分。如果数组有多个数字，分别生成两个新数组，一个是去掉首元素，一个是去掉尾元素，然后根据玩家标识分别调用不同的递归，只要下一个玩家两种情况中任意一种返回 false 了，那么当前玩家就可以赢了，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">PredictTheWinner</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> canWin(nums, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canWin</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums, <span class="keyword">int</span> sum1, <span class="keyword">int</span> sum2, <span class="keyword">int</span> player)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.empty()) <span class="keyword">return</span> sum1 &gt;= sum2;</span><br><span class="line">        <span class="keyword">if</span> (nums.size() == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (player == <span class="number">1</span>) <span class="keyword">return</span> sum1 + nums[<span class="number">0</span>] &gt;= sum2;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (player == <span class="number">2</span>) <span class="keyword">return</span> sum2 + nums[<span class="number">0</span>] &gt; sum1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; va = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(nums.begin() + <span class="number">1</span>, nums.end());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vb = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(nums.begin(), nums.end() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (player == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> !canWin(va, sum1 + nums[<span class="number">0</span>], sum2, <span class="number">2</span>) || !canWin(vb, sum1 + nums.back(), sum2, <span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (player == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> !canWin(va, sum1, sum2 + nums[<span class="number">0</span>], <span class="number">1</span>) || !canWin(vb, sum1, sum2 + nums.back(), <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>两人依次拿，如果Player1赢，则Player1拿的&gt;Player2拿的。我们把Player1拿的视为”+”，把Player2拿的视为”-“，如果最后结果大于等于0则Player1赢。</p>
<p>因此对于递归来说，beg ~ end的结果为<code>max(nums[beg] - partition(beg + 1, end), nums[end] - partition(beg, end + 1))</code>；对于非递归来说<code>DP[beg][end]</code>表示即为beg ~ end所取的值的大小（最终与零比较）。</p>
<p>总结：</p>
<ol>
<li>该问题没有直接比较一个选手所拿元素的和值，而是把问题转换为两个选手所拿元素的差值。这一点很巧妙，是关键的一步。</li>
<li>找出递推表达式：<code>max(nums[beg] - partition(beg + 1, end), nums[end] - partition(beg, end + 1))</code></li>
<li>通过递推表达式构造递归算法是比较简单的。但是要构造一个非递归的算法难度较大。对于非递归算法，首先在dp中赋初始值，这是我们解题的第一步。在这个问题中，我们使用一个二位的数组dp来表示nums数组中任意开始和结束位置两人结果的差值。</li>
</ol>
<p>初始的时候，我们仅仅知道对角线上的值。<code>dp[i][i] = nums[i]</code>。</p>
<p>接下来既然是求任意的开始和结束，对于二维数组，那肯定是一个双层的循环。通过dp中已知的元素和动态规划的递推表达式，我们就可以构造出我们的需要的结果。非递归的方式是从小问题到大问题的过程。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">PredictTheWinner</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(nums, <span class="number">0</span>, nums.length-<span class="number">1</span>) &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start == end) <span class="keyword">return</span> nums[start];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> Math.max(nums[start]-helper(nums, start+<span class="number">1</span>, end), nums[end]-helper(nums, start, end-<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>【java代码——递归2（保存中间状态）】<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">PredictTheWinner</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(nums, <span class="number">0</span>, nums.length-<span class="number">1</span>, <span class="keyword">new</span> Integer[nums.length][nums.length]) &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end, Integer[][] dp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[start][end] == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(start == end) <span class="keyword">return</span> nums[start];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> Math.max(nums[start]-helper(nums, start+<span class="number">1</span>,end, dp), nums[end]-helper(nums, start,end-<span class="number">1</span>, dp));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[start][end];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode491-Increasing-Subsequences"><a href="#Leetcode491-Increasing-Subsequences" class="headerlink" title="Leetcode491. Increasing Subsequences"></a>Leetcode491. Increasing Subsequences</h1><p>Given an integer array nums, return all the different possible increasing subsequences of the given array with at least two elements. You may return the answer in any order.</p>
<p>The given array may contain duplicates, and two equal integers should also be considered a special case of increasing sequence.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [4,6,7,7]</span><br><span class="line">Output: [[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [4,4,3,2,1]</span><br><span class="line">Output: [[4,4]]</span><br></pre></td></tr></table></figure></p>
<p>这道题让我们找出所有的递增子序列，应该不难想到，这题肯定是要先找出所有的子序列，从中找出递增的。首先来看一种迭代的解法，对于重复项的处理，最偷懒的方法是使用 TreeSet，利用其自动去处重复项的机制，然后最后返回时再转回 vector 即可。由于是找递增序列，所以需要对递归函数做一些修改，首先题目中说明了递增序列数字至少两个，所以只有子序列个数大于等于2时，才加入结果。然后就是要递增，如果之前的数字大于当前的数字，那么跳过这种情况，继续循环，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; findSubsequences(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        helper(nums, <span class="number">0</span>, s, res);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>(res.begin(), res.end());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> i, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; s, <span class="built_in">set</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.size() &gt; <span class="number">1</span>)</span><br><span class="line">            res.insert(s);</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; nums.size(); i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!s.empty() &amp;&amp; s.back() &gt; nums[i])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            s.push_back(nums[i]);</span><br><span class="line">            helper(nums, i+<span class="number">1</span>, s, res);</span><br><span class="line">            s.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode492-Construct-the-Rectangle"><a href="#Leetcode492-Construct-the-Rectangle" class="headerlink" title="Leetcode492. Construct the Rectangle"></a>Leetcode492. Construct the Rectangle</h1><p>For a web developer, it is very important to know how to design a web page’s size. So, given a specific rectangular web page’s area, your job by now is to design a rectangular web page, whose length L and width W satisfy the following requirements:</p>
<ol>
<li>The area of the rectangular web page you designed must equal to the given target area.</li>
<li>The width W should not be larger than the length L, which means L &gt;= W.</li>
<li>The difference between length L and width W should be as small as possible.</li>
</ol>
<p>You need to output the length L and the width W of the web page you designed in sequence.<br>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: 4</span><br><span class="line">Output: [2, 2]</span><br><span class="line">Explanation: The target area is 4, and all the possible ways to construct it are [1,4], [2,2], [4,1]. </span><br><span class="line">But according to requirement 2, [1,4] is illegal; according to requirement 3,  [4,1] is not optimal compared to [2,2]. So the length L is 2, and the width W is 2.</span><br></pre></td></tr></table></figure></p>
<p>构造矩形，并不断比较长宽差，差距最小的保留输出<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; constructRectangle(<span class="keyword">int</span> area) &#123;</span><br><span class="line">        <span class="keyword">int</span> ii = <span class="built_in">sqrt</span>(area);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        res.push_back(<span class="number">1</span>);</span><br><span class="line">        res.push_back(area);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= ii; i ++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = area / i;</span><br><span class="line">            <span class="keyword">if</span>(temp * i == area) &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">abs</span>(res[<span class="number">0</span>]-res[<span class="number">1</span>]) &gt; <span class="built_in">abs</span>(temp - i)) &#123;</span><br><span class="line">                    res[<span class="number">0</span>] = i;</span><br><span class="line">                    res[<span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(res[<span class="number">0</span>] &lt; res[<span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = res[<span class="number">0</span>];</span><br><span class="line">            res[<span class="number">0</span>] = res[<span class="number">1</span>];</span><br><span class="line">            res[<span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode495-Teemo-Attacking"><a href="#Leetcode495-Teemo-Attacking" class="headerlink" title="Leetcode495. Teemo Attacking"></a>Leetcode495. Teemo Attacking</h1><p>Our hero Teemo is attacking an enemy Ashe with poison attacks! When Teemo attacks Ashe, Ashe gets poisoned for a exactly duration seconds. More formally, an attack at second t will mean Ashe is poisoned during the inclusive time interval [t, t + duration - 1]. If Teemo attacks again before the poison effect ends, the timer for it is reset, and the poison effect will end duration seconds after the new attack.</p>
<p>You are given a non-decreasing integer array timeSeries, where timeSeries[i] denotes that Teemo attacks Ashe at second timeSeries[i], and an integer duration.</p>
<p>Return the total number of seconds that Ashe is poisoned.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: timeSeries = [1,4], duration = 2</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: Teemo&apos;s attacks on Ashe go as follows:</span><br><span class="line">- At second 1, Teemo attacks, and Ashe is poisoned for seconds 1 and 2.</span><br><span class="line">- At second 4, Teemo attacks, and Ashe is poisoned for seconds 4 and 5.</span><br><span class="line">Ashe is poisoned for seconds 1, 2, 4, and 5, which is 4 seconds in total.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: timeSeries = [1,2], duration = 2</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: Teemo&apos;s attacks on Ashe go as follows:</span><br><span class="line">- At second 1, Teemo attacks, and Ashe is poisoned for seconds 1 and 2.</span><br><span class="line">- At second 2 however, Teemo attacks again and resets the poison timer. Ashe is poisoned for seconds 2 and 3.</span><br><span class="line">Ashe is poisoned for seconds 1, 2, and 3, which is 3 seconds in total.</span><br></pre></td></tr></table></figure></p>
<p>直接使用贪心算法，比较相邻两个时间点的时间差，如果小于duration，就加上这个差，如果大于或等于，就加上duration即可。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findPoisonedDuration</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; timeSeries, <span class="keyword">int</span> duration)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> last = <span class="number">-1</span>, res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; timeSeries.size(); i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (timeSeries[i] &lt;= last) &#123;</span><br><span class="line">                <span class="keyword">if</span> (timeSeries[i] + duration &gt; last) &#123;</span><br><span class="line">                    res = res + (timeSeries[i] + duration - last <span class="number">-1</span>);</span><br><span class="line">                    last = timeSeries[i] + duration - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                res += duration;</span><br><span class="line">                last = timeSeries[i] + duration - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode496-Next-Greater-Element-I"><a href="#Leetcode496-Next-Greater-Element-I" class="headerlink" title="Leetcode496. Next Greater Element I"></a>Leetcode496. Next Greater Element I</h1><p>You are given two arrays (without duplicates) nums1 and nums2 where nums1’s elements are subset of nums2. Find all the next greater numbers for nums1’s elements in the corresponding places of nums2.</p>
<p>The Next Greater Number of a number x in nums1 is the first greater number to its right in nums2. If it does not exist, output -1 for this number.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: nums1 = [4,1,2], nums2 = [1,3,4,2].</span><br><span class="line">Output: [-1,3,-1]</span><br><span class="line">Explanation:</span><br><span class="line">    For number 4 in the first array, you cannot find the next greater number for it in the second array, so output -1.</span><br><span class="line">    For number 1 in the first array, the next greater number for it in the second array is 3.</span><br><span class="line">    For number 2 in the first array, there is no next greater number for it in the second array, so output -1.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: nums1 = [2,4], nums2 = [1,2,3,4].</span><br><span class="line">Output: [3,-1]</span><br><span class="line">Explanation:</span><br><span class="line">    For number 2 in the first array, the next greater number for it in the second array is 3.</span><br><span class="line">    For number 4 in the first array, there is no next greater number for it in the second array, so output -1.</span><br></pre></td></tr></table></figure></p>
<p>在num2中找到num1的每个元素，然后从这个元素往后找一个比它大的数，用标志位控制即可。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nextGreaterElement(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">int</span> first = nums1.size(), second = nums2.size();</span><br><span class="line">        <span class="keyword">int</span> i, j;</span><br><span class="line">        <span class="keyword">bool</span> find;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; first; i ++)&#123;</span><br><span class="line">            find = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; second; j ++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums1[i] == nums2[j])</span><br><span class="line">                    find = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(find &amp;&amp; nums1[i] &lt; nums2[j])</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(j == second)</span><br><span class="line">                res.push_back(<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                res.push_back(nums2[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode498-Diagonal-Traverse"><a href="#Leetcode498-Diagonal-Traverse" class="headerlink" title="Leetcode498. Diagonal Traverse"></a>Leetcode498. Diagonal Traverse</h1><p>Given an m x n matrix mat, return an array of all the elements of the array in a diagonal order.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: mat = [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">Output: [1,2,4,7,5,3,6,8,9]</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/20210710152100.jpg" alt></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: mat = [[1,2],[3,4]]</span><br><span class="line">Output: [1,2,3,4]</span><br></pre></td></tr></table></figure></p>
<p>这道题给了我们一个mxn大小的数组，让我们进行对角线遍历，先向右上，然后左下，再右上，以此类推直至遍历完整个数组，题目中的例子和图示也能很好的帮我们理解。由于移动的方向不再是水平或竖直方向，而是对角线方向，那么每移动一次，横纵坐标都要变化，向右上移动的话要坐标加上[-1, 1]，向左下移动的话要坐标加上[1, -1]，那么难点在于我们如何处理越界情况，越界后遍历的方向怎么变换。向右上和左下两个对角线方向遍历的时候都会有越界的可能，但是除了左下角和右上角的位置越界需要改变两个坐标之外，其余的越界只需要改变一个。那么我们就先判断要同时改变两个坐标的越界情况，即在右上角和左下角的位置。如果在右上角位置还要往右上走时，那么要移动到它下面的位置的，那么如果col超过了n-1的范围，那么col重置为n-1，并且row自增2，然后改变遍历的方向。同理如果row超过了m-1的范围，那么row重置为m-1，并且col自增2，然后改变遍历的方向。然后我们再来判断一般的越界情况，如果row小于0，那么row重置0，然后改变遍历的方向。同理如果col小于0，那么col重置0，然后改变遍历的方向。参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findDiagonalOrder(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; mat) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mat.empty() || mat[<span class="number">0</span>].empty())</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>, dir = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dirs&#123;&#123;<span class="number">-1</span>,<span class="number">1</span>&#125;, &#123;<span class="number">1</span>,<span class="number">-1</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span> m = mat.size(), n = mat[<span class="number">0</span>].size(), size = m*n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i ++) &#123;</span><br><span class="line">            res.push_back(mat[x][y]);</span><br><span class="line">            x += dirs[dir][<span class="number">0</span>];</span><br><span class="line">            y += dirs[dir][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (x &gt;= m) &#123; x = m - <span class="number">1</span>; y += <span class="number">2</span>; dir = <span class="number">1</span> - dir; &#125;</span><br><span class="line">            <span class="keyword">if</span> (y &gt;= n) &#123; y = n - <span class="number">1</span>; x += <span class="number">2</span>; dir = <span class="number">1</span> - dir; &#125;</span><br><span class="line">            <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;  x = <span class="number">0</span>; dir = <span class="number">1</span> - dir; &#125;</span><br><span class="line">            <span class="keyword">if</span> (y &lt; <span class="number">0</span>) &#123;  y = <span class="number">0</span>; dir = <span class="number">1</span> - dir; &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode500-Keyboard-Row"><a href="#Leetcode500-Keyboard-Row" class="headerlink" title="Leetcode500. Keyboard Row"></a>Leetcode500. Keyboard Row</h1><p>Given a List of words, return the words that can be typed using letters of alphabet on only one row’s of American keyboard like the image below.</p>
<p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;Hello&quot;, &quot;Alaska&quot;, &quot;Dad&quot;, &quot;Peace&quot;]</span><br><span class="line">Output: [&quot;Alaska&quot;, &quot;Dad&quot;]</span><br></pre></td></tr></table></figure></p>
<p>给出n个字符串，从而判断每个字符串中的字符石头来自美式键盘上的同一行，若来自同一行，返回该string。过程将键盘上的每行字符存储到相应的vector或者数组中，然后循环Input中的每个string，并且循环string中的每个char，从而进行比较。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; findWords(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">unordered_set</span> &lt;<span class="keyword">char</span>&gt; row1=&#123;<span class="string">'q'</span>,<span class="string">'w'</span>,<span class="string">'e'</span>,<span class="string">'r'</span>,<span class="string">'t'</span>,<span class="string">'y'</span>,<span class="string">'u'</span>,<span class="string">'i'</span>,<span class="string">'o'</span>,<span class="string">'p'</span>&#125;;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">unordered_set</span> &lt;<span class="keyword">char</span>&gt; row2=&#123;<span class="string">'a'</span>,<span class="string">'s'</span>,<span class="string">'d'</span>,<span class="string">'f'</span>,<span class="string">'g'</span>,<span class="string">'h'</span>,<span class="string">'j'</span>,<span class="string">'k'</span>,<span class="string">'l'</span>&#125;;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">unordered_set</span> &lt;<span class="keyword">char</span>&gt; row3=&#123;<span class="string">'z'</span>,<span class="string">'x'</span>,<span class="string">'c'</span>,<span class="string">'v'</span>,<span class="string">'b'</span>,<span class="string">'n'</span>,<span class="string">'m'</span>&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        </span><br><span class="line">          <span class="keyword">for</span>(<span class="built_in">string</span> word : words) &#123;</span><br><span class="line">            <span class="keyword">bool</span> d1=<span class="literal">true</span>, d2=<span class="literal">true</span>, d3=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">char</span> c : word) &#123;</span><br><span class="line">                <span class="keyword">if</span>(d1) &#123;</span><br><span class="line">                    <span class="keyword">auto</span> re = row1.find(<span class="built_in">tolower</span>(c));</span><br><span class="line">                    <span class="keyword">if</span>(re == row1.end())</span><br><span class="line">                        d1 = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(d2) &#123;</span><br><span class="line">                    <span class="keyword">auto</span> re = row2.find(<span class="built_in">tolower</span>(c));</span><br><span class="line">                    <span class="keyword">if</span>(re == row2.end())</span><br><span class="line">                        d2 = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(d3) &#123;</span><br><span class="line">                    <span class="keyword">auto</span> re = row3.find(<span class="built_in">tolower</span>(c));</span><br><span class="line">                    <span class="keyword">if</span>(re == row3.end())</span><br><span class="line">                        d3 = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(d1||d2||d3)</span><br><span class="line">                res.push_back(word);    </span><br><span class="line">          &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Leetcode/" rel="tag"># Leetcode</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/04/27/Leetcode1001_1050/" rel="next" title="Leetcode1001 - 1050">
                <i class="fa fa-chevron-left"></i> Leetcode1001 - 1050
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/05/05/Leetcode1101_1150/" rel="prev" title="Leetcode1101 - 1150">
                Leetcode1101 - 1150 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/header.jpg" alt="Hao Yu">
            
              <p class="site-author-name" itemprop="name">Hao Yu</p>
              <p class="site-description motion-element" itemprop="description">Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author</p>
          </div>
          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">330</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>
        	<audio controls="controls" loop="loop" preload="auto" src="/resource/xiaomeihao.mp3">
	        </audio>
	

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yuhao0102" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:yuh18@mails.tsinghua.edu.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode451-Sort-Characters-By-Frequency"><span class="nav-number">1.</span> <span class="nav-text">Leetcode451. Sort Characters By Frequency</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode452-Minimum-Number-of-Arrows-to-Burst-Balloons"><span class="nav-number">2.</span> <span class="nav-text">Leetcode452. Minimum Number of Arrows to Burst Balloons</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode452-Minimum-Number-of-Arrows-to-Burst-Balloons-1"><span class="nav-number">3.</span> <span class="nav-text">Leetcode452. Minimum Number of Arrows to Burst Balloons</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode453-Minimum-Moves-to-Equal-Array-Elements"><span class="nav-number">4.</span> <span class="nav-text">Leetcode453. Minimum Moves to Equal Array Elements</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode454-4Sum-II"><span class="nav-number">5.</span> <span class="nav-text">Leetcode454. 4Sum II</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode455-Assign-Cookies"><span class="nav-number">6.</span> <span class="nav-text">Leetcode455. Assign Cookies</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode456-132-Pattern"><span class="nav-number">7.</span> <span class="nav-text">Leetcode456. 132 Pattern</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode459-Repeated-Substring-Pattern"><span class="nav-number">8.</span> <span class="nav-text">Leetcode459. Repeated Substring Pattern</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode461-Hamming-Distance"><span class="nav-number">9.</span> <span class="nav-text">Leetcode461. Hamming Distance</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode462-Minimum-Moves-to-Equal-Array-Elements-II"><span class="nav-number">10.</span> <span class="nav-text">Leetcode462. Minimum Moves to Equal Array Elements II</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode463-Island-Perimeter"><span class="nav-number">11.</span> <span class="nav-text">Leetcode463. Island Perimeter</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode468-Validate-IP-Address"><span class="nav-number">12.</span> <span class="nav-text">Leetcode468. Validate IP Address</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode467-Unique-Substrings-in-Wraparound-String"><span class="nav-number">13.</span> <span class="nav-text">Leetcode467. Unique Substrings in Wraparound String</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode470-Implement-Rand10-Using-Rand7"><span class="nav-number">14.</span> <span class="nav-text">Leetcode470. Implement Rand10() Using Rand7()</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode472-Concatenated-Words"><span class="nav-number">15.</span> <span class="nav-text">Leetcode472. Concatenated Words</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode473-Matchsticks-to-Square"><span class="nav-number">16.</span> <span class="nav-text">Leetcode473. Matchsticks to Square</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode474-Ones-and-Zeroes"><span class="nav-number">17.</span> <span class="nav-text">Leetcode474. Ones and Zeroes</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode475-Heaters"><span class="nav-number">18.</span> <span class="nav-text">Leetcode475. Heaters</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode476-Number-Complement"><span class="nav-number">19.</span> <span class="nav-text">Leetcode476. Number Complement</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode477-Total-Hamming-Distance"><span class="nav-number">20.</span> <span class="nav-text">Leetcode477. Total Hamming Distance</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode478-Generate-Random-Point-in-a-Circle-生成圆中的随机点"><span class="nav-number">21.</span> <span class="nav-text">Leetcode478. Generate Random Point in a Circle 生成圆中的随机点</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode481-Magical-String"><span class="nav-number">22.</span> <span class="nav-text">Leetcode481. Magical String</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode482-License-Key-Formatting"><span class="nav-number">23.</span> <span class="nav-text">Leetcode482. License Key Formatting</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode485-Max-Consecutive-Ones"><span class="nav-number">24.</span> <span class="nav-text">Leetcode485. Max Consecutive Ones</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode486-Predict-the-Winner"><span class="nav-number">25.</span> <span class="nav-text">Leetcode486. Predict the Winner</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode491-Increasing-Subsequences"><span class="nav-number">26.</span> <span class="nav-text">Leetcode491. Increasing Subsequences</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode492-Construct-the-Rectangle"><span class="nav-number">27.</span> <span class="nav-text">Leetcode492. Construct the Rectangle</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode495-Teemo-Attacking"><span class="nav-number">28.</span> <span class="nav-text">Leetcode495. Teemo Attacking</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode496-Next-Greater-Element-I"><span class="nav-number">29.</span> <span class="nav-text">Leetcode496. Next Greater Element I</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode498-Diagonal-Traverse"><span class="nav-number">30.</span> <span class="nav-text">Leetcode498. Diagonal Traverse</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode500-Keyboard-Row"><span class="nav-number">31.</span> <span class="nav-text">Leetcode500. Keyboard Row</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>
  <div id="DvelopmentTarget">     
  </div>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart" aria-hidden="false"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>

  
</div>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_uv"> 
  本站访客数<span id="busuanzi_value_site_uv"></span>人次
</span>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  


  <script type="text/javascript" src="/js/src/love.js"></script>

</body>
</html>
