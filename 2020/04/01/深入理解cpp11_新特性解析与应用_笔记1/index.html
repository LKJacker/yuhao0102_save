<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zn-ch">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-center-simple.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="C++,">










<meta name="description" content="新标准的诞生C++的变化包括以下几点：  通过内存模型、线程、原子操作等来支持本地并行编程 通过统一初始化表达式、auto、declytype、移动语义等统一对泛型编程的支持 通过constexpr、POD等更好地支持系统编程 通过内联命名空间、继承构造函数和右值引用等更好地支持库的构建    保证稳定性和兼容性C++有一个众所周知的特性——对C语言的高度兼容。这样的兼容性不仅体现在程序员可以较为">
<meta name="keywords" content="C++">
<meta property="og:type" content="article">
<meta property="og:title" content="深入理解C++11_新特性解析与应用 笔记1">
<meta property="og:url" content="http://yoursite.com/2020/04/01/深入理解cpp11_新特性解析与应用_笔记1/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="新标准的诞生C++的变化包括以下几点：  通过内存模型、线程、原子操作等来支持本地并行编程 通过统一初始化表达式、auto、declytype、移动语义等统一对泛型编程的支持 通过constexpr、POD等更好地支持系统编程 通过内联命名空间、继承构造函数和右值引用等更好地支持库的构建    保证稳定性和兼容性C++有一个众所周知的特性——对C语言的高度兼容。这样的兼容性不仅体现在程序员可以较为">
<meta property="og:locale" content="zn-ch">
<meta property="og:image" content="http://yoursite.com/img/20200401105300.jpg">
<meta property="og:image" content="http://yoursite.com/img/20200401105400.jpg">
<meta property="og:image" content="http://yoursite.com/img/6010392183348dbad12481bbaa24d1be426675cb.png">
<meta property="og:image" content="http://yoursite.com/img/bb7799031a52c3cd84200c960028563396bc3924.png">
<meta property="og:image" content="http://yoursite.com/img/6783e62f4a87465a37ecf2923cde397337d6f8e6.png">
<meta property="og:image" content="http://yoursite.com/img/1c555bfcdd7b6debcee0b811af3af507c4024047.png">
<meta property="og:image" content="http://yoursite.com/img/9baea780f7719205e6eeaec221073598b1156898.png">
<meta property="og:image" content="http://yoursite.com/img/97c6aabbe90675c66837c1e0d8dc0cadc08e3861.png">
<meta property="og:image" content="http://yoursite.com/img/20200401183200.jpg">
<meta property="og:image" content="http://yoursite.com/img/75002a937720a85b2101d77e37b5821a876d3134.png">
<meta property="og:image" content="http://yoursite.com/img/20200401211700.jpg">
<meta property="og:image" content="http://yoursite.com/img/20200403170500.png">
<meta property="og:image" content="http://yoursite.com/img/20200404151200.png">
<meta property="og:updated_time" content="2020-04-04T07:29:30.552Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="深入理解C++11_新特性解析与应用 笔记1">
<meta name="twitter:description" content="新标准的诞生C++的变化包括以下几点：  通过内存模型、线程、原子操作等来支持本地并行编程 通过统一初始化表达式、auto、declytype、移动语义等统一对泛型编程的支持 通过constexpr、POD等更好地支持系统编程 通过内联命名空间、继承构造函数和右值引用等更好地支持库的构建    保证稳定性和兼容性C++有一个众所周知的特性——对C语言的高度兼容。这样的兼容性不仅体现在程序员可以较为">
<meta name="twitter:image" content="http://yoursite.com/img/20200401105300.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/04/01/深入理解cpp11_新特性解析与应用_笔记1/">





  <title>深入理解C++11_新特性解析与应用 笔记1 | Hao Yu's blog</title>
  








 
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zn-ch">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hao Yu's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">The program monkey was eaten by the siege lion.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/resume.pdf" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-mybetterhalf">
          <a href="/mybetterhalf/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>
            
            mybetterhalf
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/01/深入理解cpp11_新特性解析与应用_笔记1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">深入理解C++11_新特性解析与应用 笔记1</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-04-01T10:21:00+08:00">
                2020-04-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="新标准的诞生"><a href="#新标准的诞生" class="headerlink" title="新标准的诞生"></a>新标准的诞生</h1><h2 id="C-的变化"><a href="#C-的变化" class="headerlink" title="C++的变化"></a>C++的变化</h2><p>包括以下几点：</p>
<ul>
<li>通过内存模型、线程、原子操作等来支持本地并行编程</li>
<li>通过统一初始化表达式、auto、declytype、移动语义等统一对泛型编程的支持</li>
<li>通过constexpr、POD等更好地支持系统编程</li>
<li>通过内联命名空间、继承构造函数和右值引用等更好地支持库的构建</li>
</ul>
<p><img src="/img/20200401105300.jpg" alt><br><img src="/img/20200401105400.jpg" alt></p>
<p><img src="/img/6010392183348dbad12481bbaa24d1be426675cb.png" alt><br><img src="/img/bb7799031a52c3cd84200c960028563396bc3924.png" alt><br><img src="/img/6783e62f4a87465a37ecf2923cde397337d6f8e6.png" alt><br><img src="/img/1c555bfcdd7b6debcee0b811af3af507c4024047.png" alt></p>
<h1 id="保证稳定性和兼容性"><a href="#保证稳定性和兼容性" class="headerlink" title="保证稳定性和兼容性"></a>保证稳定性和兼容性</h1><p>C++有一个众所周知的特性——对C语言的高度兼容。这样的兼容性不仅体现在程序员可以较为容易地将C代码“升级”为C++代码上，也体现在C代码可以被C++的编译器所编译上。在C++11中，设计者总是保证在不破坏原有设计的情况下，增加新的特性，以充分保证语言的稳定性与兼容性。</p>
<h2 id="保持与C99兼容"><a href="#保持与C99兼容" class="headerlink" title="保持与C99兼容"></a>保持与C99兼容</h2><p>所以C++11将对以下C99特性的支持也都纳入了新标准中：</p>
<ul>
<li>C99中的预定义宏</li>
<li><code>__func__</code>预定义标识符</li>
<li><code>_Pragma</code>操作符</li>
<li>补丁参数宏定义以及<code>__VA_ARGS__</code></li>
<li>宽窄字符串连接</li>
</ul>
<h3 id="预定义宏"><a href="#预定义宏" class="headerlink" title="预定义宏"></a>预定义宏</h3><p>相较于C89标准，C99语言标准增加一些预定义宏。C++11同样增加了对这些宏的支持。<br><img src="/img/9baea780f7719205e6eeaec221073598b1156898.png" alt></p>
<p>使用这些宏，我们可以查验机器环境对C标准和C库的支持状况。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">    cout &lt;&lt; &quot;Standard Clib: &quot; &lt;&lt; __STDC_HOSTED__ &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;Standard C: &quot; &lt;&lt; __STDC__ &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;C Standard version: &quot; &lt;&lt; __STDC_VERSION__ &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>预定义宏对于多目标平台代码的编写通常具有重大意义。通过以上的宏，<strong>程序员通过使用#ifdef/#endif等预处理指令，就可使得平台相关代码只在适合于当前平台的代码上编译</strong>，从而在同一套代码中完成对多平台的支持。</p>
<h3 id="func-预定义标识符"><a href="#func-预定义标识符" class="headerlink" title="__func__预定义标识符"></a><code>__func__</code>预定义标识符</h3><p>很多现实的编译器都支持C99标准中的<code>__func__</code>预定义标识符功能，其基本功能就是返回所在函数的名字。我们可以看看下面这个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const char* hello() &#123;return __func__;&#125;</span><br><span class="line">const char* world() &#123;return __func__;&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    cout &lt;&lt; hello() &lt;&lt; &quot;,&quot; &lt;&lt; world() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码定义了两个函数hello和world。利用<code>__func__</code>预定义标识符，我们返回了函数的名字，并将其打印出来。事实上，按照标准定义，编译器会隐式地在函数的定义之后定义<code>__func__</code>标识符。比如上述例子中的hello函数，其实际的定义等同于如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const char* hello() &#123; </span><br><span class="line">    static const char* __func__ = &quot;hello&quot;; </span><br><span class="line">    return __func__; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>__func__</code>预定义标识符对于轻量级的调试代码具有十分重要的作用。而在C++11中，标准甚至允许其使用在类或者结构体中。</p>
<h3 id="Pragma操作符"><a href="#Pragma操作符" class="headerlink" title="_Pragma操作符"></a><code>_Pragma</code>操作符</h3><p>在C/C++标准中，<code>#pragma</code>是一条预处理的指令（preprocessor directive）。简单地说，<code>#pragma</code>是用来向编译器传达语言标准以外的一些信息。如果我们在代码的头文件中定义了以下语句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br></pre></td></tr></table></figure></p>
<p>那么该指令会指示编译器（如果编译器支持），该头文件应该只被编译一次。这与使用如下代码来定义头文件所达到的效果是一样的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#ifndef THIS_HEADER</span><br><span class="line">#define THIS_HEADER</span><br><span class="line">// 一些头文件的定义</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></p>
<p>在C++11中，标准定义了与预处理指令#pragma功能相同的操作符_Pragma。_Pragma操作符的格式如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_Pragma (字符串字面量)</span><br></pre></td></tr></table></figure></p>
<p>其使用方法跟sizeof等操作符一样，将字符串字面量作为参数写在括号内即可。那么要达到与上例#pragma类似的效果，则只需要如下代码即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_Pragma(&quot;once&quot;);</span><br></pre></td></tr></table></figure></p>
<p>由于_Pragma是一个操作符，因此可以用在一些宏中。我们可以看看下面这个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define CONCAT(x) PRAGMA(concat on #x)</span><br><span class="line">#define PRAGMA(x) _Pragma(#x)</span><br><span class="line">CONCAT( ..\concat.dir )</span><br></pre></td></tr></table></figure></p>
<p>这里，<code>CONCAT( ..concat.dir )</code>最终会产生<code>_Pragma(concat on &quot;..concat.dir&quot;)</code>这样的效果（这里只是显示语法效果，应该没有编译器支持这样的_Pragma语法）。而<code>#pragma</code>则不能在宏中展开，因此从灵活性上来讲，C++11的_Pragma具有更大的灵活性。</p>
<h3 id="变长参数的宏定义以及-VA-ARGS"><a href="#变长参数的宏定义以及-VA-ARGS" class="headerlink" title="变长参数的宏定义以及 VA_ARGS"></a>变长参数的宏定义以及 <code>VA_ARGS</code></h3><p>变长参数的宏定义是指在宏定义中参数列表的最后一个参数为省略号，而预定义宏<code>__VA_ARGS__</code>则可以在宏定义的实现部分替换省略号所代表的字符串。比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define PR(...) printf(__VA_ARGS__)</span><br></pre></td></tr></table></figure></p>
<p>就可以定义一个printf的别名PR。事实上，变长参数宏与printf是一对好搭档。我们可以看如代码清单2-4所示的一个简单的变长参数宏的应用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#define LOG(...) &#123; \</span><br><span class="line">    fprintf(stderr, &quot;%s: Line %d:\t&quot;, __FILE__, __LINE__); \</span><br><span class="line">    fprintf(stderr, __VA_ARGS__); \</span><br><span class="line">    fprintf(stderr, &quot;\n&quot;); \</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    int x = 3;</span><br><span class="line">    LOG(&quot;x = %d&quot;, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="宽窄字符串的连接"><a href="#宽窄字符串的连接" class="headerlink" title="宽窄字符串的连接"></a>宽窄字符串的连接</h3><p>在之前的C++标准中，将窄字符串（char）转换成宽字符串（wchar_t）是未定义的行为。而在C++11标准中，在将窄字符串和宽字符串进行连接时，支持C++11标准的编译器会将窄字符串转换成宽字符串，然后再与宽字符串进行连接。</p>
<h2 id="long-long-整型"><a href="#long-long-整型" class="headerlink" title="long long 整型"></a><code>long long</code> 整型</h2><p><code>long long</code>整型有两种：<code>long long</code>和<code>unsigned long long</code>。在C++11中，标准要求<code>long long</code>整型可以在不同平台上有不同的长度，但至少有64位。我们在写常数字面量时，可以使用LL后缀（或是ll）标识一个<code>long long</code>类型的字面量，而ULL（或ull、Ull、uLL）表示一个unsigned long long类型的字面量。比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">long long int lli = -9000000000000000000LL;</span><br><span class="line">unsigned long long int ulli = -9000000000000000000ULL;</span><br></pre></td></tr></table></figure></p>
<p>对于printf函数来说，输出有符号的<code>long long</code>类型变量可以用符号%lld，而无符号的<code>unsigned long long</code>则可以采用%llu。18446744073709551615用16进制表示是0xFFFFFFFFFFFFFFFF（16个F），可知在我们的实验机上，long long是一个64位的类型。</p>
<h2 id="扩展的整型"><a href="#扩展的整型" class="headerlink" title="扩展的整型"></a>扩展的整型</h2><p>C++11标准允许编译器扩展自有的所谓扩展整型（extended integer type）。这些扩展整型的长度（占用内存的位数）可以比最长的标准整型（long long int，通常是一个64位长度的数据）还长，也可以介于两个标准整数的位数之间。C++11规定，<strong>扩展的整型必须和标准类型一样，有符号类型和无符号类型占用同样大小的内存空间</strong>。而由于C/C++是一种弱类型语言，<strong>当运算、传参等类型不匹配的时候，整型间会发生隐式的转换</strong>，这种过程通常被称为整型的提升（Integral promotion）。比如如下表达式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(int) a + (long long)b</span><br></pre></td></tr></table></figure></p>
<p>通常就会导致变量(int)a被提升为long long类型后才与(long long)b进行运算。而无论是扩展的整型还是标准的整型，其转化的规则会由它们的“等级”（rank）决定。而通常情况，我们认为有如下原则：</p>
<ul>
<li>长度越大的整型等级越高，比如long long int的等级会高于int。</li>
<li>长度相同的情况下，标准整型的等级高于扩展类型，比如long long int和_int64如果都是64位长度，则long long int类型的等级更高。</li>
<li>相同大小的有符号类型和无符号类型的等级相同，long long int和unsigned long long int的等级相同。</li>
<li>而在进行隐式的整型转换的时候，一般是按照低等级整型转换为高等级整型，有符号的转换为无符号。</li>
</ul>
<h2 id="宏-cplusplus"><a href="#宏-cplusplus" class="headerlink" title="宏__cplusplus"></a>宏<code>__cplusplus</code></h2><p>在C与C++混合编写的代码中，我们常常会在头文件里看到如下的声明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#ifdef __cplusplus</span><br><span class="line">extern &quot;C&quot; &#123;</span><br><span class="line">#endif</span><br><span class="line">// 一些代码</span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></p>
<p>这种类型的头文件可以被#include到C文件中进行编译，也可以被#include到C++文件中进行编译。由于<strong>extern “C”可以抑制C++对函数名、变量名等符号（symbol）进行名称重整（name mangling)</strong>，因此编译出的C目标文件和C++目标文件中的变量、函数名称等符号都是相同的（否则不相同），链接器可以可靠地对两种类型的目标文件进行链接。这样该做法成为了C与C++混用头文件的典型做法。</p>
<p>鉴于以上的做法，程序员可能认为<code>__cplusplus</code>这个宏只有“被定义了”和“未定义”两种状态。事实上却并非如此，<code>__cplusplus</code>这个宏通常被定义为一个整型值。而且随着标准变化，<code>__cplusplus</code>宏一般会是一个比以往标准中更大的值。比如在C++03标准中，<code>__cplusplus</code>的值被预定为199711L，而在C++11标准中，宏<code>__cplusplus</code>被预定义为201103L。这点变化可以为代码所用。比如程序员在想确定代码是使用支持C++11编译器进行编译时，那么可以按下面的方法进行检测：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#if __cplusplus &lt; 201103L</span><br><span class="line">    #error &quot;should use C++11 implementation&quot;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></p>
<h2 id="静态断言"><a href="#静态断言" class="headerlink" title="静态断言"></a>静态断言</h2><h3 id="断言：运行时与预处理时"><a href="#断言：运行时与预处理时" class="headerlink" title="断言：运行时与预处理时"></a>断言：运行时与预处理时</h3><p>断言（assertion）是一种编程中常用的手段。在通常情况下，断言就是<strong>将一个返回值总是需要为真的判别式放在语句中，用于排除在设计的逻辑上不应该产生的情况</strong>。对于程序调试来说，通常断言能够帮助程序开发者快速定位那些违反了某些前提条件的程序错误。在C++中，标准在或头文件中为程序员提供了assert宏，用于在运行时进行断言。</p>
<p>在C++中，程序员也可以<strong>定义宏NDEBUG来禁用assert宏</strong>。事实上，assert宏在中的实现方式类似于下列形式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#ifdef  NDEBUG</span><br><span class="line"># define assert(expr)           (static_cast&lt;void&gt; (0))</span><br><span class="line">#else</span><br><span class="line">...</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></p>
<p>一旦定义了NDBUG宏，assert宏将被展开为一条无意义的C语句（通常会被编译器优化掉）。</p>
<h3 id="静态断言与static-assert"><a href="#静态断言与static-assert" class="headerlink" title="静态断言与static_assert"></a>静态断言与static_assert</h3><p>断言assert宏只有在程序运行时才能起作用。而#error只在编译器预处理时才能起作用。有的时候，我们希望在编译时能做一些断言，即所谓的“静态断言”。在C++11标准中，引入了static_assert断言。static_assert使用起来非常简单，它接收两个参数，一个是断言表达式，这个表达式通常需要返回一个bool值；一个则是警告信息，它通常也就是一段字符串。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename t, typename u&gt; int bit_copy(t&amp; a, u&amp; b)&#123;</span><br><span class="line">     static_assert(sizeof(b) == sizeof(a),&quot;the parameters of bit_copy must have same width.&quot;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>那么再次编译代码时，我们就会得到如下信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: static assertion failed: &quot;the parameters of bit_copy should have same width.&quot;</span><br></pre></td></tr></table></figure></p>
<p>这样的错误信息就非常清楚，也非常有利于程序员排错。而由于static_assert是编译时期的断言，其使用范围不像assert一样受到限制。在通常情况下，static_assert可以用于任何名字空间。</p>
<h2 id="noexcept修饰符与noexcept操作符"><a href="#noexcept修饰符与noexcept操作符" class="headerlink" title="noexcept修饰符与noexcept操作符"></a>noexcept修饰符与noexcept操作符</h2><p>异常通常是用于逻辑上可能发生的错误。表示函数不会抛出异常的动态异常声明throw()也被新的noexcept异常声明所取代。noexcept表示其修饰的函数不会抛出异常。在C++11中如果noexcept修饰的函数抛出了异常，编译器可以选择直接调用<code>std::terminate()</code>终止程序运行。</p>
<p>从语法上讲，noexcept修饰符有2种形式，一种是简单地在函数声明后加上noexcept关键字：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void excpt_func noexcept;</span><br></pre></td></tr></table></figure></p>
<p>另一种接受一个常量表达式作为参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void excpt_func() noexcept (常量表达式);</span><br></pre></td></tr></table></figure></p>
<p>常量表达式的结果会被转换成一个bool值，值为true表示函数不会抛出异常，反之则可能抛出异常。</p>
<p>noexcept修饰的函数通过<code>std::terminate</code>的调用结束程序的执行，虽然会导致很多额外难题，但是也被广泛用到标准库中。比如在C++98中存在着使用throw()声明不抛出异常的函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T&gt; class A &#123;</span><br><span class="line">public:</span><br><span class="line">    static constexpr T min() throw() &#123; return T(); &#125;</span><br><span class="line">    static constexpr T max() throw() &#123; return T(); &#125;</span><br><span class="line">    static constexpr T lowest() throw() &#123; return T(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>而在C++11中，则使用noexcept替换throw()：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T&gt; class A &#123;</span><br><span class="line">public:</span><br><span class="line">    static constexpr T min() noexcept &#123; return T(); &#125;</span><br><span class="line">    static constexpr T max() noexcept &#123; return T(); &#125;</span><br><span class="line">    static constexpr T lowest() noexcept &#123; return T(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="快速初始化成员变量"><a href="#快速初始化成员变量" class="headerlink" title="快速初始化成员变量"></a>快速初始化成员变量</h2><p>在C++98中，支持了在类声明中使用等号“=”加初始值的方式，来初始化类中静态成员常量。这种声明方式我们也称之为“就地”声明。就地声明在代码编写时非常便利，不过C++98对类中就地声明的要求却非常高。<strong>如果静态成员不满足常量性，则不可以就地声明</strong>，而且即使常量的静态成员也只能是整型或者枚举型才能就地初始化。而非静态成员变量的初始化则必须在构造函数中进行。</p>
<p>在C++11中，标准允许非静态成员变量的初始化有多种形式。具体而言，除了初始化列表外，在C++11中，标准还允许使用等号=或者花括号{}进行就地的非静态成员变量初始化。比如在这个名叫init的结构体中，我们给了非静态成员a和b分别赋予初值1和1.2。这在C++11中是一个合法的结构体声明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct init&#123; int a = 1; double b &#123;1.2&#125;; &#125;;</span><br></pre></td></tr></table></figure></p>
<p>对于非常量的静态成员变量，C++11则与C++98保持了一致。程序员还是需要到头文件以外去定义它，这会保证编译时，类静态成员的定义最后只存在于一个目标文件中。</p>
<h2 id="非静态成员的sizeof"><a href="#非静态成员的sizeof" class="headerlink" title="非静态成员的sizeof"></a>非静态成员的sizeof</h2><p>从C语言被发明开始，sizeof就是一个运算符，也是C语言中除了加减乘除以外为数不多的特殊运算符之一。而在C++引入类（class）类型之后，sizeof的定义也随之进行了拓展。不过在C++98标准中，对非静态成员变量使用sizeof是不能够通过编译的。在C++11中，对非静态成员变量使用sizeof操作是合法的。<code>sizeof(People::hand);</code></p>
<h2 id="扩展的friend语法"><a href="#扩展的friend语法" class="headerlink" title="扩展的friend语法"></a>扩展的friend语法</h2><p>friend关键字用于声明类的友元，友元可以无视类中成员的属性。无论成员是public、protected或是private的，友元类或友元函数都可以访问，这就完全破坏了面向对象编程中封装性的概念。<strong>因此，使用friend关键字充满了争议性</strong>。在通常情况下，面向对象程序开发的专家会建议程序员使用Get/Set接口来访问类的成员，但有的时候，friend关键字确实会让程序员少写很多代码。因此即使存在争论，friend还是在很多程序中被使用到。而C++11对friend关键字进行了一些改进，以保证其更加好用。<br><img src="/img/97c6aabbe90675c66837c1e0d8dc0cadc08e3861.png" alt></p>
<p>我们声明了3个类型：LiLei、Jim和HanMeiMei，它们都有一个友元类型Poly。从编译通过与否的状况中我们可以看出，在C++11中，声明一个类为另外一个类的友元时，不再需要使用class关键字。本例中的Jim和HanMeiMei就是这样一种情况，在HanMeiMei的声明中，我们甚至还使用了Poly的别名P，这同样是可行的。</p>
<p>程序员可以为类模板声明友元了:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class P;</span><br><span class="line">template&lt;typename T&gt; class People &#123;</span><br><span class="line">    friend T;</span><br><span class="line">&#125;</span><br><span class="line">People&lt;P&gt; PP;   // 类型P是People的友元</span><br><span class="line">People&lt;int&gt; Pi; // 对于int类型模板参数，友元声明被忽略</span><br></pre></td></tr></table></figure></p>
<h2 id="final-override控制"><a href="#final-override控制" class="headerlink" title="final/override控制"></a>final/override控制</h2><p>一旦在基类A中的成员函数fun被声明为virtual的，那么对于其派生类B而言，fun总能被重载，有的时候并不想fun在B类型中被重载，那么使用final使得派生类不可覆盖它所有修饰的虚函数。</p>
<p>C++中引入了虚函数描述符，如果派生类在虚函数声明中使用了override，那么该函数必须重载其基类的同名函数。</p>
<h2 id="模板函数的默认模板参数"><a href="#模板函数的默认模板参数" class="headerlink" title="模板函数的默认模板参数"></a>模板函数的默认模板参数</h2><p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T = int&gt;</span><br><span class="line">void DefTempParm() &#123;&#125;;</span><br></pre></td></tr></table></figure></p>
<p>DefTempParm函数模板拥有一个默认参数。</p>
<h2 id="外部模板"><a href="#外部模板" class="headerlink" title="外部模板"></a>外部模板</h2><p>如果在a.c中声明了int i，b.c中我们声明int i的时候不加上extern的话，那么i就会实实在在地既存在于a.o的数据区中，也存在于b.o的数据区中。那么链接器在链接a.o和b.o的时候，就会报告错误，因为无法决定相同的符号是否需要合并。而对于函数模板来说，现在我们遇到的几乎是一模一样的问题。不同的是，发生问题的不是变量（数据），而是函数（代码）。这样的困境是由于模板的实例化带来的。</p>
<p>外部模板的使用实际依赖于C++98中一个已有的特性，即显式实例化（Explicit Instantiation）。显式实例化的语法很简单，比如对于以下模板：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt; void fun(T) &#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们只需要声明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template void fun&lt;int&gt;(int);</span><br></pre></td></tr></table></figure></p>
<p>这就可以使编译器在本编译单元中实例化出一个fun(int)版本的函数（这种做法也被称为强制实例化）。而在C++11标准中，又加入了外部模板（Extern Template）的声明。语法上，外部模板的声明跟显式的实例化差不多，只是多了一个关键字extern。对于上面的例子，我们可以通过：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extern template void fun&lt;int&gt;(int);</span><br></pre></td></tr></table></figure></p>
<p>这样的语法完成一个外部模板的声明，例如：<br><img src="/img/20200401183200.jpg" alt></p>
<h2 id="局部和匿名类型作模板实参"><a href="#局部和匿名类型作模板实参" class="headerlink" title="局部和匿名类型作模板实参"></a>局部和匿名类型作模板实参</h2><p>在C++98中，标准对模板实参的类型还有一些限制。具体地讲，局部的类型和匿名的类型在C++98中都不能做模板类的实参。<br><img src="/img/75002a937720a85b2101d77e37b5821a876d3134.png" alt></p>
<p>在C++11中标准允许了以上类型做模板参数的做法。</p>
<h1 id="通用为本，专用为末"><a href="#通用为本，专用为末" class="headerlink" title="通用为本，专用为末"></a>通用为本，专用为末</h1><h2 id="继承构造函数"><a href="#继承构造函数" class="headerlink" title="继承构造函数"></a>继承构造函数</h2><p>类具有可派生性，派生类可以自动获得基类的成员变量和接口（虚函数和纯虚函数，这里我们指的都是public派生）。如果派生类要使用基类的构造函数，通常需要在构造函数中显式声明。比如下面的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">struct A &#123; A(int i) &#123;&#125; &#125;;</span><br><span class="line">struct B : A &#123; B(int i): A(i) &#123;&#125; &#125;;</span><br></pre></td></tr></table></figure></p>
<p>B派生于A，B又在构造函数中调用A的构造函数，从而完成构造函数的“传递”。</p>
<p>如果派生类要使用基类的成员函数，可以通过using声明完成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct Base &#123;</span><br><span class="line">    void f(double i) &#123; cout &lt;&lt; &quot;Base: &quot;&lt;&lt; i &lt;&lt; endl;&#125;</span><br><span class="line">&#125;</span><br><span class="line">struct Derived : Base &#123;</span><br><span class="line">    using Base::f;</span><br><span class="line">    void f(int i) &#123; cout &lt;&lt; &quot;Derived: &quot;&lt;&lt; i &lt;&lt; endl;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样派生类有了两个f函数，分别接受不同的i参数。</p>
<p>C++11上这种方法被扩展到了构造函数中，子类使用using声明来声明继承基类的构造函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct A &#123;</span><br><span class="line">    A(int i) &#123;&#125;</span><br><span class="line">    A(double d, int i) &#123;&#125;</span><br><span class="line">    A(float f, int i, const char* c) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">struct B : A &#123;</span><br><span class="line">    using A::A;</span><br><span class="line">    virtual void ExtraInterface() &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>通过<code>using A::A</code>声明把基类中的构造函数悉数集成到派生类中。C++11标准继承构造函数被设计为跟派生类中的各种类默认函数（默认构造、析构、拷贝构造等）一样，是隐式声明的。这意味着如果一个继承构造函数不被相关代码使用，编译器不会为其产生真正的函数代码。</p>
<p>在使用有参数默认值的构造函数的基类时，要注意确认下！</p>
<p>如果两个基类的构造函数导致了派生类的继承构造函数矛盾，则通过显式定义继承类的冲突的构造函数，阻止隐式生成相应的继承构造函数。</p>
<p>如果基类的构造函数被声明为私有成员函数，或者派生类是从基类中虚继承的，那么就不能够在派生类中声明继承构造函数。此外，如果一旦使用了继承构造函数，编译器就不会再为派生类生成默认构造函数了，那么形如代码清单3-8中这样的情况，程序员就必须注意继承构造函数没有包含一个无参数的版本。</p>
<h2 id="委派构造函数"><a href="#委派构造函数" class="headerlink" title="委派构造函数"></a>委派构造函数</h2><p>如果有多个构造函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Info &#123;</span><br><span class="line">public:</span><br><span class="line">    Info() : type(1), name(&apos;a&apos;) &#123; InitRest(); &#125;</span><br><span class="line">    Info(int i) : type(i), name(&apos;a&apos;) &#123; InitRest(); &#125;</span><br><span class="line">    Info(char e): type(1), name(e) &#123; InitRest(); &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    void InitRest() &#123; /* 其它初始化 */ &#125;</span><br><span class="line">    int  type;</span><br><span class="line">    char name;</span><br><span class="line">    // ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>C++11中的委派构造函数是在构造函数的初始化列表位置进行构造、委派的。在Info(int)和Info(char)的初始化列表中，调用了基准版本的构造函数，调用基准版本的构造函数为<strong>委派构造函数</strong>，被调用的基准版本则为<strong>目标构造函数</strong>。在C++11中，所谓委派构造，就是指委派函数将构造的任务委派给了目标构造函数来完成这样一种类构造的方式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Info &#123;</span><br><span class="line">public:</span><br><span class="line">    Info() &#123; InitRest(); &#125;</span><br><span class="line">    Info(int i) : Info() &#123; type = i; &#125;</span><br><span class="line">    Info(char e): Info() &#123; name = e; &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    void InitRest() &#123; /* 其它初始化 */ &#125;</span><br><span class="line">    int  type &#123;1&#125;;</span><br><span class="line">    char name &#123;&apos;a&apos;&#125;;</span><br><span class="line">    // ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>委派构造函数只能在函数体中为type、name等成员赋初值。<strong>这是由于委派构造函数不能有初始化列表造成的</strong>。在C++中，构造函数不能同时“委派”和使用初始化列表，所以如果委派构造函数要给变量赋初值，<strong>初始化代码必须放在函数体中</strong>。比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct Rule1 &#123;</span><br><span class="line">    int i;</span><br><span class="line">    Rule1(int a): i(a) &#123;&#125;</span><br><span class="line">    Rule1(): Rule1(40), i(1) &#123;&#125; // 无法通过编译</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>Rule1的委派构造函数Rule1()的写法就是非法的。我们不能在初始化列表中既初始化成员，又委托其他构造函数完成构造。</p>
<p>我们定义了一个私有的目标构造函数Info(int, char)，这个构造函数接受两个参数，并将参数在初始化列表中初始化。而且由于这个目标构造函数的存在，我们可以不再需要InitRest函数了，而是将其代码都放入Info(int, char)中。这样一来，其他委派构造函数就可以委托该目标构造函数来完成构造。事实上，在使用委派构造函数的时候，我们也建议程序员抽象出最为“通用”的行为做目标构造函数。这样做一来代码清晰，二来行为也更加正确。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Info &#123;</span><br><span class="line">public:</span><br><span class="line">    Info() : Info(1, &apos;a&apos;) &#123; &#125;</span><br><span class="line">    Info(int i) : Info(i, &apos;a&apos;) &#123; &#125;</span><br><span class="line">    Info(char e): Info(1, e) &#123; &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    Info(int i, char e): type(i), name(e) &#123; /* 其它初始化 */ &#125;</span><br><span class="line">    int  type;</span><br><span class="line">    char name;</span><br><span class="line">    // ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>我们可能会拥有不止一个委派构造函数，而一些目标构造函数很可能也是委派构造函数，这样一来，我们就可能在委派构造函数中形成链状的委派构造关系。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Info &#123;</span><br><span class="line">public:</span><br><span class="line">    Info() : Info(1) &#123; &#125;    // 委托构造函数</span><br><span class="line">    Info(int i) : Info(i, &apos;a&apos;) &#123; &#125; // 既是目标构造函数，也是委托构造函数</span><br><span class="line">    Info(char e): Info(1, e) &#123; &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    Info(int i, char e): type(i), name(e) &#123; /* 其它初始化 */ &#125; // 目标构造函数</span><br><span class="line">    int  type;</span><br><span class="line">    char name;</span><br><span class="line">    // ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="右值引用：移动语义和完美转发"><a href="#右值引用：移动语义和完美转发" class="headerlink" title="右值引用：移动语义和完美转发"></a>右值引用：移动语义和完美转发</h2><h3 id="移动语义"><a href="#移动语义" class="headerlink" title="移动语义"></a>移动语义</h3><p>下图的上半部分可以看到时从临时变量中拷贝构造函数a的做法，在拷贝时分配新的堆内存，并从临时对象的堆内存中拷贝内容，而构造完成后临时对象将析构。下半部分在构造时使得a.d指向临时对象的堆内存资源，同时我们保证临时对象不释放所指向的堆内存，那么在构造完成后，临时对象被析构，a就从中偷到了临时对象所拥有的堆内存资源。这就被称为移动构造函数。这样的行为成为移动语义。<br><img src="/img/20200401211700.jpg" alt></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class HasPtrMem &#123;</span><br><span class="line">public:</span><br><span class="line">    HasPtrMem(): d(new int(3)) &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Construct: &quot; &lt;&lt; ++n_cstr &lt;&lt; endl; </span><br><span class="line">    &#125;</span><br><span class="line">    HasPtrMem(const HasPtrMem &amp; h): d(new int(*h.d)) &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Copy construct: &quot; &lt;&lt; ++n_cptr &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    HasPtrMem(HasPtrMem &amp;&amp; h): d(h.d) &#123; // 移动构造函数</span><br><span class="line">        h.d = nullptr;                  // 将临时值的指针成员置空</span><br><span class="line">        cout &lt;&lt; &quot;Move construct: &quot; &lt;&lt; ++n_mvtr &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~HasPtrMem() &#123; </span><br><span class="line">        delete d;</span><br><span class="line">        cout &lt;&lt; &quot;Destruct: &quot; &lt;&lt; ++n_dstr &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    int * d;</span><br><span class="line">    static int n_cstr;</span><br><span class="line">    static int n_dstr;</span><br><span class="line">    static int n_cptr;</span><br><span class="line">    static int n_mvtr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int HasPtrMem::n_cstr = 0;</span><br><span class="line">int HasPtrMem::n_dstr = 0;</span><br><span class="line">int HasPtrMem::n_cptr = 0;</span><br><span class="line">int HasPtrMem::n_mvtr = 0;</span><br><span class="line"></span><br><span class="line">const HasPtrMem GetTemp() &#123; </span><br><span class="line">    const HasPtrMem h;</span><br><span class="line">    cout &lt;&lt; &quot;Resource from &quot; &lt;&lt;  __func__ &lt;&lt; &quot;: &quot; &lt;&lt; hex &lt;&lt; h.d &lt;&lt; endl;</span><br><span class="line">    return h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    const HasPtrMem &amp;&amp; a = GetTemp();</span><br><span class="line">    cout &lt;&lt; &quot;Resource from &quot; &lt;&lt;  __func__ &lt;&lt; &quot;: &quot; &lt;&lt; hex &lt;&lt; a.d &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码多了一个<code>&amp;&amp;</code>，移动构造函数接受一个所谓的<strong>右值引用</strong>参数，使用参数h的成员d初始化了本对象的成员d，而不是像拷贝构造函数一样需要分配内存，然后向内容依次拷贝到新分配的内存中，而h的成员d随后被置为nullptr，如果不改变临时对象的指针成员的话，则临时对象会析构掉本来是我们偷来的内存。函数返回临时变量的好处是不需要声明变量，也不需要知道生命周期。</p>
<p>在C++中，最为典型的判别左值、右值的放啊是，在赋值表达式中，出现在等号左边的就是左值，在等号右边的是右值；可以取地址有名字的叫做左值，没有名字的是右值；更为细致的，右值有两个概念构成，一个是将亡值，一个是纯右值。C++98中右值是纯右值，纯右值指的是临时变量值、不跟对象关联的字面量值。临时变量指的是非引用返回的函数返回值、表达式等；亡值则是C++11新增的跟右值引用相关的表达式，<strong>这样表达式通常是将要被移动的对象</strong>（移为他用），比如返回右值引用<code>T&amp;&amp;</code>的函数返回值、<code>std::move</code>的返回值，或者转换为<code>T&amp;&amp;</code>的类型转换函数的返回值。将亡值可以理解为通过“盗取”其他变量内存空间的方式获取到的值。在确保其他变量不再被使用、或即将被销毁时，通过“盗取”的方式可以避免内存空间的释放和分配，能够延长变量值的生命期。</p>
<p>只能通过右值表达式获得其引用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T &amp;&amp; a = ReturnValue()</span><br></pre></td></tr></table></figure></p>
<p>假设ReturnValue返回一个右值，那么声明了一个名为a的右值引用。ReturnValue函数返回的右值在表达式语句结束后，其生命也就终结了，而通过右值引用，该右值又获得新生，只要a还活着，该右值临时变量会一直存活。相比于：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T a = ReturnValue()</span><br></pre></td></tr></table></figure></p>
<p>少一次对象的析构和一次对象的构造。</p>
<p>如果使用常量左值，可以减少临时对象的凯奥，使用左值引用时临时对象被直接作为函数的参数，就不需要不必要的拷贝了。</p>
<p>如果实现一个：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void AcceptRvalueRef(Copyable &amp;&amp; s) &#123;</span><br><span class="line">    Copyable news = std::move(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里<code>std::move</code>的作用是强制一个左值成为右值，继而通过右值引用使用该值，以用于移动语义，类似一个强制类型转换<code>static_cast&lt;T&amp;&amp;&gt;(lvalue)</code>。被转化的左值其生命周期并没有随着左右值得变化而改变。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class HugeMem&#123;</span><br><span class="line">public:</span><br><span class="line">    HugeMem(int size): sz(size &gt; 0 ? size : 1) &#123;</span><br><span class="line">        c = new int[sz];</span><br><span class="line">    &#125;</span><br><span class="line">    ~HugeMem() &#123; delete [] c; &#125;</span><br><span class="line">    HugeMem(HugeMem &amp;&amp; hm): sz(hm.sz), c(hm.c) &#123;</span><br><span class="line">        hm.c = nullptr;</span><br><span class="line">    &#125;</span><br><span class="line">    int * c;</span><br><span class="line">    int sz;</span><br><span class="line">&#125;;</span><br><span class="line">class Moveable&#123;</span><br><span class="line">public:</span><br><span class="line">    Moveable():i(new int(3)), h(1024) &#123;&#125;</span><br><span class="line">    ~Moveable() &#123; delete i; &#125;</span><br><span class="line">    Moveable(Moveable &amp;&amp; m):</span><br><span class="line">        i(m.i), h(move(m.h)) &#123;      // 强制转为右值，以调用移动构造函数</span><br><span class="line">        m.i = nullptr; </span><br><span class="line">    &#125;</span><br><span class="line">    int* i;</span><br><span class="line">    HugeMem h;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Moveable GetTemp() &#123; </span><br><span class="line">    Moveable tmp = Moveable(); </span><br><span class="line">    cout &lt;&lt; hex &lt;&lt; &quot;Huge Mem from &quot; &lt;&lt; __func__ </span><br><span class="line">        &lt;&lt; &quot; @&quot; &lt;&lt; tmp.h.c &lt;&lt; endl; // Huge Mem from GetTemp @0x603030</span><br><span class="line">    return tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    Moveable a(GetTemp()); </span><br><span class="line">    cout &lt;&lt; hex &lt;&lt; &quot;Huge Mem from &quot; &lt;&lt; __func__ </span><br><span class="line">        &lt;&lt; &quot; @&quot; &lt;&lt; a.h.c &lt;&lt; endl;   // Huge Mem from main @0x603030</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在Moveable中，强制将m.h转化为右值，以迫使Moveable中的h能实现移动构造，那如果不适用move(m.h)，直接使用m.h的话，其实也可以。其实这是C++11中有趣的地方：可以接受右值的右值引用本身却是个左值。这里的m.h引用了一个确定的对象，而且m.h也有名字，可以使用<code>&amp;m.h</code>取到地址，因此是个不折不扣的左值。不过这个左值确确实实会很快“灰飞烟灭”，因为拷贝构造函数在Moveable对象a的构造完成后也就结束了。那么这里使用std::move强制其为右值就不会有问题了。而且，如果我们不这么做，由于m.h是个左值，就会导致调用HugeMem的拷贝构造函数来构造Moveable的成员h。如果是这样，移动语义就没有能够成功地向类的成员传递。换言之，还是会由于拷贝而导致一定的性能上的损失。</p>
<p>移动语义一定是要修改临时变量的值。那么，如果这样声明移动构造函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Moveable(const Moveable &amp;&amp;)</span><br></pre></td></tr></table></figure></p>
<p>或者这样声明函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const Moveable ReturnVal();</span><br></pre></td></tr></table></figure></p>
<p>都会使得临时变量常量化，成为一个常量右值，那么临时变量的引用也就无法修改，从而导致无法实现移动语义。因此程序员在实现移动语义一定要注意排除不必要的const关键字。</p>
<p>在C++11中，拷贝/移动构造函数实际上有以下3个版本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TObject(T &amp;)</span><br><span class="line">TObject(const T&amp;)</span><br><span class="line">TObject(T &amp;&amp;)</span><br></pre></td></tr></table></figure></p>
<p>其中常量左值引用的版本是一个拷贝构造版本，而右值引用版本是一个移动构造版本。默认情况下，编译器会隐式地生成一个移动构造函数。不过如果程序员声明了自定义的拷贝构造函数、拷贝赋值数、移动赋值函数、析构函数中的一个或多个，则都不会再生成默认版本。</p>
<p>通过一个辅助的模板类判断一个类型是否可以移动，比如<code>is_move_constructible</code>、<code>is_trivially_move_constructible</code>、<code>is_nothrow_move_constructible</code>。</p>
<p>实现高性能置换函数:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class T&gt; </span><br><span class="line">void swap(T &amp;a, T &amp;b) &#123;</span><br><span class="line">    T tmp(move(a));</span><br><span class="line">    a = move(b);</span><br><span class="line">    b = move(tmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>整个过程代码只会按照移动语义进行指针交换，不会有资源的释放与申请，而如果T是不可移动却是可拷贝的，那么拷贝语义会被用来置换。</p>
<p>对于移动构造函数来说，抛出异常有时是危险的，因为可能移动语义还没完成一个异常就抛出来了，这会导致一些指针成为悬挂指针。通过为其添加一个noexcept关键字，可以保证移动构造函数中抛出来的异常会直接调用terminate程序终止运行。还可以用一个<code>move_if_noexcept</code>的模板函数替代move函数，该函数在类的移动构造函数没有noexcept关键字修饰时返回一个左值引用从而使变量可以使用拷贝语义，而在类的移动构造函数没有noexcept时返回一个右值引用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;utility&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">struct Maythrow &#123;</span><br><span class="line">    Maythrow() &#123;&#125;</span><br><span class="line">    Maythrow(const Maythrow&amp;) &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;Maythorow copy constructor.&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    Maythrow(Maythrow&amp;&amp;) &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;Maythorow move constructor.&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">struct Nothrow &#123;</span><br><span class="line">    Nothrow() &#123;&#125;</span><br><span class="line">    Nothrow(Nothrow&amp;&amp;) noexcept &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;Nothorow move constructor.&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    Nothrow(const Nothrow&amp;) &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;Nothorow move constructor.&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">int main() &#123;</span><br><span class="line">    Maythrow m;</span><br><span class="line">    Nothrow n;</span><br><span class="line"></span><br><span class="line">    Maythrow mt = move_if_noexcept(m);  // Maythorow copy constructor.</span><br><span class="line">    Nothrow nt = move_if_noexcept(n);   // Nothorow move constructor.</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>RVO/NRVO：return value optimization，返回值优化，会将很多移动和构造省略。</p>
<h3 id="完美转发"><a href="#完美转发" class="headerlink" title="完美转发"></a>完美转发</h3><p>在函数模板中，完全依照模板的参数类型，将参数传递给函数模板中调用的另一个函数。C++11通过引入所谓<strong>引用折叠</strong>，并结合新的模板推到规则完成完美转发。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typedef const int T;</span><br><span class="line">typedef T&amp; TR;</span><br><span class="line">TR&amp; v =1;</span><br></pre></td></tr></table></figure></p>
<p>在C++11中一旦出现了这种表达式，发生引用折叠，将复杂的表达式折叠为已知的简单表达式。一旦定义中出现了左值引用，首先折叠为左值引用。而模板对类型的推导规则就比较简单，当转发函数的实参是类型X的一个左值引用，那么模板参数被推导为<code>X&amp;</code>类型，而转发函数的实参是类型X的一个右值引用的话，模板的参数被推导为<code>X&amp;&amp;</code>类型。结合以上的引用折叠规则，就能确定出参数的实际类型。<br><img src="/img/20200403170500.png" alt></p>
<p>例如，如果调用一个转发函数传入X类型的右值引用的话，转发函数被实例化为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void IamForwarding(X&amp;&amp; &amp;&amp; t) &#123;</span><br><span class="line">    IrunCodeActually(static_cast&lt;X&amp;&amp; &amp;&amp;&gt;(t));</span><br><span class="line">&#125;</span><br><span class="line">转成:</span><br><span class="line">void IamForwarding(X&amp;&amp; t) &#123;</span><br><span class="line">    IrunCodeActually(static_cast&lt;X&amp;&amp;&gt;(t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果想在函数调用中继续传递右值，那就要使用<code>std::move</code>进行左右值的转换。而<code>std::move</code>就是一个static_cast：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void IamForwarding(X&amp;&amp; t) &#123;</span><br><span class="line">    IrunCodeActually(forward(t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void RunCode(int &amp;&amp; m) &#123; cout &lt;&lt; &quot;rvalue ref&quot; &lt;&lt; endl; &#125;</span><br><span class="line">void RunCode(int &amp; m) &#123; cout &lt;&lt; &quot;lvalue ref&quot; &lt;&lt; endl; &#125;</span><br><span class="line">void RunCode(const int &amp;&amp; m) &#123; cout &lt;&lt; &quot;const rvalue ref&quot; &lt;&lt; endl; &#125;</span><br><span class="line">void RunCode(const int &amp; m) &#123; cout &lt;&lt; &quot;const lvalue ref&quot; &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">void PerfectForward(T &amp;&amp;t) &#123;   RunCode(forward&lt;T&gt;(t));    &#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int a;</span><br><span class="line">    int b;</span><br><span class="line">    const int c = 1;</span><br><span class="line">    const int d = 0;</span><br><span class="line"></span><br><span class="line">    PerfectForward(a);          // lvalue ref</span><br><span class="line">    PerfectForward(move(b));    // rvalue ref</span><br><span class="line">    PerfectForward(c);          // const lvalue ref</span><br><span class="line">    PerfectForward(move(d));    // const rvalue ref</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="显式转换操作符"><a href="#显式转换操作符" class="headerlink" title="显式转换操作符"></a>显式转换操作符</h2><p>C++11中将explicit的适用范围扩展到自定义的类型转换操作符上，以支持所谓的显式类型转换。explicit作用于类型转换操作符上，意味着只有在直接构造目标类型或显式类型转换时才能使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class ConvertTo &#123;&#125;;</span><br><span class="line">class Convertable &#123;</span><br><span class="line">public:</span><br><span class="line">    explicit operator ConvertTo () const &#123; return ConvertTo(); &#125;</span><br><span class="line">    //operator bool () const &#123; return true; &#125;</span><br><span class="line">    explicit operator bool () const &#123; return true; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">void Func(ConvertTo ct) &#123;&#125;</span><br><span class="line"></span><br><span class="line">void test() &#123;</span><br><span class="line">    Convertable c;</span><br><span class="line">    ConvertTo ct(c);        // 直接初始化，通过</span><br><span class="line">    ConvertTo ct2 = c;      // 拷贝构造初始化，编译失败</span><br><span class="line">    ConvertTo ct3 = static_cast&lt;ConvertTo&gt;(c);  // 强制转化，通过</span><br><span class="line">    Func(c);                // 拷贝构造初始化，编译失败</span><br><span class="line"></span><br><span class="line">    if (c) &#123;&#125;</span><br><span class="line">    c + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在代码中，我们定义了两个类型ConvertTo和Convertable，Convertable定义了一个显式转换到ConvertTo类型的类型转换符。那么对于main中ConvertTo类型的ct变量而言，由于其直接初始化构造于Convable变量c，所以可以编译通过。而做强制类型转换的ct3同样通过了编译。而ct2由于需要从c中拷贝构造，因而不能通过编译。此外，我们使用函数Func的时候，传入Convertable的变量c的也会导致参数的拷贝构造，因此也不能通过编译。</p>
<p>所谓显式类型转换并没完全禁止从源类型到目标类型的转换，不过由于此时拷贝构造和非显式类型转换不被允许，那么我们通常就不能通过赋值表达式或者函数参数的方式来产生这样一个目标类型。通常通过赋值表达式和函数参数进行的转换有可能是程序员的一时疏忽，而并非本意。那么使用了显式类型转换，这样的问题就会暴露出来，这也是我们需要显式转换符的一个重要原因。</p>
<h2 id="列表初始化"><a href="#列表初始化" class="headerlink" title="列表初始化"></a>列表初始化</h2><h3 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h3><p>标准程序库中的vector这样的容器总要声明对象-循环初始化这样的重复动作。C++11中集合的初始化已经实现，叫做<strong>初始化列表</strong>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int a[] = &#123;1, 3, 5&#125;;        // C++98 - 通过, C++11 - 通过</span><br><span class="line">int b[] &#123;2, 4, 6&#125;;          // C++98 - 失败, C++11 - 通过</span><br><span class="line">vector&lt;int&gt; c&#123;1, 3, 5&#125;;     // C++98 - 失败, C++11 - 通过</span><br><span class="line">map&lt;int, float&gt; d = &#123;&#123;1, 1.0f&#125;, &#123;2, 2.0f&#125; , &#123;5, 3.2f&#125;&#125;; // C++98 - 失败, C++11 - 通过</span><br></pre></td></tr></table></figure></p>
<p>可以使用以下几种：</p>
<ul>
<li>等号<code>=</code>加上赋值表达式，比如<code>int a = 3 + 4</code></li>
<li>等号<code>=</code>加上花括号的初始化列表，比如<code>int a = { 3 + 4 }</code></li>
<li>圆括号式的表达式：<code>int a (3+4)</code></li>
<li>花括号式的表达式：<code>int a {3+4}</code></li>
</ul>
<p>如果能声明一个以<code>initialize_list&lt;T&gt;</code>模板类为参数的构造函数，同样可以使得自定义的类型使用列表初始化。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">enum Gender &#123;boy, girl&#125;;</span><br><span class="line">class People &#123;</span><br><span class="line">public:</span><br><span class="line">    People(initializer_list&lt;pair&lt;string, Gender&gt;&gt; l) &#123;  // initializer_list的构造函数</span><br><span class="line">        auto i = l.begin();</span><br><span class="line">        for (;i != l.end(); ++i)</span><br><span class="line">            data.push_back(*i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    vector&lt;pair&lt;string, Gender&gt;&gt; data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">People ship2012 = &#123;&#123;&quot;Garfield&quot;, boy&#125;, &#123;&quot;HelloKitty&quot;, girl&#125;&#125;;</span><br></pre></td></tr></table></figure></p>
<p>下边的程序使用初始化列表重载了operator[]。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Mydata &#123;</span><br><span class="line">public:</span><br><span class="line">    Mydata &amp; operator [] (initializer_list&lt;int&gt; l)</span><br><span class="line">    &#123;</span><br><span class="line">        for (auto i = l.begin(); i != l.end(); ++i)</span><br><span class="line">            idx.push_back(*i);</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">    Mydata &amp; operator = (int v) </span><br><span class="line">    &#123;</span><br><span class="line">        if (idx.empty() != true) &#123;</span><br><span class="line">            for (auto i = idx.begin(); i != idx.end(); ++i) &#123;</span><br><span class="line">                d.resize((*i &gt; d.size()) ? *i : d.size());</span><br><span class="line">                d[*i - 1] = v;</span><br><span class="line">            &#125;</span><br><span class="line">            idx.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void Print() &#123;</span><br><span class="line">        for (auto i = d.begin(); i != d.end(); ++i) </span><br><span class="line">            cout &lt;&lt; *i &lt;&lt; &quot; &quot;;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    vector&lt;int&gt; idx;    // 辅助数组，用于记录index</span><br><span class="line">    vector&lt;int&gt; d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    Mydata d;</span><br><span class="line">    d[&#123;2, 3, 5&#125;] = 7;</span><br><span class="line">    d[&#123;1, 4, 5, 8&#125;] = 4;</span><br><span class="line">    d.Print();  // 4 7 7 4 4 0 0 4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>初始化列表可用于函数返回的情况，虽然会引起构造一个临时变量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; Func() &#123;return &#123;1, 3&#125;;&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果返回值是一个引用类型则会返回一个临时变量的引用，一定要加const<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const vector&lt;int&gt;&amp; Func() &#123;return &#123;1, 3&#125;;&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="防止类型收窄"><a href="#防止类型收窄" class="headerlink" title="防止类型收窄"></a>防止类型收窄</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const int x = 1024;</span><br><span class="line">const int y = 10;</span><br><span class="line"></span><br><span class="line">char a = x;                     // 收窄，但可以通过编译</span><br><span class="line">char* b = new char(1024);       // 收窄，但可以通过编译</span><br><span class="line"></span><br><span class="line">char c = &#123;x&#125;;                   // 收窄，无法通过编译</span><br><span class="line">char d = &#123;y&#125;;                   // 可以通过编译</span><br><span class="line">unsigned char e &#123;-1&#125;;           // 收窄，无法通过编译</span><br><span class="line"></span><br><span class="line">float f &#123; 7 &#125;;                  // 可以通过编译</span><br><span class="line">int g &#123; 2.0f &#125;;                 // 收窄，无法通过编译</span><br><span class="line">float * h = new float&#123;1e48&#125;;    // 收窄，无法通过编译</span><br><span class="line">float i = 1.2l;                 // 可以通过编译</span><br></pre></td></tr></table></figure>
<p>C++11中，列表初始化是唯一一种可以防止类型收窄的初始化方式。</p>
<h2 id="POD类型"><a href="#POD类型" class="headerlink" title="POD类型"></a>POD类型</h2><p>POD是英文中Plain Old Data的缩写，通常用于说明一个类型的属性，尤其是用户自定义类型的属性。Plain表示POD是个普通的类型，不像一些存在着虚函数虚继承的类型那么特别。而Old则体现了其与C的兼容性。C++11将POD划分为两个基本概念的合集，即：平凡的、标准布局的</p>
<p>通常情况下，一个平凡的类或结构体应该符合以下定义：</p>
<ul>
<li>拥有平凡的默认构造函数和析构函数：平凡的默认构造函数就是说构造函数“什么都不干”。通常情况下，不定义类的构造函数，编译器就会为我们生成一个平凡的默认构造数。而一旦定义了构造函数，即使构造函数不包含参数，数体里也没有任何的代码，那么该构造函数也不再是“平凡”的。</li>
<li>拥有平凡的拷贝构造函数和移动构造函数。平凡的拷贝构造函数基本上等同于使用memcpy进行类型的构造。同平凡的默认构造函数一样，不声明拷贝构造函数的话，编译器会帮程序员自动地生成。</li>
<li>拥有平凡的拷贝赋值运算符和移动赋值运算符</li>
<li>不能包含虚函数以及虚基类</li>
</ul>
<p>通过<code>std::is_trivial</code>判断是否是类型是否是一个平凡的类型。</p>
<p>另一个是标准布局：</p>
<ul>
<li>所有非静态成员都有相同的访问权限</li>
<li>在类或者结构体继承时：<ul>
<li>派生类中有非静态成员，只有一个仅包含静态成员的基类</li>
<li>基类有非静态成猿，而派生类没有非静态成员</li>
</ul>
</li>
<li>类中第一个非静态成员的类型与基类不同</li>
</ul>
<p>最后一个规则，基于C++允许优化不包含成员的基类产生的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct B1 &#123;&#125;;</span><br><span class="line">struct B2 &#123;&#125;;</span><br><span class="line"></span><br><span class="line">struct D1 : B1 &#123;</span><br><span class="line">    B1 b;       // 第一个非静态变量跟基类相同</span><br><span class="line">    int i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct D2 : B1 &#123;</span><br><span class="line">    B2 b;</span><br><span class="line">    int i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    D1 d1;</span><br><span class="line">    D2 d2;</span><br><span class="line">    cout &lt;&lt; hex;</span><br><span class="line">    cout &lt;&lt; reinterpret_cast&lt;long long&gt;(&amp;d1) &lt;&lt; endl;       // 7ffffd945c60</span><br><span class="line">    cout &lt;&lt; reinterpret_cast&lt;long long&gt;(&amp;(d1.b)) &lt;&lt; endl;   // 7ffffd945c61</span><br><span class="line">    cout &lt;&lt; reinterpret_cast&lt;long long&gt;(&amp;(d1.i)) &lt;&lt; endl;   // 7ffffd945c64</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; reinterpret_cast&lt;long long&gt;(&amp;d2) &lt;&lt; endl;       // 7ffffd945c50</span><br><span class="line">    cout &lt;&lt; reinterpret_cast&lt;long long&gt;(&amp;(d2.b)) &lt;&lt; endl;   // 7ffffd945c50</span><br><span class="line">    cout &lt;&lt; reinterpret_cast&lt;long long&gt;(&amp;(d2.i)) &lt;&lt; endl;   // 7ffffd945c54</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; sizeof(d2.b) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; sizeof(d1.b) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于d2，它和它的成员共享了同一个地址，d1却没有。如果基类没有成员，标准允许派生类的第一个成员与基类共享地址，因为派生类的地址总是堆叠在基类之上的，也表明了基类并没有占据空间。但如果基类的第一个成员仍然是基类，仍然会为基类分配一字节的空间，这是由于C++要求类型相同的对象地址一定不同。所以C++强制要求派生类的第一个非静态成员的类型必须不同于基类。</p>
<ul>
<li>没有虚函数和虚基类</li>
<li>所有非静态数据成员均符合标准布局类型。<br><img src="/img/20200404151200.png" alt></li>
</ul>
<p>通过<code>std::is_standard_layout</code>判断是否是类型是否是一个标准布局的类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;type_traits&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct SLayout1 &#123;&#125;;</span><br><span class="line"></span><br><span class="line">struct SLayout2 &#123;</span><br><span class="line">private: </span><br><span class="line">    int x;</span><br><span class="line">    int y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct SLayout3 : SLayout1 &#123;</span><br><span class="line">    int x;</span><br><span class="line">    int y;</span><br><span class="line">    void f(); </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct SLayout4 : SLayout1 &#123;</span><br><span class="line">    int x;</span><br><span class="line">    SLayout1 y; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct SLayout5 : SLayout1, SLayout3 &#123;&#125;;</span><br><span class="line"></span><br><span class="line">struct SLayout6 &#123; static int y; &#125;;</span><br><span class="line"></span><br><span class="line">struct SLayout7: SLayout6 &#123; int x; &#125;;</span><br><span class="line"></span><br><span class="line">struct NonSLayout1 : SLayout1 &#123;</span><br><span class="line">    SLayout1 x; </span><br><span class="line">    int i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct NonSLayout2 : SLayout2 &#123; int z; &#125;;</span><br><span class="line"></span><br><span class="line">struct NonSLayout3 : NonSLayout2 &#123;&#125;; </span><br><span class="line"></span><br><span class="line">struct NonSLayout4 &#123;</span><br><span class="line">public:</span><br><span class="line">    int x;</span><br><span class="line">private:</span><br><span class="line">    int y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    cout&lt;&lt;is_standard_layout&lt;SLayout1&gt;::value &lt;&lt; endl;  // 1</span><br><span class="line">    cout&lt;&lt;is_standard_layout&lt;SLayout2&gt;::value &lt;&lt; endl;  // 1</span><br><span class="line">    cout&lt;&lt;is_standard_layout&lt;SLayout3&gt;::value &lt;&lt; endl;  // 1</span><br><span class="line">    cout&lt;&lt;is_standard_layout&lt;SLayout4&gt;::value &lt;&lt; endl;  // 1</span><br><span class="line">    cout&lt;&lt;is_standard_layout&lt;SLayout5&gt;::value &lt;&lt; endl;  // 1</span><br><span class="line">    cout&lt;&lt;is_standard_layout&lt;SLayout6&gt;::value &lt;&lt; endl;  // 1</span><br><span class="line">    cout&lt;&lt;is_standard_layout&lt;SLayout7&gt;::value &lt;&lt; endl;  // 1</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;is_standard_layout&lt;NonSLayout1&gt;::value &lt;&lt; endl;   // 0</span><br><span class="line">    cout&lt;&lt;is_standard_layout&lt;NonSLayout2&gt;::value &lt;&lt; endl;   // 0</span><br><span class="line">    cout&lt;&lt;is_standard_layout&lt;NonSLayout3&gt;::value &lt;&lt; endl;   // 0</span><br><span class="line">    cout&lt;&lt;is_standard_layout&lt;NonSLayout4&gt;::value &lt;&lt; endl;   // 0</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过<code>std::is_pod</code>判断是否是类型是否是一个POD的类型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;type_traits&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">union U&#123;&#125;;</span><br><span class="line">union U1&#123; U1()&#123;&#125; &#125;;</span><br><span class="line">enum E&#123;&#125;;</span><br><span class="line">typedef double* DA;</span><br><span class="line">typedef void (*PF)(int, double);</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    cout &lt;&lt; is_pod&lt;U&gt;::value &lt;&lt; endl;   // 1</span><br><span class="line">    cout &lt;&lt; is_pod&lt;U1&gt;::value &lt;&lt; endl;  // 0</span><br><span class="line">    cout &lt;&lt; is_pod&lt;E&gt;::value &lt;&lt; endl;   // 1</span><br><span class="line">    cout &lt;&lt; is_pod&lt;int&gt;::value &lt;&lt; endl; // 1</span><br><span class="line">    cout &lt;&lt; is_pod&lt;DA&gt;::value &lt;&lt; endl;  // 1</span><br><span class="line">    cout &lt;&lt; is_pod&lt;PF&gt;::value &lt;&lt; endl;  // 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用pod的好处：</p>
<ul>
<li>方便的使用memset和memcpy进行初始化和拷贝</li>
<li>提供对C内存布局的兼容</li>
<li>保证了静态初始化的安全</li>
</ul>
<h2 id="受限非联合体"><a href="#受限非联合体" class="headerlink" title="受限非联合体"></a>受限非联合体</h2><p>C++98中并不是所有数据类型都能够成为union的数据成员，不允许联合体拥有非POD(Plain Old Data)、静态或引用类型的成员。 C++11中取消了联合体对于数据成员的限制，任何<strong>非引用类型</strong>都可以成为联合体的数据成员，成为非受限联合体。</p>
<p>C++98标准规定，联合体会自动对未在初始化成员列表中出现的成员赋默认初值。然而对于联合体而言，这种初始化常常会带来疑问，因为在任何时刻只有一个成员可以是有效的。如下示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">union T </span><br><span class="line">&#123; </span><br><span class="line">    int x;</span><br><span class="line">    double d;</span><br><span class="line">    char b[sizeof(double)];</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">T t = &#123; 0 &#125;; // 到底是初始化第一个成员还是所有成员呢?</span><br></pre></td></tr></table></figure></p>
<p>使用了花括号组成的初始化列表，试图将成员变量x初始化为零，即整个联合体的数据t中低位的4字节被初始化为0，然而实际上，t所占的8个字节将全部被置0。而在C++11中，为了减少这样的疑问，标准会默认删除一些非受限联合体的默认函数。</p>
<p>比如，非受限联合体有一个非POD的成员，而该非POD成员类型拥有非平凡的构造函数，那么非受限联合体成员的默认构造函数将被编译器删除。如下示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std; </span><br><span class="line"></span><br><span class="line">union T</span><br><span class="line">&#123; </span><br><span class="line">    string s; // string有非平凡的构造函数 </span><br><span class="line">    int n;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123; </span><br><span class="line">    T t; // 构造失败，因为T的构造函数被删除; ERROR:尝试引用已删除的函数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>联合体T拥有一个非POD的成员变量s。而string却有非平凡的构造函数，因此T的构造函数被删除，其类型的变量t也就无法声明成功。解决这个问题的办法：由程序员自己为非受限联合体定义构造函数。通常情况下，placement new会发挥很好的作用，改为如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std; </span><br><span class="line"></span><br><span class="line">union T</span><br><span class="line">&#123; </span><br><span class="line">    string s; // string有非平凡的构造函数 </span><br><span class="line">    int n;</span><br><span class="line">public:</span><br><span class="line">    T() &#123; new (&amp;s) string; &#125;  // 自定义构造函数</span><br><span class="line">    ~T() &#123; s.~string(); &#125;     // 自定义析构函数</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123; </span><br><span class="line">    T t; // 编译通过</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>自定义了union T的构造和析构函数。构造时，采用placement new将s构造在其地址&amp;s上。这里placement new的唯一作用只是调用了一下string的构造函数。而在析构时，又调用了string的析构函数。</p>
<p>匿名非受限联合体可以运用于类的声明中，这样的类也称为“枚举式的类”。如下示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct Student</span><br><span class="line">&#123;</span><br><span class="line">    Student(bool g, int a) : gender(g), age(a) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    bool gender;</span><br><span class="line">    int age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Singer</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    enum Type &#123; STUDENT, NATIVE, FOREIGNER &#125;;</span><br><span class="line">    Singer(bool g, int a) : s(g, a)</span><br><span class="line">    &#123;</span><br><span class="line">        t = STUDENT;</span><br><span class="line">    &#125;</span><br><span class="line">    Singer(int i) : id(i) </span><br><span class="line">    &#123;</span><br><span class="line">        t = NATIVE;</span><br><span class="line">    &#125;</span><br><span class="line">    Singer(const char* n, int s)</span><br><span class="line">    &#123;</span><br><span class="line">        int size = (s &gt; 9) ? 9 : s;</span><br><span class="line">        memcpy(name, n, size);</span><br><span class="line">        name[s] = &apos;\0&apos;;</span><br><span class="line">        t = FOREIGNER;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Singer() &#123;&#125;</span><br><span class="line">    void print()</span><br><span class="line">    &#123;</span><br><span class="line">        switch (t)</span><br><span class="line">        &#123;</span><br><span class="line">        case STUDENT:</span><br><span class="line">            cout &lt;&lt; &quot;s.gender: &quot; &lt;&lt; s.gender &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; &quot;s.age: &quot; &lt;&lt; s.age &lt;&lt; endl;</span><br><span class="line">            break;</span><br><span class="line">        case NATIVE:</span><br><span class="line">            cout &lt;&lt; &quot;id: &quot; &lt;&lt; id &lt;&lt; endl;</span><br><span class="line">            break;</span><br><span class="line">        case FOREIGNER:</span><br><span class="line">            cout &lt;&lt; &quot;name: &quot; &lt;&lt; name &lt;&lt; endl;</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    Type t;</span><br><span class="line">    union</span><br><span class="line">    &#123;</span><br><span class="line">        Student s;</span><br><span class="line">        int id;</span><br><span class="line">        char name[10];</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Singer objSer1(true, 13);</span><br><span class="line">    objSer1.print();</span><br><span class="line"></span><br><span class="line">    Singer objSer2(20200129);</span><br><span class="line">    objSer2.print();</span><br><span class="line"></span><br><span class="line">    Singer objSer3(&quot;kaizenliu&quot;, 9);</span><br><span class="line">    objSer3.print();</span><br><span class="line"></span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*运行结果</span><br><span class="line">s.gender: 1</span><br><span class="line">s.age: 13</span><br><span class="line">id: 20200129</span><br><span class="line">name: kaizenliu</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></p>
<p>把匿名非受限联合体成为类Singer的“变长成员”（variant member）。可以看到，这样的变长成员给类的编写带来了更大的灵活性。</p>
<h2 id="用户自定义字面量"><a href="#用户自定义字面量" class="headerlink" title="用户自定义字面量"></a>用户自定义字面量</h2><p>C++11可以通过定一个后缀标识的操作符，将声明了该后缀标识的字面量转换为需要的相应类型。如代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef unsigned char uint8;</span><br><span class="line"></span><br><span class="line">struct RGBA</span><br><span class="line">&#123;</span><br><span class="line">    uint8 r;</span><br><span class="line">    uint8 g;</span><br><span class="line">    uint8 b;</span><br><span class="line">    uint8 a;</span><br><span class="line">    RGBA(uint8 R, uint8 G, uint8 B, uint8 A = 0)</span><br><span class="line">        : r(R), g(G), b(B), a(A)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">RGBA operator &quot;&quot; _C(const char* col, size_t n)</span><br><span class="line">&#123;</span><br><span class="line">    const char* p = col;</span><br><span class="line">    const char* end = col + n;</span><br><span class="line">    const char* r, *g, *b, *a;</span><br><span class="line">    r = g = b = a = nullptr;</span><br><span class="line">    for (; p != end; ++p)</span><br><span class="line">    &#123;</span><br><span class="line">        if (*p == &apos;r&apos;) r = p;</span><br><span class="line">        else if (*p == &apos;g&apos;) g = p;</span><br><span class="line">        else if (*p == &apos;b&apos;) b = p;</span><br><span class="line">        else if (*p == &apos;a&apos;) a = p;</span><br><span class="line">    &#125;</span><br><span class="line">    if ((nullptr == r) || (nullptr == g) || (nullptr == b))</span><br><span class="line">    &#123;</span><br><span class="line">        throw;</span><br><span class="line">    &#125;</span><br><span class="line">    else if (nullptr == a)</span><br><span class="line">        return RGBA(atoi(r + 1), atoi(g + 1), atoi(b + 1));</span><br><span class="line">    else</span><br><span class="line">        return RGBA(atoi(r + 1), atoi(g + 1), atoi(b + 1), atoi(a + 1));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ostream&amp; operator&lt;&lt;(ostream&amp; out, RGBA&amp; col)</span><br><span class="line">&#123;</span><br><span class="line">    return out &lt;&lt; &quot;r: &quot; &lt;&lt; (int)col.r</span><br><span class="line">        &lt;&lt; &quot;, g: &quot; &lt;&lt; (int)col.g</span><br><span class="line">        &lt;&lt; &quot;, b: &quot; &lt;&lt; (int)col.b</span><br><span class="line">        &lt;&lt; &quot;, a: &quot; &lt;&lt; (int)col.a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void blend(RGBA &amp;&amp; col1, RGBA &amp;&amp; col2)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;blend &quot; &lt;&lt; endl &lt;&lt; col1 &lt;&lt; col2 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;    </span><br><span class="line">    blend(&quot;r255 g240 b155&quot;_C, &quot;r15 g255 b10 a7&quot;_C);</span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*运行结果</span><br><span class="line">blend</span><br><span class="line">r: 255, g: 240, b: 155, a: 0</span><br><span class="line">r: 15, g: 255, b: 10, a: 7</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></p>
<p>声明了一个字面量操作符（literal operator）函数:<code>RGBA operator&quot;&quot; _C(const char*col, size_t n)</code>函数。这个函数会解析以_C为后缀的字符串，并返回一个RGBA的临时变量。有了这样一个用户字面常量的定义，程序中不再需要通过声明RGBA类型的声明变量–传值运算的方式来传递实际意义上的常量。通过声明一个字符串以及一个_C后缀，<code>operator&quot;&quot;_C</code>函数会产生临时变量。blend函数就可以通过右值引用获得这些临时值并进行计算。</p>
<p>注意事项：</p>
<ul>
<li>在字面量操作符函数的声明中，operator””与用户自定义后缀之间必须有空格。</li>
<li>后缀建议以下划线开始。不宜使用非下划线后缀的用户自定义字符串常量，否则会被编译器警告。</li>
<li>C++11标准中要求声明字面量操作符有一定的规则，该规则跟字面量的“类型”密切相关。具体规则如下：<ul>
<li>如果字面量为整型数，那么字面量操作符函数只可接受unsigned long long或者const char*为其参数。</li>
<li>当unsigned long long无法容纳该字面量的时候，编译器会自动将该字面量转化为以\0为结束符的字符串，并调用以const char*为参数的版本进行处理。</li>
<li>如果字面量为浮点型数，则字面量操作符函数只可接受long double或者const char<em>为参数。const char</em>版本的调用规则同整型的一样（过长则使用const char*版本）。</li>
<li>如果字面量为字符串，则字面量操作符函数函数只可接受const char*, size_t为参数（已知长度的字符串）。</li>
<li>如果字面量为字符，则字面量操作符函数只可接受一个char为参数。</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">// 浮点数操作符</span><br><span class="line">long double operator&quot;&quot; _mm(long double x) &#123; return x / 1000; &#125;</span><br><span class="line">long double operator&quot;&quot; _m(long double x) &#123; return x; &#125;</span><br><span class="line">long double operator&quot;&quot; _km(long double x) &#123; return x * 1000; &#125;</span><br><span class="line"></span><br><span class="line">// 字符串操作符，第二个参数会自动推断为字符串的长度</span><br><span class="line">size_t operator&quot;&quot; _len(char const*, size_t n)</span><br><span class="line">&#123;</span><br><span class="line">    return n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 原始字面量操作符1</span><br><span class="line">char const* operator&quot;&quot; _r(char const* s)</span><br><span class="line">&#123;</span><br><span class="line">    return s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 原始字面量操作符2</span><br><span class="line">string operator&quot;&quot; _rs(char const* s)</span><br><span class="line">&#123;</span><br><span class="line">    return &apos;x&apos; + string(s) + &apos;y&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; 1.0_mm &lt;&lt; &apos;\n&apos;;  // 0.001</span><br><span class="line">    cout &lt;&lt; 1.0_m &lt;&lt; &apos;\n&apos;;   // 1</span><br><span class="line">    cout &lt;&lt; 1.0_km &lt;&lt; &apos;\n&apos;;  // 1000</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;ABCDEFGH&quot;_len &lt;&lt; &apos;\n&apos;; // 8</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; 12_r &lt;&lt; &apos;\n&apos;; // 12</span><br><span class="line">    cout &lt;&lt; 5_rs &lt;&lt; &apos;\n&apos;; // x5y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="内联命名空间"><a href="#内联命名空间" class="headerlink" title="内联命名空间"></a>内联命名空间</h2><p>C++引入了命名空间的概念，分割全局共享的命名空间，使用<code>空间名::函数/变量名</code>。C++11中引入了内联命名空间（inline namespace），它的特点就是不需要使用using语句就可以直接在外层命名空间使用该命名空间内部的内容，而且无需使用命名空间前缀。先看代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">namespace Jim &#123;</span><br><span class="line">    inline namespace Basic &#123;</span><br><span class="line">        struct Knife&#123; Knife() &#123; cout &lt;&lt; &quot;Knife in Basic.&quot; &lt;&lt; endl; &#125; &#125;;</span><br><span class="line">        class CorkScrew&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    inline namespace Toolkit &#123;</span><br><span class="line">        template&lt;typename T&gt; class SwissArmyKnife&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    // ...</span><br><span class="line">    namespace Other&#123;</span><br><span class="line">        Knife b;            // Knife in Basic</span><br><span class="line">        struct Knife&#123; Knife() &#123; cout &lt;&lt; &quot;Knife in Other&quot; &lt;&lt; endl;&#125; &#125;;</span><br><span class="line">        Knife c;            // Knife in Other </span><br><span class="line">        Basic::Knife k;     // Knife in Basic</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 这是LiLei在使用Jim的库</span><br><span class="line">namespace Jim &#123;</span><br><span class="line">    template&lt;&gt; class SwissArmyKnife&lt;Knife&gt;&#123;&#125;;   // 编译通过</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">using namespace Jim;</span><br><span class="line">int main() &#123;</span><br><span class="line">    SwissArmyKnife&lt;Knife&gt; sknife;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="模板的别名"><a href="#模板的别名" class="headerlink" title="模板的别名"></a>模板的别名</h2><p>使用关键字using作为别名声明来定义类型的别名，其后紧跟别名和等号。作用是把等号左侧的名字规定成等号右侧类型的别名。</p>
<p>（1）using用法与typedef相同点</p>
<p>代码示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;type_traits&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">using uint = unsigned int;</span><br><span class="line">typedef unsigned int UINT;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; is_same&lt;uint, UINT&gt;::value &lt;&lt; endl; // 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>（2）using与typedef不同点（优势）</p>
<p>由于模板不是一个类型，所以不能定义一个typedef引用一个模板，但是新标准允许使用using为类模板定义一个别名：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt; using twin = pair&lt;T, T&gt;;</span><br><span class="line">twin&lt;string&gt; authors;           // authors是一个pair&lt;string, string&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>我们介绍了C++11中共11个崭新特性。这些新特性都在着重于通用性的考量下，经过标准委员会反复揣摩而最终成型。</p>
<p>最为引人注目的就是右值引用。右值引用堪称是C++1中的一项重大的变革。这次的变革，是以暴露原本一直被C/C++掩盖得较好的左值右值关系为代价的。右值引用的理解会稍微复杂一些，但其目的却比较明确，就是实现所谓的移动语义。移动语义与在C++98中常见的拷贝语义在类的构造上采用了完全不同的方式。移动语义主要是将行将被释放的资源“偷”出来，作为行将构造的类型的资源。那么这势必就会跟变量生命周期产生关系，跟右值、临时量打上交道。而最终，C++11中又采用了右值引用的方式使得移动构造函数能够有效地获得这些右值临时量，以使程序员能够完成行为良好的移动语义。通过这样的移动语义，库的实现者可以巧妙地将各种形如堆内存的资源放入对象中，而不必担心在诸如函数传递的过程中带来过大的资源释放、申请开销。此外，标准制定者还趁<br>机利用了右值引用来实现了所谓的完美转发，从技术上讲，完美转发就是通过引用折叠规则和模板推导规则，使得转发函数在不损失任何数据属性的情况下，将数据完美地传递给其他函数。</p>
<p>在C++11中，标准则又重新回答了什么是简单的类型及什么是复杂的类型，即怎么才算得上是POD。POD的概念分为平凡的和标准布局两个概念。标准布局强调了类型的数据在排布上是简单的，比如可以通过memcpy拷贝的简单类型。而平凡的则强调了类型没有复杂的构造、析构或者多态等看起来“不平凡”的行为。</p>
<p>另外一个新引入的改动则是列表初始化。相比于C++98中的赋值表达式和值初始化，列表初始化主要被实现为标准库中的initializer_list，使得用户不仅可以列表式地初始化内置类型、数组、STL容器，还可以对自定义类型进行列表初始化。这应该是C++标准中第一次出现与库实现结合得如此紧密的语言特性。而列表初始化相对于老式的初始化，对总是容易出错的类型收窄做了限制。总的说来，无论从使用的方便性还是安全性上讲，列表初始化都表现出了优良的特性，也是C++核心语言进步的一种体现。</p>
<p>两种新的构造函数的声明方式，继承构造函数和委派构造数，则都使得程序员能够在编写构造函数中少写一些代码。前者我们将关注点放在了继承结构下使用using关键字将构造函数继承上，而后者，我们则把目光放在了单类型中多个构造函数间通过初始化列表的相互委托关系上。</p>
<p>而用户自定义字面量将C++中的各种重载再一次强化。通过后缀，用户可以将程序中非内置的几乎所有的字面量据为己用，产生自己的类型。同样地，这会减<br>少C++11代码的书写量。另外一个简化，则是using的“泛化”，using关键字已经能够像typedef一样定义别名，且其在模板中使用起来更佳。</p>
<p>此外，我们还介绍了能够避免意外的显式类型转换，以及能为类产生变长成员的非受限联合体。内联的名字空间则是用于库发布的一个特性，通过将子名字空间的名字导入父名字空间，用户可以方便地使用名字空间的名字。不过名字空间的内联也导致名字空间对名字封装的失效。因此通常情况下，这个特性都会结合宏一起使用。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/C/" rel="tag"># C++</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/03/28/一致性算法Paxos_Raft_ZAB/" rel="next" title="一致性算法（Paxos、Raft、ZAB）">
                <i class="fa fa-chevron-left"></i> 一致性算法（Paxos、Raft、ZAB）
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/04/04/深入理解cpp11_新特性解析与应用_笔记2/" rel="prev" title="深入理解C++11_新特性解析与应用 笔记2">
                深入理解C++11_新特性解析与应用 笔记2 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/header.jpg" alt="Hao Yu">
            
              <p class="site-author-name" itemprop="name">Hao Yu</p>
              <p class="site-description motion-element" itemprop="description">Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author</p>
          </div>
          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">334</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>
        	<audio controls="controls" loop="loop" preload="auto" src="/resource/xiaomeihao.mp3">
	        </audio>
	

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yuhao0102" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:yuh18@mails.tsinghua.edu.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#新标准的诞生"><span class="nav-number">1.</span> <span class="nav-text">新标准的诞生</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#C-的变化"><span class="nav-number">1.1.</span> <span class="nav-text">C++的变化</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#保证稳定性和兼容性"><span class="nav-number">2.</span> <span class="nav-text">保证稳定性和兼容性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#保持与C99兼容"><span class="nav-number">2.1.</span> <span class="nav-text">保持与C99兼容</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#预定义宏"><span class="nav-number">2.1.1.</span> <span class="nav-text">预定义宏</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#func-预定义标识符"><span class="nav-number">2.1.2.</span> <span class="nav-text">__func__预定义标识符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Pragma操作符"><span class="nav-number">2.1.3.</span> <span class="nav-text">_Pragma操作符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#变长参数的宏定义以及-VA-ARGS"><span class="nav-number">2.1.4.</span> <span class="nav-text">变长参数的宏定义以及 VA_ARGS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#宽窄字符串的连接"><span class="nav-number">2.1.5.</span> <span class="nav-text">宽窄字符串的连接</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#long-long-整型"><span class="nav-number">2.2.</span> <span class="nav-text">long long 整型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#扩展的整型"><span class="nav-number">2.3.</span> <span class="nav-text">扩展的整型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#宏-cplusplus"><span class="nav-number">2.4.</span> <span class="nav-text">宏__cplusplus</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#静态断言"><span class="nav-number">2.5.</span> <span class="nav-text">静态断言</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#断言：运行时与预处理时"><span class="nav-number">2.5.1.</span> <span class="nav-text">断言：运行时与预处理时</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#静态断言与static-assert"><span class="nav-number">2.5.2.</span> <span class="nav-text">静态断言与static_assert</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#noexcept修饰符与noexcept操作符"><span class="nav-number">2.6.</span> <span class="nav-text">noexcept修饰符与noexcept操作符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#快速初始化成员变量"><span class="nav-number">2.7.</span> <span class="nav-text">快速初始化成员变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#非静态成员的sizeof"><span class="nav-number">2.8.</span> <span class="nav-text">非静态成员的sizeof</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#扩展的friend语法"><span class="nav-number">2.9.</span> <span class="nav-text">扩展的friend语法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#final-override控制"><span class="nav-number">2.10.</span> <span class="nav-text">final/override控制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#模板函数的默认模板参数"><span class="nav-number">2.11.</span> <span class="nav-text">模板函数的默认模板参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#外部模板"><span class="nav-number">2.12.</span> <span class="nav-text">外部模板</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#局部和匿名类型作模板实参"><span class="nav-number">2.13.</span> <span class="nav-text">局部和匿名类型作模板实参</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#通用为本，专用为末"><span class="nav-number">3.</span> <span class="nav-text">通用为本，专用为末</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#继承构造函数"><span class="nav-number">3.1.</span> <span class="nav-text">继承构造函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#委派构造函数"><span class="nav-number">3.2.</span> <span class="nav-text">委派构造函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#右值引用：移动语义和完美转发"><span class="nav-number">3.3.</span> <span class="nav-text">右值引用：移动语义和完美转发</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#移动语义"><span class="nav-number">3.3.1.</span> <span class="nav-text">移动语义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#完美转发"><span class="nav-number">3.3.2.</span> <span class="nav-text">完美转发</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#显式转换操作符"><span class="nav-number">3.4.</span> <span class="nav-text">显式转换操作符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#列表初始化"><span class="nav-number">3.5.</span> <span class="nav-text">列表初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#初始化列表"><span class="nav-number">3.5.1.</span> <span class="nav-text">初始化列表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#防止类型收窄"><span class="nav-number">3.5.2.</span> <span class="nav-text">防止类型收窄</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#POD类型"><span class="nav-number">3.6.</span> <span class="nav-text">POD类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#受限非联合体"><span class="nav-number">3.7.</span> <span class="nav-text">受限非联合体</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#用户自定义字面量"><span class="nav-number">3.8.</span> <span class="nav-text">用户自定义字面量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内联命名空间"><span class="nav-number">3.9.</span> <span class="nav-text">内联命名空间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#模板的别名"><span class="nav-number">3.10.</span> <span class="nav-text">模板的别名</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#小结"><span class="nav-number">3.11.</span> <span class="nav-text">小结</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>
  <div id="DvelopmentTarget">     
  </div>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart" aria-hidden="false"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>

  
</div>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_uv"> 
  本站访客数<span id="busuanzi_value_site_uv"></span>人次
</span>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  


  <script type="text/javascript" src="/js/src/love.js"></script>

</body>
</html>
