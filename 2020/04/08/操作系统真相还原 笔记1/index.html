<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zn-ch">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-center-simple.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="操作系统,">










<meta name="description" content="一些你可能正感到迷惑的问题软件是如何访问硬件的硬件在输入输出上大体分为串行和并行，相应的接口也就是串行接口和并行接口。CPU通过串行接口与串行设备数据传输。并行设备的访问类似，只不过是通过并行接口进行的。访问外部硬件有两个方式：  将某个外设的内存映射到一定范围的地址空间中，CPU通过地址总线访问该内存区域时会落到外设的内存中，这种映射让CPU 访问外设的内存就如同访问主板上的物理内存一样。 外设">
<meta name="keywords" content="操作系统">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统真相还原">
<meta property="og:url" content="http://yoursite.com/2020/04/08/操作系统真相还原 笔记1/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="一些你可能正感到迷惑的问题软件是如何访问硬件的硬件在输入输出上大体分为串行和并行，相应的接口也就是串行接口和并行接口。CPU通过串行接口与串行设备数据传输。并行设备的访问类似，只不过是通过并行接口进行的。访问外部硬件有两个方式：  将某个外设的内存映射到一定范围的地址空间中，CPU通过地址总线访问该内存区域时会落到外设的内存中，这种映射让CPU 访问外设的内存就如同访问主板上的物理内存一样。 外设">
<meta property="og:locale" content="zn-ch">
<meta property="og:image" content="http://yoursite.com/img/20200416151400.png">
<meta property="og:image" content="http://yoursite.com/img/20200416151600.jpg">
<meta property="og:image" content="http://yoursite.com/img/1587022334.jpg">
<meta property="og:image" content="http://yoursite.com/img/1587022380.jpg">
<meta property="og:image" content="http://yoursite.com/img/1587024090.jpg">
<meta property="og:image" content="http://yoursite.com/img/20200527154000.png">
<meta property="og:image" content="http://yoursite.com/img/1590576073.jpg">
<meta property="og:image" content="http://yoursite.com/img/1590578903.jpg">
<meta property="og:image" content="http://yoursite.com/img/1590584080.jpg">
<meta property="og:image" content="http://yoursite.com/img/1590585314.jpg">
<meta property="og:updated_time" content="2020-05-27T13:30:26.359Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="操作系统真相还原">
<meta name="twitter:description" content="一些你可能正感到迷惑的问题软件是如何访问硬件的硬件在输入输出上大体分为串行和并行，相应的接口也就是串行接口和并行接口。CPU通过串行接口与串行设备数据传输。并行设备的访问类似，只不过是通过并行接口进行的。访问外部硬件有两个方式：  将某个外设的内存映射到一定范围的地址空间中，CPU通过地址总线访问该内存区域时会落到外设的内存中，这种映射让CPU 访问外设的内存就如同访问主板上的物理内存一样。 外设">
<meta name="twitter:image" content="http://yoursite.com/img/20200416151400.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/04/08/操作系统真相还原 笔记1/">





  <title>操作系统真相还原 | Hao Yu's blog</title>
  








 
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zn-ch">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hao Yu's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">The program monkey was eaten by the siege lion.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-mybetterhalf">
          <a href="/mybetterhalf/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>
            
            mybetterhalf
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="Searching..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/08/操作系统真相还原 笔记1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">操作系统真相还原</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-04-08T19:13:00+08:00">
                2020-04-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="一些你可能正感到迷惑的问题"><a href="#一些你可能正感到迷惑的问题" class="headerlink" title="一些你可能正感到迷惑的问题"></a>一些你可能正感到迷惑的问题</h1><h2 id="软件是如何访问硬件的"><a href="#软件是如何访问硬件的" class="headerlink" title="软件是如何访问硬件的"></a>软件是如何访问硬件的</h2><p>硬件在输入输出上大体分为串行和并行，相应的接口也就是串行接口和并行接口。CPU通过串行接口与串行设备数据传输。并行设备的访问类似，只不过<br>是通过并行接口进行的。访问外部硬件有两个方式：</p>
<ul>
<li>将某个外设的内存映射到一定范围的地址空间中，CPU通过地址总线访问该内存区域时会落到外设的内存中，这种映射让CPU 访问外设的内存就如同访问主板上的物理内存一样。</li>
<li>外设是通过IO接口与CPU通信的，CPU访问外设，就是访问IO接口，由IO接口将信息传递给另一端的外设。</li>
</ul>
<h2 id="应用程序操作系统是如何配合到一起的"><a href="#应用程序操作系统是如何配合到一起的" class="headerlink" title="应用程序操作系统是如何配合到一起的"></a>应用程序操作系统是如何配合到一起的</h2><p>编译器提供了一套库函数，库函数中又有封装的系统调用，这样的代码集合称之为运行库。C 语言的运行库称为C 运行库，就是所谓的CRT（C Runtime Library）。</p>
<p>用户态与内核态是对CPU 来讲的，是指CPU 运行在用户态（特权3 级）还是内核态（特权0 级）。用户进程陷入内核态是指：<strong>由于内部或外部中断发生，当前进程被暂时终止执行，其上下文被内核的中断程序保存起来后，开始执行一段内核的代码</strong>，所以“用户态与内核态”是对CPU 来说的。</p>
<h2 id="为什么称为“陷入”内核"><a href="#为什么称为“陷入”内核" class="headerlink" title="为什么称为“陷入”内核"></a>为什么称为“陷入”内核</h2><p>应用程序处于特权级3，操作系统内核处于特权级0。当用户程序欲访问系统资源时（无论是硬件，还是内核数据结构），它需要进行系统调用。这样CPU 便进入了内核态，也称管态。</p>
<h2 id="内存访问为什么要分段"><a href="#内存访问为什么要分段" class="headerlink" title="内存访问为什么要分段"></a>内存访问为什么要分段</h2><p>内存是随机读写设备，即访问其内部任何一处，不需要从头开始找，只要直接给出其地址便可。CPU 采用“段基址+段内偏移地址”的方式来访问任意内存。这<br>样的好处是程序可以重定位了，尽管程序指令中给的是绝对物理地址，但终究可以同时运行多个程序了。<strong>重定位</strong>就是将程序中指令的地址改写成另外一个地址，但该地址处的内容还是原地址处的内容。</p>
<p>只要程序分了段，把整个段平移到任何位置后，段内的地址相对于段基址是不变的，无论段基址是多少，只要给出段内偏移地址，CPU 就能访问到正确的指令。于是加载用户程序时，只要将整个段的内容复制到新的位置，再将段基址寄存器中的地址改成该地址，程序便可准确无误地运行，因为程序中用的是段内偏移地址，相对于新的段基址，该偏移地址处的内存内容还是一样的。</p>
<h2 id="代码中为什么分为代码段、数据段？"><a href="#代码中为什么分为代码段、数据段？" class="headerlink" title="代码中为什么分为代码段、数据段？"></a>代码中为什么分为代码段、数据段？</h2><p>分段只是为了使程序更加优美。如果是在<strong>平坦模型</strong>下编程，操作系统将整个4GB 内存都放在同一个段中，我们就不需要来回切换段寄存器所指向的段。对于代码中是否要分段，这取决于操作系统是否在平坦模型下。</p>
<p>指令间不存在空隙，下一条指令的地址是按照前面指令的尺寸大小排下来的，这就是Intel 处理器的程序计数器cs：eip能够自动获得下一条指令的原理，即将当前eip 中的地址加上当前指令机器码的大小便是内存中下一条指令的起始地址。为了让程序内指令接连不断地执行，要把指令全部排在一起，形成一片连续的指令区域，这就是代码段。把数据连续地并排在一起存储形成的段落，就称为数据段。</p>
<p>只要指令逻辑上是连续的就可以，没必要一定得是物理上连续。所以，明确一点，即使数据和代码在物理上混在一起，程序也是可以运行的，这并不意味<br>着指令被数据“断开”了。只要程序中有指令能够跨过这些数据就行啦，最典型的就是用jmp 跳过数据区。</p>
<p>在保护模式下，有这样一个数据结构，它叫全局描述符表（Global Descriptor Table，GDT），这个表中的每一项称为段描述符。编译器负责挑选出数据具备的属性，从而根据属性将程序片段分类，比如，划分出了只读属性的代码段和可写属性的数据段。操作系统通过设置GDT 全局描述符表来构建段描述符，在段描述符中指定段的位置、大小及属性（包括S 字段和TYPE 字段）。CPU 中的段寄存器提前被操作系统赋予相应的选择子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">section my_code vstart=0</span><br><span class="line">;通过远跳转的方式给代码段寄存器CS 赋值0x90</span><br><span class="line">jmp 0x90:start</span><br><span class="line">start: ;标号start 只是为了jmp 跳到下一条指令</span><br><span class="line">;初始化数据段寄存器DS</span><br><span class="line">mov ax,section.my_data.start</span><br><span class="line">add ax,0x900 ;加0x900 是因为本程序会被mbr 加载到内存0x900 处</span><br><span class="line">shr ax,4 ;提前右移4 位,因为段基址会被CPU 段部件左移4 位</span><br><span class="line">mov ds,ax</span><br><span class="line"></span><br><span class="line">;初始化栈段寄存器SS</span><br><span class="line">mov ax,section.my_stack.start</span><br><span class="line">add ax,0x900 ;加0x900 是因为本程序会被mbr 加载到内存0x900 处</span><br><span class="line">shr ax,4 ;提前右移4 位,因为段基址会被CPU 段部件左移4 位</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,stack_top ;初始化栈指针</span><br><span class="line"></span><br><span class="line">;此时CS､DS､SS 段寄存器已经初始化完成,下面开始正式工作</span><br><span class="line">push word [var2] ;变量名var2 编译后变成0x4</span><br><span class="line">jmp $</span><br><span class="line"></span><br><span class="line">;自定义的数据段</span><br><span class="line">section my_data align=16 vstart=0</span><br><span class="line">var1 dd 0x1</span><br><span class="line">var2 dd 0x6</span><br><span class="line"></span><br><span class="line">;自定义的栈段</span><br><span class="line">section my_stack align=16 vstart=0</span><br><span class="line">times 128 db 0</span><br><span class="line">stack_top: ;此处用于栈顶,标号作用域是当前section,</span><br><span class="line">;以当前section 的vstart 为基数</span><br></pre></td></tr></table></figure></p>
<p>代码是实模式下运行的程序，其中自定义了三个段，代码段取名为my_code，数据段取名为my_data，栈段取名为my_stack。用“jmp 0x90：0”初始化了程序计数器CS 和IP。这样段寄存器CS 就是程序中咱们自己划分的代码段了。各section 中的定义都有align=16 和vstart=0，这是用来指定各section 按16 位对齐的，第 6～10 行是初始化数据段寄存器DS，是用程序中自已划分的段my_data 的地址来初始化的。第 12～17 行是初始化栈段寄存器，原理和数据段差不多，唯一区别是栈段初始化多了个针指针SP，为它初始化的值stack_top 是最后一行，因为栈指针在使用过程中指向的地址越来越低，所以初始化时一<br>定得是栈段的最高地址。</p>
<h2 id="物理地址、逻辑地址、有效地址、线性地址、虚拟地址的区别"><a href="#物理地址、逻辑地址、有效地址、线性地址、虚拟地址的区别" class="headerlink" title="物理地址、逻辑地址、有效地址、线性地址、虚拟地址的区别"></a>物理地址、逻辑地址、有效地址、线性地址、虚拟地址的区别</h2><p>物理地址就是物理内存真正的地址，相当于内存中每个存储单元的门牌号，具有唯一性。在实模式下，“段基址+段内偏移地址”经过段部件的处理，直接输出的就是物理地址，CPU 可以直接用此地址访问内存。</p>
<p>而在保护模式下，“段基址+段内偏移地址”称为<strong>线性地址</strong>，不过，此时的段基址已经不再是真正的地址了，而是一个称为<strong>选择子</strong>的东西。它本质是个索引，类似于数组下标，通过这个索引便能在GDT 中找到相应的段描述符，在该描述符中记录了该段的起始、大小等信息，这样便得到了段基址。</p>
<p>若没有开启地址分页功能，此线性地址就被当作物理地址来用，可直接访问内存。若开启了分页功能，此线性地址又多了一个名字，就是<strong>虚拟地址</strong>（虚拟地址、线性地址在分页机制下都是一回事）。虚拟地址要经过CPU 页部件转换成具体的物理地址，这样CPU 才能将其送上地址总线去访问内存。</p>
<p>无论在实模式或是保护模式下，段内偏移地址又称为有效地址，也称为逻辑地址。线性地址或称为虚拟地址，这都不是真实的内存地址。它们都用来描述程序或任务的地址空间。<br><img src="/img/20200416151400.png" alt></p>
<h2 id="什么是段重叠"><a href="#什么是段重叠" class="headerlink" title="什么是段重叠"></a>什么是段重叠</h2><p>CPU 的内存寻址方式是：给我一个段基址，再给我一个相对于该段起始位置的偏移地址，我就能访问到相应内存。它并不要求一个内存地址只隶属于某一个段。用段A 去访问，其偏移为5，用段B 去访问，其偏移量为3。这样一来，用段B 和段A 在地址0xC02 之后，一直到段B偏移地址为0xfffe 的部分，像是重叠在一起了，这就是段重叠了。<br><img src="/img/20200416151600.jpg" alt></p>
<h2 id="什么是平坦模型"><a href="#什么是平坦模型" class="headerlink" title="什么是平坦模型"></a>什么是平坦模型</h2><p>所以说平坦模型指的就是一个段。段的大小可以是地址总线能够到达的范围。</p>
<h2 id="cs、ds-这类sreg-段寄存器，位宽是多少"><a href="#cs、ds-这类sreg-段寄存器，位宽是多少" class="headerlink" title="cs、ds 这类sreg 段寄存器，位宽是多少"></a>cs、ds 这类sreg 段寄存器，位宽是多少</h2><p>CPU 内部的段寄存器（Segment reg）如下：</p>
<ol>
<li>CS—代码段寄存器（Code Segment Register），其值为代码段的段基值。</li>
<li>DS—数据段寄存器（Data Segment Register），其值为数据段的段基值。</li>
<li>ES—附加段寄存器（Extra Segment Register），其值为附加数据段的段基值，称为“附加”是因为此段寄存器用途不像其他sreg 那样固定，可以额外做他用。</li>
<li>FS—附加段寄存器（Extra Segment Register），其值为附加数据段的段基值，同上，用途不固定，使用上灵活机动。</li>
<li>GS—附加段寄存器（Extra Segment Register），其值为附加数据段的段基值。</li>
<li>SS—堆栈段寄存器（Stack Segment Register），其值为堆栈段的段值。</li>
</ol>
<p>在实模式下，CS、DS、ES、SS 中的值为段基址，是具体的物理地址，内存单元的逻辑地址仍为“段基值：段内偏移量”的形式。在保护模式下，装入段寄存器的不再是段地址，而是“段选择子”（Selector），当然，选择子也是数值，其依然为16 位宽度。</p>
<h2 id="什么是工程，什么是协议"><a href="#什么是工程，什么是协议" class="headerlink" title="什么是工程，什么是协议"></a>什么是工程，什么是协议</h2><p>软件中的工程是指开发一套软件所需要的全部文件，包括配置环境。</p>
<p>协议是一种大家共同遵守的规约，主要用来实现通信、共享、协作，给大家统一一种接口、一组数据调用或者分析的约定。</p>
<h2 id="局部变量和函数参数为什么要放在栈中"><a href="#局部变量和函数参数为什么要放在栈中" class="headerlink" title="局部变量和函数参数为什么要放在栈中"></a>局部变量和函数参数为什么要放在栈中</h2><p>局部变量只是自己在用，放在数据段中纯属浪费空间，没有必要，故将其放在自己的栈中，随时可以清理，真正体现了局部的意义。</p>
<p>堆是程序运行过程中用于动态内存分配的内存空间，是操作系统为每个用户进程规划的，属于软件范畴。栈是处理器运行必备的内存空间，是硬件必需的，但又是由软件（操作系统）提供的。</p>
<p><strong>栈从高地址往低地址发展，堆是从低地址往高地址发展</strong>，堆和栈早晚会碰头，它们各自的大小取决于实际的使用情况，界限并不明朗。</p>
<h2 id="编译型程序与解释型程序的区别"><a href="#编译型程序与解释型程序的区别" class="headerlink" title="编译型程序与解释型程序的区别"></a>编译型程序与解释型程序的区别</h2><p>解释型语言，也称为脚本语言，本身是文本文件，是某个应用程序的输入，这个应用程序是脚本解释器。由于只是文本，这些脚本中的代码在脚本解释器看来和字符串无异。也就是说，脚本中的代码从来没真正上过CPU 去执行，CPU 的cs：ip 寄存器从来没指向过它们，在CPU 眼里只看得到脚本解释器</p>
<p>本质上是脚本解释器在时时分析这个脚本，动态根据关键字和语法来做出相应的行为。因此脚本中若出现错误，先前正确的部分也会被正常执行，这和编译型程序有很大区别。</p>
<p>编译型语言编译出来的程序，运行时本身就是一个进程。它是由操作系统直接调用的。也就是由操作系统加载到内存后，操作系统将CS：IP 寄存器指向这个程序的入口，使它直接上CPU 运行。</p>
<h2 id="什么是大端字节序、小端字节序"><a href="#什么是大端字节序、小端字节序" class="headerlink" title="什么是大端字节序、小端字节序"></a>什么是大端字节序、小端字节序</h2><ol>
<li>小端：因为低位在低字节，强制转换数据型时不需要再调整字节了。</li>
<li>大端：有符号数，其字节最高位不仅表示数值本身，还起到了符号的作用。符号位固定为第一字节，也就是最高位占据最低地址，符号直接可以取出来，容易判断正负。</li>
</ol>
<p>简要说明一下小端的优势。因为在做强制数据类型转换时，如果转换是由低精度转向高精度，这数值本身没什么变化，如short 是2 字节，将其转换为4 字节的int 类型，无非是由0x1234 变成了0x00001234，数值上是不变的，只是存储形式上变了。如果转换是高精度转向低精度，也就是多个字节的数值要减少一<br>些存储字节，这必然是要丢弃一部分数值。编译器的转换原则是强制转换到低精度类型，丢弃数值的高字节位，只保留数值的低字节。</p>
<p>对于大端的优势，就硬件而言，就是符号位的判断变得方便了。最高位在最低地址，也就是直接就可以取到了，不用再跨越几个字节，减少了时钟周期。</p>
<h2 id="BIOS-中断、DOS-中断、Linux-中断的区别"><a href="#BIOS-中断、DOS-中断、Linux-中断的区别" class="headerlink" title="BIOS 中断、DOS 中断、Linux 中断的区别"></a>BIOS 中断、DOS 中断、Linux 中断的区别</h2><p>BIOS 和DOS 都是存在于实模式下的程序，由它们建立的中断调用都是建立在中断向量表（Interrupt Vector Table，IVT）中的。它们都是通过软中断指令int 中断号来调用的。</p>
<p>中断向量表中的每个中断向量大小是4 字节。这4 字节描述了一个中断处理例程（程序）的段基址和段内偏移地址。BIOS 中断调用的主要功能是提供了硬件访问的方法，该方法使对硬件的操作变得简单易行。BIOS 中断程序处理是用来操作硬件的，故该处理程序中一定到处都是in/out 指令。</p>
<p>DOS 是运行在实模式下的，故其建立的中断调用也建立在中断向量表中，只不过其中断向量号和BIOS的不能冲突。</p>
<p>而 Linux 内核是在进入保护模式后才建立中断例程的，不过在保护模式下，中断向量表已经不存在了，取而代之的是<strong>中断描述符表</strong>（Interrupt Descriptor Table，IDT）。所以在Linux 下执行的中断调用，访问的中断例程是在<strong>中断描述符表</strong>中，已不在中断向量表里了。Linux 的系统调用和DOS 中断调用类似，不过Linux 是通过int 0x80 指令进入一个中断程序后再根据eax 寄存器的值来调用不同的子功能函数的。</p>
<h2 id="Section-和Segment-的区别"><a href="#Section-和Segment-的区别" class="headerlink" title="Section 和Segment 的区别"></a>Section 和Segment 的区别</h2><p>在汇编源码中，通常用语法关键字 section 或segment 来表示一段区域，它们是编译器提供的伪指令，作用是相同的，都是在程序中“逻辑地”规划一段区域，此区域便是节。操作系统在加载程序时，不需要对逐个节进行加载，只要给出相同权限的节的集合就行了，这样操作系统就能为它们分配不同的段选择子，从而指向不同段描述符，实现不同的访问权限了。</p>
<p>section 称为节，是指在汇编源码中经由关键字section 或segment 修饰、逻辑划分的指令或数据区域，汇编器会将这两个关键字修饰的区域在目标文件中编译成节，也就是说“节”最初诞生于目标文件中。</p>
<p>segment 称为段，是链接器根据目标文件中属性相同的多个section 合并后的section 集合，这个集合称为segment，也就是段，链接器把目标文件链接成可执行文件，因此段最终诞生于可执行文件中。我们平时所说的可执行程序内存空间中的代码段和数据段就是指的segment。<br><img src="/img/1587022334.jpg" alt><br><img src="/img/1587022380.jpg" alt></p>
<p>Program Headers 部分，此处一共有两个段，第一个段是我们的代码段，通过其Flg 值为RE 便可推断，只读（Readonly）可执行（Execute）。第二个段便是我们的数据段，但此数据段中只包含.bss 节（section），它用于存储全局未初始化数据故其Flg 必然可读写，其属性为RW。</p>
<h2 id="操作系统是如何识别文件系统的"><a href="#操作系统是如何识别文件系统的" class="headerlink" title="操作系统是如何识别文件系统的"></a>操作系统是如何识别文件系统的</h2><p>各分区都有超级块，一般位于本分区的第2 个扇区，比如若各分区的扇区以0 开始索引，其第1 个扇区便是超级块的起始扇区。超级块里面记录了此分区的信息，其中就有文件系统的魔数，一种文件系统对应一个魔数。</p>
<h2 id="如何控制-CPU-的下一条指令"><a href="#如何控制-CPU-的下一条指令" class="headerlink" title="如何控制 CPU 的下一条指令"></a>如何控制 CPU 的下一条指令</h2><p>我们常说的用于存放下一条指令地址的寄存器称为程序计数器PC。在 x86 体系结构的CPU 中程序计数器PC 并不是单一的某种寄存器，它是一种寄存器组合，指的段寄存器CS 和指令寄存器IP。CS 和IP 是CPU 待执行的下一条指令的段基址和段内偏移地址，不能直接用mov 指令去改变它们。有专门改变执行流的指令，如jmp、call、int、ret，这些指令可以同时修改cs 和ip，它们在硬件级别上实现了原子操作。</p>
<h2 id="库函数是用户进程与内核的桥梁"><a href="#库函数是用户进程与内核的桥梁" class="headerlink" title="库函数是用户进程与内核的桥梁"></a>库函数是用户进程与内核的桥梁</h2><p>例如对printf的声明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extern int printf (__const char *__restrict __format,...);</span><br></pre></td></tr></table></figure></p>
<p>头文件被包含进来后，其内容也是原样被展开到include 所在的位置，就是把整个头文件中的内容挪了过来。头文件中一般仅仅有函数声明，这个声明告诉编译器至少两件事。</p>
<ol>
<li>函数返回值类型、参数类型及个数，用来确定分配的栈空间。</li>
<li>该函数是外部函数，定义在其他文件，现在无法为其分配地址，需要在链接阶段将该函数体所在的目标文件一同链接时再安排地址。</li>
</ol>
<p>如果预处理后，主调函数所在的文件中找不到所调用函数的函数体，一定要在链接阶段把该函数体所在的目标文件链接进来。编译器提供的C 运行库中已经为我们准备好了这些标准函数的函数体所在的目标文件，在链接时默默帮我们链接上了。这些目标文件都是待重定位文件，重定位文件意思是文件中的函数是没有地址的，用file 命令查看它们时会显示relocatable，它们中的地址是在与用户程序的目标文件链接成一个可执行文件时由链接器统一分配的。</p>
<h2 id="MBR、EBR、DBR-和OBR-各是什么"><a href="#MBR、EBR、DBR-和OBR-各是什么" class="headerlink" title="MBR、EBR、DBR 和OBR 各是什么"></a>MBR、EBR、DBR 和OBR 各是什么</h2><p>MBR 是主引导记录，Master 或Main Boot Record，它存在于整个硬盘最开始的那个扇区，即0盘0道1扇区，这个扇区便称为MBR 引导扇区。在 MBR 引导扇区中存储引导程序，为的是从BIOS 手中接过系统的控制权，。BIOS 知道MBR 在0 盘0 道1 扇区，这是约定好的，因此它会将0 盘0 道1 扇区中的MBR 引<br>导程序加载到物理地址0x7c00，然后跳过去执行，这样BIOS 就把处理器使用权移交给MBR 了。在 MBR 引导扇区中的内容是：</p>
<ol>
<li>446 字节的引导程序及参数；</li>
<li>64 字节的分区表；</li>
<li>2 字节结束标记0x55 和0xaa。</li>
</ol>
<p>MBR 的作用相当于下一棒的引导程序总入口，BIOS 把控制权交给MBR 就行了，由MBR 从众多可能的接力选手中挑出合适的人选并交出系统控制权，这个过程就是由“主引导程序”去找“次引导程序”。MBR 引导程序的任务就是把控制权交给操作系统加载器，由该加载器完成操作系统的自举，最终使控制权交付给操作系统内核。</p>
<p>为了让 MBR 知道哪里有操作系统，我们在分区时，如果想在某个分区中安装操作系统，就用分区工具将该分区设置为活动分区，设置活动分区的本质就是把分区表中该分区对应的分区表项中的活动标记为0x80。</p>
<p>“控制权交接”是处理器从“上一棒选手”跳到“下一棒选手”来完成的，内核加载器的入口地址是这里所说的“下一棒选手”，为了MBR 方便找到活动分区上的内核加载器，内核加载器的入口地址也必须在固定的位置，这个位置就是各分区最开始的扇区，这也是约定好的。这个“各分区起始的扇区”中存放的是操作系统<br>引导程序—内核加载器，因此该扇区称为<strong>操作系统引导扇区</strong>，其中的引导程序（内核加载器）称为<strong>操作系统引导记录OBR</strong>，即OS Boot Record，此扇区也称为OBR 引导扇区。在OBR 扇区的前3 个字节存放了跳转指令，这同样是约定，因此MBR 找到活动分区后，就大胆主动跳到活动分区OBR 引导扇区的起始处，该起始处的跳转指令马上将处理器带入操作系统引导程序，从此MBR 完成了交接工作，以后便是内核的天下了。</p>
<p>DBR 是DOS Boot Record，也就是DOS 操作系统的引导记录（程序）。在 DOS 时代只有4 个分区，不存在扩展分区，这4 个分区都相当于主分区，所以各主分区最开始的扇区称为DBR 引导扇区。</p>
<p>这里提到了扩展分区就不得不提到EBR。当初为了解决分区数量限制的问题才有了扩展分区，EBR是扩展分区中为了兼容MBR 才提出的概念，主要是兼容MBR 中的分区表。为扩展分区存储分区表的扇区称为EBR，即Expand Boot Record，</p>
<p>MBR 和EBR 是分区工具创建维护的，不属于操作系统管理的范围，因此操作系统不可以往里面写东西。OBR 是各分区（主分区或逻辑分区）最<br>开始的扇区，因此属于操作系统管理。DBR、OBR、MBR、EBR 都包含引导程序，因此它们都称为引导扇区，只要该扇区中存在可执行的程序，该扇区就是可引导扇区。若该扇区位于整个硬盘最开始的扇区，并且以0x55 和0xaa 结束，BIOS就认为该扇区中存在MBR，该扇区就是MBR 引导扇区。<br><img src="/img/1587024090.jpg" alt></p>
<h1 id="部署工作环境"><a href="#部署工作环境" class="headerlink" title="部署工作环境"></a>部署工作环境</h1><h2 id="我们需要哪些编译器"><a href="#我们需要哪些编译器" class="headerlink" title="我们需要哪些编译器"></a>我们需要哪些编译器</h2><p>NASM 是一个为可移植性与模块化而设计的一个<strong>80x86的汇编器</strong>。它支持相当多的目标文件格式，包括’Linux’和’NetBSD/FreeBSD’，’a.out’，’ELF’，’COFF’，微软16位的’OBJ’和’Win32’。它还可以输出纯二进制文件。它的语法设计得相当的简洁易懂，和Intel语法相似但更简单。它支持’Pentium’，’P6’，’MMX’，’3DNow!’，’SSE’和’SSE2’指令集。</p>
<h1 id="编写MBR-主引导记录，让我们开始掌权"><a href="#编写MBR-主引导记录，让我们开始掌权" class="headerlink" title="编写MBR 主引导记录，让我们开始掌权"></a>编写MBR 主引导记录，让我们开始掌权</h1><h2 id="计算机的启动过程"><a href="#计算机的启动过程" class="headerlink" title="计算机的启动过程"></a>计算机的启动过程</h2><p>CPU 的硬件电路被设计成只能运行处于内存中的程序。因此，OS需要被载入内存中，大概上分两部分。</p>
<ol>
<li>程序被加载器（软件或硬件）加载到内存某个区域。</li>
<li>CPU 的cs：ip 寄存器被指向这个程序的起始地址。</li>
</ol>
<p>操作系统在加载程序时，是需要某个加载器来将用户程序存储到内存中的。其实“加载器”本质上它就是一堆函数组成的模块。</p>
<h2 id="软件接力第一棒，BIOS"><a href="#软件接力第一棒，BIOS" class="headerlink" title="软件接力第一棒，BIOS"></a>软件接力第一棒，BIOS</h2><p>BIOS全称叫<code>Base Input &amp; Output System</code>，即基本输入输出系统。</p>
<h3 id="实模式下的1MB内存布局"><a href="#实模式下的1MB内存布局" class="headerlink" title="实模式下的1MB内存布局"></a>实模式下的1MB内存布局</h3><p>Intel 8086有20条地址线，故其可以访问1MB的内存空间，即2的20次方=1048576=1MB，地址范围是0x00000到0xFFFFF。下表是实模式下1MB内存布局。<br><img src="/img/20200527154000.png" alt></p>
<p>地址0～0x9FFFF处是DRAM（Dynamic Random Access Memory），即<strong>动态随机访问内存</strong>，我们所装的物理内存就是DRAM，如DDR、DDR2 等。动态指<strong>此种存储介质需要定期地刷新</strong>，它的空间范围是640KB，这片地址对应到了DRAM，也就是插在主板上的内存条。</p>
<p>地址总线宽度决定了可以访问的内存空间大小，如16位机的地址总线为20位，其地址范围是1MB，但是并不是只有内存条需要通过地址总线访问，需要在地址总线上提前预留出来一些地址空间给其他外设用，留够了以后，地址总线上其余的可用地址再指向DRAM，也就是指插在主板上的内存条，所以地址总线的长度与DRAM的大小不同。</p>
<p>顶部的0xF0000～0xFFFFF，这64KB的内存是<strong>ROM</strong>，这里面存的就是BIOS的代码。BIOS还建立了中断向量表，这样就可以通过<code>int 中断号</code>来实现相关的硬件调用，当然BIOS建立的这些功能就是对硬件的IO操作，也就是输入输出，加上一些重要的、保证计算机能运行的那些硬件的基本IO操作，就行了。这就是BIOS称为基本输入输出系统的原因。</p>
<p><strong>BIOS被写进ROM</strong>。ROM也是块内存，内存就需要被访问。此ROM被映射在低端1MB内存的顶部，即地址0xF0000～0xFFFFF处。<strong>只要访问此处的地址便是访问了BIOS，这个映射是由硬件完成的。</strong>BIOS本身是个程序，程序要执行，就要有个入口地址才行，此入口地址便是<code>0xFFFF0</code>。</p>
<p>CPU访问内存是用<code>段地址+偏移地址</code>来实现的，由于<strong>在实模式之下，段地址需要乘以16后才能与偏移地址相加，求出的和便是物理地址</strong>，CPU便拿此地址直接用了。在接电的一瞬间，<code>CPU的cs:ip寄存器被强制初始化为0xF000:0xFFF0</code>。由于开机的时候处于实模式，在实模式下的段基址要乘以16，也就是左移4位，于是<code>0xF000:0xFFF0</code>的等效地址将是<code>0xFFFF0</code>，此地址便是BIOS的入口地址。物理地址0xFFFF0处应该是指令，否则会出错，里面有条指令<code>jmp far f000:e05b</code>，这是条跳转指令，也就是证明了在内存物理地址0xFFFF0处的内容是一条跳转指令。</p>
<p>BIOS最后一项工作校验启动盘中位于0盘0道1扇区的内容。<code>0盘0道1扇区本质上就相当于0盘0道0扇区</code>。CHS方法（即柱面Cylinder磁头Header扇区Sector，另外一种是LBA 方式，暂不关心），<code>0盘</code>说的是<code>0磁头</code>，因为一张盘是有上下两个盘面的，一个盘面上对应一个磁头，所以用<code>磁头Header</code>来表示盘面。<code>0道</code>是指<code>0柱面</code>，柱面Cylinder指的是所有盘面上、编号相同的磁道的集合。在<code>CHS方式中扇区的编号是从1开始的</code>，它就是磁盘上最开始的那个扇区。如果此扇区末尾的两个字节分别是魔数<code>0x55</code>和<code>0xaa</code>，BIOS便认为此扇区中确实存在可执行的程序，便<code>加载到物理地址0x7c00</code>，随后跳转到此地址，继续执行。</p>
<blockquote>
<p>8086CPU要求物理地址<code>0x0～0x3FF</code>存放中断向量表，所以此处不能动了；按 DOS 1.0 要求的最小内存32KB来说，MBR希望给人家尽可能多的预留空间，所以MBR只能放在32KB的末尾；MBR本身也是程序，是程序就要用到栈，估计1KB内存够用了。结合以上三点，选择32KB中的最后1KB最为合适，32KB换算为十六进制为0x8000，减去1KB(0x400)的话，等于0x7c00。这就是倍受质疑的0x7c00 的由来。</p>
</blockquote>
<h2 id="让-MBR-先飞一会儿"><a href="#让-MBR-先飞一会儿" class="headerlink" title="让 MBR 先飞一会儿"></a>让 MBR 先飞一会儿</h2><p><code>$</code>和<code>$$</code>是编译器NASM 预留的关键字，用来表示当前行和本section的地址，起到了标号的作用。汇编语言中的标号是程序员“显式地”写在明处的，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">code_start：</span><br><span class="line">mov ax， 0</span><br></pre></td></tr></table></figure></p>
<p><code>code_start</code>这个标号被nasm认为是一个地址，此地址便是<code>mov ax, 0</code>这条指令所在的地址，即其指令机器码存放的内存位置是<code>code_start</code>。<code>code_start</code>只是个标记，CPU并不认识，nasm会用为其安排的地址来替换标号code_start，到了CPU手中，已经被替换为有意义的数字形式的地址了。</p>
<p><code>$</code>属于“隐式地”藏在本行代码前的标号，也就是<code>编译器给当前行安排的地址</code>，看不到却又无处不在，<code>$</code>在每行都有。如果上面的例子改为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">code_start：</span><br><span class="line">jmp $</span><br></pre></td></tr></table></figure></p>
<p>这就和<code>jmp code_start</code>是等效的。<code>$</code>和<code>code_start</code>是同一个值。</p>
<p><code>$$</code>指代<strong>本section的起始地址</strong>，此地址同样是编译器给安排的。默认情况下，它们的值是相对于本文件开头的偏移量。如果该section用了<code>vstart=xxxx</code>修饰，<code>$$</code>的值则是此section的虚拟起始地址xxxx。<code>$</code>的值是以xxxx为起始地址的顺延。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">;主引导程序</span><br><span class="line">;------------------------------------------------------------</span><br><span class="line">SECTION MBR vstart=0x7c00</span><br><span class="line">mov ax,cs</span><br><span class="line">mov ds,ax</span><br><span class="line">mov es,ax</span><br><span class="line">mov ss,ax</span><br><span class="line">mov fs,ax</span><br><span class="line">mov sp,0x7c00</span><br><span class="line"></span><br><span class="line">; 清屏利用0x06号功能,上卷全部行,则可清屏｡</span><br><span class="line">; -----------------------------------------------------------</span><br><span class="line">;INT 0x10 功能号:0x06 功能描述:上卷窗口</span><br><span class="line">;------------------------------------------------------</span><br><span class="line">;输入:</span><br><span class="line">;AH 功能号= 0x06</span><br><span class="line">;AL = 上卷的行数(如果为0,表示全部)</span><br><span class="line">;BH = 上卷行属性</span><br><span class="line">;(CL,CH) = 窗口左上角的(X,Y)位置</span><br><span class="line">;(DL,DH) = 窗口右下角的(X,Y)位置</span><br><span class="line">;无返回值:</span><br><span class="line">mov ax, 0x600</span><br><span class="line">mov bx, 0x700</span><br><span class="line">mov cx, 0 ; 左上角: (0, 0)</span><br><span class="line">mov dx, 0x184f ; 右下角: (80,25),</span><br><span class="line">; VGA 文本模式中,一行只能容纳80个字符,共25行｡</span><br><span class="line">; 下标从0 开始,所以0x18=24,0x4f=79</span><br><span class="line">int 0x10 ; int 0x10</span><br><span class="line"></span><br><span class="line">;;;;;;;;; 下面这三行代码获取光标位置 ;;;;;;;;;</span><br><span class="line">;.get_cursor 获取当前光标位置,在光标位置处打印字符｡</span><br><span class="line">mov ah, 3 ; 输入: 3 号子功能是获取光标位置,需要存入ah 寄存器</span><br><span class="line">mov bh, 0 ; bh 寄存器存储的是待获取光标的页号</span><br><span class="line"></span><br><span class="line">int 0x10 ; 输出: ch=光标开始行,cl=光标结束行</span><br><span class="line">; dh=光标所在行号,dl=光标所在列号</span><br><span class="line"></span><br><span class="line">;;;;;;;;; 获取光标位置结束 ;;;;;;;;;;;;;;;;</span><br><span class="line"></span><br><span class="line">;;;;;;;;; 打印字符串 ;;;;;;;;;;;</span><br><span class="line">;还是用10h 中断,不过这次调用13 号子功能打印字符串</span><br><span class="line">mov ax, message</span><br><span class="line">mov bp, ax ; es:bp 为串首地址,es 此时同cs 一致,</span><br><span class="line">; 开头时已经为sreg 初始化</span><br><span class="line"></span><br><span class="line">; 光标位置要用到dx 寄存器中内容,cx 中的光标位置可忽略</span><br><span class="line">mov cx, 5 ; cx 为串长度,不包括结束符0 的字符个数</span><br><span class="line">mov ax, 0x1301 ;子功能号13 显示字符及属性,要存入ah 寄存器,</span><br><span class="line">; al 设置写字符方式 ah=01: 显示字符串,光标跟随移动</span><br><span class="line">mov bx, 0x2 ; bh 存储要显示的页号,此处是第0 页,</span><br><span class="line">; bl 中是字符属性,属性黑底绿字(bl = 02h)</span><br><span class="line">int 0x10 ; 执行BIOS 0x10 号中断</span><br><span class="line">;;;;;;;;; 打字字符串结束 ;;;;;;;;;;;;;;;</span><br><span class="line"></span><br><span class="line">jmp $ ; 使程序悬停在此</span><br><span class="line"></span><br><span class="line">message db &quot;1 MBR&quot;</span><br><span class="line">times 510-($-$$) db 0</span><br><span class="line">db 0x55,0xaa</span><br></pre></td></tr></table></figure>
<p>代码功能为：<strong>在屏幕上打印字符串“1 MBR”</strong>，背景色为黑色，前景色为绿色。</p>
<ul>
<li>第3行的<code>vstart=0x7c00</code>表示本程序在编译时，告诉编译器，把我的起始地址编译为0x7c00。</li>
<li>第4～8行是用cs寄存器的值去初始化其他寄存器。由于BIOS是通过<code>jmp 0:0x7c00</code>跳转到MBR的，故cs此时为0。对于ds、es、fs、gs这类sreg，CPU中不能直接给它们赋值，没有从立即数到段寄存器的电路实现，只有通过其他寄存器来中转，这里我们<code>用的是通用寄存器ax来中转</code>。</li>
<li>第9行是<code>初始化栈指针</code>，在CPU上运行的程序得遵从CPU的规则，mbr也是程序，是程序就要用到栈。目前0x7c00以下暂时是安全的区域，就把它当作栈来用。</li>
<li>第11～28行是清屏。这里也演示了BIOS中断<code>int 0x10</code>的用法。</li>
<li>第30～35行是做打印前的工作，先获取光标位置，目的是避免打印字符混乱，覆盖别人的输出。这里还用到了页的概念，往bh寄存器中写入了0，这是告诉BIOS例程，我要获取第0页当前的光标。</li>
<li>第38～52行是往光标处打印字符。说一下第48行的<code>mov ax, 0x1301</code>，13对应的是ah寄存器，这是调用0x13号子功能。01对应的是al寄存器，表示的是写字符方式，其低2位才有意义，各位功能描述如下：<ul>
<li>al=0，显示字符串，并且光标返回起始位置。</li>
<li>al=1，显示字符串，并且光标跟随到新位置。</li>
<li>al=2，显示字符串及其属性，并且光标返回起始位置。</li>
<li>al=3，显示字符串及其属性，光标跟随到新位置。</li>
</ul>
</li>
<li>第55行执行了个死循环，$是本行指令的地址，这属于伪指令，是汇编器在编译期间分配的地址。在最终编译出来的程序中，$会被替换为指令实际所在行的地址。jmp是个近跳转，$是jmp自己的地址，于是跳到自己所在的地址再执行自己，又是跳到自己所在的地址再继续执行跳转</li>
<li>第57行是定义打印的字符串。</li>
<li>第58行的<code>$$</code>是指本section的起始地址，上面说过了$是本行所在的地址，故$-$$是本行到本section的偏移量。由于MBR的最后两个字节是固定的内容，分别是0x55和0xaa，要预留出这2个字节，故本扇区内前512-2=510字节要填满，第50行的<code>times 510-($-$$) db 0</code>是在用0将本扇区剩余空间填充。</li>
</ul>
<h1 id="完善MBR"><a href="#完善MBR" class="headerlink" title="完善MBR"></a>完善MBR</h1><h2 id="地址、section、vstart-浅尝辄止"><a href="#地址、section、vstart-浅尝辄止" class="headerlink" title="地址、section、vstart 浅尝辄止"></a>地址、section、vstart 浅尝辄止</h2><p>本质上，程序中各种数据结构的访问，就是通过<code>该数据结构的起始地址＋该数据结构所占内存的大小</code>来实现的。数据的地址，其实就是<code>该数据相对整个程序开头的距离</code>，即偏移量。<br><img src="/img/1590576073.jpg" alt></p>
<ul>
<li>第1行的mov指令，$$表示的是所在的section的起始地址，由于这6 行代码中没有定义section，故nasm 默认把全体文件当成一个大的section，全体文件自然偏移地址为0，所以在反汇编代码那列中，起始地址$$被置换为0。</li>
<li>第2行代码是真指令，不牵涉到符号转换，所以反汇编后的代码同源码一致。</li>
<li>第3行引用了var变量的值，[]符号是取所在地址处的内容。在相应的反汇编代码中，相应的第三行中var这个符号地址被编译器替换为<code>0xd</code>。结合地址列查看一下内容列，地址为0xd 的内容为99，这正是var 的值。</li>
<li>第4行源码为<code>label: mov ax, $</code>，label是个标号，代表指令<code>mov ax, $</code>所在地址。$是个隐式的标号，表示当前行地址。</li>
<li>第5行的<code>jmp label</code>编译后被替换为<code>jmp short 0x8</code>，这是短跳转指令，地址为8处的内容是第4行的<code>mov ax, $</code>，同样吻合。</li>
<li>第 6 行的便是数据定义了，定义了双字节变量<code>var</code>，其值为99。在内容处的第6行可知，内容为99，与源码定义吻合。</li>
</ul>
<p>“地址”列中的数字和“内容”列中的内容有这样一种关系：地址等于上一个地址+上一个地址处的内容的长度。例如地址列第二行的3等于“上一个地址0”+“上一个地址 0 处的内容：B80000 的长度3”，以此类推。<strong>编译器给程序中各符号（变量名或函数名等）分配的地址，就是各符号相对于文件开头的偏移量。</strong></p>
<h2 id="CPU-的实模式"><a href="#CPU-的实模式" class="headerlink" title="CPU 的实模式"></a>CPU 的实模式</h2><p>实模式是指<strong>8086 CPU 的寻址方式、寄存器大小、指令用法等，是用来反应CPU 在该环境下如何工作的概念</strong>。CPU 大体上可以划分为3 个部分，它们是<strong>控制单元</strong>、<strong>运算单元</strong>、<strong>存储单元</strong>。<strong>控制单元</strong>是 CPU 的控制中心，CPU 需要经过它的帮忙才知道自己下一步要做什么。而控制单元大致由<strong>指令寄存器IR</strong>（Instruction Register）、<strong>指令译码器ID</strong>（Instruction Decoder）、<strong>操作控制器OC</strong>（Operation Controller）组成。</p>
<p>程序被加载到内存后，<strong>指令指针寄存器IP指向内存中下一条待执行指令的地址</strong>，控制单元根据IP寄存器的指向，将位于内存中的指令逐个装载到指令寄存器中。然后指令译码器将位于指令寄存器中的指令按照指令格式来解码，分析出操作码是什么，操作数在哪里之类的。</p>
<p>存储单元是指CPU内部的L1、L2缓存及寄存器，待处理的数据就存放在这些存储单元中。寄存器可分为两大类，程序员可以使用的寄存器称为程序可见寄存器，如通用寄存器、段寄存器。程序不可见寄存器是指程序员不可使用，也无法访问到它们，系统运行期间可能要用到寄存器。</p>
<p>运算单元负责算术运算（加减乘除）和逻辑运算（比较、移位），它从控制单元那里接收命令（信号）并执行，它没有自主意识，只是个执行部件。<br><img src="/img/1590578903.jpg" alt></p>
<p>CPU 中的寄存器大致上分为两大类。</p>
<ul>
<li>一类是其内部使用的，程序员不能使用。我们无法使用一些寄存器，比如全局描述符表寄存器GDTR、中断描述符表寄存器IDTR、局部描述符表寄存器LDTR、<br>任务寄存器TR、控制寄存器CR0～3、指令指针寄存器IP、标志寄存器flags、调试寄存器DR0～7。</li>
<li>另一类是对程序员可见的寄存器。我们进行汇编语言程序设计时，能够直接操作的就是这些寄存器，如段寄存器、通用寄存器。</li>
</ul>
<p>上面提到的“段基址：段内偏移地址”中的段基址，就是用段寄存器来存储的，<strong>段寄存器的作用就是指定一片内存的起始地址，故也称为段基址寄存器</strong>。尽管段基址在实模式下要乘以16，在保护模式下只是个选择子（保护模式中会讲），但其作用就是指定一片内存的起始地址。而段内偏移地址，顾名思义，仅仅相对于此起始地址的偏移量。</p>
<p>访问内存就要提供地址，初次访问内存时，该地址肯定不能用内存本身来存，用寄存器来存储内存地址。由于要指定的是内存中的一段区域的起始地址，所以称之为段基址寄存器，也称段寄存器，无论是在实模式下，还是保护模式下，它们都是16位宽。</p>
<ul>
<li>代码段把<strong>所有指令都连续排放在一起，形成了一个全部都是指令的区域</strong>，里面存储的是指令的操作码及寻址方式等。代码段寄存器CS就是用来指向内存中这段指令区域的起始地址。</li>
<li>数据段和代码段类似，只是这段区域存储的是程序运行所需要的数据，属于指令的操作数。数据段寄存器DS便是用来指向此数据区域的起始地址。</li>
<li>栈段是在内存中，硬盘文件中可真没有。一般的栈段是由操作系统分配指定的，所以是属于被加载到内存后才有的。栈段寄存器SS 就是用来指向此区域的起始地址。</li>
<li><p>值得说明的是在16 位CPU 中，只有一个附加段寄存器ES。而FS和GS附加段寄存器是在32 位CPU 中增加的。</p>
</li>
<li><p>IP寄存器是不可见寄存器，CS寄存器是可见寄存器。这两个配合在一起后就是CPU的罗盘。访问内存就要用“段：段内偏移”的形式，所以CS 寄存器用来存代码段段基址，IP 寄存器用来存储代码段段内偏移地址，同CS 寄存器一样都是16 位宽。</p>
</li>
<li>flags 寄存器是计算机的窗口，展示了CPU 内部各项设置、指标。任何一个指令的执行、其执行过程的细节、对计算机造成了哪些影响，都在flags 寄存器中通过一些标志位反映出来。</li>
<li>无论是实模式，还是保护模式，通用寄存器有8 个，分别是AX、BX、CX、DX、SI、DI、BP、SP。</li>
</ul>
<p><img src="/img/1590584080.jpg" alt></p>
<p>拿AX寄存器举例，根据图3-6可知，AX寄存器是由AH寄存器和AL寄存器组成的，它们都是8位寄存器，AX寄存器的低8位是AL寄存器。高8位是AH寄存器。由于某种原因，16位AX寄存器不够用了，将其扩展（Extend）为32位，在AX原有的基础上，增加16位作为高16位便是扩展的AX，即EAX。所以EAX归根结底也是由AL、AH组成的，AL或AH值变了直接影响EAX。</p>
<p>以上的这8个寄存器实际上是通用寄存器，通用是说每个寄存器的功能不单一，可以有多种用途，不像段寄存器SS那样只能用来放栈段基址，通用寄存器可以用来保存任何数据。一般情况下，cx寄存器用作循环的次数控制，bx寄存器用于存储起始地址。<br><img src="/img/1590585314.jpg" alt></p>
<h3 id="实模式下内存分段的由来"><a href="#实模式下内存分段的由来" class="headerlink" title="实模式下内存分段的由来"></a>实模式下内存分段的由来</h3><p>有了保护模式后，为了与老的模式区别开来，所以称老的模式为<strong>实模式</strong>。实模式的“实”体现在：<strong>程序中用到的地址都是真实的物理地址</strong>，“段基址：段内偏移”产生的逻辑地址就是物理地址，也就是程序员看到的完全是真实的内存。</p>
<p>为了让16位的寄存器寻址能够访问20位的地址空间，CPU 工程师定位到根本瓶颈是在段寄存器，它要是能提供20位的段地址，哪怕偏移地址是1也照样可以访问到内存的各个角落。于是，通过<strong>先把16位的段基址左移4位后变成20位，再加段内偏移地址，这样便形成了20位地址</strong>，只要保证了段基址是20位的，偏移地址是多少位都不关心了，从而突破了16位寄存器作为偏移地址而无法访问1MB空间的限制。</p>
<p>拿 0xFFFF 来说，现在能访问的最大的地址是0xFFFF：0xFFFF，经过左移段基址4位后得到的最大地址是：<code>0xFFFF * 16 + 0xFFFF = 0xFFFF0 + 0xFFFF = 0xFFFFF + 0xFFF0 = 1M + 16 * 4KB - 16 - 1 = 0x10FFEF</code>。得到的最大地址是<code>1MB+64KB-16</code>字节，因为这是空间范围，所以要减去1得到地址范围。多出来64K-16 字节，这部分内存就是传说中的高端内存区，但是这部分内存不存在。所以由于超过了20位而产生的进位，就给丢掉了。其作用相当于把地址对1MB取模了。</p>
<h3 id="实模式下CPU-内存寻址方式"><a href="#实模式下CPU-内存寻址方式" class="headerlink" title="实模式下CPU 内存寻址方式"></a>实模式下CPU 内存寻址方式</h3><p>下面把8086的寻址模式和大家说说。寻址方式，从大方向来看可以分为三大类：</p>
<ul>
<li>寄存器寻址；</li>
<li>立即数寻址；</li>
<li>内存寻址。<ul>
<li>直接寻址；</li>
<li>基址寻址；</li>
<li>变址寻址；</li>
<li>基址变址寻址。</li>
</ul>
</li>
</ul>
<p>寄存器寻址：最直接的寻址方式就是寄存器寻址，它是指“数”在寄存器中，直接从寄存器中拿数据就行了。例如下面用mul 指令实现0x10*0x9。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax, 0x10</span><br><span class="line">mov dx, 0x9</span><br><span class="line">mul dx</span><br></pre></td></tr></table></figure></p>
<p>以上三条指令都是寄存器寻址。第一条命令是将<code>0x10</code>存入ax寄存器，第二条命令是将<code>0x9</code>存入dx，第三条指令是求ax和dx的乘积，乘积的高16位在dx寄存器，低16位在ax寄存器。只要牵扯到寄存器的操作，无论其是源操作数，还是目的操作数，都是寄存器寻址。上面的第一、二条指令，它们的源操作数都是立即数，所以也属于立即数寻址。</p>
<p>立即数寻址：如果操作数“直接”存在指令中，直接拿过来，立即就能用了。为了突显“立即就能用”的高效率，此数便称为立即数。立即数免去了找数的过程。如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0x18</span><br><span class="line">mov ds, ax</span><br></pre></td></tr></table></figure></p>
<p>第一条指令中的源操作数0x18是立即数，目的操作数ax是寄存器，所以它既是立即数寻址，也是寄存器寻址。第二条指令中，源操作数和目的操作数都是寄存器，所以纯粹是寄存器寻址。提醒一下，像这样的寻址也是立即数寻址：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax, macro_selector</span><br><span class="line">mov ax, label_start</span><br></pre></td></tr></table></figure></p>
<p>第一条指令的源操作数<code>macro_selector</code>是个宏，第二条指令的源操作数<code>label_start</code>是个标号，这两个在编译阶段会转换为数字，最终可执行文件中的依然是立即数。</p>
<p>内存寻址：操作数在内存中的寻址方式称为内存寻址。<strong>大多数时候操作数位于内存中的某个位置，只知道操作数所在的内存地址，不知道操作数的值，更谈不上将其变成立即数用在指令中了，这就更加有理由让内存寻址成为“应该”</strong>。由于访问内存是用“段基址：偏内偏移地址”的形式，此形式只用在内存访问中。默认情况下数据段寄存器是DS，即段基址已经有了，只要再给出段内偏移地址就可以访问内存了，<strong>最终起决定作用的、有效的是段内偏移地址</strong>，所以段内偏移地址称为有效地址。以下所说的寻址方法都是在内存中寻址的方法。</p>
<p>直接寻址，就是将直接在操作数中给出的数字作为内存地址，通过中括号的形式告诉CPU，取此地址中的值作为操作数。如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax, [0x1234]</span><br><span class="line">mov ax, [fs:0x5678]</span><br></pre></td></tr></table></figure></p>
<p>0x1234 是段内偏移地址，默认的段地址是DS。这条指令是将内存地址<code>DS:0x1234</code>处的值写入ax寄存器。第二条指令中，由于使用了段跨越前缀<code>fs, 0x5678</code>的段基址则变成了gs寄存器。最终的内存地址是gs寄存器的值<code>*16+0x5678</code>，CPU到此内存地址取值再存入ax寄存器。</p>
<p>基址寻址，就是<strong>在操作数中用bx寄存器或寄存器作为地址的起始，地址的变化以它为基础</strong>。注意看啦，这里说的是<strong>只能用bx 或bp 作为基址寄存器</strong>。用寄存器作为内存寻址，到了保护模式下就没这个限制了，基址寄存器可选择的很多。说明一下，bx 寄存器的默认段寄存器是DS，而bp 寄存器的默认段寄存器是SS，即bp 和sp 都是栈的有效地址。</p>
<p>sp 寄存器作为栈顶指针，相当于栈中数据的游标，这是专门给push 指令和pop 指令做导航用的寄存器，push 指令往哪个内存压入数据，popd 将哪个地址的数据弹出栈，都要看sp 的值是多少。在实模式下，CPU 字长是16，所以实模式下的push 指令默认情况下是压入2 字节的数据，其工作原理可以分为两步，假如执行push ax：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sub sp，2 先将sp 的值减去</span><br><span class="line">mov sp，ax 再将ax 的值mov 加到新的sp 指向的内存</span><br></pre></td></tr></table></figure></p>
<p>实模式下 pop 指令，其工作原理也分为两步，假如执行pop ax：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax， [sp] 先将sp 指向的值mov 到</span><br><span class="line">add sp，2 再将sp 的指针+2</span><br></pre></td></tr></table></figure></p>
<p>访问栈有两种方式，一种是把栈当成“栈”来使用，也就是用push 和pop 指令操作栈，但这样我们只能访问到栈顶，即sp 指向的地址，没有办法直接访问到栈底和栈顶之间的数据。很多时候，我们需要读写栈中的数据，即需要把栈当成普通数据段那样访问。<strong>举个需要直接写栈的例子，比如标志寄存器eflags 无法直接修改，只能用pushf 指令把eflags 寄存器的内容压到栈中，我们在栈中修改完后，再用popf 把它弹回到eflags 中</strong>。处理器为了让开发人员方便控制栈中数据，提供了这种把栈当成数据段来访问的方式，可以用寄存器bp 来给出栈中偏移量，所以bp 默认的段寄存器就是SS，这样就可通过SS：bp 的方式把栈当成普通的数据段来访问。</p>
<p>92！</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/操作系统/" rel="tag"># 操作系统</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/04/06/深入理解cpp11_新特性解析与应用_笔记3/" rel="next" title="深入理解C++11_新特性解析与应用 笔记3">
                <i class="fa fa-chevron-left"></i> 深入理解C++11_新特性解析与应用 笔记3
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/04/10/cpp的rvo/" rel="prev" title="C++ RVO">
                C++ RVO <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/header.jpg" alt="Hao Yu">
            
              <p class="site-author-name" itemprop="name">Hao Yu</p>
              <p class="site-description motion-element" itemprop="description">Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author</p>
          </div>
          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">238</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>
        	<audio controls="controls" loop="loop" preload="auto" src="/resource/xiaomeihao.mp3">
	        </audio>
	

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yuhao0102" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:yuh18@mails.tsinghua.edu.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#一些你可能正感到迷惑的问题"><span class="nav-number">1.</span> <span class="nav-text">一些你可能正感到迷惑的问题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#软件是如何访问硬件的"><span class="nav-number">1.1.</span> <span class="nav-text">软件是如何访问硬件的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#应用程序操作系统是如何配合到一起的"><span class="nav-number">1.2.</span> <span class="nav-text">应用程序操作系统是如何配合到一起的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么称为“陷入”内核"><span class="nav-number">1.3.</span> <span class="nav-text">为什么称为“陷入”内核</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内存访问为什么要分段"><span class="nav-number">1.4.</span> <span class="nav-text">内存访问为什么要分段</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#代码中为什么分为代码段、数据段？"><span class="nav-number">1.5.</span> <span class="nav-text">代码中为什么分为代码段、数据段？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#物理地址、逻辑地址、有效地址、线性地址、虚拟地址的区别"><span class="nav-number">1.6.</span> <span class="nav-text">物理地址、逻辑地址、有效地址、线性地址、虚拟地址的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是段重叠"><span class="nav-number">1.7.</span> <span class="nav-text">什么是段重叠</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是平坦模型"><span class="nav-number">1.8.</span> <span class="nav-text">什么是平坦模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#cs、ds-这类sreg-段寄存器，位宽是多少"><span class="nav-number">1.9.</span> <span class="nav-text">cs、ds 这类sreg 段寄存器，位宽是多少</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是工程，什么是协议"><span class="nav-number">1.10.</span> <span class="nav-text">什么是工程，什么是协议</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#局部变量和函数参数为什么要放在栈中"><span class="nav-number">1.11.</span> <span class="nav-text">局部变量和函数参数为什么要放在栈中</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#编译型程序与解释型程序的区别"><span class="nav-number">1.12.</span> <span class="nav-text">编译型程序与解释型程序的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是大端字节序、小端字节序"><span class="nav-number">1.13.</span> <span class="nav-text">什么是大端字节序、小端字节序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BIOS-中断、DOS-中断、Linux-中断的区别"><span class="nav-number">1.14.</span> <span class="nav-text">BIOS 中断、DOS 中断、Linux 中断的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Section-和Segment-的区别"><span class="nav-number">1.15.</span> <span class="nav-text">Section 和Segment 的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#操作系统是如何识别文件系统的"><span class="nav-number">1.16.</span> <span class="nav-text">操作系统是如何识别文件系统的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何控制-CPU-的下一条指令"><span class="nav-number">1.17.</span> <span class="nav-text">如何控制 CPU 的下一条指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#库函数是用户进程与内核的桥梁"><span class="nav-number">1.18.</span> <span class="nav-text">库函数是用户进程与内核的桥梁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MBR、EBR、DBR-和OBR-各是什么"><span class="nav-number">1.19.</span> <span class="nav-text">MBR、EBR、DBR 和OBR 各是什么</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#部署工作环境"><span class="nav-number">2.</span> <span class="nav-text">部署工作环境</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#我们需要哪些编译器"><span class="nav-number">2.1.</span> <span class="nav-text">我们需要哪些编译器</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#编写MBR-主引导记录，让我们开始掌权"><span class="nav-number">3.</span> <span class="nav-text">编写MBR 主引导记录，让我们开始掌权</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#计算机的启动过程"><span class="nav-number">3.1.</span> <span class="nav-text">计算机的启动过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#软件接力第一棒，BIOS"><span class="nav-number">3.2.</span> <span class="nav-text">软件接力第一棒，BIOS</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#实模式下的1MB内存布局"><span class="nav-number">3.2.1.</span> <span class="nav-text">实模式下的1MB内存布局</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#让-MBR-先飞一会儿"><span class="nav-number">3.3.</span> <span class="nav-text">让 MBR 先飞一会儿</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#完善MBR"><span class="nav-number">4.</span> <span class="nav-text">完善MBR</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#地址、section、vstart-浅尝辄止"><span class="nav-number">4.1.</span> <span class="nav-text">地址、section、vstart 浅尝辄止</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CPU-的实模式"><span class="nav-number">4.2.</span> <span class="nav-text">CPU 的实模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#实模式下内存分段的由来"><span class="nav-number">4.2.1.</span> <span class="nav-text">实模式下内存分段的由来</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实模式下CPU-内存寻址方式"><span class="nav-number">4.2.2.</span> <span class="nav-text">实模式下CPU 内存寻址方式</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>
  <div id="DvelopmentTarget">     
  </div>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart" aria-hidden="false"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>

  
</div>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_uv"> 
  本站访客数<span id="busuanzi_value_site_uv"></span>人次
</span>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  


  <script type="text/javascript" src="/js/src/love.js"></script>

</body>
</html>
