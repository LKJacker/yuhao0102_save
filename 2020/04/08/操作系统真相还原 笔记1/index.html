<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zn-ch">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-center-simple.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="操作系统,">










<meta name="description" content="一些你可能正感到迷惑的问题软件是如何访问硬件的硬件在输入输出上大体分为串行和并行，相应的接口也就是串行接口和并行接口。CPU通过串行接口与串行设备数据传输。并行设备的访问类似，只不过是通过并行接口进行的。访问外部硬件有两个方式：  将某个外设的内存映射到一定范围的地址空间中，CPU通过地址总线访问该内存区域时会落到外设的内存中，这种映射让CPU 访问外设的内存就如同访问主板上的物理内存一样。 外设">
<meta name="keywords" content="操作系统">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统真相还原1-4章">
<meta property="og:url" content="http://yoursite.com/2020/04/08/操作系统真相还原 笔记1/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="一些你可能正感到迷惑的问题软件是如何访问硬件的硬件在输入输出上大体分为串行和并行，相应的接口也就是串行接口和并行接口。CPU通过串行接口与串行设备数据传输。并行设备的访问类似，只不过是通过并行接口进行的。访问外部硬件有两个方式：  将某个外设的内存映射到一定范围的地址空间中，CPU通过地址总线访问该内存区域时会落到外设的内存中，这种映射让CPU 访问外设的内存就如同访问主板上的物理内存一样。 外设">
<meta property="og:locale" content="zn-ch">
<meta property="og:image" content="http://yoursite.com/img/20200416151400.png">
<meta property="og:image" content="http://yoursite.com/img/20200416151600.jpg">
<meta property="og:image" content="http://yoursite.com/img/1587022334.jpg">
<meta property="og:image" content="http://yoursite.com/img/1587022380.jpg">
<meta property="og:image" content="http://yoursite.com/img/1587024090.jpg">
<meta property="og:image" content="http://yoursite.com/img/20200527154000.png">
<meta property="og:image" content="http://yoursite.com/img/1590576073.jpg">
<meta property="og:image" content="http://yoursite.com/img/1590578903.jpg">
<meta property="og:image" content="http://yoursite.com/img/1590584080.jpg">
<meta property="og:image" content="http://yoursite.com/img/1590585314.jpg">
<meta property="og:image" content="http://yoursite.com/img/1590660105.jpg">
<meta property="og:image" content="http://yoursite.com/img/1590663438.jpg">
<meta property="og:image" content="http://yoursite.com/img/1590665229.jpg">
<meta property="og:image" content="http://yoursite.com/img/1590665476.jpg">
<meta property="og:image" content="http://yoursite.com/img/1590665713.jpg">
<meta property="og:image" content="http://yoursite.com/img/1591320347.jpg">
<meta property="og:image" content="http://yoursite.com/img/1593400518.jpg">
<meta property="og:image" content="http://yoursite.com/img/1593401302.jpg">
<meta property="og:image" content="http://yoursite.com/img/1593401486.jpg">
<meta property="og:image" content="http://yoursite.com/img/1593401932.jpg">
<meta property="og:image" content="http://yoursite.com/img/1593402008.jpg">
<meta property="og:image" content="http://yoursite.com/img/1593402478.jpg">
<meta property="og:image" content="http://yoursite.com/img/1593403153.jpg">
<meta property="og:image" content="http://yoursite.com/img/1593426673.jpg">
<meta property="og:image" content="http://yoursite.com/img/1593431715.png">
<meta property="og:image" content="http://yoursite.com/img/1593431741.jpg">
<meta property="og:image" content="http://yoursite.com/img/1593535623.jpg">
<meta property="og:image" content="http://yoursite.com/img/1593571524.jpg">
<meta property="og:image" content="http://yoursite.com/img/1593571866.png">
<meta property="og:image" content="http://yoursite.com/img/1593573199.jpg">
<meta property="og:image" content="http://yoursite.com/img/1593573776.jpg">
<meta property="og:updated_time" content="2020-07-01T03:09:06.924Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="操作系统真相还原1-4章">
<meta name="twitter:description" content="一些你可能正感到迷惑的问题软件是如何访问硬件的硬件在输入输出上大体分为串行和并行，相应的接口也就是串行接口和并行接口。CPU通过串行接口与串行设备数据传输。并行设备的访问类似，只不过是通过并行接口进行的。访问外部硬件有两个方式：  将某个外设的内存映射到一定范围的地址空间中，CPU通过地址总线访问该内存区域时会落到外设的内存中，这种映射让CPU 访问外设的内存就如同访问主板上的物理内存一样。 外设">
<meta name="twitter:image" content="http://yoursite.com/img/20200416151400.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/04/08/操作系统真相还原 笔记1/">





  <title>操作系统真相还原1-4章 | Hao Yu's blog</title>
  








 
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zn-ch">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hao Yu's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">The program monkey was eaten by the siege lion.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-mybetterhalf">
          <a href="/mybetterhalf/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>
            
            mybetterhalf
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="Searching..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/08/操作系统真相还原 笔记1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">操作系统真相还原1-4章</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-04-08T19:13:00+08:00">
                2020-04-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="一些你可能正感到迷惑的问题"><a href="#一些你可能正感到迷惑的问题" class="headerlink" title="一些你可能正感到迷惑的问题"></a>一些你可能正感到迷惑的问题</h1><h2 id="软件是如何访问硬件的"><a href="#软件是如何访问硬件的" class="headerlink" title="软件是如何访问硬件的"></a>软件是如何访问硬件的</h2><p>硬件在输入输出上大体分为串行和并行，相应的接口也就是串行接口和并行接口。CPU通过串行接口与串行设备数据传输。并行设备的访问类似，只不过<br>是通过并行接口进行的。访问外部硬件有两个方式：</p>
<ul>
<li>将某个外设的内存映射到一定范围的地址空间中，CPU通过地址总线访问该内存区域时会落到外设的内存中，这种映射让CPU 访问外设的内存就如同访问主板上的物理内存一样。</li>
<li>外设是通过IO接口与CPU通信的，CPU访问外设，就是访问IO接口，由IO接口将信息传递给另一端的外设。</li>
</ul>
<h2 id="应用程序操作系统是如何配合到一起的"><a href="#应用程序操作系统是如何配合到一起的" class="headerlink" title="应用程序操作系统是如何配合到一起的"></a>应用程序操作系统是如何配合到一起的</h2><p>编译器提供了一套库函数，库函数中又有封装的系统调用，这样的代码集合称之为运行库。C 语言的运行库称为C 运行库，就是所谓的CRT（C Runtime Library）。</p>
<p>用户态与内核态是对CPU 来讲的，是指CPU 运行在用户态（特权3 级）还是内核态（特权0 级）。用户进程陷入内核态是指：<strong>由于内部或外部中断发生，当前进程被暂时终止执行，其上下文被内核的中断程序保存起来后，开始执行一段内核的代码</strong>，所以“用户态与内核态”是对CPU 来说的。</p>
<h2 id="为什么称为“陷入”内核"><a href="#为什么称为“陷入”内核" class="headerlink" title="为什么称为“陷入”内核"></a>为什么称为“陷入”内核</h2><p>应用程序处于特权级3，操作系统内核处于特权级0。当用户程序欲访问系统资源时（无论是硬件，还是内核数据结构），它需要进行系统调用。这样CPU 便进入了内核态，也称管态。</p>
<h2 id="内存访问为什么要分段"><a href="#内存访问为什么要分段" class="headerlink" title="内存访问为什么要分段"></a>内存访问为什么要分段</h2><p>内存是随机读写设备，即访问其内部任何一处，不需要从头开始找，只要直接给出其地址便可。CPU 采用“段基址+段内偏移地址”的方式来访问任意内存。这<br>样的好处是程序可以重定位了，尽管程序指令中给的是绝对物理地址，但终究可以同时运行多个程序了。<strong>重定位</strong>就是将程序中指令的地址改写成另外一个地址，但该地址处的内容还是原地址处的内容。</p>
<p>只要程序分了段，把整个段平移到任何位置后，段内的地址相对于段基址是不变的，无论段基址是多少，只要给出段内偏移地址，CPU 就能访问到正确的指令。于是加载用户程序时，只要将整个段的内容复制到新的位置，再将段基址寄存器中的地址改成该地址，程序便可准确无误地运行，因为程序中用的是段内偏移地址，相对于新的段基址，该偏移地址处的内存内容还是一样的。</p>
<h2 id="代码中为什么分为代码段、数据段？"><a href="#代码中为什么分为代码段、数据段？" class="headerlink" title="代码中为什么分为代码段、数据段？"></a>代码中为什么分为代码段、数据段？</h2><p>分段只是为了使程序更加优美。如果是在<strong>平坦模型</strong>下编程，操作系统将整个4GB 内存都放在同一个段中，我们就不需要来回切换段寄存器所指向的段。对于代码中是否要分段，这取决于操作系统是否在平坦模型下。</p>
<p>指令间不存在空隙，下一条指令的地址是按照前面指令的尺寸大小排下来的，这就是Intel 处理器的程序计数器cs：eip能够自动获得下一条指令的原理，即将当前eip 中的地址加上当前指令机器码的大小便是内存中下一条指令的起始地址。为了让程序内指令接连不断地执行，要把指令全部排在一起，形成一片连续的指令区域，这就是代码段。把数据连续地并排在一起存储形成的段落，就称为数据段。</p>
<p>只要指令逻辑上是连续的就可以，没必要一定得是物理上连续。所以，明确一点，即使数据和代码在物理上混在一起，程序也是可以运行的，这并不意味<br>着指令被数据“断开”了。只要程序中有指令能够跨过这些数据就行啦，最典型的就是用jmp 跳过数据区。</p>
<p>在保护模式下，有这样一个数据结构，它叫全局描述符表（Global Descriptor Table，GDT），这个表中的每一项称为段描述符。编译器负责挑选出数据具备的属性，从而根据属性将程序片段分类，比如，划分出了只读属性的代码段和可写属性的数据段。操作系统通过设置GDT 全局描述符表来构建段描述符，在段描述符中指定段的位置、大小及属性（包括S 字段和TYPE 字段）。CPU 中的段寄存器提前被操作系统赋予相应的选择子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">section my_code vstart=0</span><br><span class="line">;通过远跳转的方式给代码段寄存器CS 赋值0x90</span><br><span class="line">jmp 0x90:start</span><br><span class="line">start: ;标号start 只是为了jmp 跳到下一条指令</span><br><span class="line">;初始化数据段寄存器DS</span><br><span class="line">mov ax,section.my_data.start</span><br><span class="line">add ax,0x900 ;加0x900 是因为本程序会被mbr 加载到内存0x900 处</span><br><span class="line">shr ax,4 ;提前右移4 位,因为段基址会被CPU 段部件左移4 位</span><br><span class="line">mov ds,ax</span><br><span class="line"></span><br><span class="line">;初始化栈段寄存器SS</span><br><span class="line">mov ax,section.my_stack.start</span><br><span class="line">add ax,0x900 ;加0x900 是因为本程序会被mbr 加载到内存0x900 处</span><br><span class="line">shr ax,4 ;提前右移4 位,因为段基址会被CPU 段部件左移4 位</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,stack_top ;初始化栈指针</span><br><span class="line"></span><br><span class="line">;此时CS､DS､SS 段寄存器已经初始化完成,下面开始正式工作</span><br><span class="line">push word [var2] ;变量名var2 编译后变成0x4</span><br><span class="line">jmp $</span><br><span class="line"></span><br><span class="line">;自定义的数据段</span><br><span class="line">section my_data align=16 vstart=0</span><br><span class="line">var1 dd 0x1</span><br><span class="line">var2 dd 0x6</span><br><span class="line"></span><br><span class="line">;自定义的栈段</span><br><span class="line">section my_stack align=16 vstart=0</span><br><span class="line">times 128 db 0</span><br><span class="line">stack_top: ;此处用于栈顶,标号作用域是当前section,</span><br><span class="line">;以当前section 的vstart 为基数</span><br></pre></td></tr></table></figure></p>
<p>代码是实模式下运行的程序，其中自定义了三个段，代码段取名为my_code，数据段取名为my_data，栈段取名为my_stack。用“jmp 0x90：0”初始化了程序计数器CS 和IP。这样段寄存器CS 就是程序中咱们自己划分的代码段了。各section 中的定义都有align=16 和vstart=0，这是用来指定各section 按16 位对齐的，第 6～10 行是初始化数据段寄存器DS，是用程序中自已划分的段my_data 的地址来初始化的。第 12～17 行是初始化栈段寄存器，原理和数据段差不多，唯一区别是栈段初始化多了个针指针SP，为它初始化的值stack_top 是最后一行，因为栈指针在使用过程中指向的地址越来越低，所以初始化时一<br>定得是栈段的最高地址。</p>
<h2 id="物理地址、逻辑地址、有效地址、线性地址、虚拟地址的区别"><a href="#物理地址、逻辑地址、有效地址、线性地址、虚拟地址的区别" class="headerlink" title="物理地址、逻辑地址、有效地址、线性地址、虚拟地址的区别"></a>物理地址、逻辑地址、有效地址、线性地址、虚拟地址的区别</h2><p>物理地址就是物理内存真正的地址，相当于内存中每个存储单元的门牌号，具有唯一性。在实模式下，“段基址+段内偏移地址”经过段部件的处理，直接输出的就是物理地址，CPU 可以直接用此地址访问内存。</p>
<p>而在保护模式下，“段基址+段内偏移地址”称为<strong>线性地址</strong>，不过，此时的段基址已经不再是真正的地址了，而是一个称为<strong>选择子</strong>的东西。它本质是个索引，类似于数组下标，通过这个索引便能在GDT 中找到相应的段描述符，在该描述符中记录了该段的起始、大小等信息，这样便得到了段基址。</p>
<p>若没有开启地址分页功能，此线性地址就被当作物理地址来用，可直接访问内存。若开启了分页功能，此线性地址又多了一个名字，就是<strong>虚拟地址</strong>（虚拟地址、线性地址在分页机制下都是一回事）。虚拟地址要经过CPU 页部件转换成具体的物理地址，这样CPU 才能将其送上地址总线去访问内存。</p>
<p>无论在实模式或是保护模式下，段内偏移地址又称为有效地址，也称为逻辑地址。线性地址或称为虚拟地址，这都不是真实的内存地址。它们都用来描述程序或任务的地址空间。<br><img src="/img/20200416151400.png" alt></p>
<h2 id="什么是段重叠"><a href="#什么是段重叠" class="headerlink" title="什么是段重叠"></a>什么是段重叠</h2><p>CPU 的内存寻址方式是：给我一个段基址，再给我一个相对于该段起始位置的偏移地址，我就能访问到相应内存。它并不要求一个内存地址只隶属于某一个段。用段A 去访问，其偏移为5，用段B 去访问，其偏移量为3。这样一来，用段B 和段A 在地址0xC02 之后，一直到段B偏移地址为0xfffe 的部分，像是重叠在一起了，这就是段重叠了。<br><img src="/img/20200416151600.jpg" alt></p>
<h2 id="什么是平坦模型"><a href="#什么是平坦模型" class="headerlink" title="什么是平坦模型"></a>什么是平坦模型</h2><p>所以说平坦模型指的就是一个段。段的大小可以是地址总线能够到达的范围。</p>
<h2 id="cs、ds-这类sreg-段寄存器，位宽是多少"><a href="#cs、ds-这类sreg-段寄存器，位宽是多少" class="headerlink" title="cs、ds 这类sreg 段寄存器，位宽是多少"></a>cs、ds 这类sreg 段寄存器，位宽是多少</h2><p>CPU 内部的段寄存器（Segment reg）如下：</p>
<ol>
<li>CS—代码段寄存器（Code Segment Register），其值为代码段的段基值。</li>
<li>DS—数据段寄存器（Data Segment Register），其值为数据段的段基值。</li>
<li>ES—附加段寄存器（Extra Segment Register），其值为附加数据段的段基值，称为“附加”是因为此段寄存器用途不像其他sreg 那样固定，可以额外做他用。</li>
<li>FS—附加段寄存器（Extra Segment Register），其值为附加数据段的段基值，同上，用途不固定，使用上灵活机动。</li>
<li>GS—附加段寄存器（Extra Segment Register），其值为附加数据段的段基值。</li>
<li>SS—堆栈段寄存器（Stack Segment Register），其值为堆栈段的段值。</li>
</ol>
<p>在实模式下，CS、DS、ES、SS 中的值为段基址，是具体的物理地址，内存单元的逻辑地址仍为“段基值：段内偏移量”的形式。在保护模式下，装入段寄存器的不再是段地址，而是“段选择子”（Selector），当然，选择子也是数值，其依然为16 位宽度。</p>
<h2 id="什么是工程，什么是协议"><a href="#什么是工程，什么是协议" class="headerlink" title="什么是工程，什么是协议"></a>什么是工程，什么是协议</h2><p>软件中的工程是指开发一套软件所需要的全部文件，包括配置环境。</p>
<p>协议是一种大家共同遵守的规约，主要用来实现通信、共享、协作，给大家统一一种接口、一组数据调用或者分析的约定。</p>
<h2 id="局部变量和函数参数为什么要放在栈中"><a href="#局部变量和函数参数为什么要放在栈中" class="headerlink" title="局部变量和函数参数为什么要放在栈中"></a>局部变量和函数参数为什么要放在栈中</h2><p>局部变量只是自己在用，放在数据段中纯属浪费空间，没有必要，故将其放在自己的栈中，随时可以清理，真正体现了局部的意义。</p>
<p>堆是程序运行过程中用于动态内存分配的内存空间，是操作系统为每个用户进程规划的，属于软件范畴。栈是处理器运行必备的内存空间，是硬件必需的，但又是由软件（操作系统）提供的。</p>
<p><strong>栈从高地址往低地址发展，堆是从低地址往高地址发展</strong>，堆和栈早晚会碰头，它们各自的大小取决于实际的使用情况，界限并不明朗。</p>
<h2 id="编译型程序与解释型程序的区别"><a href="#编译型程序与解释型程序的区别" class="headerlink" title="编译型程序与解释型程序的区别"></a>编译型程序与解释型程序的区别</h2><p>解释型语言，也称为脚本语言，本身是文本文件，是某个应用程序的输入，这个应用程序是脚本解释器。由于只是文本，这些脚本中的代码在脚本解释器看来和字符串无异。也就是说，脚本中的代码从来没真正上过CPU 去执行，CPU 的cs：ip 寄存器从来没指向过它们，在CPU 眼里只看得到脚本解释器</p>
<p>本质上是脚本解释器在时时分析这个脚本，动态根据关键字和语法来做出相应的行为。因此脚本中若出现错误，先前正确的部分也会被正常执行，这和编译型程序有很大区别。</p>
<p>编译型语言编译出来的程序，运行时本身就是一个进程。它是由操作系统直接调用的。也就是由操作系统加载到内存后，操作系统将CS：IP 寄存器指向这个程序的入口，使它直接上CPU 运行。</p>
<h2 id="什么是大端字节序、小端字节序"><a href="#什么是大端字节序、小端字节序" class="headerlink" title="什么是大端字节序、小端字节序"></a>什么是大端字节序、小端字节序</h2><ol>
<li>小端：因为低位在低字节，强制转换数据型时不需要再调整字节了。</li>
<li>大端：有符号数，其字节最高位不仅表示数值本身，还起到了符号的作用。符号位固定为第一字节，也就是最高位占据最低地址，符号直接可以取出来，容易判断正负。</li>
</ol>
<p>简要说明一下小端的优势。因为在做强制数据类型转换时，如果转换是由低精度转向高精度，这数值本身没什么变化，如short 是2 字节，将其转换为4 字节的int 类型，无非是由0x1234 变成了0x00001234，数值上是不变的，只是存储形式上变了。如果转换是高精度转向低精度，也就是多个字节的数值要减少一<br>些存储字节，这必然是要丢弃一部分数值。编译器的转换原则是强制转换到低精度类型，丢弃数值的高字节位，只保留数值的低字节。</p>
<p>对于大端的优势，就硬件而言，就是符号位的判断变得方便了。最高位在最低地址，也就是直接就可以取到了，不用再跨越几个字节，减少了时钟周期。</p>
<h2 id="BIOS-中断、DOS-中断、Linux-中断的区别"><a href="#BIOS-中断、DOS-中断、Linux-中断的区别" class="headerlink" title="BIOS 中断、DOS 中断、Linux 中断的区别"></a>BIOS 中断、DOS 中断、Linux 中断的区别</h2><p>BIOS 和DOS 都是存在于实模式下的程序，由它们建立的中断调用都是建立在中断向量表（Interrupt Vector Table，IVT）中的。它们都是通过软中断指令int 中断号来调用的。</p>
<p>中断向量表中的每个中断向量大小是4 字节。这4 字节描述了一个中断处理例程（程序）的段基址和段内偏移地址。BIOS 中断调用的主要功能是提供了硬件访问的方法，该方法使对硬件的操作变得简单易行。BIOS 中断程序处理是用来操作硬件的，故该处理程序中一定到处都是in/out 指令。</p>
<p>DOS 是运行在实模式下的，故其建立的中断调用也建立在中断向量表中，只不过其中断向量号和BIOS的不能冲突。</p>
<p>而 Linux 内核是在进入保护模式后才建立中断例程的，不过在保护模式下，中断向量表已经不存在了，取而代之的是<strong>中断描述符表</strong>（Interrupt Descriptor Table，IDT）。所以在Linux 下执行的中断调用，访问的中断例程是在<strong>中断描述符表</strong>中，已不在中断向量表里了。Linux 的系统调用和DOS 中断调用类似，不过Linux 是通过int 0x80 指令进入一个中断程序后再根据eax 寄存器的值来调用不同的子功能函数的。</p>
<h2 id="Section-和Segment-的区别"><a href="#Section-和Segment-的区别" class="headerlink" title="Section 和Segment 的区别"></a>Section 和Segment 的区别</h2><p>在汇编源码中，通常用语法关键字 section 或segment 来表示一段区域，它们是编译器提供的伪指令，作用是相同的，都是在程序中“逻辑地”规划一段区域，此区域便是节。操作系统在加载程序时，不需要对逐个节进行加载，只要给出相同权限的节的集合就行了，这样操作系统就能为它们分配不同的段选择子，从而指向不同段描述符，实现不同的访问权限了。</p>
<p>section 称为节，是指在汇编源码中经由关键字section 或segment 修饰、逻辑划分的指令或数据区域，汇编器会将这两个关键字修饰的区域在目标文件中编译成节，也就是说“节”最初诞生于目标文件中。</p>
<p>segment 称为段，是链接器根据目标文件中属性相同的多个section 合并后的section 集合，这个集合称为segment，也就是段，链接器把目标文件链接成可执行文件，因此段最终诞生于可执行文件中。我们平时所说的可执行程序内存空间中的代码段和数据段就是指的segment。<br><img src="/img/1587022334.jpg" alt><br><img src="/img/1587022380.jpg" alt></p>
<p>Program Headers 部分，此处一共有两个段，第一个段是我们的代码段，通过其Flg 值为RE 便可推断，只读（Readonly）可执行（Execute）。第二个段便是我们的数据段，但此数据段中只包含.bss 节（section），它用于存储全局未初始化数据故其Flg 必然可读写，其属性为RW。</p>
<h2 id="操作系统是如何识别文件系统的"><a href="#操作系统是如何识别文件系统的" class="headerlink" title="操作系统是如何识别文件系统的"></a>操作系统是如何识别文件系统的</h2><p>各分区都有超级块，一般位于本分区的第2 个扇区，比如若各分区的扇区以0 开始索引，其第1 个扇区便是超级块的起始扇区。超级块里面记录了此分区的信息，其中就有文件系统的魔数，一种文件系统对应一个魔数。</p>
<h2 id="如何控制-CPU-的下一条指令"><a href="#如何控制-CPU-的下一条指令" class="headerlink" title="如何控制 CPU 的下一条指令"></a>如何控制 CPU 的下一条指令</h2><p>我们常说的用于存放下一条指令地址的寄存器称为程序计数器PC。在 x86 体系结构的CPU 中程序计数器PC 并不是单一的某种寄存器，它是一种寄存器组合，指的段寄存器CS 和指令寄存器IP。CS 和IP 是CPU 待执行的下一条指令的段基址和段内偏移地址，不能直接用mov 指令去改变它们。有专门改变执行流的指令，如jmp、call、int、ret，这些指令可以同时修改cs 和ip，它们在硬件级别上实现了原子操作。</p>
<h2 id="库函数是用户进程与内核的桥梁"><a href="#库函数是用户进程与内核的桥梁" class="headerlink" title="库函数是用户进程与内核的桥梁"></a>库函数是用户进程与内核的桥梁</h2><p>例如对printf的声明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extern int printf (__const char *__restrict __format,...);</span><br></pre></td></tr></table></figure></p>
<p>头文件被包含进来后，其内容也是原样被展开到include 所在的位置，就是把整个头文件中的内容挪了过来。头文件中一般仅仅有函数声明，这个声明告诉编译器至少两件事。</p>
<ol>
<li>函数返回值类型、参数类型及个数，用来确定分配的栈空间。</li>
<li>该函数是外部函数，定义在其他文件，现在无法为其分配地址，需要在链接阶段将该函数体所在的目标文件一同链接时再安排地址。</li>
</ol>
<p>如果预处理后，主调函数所在的文件中找不到所调用函数的函数体，一定要在链接阶段把该函数体所在的目标文件链接进来。编译器提供的C 运行库中已经为我们准备好了这些标准函数的函数体所在的目标文件，在链接时默默帮我们链接上了。这些目标文件都是待重定位文件，重定位文件意思是文件中的函数是没有地址的，用file 命令查看它们时会显示relocatable，它们中的地址是在与用户程序的目标文件链接成一个可执行文件时由链接器统一分配的。</p>
<h2 id="MBR、EBR、DBR-和OBR-各是什么"><a href="#MBR、EBR、DBR-和OBR-各是什么" class="headerlink" title="MBR、EBR、DBR 和OBR 各是什么"></a>MBR、EBR、DBR 和OBR 各是什么</h2><p>MBR 是主引导记录，Master 或Main Boot Record，它存在于整个硬盘最开始的那个扇区，即0盘0道1扇区，这个扇区便称为MBR 引导扇区。在 MBR 引导扇区中存储引导程序，为的是从BIOS 手中接过系统的控制权，。BIOS 知道MBR 在0 盘0 道1 扇区，这是约定好的，因此它会将0 盘0 道1 扇区中的MBR 引<br>导程序加载到物理地址0x7c00，然后跳过去执行，这样BIOS 就把处理器使用权移交给MBR 了。在 MBR 引导扇区中的内容是：</p>
<ol>
<li>446 字节的引导程序及参数；</li>
<li>64 字节的分区表；</li>
<li>2 字节结束标记0x55 和0xaa。</li>
</ol>
<p>MBR 的作用相当于下一棒的引导程序总入口，BIOS 把控制权交给MBR 就行了，由MBR 从众多可能的接力选手中挑出合适的人选并交出系统控制权，这个过程就是由“主引导程序”去找“次引导程序”。MBR 引导程序的任务就是把控制权交给操作系统加载器，由该加载器完成操作系统的自举，最终使控制权交付给操作系统内核。</p>
<p>为了让 MBR 知道哪里有操作系统，我们在分区时，如果想在某个分区中安装操作系统，就用分区工具将该分区设置为活动分区，设置活动分区的本质就是把分区表中该分区对应的分区表项中的活动标记为0x80。</p>
<p>“控制权交接”是处理器从“上一棒选手”跳到“下一棒选手”来完成的，内核加载器的入口地址是这里所说的“下一棒选手”，为了MBR 方便找到活动分区上的内核加载器，内核加载器的入口地址也必须在固定的位置，这个位置就是各分区最开始的扇区，这也是约定好的。这个“各分区起始的扇区”中存放的是操作系统<br>引导程序—内核加载器，因此该扇区称为<strong>操作系统引导扇区</strong>，其中的引导程序（内核加载器）称为<strong>操作系统引导记录OBR</strong>，即OS Boot Record，此扇区也称为OBR 引导扇区。在OBR 扇区的前3 个字节存放了跳转指令，这同样是约定，因此MBR 找到活动分区后，就大胆主动跳到活动分区OBR 引导扇区的起始处，该起始处的跳转指令马上将处理器带入操作系统引导程序，从此MBR 完成了交接工作，以后便是内核的天下了。</p>
<p>DBR 是DOS Boot Record，也就是DOS 操作系统的引导记录（程序）。在 DOS 时代只有4 个分区，不存在扩展分区，这4 个分区都相当于主分区，所以各主分区最开始的扇区称为DBR 引导扇区。</p>
<p>这里提到了扩展分区就不得不提到EBR。当初为了解决分区数量限制的问题才有了扩展分区，EBR是扩展分区中为了兼容MBR 才提出的概念，主要是兼容MBR 中的分区表。为扩展分区存储分区表的扇区称为EBR，即Expand Boot Record，</p>
<p>MBR 和EBR 是分区工具创建维护的，不属于操作系统管理的范围，因此操作系统不可以往里面写东西。OBR 是各分区（主分区或逻辑分区）最<br>开始的扇区，因此属于操作系统管理。DBR、OBR、MBR、EBR 都包含引导程序，因此它们都称为引导扇区，只要该扇区中存在可执行的程序，该扇区就是可引导扇区。若该扇区位于整个硬盘最开始的扇区，并且以0x55 和0xaa 结束，BIOS就认为该扇区中存在MBR，该扇区就是MBR 引导扇区。<br><img src="/img/1587024090.jpg" alt></p>
<h1 id="部署工作环境"><a href="#部署工作环境" class="headerlink" title="部署工作环境"></a>部署工作环境</h1><h2 id="我们需要哪些编译器"><a href="#我们需要哪些编译器" class="headerlink" title="我们需要哪些编译器"></a>我们需要哪些编译器</h2><p>NASM 是一个为可移植性与模块化而设计的一个<strong>80x86的汇编器</strong>。它支持相当多的目标文件格式，包括’Linux’和’NetBSD/FreeBSD’，’a.out’，’ELF’，’COFF’，微软16位的’OBJ’和’Win32’。它还可以输出纯二进制文件。它的语法设计得相当的简洁易懂，和Intel语法相似但更简单。它支持’Pentium’，’P6’，’MMX’，’3DNow!’，’SSE’和’SSE2’指令集。</p>
<h1 id="编写MBR-主引导记录，让我们开始掌权"><a href="#编写MBR-主引导记录，让我们开始掌权" class="headerlink" title="编写MBR 主引导记录，让我们开始掌权"></a>编写MBR 主引导记录，让我们开始掌权</h1><h2 id="计算机的启动过程"><a href="#计算机的启动过程" class="headerlink" title="计算机的启动过程"></a>计算机的启动过程</h2><p>CPU 的硬件电路被设计成只能运行处于内存中的程序。因此，OS需要被载入内存中，大概上分两部分。</p>
<ol>
<li>程序被加载器（软件或硬件）加载到内存某个区域。</li>
<li>CPU 的cs：ip 寄存器被指向这个程序的起始地址。</li>
</ol>
<p>操作系统在加载程序时，是需要某个加载器来将用户程序存储到内存中的。其实“加载器”本质上它就是一堆函数组成的模块。</p>
<h2 id="软件接力第一棒，BIOS"><a href="#软件接力第一棒，BIOS" class="headerlink" title="软件接力第一棒，BIOS"></a>软件接力第一棒，BIOS</h2><p>BIOS全称叫<code>Base Input &amp; Output System</code>，即基本输入输出系统。</p>
<h3 id="实模式下的1MB内存布局"><a href="#实模式下的1MB内存布局" class="headerlink" title="实模式下的1MB内存布局"></a>实模式下的1MB内存布局</h3><p>Intel 8086有20条地址线，故其可以访问1MB的内存空间，即2的20次方=1048576=1MB，地址范围是0x00000到0xFFFFF。下表是实模式下1MB内存布局。<br><img src="/img/20200527154000.png" alt></p>
<p>地址0～0x9FFFF处是DRAM（Dynamic Random Access Memory），即<strong>动态随机访问内存</strong>，我们所装的物理内存就是DRAM，如DDR、DDR2 等。动态指<strong>此种存储介质需要定期地刷新</strong>，它的空间范围是640KB，这片地址对应到了DRAM，也就是插在主板上的内存条。</p>
<p>地址总线宽度决定了可以访问的内存空间大小，如16位机的地址总线为20位，其地址范围是1MB，但是并不是只有内存条需要通过地址总线访问，需要在地址总线上提前预留出来一些地址空间给其他外设用，留够了以后，地址总线上其余的可用地址再指向DRAM，也就是指插在主板上的内存条，所以地址总线的长度与DRAM的大小不同。</p>
<p>顶部的0xF0000～0xFFFFF，这64KB的内存是<strong>ROM</strong>，这里面存的就是BIOS的代码。BIOS还建立了中断向量表，这样就可以通过<code>int 中断号</code>来实现相关的硬件调用，当然BIOS建立的这些功能就是对硬件的IO操作，也就是输入输出，加上一些重要的、保证计算机能运行的那些硬件的基本IO操作，就行了。这就是BIOS称为基本输入输出系统的原因。</p>
<p><strong>BIOS被写进ROM</strong>。ROM也是块内存，内存就需要被访问。此ROM被映射在低端1MB内存的顶部，即地址0xF0000～0xFFFFF处。<strong>只要访问此处的地址便是访问了BIOS，这个映射是由硬件完成的。</strong>BIOS本身是个程序，程序要执行，就要有个入口地址才行，此入口地址便是<code>0xFFFF0</code>。</p>
<p>CPU访问内存是用<code>段地址+偏移地址</code>来实现的，由于<strong>在实模式之下，段地址需要乘以16后才能与偏移地址相加，求出的和便是物理地址</strong>，CPU便拿此地址直接用了。在接电的一瞬间，<code>CPU的cs:ip寄存器被强制初始化为0xF000:0xFFF0</code>。由于开机的时候处于实模式，在实模式下的段基址要乘以16，也就是左移4位，于是<code>0xF000:0xFFF0</code>的等效地址将是<code>0xFFFF0</code>，此地址便是BIOS的入口地址。物理地址0xFFFF0处应该是指令，否则会出错，里面有条指令<code>jmp far f000:e05b</code>，这是条跳转指令，也就是证明了在内存物理地址0xFFFF0处的内容是一条跳转指令。</p>
<p>BIOS最后一项工作校验启动盘中位于0盘0道1扇区的内容。<code>0盘0道1扇区本质上就相当于0盘0道0扇区</code>。CHS方法（即柱面Cylinder磁头Header扇区Sector，另外一种是LBA 方式，暂不关心），<code>0盘</code>说的是<code>0磁头</code>，因为一张盘是有上下两个盘面的，一个盘面上对应一个磁头，所以用<code>磁头Header</code>来表示盘面。<code>0道</code>是指<code>0柱面</code>，柱面Cylinder指的是所有盘面上、编号相同的磁道的集合。在<code>CHS方式中扇区的编号是从1开始的</code>，它就是磁盘上最开始的那个扇区。如果此扇区末尾的两个字节分别是魔数<code>0x55</code>和<code>0xaa</code>，BIOS便认为此扇区中确实存在可执行的程序，便<code>加载到物理地址0x7c00</code>，随后跳转到此地址，继续执行。</p>
<blockquote>
<p>8086CPU要求物理地址<code>0x0～0x3FF</code>存放中断向量表，所以此处不能动了；按 DOS 1.0 要求的最小内存32KB来说，MBR希望给人家尽可能多的预留空间，所以MBR只能放在32KB的末尾；MBR本身也是程序，是程序就要用到栈，估计1KB内存够用了。结合以上三点，选择32KB中的最后1KB最为合适，32KB换算为十六进制为0x8000，减去1KB(0x400)的话，等于0x7c00。这就是倍受质疑的0x7c00 的由来。</p>
</blockquote>
<h2 id="让-MBR-先飞一会儿"><a href="#让-MBR-先飞一会儿" class="headerlink" title="让 MBR 先飞一会儿"></a>让 MBR 先飞一会儿</h2><p><code>$</code>和<code>$$</code>是编译器NASM 预留的关键字，用来表示当前行和本section的地址，起到了标号的作用。汇编语言中的标号是程序员“显式地”写在明处的，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">code_start：</span><br><span class="line">mov ax， 0</span><br></pre></td></tr></table></figure></p>
<p><code>code_start</code>这个标号被nasm认为是一个地址，此地址便是<code>mov ax, 0</code>这条指令所在的地址，即其指令机器码存放的内存位置是<code>code_start</code>。<code>code_start</code>只是个标记，CPU并不认识，nasm会用为其安排的地址来替换标号code_start，到了CPU手中，已经被替换为有意义的数字形式的地址了。</p>
<p><code>$</code>属于“隐式地”藏在本行代码前的标号，也就是<code>编译器给当前行安排的地址</code>，看不到却又无处不在，<code>$</code>在每行都有。如果上面的例子改为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">code_start：</span><br><span class="line">jmp $</span><br></pre></td></tr></table></figure></p>
<p>这就和<code>jmp code_start</code>是等效的。<code>$</code>和<code>code_start</code>是同一个值。</p>
<p><code>$$</code>指代<strong>本section的起始地址</strong>，此地址同样是编译器给安排的。默认情况下，它们的值是相对于本文件开头的偏移量。如果该section用了<code>vstart=xxxx</code>修饰，<code>$$</code>的值则是此section的虚拟起始地址xxxx。<code>$</code>的值是以xxxx为起始地址的顺延。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">;主引导程序</span><br><span class="line">;------------------------------------------------------------</span><br><span class="line">SECTION MBR vstart=0x7c00</span><br><span class="line">mov ax,cs</span><br><span class="line">mov ds,ax</span><br><span class="line">mov es,ax</span><br><span class="line">mov ss,ax</span><br><span class="line">mov fs,ax</span><br><span class="line">mov sp,0x7c00</span><br><span class="line"></span><br><span class="line">; 清屏利用0x06号功能,上卷全部行,则可清屏｡</span><br><span class="line">; -----------------------------------------------------------</span><br><span class="line">;INT 0x10 功能号:0x06 功能描述:上卷窗口</span><br><span class="line">;------------------------------------------------------</span><br><span class="line">;输入:</span><br><span class="line">;AH 功能号= 0x06</span><br><span class="line">;AL = 上卷的行数(如果为0,表示全部)</span><br><span class="line">;BH = 上卷行属性</span><br><span class="line">;(CL,CH) = 窗口左上角的(X,Y)位置</span><br><span class="line">;(DL,DH) = 窗口右下角的(X,Y)位置</span><br><span class="line">;无返回值:</span><br><span class="line">mov ax, 0x600</span><br><span class="line">mov bx, 0x700</span><br><span class="line">mov cx, 0 ; 左上角: (0, 0)</span><br><span class="line">mov dx, 0x184f ; 右下角: (80,25),</span><br><span class="line">; VGA 文本模式中,一行只能容纳80个字符,共25行｡</span><br><span class="line">; 下标从0 开始,所以0x18=24,0x4f=79</span><br><span class="line">int 0x10 ; int 0x10</span><br><span class="line"></span><br><span class="line">;;;;;;;;; 下面这三行代码获取光标位置 ;;;;;;;;;</span><br><span class="line">;.get_cursor 获取当前光标位置,在光标位置处打印字符｡</span><br><span class="line">mov ah, 3 ; 输入: 3 号子功能是获取光标位置,需要存入ah 寄存器</span><br><span class="line">mov bh, 0 ; bh 寄存器存储的是待获取光标的页号</span><br><span class="line"></span><br><span class="line">int 0x10 ; 输出: ch=光标开始行,cl=光标结束行</span><br><span class="line">; dh=光标所在行号,dl=光标所在列号</span><br><span class="line"></span><br><span class="line">;;;;;;;;; 获取光标位置结束 ;;;;;;;;;;;;;;;;</span><br><span class="line"></span><br><span class="line">;;;;;;;;; 打印字符串 ;;;;;;;;;;;</span><br><span class="line">;还是用10h 中断,不过这次调用13 号子功能打印字符串</span><br><span class="line">mov ax, message</span><br><span class="line">mov bp, ax ; es:bp 为串首地址,es 此时同cs 一致,</span><br><span class="line">; 开头时已经为sreg 初始化</span><br><span class="line"></span><br><span class="line">; 光标位置要用到dx 寄存器中内容,cx 中的光标位置可忽略</span><br><span class="line">mov cx, 5 ; cx 为串长度,不包括结束符0 的字符个数</span><br><span class="line">mov ax, 0x1301 ;子功能号13 显示字符及属性,要存入ah 寄存器,</span><br><span class="line">; al 设置写字符方式 ah=01: 显示字符串,光标跟随移动</span><br><span class="line">mov bx, 0x2 ; bh 存储要显示的页号,此处是第0 页,</span><br><span class="line">; bl 中是字符属性,属性黑底绿字(bl = 02h)</span><br><span class="line">int 0x10 ; 执行BIOS 0x10 号中断</span><br><span class="line">;;;;;;;;; 打字字符串结束 ;;;;;;;;;;;;;;;</span><br><span class="line"></span><br><span class="line">jmp $ ; 使程序悬停在此</span><br><span class="line"></span><br><span class="line">message db &quot;1 MBR&quot;</span><br><span class="line">times 510-($-$$) db 0</span><br><span class="line">db 0x55,0xaa</span><br></pre></td></tr></table></figure>
<p>代码功能为：<strong>在屏幕上打印字符串“1 MBR”</strong>，背景色为黑色，前景色为绿色。</p>
<ul>
<li>第3行的<code>vstart=0x7c00</code>表示本程序在编译时，告诉编译器，把我的起始地址编译为0x7c00。</li>
<li>第4～8行是用cs寄存器的值去初始化其他寄存器。由于BIOS是通过<code>jmp 0:0x7c00</code>跳转到MBR的，故cs此时为0。对于ds、es、fs、gs这类sreg，CPU中不能直接给它们赋值，没有从立即数到段寄存器的电路实现，只有通过其他寄存器来中转，这里我们<code>用的是通用寄存器ax来中转</code>。</li>
<li>第9行是<code>初始化栈指针</code>，在CPU上运行的程序得遵从CPU的规则，mbr也是程序，是程序就要用到栈。目前0x7c00以下暂时是安全的区域，就把它当作栈来用。</li>
<li>第11～28行是清屏。这里也演示了BIOS中断<code>int 0x10</code>的用法。</li>
<li>第30～35行是做打印前的工作，先获取光标位置，目的是避免打印字符混乱，覆盖别人的输出。这里还用到了页的概念，往bh寄存器中写入了0，这是告诉BIOS例程，我要获取第0页当前的光标。</li>
<li>第38～52行是往光标处打印字符。说一下第48行的<code>mov ax, 0x1301</code>，13对应的是ah寄存器，这是调用0x13号子功能。01对应的是al寄存器，表示的是写字符方式，其低2位才有意义，各位功能描述如下：<ul>
<li>al=0，显示字符串，并且光标返回起始位置。</li>
<li>al=1，显示字符串，并且光标跟随到新位置。</li>
<li>al=2，显示字符串及其属性，并且光标返回起始位置。</li>
<li>al=3，显示字符串及其属性，光标跟随到新位置。</li>
</ul>
</li>
<li>第55行执行了个死循环，$是本行指令的地址，这属于伪指令，是汇编器在编译期间分配的地址。在最终编译出来的程序中，$会被替换为指令实际所在行的地址。jmp是个近跳转，$是jmp自己的地址，于是跳到自己所在的地址再执行自己，又是跳到自己所在的地址再继续执行跳转</li>
<li>第57行是定义打印的字符串。</li>
<li>第58行的<code>$$</code>是指本section的起始地址，上面说过了$是本行所在的地址，故$-$$是本行到本section的偏移量。由于MBR的最后两个字节是固定的内容，分别是0x55和0xaa，要预留出这2个字节，故本扇区内前512-2=510字节要填满，第50行的<code>times 510-($-$$) db 0</code>是在用0将本扇区剩余空间填充。</li>
</ul>
<h1 id="完善MBR"><a href="#完善MBR" class="headerlink" title="完善MBR"></a>完善MBR</h1><h2 id="地址、section、vstart-浅尝辄止"><a href="#地址、section、vstart-浅尝辄止" class="headerlink" title="地址、section、vstart 浅尝辄止"></a>地址、section、vstart 浅尝辄止</h2><p>本质上，程序中各种数据结构的访问，就是通过<code>该数据结构的起始地址＋该数据结构所占内存的大小</code>来实现的。数据的地址，其实就是<code>该数据相对整个程序开头的距离</code>，即偏移量。<br><img src="/img/1590576073.jpg" alt></p>
<ul>
<li>第1行的mov指令，$$表示的是所在的section的起始地址，由于这6 行代码中没有定义section，故nasm 默认把全体文件当成一个大的section，全体文件自然偏移地址为0，所以在反汇编代码那列中，起始地址$$被置换为0。</li>
<li>第2行代码是真指令，不牵涉到符号转换，所以反汇编后的代码同源码一致。</li>
<li>第3行引用了var变量的值，[]符号是取所在地址处的内容。在相应的反汇编代码中，相应的第三行中var这个符号地址被编译器替换为<code>0xd</code>。结合地址列查看一下内容列，地址为0xd 的内容为99，这正是var 的值。</li>
<li>第4行源码为<code>label: mov ax, $</code>，label是个标号，代表指令<code>mov ax, $</code>所在地址。$是个隐式的标号，表示当前行地址。</li>
<li>第5行的<code>jmp label</code>编译后被替换为<code>jmp short 0x8</code>，这是短跳转指令，地址为8处的内容是第4行的<code>mov ax, $</code>，同样吻合。</li>
<li>第 6 行的便是数据定义了，定义了双字节变量<code>var</code>，其值为99。在内容处的第6行可知，内容为99，与源码定义吻合。</li>
</ul>
<p>“地址”列中的数字和“内容”列中的内容有这样一种关系：地址等于上一个地址+上一个地址处的内容的长度。例如地址列第二行的3等于“上一个地址0”+“上一个地址 0 处的内容：B80000 的长度3”，以此类推。<strong>编译器给程序中各符号（变量名或函数名等）分配的地址，就是各符号相对于文件开头的偏移量。</strong></p>
<h2 id="CPU-的实模式"><a href="#CPU-的实模式" class="headerlink" title="CPU 的实模式"></a>CPU 的实模式</h2><p>实模式是指<strong>8086 CPU 的寻址方式、寄存器大小、指令用法等，是用来反应CPU 在该环境下如何工作的概念</strong>。CPU 大体上可以划分为3 个部分，它们是<strong>控制单元</strong>、<strong>运算单元</strong>、<strong>存储单元</strong>。<strong>控制单元</strong>是 CPU 的控制中心，CPU 需要经过它的帮忙才知道自己下一步要做什么。而控制单元大致由<strong>指令寄存器IR</strong>（Instruction Register）、<strong>指令译码器ID</strong>（Instruction Decoder）、<strong>操作控制器OC</strong>（Operation Controller）组成。</p>
<p>程序被加载到内存后，<strong>指令指针寄存器IP指向内存中下一条待执行指令的地址</strong>，控制单元根据IP寄存器的指向，将位于内存中的指令逐个装载到指令寄存器中。然后指令译码器将位于指令寄存器中的指令按照指令格式来解码，分析出操作码是什么，操作数在哪里之类的。</p>
<p>存储单元是指CPU内部的L1、L2缓存及寄存器，待处理的数据就存放在这些存储单元中。寄存器可分为两大类，程序员可以使用的寄存器称为程序可见寄存器，如通用寄存器、段寄存器。程序不可见寄存器是指程序员不可使用，也无法访问到它们，系统运行期间可能要用到寄存器。</p>
<p>运算单元负责算术运算（加减乘除）和逻辑运算（比较、移位），它从控制单元那里接收命令（信号）并执行，它没有自主意识，只是个执行部件。<br><img src="/img/1590578903.jpg" alt></p>
<p>CPU 中的寄存器大致上分为两大类。</p>
<ul>
<li>一类是其内部使用的，程序员不能使用。我们无法使用一些寄存器，比如全局描述符表寄存器GDTR、中断描述符表寄存器IDTR、局部描述符表寄存器LDTR、<br>任务寄存器TR、控制寄存器CR0～3、指令指针寄存器IP、标志寄存器flags、调试寄存器DR0～7。</li>
<li>另一类是对程序员可见的寄存器。我们进行汇编语言程序设计时，能够直接操作的就是这些寄存器，如段寄存器、通用寄存器。</li>
</ul>
<p>上面提到的“段基址：段内偏移地址”中的段基址，就是用段寄存器来存储的，<strong>段寄存器的作用就是指定一片内存的起始地址，故也称为段基址寄存器</strong>。尽管段基址在实模式下要乘以16，在保护模式下只是个选择子（保护模式中会讲），但其作用就是指定一片内存的起始地址。而段内偏移地址，顾名思义，仅仅相对于此起始地址的偏移量。</p>
<p>访问内存就要提供地址，初次访问内存时，该地址肯定不能用内存本身来存，用寄存器来存储内存地址。由于要指定的是内存中的一段区域的起始地址，所以称之为段基址寄存器，也称段寄存器，无论是在实模式下，还是保护模式下，它们都是16位宽。</p>
<ul>
<li>代码段把<strong>所有指令都连续排放在一起，形成了一个全部都是指令的区域</strong>，里面存储的是指令的操作码及寻址方式等。代码段寄存器CS就是用来指向内存中这段指令区域的起始地址。</li>
<li>数据段和代码段类似，只是这段区域存储的是程序运行所需要的数据，属于指令的操作数。数据段寄存器DS便是用来指向此数据区域的起始地址。</li>
<li>栈段是在内存中，硬盘文件中可真没有。一般的栈段是由操作系统分配指定的，所以是属于被加载到内存后才有的。栈段寄存器SS 就是用来指向此区域的起始地址。</li>
<li><p>值得说明的是在16 位CPU 中，只有一个附加段寄存器ES。而FS和GS附加段寄存器是在32 位CPU 中增加的。</p>
</li>
<li><p>IP寄存器是不可见寄存器，CS寄存器是可见寄存器。这两个配合在一起后就是CPU的罗盘。访问内存就要用“段：段内偏移”的形式，所以CS 寄存器用来存代码段段基址，IP 寄存器用来存储代码段段内偏移地址，同CS 寄存器一样都是16 位宽。</p>
</li>
<li>flags 寄存器是计算机的窗口，展示了CPU 内部各项设置、指标。任何一个指令的执行、其执行过程的细节、对计算机造成了哪些影响，都在flags 寄存器中通过一些标志位反映出来。</li>
<li>无论是实模式，还是保护模式，通用寄存器有8 个，分别是AX、BX、CX、DX、SI、DI、BP、SP。</li>
</ul>
<p><img src="/img/1590584080.jpg" alt></p>
<p>拿AX寄存器举例，根据图3-6可知，AX寄存器是由AH寄存器和AL寄存器组成的，它们都是8位寄存器，AX寄存器的低8位是AL寄存器。高8位是AH寄存器。由于某种原因，16位AX寄存器不够用了，将其扩展（Extend）为32位，在AX原有的基础上，增加16位作为高16位便是扩展的AX，即EAX。所以EAX归根结底也是由AL、AH组成的，AL或AH值变了直接影响EAX。</p>
<p>以上的这8个寄存器实际上是通用寄存器，通用是说每个寄存器的功能不单一，可以有多种用途，不像段寄存器SS那样只能用来放栈段基址，通用寄存器可以用来保存任何数据。一般情况下，cx寄存器用作循环的次数控制，bx寄存器用于存储起始地址。<br><img src="/img/1590585314.jpg" alt></p>
<h3 id="实模式下内存分段的由来"><a href="#实模式下内存分段的由来" class="headerlink" title="实模式下内存分段的由来"></a>实模式下内存分段的由来</h3><p>有了保护模式后，为了与老的模式区别开来，所以称老的模式为<strong>实模式</strong>。实模式的“实”体现在：<strong>程序中用到的地址都是真实的物理地址</strong>，“段基址：段内偏移”产生的逻辑地址就是物理地址，也就是程序员看到的完全是真实的内存。</p>
<p>为了让16位的寄存器寻址能够访问20位的地址空间，CPU 工程师定位到根本瓶颈是在段寄存器，它要是能提供20位的段地址，哪怕偏移地址是1也照样可以访问到内存的各个角落。于是，通过<strong>先把16位的段基址左移4位后变成20位，再加段内偏移地址，这样便形成了20位地址</strong>，只要保证了段基址是20位的，偏移地址是多少位都不关心了，从而突破了16位寄存器作为偏移地址而无法访问1MB空间的限制。</p>
<p>拿 0xFFFF 来说，现在能访问的最大的地址是0xFFFF：0xFFFF，经过左移段基址4位后得到的最大地址是：<strong>0xFFFF <em> 16 + 0xFFFF = 0xFFFF0 + 0xFFFF = 0xFFFFF + 0xFFF0 = 1M + 16 </em> 4KB - 16 - 1 = 0x10FFEF</strong>。得到的最大地址是<strong>1MB+64KB-16</strong>字节，因为这是空间范围，所以要减去1得到地址范围。多出来64K-16 字节，这部分内存就是传说中的高端内存区，但是这部分内存不存在。所以由于超过了20位而产生的进位，就给丢掉了。其作用相当于把地址对1MB取模了。</p>
<h3 id="实模式下CPU-内存寻址方式"><a href="#实模式下CPU-内存寻址方式" class="headerlink" title="实模式下CPU 内存寻址方式"></a>实模式下CPU 内存寻址方式</h3><p>下面把8086的寻址模式和大家说说。寻址方式，从大方向来看可以分为三大类：</p>
<ul>
<li>寄存器寻址；</li>
<li>立即数寻址；</li>
<li>内存寻址。<ul>
<li>直接寻址；</li>
<li>基址寻址；</li>
<li>变址寻址；</li>
<li>基址变址寻址。</li>
</ul>
</li>
</ul>
<p>寄存器寻址：最直接的寻址方式就是寄存器寻址，它是指“数”在寄存器中，直接从寄存器中拿数据就行了。例如下面用mul 指令实现0x10*0x9。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax, 0x10</span><br><span class="line">mov dx, 0x9</span><br><span class="line">mul dx</span><br></pre></td></tr></table></figure></p>
<p>以上三条指令都是寄存器寻址。第一条命令是将<code>0x10</code>存入ax寄存器，第二条命令是将<code>0x9</code>存入dx，第三条指令是求ax和dx的乘积，乘积的高16位在dx寄存器，低16位在ax寄存器。只要牵扯到寄存器的操作，无论其是源操作数，还是目的操作数，都是寄存器寻址。上面的第一、二条指令，它们的源操作数都是立即数，所以也属于立即数寻址。</p>
<p>立即数寻址：如果操作数“直接”存在指令中，直接拿过来，立即就能用了。为了突显“立即就能用”的高效率，此数便称为立即数。立即数免去了找数的过程。如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0x18</span><br><span class="line">mov ds, ax</span><br></pre></td></tr></table></figure></p>
<p>第一条指令中的源操作数0x18是立即数，目的操作数ax是寄存器，所以它既是立即数寻址，也是寄存器寻址。第二条指令中，源操作数和目的操作数都是寄存器，所以纯粹是寄存器寻址。提醒一下，像这样的寻址也是立即数寻址：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax, macro_selector</span><br><span class="line">mov ax, label_start</span><br></pre></td></tr></table></figure></p>
<p>第一条指令的源操作数<code>macro_selector</code>是个宏，第二条指令的源操作数<code>label_start</code>是个标号，这两个在编译阶段会转换为数字，最终可执行文件中的依然是立即数。</p>
<p>内存寻址：操作数在内存中的寻址方式称为内存寻址。<strong>大多数时候操作数位于内存中的某个位置，只知道操作数所在的内存地址，不知道操作数的值，更谈不上将其变成立即数用在指令中了，这就更加有理由让内存寻址成为“应该”</strong>。由于访问内存是用“段基址：偏内偏移地址”的形式，此形式只用在内存访问中。默认情况下数据段寄存器是DS，即段基址已经有了，只要再给出段内偏移地址就可以访问内存了，<strong>最终起决定作用的、有效的是段内偏移地址</strong>，所以段内偏移地址称为有效地址。以下所说的寻址方法都是在内存中寻址的方法。</p>
<p>直接寻址，就是将直接在操作数中给出的数字作为内存地址，通过中括号的形式告诉CPU，取此地址中的值作为操作数。如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax, [0x1234]</span><br><span class="line">mov ax, [fs:0x5678]</span><br></pre></td></tr></table></figure></p>
<p>0x1234 是段内偏移地址，默认的段地址是DS。这条指令是将内存地址<code>DS:0x1234</code>处的值写入ax寄存器。第二条指令中，由于使用了段跨越前缀<code>fs, 0x5678</code>的段基址则变成了gs寄存器。最终的内存地址是<code>gs寄存器的值*16+0x5678</code>，CPU到此内存地址取值再存入ax寄存器。</p>
<p>基址寻址，就是<strong>在操作数中用bx寄存器或寄存器作为地址的起始，地址的变化以它为基础</strong>。这里说的是<strong>只能用bx 或bp 作为基址寄存器</strong>。用寄存器作为内存寻址，到了保护模式下就没这个限制了，基址寄存器可选择的很多。说明一下，bx 寄存器的默认段寄存器是DS，而bp 寄存器的默认段寄存器是SS，即bp 和sp 都是栈的有效地址。</p>
<p>sp寄存器作为栈顶指针，相当于栈中数据的游标，这是专门给push 指令和pop 指令做导航用的寄存器，push 指令往哪个内存压入数据，popd 将哪个地址的数据弹出栈，都要看sp 的值是多少。在实模式下，CPU 字长是16，所以实模式下的push 指令默认情况下是压入2 字节的数据，其工作原理可以分为两步，假如执行push ax：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sub sp，2 先将sp 的值减去</span><br><span class="line">mov sp，ax 再将ax 的值mov 加到新的sp 指向的内存</span><br></pre></td></tr></table></figure></p>
<p>实模式下 pop 指令，其工作原理也分为两步，假如执行pop ax：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax， [sp] 先将sp 指向的值mov 到</span><br><span class="line">add sp，2 再将sp 的指针+2</span><br></pre></td></tr></table></figure></p>
<p>访问栈有两种方式，一种是把栈当成“栈”来使用，也就是用push 和pop 指令操作栈，但这样我们只能访问到栈顶，即sp 指向的地址，没有办法直接访问到栈底和栈顶之间的数据。很多时候，我们需要读写栈中的数据，即需要把栈当成普通数据段那样访问。<strong>举个需要直接写栈的例子，比如标志寄存器eflags 无法直接修改，只能用pushf指令把eflags寄存器的内容压到栈中，我们在栈中修改完后，再用popf 把它弹回到eflags 中</strong>。处理器为了让开发人员方便控制栈中数据，提供了这种把栈当成数据段来访问的方式，可以用寄存器bp 来给出栈中偏移量，所以bp 默认的段寄存器就是SS，这样就可通过SS：bp 的方式把栈当成普通的数据段来访问。</p>
<p>在32 位环境下，ebp寄存器应用在堆栈框架中，堆栈框架是<strong>编译器在栈中为局部变量分配内存空间的方式</strong>，局部变量存在于函数中，因此有关堆栈框架的汇编指令是在函数的开头和结尾处。下面通过这段代码了解堆栈框架的原理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int a = 0；</span><br><span class="line">function(int b, int c) &#123;</span><br><span class="line">    int d；</span><br><span class="line">&#125;</span><br><span class="line">a++；</span><br></pre></td></tr></table></figure></p>
<ol>
<li>调用<code>function(1,2)</code>；按照C语言调用规范，参数入栈的顺序从右到左：会先压入2，再压入1。每个参数在栈中各占4字节。</li>
<li>栈中再压入function的返回地址，此时栈顶的值是执行“a++”相关指令的地址。</li>
</ol>
<p>下面是堆栈框架的指令。</p>
<ol start="3">
<li><code>push ebp</code>；将ebp 压入栈，栈中备份ebp 的值，占用4 字节。</li>
<li><code>mov ebp, esp</code>；将esp 的值复制到ebp，ebp 作为堆栈框架的基址，可用于对栈中的局部变量和其他参数寻址。此时的 ebp 便是栈中局部变量的分界线。在这之后，esp 将自减一定的值为局部变量在栈中分配空间，该值取决于所有局部变量空间大小的总和。</li>
<li><code>sub esp, 4</code>；由于函数function 中有局部变量d，局部变量是在栈中存放的，故esp 要预留出4 字节，专门给变量d 使用。</li>
</ol>
<p>终于到了应用 ebp 指针的时候，以ebp 为基址对栈中数据寻址。</p>
<ul>
<li><code>[ebp-4]</code>是局部变量d，对应上面的第（5）步。</li>
<li><code>[ebp]</code>是ebp 在栈中的备份，对应上面的第（3）步。</li>
<li><code>[ebp+4]</code>是函数的返回地址，对应上面的第（2）步。</li>
<li>函数中的参数b是用<code>[ebp+8]</code>访问，参数c用<code>[ebp+12]</code>访问，对应上面的第（1）步。</li>
</ul>
<p>栈中数据的布局如图 3-8 所示。</p>
<ul>
<li>函数结束后跳过局部变量的空间：mov esp, ebp。</li>
<li>恢复ebp 的值：pop ebp。</li>
<li>至此函数中堆栈框架的指令结束了，然后是返回指令ret，接着主调函数中执行<code>add esp, 8</code>来回收参数b 和c 的空间。</li>
</ul>
<p><img src="/img/1590660105.jpg" alt></p>
<p>堆栈框架的工作是为函数分配局部变量空间，因此应该在刚刚进入函数时就进行为局部变量分配空间的工作，离开函数时再回收局部变量的空间。<br>数时进行的。</p>
<p>变址寻址其实和基址寻址类似，只是<strong>寄存器由bx、bp 换成了si 和di</strong>。si 是指源索引寄存器（source index），di 是指目的索引寄存器（destination index）。两个寄存器的默认段寄存器也是ds。<code>mov [di]，ax</code> ：将寄存器ax的值存入ds：di 指向的内存；<code>mov [si+0x1234], ax</code> ：变址中也可以加个偏移量。<strong>变址寻址主要是用于字符搬运方面的指令，这两个寄存器在很多指令中都要成对使用</strong>，如<code>movsb</code>，<code>movsw</code>，<code>movsd</code>等。</p>
<p>基址变址寻址；从名字上看，这是基址寻址和变址寻址的结合，即<strong>基址寄存器bx或bp加一个变址寄存器si或di</strong>。如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov [bx+di], ax</span><br><span class="line">add [bx+si], ax</span><br></pre></td></tr></table></figure></p>
<p>第一条指令是将ax中的值送入以ds为段基址，bx+di 为偏移地址的内存。第二条指令是将ax与<code>[ds：bx+si]</code>处的值相加后存入内存<code>[ds：bx+si]</code>。</p>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>给栈指定一片内存区域，区域的起始地址作为栈基址，存入<strong>栈基址寄存器SS</strong>中，另一端是动态变化的，<strong>用栈指针寄存器SP来指定</strong>，栈顶地址肯定小于栈底地址。栈中的内存地址用<strong>段基址SS的值*16+栈指针SP（段内偏移地址）形成的20位地址</strong>访问到的。硬件提供了相应的方法来存取栈，即push 和pop 指令。push 指令负责把数据压入栈，pop 指令功能相反，将其从栈中取出。</p>
<p><strong>栈指针寄存器SP中的值是段内偏移地址</strong>，是栈顶相对于栈底的偏移量。push压入数据的过程是：<strong>先将SP减去字长，目的是避免将栈顶的数据破坏，所得的差再存入SP，栈顶在此被更新，这样栈顶就指向了栈中下一个存储单元的位置</strong>。<strong>再将数据压入SP（新的栈顶）指向的新的内存地址</strong>。pop指令相反，栈指针寄存器SP的值增大一个数据单位。由于要弹出的数据就在当前栈顶，所以在弹出数据后，才将SP加上字长，所得的和再存入SP，从而更新了栈顶。<br><img src="/img/1590663438.jpg" alt></p>
<p>即使是这里的硬件栈，咱们也可以自己维护指针，如<code>push ax</code>可以这样代替：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov bp,sp</span><br><span class="line">sub bp, 2</span><br><span class="line">mov [bp],ax</span><br></pre></td></tr></table></figure></p>
<p>push 和pop 操作是要成对出现的，这样才能维护栈平衡。</p>
<h3 id="实模式下的call-ret"><a href="#实模式下的call-ret" class="headerlink" title="实模式下的call/ret"></a>实模式下的call/ret</h3><p>经过代码段段基址寄存器CS*16后再加上代码段的段内偏移地址寄存器IP的值，所得的和就是指令存放的内存地址。CPU 在此内存地址处获得指令并执行。所以说，<strong>CPU 前进的方向永远是CS：IP 这两个寄存器</strong>。call指令用来执行一段新的代码，需要返回指令ret来帮忙。<strong>ret（return）指令的功能是在栈顶（寄存器ss：sp 所指向的地址）弹出2 字节的内容来替换IP寄存器</strong>。<strong>retf（return far）是从栈顶取得4 字节，栈顶处的2 字节用来替换IP 寄存器，另外的2 字节用来替换CS 寄存器</strong>。<strong>retf指令会使sp指针+4</strong>。，<strong>call和ret是一对配合，用于近调用和近返回，call far和retf是一对配合，用于远调用和远返回</strong>。</p>
<p>在 8086 处理器中，也就是我们所说的实模式下，call 指令调用函数有四种方式。</p>
<ul>
<li>16 位实模式相对近调用：<strong>call 指令所调用目标函数和当前代码段是同一个段</strong>，所以只给出段内偏移地址。和“近”有关的调用就可以用关键字<code>near</code>来修饰，由于是在同一个代码段中，所以只要给出目标函数的<strong>相对地址</strong>即可。指令格式是<code>call near 立即数地址</code>。。此指令是个3字节指令，0xe8是此操作的操作码，占1 字节，剩下2 字节便是操作数。<ul>
<li>此操作数并不是目标函数的绝对地址，只是相对于目标函数地址的相对增量，所以此操作数并不能直接被CPU使用。CPU在实际执行中还要将此增量还原成绝对地址。所以此相对近调用并不能称为“直接”相对近调用。</li>
<li>near 的意思同数据类型伪指令word 一样，是指在内存地址处取2 字节内容，或者将操作数强制转换为2 字节。可以认为像near、short、far，这些用在调用或转移中的修饰符（后面会说到），其意义就是数据类型转换。</li>
</ul>
</li>
<li>16 位实模式间接绝对近调用。“间接”是指目标函数的地址并没有直接给出，地址要么在寄存器中，要么在内存中，总之不以立即数的形式出现。“绝对”是指目标函数的地址是绝对地址，不像“16 位相对近调用”中的那样是相对地址。指令的一般形式是<code>call 寄存器寻址</code>或<code>call 内存寻址</code>，如<code>call ax</code>，<code>call [0x1234]</code>。</li>
<li>16 位实模式直接绝对远调用。凡是包含“远”，就意指要跨段啦，目标函数和当前指令不在同一个段中。由于是远调用，所以CS 和IP 都要用新的，call 指令将来还是要回来的，所以要在栈中保留回来的路，即先把老的CS 寄存器压入栈，再把老的IP 寄存器压入栈后，用新的CS 和IP 寄存器替换，从此开启新<br>的旅途。<code>call far 段基址（立即数）：段内偏移地址（立即数）</code></li>
<li>16 位实模式间接绝对远调用。这和第 3 种的区别就是“直接”变“间接”了。也就是说，段基址和段内偏移地址，都不是立即数。16 位间接绝对远调用指令格式是：<code>call far 内存寻址</code>，如<code>call far [bx]</code>,<code>call far [0x1234]</code></li>
</ul>
<h3 id="实模式下的jmp"><a href="#实模式下的jmp" class="headerlink" title="实模式下的jmp"></a>实模式下的jmp</h3><p>jmp 转移指令<strong>只要更新CS：IP 寄存器或只更新IP 寄存器就好了</strong>，不需要保存它们的值，所以跳到新的地址后没办法再回来，它属于“一去不回头”地去执行新指令。和 call 一样，按远近（是否跨段）来划分，大致分为两类，<strong>近转移</strong>、<strong>远转移</strong>。不过在转移方式中，还有个更近的，叫短转移。相对近转移和相对短转移相比，就是操作数范围增大了，由8 位宽度变成了16 位宽度，操作数依然是地址相对量，可正可负，范围是-32768～32767。间接，是指<strong>操作数并不直接给出，而是存储在寄存器或内存中</strong>。绝对地址顾名思义，就是<strong>段内偏移地址</strong>，指的是“CS：IP”中的IP 值，偏移地址是16位。</p>
<h3 id="标志寄存器flags"><a href="#标志寄存器flags" class="headerlink" title="标志寄存器flags"></a>标志寄存器flags</h3><p>实模式下标志寄存器是16 位的flags，在32 位保护模式下，扩展（extend）了标志寄存器，成为32位的eflags。<br><img src="/img/1590665229.jpg" alt></p>
<ul>
<li>第0位为CF位，即Carry Flag，意为进位。因为CF 为1 时，也就是最高位有进位或借位，肯定是溢出。</li>
<li>第2位为PF位，即Parity Flag，意为奇偶位。用于标记结果低8 位中1 的个数。</li>
<li>第4位为AF位，即Auxiliary carry Flag，意为辅助进位标志，用来记录运算结果低4 位的进、借位情况。</li>
<li>第6位为ZF位，即Zero Flag，意为零标志位。若计算结果为0，此标志为1，否则为0。</li>
<li>第7位为SF位，即Sign Flag，意为符号标志位。若运算结果为负，则SF 位为1，否则为0。</li>
<li>第8位为TF位，即Trap Flag，意为陷阱标志位。此位若为1，用于让CPU 进入单步运行方式，若为0，则为连续工作的方式。</li>
<li>第9位为IF位，即Interrupt Flag，意为中断标志位。若IF 位为1，表示中断开启，CPU 可以响应外部可屏蔽中断。</li>
<li>第10位为DF位，即Direction Flag，意为方向标志位。此标志位用于字符串操作指令中，当DF 为1 时，指令中的操作数地址会自动减少一个单位。</li>
<li>第11位为OF位，即Overflow Flag，意为溢出标志位。用来标识计算的结果是否超过了数据类型可表示的范围</li>
</ul>
<h3 id="有条件转移"><a href="#有条件转移" class="headerlink" title="有条件转移"></a>有条件转移</h3><p>如果条件满足，jxx 将会跳转到指定的位置去执行，否则继续顺序地执行下一条指令。其格式为 jxx 目标地址。若条件满足则跳转到目标地址，否则顺序执行下一条指令。其中，<strong>目标地址只能是段内偏移地址</strong>。在实模式下，由编译器根据当前指令与目标地址的偏移量，自行将其编译成短转移或近转移。条件转移指令一定得在某个能够影响标志位的指令之后进行。<br><img src="/img/1590665476.jpg" alt></p>
<h2 id="让我们直接对显示器说点什么吧"><a href="#让我们直接对显示器说点什么吧" class="headerlink" title="让我们直接对显示器说点什么吧"></a>让我们直接对显示器说点什么吧</h2><p>为了简化CPU 访问外部设备的工作，能够轻松地同任何硬件通信，约定好IO 接口的功能:</p>
<ol>
<li>设置数据缓冲，解决CPU 与外设的速度不匹配</li>
<li>设置信号电平转换电路</li>
<li>设置数据格式转换</li>
<li>设置时序控制电路来同步CPU 和外部设备</li>
<li>提供地址译码</li>
</ol>
<p>同一时刻，CPU 只能和一个IO 接口通信。使用一个芯片<strong>仲裁IO 接口的竞争，还要连接各种内部总线</strong>。由于它的使命，它的名字就叫做<strong>输入输出控制中心</strong>（I/O control hub，ICH），也就是<strong>南桥芯片</strong>。南桥用于连接pci、pci-express、AGP 等低速设备，北桥用于连接高速设备，如内存。<strong>南桥提供了专门用于扩展的接口，这就是PCI 接口</strong>。<br><img src="/img/1590665713.jpg" alt></p>
<p>IO 接口是连接CPU和硬件的桥梁，一端是CPU，另一端是硬件。<strong>端口是IO接口开放给CPU的接口</strong>。端口也是寄存器，寄存器就有数据宽度，有8位、16位、32位。CPU 提供了专门的指令来干这事，<strong>in和out</strong>。</p>
<p><strong>in指令用于从端口中读取数据</strong>，其一般形式是：</p>
<ol>
<li><code>in al, dx</code>；</li>
<li><code>in ax, dx</code>。</li>
</ol>
<p>其中<strong>al 和ax 用来存储从端口获取的数据</strong>，dx 是指端口号。这是固定用法，<strong>只要用in指令，源操作数（端口号）必须是dx</strong>，而目的操作数是用al，还是ax，取决于dx 端口指代的寄存器是8 位宽度，还是16 位宽度。</p>
<p>out 指令用于往端口中写数据，其一般形式是：</p>
<ol>
<li>out <code>dx, al</code></li>
<li>out <code>dx,ax</code></li>
<li>out <code>立即数, al</code></li>
<li>out <code>立即数, ax</code></li>
</ol>
<p>注意啦，这和 in 指令相反，<strong>in 指令的源操作数是端口号，而out 指令中的目的操作数是端口号</strong>。</p>
<h2 id="硬盘介绍"><a href="#硬盘介绍" class="headerlink" title="硬盘介绍"></a>硬盘介绍</h2><p>通过读写硬盘控制器的端口让硬盘工作，端口就是位于IO控制器上的寄存器，此处的端口是指硬盘控制器上的寄存器。<br><img src="/img/1591320347.jpg" alt></p>
<p>端口可以被分为两组，<strong>Command Block registers</strong>和<strong>Control Block registers</strong>。Command Block registers<br>用于向硬盘驱动器写入命令字或者从硬盘控制器获得硬盘状态，Control Block registers 用于控制硬盘工作状态。下面重点介绍Command Block registers 组中的寄存器。</p>
<ul>
<li>data寄存器是负责管理数据的，其作用是读取或写入数据。数据的读写还是越快越好，所以此寄存器较其他寄存器宽一些，16 位；</li>
<li>读硬盘时，端口0x171或0x1F1的寄存器名字叫Error寄存器，只在读取硬盘失败时有用，里面才会记录失败的信息，尚未读取的扇区数在Sector count 寄存器中；在写硬盘时，此寄存器有了别的用途，用来存储额外参数，叫Feature 寄存器。</li>
<li>Sector count 寄存器用来指定待读取或待写入的扇区数；</li>
<li>用28位比特来描述一个扇区的地址，最大可寻址范围是2的28次方，称为LBA方法，与之对应的LBA low、LBA mid、LBA high三个寄存器都是8位宽度的。<ul>
<li>LBA low 寄存器用来存储28位地址的第0～7位，LBA mid寄存器用来存储第8～15位，LBA high寄存器存储第16～23位。</li>
</ul>
</li>
<li>device寄存器是个杂项，它的宽度是8位。<ul>
<li>在此寄存器的低4位用来存储LBA地址的第24～27 位。</li>
<li>第4位用来指定通道上的主盘或从盘，0代表主盘，1代表从盘。</li>
<li>第6位用来设置是否启用LBA方式，1代表启用LBA模式，0代表启用CHS模式。</li>
<li>另外的两位：第5位和第7位是固定为1的，称为MBS位。</li>
</ul>
</li>
<li>端口0x1F7或0x177的寄存器名称是Status，它是8位宽度的寄存器，用来给出硬盘的状态信息；在写硬盘时，端口0x1F7或0x177的寄存器名称是command。</li>
</ul>
<p>一般硬盘操作的基本顺序：</p>
<ol>
<li>先选择通道，往该通道的sector count 寄存器中写入待操作的扇区数。</li>
<li>往该通道上的三个LBA 寄存器写入扇区起始地址的低24 位。</li>
<li>往device 寄存器中写入LBA 地址的24～27 位，并置第6 位为1，使其为LBA 模式，设置第4位，选择操作的硬盘（master 硬盘或slave 硬盘）。</li>
<li>往该通道上的command 寄存器写入操作命令。</li>
<li>读取该通道上的status 寄存器，判断硬盘工作是否完成。</li>
<li>如果以上步骤是读硬盘，进入下一个步骤。否则，完工。</li>
<li>将硬盘数据读出。</li>
</ol>
<p>硬盘工作完成后，它已经准备好了数据，咱们该怎么获取呢？一般常用的数据传送方式如下。</p>
<ol>
<li>无条件传送方式。数据源设备一定是随时准备好了数据。</li>
<li>查询传送方式。称为程序I/O、PIO（Programming Input/Output Model），是指传输之前，由程序先去检测设备的状态。数据源设备在一定的条件下才能传送数据</li>
<li>中断传送方式。也称为中断驱动I/O。通知CPU 可以采用中断的方式，当数据源设备准备好数据后，它通过发中断来通知CPU 来拿数据</li>
<li>直接存储器存取方式（DMA）。完全由数据源设备和内存直接传输，CPU 直接到内存中拿数据就好了</li>
<li>I/O 处理机传送方式。</li>
</ol>
<h1 id="让-MBR-使用硬盘"><a href="#让-MBR-使用硬盘" class="headerlink" title="让 MBR 使用硬盘"></a>让 MBR 使用硬盘</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line">;主引导程序</span><br><span class="line">;------------------------------------------------------------</span><br><span class="line">%include &quot;boot.inc&quot;</span><br><span class="line">SECTION MBR vstart=0x7c00</span><br><span class="line">mov ax,cs</span><br><span class="line">mov ds,ax</span><br><span class="line">mov es,ax</span><br><span class="line">mov ss,ax</span><br><span class="line">mov fs,ax</span><br><span class="line">mov sp,0x7c00</span><br><span class="line">mov ax,0xb800</span><br><span class="line">mov gs,ax</span><br><span class="line">;清屏</span><br><span class="line">;利用0x06 号功能，上卷全部行，则可清屏</span><br><span class="line">; -----------------------------------------------------------</span><br><span class="line">;INT 0x10 功能号：0x06 功能描述：上卷窗口</span><br><span class="line">;------------------------------------------------------</span><br><span class="line">;输入：</span><br><span class="line">;AH 功能号= 0x06</span><br><span class="line">;AL = 上卷的行数（如果为0，表示全部）</span><br><span class="line">;BH = 上卷行属性</span><br><span class="line">;(CL,CH) = 窗口左上角的(X,Y)位置</span><br><span class="line">;(DL,DH) = 窗口右下角的(X,Y)位置</span><br><span class="line">;无返回值：</span><br><span class="line"></span><br><span class="line">mov ax, 0600h</span><br><span class="line">mov bx, 0700h</span><br><span class="line">mov cx, 0 ; 左上角: (0, 0)</span><br><span class="line">mov dx, 184fh ; 右下角: (80,25),</span><br><span class="line">; 因为VGA 文本模式中，一行只能容纳80 个字符，共25 行</span><br><span class="line">; 下标从0 开始，所以0x18=24，0x4f=79</span><br><span class="line">int 10h ; int 10h</span><br><span class="line">; 输出字符串:MBR</span><br><span class="line">mov byte [gs:0x00],&apos;1&apos;</span><br><span class="line">mov byte [gs:0x01],0xA4</span><br><span class="line">mov byte [gs:0x02],&apos; &apos;</span><br><span class="line">mov byte [gs:0x03],0xA4</span><br><span class="line">mov byte [gs:0x04],&apos;M&apos;</span><br><span class="line">mov byte [gs:0x05],0xA4</span><br><span class="line">;表示绿色背景闪烁,4 表示前景色为红色</span><br><span class="line">mov byte [gs:0x06],&apos;B&apos;</span><br><span class="line">mov byte [gs:0x07],0xA4</span><br><span class="line">mov byte [gs:0x08],&apos;R&apos;</span><br><span class="line">mov byte [gs:0x09],0xA4</span><br><span class="line">mov eax,LOADER_START_SECTOR ; 起始扇区lba 地址</span><br><span class="line">mov bx,LOADER_BASE_ADDR ; 写入的地址</span><br><span class="line">mov cx,1 ; 待读入的扇区数</span><br><span class="line">call rd_disk_m_16 ; 以下读取程序的起始部分(一个扇区)</span><br><span class="line">jmp LOADER_BASE_ADDR</span><br><span class="line">;-------------------------------------------------------------------------------</span><br><span class="line">;功能:读取硬盘n 个扇区</span><br><span class="line">rd_disk_m_16:</span><br><span class="line">;-------------------------------------------------------------------------------</span><br><span class="line">; eax=LBA 扇区号</span><br><span class="line">; bx=将数据写入的内存地址</span><br><span class="line">; cx=读入的扇区数</span><br><span class="line">mov esi,eax ;备份eax</span><br><span class="line">mov di,cx ;备份cx</span><br><span class="line">;读写硬盘:</span><br><span class="line">;第1 步:设置要读取的扇区数</span><br><span class="line">mov dx,0x1f2</span><br><span class="line">mov al,cl</span><br><span class="line">out dx,al ;读取的扇区数</span><br><span class="line">mov eax,esi ;恢复ax</span><br><span class="line">;第2 步:将LBA 地址存入0x1f3 ～ 0x1f6</span><br><span class="line">;LBA 地址7～0 位写入端口0x1f3</span><br><span class="line">mov dx,0x1f3</span><br><span class="line">out dx,al</span><br><span class="line">;LBA 地址15～8 位写入端口0x1f4</span><br><span class="line">mov cl,8</span><br><span class="line">shr eax,cl</span><br><span class="line">mov dx,0x1f4</span><br><span class="line">out dx,al</span><br><span class="line">;LBA 地址23～16 位写入端口0x1f5</span><br><span class="line">shr eax,cl</span><br><span class="line">mov dx,0x1f5</span><br><span class="line">out dx,al</span><br><span class="line">shr eax,cl</span><br><span class="line">and al,0x0f ;lba 第24～27 位</span><br><span class="line">or al,0xe0 ; 设置7～4 位为1110,表示lba 模式</span><br><span class="line">mov dx,0x1f6</span><br><span class="line">out dx,al</span><br><span class="line"></span><br><span class="line">;第3 步:向0x1f7 端口写入读命令,0x20</span><br><span class="line">mov dx,0x1f7</span><br><span class="line">mov al,0x20</span><br><span class="line">out dx,al</span><br><span class="line">;第4 步:检测硬盘状态</span><br><span class="line">.not_ready:</span><br><span class="line">;同一端口,写时表示写入命令字,读时表示读入硬盘状态</span><br><span class="line">nop</span><br><span class="line">in al,dx</span><br><span class="line">and al,0x88 ;第4 位为1 表示硬盘控制器已准备好</span><br><span class="line">; 第7 位为1 表示硬盘忙</span><br><span class="line">cmp al,0x08</span><br><span class="line">jnz .not_ready ;若未准备好,继续等</span><br><span class="line">;第5 步:从0x1f0 端口读数据</span><br><span class="line">mov ax, di</span><br><span class="line">mov dx, 256</span><br><span class="line">mul dx</span><br><span class="line">mov cx, ax</span><br><span class="line">; di 为要读取的扇区数,一个扇区有512 字节,每次读入一个字</span><br><span class="line">; 共需di*512/2 次,所以di*256</span><br><span class="line">mov dx, 0x1f0</span><br><span class="line">.go_on_read:</span><br><span class="line">in ax,dx</span><br><span class="line">mov [bx],ax</span><br><span class="line">add bx,2</span><br><span class="line">loop .go_on_read</span><br><span class="line">ret</span><br><span class="line">times 510-($-$$) db 0</span><br><span class="line">db 0x55,0xaa</span><br></pre></td></tr></table></figure>
<p>程序最开始的%include “boot.inc”，这个%include 是nasm 编译器中的预处理指令，意思是让编译器在编译之前把boot.inc 文件包含进来。</p>
<p>第 50～52 行为函数rd_disk_m_16 传递参数。在此说明一下，汇编语言中定义的函数（或者称为例程，proc），由于汇编语言能够直接操作寄存器，所以其传递参数可以用寄存器，也可以用栈。用寄存器传参数，没有固定的形式，原则上用哪个寄存器都行，此函数需要三个参数，我们选择用eax、bx、cx 寄存器来传递参数。</p>
<p>寄存器 cx 是读入的扇区数，cx 其值为1。到底读入几个扇区，是由实际文件大小来决定的。由于将来会写一个简单的loader，其大小肯定不会超过512 字节，所以此处读入的扇区数置为1 即可。</p>
<p>函数名rd_disk_m_16 的意思是“在16 位模式下读硬盘”。第 64 行的“mov esi，eax”是把eax 中的值先备份到esi 中。因为al 在out 指令中会被用到，这会影响到eax 的低8 位。第 65 行是备份读取的扇区数到di 寄存器，di 寄存器是16 位的，和cx 大小一致。cx 的值会在读取数据时用到，所以在此提前备份。第 67～70 行，按照咱们操作硬盘的约定，先选定一个通道，再往sector count 寄存器中写扇区数。往端口中写入数据用out 指令，注意out 指令中dx 寄存器是用来存储端口号的。其操作格式可见3.3.1 节的结尾部分。</p>
<p>第 74～95 行是将LBA 地址写入三个LBA 寄存器和device 寄存器的低4 位。端口0x1f3 是寄存器LBAlow，端口0x1f4 是寄存器LBA mid，端口0x1f5 是寄存器LBA high。shr 指令是逻辑右移指令，这里主要通过此指令置换出地址的相应部分，写入相应的LBA 寄存器。第93 行的“or al，0xe0”，用了or“或”指令和0xe0 做或运算，拼出device 寄存器的值。高4 位为e，即高4 位的二进制表示为1110，其第5 位和第7 位固定为1，第6 位为1 表示启用LBA。第 97～100 行便是写入命令啦，因为我们这里是读操作，所以读扇区的命令是0x20。通过out 指令写入command 端口0x1f7 后，硬盘就开始工作了。</p>
<p>第 102～109 行检测status 寄存器的BSY 位。由于status 寄存器依然是0x1f7 端口，所以不需要再为dx 重新赋值。105 行的nop 表示空操作，即什么也不做，只是为了增加延迟，相当于sleep 了一小下，目的是减少打扰硬盘的工作。第 111～122 行是从硬盘取数据的过程。由于data 寄存器是16 位，即每次in 操作只读入2 字节，根据读入的数据总量（扇区数*512 字节）来求得执行in 指令的次数。第 123 行返回指令ret，它用来从函数中返回。</p>
<h1 id="保护模式入门"><a href="#保护模式入门" class="headerlink" title="保护模式入门"></a>保护模式入门</h1><h2 id="保护模式概述"><a href="#保护模式概述" class="headerlink" title="保护模式概述"></a>保护模式概述</h2><h3 id="为什么要有保护模式"><a href="#为什么要有保护模式" class="headerlink" title="为什么要有保护模式"></a>为什么要有保护模式</h3><p>实模式的缺点：</p>
<ol>
<li>实模式下操作系统和用户程序属于同一特权级，这哥俩平起平坐，没有区别对待。</li>
<li>用户程序所引用的地址都是指向真实的物理地址，也就是说逻辑地址等于物理地址，实实在在地指哪打哪。</li>
<li>用户程序可以自由修改段基址，可以不亦乐乎地访问所有内存，没人拦得住。</li>
</ol>
<p>以上 3 个原因属于安全缺陷，没有安全可言的CPU 注定是不可依赖的，这决定了用户程序乃至操作系统的数据都可以被随意地删改，一旦出事往往都是灾难性的，而且不容易排查。</p>
<ol>
<li>访问超过64KB 的内存区域时要切换段基址，转来转去容易晕乎。</li>
<li>一次只能运行一个程序，无法充分利用计算机资源。</li>
<li>共20 条地址线，最大可用内存为1MB，这即使在20 年前也不够用。</li>
</ol>
<p>保护模式下，物理内存地址不能直接被程序访问，程序内部的地址（虚拟地址）需要被转化为物理地址后再去访问。</p>
<p>我们说实模式时，指的是32 位的CPU 运行在16 位模式下的状态，不是CPU 变身成纯粹的16位啦，大家不要感到迷惑。</p>
<h2 id="初见保护模式"><a href="#初见保护模式" class="headerlink" title="初见保护模式"></a>初见保护模式</h2><h3 id="保护模式之寄存器扩展"><a href="#保护模式之寄存器扩展" class="headerlink" title="保护模式之寄存器扩展"></a>保护模式之寄存器扩展</h3><p>为了让一个寄存器就能访问 4GB 空间，需要寄存器宽度提升到32 位。除段寄存器外，通用寄存器、指令指针寄存器、标志寄存器都由原来的16 位扩展到了32 位。<strong>注意段寄存器用16位就够用了</strong>。</p>
<p>寄存器要保持向下兼容，不能推翻之前的方案从头再来，必须在原有的基础上扩展（extend），各寄存器在原有16 位的基础上，再次向高位扩展了16 位，成为了32 位寄存器。经过extend 后的寄存器，统一在名字前加了e 表示扩展，<br><img src="/img/1593400518.jpg" alt></p>
<p>左边已经标注名字的寄存器有通用寄存器组，名字前统一加了字符E表示扩展，同样，EFLAGS寄存器和EIP分别在FLAGS和IP基础上扩展而成。图下边的6个段寄存器，依然是16 位。<strong>寄存器中低16位的部分可以单独使用</strong>。高16位没办法单独使用，只能在用32位寄存器时才有机会用到它们。</p>
<p>偏移地址与实模式下的一样，但段基址可不是简单的一个地址的事了，专门找了个数据结构—<strong>全局描述符表</strong>，其中每一个表项称为段描述符，其大小为64字节，用来<strong>描述各个内存段的起始地址、大小、权限等信息</strong>。该全局描述符表很大，所以放在了内存中，由<strong>GDTR寄存器</strong>指向它就行。</p>
<p>这样，<strong>段寄存器中保存的内容叫“选择子”</strong>，selector，该选择子其实就是个数，用这个数来索引全局描述符表中的段描述符，把全局描述符表当成数组，选择子就像数组下标一样。对段寄存器应用了缓存技术，将段信息用一个寄存器来缓存，这就是<strong>段描述符缓冲寄存器</strong>。以后每次访问相同的段时，就直接读取该段寄存器对应的段描述符缓冲寄存器。</p>
<p>段描述符缓冲寄存器也可以用在实模式下，在实模式下时，段基址左移4位后的结果就被放入段描述符缓冲寄存器中，以后每次引用一个段时，就直接走段描述符缓冲寄存器，直到该段寄存器被重新赋值。</p>
<p>80286虽然有了保护模式，但其依然是16位的CPU，其通用寄存器还是16位宽。但其与8086不同的是其地址线由20位变为了24位，即寻址空间变成了2的24次方，等于16MB大小。</p>
<p>有了保护模式，之前的实模式下的程序还得兼容，所以便有了个“过渡模式”，即虚拟8086 模式。因为80286是首款具备保护模式的CPU，而之前的CPU都是只有实模式，最有代表性的、应用最广的CPU 是8086。综上所述，CPU 有三种模式：实模式、虚拟8086 模式、保护模式。</p>
<h3 id="保护模式之寻址扩展"><a href="#保护模式之寻址扩展" class="headerlink" title="保护模式之寻址扩展"></a>保护模式之寻址扩展</h3><p>在保护模式下的内存寻址中，基址寄存器不再只是bx、bp，而是所有32位的通用寄存器，变址寄存器也是一样，不再只是si、di，而是除esp 之外的所有32 位通用寄存器，偏移量由实模式的16位变成了32位。并且，还可以对变址寄存器乘以一个比例因子，注意比例因子，只能是1、2、4、8。<br><img src="/img/1593401302.jpg" alt></p>
<p>具体形式如下代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov eax，[eax+edx*8+0x12345678]</span><br><span class="line">mov eax，[eax+edx*2+0x8]</span><br><span class="line">mov eax，[ecx*4+0x1234]</span><br></pre></td></tr></table></figure></p>
<p>虽然esp 无法用作变址寄存器，但其可用于基址寄存器。所以，如下代码是正确的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov eax，[esp]</span><br><span class="line">mov eax，[esp+2]</span><br></pre></td></tr></table></figure></p>
<h3 id="保护模式之运行模式反转"><a href="#保护模式之运行模式反转" class="headerlink" title="保护模式之运行模式反转"></a>保护模式之运行模式反转</h3><p>编译器提供了<strong>伪指令bits</strong>，用它来向编译器传达：我下面的指令都要编译成xx位的，因为我知道下面的代码的运行环境是xx 模式。比如在实模式下，运行的指令都是16 位的，所以编译器要将代码编译成16 位的指令。在实模式下准备好了保护模式所需要的环境后，进入保护模式后的代码就应该是32 位指令。也就是，同一段程序要经历两种模式，所以同一段程序中有两种模式的机器码。bits 指令的范围是从当前bits 标签直到下一个bits 标签的范围，这个范围中的代码将被编译成相应字长的机器码。</p>
<p>bits 的指令格式是[bits 16]或[bits 32]。</p>
<ul>
<li>[bits 16]是告诉编译器，下面的代码帮我编译成16 位的机器码。</li>
<li>[bits 32]是告诉编译器，下面的代码帮我编译成32 位的机器码。</li>
</ul>
<p><img src="/img/1593401486.jpg" alt></p>
<p>如果要用另一模式下的操作数大小，需要<strong>在指令前添加指令前缀0x66</strong>，将当前模式临时改变成另一模式。这就是反转的意义，不管是当前模式是什么，总是转变成相反的运行模式。比如，在指令中添加了 0x66 反转前缀之后：</p>
<ul>
<li>假设当前运行模式是 16 位实模式，操作数大小将变为32 位。</li>
<li>假设当前运行模式是 32 位保护模式，操作数大小将变为16 位。</li>
<li>这个转换只是临时的，只在当前指令有效。</li>
</ul>
<p><img src="/img/1593401932.jpg" alt><br>第 5 行是16 位指令，但当前已在32 位模式下，所以要用操作数反转前缀0x66 来临时将当前模式的32 位操作数反转成16 位大小的操作数，故机器码是66B83412。最前面的0x66 正是反转前缀，b8、3412分别是操作码和操作数。</p>
<p>寻址方式反转前缀0x67：不同模式之间不仅可以使用对方模式下的操作数，还可以使用对方模式下的寻址方式。第3行把eax 寄存器作为基址寻址，eax 寄存器不属于实模式，所以在机器码前添加了寻址方式反转前缀0x67。<br><img src="/img/1593402008.jpg" alt></p>
<h3 id="保护模式之指令扩展"><a href="#保护模式之指令扩展" class="headerlink" title="保护模式之指令扩展"></a>保护模式之指令扩展</h3><p>mul 指令是无符号数相乘指令，指令格式是<code>mul 寄存器/内存</code>。其中“寄存器/内存”是乘数。</p>
<ul>
<li>如果乘数是 8 位，则把寄存器al 当作另一个乘数，结果便是16 位，存入寄存器ax。</li>
<li>如果乘数是 16 位，则把寄存器ax 当作另一个乘数，结果便是32 位，存入寄存器eax。</li>
<li>如果乘数是32 位，则把寄存器eax 当作另一个乘数，结果便是64 位，存入edx：eax，其中edx 是积的高32 位，eax 是积的低32 位。</li>
</ul>
<p>对于无符号数除法指令div，其格式是div 寄存器/内存，其中的“寄存器/内存”是除法计算中的除数。</p>
<ul>
<li>如果除数是8 位，被除数就是16 位，位于寄存器ax。所得的结果，商在寄存器al，余数在寄存器ah。</li>
<li>如果除数是16 位，被除数就是32 位，被除数的高16 位则位于寄存器dx，被除数的低16 位则位于寄存器ax。所得的结果，商在寄存器ax，余数在寄存器dx。</li>
<li>如果除数是32 位，被除数就是64 位，被除数的高32 位则位于寄存器edx，被除数的低32 位则位于寄存器eax，所得的结果，商在寄存器eax，余数在寄存器edx。</li>
</ul>
<p>对于 push 指令，需要根据其操作数的类型，分别讨论，操作数类型如下。</p>
<ol>
<li>立即数。</li>
<li>寄存器。</li>
<li>内存。</li>
</ol>
<p>第 1 种情况，对于立即数来说，可以分别压入8 位、16 位、32 位数据。指令格式是：</p>
<ul>
<li>push 8 位立即数</li>
<li>push 16 位立即数</li>
<li>push 32 位立即数</li>
</ul>
<p>虽说可以压入8位立即数，但实际上，对于CPU 来说，出于对齐的考虑，操作数要么是16 位，要么是32 位，所以8 位立即数会被扩展成各模式下的默认操作数宽度，即实模式下8 位立即数扩展成为16 位后再入栈，保护模式下扩展成为32 位后再入栈。</p>
<p>在实模式环境下：</p>
<ul>
<li>当压入 8 位立即数时，由于实模式下默认操作数是16 位，CPU 会将其扩展为16 位后再将其入栈，sp-2。</li>
<li>当压入 16 位立即数时，CPU 会将其直接入栈，sp-2。</li>
<li>当压入 32 位立即数时，CPU 会将其直接入栈，sp-4。</li>
</ul>
<p>在保护模式下，同样是这些压入立即数的指令，栈指针会有怎样的变化呢？</p>
<ul>
<li>当压入 8 位立即数时，由于保护模式下默认操作数是32 位，CPU 将其扩展为32 位后入栈，esp 指针减4。</li>
<li>当压入 16 位立即数时，CPU 直接压入2 字节，esp 指针减2。</li>
<li>当压入 32 位立即数时，CPU 直接压入4 字节，esp 指针减4。</li>
</ul>
<p>实模式下每次压入一个段寄存器，栈指针sp 都会减2。保护模式下每次压入一个段寄存器，栈指针esp 都会减4。对于通用寄存器和内存，无论是在实模式或保护模式：</p>
<ul>
<li>如果压入的是 16 位数据，栈指针减2。</li>
<li>如果压入的是 32 位数据，栈指针减4。</li>
</ul>
<h2 id="全局描述符表"><a href="#全局描述符表" class="headerlink" title="全局描述符表"></a>全局描述符表</h2><p>全局描述符表（Global Descriptor Table，GDT）是保护模式下内存段的登记表，这是不同于实模式的显著特征之一。</p>
<h3 id="段描述符"><a href="#段描述符" class="headerlink" title="段描述符"></a>段描述符</h3><p>用来描述内存段的属性被放到了一个称为段描述符的结构中，该结构专门用来描述一个内存段，该结构是8字节大小。<br><img src="/img/1593402478.jpg" alt></p>
<p>保护模式下地址总线宽度是 32 位，段基址需要用32 位地址来表示。<strong>段界限表示段边界的扩展最值</strong>，即最大扩展到多少或最小扩展到多少。扩展方向只有上下两种。<strong>对于数据段和代码段，段的扩展方向是向上</strong>，即地址越来越高，此时的段界限用来表示段内偏移的最大值。<strong>对于栈段，段的扩展方向是向下</strong>，即地址越来越低，此时的段界限用来表示段内偏移的最小值。</p>
<p>段界限用20 个二进制位来表示。只不过此段界限只是个单位量，它的单位要么是字节，要么是4KB，这是由描述符中的G位来指<br>定的。最终段的边界是<strong>此段界限值*单位</strong>，故段的大小要么是2的20次方等于1MB，要么是2的32次方（4KB 等于2 的12 次方，12+20=32）等于4GB。</p>
<p>上面所说的1MB 和4GB 只是个范围，并不是具体的边界值。由于段界限只是个偏移量，是从0 算起的，所以<strong>实际的段界限边界值=（描述符中段界限+1）*（段界限的粒度大小：4KB 或者1）-1</strong>。</p>
<p>如果 G 位为0，表示段界限粒度大小为1 字节，根据上面的公式，<strong>实际段界限=（描述符中段界限+1）*1 -1=描述符中段界限</strong>，段界限实际大小就等于描述符中的段界限值。</p>
<p>如果 G 位为1，表示段界限粒度大小为4KB 字节，故<strong>实际段界限=（描述符中段界限+1）*4k-1</strong>。举个例子，如果是平坦模型，段界限为0xFFFFF，G位为1，套用上面公式，<strong>段界限边界值=0x100000*0x1000-1=0xFFFFFFFF</strong>。</p>
<p>段描述符的低32位分为两部分，<strong>前16位用来存储段的段界限的前0～15位，后16位用来存储段基址的0～15位</strong>。主要的属性都在段描述符的高32位。</p>
<ul>
<li>0～7位是段基址的16～23，24～31位是段基址的24～31位，加上在段描述符低32位中的段基址0～15位，这下32位基地址才算齐全了。</li>
<li>8～11 位是type字段，<strong>共4位</strong>，用来<strong>指定本描述符的类型</strong>。<ul>
<li>一个段描述符，分为系统段/数据段，这是由段描述符中的S位决定的，用它指示是否是系统段。S为0时表示系统段，S为1时表示数据段。</li>
<li>type字段是要和S字段配合在一起才能确定段描述符的确切类型</li>
<li>称为“门”的结构便是系统段，也就是硬件系统需要的结构。门的意思就是入口，它通往一段程序。</li>
<li>该字段共4 位，用于表示内存段或门的子类型。</li>
</ul>
</li>
</ul>
<p><img src="/img/1593403153.jpg" alt></p>
<ul>
<li>表中的 A 位表示Accessed位，这是由CPU来设置的，每当该段被CPU访问过后，CPU 就将此位置1。</li>
<li>C 表示一致性代码段，也称为依从代码段。一致性代码段是指如果自己是转移的目标段，并且自己是一致性代码段，自己的特权级一定要高于当前特权级，转移后的特权级不与自己的DPL 为主，而是与转移前的低特权级一致，也就是听从、依从转移前的低特权级。C 为1 时则表示该段是一致性代码段，C 为0 时则表示该段为非一致性代码段。</li>
<li>R 表示可读，R 为1 表示可读，R 为0 表示不可读。这个属性一般用来限制代码段的访问。如果指令执行过程中，CPU 发现某些指令对R 为0 的段进行访问，如使用段超越前缀CS 来访问代码段，CPU 将抛出异常。</li>
<li>X 表示该段是否可执行，EXecutable。我们所说的指令和数据，在CPU 眼中是没有任何区别的，都是010101 这样类似的二进制。所以要用type 中的X 位来标识出是否是可执行的代码。代码段是可执行的，即X 为1。而数据段是不可执行的，即X 为0。</li>
<li>E 是用来标识段的扩展方向，Extend。E 为0 表示向上扩展，即地址越来越高，通常用于代码段和数据段。E 为1 表示向下扩展，地址越来越低，通常用于栈段。</li>
<li><p>W 是指段是否可写，Writable。W 为1 表示可写，通常用于数据段。W 为0表示不可写入，通常用于代码段。对于W 为0 的段有写入行为，同样会引发CPU 抛出异常。</p>
</li>
<li><p>段描述符的第12位是S字段，用来指出当前描述符是否是系统段。S为0表示系统段，S为1表示非系统段。</p>
</li>
<li>段描述符的第13～14位是DPL字段，Descriptor Privilege Level，即<strong>描述符特权级</strong>，这是保护模式提供的安全解决方案，将计算机世界按权力划分成不同等级，每一种等级称为一种特权级。由于段描述符用来描述一个内存段或一段代码的情况（若描述符类型为“门”），所以描述符中的DPL是指所代表的内存段的特权级。<ul>
<li>这两位能表示4 种特权级，分别是0、1、2、3 级特权，数字越小，特权级越大。</li>
<li>某些指令只能在0 特权级下执行，从而保证了安全。</li>
</ul>
</li>
<li>段描述符的第15 位是P 字段，Present，即段是否存在。如果段存在于内存中，P 为1，否则P 为0。P 字段是由CPU 来检查的，如果为0，CPU 将抛出异常。</li>
<li>段描述符的第 20 位为AVL 字段，从名字上看它是AVaiLable，可用的。不过这“可用的”是对用户来说的，也就是操作系统可以随意用此位。</li>
<li>段描述符的第21 位为L 字段，用来设置<strong>是否是64 位代码段</strong>。L 为1 表示64 位代码段，否则表示32位代码段。</li>
<li>段描述符的第22 位是D/B字段，用来指示有效地址（段内偏移地址）及操作数的大小。与指令相关的内存段是代码段和栈段，所以此字段是D 或B。<ul>
<li>对于代码段来说，此位是D 位，若D为0，表示指令中的有效地址和操作数是16位，指令有效地址用IP寄存器。</li>
<li>若D为1，表示指令中的有效地址及操作数是32 位，指令有效地址用EIP 寄存器。</li>
<li>对于栈段来说，此位是B 位，用来指定操作数大小，若B为0用sp寄存器；若B为1用esp寄存器。</li>
</ul>
</li>
<li>段描述符的第23位是G 字段，Granularity，粒度，用来指定段界限的单位大小。所以此位是用来配合段界限的。<ul>
<li>若G为0，表示段界限的单位是1 字节，这样段最大是2的20次方*1字节，即1MB。</li>
<li>若G为1，表示段界限的单位是4KB，这样段最大是2 的20次方*4KB字节，即4GB。</li>
</ul>
</li>
</ul>
<h3 id="全局描述符表GDT、局部描述符表LDT-及选择子"><a href="#全局描述符表GDT、局部描述符表LDT-及选择子" class="headerlink" title="全局描述符表GDT、局部描述符表LDT 及选择子"></a>全局描述符表GDT、局部描述符表LDT 及选择子</h3><p>一个段描述符只用来描述一个内存段。<strong>代码段要占用一个段描述符、数据段和栈段等，多个内存段也要各自占用一个段描述符</strong>，放在全局描述符表，它相当于是描述符的数组，数组中的每个元素都是8 字节的描述符。可以用选择子（马上会讲到）中提供的下标在GDT中索引描述符。</p>
<p>全局描述符表位于内存中，需要用专门的寄存器指向它后，CPU 才知道它在哪里。这个专门的寄存器便是GDTR，即GDT Register，专门用来存储GDT 的内存地址及大小。GDTR 是个48位的寄存器。<code>lgdt</code>为gdtr初始化。</p>
<p>为了进入保护模式才讲述lgdt，因此看上去此指令是在实模式下执行的，但实际上，<strong>此指令在保护模式下也能够执行</strong>。言外之意便是<strong>进入保护模式需要有GDT，但进入保护模式后，还可以再重新换个GDT 加载</strong>。在保护模式下重新换个GDT 的原因是实模式下只能访问低端1MB空间，所以GDT只能位于1MB之内。在进入保护模式后，访问的内存空间突破了1MB，可以将GDT 放在合适的位置后再重新加载进来。</p>
<p>lgdt的指令格式是：<code>lgdt 48位内存数据</code>。这 48 位内存数据划分为两部分，其中<strong>前16位是GDT以字节为单位的界限值</strong>，所以这16位相当于GDT的字节大小减1。<strong>后32位是GDT的起始地址</strong>。由于GDT的大小是16位二进制，其表示的范围是2<br>的16次方等于65536字节。每个描述符大小是8字节，<strong>GDT中最多可容纳的描述符数量是65536/8=8192个</strong>，即GDT 中可容纳8192 个段或门。</p>
<p>段寄存器 CS、DS、ES、FS、GS、SS，<strong>在实模式下时，段中存储的是段基地址</strong>，即内存段的起始地址。而在保护模式下时，由于段基址已经存入了段描述符中，所以段寄存器中再存放段基址是没有意义的，<strong>在段寄存器中存入的是一个叫作选择子的东西</strong>。用此索引值在段描述符表中索引相应的段描述符，这样，便在段描述符中得到了内存段的起始地址和段界限值等相关信息。</p>
<p>由于段寄存器是16位，所以选择子也是16位：</p>
<ul>
<li>在其低2位即第0～1位，用来存储RPL，即请求特权级，可以表示0、1、2、3 四种特权级。</li>
<li>在选择子的第2位是TI位，即Table Indicator，用来指示选择子是在GDT中，还是LDT中。</li>
<li>选择子的高13 位，即第3～15 位是描述符的索引值，用此值在GDT中索引描述符。前面说过GDT相当于一个描述符数组，所以此选择子中的索引值就是GDT 中的下标</li>
</ul>
<p>选择子的作用主要是确定段描述符，确定描述符的目的，一是为了特权级、界限等安全考虑，最主要的还是要确定段的基地址。</p>
<p>保护模式下的段寄存器中已经是选择子，不再是直接的段基址。段基址在段描述符中，用给出的选择子索引到描述符后，CPU 自动从段描述符中取出段基址，这样再加上段内偏移地址，便凑成了“段基址：段内偏移地址”的形式。<br><img src="/img/1593426673.jpg" alt></p>
<p>局部描述符表，叫LDT，Local Descriptor Table，它是CPU厂商为在硬件一级原生支持多任务而创造的表，按照CPU 的设想，一个任务对应一个LDT。LDT 也位于内存中，其地址需要先被加载到某个寄存器后，CPU 才能使用LDT，该寄存器是LDTR，即LDT Register。同样也有专门的指令用于加载LDT，即lldt。以后每切换任务时，都要用lldt 指令重新加载任务的私有内存段。</p>
<p>段描述符是需要用选择子去访问的。故，lldt 的指令格式为：<code>lldt 16 位寄存器/16 位内存</code>，无论是寄存器，还是内存，其内容一定是个选择子，该选择子用来在GDT 中索引LDT 的段描述符。</p>
<p>实模式下寄存器都是16位的，如果段基址和段内偏移地址都为16位的最大值，即0xFFFF：0xFFFF，最大地址是0xFFFF0+0xFFFF，即0x10FFEF。由于实模式下的地址线是20位，最大寻址空间0x00000～0xFFFFF。超出1MB内存的部分在逻辑上也是正常的，将超过1MB 的部分自动回绕到0地址，继续从0地址开始映射。相当于把地址对1MB 求模。超过1MB 多余出来的内存被称为<strong>高端内存区HMA</strong>。</p>
<p>地址（Address）线从0开始编号，在8086/8088 中，20 位地址线表示的内存是2 的20 次方即0x0～0xFFFFF。若地址进位到1MB 以上，如0x100000，由于没有第21 位地址线，相当于丢掉了进位1，变成了0x00000。用某根输出线来控制第21 根地址线（A20）的有效性，故被称为A20Gate。</p>
<ul>
<li>如果 A20Gate 被打开，当访问到0x100000～0x10FFEF 之间的地址时，CPU 将真正访问这块物理内存。</li>
<li>如果 A20Gate 被禁止，当访问0x100000～0x10FFEF 之间的地址时，CPU 将采用8086/8088 的地址回绕。</li>
</ul>
<p>其实打开A20Gate 的方式是极其简单的，将端口0x92 的第1 位置1 就可以了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">in al，0x92</span><br><span class="line">or al，0000_0010B</span><br><span class="line">out 0x92，al</span><br></pre></td></tr></table></figure></p>
<h3 id="保护模式的开关，CR0-寄存器的PE-位"><a href="#保护模式的开关，CR0-寄存器的PE-位" class="headerlink" title="保护模式的开关，CR0 寄存器的PE 位"></a>保护模式的开关，CR0 寄存器的PE 位</h3><p>控制寄存器是CPU 的窗口，既可以用来展示CPU的内部状态，也可用于控制CPU 的运行机制。这次我们要用到的是CR0 寄存器。更准确地说，我们要用到CR0寄存器的第0 位，即PE 位，Protection Enable，此位用于启用保护模式，是保护模式的开关。<br><img src="/img/1593431715.png" alt><br><img src="/img/1593431741.jpg" alt></p>
<h2 id="处理器微架构简介"><a href="#处理器微架构简介" class="headerlink" title="处理器微架构简介"></a>处理器微架构简介</h2><h3 id="流水线"><a href="#流水线" class="headerlink" title="流水线"></a>流水线</h3><h3 id="乱序执行"><a href="#乱序执行" class="headerlink" title="乱序执行"></a>乱序执行</h3><p>乱序执行，是指在CPU 中运行的指令并不按照代码中的顺序执行，而是按照一定的策略打乱顺序执行，也许后面的指令先执行，当然，得保证指令之间不具备相关性。</p>
<p>x86 发展到后来，虽然还是CISC 指令集，但其内部已经采用RISC 内核，译码对于x86 体系来说，除了按照指令格式分析机器码外，还要将CISC 指令分解成多个RISC 指令。当一个“大”操作被分解成多个“微”操作时，它们之间通常独立无关联，所以非常适合乱序执行。</p>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>根据程序的局部性原理采取缓存策略。</p>
<h3 id="分支预测"><a href="#分支预测" class="headerlink" title="分支预测"></a>分支预测</h3><p>对于无条件跳转，直接跳过去就是了。所谓的预测是针对有条件跳转来说的，因为不知道条件成不成立。最简单的统计是根据上一次跳转的结果来预测本次，如果上一次跳转啦，这一次也预测为跳转，否则不跳。</p>
<p>最简单的方法是2 位预测法。<strong>用2 位bit 的计数器来记录跳转状态</strong>，每跳转一次就加1，直到加到最大值3 就不再加啦，如果未跳转就减1，直到减到最小值0 就不再减了。当遇到跳转指令时，如果计数器的值大于1 则跳转，如果小于等于1 则不跳。</p>
<p>Intel 的分支预测部件中用了分支目标缓冲器（Branch Target Buffer，BTB）。<br><img src="/img/1593535623.jpg" alt></p>
<p>BTB 中记录着分支指令地址，CPU 遇到分支指令时，先用分支指令的地址在BTB 中查找，若找到相同地址的指令，根据跳转统计信息判断是否把相应的预测分支地址上的指令送上流水线。在真正执行时，根据实际分支流向，更新BTB 中跳转统计信息。</p>
<p>如果 BTB 中没有相同记录该怎么办呢？这时候可以使用<strong>Static Predictor，静态预测器</strong>，存储在里面的预测策略是固定写死的。比如，转移目标的地址若小于当前转移指令的地址，则认为转移会发生。静态预测器的策略是：若向上跳转则转移会发生，若向下跳转则转移不发生。</p>
<p>如果分支预测错了，也就是说，当前指令执行结果与预测的结果不同，需要将流水线清空。因为处于执行阶段的是当前指令，即分支跳转指令。处于“译码”“取指”的是尚未执行的指令，即错误分支上的指令。</p>
<h3 id="使用远跳转指令清空流水线，更新段描述符缓冲寄存器"><a href="#使用远跳转指令清空流水线，更新段描述符缓冲寄存器" class="headerlink" title="使用远跳转指令清空流水线，更新段描述符缓冲寄存器"></a>使用远跳转指令清空流水线，更新段描述符缓冲寄存器</h3><p>段描述符缓冲寄存器在CPU 的实模式和保护模式中都同时使用，在不重新引用一个段时，段描述符缓冲寄存器中的内容是不会更新的，无论是在实模式，还是保护模式下，CPU 都以段描述符缓冲寄存器中的内容为主。<strong>实模式进入保护模式时，由于段描述符缓冲寄存器中的内容仅仅是实模式下的20 位的段基址，很多属性位都是错误的值，这对保护模式来说必然会造成错误，所以需要马上更新段描述符缓冲寄存器，也就是要想办法往相应段寄存器中加载选择子。</strong></p>
<p>CPU 为了提高效率而采用了流水线，这样，<strong>指令间是重叠执行的</strong>。某一行之前的指令都是16 位指令，自此行之后，CPU 便进入了保护模式，但它依然还是16 位的指令，相当于处于16 位保护模式下。为了让其使用32 位偏移地址，所以添加了伪指<br>令dword，故其机器码前会加0x66 反转前缀。</p>
<p>流水线的工作是这样的：在16位指令代码执行的同时，32位指令及其之后的部分指令已经被送上流水线了，但是，段描述符缓冲寄存器在实模式下时已经在使用了，其低20位是段基址，但其他位默认为0，也就是描述符中的D 位为0，这表示当前的操作数大小是16 位。流水线上的指令全是按照16 位操作数来译码的，所以需要加入一个无条件跳转指令。综上所述，解决问题的关键就是既要改变代码段描述符缓冲寄存器的值，又要清空流水线。</p>
<p><strong>代码段寄存器cs，只有用远过程调用指令call、远转移指令jmp、远返回指令retf 等指令间接改变，没有直接改变cs 的方法，如直接mov cs，xx 是不行的。另外，之前介绍过了流水线原理，CPU 遇到jmp指令时，之前已经送上流水线上的指令只有清空，所以jmp 指令有清空流水线的神奇功效。</strong></p>
<h2 id="保护模式之内存段的保护"><a href="#保护模式之内存段的保护" class="headerlink" title="保护模式之内存段的保护"></a>保护模式之内存段的保护</h2><h3 id="向段寄存器加载选择子时的保护"><a href="#向段寄存器加载选择子时的保护" class="headerlink" title="向段寄存器加载选择子时的保护"></a>向段寄存器加载选择子时的保护</h3><p><strong>当引用一个内存段时，实际上就是往段寄存器中加载选择子</strong>，为了避免出现非法引用内存段的情况，在这时候，处理器会在以下几方面做出检查。</p>
<p>首先<strong>根据选择子的值验证段描述符是否超越界限</strong>。选择子的高13位是段描述符的索引值，第0～1位是RPL，第2 位是TI 位。首先<strong>选择子的索引值一定要小于等于描述符表（GDT 或LDT）中描述符的个数</strong>。在往段寄存器中加载选择子时，处理器要求选择子中的索引值要满足下面表达式：<strong>描述符表基地址+选择子中的索引值*8+7 &lt;=描述符表基地址+描述符表界限值</strong>。</p>
<p>检查过程如下：处理器先检查TI 的值，如果TI 是0，则从全局描述符表寄存器gdtr 中拿到GDT基地址和GDT 界限值。如果TI 是1，则从局部描述符表寄存器ldtr 中拿到LDT 基地址和LDT 界限值。有了描述符表基地址和描述符表界限值后，把选择子的高13 位代入上面的表达式，若不成立，处理器则抛出异常。<br><img src="/img/1593571524.jpg" alt></p>
<p>段描述符中还有个type 字段，这用来表示段的类型，也就是不同的段有不同的作用。在选择子检查过后，就要检查段的类型了。这里主要是检查段寄存器的用途和段类型是否匹配。大的原则如下。</p>
<ul>
<li>只有具备可执行属性的段（代码段）才能加载到 CS 段寄存器中。</li>
<li>只具备执行属性的段（代码段）不允许加载到除 CS 外的段寄存器中。</li>
<li>只有具备可写属性的段（数据段）才能加载到 SS 栈段寄存器中。</li>
<li>至少具备可读属性的段才能加载到 DS、ES、FS、GS 段寄存器中。</li>
<li>如果 CPU 发现有任意上述规则不符，检查就不会通过。</li>
</ul>
<p><img src="/img/1593571866.png" alt></p>
<p><strong>检查完 type 后，还会再检查段是否存在。</strong>CPU 通过段描述符中的P 位来确认内存段是否存在，如果P 位为1，则表示存在，这时候就可以将选择子载入段寄存器了，同时段描述符缓冲寄存器也会更新为选择子对应的段描述符的内容，随后处理器将段描述符中的A 位置为1，表示已经访问过了。如果P 位为0，则表示该内存段不存在，不存在的原因可能是由于内存不足，操作系统将该段移出内存转储到硬盘上了。这时候处理器会抛出异常，自动转去执行相应的异常处理程序，异常处理程序将段从硬盘加载到内存后并将P 位置为1，随后返回。CPU 继续执行刚才的操作，判断P 位。</p>
<h3 id="代码段和数据段的保护"><a href="#代码段和数据段的保护" class="headerlink" title="代码段和数据段的保护"></a>代码段和数据段的保护</h3><p>代码段既然也是内存中的区域，所以对于代码段的访问也要用“<strong>段基址：段内偏移地址</strong>”的形式，在32 位保护模式下，段基址存放在CS 寄存器中，段内偏移地址，即<strong>有效地址，存放在EIP 寄存器中</strong>。CS：EIP 只是指令的起始地址，指令本身也是有长度的，之前我们见过各种各样的机器码，它们的长度有2 字节的、3 字节的等，如<code>jmp .-2</code>，其机器码为ebfe，大小就是2 字节。CPU 得确保指令“完全、完整”地任意一部分都在当前的代码段内，也就是要满足以下条件：</p>
<ul>
<li>EIP 中的偏移地址+指令长度-1≤实际段界限大小</li>
<li>如果不满足条件，指令未完整地落在本段内，CPU 则会抛出异常。</li>
</ul>
<p><img src="/img/1593573199.jpg" alt></p>
<p>数据地址也要遵循此原则：偏移地址+数据长度-1≤实际段界限大小。</p>
<h3 id="栈段的保护"><a href="#栈段的保护" class="headerlink" title="栈段的保护"></a>栈段的保护</h3><p>虽然段描述符type 中的e 位用来表示段的扩展方向，但它和别的描述符属性一样，仅仅是用来描述段的性质，即使e 等于1 向下扩展，依然可以引用不断向上递增的内存地址，即使e 等于0 向上扩展，也依然可以引用不断向下递减的内存地址。栈顶指针[e]sp 的值逐渐降低，这是push 指令的作用，与描述符是否向下扩展无关，也就是说，是数据段就可以用作栈。</p>
<p>CPU 对数据段的检查，其中一项就是看地址是否超越段界限。如果将向上扩展的数据段用作栈，那CPU 将按照上一节提到的数据段的方式检查该段。如果用向下扩展的段做栈的话，情况有点复杂，这体现在段界限的意义上。</p>
<ul>
<li>对于向上扩展的段，实际的段界限是段内可以访问的最后一字节。</li>
<li>对于向下扩展的段，实际的段界限是段内不可以访问的第一个字节。</li>
</ul>
<p>栈的段界限是以栈段的基址为基准的，并不是以栈底，因此栈的段界限肯定是位于栈顶之下。地址本身由低向高发展，段界限也是个地址，而栈的扩展方向是由高地址向低地址，与段界限有个碰撞的趋势。为了避免碰撞，将段界限地址+1 视为栈可以访问的下限。段界限+1，才是栈指针可达的下边界。<br><img src="/img/1593573776.jpg" alt></p>
<p>32 位保护模式下栈的栈顶指针是esp 寄存器，栈的操作数大小是由B 位决定的，我们这里假设B 为1，即操作数是32 位。栈段也是位于内存中，所以它也要受控于段描述符中的G 位。</p>
<ul>
<li>如果 G 为0，<code>实际的段界限大小=描述符中的段界限</code>。</li>
<li>如果 G 为1，<code>实际的段界限大小=描述符中段界限*0x1000+0xFFF</code>。</li>
</ul>
<p>同代码段的操作数一样，用于压栈的操作数也有其长度，push 指令每向栈中压入操作数时，实际上就是<strong>将esp 指针减去操作数的大小（2 字节或4 字节）后，再将操作数复制到esp 减4 后的新地址</strong>。栈指针可访问的最低地址是由实际段界限决定的，但栈段最大可访问的地址是由B 位决定的，我们这里B 位为1，表示32 位操作数，所以栈指针最大可访问地址是0xFFFFFFFF。综上所述，每次向栈中压入数据时就是CPU 检查栈段的时机，它要求必须满足以下条件。</p>
<ul>
<li>实际段界限+1≤esp-操作数大小≤ 0xFFFFFFFF<ul>
<li>假设现在esp 指针为0xFFFFE002，段描述符的G 位为1，描述符中的段界限为0xFFFFD。故实际段界限为0x1000*FFFFD+0xFFF=0xFFFFDFFF。当执行push ax，压入2 字节的操作数，即esp-2=0xFFFFE000，新的esp 值≥实际段界限0xFFFFDFFF +1。如果执行push eax，压入4 字节的数据，esp-4=0xFFFFDFFE，小于实际段界限0xFFFFDFFF，故CPU 会抛出异常。</li>
</ul>
</li>
<li>由于 esp 只是栈段内的偏移地址，其真正物理地址还要加上段基址。假设段基址为0，故该栈段：<ul>
<li>最大可访问地址为 0+0xFFFFFFFF=0xFFFFFFFF。</li>
<li>最小可访问地址为 0+0xFFFFDFFF+1=0xFFFFE000。</li>
<li>栈段空间大小为 0xFFFFFFFF-0xFFFFE000=8KB。</li>
</ul>
</li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/操作系统/" rel="tag"># 操作系统</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/04/06/深入理解cpp11_新特性解析与应用_笔记3/" rel="next" title="深入理解C++11_新特性解析与应用 笔记3">
                <i class="fa fa-chevron-left"></i> 深入理解C++11_新特性解析与应用 笔记3
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/04/10/cpp的rvo/" rel="prev" title="C++ RVO">
                C++ RVO <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/header.jpg" alt="Hao Yu">
            
              <p class="site-author-name" itemprop="name">Hao Yu</p>
              <p class="site-description motion-element" itemprop="description">Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author</p>
          </div>
          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">303</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>
        	<audio controls="controls" loop="loop" preload="auto" src="/resource/xiaomeihao.mp3">
	        </audio>
	

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yuhao0102" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:yuh18@mails.tsinghua.edu.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#一些你可能正感到迷惑的问题"><span class="nav-number">1.</span> <span class="nav-text">一些你可能正感到迷惑的问题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#软件是如何访问硬件的"><span class="nav-number">1.1.</span> <span class="nav-text">软件是如何访问硬件的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#应用程序操作系统是如何配合到一起的"><span class="nav-number">1.2.</span> <span class="nav-text">应用程序操作系统是如何配合到一起的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么称为“陷入”内核"><span class="nav-number">1.3.</span> <span class="nav-text">为什么称为“陷入”内核</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内存访问为什么要分段"><span class="nav-number">1.4.</span> <span class="nav-text">内存访问为什么要分段</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#代码中为什么分为代码段、数据段？"><span class="nav-number">1.5.</span> <span class="nav-text">代码中为什么分为代码段、数据段？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#物理地址、逻辑地址、有效地址、线性地址、虚拟地址的区别"><span class="nav-number">1.6.</span> <span class="nav-text">物理地址、逻辑地址、有效地址、线性地址、虚拟地址的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是段重叠"><span class="nav-number">1.7.</span> <span class="nav-text">什么是段重叠</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是平坦模型"><span class="nav-number">1.8.</span> <span class="nav-text">什么是平坦模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#cs、ds-这类sreg-段寄存器，位宽是多少"><span class="nav-number">1.9.</span> <span class="nav-text">cs、ds 这类sreg 段寄存器，位宽是多少</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是工程，什么是协议"><span class="nav-number">1.10.</span> <span class="nav-text">什么是工程，什么是协议</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#局部变量和函数参数为什么要放在栈中"><span class="nav-number">1.11.</span> <span class="nav-text">局部变量和函数参数为什么要放在栈中</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#编译型程序与解释型程序的区别"><span class="nav-number">1.12.</span> <span class="nav-text">编译型程序与解释型程序的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是大端字节序、小端字节序"><span class="nav-number">1.13.</span> <span class="nav-text">什么是大端字节序、小端字节序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BIOS-中断、DOS-中断、Linux-中断的区别"><span class="nav-number">1.14.</span> <span class="nav-text">BIOS 中断、DOS 中断、Linux 中断的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Section-和Segment-的区别"><span class="nav-number">1.15.</span> <span class="nav-text">Section 和Segment 的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#操作系统是如何识别文件系统的"><span class="nav-number">1.16.</span> <span class="nav-text">操作系统是如何识别文件系统的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何控制-CPU-的下一条指令"><span class="nav-number">1.17.</span> <span class="nav-text">如何控制 CPU 的下一条指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#库函数是用户进程与内核的桥梁"><span class="nav-number">1.18.</span> <span class="nav-text">库函数是用户进程与内核的桥梁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MBR、EBR、DBR-和OBR-各是什么"><span class="nav-number">1.19.</span> <span class="nav-text">MBR、EBR、DBR 和OBR 各是什么</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#部署工作环境"><span class="nav-number">2.</span> <span class="nav-text">部署工作环境</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#我们需要哪些编译器"><span class="nav-number">2.1.</span> <span class="nav-text">我们需要哪些编译器</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#编写MBR-主引导记录，让我们开始掌权"><span class="nav-number">3.</span> <span class="nav-text">编写MBR 主引导记录，让我们开始掌权</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#计算机的启动过程"><span class="nav-number">3.1.</span> <span class="nav-text">计算机的启动过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#软件接力第一棒，BIOS"><span class="nav-number">3.2.</span> <span class="nav-text">软件接力第一棒，BIOS</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#实模式下的1MB内存布局"><span class="nav-number">3.2.1.</span> <span class="nav-text">实模式下的1MB内存布局</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#让-MBR-先飞一会儿"><span class="nav-number">3.3.</span> <span class="nav-text">让 MBR 先飞一会儿</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#完善MBR"><span class="nav-number">4.</span> <span class="nav-text">完善MBR</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#地址、section、vstart-浅尝辄止"><span class="nav-number">4.1.</span> <span class="nav-text">地址、section、vstart 浅尝辄止</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CPU-的实模式"><span class="nav-number">4.2.</span> <span class="nav-text">CPU 的实模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#实模式下内存分段的由来"><span class="nav-number">4.2.1.</span> <span class="nav-text">实模式下内存分段的由来</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实模式下CPU-内存寻址方式"><span class="nav-number">4.2.2.</span> <span class="nav-text">实模式下CPU 内存寻址方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#栈"><span class="nav-number">4.2.3.</span> <span class="nav-text">栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实模式下的call-ret"><span class="nav-number">4.2.4.</span> <span class="nav-text">实模式下的call/ret</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实模式下的jmp"><span class="nav-number">4.2.5.</span> <span class="nav-text">实模式下的jmp</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#标志寄存器flags"><span class="nav-number">4.2.6.</span> <span class="nav-text">标志寄存器flags</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#有条件转移"><span class="nav-number">4.2.7.</span> <span class="nav-text">有条件转移</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#让我们直接对显示器说点什么吧"><span class="nav-number">4.3.</span> <span class="nav-text">让我们直接对显示器说点什么吧</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#硬盘介绍"><span class="nav-number">4.4.</span> <span class="nav-text">硬盘介绍</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#让-MBR-使用硬盘"><span class="nav-number">5.</span> <span class="nav-text">让 MBR 使用硬盘</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#保护模式入门"><span class="nav-number">6.</span> <span class="nav-text">保护模式入门</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#保护模式概述"><span class="nav-number">6.1.</span> <span class="nav-text">保护模式概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么要有保护模式"><span class="nav-number">6.1.1.</span> <span class="nav-text">为什么要有保护模式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#初见保护模式"><span class="nav-number">6.2.</span> <span class="nav-text">初见保护模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#保护模式之寄存器扩展"><span class="nav-number">6.2.1.</span> <span class="nav-text">保护模式之寄存器扩展</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#保护模式之寻址扩展"><span class="nav-number">6.2.2.</span> <span class="nav-text">保护模式之寻址扩展</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#保护模式之运行模式反转"><span class="nav-number">6.2.3.</span> <span class="nav-text">保护模式之运行模式反转</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#保护模式之指令扩展"><span class="nav-number">6.2.4.</span> <span class="nav-text">保护模式之指令扩展</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#全局描述符表"><span class="nav-number">6.3.</span> <span class="nav-text">全局描述符表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#段描述符"><span class="nav-number">6.3.1.</span> <span class="nav-text">段描述符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#全局描述符表GDT、局部描述符表LDT-及选择子"><span class="nav-number">6.3.2.</span> <span class="nav-text">全局描述符表GDT、局部描述符表LDT 及选择子</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#保护模式的开关，CR0-寄存器的PE-位"><span class="nav-number">6.3.3.</span> <span class="nav-text">保护模式的开关，CR0 寄存器的PE 位</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#处理器微架构简介"><span class="nav-number">6.4.</span> <span class="nav-text">处理器微架构简介</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#流水线"><span class="nav-number">6.4.1.</span> <span class="nav-text">流水线</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#乱序执行"><span class="nav-number">6.4.2.</span> <span class="nav-text">乱序执行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缓存"><span class="nav-number">6.4.3.</span> <span class="nav-text">缓存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分支预测"><span class="nav-number">6.4.4.</span> <span class="nav-text">分支预测</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用远跳转指令清空流水线，更新段描述符缓冲寄存器"><span class="nav-number">6.4.5.</span> <span class="nav-text">使用远跳转指令清空流水线，更新段描述符缓冲寄存器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#保护模式之内存段的保护"><span class="nav-number">6.5.</span> <span class="nav-text">保护模式之内存段的保护</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#向段寄存器加载选择子时的保护"><span class="nav-number">6.5.1.</span> <span class="nav-text">向段寄存器加载选择子时的保护</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#代码段和数据段的保护"><span class="nav-number">6.5.2.</span> <span class="nav-text">代码段和数据段的保护</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#栈段的保护"><span class="nav-number">6.5.3.</span> <span class="nav-text">栈段的保护</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>
  <div id="DvelopmentTarget">     
  </div>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart" aria-hidden="false"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>

  
</div>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_uv"> 
  本站访客数<span id="busuanzi_value_site_uv"></span>人次
</span>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  


  <script type="text/javascript" src="/js/src/love.js"></script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
