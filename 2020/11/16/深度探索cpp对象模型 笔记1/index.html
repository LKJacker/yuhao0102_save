<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zn-ch">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-center-simple.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="C++,">










<meta name="description" content="第1章 关于对象C中数据和处理数据的函数是分开定义的，语言本身并没有支持“数据和函数”之间的关联性。C++与C不同，用独立的抽象数据结构来实现，或是通过一个双层或三层的继承体系实现。更进一步，他们都能够被参数化。例如一个点类型Point：123456789101112template &amp;lt;class type&amp;gt;class Point3d &amp;#123;public:    Point3d(">
<meta name="keywords" content="C++">
<meta property="og:type" content="article">
<meta property="og:title" content="深度探索C++对象模型 笔记1">
<meta property="og:url" content="http://yoursite.com/2020/11/16/深度探索cpp对象模型 笔记1/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="第1章 关于对象C中数据和处理数据的函数是分开定义的，语言本身并没有支持“数据和函数”之间的关联性。C++与C不同，用独立的抽象数据结构来实现，或是通过一个双层或三层的继承体系实现。更进一步，他们都能够被参数化。例如一个点类型Point：123456789101112template &amp;lt;class type&amp;gt;class Point3d &amp;#123;public:    Point3d(">
<meta property="og:locale" content="zn-ch">
<meta property="og:image" content="http://yoursite.com/img/1605490522.jpg">
<meta property="og:image" content="http://yoursite.com/img/1605490857.jpg">
<meta property="og:image" content="http://yoursite.com/img/1605490985.jpg">
<meta property="og:image" content="http://yoursite.com/img/1605497643.jpg">
<meta property="og:image" content="http://yoursite.com/img/1605627052.jpg">
<meta property="og:image" content="http://yoursite.com/img/1605627288.jpg">
<meta property="og:image" content="http://yoursite.com/img/1605628063.jpg">
<meta property="og:image" content="http://yoursite.com/img/1605801747.jpg">
<meta property="og:image" content="http://yoursite.com/img/1605801829.jpg">
<meta property="og:image" content="http://yoursite.com/img/1605802474.jpg">
<meta property="og:image" content="http://yoursite.com/img/1605851633.jpg">
<meta property="og:updated_time" content="2020-12-03T09:07:07.379Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="深度探索C++对象模型 笔记1">
<meta name="twitter:description" content="第1章 关于对象C中数据和处理数据的函数是分开定义的，语言本身并没有支持“数据和函数”之间的关联性。C++与C不同，用独立的抽象数据结构来实现，或是通过一个双层或三层的继承体系实现。更进一步，他们都能够被参数化。例如一个点类型Point：123456789101112template &amp;lt;class type&amp;gt;class Point3d &amp;#123;public:    Point3d(">
<meta name="twitter:image" content="http://yoursite.com/img/1605490522.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/11/16/深度探索cpp对象模型 笔记1/">





  <title>深度探索C++对象模型 笔记1 | Hao Yu's blog</title>
  








 
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zn-ch">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hao Yu's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">The program monkey was eaten by the siege lion.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/resume.pdf" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-mybetterhalf">
          <a href="/mybetterhalf/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>
            
            mybetterhalf
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/11/16/深度探索cpp对象模型 笔记1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">深度探索C++对象模型 笔记1</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-11-16T09:13:00+08:00">
                2020-11-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="第1章-关于对象"><a href="#第1章-关于对象" class="headerlink" title="第1章 关于对象"></a>第1章 关于对象</h1><p>C中数据和处理数据的函数是分开定义的，语言本身并没有支持“数据和函数”之间的关联性。C++与C不同，用独立的<strong>抽象数据结构</strong>来实现，或是通过一个双层或三层的继承体系实现。更进一步，他们都能够被<strong>参数化</strong>。例如一个点类型<code>Point</code>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Point3d</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point3d(type x = <span class="number">0.0</span>, type y = <span class="number">0.0</span>, type z = <span class="number">0.0</span>)</span><br><span class="line">        : _x(x), _y(y), _z(z) &#123;&#125;</span><br><span class="line">    <span class="function">type <span class="title">x</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> _x;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setx</span><span class="params">(type xval)</span> </span>&#123;x = xval;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    type _x;</span><br><span class="line">    type _y;</span><br><span class="line">    type _z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>也可以坐标类型和坐标数目都参数化：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">type</span>, <span class="title">int</span> <span class="title">dim</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point();</span><br><span class="line">    Point(type coords[dim]) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; dim; index ++) </span><br><span class="line">            _coords[index] = coords[index];</span><br><span class="line">    &#125;</span><br><span class="line">    type&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index) &#123;</span><br><span class="line">        assert(index &lt; dim &amp;&amp; index &gt;= <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> _coords[index];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    type _coords[dim];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="加入封装后的布局成本"><a href="#加入封装后的布局成本" class="headerlink" title="加入封装后的布局成本"></a>加入封装后的布局成本</h2><p>答案是并没有增加布局成本。就像C struct一样，data members直接在每一个object中，但是<strong>memeber functions虽然含在class的声明之内，却不出现在object中</strong>。每一个non-inline member function只会<strong>诞生一个函数实体</strong>。至于每一个<strong>拥有零个或一个定义</strong>的inline function则会在其每一个使用者(模块)身上产生一个函数实体。</p>
<p>C++在布局以及存取时间上主要的额外负担是由<strong>virtual引起的</strong>，包括：</p>
<ul>
<li>virtual funciton机制，用以支持一个有效率的<strong>执行期绑定</strong>（runtime binding）</li>
<li>virtual base class，用以实现<strong>多次出现在继承体系中的base class，有一个单一而被共享的实体</strong></li>
</ul>
<h2 id="C-对象模式-The-C-Object-Model"><a href="#C-对象模式-The-C-Object-Model" class="headerlink" title="C++ 对象模式(The C++ Object Model)"></a>C++ 对象模式(The C++ Object Model)</h2><p>在C++中，有两种class data members：<strong>static</strong>和<strong>nonstatic</strong>，以及三种class member functions：<strong>static</strong>、<strong>nonstatic</strong>和<strong>virtual</strong>。已知下面这个class Point声明：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point(<span class="keyword">float</span> xval);</span><br><span class="line">    <span class="keyword">virtual</span> ~Point();</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">x</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">PointCount</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ostream&amp; <span class="title">print</span><span class="params">(ostream &amp;os)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="keyword">float</span> _x;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> _point_count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>简单对象模型：一个object是一系列的slots，每一个slot指向一个members。Members按其声明的顺序被指定一个slot。每一个data member或function member都有自己的slot。<br><img src="/img/1605490522.jpg" alt></p>
<p>在这个简单模型中，members本身并不放在object之中。只有“指向member的指针”被放在object内。这么做可以避免“members有不同的类型，因而需要不同的存储空间”所招致的问题。Object中的members是以slot的索引值来寻址：本例之中_x的索引是6，_point_count的索引是7。一个class object的大小很容易计算出来：“指针大小，乘以class中所声明的members数目”便是。（类似指针数组，一个object就是一个指针数组。）</p>
<p>表格驱动对象模型：把所有与members相关的信息抽取出来，放在一个data member table和一个member function table之中，class object本身则含有指向这两个表格的指针。member function table是一系列的slot，每一个slot指出一个member function，data member table则直接含有数据本身:<br><img src="/img/1605490857.jpg" alt></p>
<p>C++对象模型：<strong>nonstatic data members被配置于每一个class object之内</strong>，static data members则被存放在所有的class object之外。static和nonstatic function members也被放在所有的class object之外。</p>
<p>虚函数则以两个步骤支持之：</p>
<ol>
<li>每个class产生出一堆指向虚函数的指针，放在表格之中。这个表格被称为<strong>virtual table</strong>(vtbl)</li>
<li><strong>每一个class object被安插一个指针，指向相关的virtual table</strong>。通常这个指针被称为vptr。vptr的设定和重置都由每一个class的constructor、destructor和copy assignment运算符自动完成。每一个class所关联的type_info object(用以支持runtime type identification, RTTI)也经由virtual table被指出来，通常放在表格的第一个slot处。</li>
</ol>
<p>故上面的声明所对应的对象模型如下：<br><img src="/img/1605490985.jpg" alt></p>
<p>上图说明了C++对象模型如何应用于Point Class身上，这个模型的主要优点在于它的空间和存取时间的效率。主要缺点是：如果应用程序代码未曾改变，但所用到的class objects的nonstatic data members有所修改(有可能是增加、移除或更改)，那么应用程序代码同样得重新编译。</p>
<p>加上继承：C++支持单一/多重继承。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">iostream</span>:</span></span><br><span class="line">    <span class="keyword">public</span> istream,</span><br><span class="line">    <span class="keyword">public</span> ostream </span><br><span class="line">    &#123;...&#125;;</span><br></pre></td></tr></table></figure></p>
<p>继承关系可以指定为虚拟(virtual，也就是共享的意思)：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">istream</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> ios &#123;...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ostream</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> ios &#123;...&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在虚拟继承的情况下，base class不管在继承链中被派生(derived)多少次，<strong>永远只会存在一个实例</strong>(称为subobject)，例如iostream中只有virtual ios base class的一个实体。</p>
<p>每一个base class可以被derived class object内的一个slot指出，该slot内含base class subobject的地址。这个体制因为间接性导致了空间和存取时间上的额外负担，优点则是class object大小不会因为base class的改变而受到影响。</p>
<p>另一种所谓的base table模型。这里所说的base class table被产生出来时，表格中的每一个slot内含一个相关的base class地址，这很像virtual table内含每一个virtual function的地址一样。每一个class object内含一个bptr，它会被初始化，指向其base class table。这种策略的主要缺点是由于间接性而导致的空间和存取时间上的额外负担，优点则是在每一个class object中对于继承都有一致的表现方式：每一个class object都应该在某个固定位置上安放一个base table指针，与base classes的大小或数目无关。第二个优点是，不需要改变class objects本身，就可以放大、缩小、或更改base class table。 </p>
<p><img src="/img/1605497643.jpg" alt></p>
<p>不管上述哪一种体制，“间接性”的级数都将因为继承的深度而增加。如果在derived class内复制一个指针，指向继承串链中的每一个base class，倒是可以获得一个永远不变的存取时间。当然这必须付出代价，因为需要额外的空间来放置额外的指针。</p>
<p>C++最初采用的继承模型并不运用任何间接性：base class subobject的data members被直接放置于derived class object中。这提供了对base class members最紧凑而且最有效率的存取。缺点是base class members的任何改变，包括增加、移除或改变类型等等，都使得所有用到此base class或其derived class的objects必须重新编译。</p>
<p>自c++ 2.0起才新导入的virtual base class，需要一些间接的base class表现方法。Virtual base class的原始模型是在class object中为每一个有关联的virtual base class加上一个指针。其它演化出来的模型则若不是导入一个virtual base class table，就是扩充原已存在的virtual table，以便维护每一个virtual base class的位置。</p>
<p>对象模型如何影响程序：不同的对象模型会导致“现有的程序代码必须修改”和“必须加入新的代码”两个结果。</p>
<h2 id="关键词带来的差异"><a href="#关键词带来的差异" class="headerlink" title="关键词带来的差异"></a>关键词带来的差异</h2><p>下面一行其实是pf的一个函数调用而不是声明：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直到看到1024才决定是声明还是调用</span></span><br><span class="line"><span class="keyword">int</span> (*pf)(<span class="number">1024</span>)</span><br></pre></td></tr></table></figure></p>
<p>而在下边的这个声明中，上边那样的<strong>向前预览</strong>甚至不起作用。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> (*pf) ();</span><br></pre></td></tr></table></figure></p>
<p>当语言无法区分是一个声明还是一个表达式时，需要一个超越语言范围的规则，该规则将上述式子判断为一个“声明”。</p>
<p>关键词struct本身并不一定要象征其后随之声明的任何东西。我们可以使用struct代替class，但仍然声明public、protected、private等等存取区段，及一个完全public的接口，以及virtual functions，以及单一继承、多重继承、虚拟继承等等。</p>
<p>真正的问题并不在于所有“使用者自定义类型”的声明是否必须使用相同的关键词，问题在于使用class或struct关键词是否可以<strong>给予“类型的内部声明”以某种承诺</strong>。也就是说，如果struct关键词的使用实现了C的数据萃取观念，而class关键词实现的是C++的ADT (Abstract Data Type）观念，那么当然“不一致性”是一种错误的语言用法。就好像下面这种错误，一个object被矛盾地声明为static和extern:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不合法吗？是的 </span></span><br><span class="line"><span class="comment">//以下两个声明造成矛盾的存储空间</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> foo;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> foo;</span><br></pre></td></tr></table></figure></p>
<p>这组声明对于foo的存储空间造成矛盾。然而，如你所见，struct和class这两个关键词并不会造成这样的矛盾。class的真正特性是由声明的本身（declaration body）来决定的。“一致性的用法”只不过是一种风格上的问题而已。</p>
<h2 id="对象的差异"><a href="#对象的差异" class="headerlink" title="对象的差异"></a>对象的差异</h2><p>C++程序设计模型支持三种programming paradigms典范：</p>
<ol>
<li><p>程序模型（procedural model），就像C一样，C++当然也支持它，字符串的处理就是一个例子，我们可以使用字符数组以及<code>str*</code>函数集（定义在标准的C函数库中）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> boy[] = <span class="string">"Danny"</span>;</span><br><span class="line"><span class="keyword">char</span> *p_son;</span><br><span class="line">……</span><br><span class="line">p_son = <span class="keyword">new</span> <span class="keyword">char</span>[ <span class="built_in">strlen</span> (boy ) + <span class="number">1</span> ];</span><br><span class="line"><span class="built_in">strcpy</span>( p_son, boy );</span><br><span class="line">……</span><br><span class="line"><span class="keyword">if</span> ( !<span class="built_in">strcmp</span>( p_son, boy ) )</span><br><span class="line">   take_to_disneyland( boy );</span><br></pre></td></tr></table></figure>
</li>
<li><p>抽象数据类型模型（abstract data type model, ADT)。该模型所谓的“抽象”是和一组表达式（public 接口）一起提供，而其运算定义仍然隐而未明。例如下面的String class:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String girl = <span class="string">"Anna"</span>;</span><br><span class="line">String daughter;</span><br><span class="line">……</span><br><span class="line"><span class="comment">// String::operator=();</span></span><br><span class="line">daughter = girl;</span><br><span class="line">……</span><br><span class="line"><span class="comment">// String::operator==();</span></span><br><span class="line"><span class="keyword">if</span> ( girl == daughter )</span><br><span class="line">  take_to_disneyland( girl );</span><br></pre></td></tr></table></figure>
</li>
<li><p>面向对象模型（object-oriented model）。在此模型中有一些彼此相关的类型，通过一个抽象的 base class (用以提供共通接口）被封装起来。Library_materials class 就是一个例子，真正的 subtypes 例如 Book、Video、Compact_Disc、Puppet、Laptop 等等都可以从那里派生而来：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">check_in</span><span class="params">( Library_materials *pmat )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( pmat-&gt;late() )</span><br><span class="line">     pmat-&gt;fine();</span><br><span class="line">  pmat-&gt;check_in();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( Lender *plend = pmat-&gt;reserved() )</span><br><span class="line">     pmat-&gt;notify( plend );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>纯粹以一种 paradigm 写程序，有助于整体行为的良好稳固。</p>
<p>在 OO paradigm 中，程序员需要处理一个未知的实体，虽然类型有所界限，但有无穷的可能，被指定的 object 的真实类型在某个特定执行点之前，是无法解析的。只用通过 pointers 和 references 的操作才能够完成。相反，在 ADT paradigm 中，程序员处理的则是一个固定而单一的实体，在编译时已经定义完成。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 描述objects：不确定类型</span></span><br><span class="line">Library_materials *px = retrieve_some_material();</span><br><span class="line">Library_materials &amp;rx = *px;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 描述已知物：不可能有令人惊讶的结果产生 </span></span><br><span class="line">Librar materials dx= *px;</span><br></pre></td></tr></table></figure>
<p>你绝对没有办法确定地说出px或rx的类型，只能说要不是Library_materials object，要不是它的子类型。不过，我们倒是可以确定，dx只能是Libraty materials class的一个object。</p>
<p>对于object的多态操作要求此object必须可以经由一个pointer或reference来存取，然而C++中的pointer或reference的处理却不是多态的必要结果：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *pi;</span><br><span class="line"><span class="comment">// 没有多态，操作对象不是class object</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *pvi;</span><br><span class="line"><span class="comment">// 没有语言所支持的多态，操作对象不是class object</span></span><br><span class="line"></span><br><span class="line">x *px;</span><br><span class="line"><span class="comment">// class x视为一个base class</span></span><br></pre></td></tr></table></figure></p>
<p>在C++，多态只存在于一个个的public class体系中。举个例子，Px可能指向自我类型的一个object，或指向以public派生而来的一个类型〔请不要把不良的转型操作考虑在内）。Nonpublic的派生行为以及类型为void*的指针可以说是多态，但它们并没有被语言明白地支持，也就是说它们必须由程序员通过明白的转型操作来管理〔你或许可以说它们并不是多态对象的一线选手）. </p>
<p>C++ 用下列方法支持多态：</p>
<ol>
<li><p>经由一组隐含的转化操作。如：把一个 derived class 类型的指针转化为一个指向 base type 的指针：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shape *ps = <span class="keyword">new</span> circle();</span><br></pre></td></tr></table></figure>
</li>
<li><p>经由 virtual function 机制。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps-&gt;rotate();</span><br></pre></td></tr></table></figure>
</li>
<li><p>经由 dynamic_cast 和 typeid 运算符：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (circle *pc = <span class="keyword">dynamic_cast</span>&lt;circle*&gt;(ps))...</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>多态的主要用途是<strong>经由一个共同的接口来影响类型的封装</strong>，这个接口通常被定义在一个抽象的base class中。例如Library materials class就为Book、Video、Puppet等subtype定义了一个接口。这个共享接口是以virtual function机制引发的，它可以在执行期根据object的真正类型解析出到底是哪一个函数实体被调用。经由这样的操作：<code>Library_material-&gt;check_out();</code>，我们的代码可以避免由于“借助某一特定library的materials”而导致变动无常。这不只使得“当类型有所增加、修改、或删减时，我们的程序代码不需改变”，而且也使一个新的Library_materials subtype的供应者不需要重新写出“对继承体系中的所有类型都共通”的行为和操作。</p>
<p>需要多少内存才能表现一个 class object？一般而言：</p>
<ul>
<li>其 nonstatic data members 的总和大小；</li>
<li>加上任何由于 alignment 的需求而填补（padding）上去空间；</li>
<li>加上为了支持 virtual 而由内部产生的任何额外负担（overhead）。</li>
</ul>
<p>指针的类型（The Type of a Pointer）：“指向不同类型的各个指针”间的差异，不在于指针表示法不同，也不在其内容（地址）不同，而是在其所寻址出来的 object 类型的不同。也就是说，“指针类型”会教导编译器如何解释某个特定地址中的内存内容及大小。</p>
<ol>
<li>指向地址1000的整数指针，在32位机器上将涵盖地址空间1000-1003</li>
<li>如果string是传统的8-byte，包含一个4-byte的字符指针和一个用来表示字符串长度的证书，那么一个Zoo Animal指针将横跨1000-1015：</li>
<li>一个指向地址1000的<code>void*</code>指针的地址空间呢？不知道！</li>
</ol>
<p><img src="/img/1605627052.jpg" alt></p>
<p>加上多态之后（Adding Polymorphism）：<br>定义以下类：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ZooAnimal</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  ZooAnimal();</span><br><span class="line">  <span class="keyword">virtual</span> ~ZooAnimal();</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">int</span>    loc;</span><br><span class="line">  String name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bear</span> :</span> <span class="keyword">public</span> ZooAnimal &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  Bear();</span><br><span class="line">  ~Bear();</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">dance</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">enum</span> Dances &#123;... &#125;;</span><br><span class="line">  Dances dances_known;</span><br><span class="line">  <span class="keyword">int</span>    cell_block;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Bear  <span class="title">b</span><span class="params">(<span class="string">"Yogi"</span>)</span></span>;</span><br><span class="line">Bear* pb = &amp;b;</span><br><span class="line">Bear&amp; rb = *pb;</span><br></pre></td></tr></table></figure></p>
<p>不管 pointer 还是 reference 都只需要一个 word 的空间（32 位机器上为 4-bytes）。Bear object 需要 24 bytes，也就是 ZooAnimal 的 16 bytes 加上 Bear 所带来的 8 bytes。<br><img src="/img/1605627288.jpg" alt></p>
<p>有如下指针：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Bear b;</span><br><span class="line">ZooAnimal *pz = &amp;b;</span><br><span class="line">Bear *pb = &amp;b;</span><br></pre></td></tr></table></figure></p>
<p>它们每个都指向 Bear object 的第一个 bytes。差别是：</p>
<ul>
<li>pb 所涵盖整个 Bear object，</li>
<li>pz 值只涵盖 Bear object 中的 ZooAnimal subobject。</li>
</ul>
<p>不能用pz处理Bear的任何member，唯一例外是通过virtual：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不合法</span></span><br><span class="line">pz-&gt;cell_block;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ok：经过一个downcast没问题</span></span><br><span class="line">((Bear*)pz)-&gt;cell_block;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下边这样更好但是是一个runtime operation</span></span><br><span class="line"><span class="keyword">if</span> (Bear* pb2 = <span class="keyword">dynamic_cast</span>&lt;Bear*&gt;(pz))</span><br><span class="line">    pb2-&gt;cell_block;</span><br></pre></td></tr></table></figure></p>
<p>当我们写下<code>pz-&gt;protate()</code>时，pz 的类型将在编译时期决定以下两点：</p>
<ul>
<li>固定可用的接口。pz 只能调用 ZooAnimal 的 public 接口。</li>
<li>该接口的 access level （例如 rotate() 是 ZooAnimal 的一个 public member）。</li>
</ul>
<p>在每一个执行点，pz所指的类型可以决定<code>rotate()</code>所调用的实体。类型信息的封装不是维护于<code>pz</code>中，而是维护于link之中，link存在于object的vptr和vptr所指的virtual table之间。</p>
<p>编译器必须确保如果一个object含有一个或一个以上的vptrs，那些vptrs的内容不会被base class object初始化或改变。OO 程序设计不支持对 object 的直接处理，考虑如下例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ZooAnimal za;</span><br><span class="line">ZooAnimal *pza;</span><br><span class="line"></span><br><span class="line">Bear b;</span><br><span class="line">Panda *pp = <span class="keyword">new</span> Panda;</span><br><span class="line"></span><br><span class="line">pza = &amp;b;</span><br></pre></td></tr></table></figure></p>
<p>其内存布局可能如下：<br><img src="/img/1605628063.jpg" alt></p>
<p>将 za 或 b 的地址，或 pp 所含内容（也是地址）指定给 pza，显然没问题。一个 pointer 或一个 reference 之所以支持多态，是因为它们并不引发内存中任何“与类型有关的内存委托操作”，改变的只是他们所指向的内存的“大小和内容解释方式”。</p>
<p>任何企图改变 object za 大小的行为，都会违反其定义中的“资源需求量”，如：把整个 Bear object 指定给 za，那么就会溢出它所配置得到的内存。<strong>当一个 base class object 被指定为一个 derived class object 时，derived object 就会被切割</strong>，以塞入较小的 base type 内存中。derived type 将不会留下任何痕迹。</p>
<p>C++ 也支持 object-based（OB）风格（非 OO），区别是对象构建不需要 virtual 机制，编译时即可决定类型。例如String class，一种非多态的数据结构，String class可以展示封装的非多态形式，它提供一个public接口和一个private实作品，包括数据和算法，但是不支持类型的扩充，一个OB设计可能比一个对等的OO涉及速度更快而且空间更紧凑，速度快是因为所有函数引发操作都在编译期决定，对象构建起来不需要virtual机制，空间紧凑是因为每一个class object不需要负担传统上为了支持virtual机制而需要的额外负荷，不过OB设计没有弹性。</p>
<h1 id="第二章-构造函数语意学"><a href="#第二章-构造函数语意学" class="headerlink" title="第二章 构造函数语意学"></a>第二章 构造函数语意学</h1><p>iostream 函数库的建筑师：Jerry Schwarz 早期意图支持一个 iostream class object 的纯测试量（scalar test)：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">cin</span>) ...</span><br></pre></td></tr></table></figure></p>
<p>为了让 cin 可以求得真假值，Jerry 定义了一个 conversion 运算符：<code>operator int()</code>（把 cin 转换成 int 类型）。正确使用的话确实可行，但如下情况：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// oops: meant cout, not cin</span></span><br><span class="line"><span class="built_in">cin</span> &lt;&lt; intVal;</span><br></pre></td></tr></table></figure></p>
<p>这里程序员犯了个粗心的错误，本应使用 cout 而不是 cin，Class 的 “type-safe”本应可以捕捉这种运算符的错误运用，但是，编译器比较喜欢找到一个正确的诠释，而不是仅仅抛出错误，此例中，编译器首先会认出<code>&lt;&lt;</code>是一个左移运算符，而左移运算符只有在“cin 可以改变为和一个整数值同义”才可用，然后编译器就去找 conversion 运算符，于是找到了<code>operator int()</code>。那么：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> temp = <span class="built_in">cin</span>.<span class="keyword">operator</span> <span class="keyword">int</span>();</span><br><span class="line">temp &lt;&lt; intVal;</span><br></pre></td></tr></table></figure></p>
<p>现在合法了，这种错误被戏称为“Schwarz Error”。设计师以<code>operator void*()</code>取代<code>operator int()</code>。</p>
<p>关键词<code>explict</code>之所以被导入，就是为了提供一种方法，使他们能够制止<strong>单一参数的constructor被当做一个conversion运算符</strong>。</p>
<h2 id="Default-Construtor-的建构操作"><a href="#Default-Construtor-的建构操作" class="headerlink" title="Default Construtor 的建构操作"></a>Default Construtor 的建构操作</h2><p>default constructors 在需要的时候会被编译器产生出来，被谁需要？有如下程序：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span>  val;</span><br><span class="line">  Foo *pnext;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo_bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Oops: program needs bar's members zeroed out</span></span><br><span class="line">  Foo bar;</span><br><span class="line">  <span class="keyword">if</span> (bar.val || bar.pnext)</span><br><span class="line">  <span class="comment">// ... do something</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>正确的程序语意是要求 default constructor，可以将两个 members 初始化为 0，但编译器并不会为之合成出一个 default constructor，因为上述所说的需要，是指编译器需要的时候，而不是程序员需要的时候，这里编译器并不需要这个 default constructor。所以正确的表述应该是：如果没有任何 user-declared constructor，那么就会有一个 default constructor 被声明，但其是一个 trivial constructor（没啥用的 constructor）。那么，编译器什么时候会生成一个 nontrivial default constructor 呢？</p>
<h3 id="“带有-Default-Constructor”的-Member-Class-Object"><a href="#“带有-Default-Constructor”的-Member-Class-Object" class="headerlink" title="“带有 Default Constructor”的 Member Class Object"></a>“带有 Default Constructor”的 Member Class Object</h3><p>简单来说：如果一个 class 没有任何 constructor，但其<strong>内含一个 member object，而这个 member object 有 default constructor</strong>，那么编译器就会合成出一个“nontrivial default constructor”。举个例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Foo(), Foo(<span class="keyword">int</span>)...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Foo   foo;</span><br><span class="line">	<span class="keyword">char</span> *str;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo_bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Bar bar;  <span class="comment">// Bar::foo must be initialized here</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (str) &#123;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个程序当中，编译器会为 class Bar 合成一个 default constructor，因为在 foo_bar 中，声明了一个 Bar 对象，这时候就需要初始化其中的 member，其中 Bar::foo 就需要调用 Foo 的 default constructor 才能初始化，这里初始化 foo 就是编译器的责任，但是 Bar::str 的初始化，则还是程序员的责任。合成出的 default constructor 可能如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// possible synthesis of Bar default constructor</span></span><br><span class="line"><span class="comment">// invoke Foo default constructor for member foo</span></span><br><span class="line"><span class="keyword">inline</span> Bar::Bar() &#123;</span><br><span class="line">  <span class="comment">// Pseudo C++ Code</span></span><br><span class="line">  foo.Foo::Foo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>假如程序员定义了一个 default constructor，提供了 str 的初始化操作，但没有提供 foo 的初始化操作：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Bar::Bar() &#123;</span><br><span class="line">	str = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在程序的需求满足，但编译器的需求没有满足，还需要初始化 foo，但 default constructor 已经被程序员定义了，没法再合成一个了，那么编译器会按如下准则行动：“如果 class A 内含一个或一个以上的 member class objects，那么，class A 的每个 constructor 必须调用每一个 member class 的default constructor”。所以，编译器可能会将代码扩展成：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Augmented default constructor</span></span><br><span class="line"><span class="comment">// Pseudo C++ Code</span></span><br><span class="line">Bar::Bar() &#123;</span><br><span class="line">  foo.Foo::Foo();  <span class="comment">// augmented compiler code</span></span><br><span class="line">  str = <span class="number">0</span>;         <span class="comment">// explicit user code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果有多个 class member object 都需要进行初始化操作，那么编译器会<strong>按 member object 在 class 中的声明次序，一个个调用其 default constructors</strong>。这些代码都将被安插在 explicit user code（生成的代码是 implicit 的）之前。</p>
<h3 id="“带有-Default-Constructor”的-Base-Class"><a href="#“带有-Default-Constructor”的-Base-Class" class="headerlink" title="“带有 Default Constructor”的 Base Class"></a>“带有 Default Constructor”的 Base Class</h3><p>如果一个没有任何 constructor 的 class 派生自一个“带有 default constructor”（包括自动生成的）的 base class，那么编译器就会为其生成一个 nontrivial default constructor，在其中调用 base class 的 default constructor。</p>
<p>如果程序员写了好几个 constructor，但就是没写 default constructor 呢？那么编译器就会扩张现有的每一个 constructor，将所需要调用的 base calss 的 default constructor 一个个加上去，但并不会为其合成新的 default constructor（因为程序员已经提供了 constructor，所以不会再合成了）。注意，如果还有上一小节说的 member class object，那么这些 object 的 default constructor 也会被安插进去，位置在 base class constructor 之后。</p>
<h3 id="“带有一个-Virtual-Function”的-Class"><a href="#“带有一个-Virtual-Function”的-Class" class="headerlink" title="“带有一个 Virtual Function”的 Class"></a>“带有一个 Virtual Function”的 Class</h3><p>在下面两种情况下，也需合成 default constructor：</p>
<ol>
<li>class 声明（或继承）一个 virtual function。</li>
<li>class 派生自一个继承串链，其中有一个或多个 virtual base class。</li>
</ol>
<p>不管哪一种情况，由于缺乏由user声明的constructor，编译器会详细记录合成一个default constructor的必要信息。有如下程序：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">flip</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flip</span><span class="params">(<span class="keyword">const</span> Widget&amp; widget)</span> </span>&#123;</span><br><span class="line">  widget.flip();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// presuming Bell and Whistle are derived from Widget</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Bell    b;</span><br><span class="line">  Whistle w;</span><br><span class="line">  flip(b);</span><br><span class="line">  flip(w);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中，Bell 和 Wistle 都继承自 Widget。那么下面两个扩张操作会在编译期间发生：</p>
<ol>
<li>编译器会产生一个 virtual function table（vtbl），其中存放 class 的 virtual function 的地址。</li>
<li>在每个 class object 中，会合成一个额外的 pointer member（vptr），存放 vtbl 的地址。</li>
</ol>
<p>并且，<code>widget.flip()</code>的虚拟引发操作会被重新改写，以使用widget的vptr和vtbl中的flip()条目：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// simplified transformation of virtual invocation: widget.flip()</span></span><br><span class="line">(*widget.vptr[<span class="number">1</span>])(&amp;widget)</span><br></pre></td></tr></table></figure></p>
<p>其中：</p>
<ul>
<li><code>1</code>表示<code>flip()</code>在 virtual table 中的索引；</li>
<li><code>&amp;widget</code>是<code>this</code>指针（每个成员函数都有一个隐含的 this 指针哦）。</li>
</ul>
<p>编译器会为每个 Widget object 的 vptr 设定初值，所以对于 class 所定义的每个 constructor，编译器都会安插一些代码来做这样的事。对于没有任何 constructor 的 class，编译器则合成一个 default constructor 来做此事。</p>
<h3 id="“带有一个-Virtual-Base-Class”的-Class"><a href="#“带有一个-Virtual-Base-Class”的-Class" class="headerlink" title="“带有一个 Virtual Base Class”的 Class"></a>“带有一个 Virtual Base Class”的 Class</h3><p>必须使virtual base class在其每一个derived class object中的位置，能够于执行期准备妥当，例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span> <span class="keyword">public</span>: <span class="keyword">int</span> i;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> :</span> <span class="keyword">public</span> <span class="keyword">virtual</span> X &#123;<span class="keyword">public</span>: <span class="keyword">int</span> j;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> <span class="keyword">virtual</span> X &#123;<span class="keyword">public</span>: <span class="keyword">double</span> d;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> :</span> <span class="keyword">public</span> A, <span class="keyword">public</span> B &#123;<span class="keyword">public</span>: <span class="keyword">int</span> k;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无法在编译期间决定pa-&gt;X::i的位置</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">const</span> A* pa)</span> </span>&#123;pa-&gt; = <span class="number">1024</span>;&#125;</span><br><span class="line"></span><br><span class="line">main ()&#123;</span><br><span class="line">  foo(<span class="keyword">new</span> A);</span><br><span class="line">  foo(<span class="keyword">new</span> C);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译器无法固定住<code>foo()</code>之中“经由<code>pa</code>而存取的<code>X::i</code>”的实际偏移位置，因为<code>pa</code>的真正类型可以改变。编译器必须改变执行存取操作的那些码，使<code>X::i</code>可以延迟到执行的时候决定。所有经由reference或pointer来存取一个virtual base class的操作都可以通过相关指针完成，<code>foo()</code>可以被改写为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">const</span> A* pa)</span> </span>&#123; pa-&gt;__vbcX-&gt;i = <span class="number">1024</span>;&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中<code>__vbcX</code>表示编译器所产生的指针。</p>
<p>因为 virtual base class 在内存中的位置也是由一个指针指示出的，所以编译器也会对每个 constructor 安插一些代码，用来支持 virtual base class，如果没有声明任何 constructor，那么编译器就会合成一个 default constructor。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>以上四种情况，编译器都会给未声明 constructor 的 class 合成一个 default constructor。C++ Standard 把这些合成物称为 implicit nontrivial default constructor。至于没有存在这四种情况下且没有声明 constructor 的 class，它们拥有的是 implicit trivial default constructor，且实际上并不会被合成出来。</p>
<p>在合成的 default constructor 中，只有 base class subobject 和 member class object 会被初始化，其他的 nonstatic data member 都不会被初始化，因为编译器不需要。</p>
<p>C++ 新手（我）一般有两个误解：</p>
<ol>
<li>任何 class 如果没有定义 default constructor，就会被合成出一个来。</li>
<li>编译器合成出来的 default constructor 会明确设定 “class 内每一个 data member 的默认值”。</li>
</ol>
<p>以上两点都是错的！</p>
<h2 id="Copy-Constructor-的建构操作"><a href="#Copy-Constructor-的建构操作" class="headerlink" title="Copy Constructor 的建构操作"></a>Copy Constructor 的建构操作</h2><p>有三种情况，会以一个 object 的内容作为另一个 class object 的初值：</p>
<ul>
<li>对一个 object 做明确的初始化操作。</li>
<li>当 object 被当作参数交给某个函数时。</li>
<li>当函数传回一个 class object 时。</li>
</ul>
<p>当程序员定义了 copy constructor 时，以上情况下，当一个class object以另一个同类实体作为初值时，都会调用这个 copy constructor，这可能会导致一个暂时性class object的产生或程序代码的蜕变。</p>
<h3 id="Default-Memberwise-Initialization"><a href="#Default-Memberwise-Initialization" class="headerlink" title="Default Memberwise Initialization"></a>Default Memberwise Initialization</h3><p>若程序员没有定义 copy constructor，那么当 class object 以相同 class 的另一个 object 作为初值时，其内部是以 default memberwise initialization 手法完成的，把每一个内建的或派生的data member的值，从一个object拷贝到另一个object身上，不过它并不会拷贝其中的member class object，而是以递归的方式实行member wise initialization。比如下列程序：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// ... no explicit copy constructor</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">char</span> *str;</span><br><span class="line">  <span class="keyword">int</span>   len;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">noun</span><span class="params">(<span class="string">"book"</span>)</span></span>;</span><br><span class="line">String verb = noun;</span><br></pre></td></tr></table></figure></p>
<p>其完成方式就像设定每一个member一样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// semantic equivalent of memberwise initialization</span></span><br><span class="line">verb.str = noun.str;</span><br><span class="line">verb.len = noun.len;</span><br></pre></td></tr></table></figure></p>
<p>如果一个 String object 被声明为另一个 class 的 member：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Word</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// ...no explicit copy constructor</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span>    _occurs;</span><br><span class="line">  String _word;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>那么一个 Word object 的 default memberwise initialization 会拷贝其内建的member <code>_occurs</code>，然后再于<code>_word</code>身上递归的进行 memberwise initialization。</p>
<blockquote>
<p>从概念上对于一个class X，这个操作是被一个copy constructor实现出来。</p>
</blockquote>
<blockquote>
<p>一个良好的编译器可以为大部分class object产生bitwise copies，因为它们有bitwise copy semantics。</p>
</blockquote>
<p>应该是，default constructor和copy constructor在需要的时候才由编译器产生。这个句子的“必要”指当class不展现bitwise copy semantics时。</p>
<p>一个 class object 可以从两种方式复制得到，一种是<strong>被初始化</strong>（也就是我们这里所说的），另一种是<strong>被指定</strong>（assignment）。这两个操作分别以 copy constructor 和 copy assignment operator 完成。</p>
<p>就像 default constructor 一样，如果 class 没有声明 copy constructor，那么只有 nontrivial 的情况出现时，编译器才会在必要的时候合成一个 copy constructor，而在 trivial 的情况下，则会使用 bitwise copy semantics 。</p>
<h3 id="Bitwise-Copy-Semantics（位逐次拷贝）"><a href="#Bitwise-Copy-Semantics（位逐次拷贝）" class="headerlink" title="Bitwise Copy Semantics（位逐次拷贝）"></a>Bitwise Copy Semantics（位逐次拷贝）</h3><p>有如下程序：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Word.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">Word <span class="title">noun</span><span class="params">(<span class="string">"block"</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Word verb = noun;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>很明显 verb 是根据 nonun 来初始化。如果 class Word 定义了一个 copy constructor，则 verb 的初始化操作会调用它，但如果没有，则编译器会先看看 Word 这个 class 是否展现了 “bitwise copy semantics”，然后再决定要不要合成一个 copy constructor。若 class Word 声明如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// declaration exhibits bitwise copy semantics</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Word</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  Word(<span class="keyword">const</span> <span class="keyword">char</span>*);</span><br><span class="line">  ~Word() &#123;</span><br><span class="line">    <span class="keyword">delete</span>[] str;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span>   cnt;</span><br><span class="line">  <span class="keyword">char</span>* str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>那么这时候并不会合成一个 default copy constructor，因为上述声明展现了“default copy semantics”（但上述程序是有问题的，Word 的析构函数可能会重复 delete str，因为 str 被浅拷贝了）。</p>
<p>如果 class Word 这样声明：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// declaration does not exhibits bitwise copy semantics</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Word</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  Word(<span class="keyword">const</span> String&amp;);</span><br><span class="line">  ~Word();</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span>    cnt;</span><br><span class="line">  String str;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>其中，String 有自己的 copy constructor，这样的情况，编译器则必须合成一个 copy constructor 用来调用 String 的 copy constructor：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A synthesized copy constructor</span></span><br><span class="line"><span class="comment">// Pseudo C++ Code</span></span><br><span class="line"><span class="keyword">inline</span> Word::Word(<span class="keyword">const</span> Word&amp; wd) &#123;</span><br><span class="line">  str.String::String(wd.str);</span><br><span class="line">  cnt = wd.cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意：在合成的 copy constructor 中，不只 String 被复制，普通的成员如数组、指针等等 nonclass member 也会被复制。</p>
<h3 id="不要-Bitwise-Copy-Semantics！"><a href="#不要-Bitwise-Copy-Semantics！" class="headerlink" title="不要 Bitwise Copy Semantics！"></a>不要 Bitwise Copy Semantics！</h3><p>以下四种情况 class 不展现出“bitwise copy semantics”：</p>
<ul>
<li>当 class 内含一个 member object，而这个 member object 有一个 copy constructor（包括程序员定义的和编译器合成的）。</li>
<li>当 class 继承自一个 base class，而这个 base class 有一个 copy constructor（同样，包括程序员定义的和编译器合成的）。</li>
<li>当 class 声明了 virtual function 时。</li>
<li>当 class 派生自一个继承串链，其中有 virtual base class 时。</li>
</ul>
<p>前两个情况很好理解，编译器必须将member或base class的copy constructors调用操作安插到被合成的copy constructors中，下面讨论后两种情况。</p>
<h4 id="重新设定-Virtual-Table-的指针"><a href="#重新设定-Virtual-Table-的指针" class="headerlink" title="重新设定 Virtual Table 的指针"></a>重新设定 Virtual Table 的指针</h4><p>在 class 声明了 virtual function 后，编译期间会有两个程序扩张操作：</p>
<ul>
<li>增加一个 virtual function table（vtbl），内含每个 virtual function 的地址。</li>
<li>将一个指向 virtual function table 的指针（vptr），安插在每一个 class object 内。</li>
</ul>
<p>很显然，在 copy 的时候需要为 vptr 正确的设定初值才行，而不是简单的拷贝。这时候，class 就不再展现 bitwise semantics 了，编译器需要合成一个copy constructor，讲vptr适当地初始化。有如下程序：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ZooAnimal</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  ZooAnimal();</span><br><span class="line">  <span class="keyword">virtual</span> ~ZooAnimal();</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">animate</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// data necessary for ZooAnimal's</span></span><br><span class="line">  <span class="comment">// version of animate() and draw()</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bear</span> :</span> <span class="keyword">public</span> ZooAnimal &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  Bear();</span><br><span class="line">  <span class="function"><span class="keyword">void</span>         <span class="title">animate</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span>         <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">dance</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// data necessary for Bear's version</span></span><br><span class="line">  <span class="comment">// of animate(), draw(), and dance()</span></span><br><span class="line">&#125;;</span><br><span class="line">Bear yogi;</span><br><span class="line">Bear winnie = yogi;</span><br></pre></td></tr></table></figure></p>
<p>ZooAnimal class object以另一个ZooAnimal class object作为初值可以直接靠bitwise copy semantics完成。</p>
<p>yogi 会被 default Bear constructor 初始化。且在 constructor 中，yogi 的 vptr 被设定指向了 Bear class 的 virtual table（靠编译器完成的）。此时，把 yogi 的 vptr 的值拷贝给 winnie 是安全的。yogi 和 winnie 的关系如下图所示：<br><img src="/img/1605801747.jpg" alt></p>
<p>当一个 base class object 用一个 derived class 的 object 初始化时，其 vptr 的复制也必须保证安全：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZooAnimal franny = yogi;	<span class="comment">// 译注：这会发生切割（sliced）行为</span></span><br></pre></td></tr></table></figure></p>
<p>franny 的 vptr 显然不可以指向 Bear class 的 virtual table（如果 yogi 使用“bitwise copy”则会直接拷贝 vptr）。不然如下程序就会出错：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">(<span class="keyword">const</span> ZooAnimal&amp; zoey)</span> </span>&#123;</span><br><span class="line">  zoey.draw();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// franny's vptr must address the ZooAnimal virtual table</span></span><br><span class="line">  <span class="comment">// not the Bear virtual table yogi's vptr addresses</span></span><br><span class="line">  ZooAnimal franny = yogi;</span><br><span class="line">  draw(yogi);    <span class="comment">// invoke Bear::draw()</span></span><br><span class="line">  draw(franny);  <span class="comment">// invoke ZooAnimal::draw()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果直接复制 vptr 的话，第 10 行的 draw 就会调用 Bear 的 draw 而不是其基类 ZooAnimal 的 draw。franny 和 yogi 正确的关系如下图所示：<br><img src="/img/1605801829.jpg" alt></p>
<p>也就是说，合成出的 ZooAnimal copy constructor 会明确设定 object 的 vptr 指向 ZooAnimal class 的 virtual table，而非单纯的拷贝。</p>
<h3 id="处理-Virtual-Base-Class-Subobject"><a href="#处理-Virtual-Base-Class-Subobject" class="headerlink" title="处理 Virtual Base Class Subobject"></a>处理 Virtual Base Class Subobject</h3><p>如果一个 class object 以另一个 object 作为初值，且后者有一个 virtual base class subobject，那么“bitwise copy semantics”就会失效。</p>
<p>每一个编译器都必须让 derived class object 中的 virtual base class subobject 的位置在执行期就准备妥当。“Bitwise copy semantics”就可能会破坏这个位置。所以需要合成一个 copy constructor 来做这件事。举个例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Raccoon</span> :</span> <span class="keyword">public</span> <span class="keyword">virtual</span> ZooAnimal &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  Raccoon() &#123; <span class="comment">/* private data initialization */</span></span><br><span class="line">  &#125;</span><br><span class="line">  Raccoon(<span class="keyword">int</span> val) &#123; <span class="comment">/* private data initialization */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// all necessary data</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>编译器首先会为 Raccoon 的两个 constructor 生成一些代码来初始化 vptr。注意：与上节所说的 vptr 的情况一样，一个 class object 和另一个同类型的 object 之间的 memberwise 初始化并不会出现任何问题，只有在一个 class object 用其 derived class object 作为初值时，才会出问题。如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RedPanda</span> :</span> <span class="keyword">public</span> Raccoon &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  RedPanda() &#123; <span class="comment">/* private data initialization */</span></span><br><span class="line">  &#125;</span><br><span class="line">  RedPanda(<span class="keyword">int</span> val) &#123; <span class="comment">/* private data initialization */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// all necessary data</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// simple bitwise copy is sufficient</span></span><br><span class="line">Raccoon rocky;</span><br><span class="line">Raccoon little_critter = rocky;</span><br></pre></td></tr></table></figure></p>
<p>上面的程序用 rocky 初始化 little_critter，因为他们都是 Raccoon 类型，所以“bitwise copy”就可以了。但如果这样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// simple bitwise copy is not sufficient</span></span><br><span class="line"><span class="comment">// compiler must explicitly initialize little_critter's</span></span><br><span class="line"><span class="comment">// virtual base class pointer/offset</span></span><br><span class="line">RedPanda little_red;</span><br><span class="line">Raccoon little_critter = little_red;</span><br></pre></td></tr></table></figure></p>
<p>为了正确的 little_critter 初值设定，则必须合成一个 copy constructor，在其中会生成一些代码来设定 virtual base class pointer/offset 的初值（或只是简单的确定它没有被消除），对于其它 member 则执行必要的 memberwise 初始化操作。下图展示了 little_red 和 little_critter 的关系：<br><img src="/img/1605802474.jpg" alt></p>
<p>在上面所说的四种情况下，class 将不再保持 “bitwise copy semantics”，这时候，如果 default copy constructor 没有声明，则会合成出一个 copy constructor。</p>
<h2 id="程序转化语意学"><a href="#程序转化语意学" class="headerlink" title="程序转化语意学"></a>程序转化语意学</h2><p>有如下程序片段：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"X.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">X <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  X xx;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> xx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们可能会做出如下假设：</p>
<ol>
<li>每次 foo() 被调用，就传回 xx 的值。</li>
<li>如果 class X 定义了一个 copy constructor，那么当 foo() 被调用时，保证该 copy constructor 也会被调用。</li>
</ol>
<p>这两个假设都得视编译器所提供的进取性优化程度（degree of aggressive optimization）而定。在高品质的 C++ 编译器中，上述两点对于 class X 的 nontrivial definitions 都不正确。</p>
<h3 id="明确的初始化操作（Explicit-Initialization）"><a href="#明确的初始化操作（Explicit-Initialization）" class="headerlink" title="明确的初始化操作（Explicit Initialization）"></a>明确的初始化操作（Explicit Initialization）</h3><p>定义<code>X x0;</code>，有如下程序，每一个都明显地以<code>x0</code>来初始化其class object：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void foo_bar() &#123;</span><br><span class="line">  X x1(x0);</span><br><span class="line">  X x2 = x0;</span><br><span class="line">  X x3 = X(x0);</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>会有如下两个转化阶段：</p>
<ol>
<li>重写每一个定义，其中的初始化操作会被删除。</li>
<li>class 的 copy constructor 调用操作会被安插进去。</li>
</ol>
<p>在明确的双阶段转化后，<code>foo_bar()</code>转化后可能的样子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Possible program transformation</span></span><br><span class="line"><span class="comment">// Pseudo C++ Code</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo_bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  X x1;</span><br><span class="line">  X x2;</span><br><span class="line">  X x3;</span><br><span class="line">  <span class="comment">// compiler inserted invocations</span></span><br><span class="line">  <span class="comment">// of copy constructor for X</span></span><br><span class="line">  x1.X::X(x0);</span><br><span class="line">  x2.X::X(x0);</span><br><span class="line">  x3.X::X(x0);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中的<code>x1.X::X(x0)</code>表现出对以下的copy constructor的调用：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X::X(<span class="keyword">const</span> X&amp; xx);</span><br></pre></td></tr></table></figure></p>
<h3 id="参数的初始化（Argument-Initialization）"><a href="#参数的初始化（Argument-Initialization）" class="headerlink" title="参数的初始化（Argument Initialization）"></a>参数的初始化（Argument Initialization）</h3><p>有如下函数定义：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(X x0)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>以下调用方式：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">X xx;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">foo(xx);</span><br></pre></td></tr></table></figure></p>
<p>将会要求局部实体（local instance）<code>x0</code>以 memberwise 的方式将 xx 当作初值。编译器的一种策略如下，<strong>导入暂时性的 object，并调用 copy constructor 将其初始化</strong>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Pseudo C++ code</span></span><br><span class="line"><span class="comment">// compiler generated temporary</span></span><br><span class="line">X __temp0;</span><br><span class="line"><span class="comment">// compiler invocation of copy constructor</span></span><br><span class="line">__temp0.X::X(xx);</span><br><span class="line"><span class="comment">// rewrite function call to take temporary</span></span><br><span class="line">foo(__temp0);</span><br></pre></td></tr></table></figure></p>
<p>暂时性object先以class X的copy constructor正确设定了初值，然后以bitwise方式拷贝到x0这个局部实体中。这样的话，还要将 foo 函数的声明改写才行：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(X&amp; x0)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>需要改为引用传参。在 foo() 函数完成之后，将会调用 class X 的 destructor 将其析构。</p>
<p>另一种策略是以<strong>拷贝建构</strong>（copy construct）的方式<strong>把实际参数直接建构在其应该的位置上</strong>（堆栈中）。同样，在函数返回之前，其 destructor（如果有）会被执行。</p>
<h3 id="返回值的初始化（Return-Value-Initialization）"><a href="#返回值的初始化（Return-Value-Initialization）" class="headerlink" title="返回值的初始化（Return Value Initialization）"></a>返回值的初始化（Return Value Initialization）</h3><p>有如下函数定义：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">X <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  X xx;</span><br><span class="line">  <span class="comment">// 处理 xx ...</span></span><br><span class="line">  <span class="keyword">return</span> xx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译器可能会做如下的双阶段转化：</p>
<ol>
<li>首先加上一个额外的参数，类型是 class object 的一个引用。这个参数将用来放置被“拷贝建构（copy constructed）”而得的返回值。</li>
<li>在 return 指令之前安插一个 copy constructor 调用操作，以便将欲传回的 object 的内容当作上述新参数的初值。</li>
</ol>
<p>而真正的返回值则没有了，return 将不返回任何东西：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// function transformation to reflect</span></span><br><span class="line"><span class="comment">// application of copy constructor</span></span><br><span class="line"><span class="comment">// Pseudo C++ Code</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">(X&amp; __result)</span> </span>&#123;	<span class="comment">// 这里多了一个参数哦</span></span><br><span class="line">  X xx;</span><br><span class="line">  <span class="comment">// compiler generated invocation</span></span><br><span class="line">  <span class="comment">// of default constructor</span></span><br><span class="line">  xx.X::X();</span><br><span class="line">  <span class="comment">// ... process xx</span></span><br><span class="line">  <span class="comment">// compiler generated invocation</span></span><br><span class="line">  <span class="comment">// of copy constructor</span></span><br><span class="line">  __result.X::X(xx);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在编译器则会将如下调用操作：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X xx = bar();</span><br></pre></td></tr></table></figure></p>
<p>转化为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// note: no default constructor applied</span></span><br><span class="line">X xx;</span><br><span class="line">bar( xx );</span><br></pre></td></tr></table></figure></p>
<p>而：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bar().memfunc();	<span class="comment">// 执行 bar 函数返回的 object 的成员函数</span></span><br></pre></td></tr></table></figure></p>
<p>则可能转化为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">X __temp0;</span><br><span class="line">(bar(__temp0), __temp0).memfunc();</span><br></pre></td></tr></table></figure></p>
<p>函数指针的类型也会被转换：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">X (*pf) ();</span><br><span class="line">pf = bar;</span><br></pre></td></tr></table></figure></p>
<p>转化为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> (*pf) (X&amp;);</span><br><span class="line">pf = bar;</span><br></pre></td></tr></table></figure></p>
<h3 id="在使用者层面做优化（Optimization-at-the-User-Level）"><a href="#在使用者层面做优化（Optimization-at-the-User-Level）" class="headerlink" title="在使用者层面做优化（Optimization at the User Level）"></a>在使用者层面做优化（Optimization at the User Level）</h3><p>对于如下函数，xx 会被拷贝到编译器所产生的<code>__result</code>之中：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">X <span class="title">bar</span><span class="params">(<span class="keyword">const</span> T &amp;y, <span class="keyword">const</span> T &amp;z)</span> </span>&#123;</span><br><span class="line">  X xx;</span><br><span class="line">  <span class="comment">// ... process xx using y and z</span></span><br><span class="line">  <span class="keyword">return</span> xx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>程序员可以换种形式编写，可以在 X 当中另外定义一个 constructor，接收 y 和 z 类型的值，直接计算xx，改写函数为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">X <span class="title">bar</span><span class="params">(<span class="keyword">const</span> T &amp;y, <span class="keyword">const</span> T &amp;z)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> X(y, z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>于是经过编译器转换后：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Pseudo C++ Code</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">(X &amp;__result, <span class="keyword">const</span> T &amp;y, <span class="keyword">const</span> T &amp;z)</span> </span>&#123;</span><br><span class="line">  __result.X::X(y, z);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>__result</code>直接被计算出来，而非经过 copy constructor 拷贝而得（本来应该是在 bar 中构造出 xx，然后用 copy constructor 把<code>__result</code>初始化为 xx 的值）。这种方法的优劣有待探讨。</p>
<h3 id="在编译器层面做优化（Optimization-at-the-Compiler-Level）"><a href="#在编译器层面做优化（Optimization-at-the-Compiler-Level）" class="headerlink" title="在编译器层面做优化（Optimization at the Compiler Level）"></a>在编译器层面做优化（Optimization at the Compiler Level）</h3><p>有如下函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">X <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  X xx;</span><br><span class="line">  <span class="comment">// ... process xx</span></span><br><span class="line">  <span class="keyword">return</span> xx;</span><br><span class="line">&#125;</span><br><span class="line">所有的<span class="keyword">return</span>指令传回相同的具名数值（named value），因此编译器可能会做优化，以`__result`参数代替 named <span class="keyword">return</span> value：</span><br><span class="line">```C++</span><br><span class="line"><span class="keyword">void</span> bar(X &amp;__result) &#123;</span><br><span class="line">  <span class="comment">// default constructor invocation</span></span><br><span class="line">  <span class="comment">// Pseudo C++ Code</span></span><br><span class="line">  __result.X::X();</span><br><span class="line">  <span class="comment">// ... process in __result directly</span></span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种优化被称为 Named Retrun Value（NRV）优化。有如下测试代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">friend</span> test <span class="title">foo</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  test() &#123;</span><br><span class="line">    <span class="built_in">memset</span>(<span class="built_in">array</span>, <span class="number">0</span>, <span class="number">100</span> * <span class="keyword">sizeof</span>(<span class="keyword">double</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">double</span> <span class="built_in">array</span>[<span class="number">100</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">test <span class="title">foo</span><span class="params">(<span class="keyword">double</span> val)</span> </span>&#123;</span><br><span class="line">  test local;</span><br><span class="line">  local.<span class="built_in">array</span>[<span class="number">0</span>] = val;</span><br><span class="line">  local.<span class="built_in">array</span>[<span class="number">99</span>] = val;</span><br><span class="line">  <span class="keyword">return</span> local;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> cnt = <span class="number">0</span>; cnt &lt; <span class="number">10000000</span>; cnt++) &#123;</span><br><span class="line">    test t = foo(<span class="keyword">double</span>(cnt));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码中，没有 copy constructor，所以在<code>foo()</code>中不会实施 NRV 优化。增加 copy constructor 后：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> test::test( <span class="keyword">const</span> test &amp;t ) &#123;</span><br><span class="line"><span class="built_in">memcpy</span>( <span class="keyword">this</span>, &amp;t, <span class="keyword">sizeof</span>( test ));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>激活了编译器的 NRV 优化。下面是原书测试时间表：<br><img src="/img/1605851633.jpg" alt></p>
<p>注意，只有当所有的 named return 指令在函数的 top level 时，优化才施行，比如在 if 语句里也有个 return 的话，优化就会关闭。</p>
<p>如下三个初始化操作在语义上相等：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">X <span class="title">xx0</span><span class="params">(<span class="number">1024</span>)</span></span>;</span><br><span class="line">X xx1 = X(<span class="number">1024</span>);</span><br><span class="line">X xx2 = (X) <span class="number">1024</span>;</span><br></pre></td></tr></table></figure></p>
<p>但是 2、3 两行有两个步骤的初始化操作：</p>
<ol>
<li>将一个暂时性的 object 设初值为 1024；</li>
<li>将暂时性的 object 以拷贝建构的方式作为 explicit object 的初值。</li>
</ol>
<p>xx0是被单一的constructor操作设定初值：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xx0.X::X(<span class="number">1024</span>)</span><br></pre></td></tr></table></figure></p>
<p>而xx1或xx2却调用两个constructor，产生一个暂时性object，并针对该暂时性object调用class X的destructor：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X __temp0;</span><br><span class="line">__temp0.X::X(<span class="number">1024</span>);</span><br><span class="line">xx1.X::X(__temp0);</span><br><span class="line">__temp0.X::~X();</span><br></pre></td></tr></table></figure></p>
<h3 id="Copy-Constructor：要还是不要？"><a href="#Copy-Constructor：要还是不要？" class="headerlink" title="Copy Constructor：要还是不要？"></a>Copy Constructor：要还是不要？</h3><p>如果一个 class <strong>没有任何 member（或 base）class object 带有 copy constructor，也没有任何 virtual base class 或 virtual function，那么这个 class 会以“bitwise” copy</strong>，这样效率高，且安全，不会有 memory leak，也不会产生 address aliasing。这时候程序员没理由，也不需要提供一个 copy constructor。但如果这个 class 需要 大量的 memberwise 初始化操作，例如上面的测试，以传值的方式传回 object，那么就可以提供一个 copy constructor 来让编译器进行 NRV 优化。</p>
<p>例如Point3d支持下边的函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Point3d <span class="keyword">operator</span>+(<span class="keyword">const</span> Point3d&amp;, <span class="keyword">const</span> Point3d&amp;);</span><br><span class="line">Point3d <span class="keyword">operator</span>-(<span class="keyword">const</span> Point3d&amp;, <span class="keyword">const</span> Point3d&amp;);</span><br><span class="line">Point3d <span class="keyword">operator</span>*(<span class="keyword">const</span> Point3d&amp;, <span class="keyword">int</span>);</span><br></pre></td></tr></table></figure></p>
<p>所有那些函数都能够良好地符合NRV template：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Point3d result;</span><br><span class="line"><span class="comment">// 计算result</span></span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure></p>
<p>实现copy constructor的最简单方法像这样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Point3d::Point3d(<span class="keyword">const</span> Point3d&amp; rhs) &#123;</span><br><span class="line">  _x = rhs._x;</span><br><span class="line">  _y = rhs._y;</span><br><span class="line">  _z = rhs._z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是用<code>memcpy()</code>会更简单：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Point3d::Point3d(const Point3d&amp; rhs) &#123;</span><br><span class="line">  memcpy(this, &amp;rhs, sizeof(Point3d));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>有一点需要注意，在使用 memcpy 进行初始化的时候，要注意有没有 virtual function 或者 virtual base class：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// oops: this will overwrite internal vptr!</span></span><br><span class="line">  Shape() &#123;</span><br><span class="line">    <span class="built_in">memset</span>(<span class="keyword">this</span>, <span class="number">0</span>, <span class="keyword">sizeof</span>(Shape));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">virtual</span> ~Shape();</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>上面这个 Shape 类有 virtual function，那么编译器会在 constructor 当中安插一些代码以正确设置 vptr：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Expansion of constructor</span></span><br><span class="line"><span class="comment">// Pseudo C++ Code</span></span><br><span class="line">Shape::Shape() &#123;</span><br><span class="line">  <span class="comment">// vptr must be set before user code executes</span></span><br><span class="line">  __vptr__Shape = __vtbl__Shape;</span><br><span class="line">  <span class="comment">// oops: memset zeros out value of vptr</span></span><br><span class="line">  <span class="built_in">memset</span>(<span class="keyword">this</span>, <span class="number">0</span>, <span class="keyword">sizeof</span>(Shape));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>如代码所示，<code>memset</code>会将<code>__vptr__Shape</code>变成0，<code>memcpy</code>也类似，会将<code>__vptr__Shape</code>设为错误的值。</p>
<p>小结<br>copy constructor 会使编译器对代码做出优化，尤其是当函数以传值的方式传回一个 class object 时，编译器会将 copy constructor 的调用操作优化，通过在参数表中额外安插一个参数，用来取代 NRV。</p>
<h2 id="成员们的初始化队伍（Member-Initialization-List）"><a href="#成员们的初始化队伍（Member-Initialization-List）" class="headerlink" title="成员们的初始化队伍（Member Initialization List）"></a>成员们的初始化队伍（Member Initialization List）</h2><p>初始化 class members，要么通过 member initialization list，要么就在 constructor 函数体内初始化。以下四种情况则必须使用 member initialization list：</p>
<ul>
<li>当初始化一个 reference member 时；</li>
<li>当初始化一个 const member 时；</li>
<li>当调用一个 base class 的 constructor，而它拥有一组参数时；</li>
<li>当调用一个 member class 的 constructor，而它拥有一组参数时。</li>
</ul>
<p>如下情况中，如果在函数体内初始化，会影响效率：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Word</span> &#123;</span></span><br><span class="line">  String _name;</span><br><span class="line">  <span class="keyword">int</span>    _cnt;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// not wrong, just naive ...</span></span><br><span class="line">  Word() &#123;</span><br><span class="line">    _name = <span class="number">0</span>;</span><br><span class="line">    _cnt = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这时候，编译器会做出如下扩张：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Pseudo C++ Code</span></span><br><span class="line">Word::Word(<span class="comment">/* this pointer goes here */</span>) &#123;</span><br><span class="line">  <span class="comment">// invoke default String constructor</span></span><br><span class="line">  _name.String::String();</span><br><span class="line">  <span class="comment">// generate temporary</span></span><br><span class="line">  String temp = String(<span class="number">0</span>);</span><br><span class="line">  <span class="comment">// memberwise copy _name</span></span><br><span class="line">  _name.String::<span class="keyword">operator</span>=(temp);</span><br><span class="line">  <span class="comment">// destroy temporary</span></span><br><span class="line">  temp.String::~String();</span><br><span class="line">  _cnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，Word constructor 会先产生一个暂时的 String object，然后将它初始化，最后用赋值运算符将其指定给<code>_name</code>，再摧毁那个暂时性object。</p>
<p>如果这样写则效率更佳：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// preferred implementation</span></span><br><span class="line">Word::Word : _name(<span class="number">0</span>) &#123;</span><br><span class="line">  _cnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>它会被扩张为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Pseudo C++ Code</span></span><br><span class="line">Word::Word(<span class="comment">/* this pointer goes here */</span>) &#123;</span><br><span class="line">  <span class="comment">// invoke String( int ) constructor</span></span><br><span class="line">  _name.String::String(<span class="number">0</span>);</span><br><span class="line">  _cnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>陷阱最有可能发生在这种形式的template code中：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">foo</span>&lt;type&gt;:</span>:foo(type t) &#123;</span><br><span class="line">  <span class="keyword">_t</span> = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种优化会导致一些程序员坚持所有的 member 初始化操作必须在 member initialization list 中完成，即使是行为良好的 member 如 _cnt。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Word::Word() : _cnt(<span class="number">0</span>), _name(<span class="number">0</span>) &#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>事实上，编译器会一个个操作 initialization list，以<strong>声明</strong>的次序，将代码安插在 constructor 内，并且是安插在 explicit user code 之前。下面这个初始化操作就会出错：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// oops! do you see the problem?</span></span><br><span class="line">  X(<span class="keyword">int</span> val) : j(val), i(j)&#123;&#125;...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>程序员的本意是想把 j 用 val 先初始化，然后再用 j 把 i 初始化，而事实上，初始化的顺序是按照 member 的声明次序来的，所以会先用 j 初始化 i，而 i 目前是个随机值。建议把一个member的初始化操作和另一个放在一起，放在constructor中：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">X::X(<span class="keyword">int</span> val) :j(val) &#123;</span><br><span class="line">  i = j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>另外，可以调用一个 member function 来设定一个 member 的初值。但这时候应该在 constructor 体内调用 member function 做初始化，而不是在 member initialization list 中，因为这时候，和此 object 相关的 this 指针已经准备好了，可以通过 this 指针调用 member function 了。</p>
<p>最后，用一个 derived class member function 的调用结果来初始化 base class constructor 会如何：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// is the invocation of FooBar::fval() ok?</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooBar</span> :</span> <span class="keyword">public</span> X &#123;			<span class="comment">// FooBar 继承自 X</span></span><br><span class="line">  <span class="keyword">int</span> _fval;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">fval</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _fval;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 用成员函数 fval 的调用结果作为 base class constructor 的参数</span></span><br><span class="line">  FooBar(<span class="keyword">int</span> val) : _fval(val), X(fval())&#123;&#125; </span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>编译器可能会将其扩张为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Pseudo C++ Code</span></span><br><span class="line">FooBar::FooBar( <span class="comment">/* this pointer goes here */</span> ) &#123;</span><br><span class="line">  <span class="comment">// Oops: definitely not a good idea</span></span><br><span class="line">  X::X( <span class="keyword">this</span>, <span class="keyword">this</span>-&gt;fval() );</span><br><span class="line">  _fval = val;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>很显然，调用<code>fval()</code>回传的<code>_fval</code>还是个随机值。可能是由于 base class 必须在 initialization list 里面初始化，而之前那种情况可以在 constructor 函数体内初始化，这时候就可以将所需要的 member 先初始化好，再调用成员函数。</p>
<p>简略的说，编译器会对initialization list一一处理并可能重新排序，以反映出members的声明次序，它会安插一些代码到constructor体内，并置于任何explicit user code之前。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/C/" rel="tag"># C++</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/11/08/深入理解Linux内核 笔记7/" rel="next" title="深入理解Linux内核18-20章">
                <i class="fa fa-chevron-left"></i> 深入理解Linux内核18-20章
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/11/20/深度探索cpp对象模型 笔记2/" rel="prev" title="深度探索C++对象模型 笔记2">
                深度探索C++对象模型 笔记2 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/header.jpg" alt="Hao Yu">
            
              <p class="site-author-name" itemprop="name">Hao Yu</p>
              <p class="site-description motion-element" itemprop="description">Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author</p>
          </div>
          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">340</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>
        	<audio controls="controls" loop="loop" preload="auto" src="/resource/xiaomeihao.mp3">
	        </audio>
	

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yuhao0102" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:yuh18@mails.tsinghua.edu.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#第1章-关于对象"><span class="nav-number">1.</span> <span class="nav-text">第1章 关于对象</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#加入封装后的布局成本"><span class="nav-number">1.1.</span> <span class="nav-text">加入封装后的布局成本</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-对象模式-The-C-Object-Model"><span class="nav-number">1.2.</span> <span class="nav-text">C++ 对象模式(The C++ Object Model)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关键词带来的差异"><span class="nav-number">1.3.</span> <span class="nav-text">关键词带来的差异</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对象的差异"><span class="nav-number">1.4.</span> <span class="nav-text">对象的差异</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第二章-构造函数语意学"><span class="nav-number">2.</span> <span class="nav-text">第二章 构造函数语意学</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Default-Construtor-的建构操作"><span class="nav-number">2.1.</span> <span class="nav-text">Default Construtor 的建构操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#“带有-Default-Constructor”的-Member-Class-Object"><span class="nav-number">2.1.1.</span> <span class="nav-text">“带有 Default Constructor”的 Member Class Object</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#“带有-Default-Constructor”的-Base-Class"><span class="nav-number">2.1.2.</span> <span class="nav-text">“带有 Default Constructor”的 Base Class</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#“带有一个-Virtual-Function”的-Class"><span class="nav-number">2.1.3.</span> <span class="nav-text">“带有一个 Virtual Function”的 Class</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#“带有一个-Virtual-Base-Class”的-Class"><span class="nav-number">2.1.4.</span> <span class="nav-text">“带有一个 Virtual Base Class”的 Class</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#小结"><span class="nav-number">2.1.5.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Copy-Constructor-的建构操作"><span class="nav-number">2.2.</span> <span class="nav-text">Copy Constructor 的建构操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Default-Memberwise-Initialization"><span class="nav-number">2.2.1.</span> <span class="nav-text">Default Memberwise Initialization</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Bitwise-Copy-Semantics（位逐次拷贝）"><span class="nav-number">2.2.2.</span> <span class="nav-text">Bitwise Copy Semantics（位逐次拷贝）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#不要-Bitwise-Copy-Semantics！"><span class="nav-number">2.2.3.</span> <span class="nav-text">不要 Bitwise Copy Semantics！</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#重新设定-Virtual-Table-的指针"><span class="nav-number">2.2.3.1.</span> <span class="nav-text">重新设定 Virtual Table 的指针</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#处理-Virtual-Base-Class-Subobject"><span class="nav-number">2.2.4.</span> <span class="nav-text">处理 Virtual Base Class Subobject</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#程序转化语意学"><span class="nav-number">2.3.</span> <span class="nav-text">程序转化语意学</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#明确的初始化操作（Explicit-Initialization）"><span class="nav-number">2.3.1.</span> <span class="nav-text">明确的初始化操作（Explicit Initialization）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#参数的初始化（Argument-Initialization）"><span class="nav-number">2.3.2.</span> <span class="nav-text">参数的初始化（Argument Initialization）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#返回值的初始化（Return-Value-Initialization）"><span class="nav-number">2.3.3.</span> <span class="nav-text">返回值的初始化（Return Value Initialization）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在使用者层面做优化（Optimization-at-the-User-Level）"><span class="nav-number">2.3.4.</span> <span class="nav-text">在使用者层面做优化（Optimization at the User Level）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在编译器层面做优化（Optimization-at-the-Compiler-Level）"><span class="nav-number">2.3.5.</span> <span class="nav-text">在编译器层面做优化（Optimization at the Compiler Level）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Copy-Constructor：要还是不要？"><span class="nav-number">2.3.6.</span> <span class="nav-text">Copy Constructor：要还是不要？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#成员们的初始化队伍（Member-Initialization-List）"><span class="nav-number">2.4.</span> <span class="nav-text">成员们的初始化队伍（Member Initialization List）</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>
  <div id="DvelopmentTarget">     
  </div>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart" aria-hidden="false"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>

  
</div>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_uv"> 
  本站访客数<span id="busuanzi_value_site_uv"></span>人次
</span>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  


  <script type="text/javascript" src="/js/src/love.js"></script>

</body>
</html>
