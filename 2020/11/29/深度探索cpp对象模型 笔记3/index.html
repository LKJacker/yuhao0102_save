<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zn-ch">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-center-simple.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="C++,">










<meta name="description" content="构造、解构、拷贝语义学（Semantics of Construction, Destruction, and Copy）有如下抽象基类的声明：12345678Class Abstract_base &amp;#123; public:  virtual ~Abstract_base() = 0;  virtual void interface() const = 0;  virtual const ch">
<meta name="keywords" content="C++">
<meta property="og:type" content="article">
<meta property="og:title" content="深度探索C++对象模型 笔记3">
<meta property="og:url" content="http://yoursite.com/2020/11/29/深度探索cpp对象模型 笔记3/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="构造、解构、拷贝语义学（Semantics of Construction, Destruction, and Copy）有如下抽象基类的声明：12345678Class Abstract_base &amp;#123; public:  virtual ~Abstract_base() = 0;  virtual void interface() const = 0;  virtual const ch">
<meta property="og:locale" content="zn-ch">
<meta property="og:image" content="http://yoursite.com/img/1606828557.jpg">
<meta property="og:image" content="http://yoursite.com/img/1606880320.jpg">
<meta property="og:image" content="http://yoursite.com/img/1606880362.jpg">
<meta property="og:image" content="http://yoursite.com/img/1606880419.jpg">
<meta property="og:image" content="http://yoursite.com/img/1606880455.jpg">
<meta property="og:image" content="http://yoursite.com/img/1606880485.jpg">
<meta property="og:updated_time" content="2020-12-11T13:37:48.587Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="深度探索C++对象模型 笔记3">
<meta name="twitter:description" content="构造、解构、拷贝语义学（Semantics of Construction, Destruction, and Copy）有如下抽象基类的声明：12345678Class Abstract_base &amp;#123; public:  virtual ~Abstract_base() = 0;  virtual void interface() const = 0;  virtual const ch">
<meta name="twitter:image" content="http://yoursite.com/img/1606828557.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/11/29/深度探索cpp对象模型 笔记3/">





  <title>深度探索C++对象模型 笔记3 | Hao Yu's blog</title>
  








 
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zn-ch">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hao Yu's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">The program monkey was eaten by the siege lion.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-mybetterhalf">
          <a href="/mybetterhalf/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>
            
            mybetterhalf
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/11/29/深度探索cpp对象模型 笔记3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">深度探索C++对象模型 笔记3</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-11-29T09:13:00+08:00">
                2020-11-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="构造、解构、拷贝语义学（Semantics-of-Construction-Destruction-and-Copy）"><a href="#构造、解构、拷贝语义学（Semantics-of-Construction-Destruction-and-Copy）" class="headerlink" title="构造、解构、拷贝语义学（Semantics of Construction, Destruction, and Copy）"></a>构造、解构、拷贝语义学（Semantics of Construction, Destruction, and Copy）</h1><p>有如下抽象基类的声明：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Class Abstract_base &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~Abstract_base() = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">interface</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">mumble</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _mumble; &#125;</span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">char</span>* _mumble;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述抽象基类的问题在于，虽然它是一个抽象类，但仍需要一个明确的构造函数来初始化<code>_mumble</code>。如果没有这个初始化操作，其 derived class 的就无法确定<code>_mumble</code>的初值。</p>
<p>如果 Abstract_base 的设计者试图让每一个 derived class 提供<code>_mumble</code>的初值，那么 derived class 的唯一要求就是 Abstract_base 必须提供一个带有唯一参数的 protected constructor：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Abstract_base::Abstract_base(<span class="keyword">char</span>* mumble_value = <span class="number">0</span>) : _mumble(mumble_value) &#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>一般而言，class 的 data member 应该在其 constructor 或 member functions 中设定初值，否则会破坏封装性质。</p>
<h2 id="纯虚函数的存在（Presence-of-a-Pure-Virtual-Function）"><a href="#纯虚函数的存在（Presence-of-a-Pure-Virtual-Function）" class="headerlink" title="纯虚函数的存在（Presence of a Pure Virtual Function）"></a>纯虚函数的存在（Presence of a Pure Virtual Function）</h2><p>C++ 新手（我）常常很惊讶地发现，竟然可以定义和调用一个<strong>pure virtual function</strong>。但它只能被静态的调用，不能经由虚拟机制调用：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ok：定义 pure virtual function</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> </span><br><span class="line">Abstract_base::interface() <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">Concrete_derived::interface() &#123;</span><br><span class="line">  <span class="comment">// ok: 静态调用纯虚函数</span></span><br><span class="line">  Abstract_base::interface();</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>要不要定义纯虚函数完全由 class 设计者决定，但有一个例外：<strong>class 的设计者必须定义 pure virtual destructor</strong>。因为每一个 derived class destructor 都会被编译器扩展，以静态调用的方式调用每一个基类的 destructor，因此，只要缺乏任何一个 base class destructor 的定义，就会导致链接失败。</p>
<p>你可能会争辩说，难道对一个pure virtual destructor的调用操作不应该在“编译器扩展derived class的destructor”时压抑下来吗？不！class 设计者可能 已经真的定义了一个pure virtual destructor，这样的设计是以C++语言的一个保证为前提：<strong>继承体系中每一个class object的destructors都会被调用</strong>。所以编译器不能够压抑这个调用操作。 </p>
<p>编译器的确没有足够知识“合成”一个pure virtual destructor的函数定义，因为编译器对一个可执行文件采取“分离编译模型”。开发环境可以提供一个设备，在链接时找出pure virtual destructor不存在的事实体，然后重新激活编译器，赋予一个特殊指令(directive)，以合成一个必要的函数实体。一个比较好的替代方案就是，<strong>不要把virtual destructor声明为pure</strong>。</p>
<h3 id="虚拟规格的存在（Presence-of-a-Virtual-Specification）"><a href="#虚拟规格的存在（Presence-of-a-Virtual-Specification）" class="headerlink" title="虚拟规格的存在（Presence of a Virtual Specification）"></a>虚拟规格的存在（Presence of a Virtual Specification）</h3><p>如果把<code>Abstract_base::mumble()</code>设计为一个 virtual function，将会是非常糟糕的选择，因为其函数定义内容与类型无关，因而几乎不会被后继的 derived class 改写，而且还会带来效率上的负担。</p>
<p>一般而言把所有的成员函数都声明为virtual function再靠编译器的优化操作把非必要的virtual invocation去除并不是好的设计观念。</p>
<h3 id="虚拟规格中-const-的存在"><a href="#虚拟规格中-const-的存在" class="headerlink" title="虚拟规格中 const 的存在"></a>虚拟规格中 const 的存在</h3><p>决定一个 virtual function 是否需要 const，看似是无所谓的事，但真正面对一个 abstract base class 时，却不容易做决定，作者的想法很简单，不再用 const 就是了。</p>
<h3 id="重新考虑-class-的声明"><a href="#重新考虑-class-的声明" class="headerlink" title="重新考虑 class 的声明"></a>重新考虑 class 的声明</h3><p>由前面的讨论可知，重新定义 Abstract_base 如下，才比较合适：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Abstract_base</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~Abstract_base();	<span class="comment">// 不是 pure 了</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">interface</span><span class="params">()</span> </span>= <span class="number">0</span>;	<span class="comment">// 不是 const 了</span></span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">mumble</span> <span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _mumble; &#125;	<span class="comment">// 不是 virtual 了</span></span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  Abstract_base( <span class="keyword">char</span> *pc = <span class="number">0</span> )	<span class="comment">// 新增一个带有唯一参数的 constructor（是保护成员哦）</span></span><br><span class="line">  <span class="keyword">char</span> *_mumble;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="“无继承”情况下的对象构造"><a href="#“无继承”情况下的对象构造" class="headerlink" title="“无继承”情况下的对象构造"></a>“无继承”情况下的对象构造</h2><p>考虑下面的程序片段：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Point global;</span><br><span class="line"></span><br><span class="line"><span class="function">Point <span class="title">foobar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Point local;</span><br><span class="line">  Point *heap = <span class="keyword">new</span> Point;</span><br><span class="line">  *heap = local;</span><br><span class="line">  <span class="comment">// ...stuff...</span></span><br><span class="line">  <span class="keyword">delete</span> heap;</span><br><span class="line">  <span class="keyword">return</span> local;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>L1，L5，L6 表现出三种不同的对象产生方式：global 内存配置、local 内存配置和 heap 内存配置。</p>
<p>local object 的生命从 L5 的定义开始，到 L10 为止。global object 的生命和整个程序的生命相同。heap object 的生命从它被 new 运算符配置出来开始，到它被 delete 运算符损毁为止。</p>
<p>下面的 Point 的声明，是一种所谓的 Plain Ol’ Data 声明形式：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="keyword">float</span> x, y, z;</span><br><span class="line">&#125; Point;</span><br></pre></td></tr></table></figure></p>
<p>如果以C++来编译这段码，观念上编译器会为Point声明一个trivial default constructor、一个trivial destructor、一个trivial copy constructor，以及一个trivial copy assignment operator，但实际上编译器会分析这个声明，并为其贴上 Plain Ol’ Data 卷标。</p>
<p>当编译器遇到这样的定义：<code>Point global;</code>，程序的行为会和在 C 语言中表现一样（没有构造函数等东西），只有一点不一样：在 C 中，global 被视为<strong>临时性的定义</strong>，因为它<strong>没有明确的初始化操作</strong>，这种“临时性的定义”会被链接器折叠，只留下单独一个实体，放在程序 data segment 中一个<strong>特别保留给未初始化之 global objects 使用</strong>的空间，这块空间被称为BSS，是 Block Started by Symbol 的缩写。</p>
<p>而 C++ 并不支持“临时性的定义”，global 在 C++ 中被视为完全定义。C 和 C++ 的一个差异就在于，BSS data segment 在 C++ 中相对不重要。C++ 的所有全局对象都被当作“初始化过的数据”来对待。</p>
<p><code>foobar()</code>函数中 L5 声明了一个Point object local，它既没有被构造也没有被解构，这会是一个潜在的 bug，比如 L7 的赋值操作。至于 heap object 在 L6 的初始化操作，会被转化为对 new 运算符的调用：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Point *heap = __new(<span class="keyword">sizeof</span>(Point));</span><br></pre></td></tr></table></figure></p>
<p>再强调一次，并没有 default constructor 施行于 new 运算符所传回的 Point object 上。L7 对此 object 有一个赋值操作，如果 local 被适当的初始化过，那么一切就没问题。观念上，这样的赋值操作会触发 copy assignment operator 进行拷贝搬运操作。然而这个 object 是一个 Plain Ol’ Data，所以赋值操作只是像 C 那样的纯粹位搬移操作。L9 执行的 delete 操作会被转化为对 delete 运算符的调用：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__delete(heap);</span><br></pre></td></tr></table></figure></p>
<p>观念上，这会触发Point的trivial destructor，但destructor 和 constructor 一样，不是没产生出来，就是没被调用。最后的 return 语句传值也是一样，只是简单的位拷贝操作。</p>
<h3 id="抽象数据类型（Abstract-Data-Type）"><a href="#抽象数据类型（Abstract-Data-Type）" class="headerlink" title="抽象数据类型（Abstract Data Type）"></a>抽象数据类型（Abstract Data Type）</h3><p>以下是 Point 的另一种声明，在public接口下多了private数据，提供了完整的封装性，但没有 virtual function：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  Point( <span class="keyword">float</span> x = <span class="number">0.0</span>, <span class="keyword">float</span> y = <span class="number">0.0</span>, <span class="keyword">float</span> z = <span class="number">0.0</span> )</span><br><span class="line">  : _x( x ), _y( y ), _z( z ) &#123;&#125;</span><br><span class="line">  <span class="comment">// no copy constructor, copy operator</span></span><br><span class="line">  <span class="comment">// or destructor defined ...</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">float</span> _x, _y, _z;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>其大小并没有改变，还是三个连续的 float，不论private还是public或是member function的声明都不会占用额外的对象空间。我们也没有定义 copy constructor 或 copy operator，因为默认的位语义（default bitwise semantics）已经足够。也无需 destructor，默认的内存管理方法也够了。现在对于一个 global 实体，就会有 default constructor 作用其上了。</p>
<p>如果要对 class 中的所有成员都设定常量初值，那么使用<strong>explicit initialization list</strong>会比较高效，比如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mumble</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Point local1 = &#123; <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span> &#125;;</span><br><span class="line">  Point local2;</span><br><span class="line">  <span class="comment">// equivalent to an inline expansion</span></span><br><span class="line">  <span class="comment">// the explicit initialization is slightly faster</span></span><br><span class="line">  local2._x = <span class="number">1.0</span>;</span><br><span class="line">  local2._y = <span class="number">1.0</span>;</span><br><span class="line">  local2._z = <span class="number">1.0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>local1 的初始化操作会比 local2 的高效。这是因为函数的 activation record 被放进程序堆栈时，上述 initialization list 中的常量就可以被放进 local1 内存中了。</p>
<p>Explicit initialization list 带来三项缺点：</p>
<ul>
<li>只有当 class members 都是 public 时，此法才奏效。</li>
<li>只能指定常量，因为它们再编译时期就恶意被评估求值。</li>
<li>由于编译器并没有自动施行之，所以初始化行为的失败可能性会比较高一些。</li>
</ul>
<p>在编译器层面，会有一个优化机制用来识别inline constructors，后者简单地 提供一个member-by-member的常量指定操作。然后编译器会抽取出那些值，并且对待它们就好像是explicit initialization list所供应的一样，而不会把constructor扩展成为一系列的assignment指令。于是，local Point object的定义：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">Point local;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在被附加上default Potni constructor的inline expansion:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//inline expansion of default constructor</span></span><br><span class="line">Point local;</span><br><span class="line">local._x = <span class="number">0.0</span>; </span><br><span class="line">local._y = <span class="number">0.0</span>;</span><br><span class="line">local._z = <span class="number">0.0</span>;</span><br></pre></td></tr></table></figure></p>
<p>L6配置出一个heap Poini object:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Point *heap = <span class="keyword">new</span> Point;</span><br></pre></td></tr></table></figure></p>
<p>现在则被附加一个“对default Point constructor的有条件调用操作”：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//c++伪码</span></span><br><span class="line">Point *heap = __new(<span class="keyword">sizeof</span>(Point));</span><br><span class="line"><span class="keyword">if</span>(heap != <span class="number">0</span>) </span><br><span class="line">  heap-&gt;Point::Point();</span><br></pre></td></tr></table></figure></p>
<p>然后才又被编译器进行inline expansion操作，至于把heap指针指向local object；<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*heap = local;</span><br></pre></td></tr></table></figure></p>
<p>则保持着简单的位拷贝操作。以传值方式传回local object，情况也是一样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">10</span>) <span class="keyword">return</span> local;</span><br></pre></td></tr></table></figure></p>
<p>L9删除heap所指之对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(9) delete heap;</span><br></pre></td></tr></table></figure></p>
<p>该操作并不会导致destructor被调用，因为我们并没有明确地提供一个destructor函数实体。</p>
<p>观念上，我们的Point class有一个相关的default copy constructor、copy operator和destructor，然而它们都是无关痛痒的（trivial），而且编译器实际上根本没有产生它们。 </p>
<h3 id="为继承做准备"><a href="#为继承做准备" class="headerlink" title="为继承做准备"></a>为继承做准备</h3><p>下面时第三个 Point 声明，将为“继承性质”以及动态决议做准备：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class"> <span class="title">public</span>:</span></span><br><span class="line">  Point( <span class="keyword">float</span> x = <span class="number">0.0</span>, <span class="keyword">float</span> y = <span class="number">0.0</span> )</span><br><span class="line">  : _x( x ), _y( y ) &#123;&#125;</span><br><span class="line">  <span class="comment">// no destructor, copy constructor, or</span></span><br><span class="line">  <span class="comment">// copy operator defined ...</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">float</span> <span class="title">z</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">float</span> _x, _y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>再一次强调，这里并没有定义 copy constructor、copy operator、destructor。因为程序在默认语义之下表现良好。</p>
<p><strong>virtual function 的引入促使每一个 Point object 拥有一个 virtual table pointer</strong>。除了多了一个 vptr 外，编译器还对 Point class 进行了扩张：</p>
<ul>
<li>constructor 被附加了一些代码，以便将 vptr 初始化。这些代码放在所有 base class constructor 之后，程序员的代码之前。</li>
<li>合成一个 copy constructor 和一个 copy assignment operator，而且其操作不再是 trivial（如果用 bitwise 拷贝可能会给 vptr 带来非法设定）。</li>
</ul>
<h2 id="继承体系下的对象构造"><a href="#继承体系下的对象构造" class="headerlink" title="继承体系下的对象构造"></a>继承体系下的对象构造</h2><p>当我们定义一个 object：<code>T object;</code>时，会发生什么？很显然，其 constructor 会被调用，不显然的是，constructor 可能会带有大量编译器为其扩展的代码：</p>
<ol>
<li>记录在 member initialization list 中的 data members 初始化操作会被放进 constructor 的函数本身，并以 member 的声明顺序放置。</li>
<li>如果有 member 没有出现在 member initialization list 中，但它有一个 default constructor，那么该 default constructor 必须被调用。</li>
<li>在那之前，如果 class object 有 virtual table pointer，它们必须被设定初值，指向适当的 virtual table。</li>
<li>在那之前，所有上一层的 base class constructor 必须被调用，以 base class 的声明次序为顺序：<ol>
<li>如果 base class 被列于 member initialization list 中，那么任何明确指定的参数都应该传递过去。</li>
<li>如果 base class 没有被列于 member initialization list 中，而它有 default constructor，那么就调用之。</li>
<li>如果 base class 是多重继承下的第二或后继的 base class，那么 this 指针必须有所调整。</li>
</ol>
</li>
<li>在那之前，所有 virtual base class constructors 必须被调用，从左到右，从最深到最浅：<ol>
<li>如果 class 被列于 member initialization list 中，那么如果有任何明确指定的参数，都应该传递过去。若没有列于 list 中，而 class 有 default constructor，那么调用之。</li>
<li>此外，class 中的每一个 virtual base class subobject 的偏移量（offset）必须在执行期可被存取。</li>
<li>如果 class object 是最底层（most-derived）的class，其 constructor 可能被调用；某些用以支持这个行为的机制必须被放进来。</li>
</ol>
</li>
</ol>
<p>这一节中，再次以 Point 为例，并增加 copy constructor、copy operator、virtual destructor：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Point( <span class="keyword">float</span> x = <span class="number">0.0</span>, <span class="keyword">float</span> y = <span class="number">0.0</span> );</span><br><span class="line">  Point( <span class="keyword">const</span> Point&amp; );</span><br><span class="line">  Point&amp; <span class="keyword">operator</span>=( <span class="keyword">const</span> Point&amp; );</span><br><span class="line">  <span class="keyword">virtual</span> ~Point();</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">float</span> <span class="title">z</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> <span class="number">0.0</span>; &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">float</span> _x, _y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>然后再定义一个 Line class，它由<code>_begin</code>和<code>_end</code>两个点构成：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Line</span> &#123;</span></span><br><span class="line">Point _begin, _end;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Line( <span class="keyword">float</span>=<span class="number">0.0</span>, <span class="keyword">float</span>=<span class="number">0.0</span>, <span class="keyword">float</span>=<span class="number">0.0</span>, <span class="keyword">float</span>=<span class="number">0.0</span> );</span><br><span class="line">  Line( <span class="keyword">const</span> Point&amp;, <span class="keyword">const</span> Point&amp; );</span><br><span class="line">  draw();</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>每一个explicit constructor都会被扩充以调用其两个member class objects的constructors。如果定义constructor如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Line::Line(<span class="keyword">const</span> Point &amp;begin, <span class="keyword">const</span> Point &amp;end) : _end(end), _begin(begin) &#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>它会被扩充为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Line* Line::Line(Line *<span class="keyword">this</span>, <span class="keyword">const</span> Point &amp;begin, <span class="keyword">const</span> Point &amp;end) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;_begin.Point::Point(begin);</span><br><span class="line">    <span class="keyword">this</span>-&gt;_end.Point::Point(end);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当程序员写下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Line a;</span><br></pre></td></tr></table></figure></p>
<p>时，implicit Line destructor会被合成出来（如果Line派生自Point，那么合成出来的destructor将会是virtual。然而由于Line只是内带Point objects而非继承自Point，所以被合成出来的destructor只是nontrivial而已）。在其中，它的member class objects的destructors会被调用（以其构造的相反顺序）<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++伪码：合成出来的Line destructor </span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> Line::~Line(Line *<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;end.Point::~Point();</span><br><span class="line">    <span class="keyword">this</span>-&gt;begin.Point::~Point();</span><br></pre></td></tr></table></figure></p>
<p>当然，如果Point destructor是inline函数，那么每一个调用操作会在调用地点被扩展开来。请注意，虽然Point destructor是virtual，但其调用操作（在containing class destructor之中）会被静态地决议出来（resolved statically）。类似的道理，当一个程序员写下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Line b = a;</span><br></pre></td></tr></table></figure></p>
<p>时，implicit Line copy constructor会被合成出来，成为一个inline public member。</p>
<p>最后，当程序员写下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = b;</span><br></pre></td></tr></table></figure></p>
<p>时，implicit copy assignment operator会被合成出来，成为一个inline public member。</p>
<h3 id="虚拟继承（Virtual-Inheritance）"><a href="#虚拟继承（Virtual-Inheritance）" class="headerlink" title="虚拟继承（Virtual Inheritance）"></a>虚拟继承（Virtual Inheritance）</h3><p>考虑如下的虚拟继承情况：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3d</span> :</span> <span class="keyword">public</span> <span class="keyword">virtual</span> Point &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point3d(<span class="keyword">float</span> x = <span class="number">0.0</span>, <span class="keyword">float</span> y = <span class="number">0.0</span>, <span class="keyword">float</span> z = <span class="number">0.0</span>) : Point(x, y), _z(z) &#123;&#125;</span><br><span class="line">    Point3d(<span class="keyword">const</span> Point3d&amp; rhs) : Point(rhs), _z(rhs._z) &#123;&#125;</span><br><span class="line">    ~Point3d();</span><br><span class="line">    Point3d&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Point3d&amp;);</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">float</span> <span class="title">z</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> z;&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">float</span> _z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于 Point3d 和 Vertex，传统的 constructor 扩充并没有用，这是因为 virtual base class 的“共享性”之故，如果正常的去扩展 constructor，那么 Point3d 和 Vertex 都会调用 Point 的 constructor，这显然不行。所以应该在最底层的 class 中将 Point 初始化，在上图中，应该由 PVertex 去初始化共享的 Point。下面就是 Point3d 的 constructor 扩充内容：<br><img src="/img/1606828557.jpg" alt></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Psuedo C++ Code:</span></span><br><span class="line"><span class="comment">// Constructor Augmentation with Virtual Base class</span></span><br><span class="line">Point3d*</span><br><span class="line">Point3d::Point3d( Point3d *<span class="keyword">this</span>, <span class="keyword">bool</span> __most_derived, <span class="comment">// 多了一个 __most_derived 参数</span></span><br><span class="line"><span class="keyword">float</span> x, <span class="keyword">float</span> y, <span class="keyword">float</span> z ) &#123;</span><br><span class="line">  <span class="keyword">if</span> ( __most_derived != <span class="literal">false</span> )</span><br><span class="line">    <span class="keyword">this</span>-&gt;Point::Point( x, y);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">this</span>-&gt;__vptr__Point3d = __vtbl__Point3d;</span><br><span class="line">  <span class="keyword">this</span>-&gt;__vptr__Point3d__Point =</span><br><span class="line">  __vtbl__Point3d__Point;</span><br><span class="line">  <span class="keyword">this</span>-&gt;_z = rhs._z;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在更深层的继承情况下，例如 Vertex3d，当调用 Point3d 和 Vertex 的 constructor 时，总是会把<code>__most_derived</code>参数设为 false，于是就压制了两个 constructor 中对 Point constructor 的调用操作：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Psuedo C++ Code:</span></span><br><span class="line"><span class="comment">// Constructor Augmentation with Virtual Base class</span></span><br><span class="line">Vertex3d*</span><br><span class="line">Vertex3d::Vertex3d( Vertex3d *<span class="keyword">this</span>, <span class="keyword">bool</span> __most_derived,</span><br><span class="line"><span class="keyword">float</span> x, <span class="keyword">float</span> y, <span class="keyword">float</span> z ) &#123;</span><br><span class="line">  <span class="keyword">if</span> ( __most_derived != <span class="literal">false</span> )</span><br><span class="line">    <span class="keyword">this</span>-&gt;Point::Point( x, y);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// invoke immediate base classes,</span></span><br><span class="line">  <span class="comment">// setting __most_derived to false</span></span><br><span class="line">  <span class="keyword">this</span>-&gt;Point3d::Point3d( <span class="literal">false</span>, x, y, z );</span><br><span class="line">  <span class="keyword">this</span>-&gt;Vertex::Vertex( <span class="literal">false</span>, x, y );</span><br><span class="line">  <span class="comment">// set vptrs</span></span><br><span class="line">  <span class="comment">// insert user code</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>所以，“virtual base class constructor 的被调用”有着明确的定义：<strong>只有当一个完整的 class object 被定义出来时，它才会被调用；如果 object 只是某个完整 object 的 subobject，它就不会被调用</strong>。</p>
<p>以这一点为杠杆，我们可以产生更有效率的constructors。某些新近的编译器把每一个constructor分裂为二，一个针对完整的object，另一个针对subobject。“完整object”版无条件地调用virtual base constructors，设定所有的vptrs等等。 “subobject”版则不调用virtual base constructors，也可能不设定vptrs等等。将在下一节讨论对vptr的设定。constructor的分裂可带来程序速度的提升。</p>
<h3 id="vptr-初始化语义学（The-Semantics-of-the-vptr-Initialization）"><a href="#vptr-初始化语义学（The-Semantics-of-the-vptr-Initialization）" class="headerlink" title="vptr 初始化语义学（The Semantics of the vptr Initialization）"></a>vptr 初始化语义学（The Semantics of the vptr Initialization）</h3><p>当我们定义一个 PVertex object 时，constructors 的调用顺序是：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Point(x, y);</span><br><span class="line">Point3d(x, y, z);</span><br><span class="line">Vertex(x, y, z);</span><br><span class="line">Vertex3d(x, y, z);</span><br><span class="line">PVertex(x, y, z);</span><br></pre></td></tr></table></figure></p>
<p>假设这个继承体系中的每一个 class 都定义了一个 virtual function：<code>size()</code>，该函数负责传回 class 的大小。如果我们写：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PVertex pv;</span><br><span class="line">Point3d p3d;</span><br><span class="line"></span><br><span class="line">Point *pt = &amp;pv;</span><br></pre></td></tr></table></figure></p>
<p>那么这个调用操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pt-&gt;size();</span><br></pre></td></tr></table></figure></p>
<p>将传回PVertex的大小，而：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pt = &amp;p3d;</span><br><span class="line">pt-&gt;size();</span><br></pre></td></tr></table></figure></p>
<p>将传回Point3d的大小。</p>
<p>假设在继承体系中的每一个 constructor 内都带一个调用操作，比如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Point3d::Point3d( <span class="keyword">float</span> x, <span class="keyword">float</span> y, <span class="keyword">float</span> z )</span><br><span class="line">: _x( x ), _y( y ), _z( z ) &#123;</span><br><span class="line">  <span class="keyword">if</span> ( spyOn )</span><br><span class="line">    <span class="built_in">cerr</span> &lt;&lt; <span class="string">"within Point3d::Point3d()"</span></span><br><span class="line">         &lt;&lt; <span class="string">" size: "</span> &lt;&lt; size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>那么，每次对<code>size()</code>的调用都会被决议为<code>PVertex::size()</code>吗（毕竟我们正在构造的是 PVertex）？</p>
<p>事实是，在 Point3d constructor 中调用的<code>size()</code>函数，必须被决议为<code>Point3d::size()</code>。更一般地，<strong>在一个 class （Point3d）的 constructor 中，经由构造中的对象（PVertex）来调用一个 virtual function，其函数实体应该是在此 class 中有作用的那个（Point3d）</strong>。</p>
<p>Constructors的调用顺序是：由根源而末端（bottom up)，由内而外（inside out)。 当base class constructor执行时，derived实体还没有被构造出来。在PVertex constructor执行完毕之前，PVertex并不是一个完整的对象：Point3d constructor执行之后，只有Point3d subobject构造完毕。</p>
<p>这意味着，当每一个PVertex base class constructors被调用时，编译系统必须保证有适当的<code>size()</code>函数实体被调用。怎样才能办到这一点呢？如果调用操作限制必须在constructor（或destructor）中直接调用，那么答案十分明显：将每一个调用操作以静态方式决议之，千万不要用到虚拟机制。如果是在Point3d constructor中，就明确调用<code>Point3d::size()</code>。</p>
<p>然而如果<code>size()</code>之中又调用一个virtual function情况下，这个调用也必须决议为Point3d的函数实体。其他情况下，这个调用是纯正的virtual，必须经由虚拟机制来决定其归向。也就是说，虚拟机制本身必须知道是否这个调用源自于一个constructor之中。</p>
<p>什么是决定一个class的virtual function名单的关键？答案是virtual table。virtual table通过vptr被处理。所以为了控制一个class中有所作用的函数，编译系统只要简单地控制住vptr的初始化和设定操作即可。</p>
<p>vptr初始化操作应该如何处理？视vptr在constructor之中“应该在何时被初始化”而定，我们有三种选择： </p>
<ol>
<li>在任何操作之前。 </li>
<li>在base class constructors调用操作之后，但是在程序员代码或是“member initialization list中所列的members初始化操作”之前。</li>
<li>在每一件事情发生之后。</li>
</ol>
<p>答案是2，策略2解决了“在class中限制一组virtual functions名单”的问题。如果每一个constructor都一直等待到其base class constructors执行完毕之后才设定其对象的vptt，那么每次它都能够调用正确的virtual function实体。</p>
<p>令每一个base class constructor设定其对象的vptr，使它指向相关的virtual table之后，构造中的对象就可以严格而正确橄变成“构造过程中所幻化出来的每一个class的对象。一个PVertex对象会先形成一个Point对象、 一个Point3d对象、一个Vertex对象、一个Vertex3d对象，然后才成为一个PVertex对象。在每一个base class constructor中，对象可以与constructor’s class 的完整对象作比较。对于对象而言，“个体发生学”概括了“系统发生学”。constructor 的执行算法通常如下：</p>
<ol>
<li>在derived class constructor中，“所有virtual base classes”及“上层base class”的constructors会被调用；</li>
<li>上述完成之后，对象的vptr(s)被初始化。指向相关的virtual table(s) </li>
<li>如果有member initialization list的话，将在constructor体内扩展开来。这必须在vptr被设定之后才进行，以免有一个virtual member function被调用。</li>
<li>执行程序员的代码</li>
</ol>
<p>例如，已知下面这个由程序员定义的PVertex constructor:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PVertex::PVertex(<span class="keyword">float</span> x, <span class="keyword">float</span> y, <span class="keyword">float</span> z) : _next(<span class="number">0</span>), Vertex3d(x, y, z), Point(x, y) &#123;</span><br><span class="line">    <span class="keyword">if</span>(spyOn)</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">"Within PVertex::PVertex()"</span> &lt;&lt; <span class="string">"size:"</span> &lt;&lt; size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>它很可能被扩展为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++伪码：</span></span><br><span class="line"><span class="comment">//PVertex constructor的扩展结果</span></span><br><span class="line">PVertex* PVertex::PVertex(PVertex *<span class="keyword">this</span>, <span class="keyword">bool</span> __most__derived, <span class="keyword">float</span> x, <span class="keyword">float</span> y, <span class="keyword">float</span> z) &#123;</span><br><span class="line">    <span class="keyword">if</span> (__most__derived != <span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">this</span>-&gt;Point::Point(x, y);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无条件调用上一层base</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;Vertex3d::Vertex3d(x, y, z);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将相关的Vptr初始化</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;__vptr__PVertex = __vtbl_PVertex;</span><br><span class="line">    <span class="keyword">this</span>-&gt;__vptr__Point__PVertex = __vtbl_Point_PVertex;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 程序员所写的码</span></span><br><span class="line">    <span class="keyword">if</span>(spyOn) </span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">"Within PVertex::PVertex()"</span> &lt;&lt; <span class="string">"size:"</span> &lt;&lt; (*<span class="keyword">this</span>-&gt;__vptr__PVertex[<span class="number">3</span>].faddr)(<span class="keyword">this</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br></pre></td></tr></table></figure></p>
<p>下面是vptr必须被设定的两种情况： </p>
<ol>
<li>当一个完整的对象被构造起来时。如果我们声明1个Point对象，Point constructor必须设定其vptr；</li>
<li>当一个subobject constructor调用了一个virtual function（不论是直接调用或间接调用）时.</li>
</ol>
<p>如果我们声明一个PVertex对象，然后由于我们对其base class constructors的最新定义，其vptr将不再需要在每一个base class constructor中被设定。解决之道是把constructor分裂为一个完整的object实体和一个subobject实体。在subobject实体中，vptr的设定可以省略。</p>
<p>在class的constructor 的 member initialization list中调用该class的一个虚拟函数，安全吗？就实际而将该函数运行于其classs data member的初始化行动中，总是安全的。这是，正如我们所见，vptr保证能够在member initialization list被扩展之前，由编译器正确设定好。但是在语意上这可能是不安全的，因为函数本身可能还得依赖未被设立初值的members。所以我并不推荐这种做法。然而，从vptr的整体来看是安全的。</p>
<h2 id="对象复制语义学（Object-Copy-Semantics）"><a href="#对象复制语义学（Object-Copy-Semantics）" class="headerlink" title="对象复制语义学（Object Copy Semantics）"></a>对象复制语义学（Object Copy Semantics）</h2><p>当设计一个 class，并以一个 class object 指定给另一个 class object 时，有三种选择：</p>
<ul>
<li>什么都不做，从而实施默认行为。</li>
<li>提供一个 explicit copy assignment operator。</li>
<li>明确地拒绝把一个 class object 指定给另一个 class object。</li>
</ul>
<p>如果选择第 3 点，只需将 copy assignment operator 声明为 private，并不提供定义即可。把它设置为private，我们就不再允许在任何地点（除了在member function以及此class的friends之中）进行赋值操作。不提供其函数定义，则一旦某个member function或friend企图影响一份拷贝，程序在链接时就会失败。</p>
<p>这一节，继续用 Point class 来帮助讨论：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  Point( <span class="keyword">float</span> x = <span class="number">0.0</span>, y = <span class="number">0.0</span> );</span><br><span class="line">  <span class="comment">//...(没有 virtual function)</span></span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">float</span> _x, _y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>似乎没有理由禁止拷贝一个 Point object，那么问题在于：默认行为是否足够？如果只是简单的拷贝操作，那么默认行为足够并且很有效率，没有理由再提供一个 copy assignment operator。</p>
<p>只有默认行为不够安全或不正确时，才需要设计一个 copy assignment operator。由于坐标都内带数值，所以不会发生“别名化”或“内存泄漏”。</p>
<p>那么如果程序员不对 Point 提供一个 copy assignment operator，只是依靠 memberwise copy，编译器是否会产生一个实体？实际和 copy constructor 一样，不会。因为这里以及有了 bitwise copy 语义，所以 implicit copy assignment operator 被视为毫无用处，所以不会被合成出来。</p>
<p>在以下情况下，不会表现出 bitwise copy 语义：</p>
<ul>
<li>当 class 内带一个 member object，而其 class 有一个 copy assignment operator 时。</li>
<li>当一个 class 的 base class 有一个 copy assignment operator 时。</li>
<li>当一个 class 声明了任何 virtual function（不能直接拷贝 vptr 的值，因为右边的 object 可能是一个 derived class object）。</li>
<li>当 class 继承自一个 virtual base class （无论其有没有 copy operator）时。</li>
</ul>
<p>于是，对于 Point class 的赋值操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Poitn a, b;</span><br><span class="line">...</span><br><span class="line">a = b;</span><br></pre></td></tr></table></figure></p>
<p>由 bitwise copy 完成，期间并没有 copy assignment operator 被调用。注意，我们可以提供一个 copy constructor，这样可以打开 NRV 优化，但这并不意味着也需要提供一个 copy assignment operator。</p>
<p>现在，导入一个 copy assignment operator，来说明其在继承下的行为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> Point&amp; Point::<span class="keyword">operator</span>=(<span class="keyword">const</span> Point&amp; p) &#123;</span><br><span class="line">  _x = p._x;</span><br><span class="line">  _y = p._y;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后派生一个 Point3d class（虚拟继承）：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3d</span> ：<span class="title">virtual</span> <span class="title">public</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  Point3d(<span class="keyword">float</span> x = <span class="number">0.0</span>, <span class="keyword">float</span> y = <span class="number">0.0</span>, <span class="keyword">float</span> z = <span class="number">0.0</span>);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">float</span> _z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在，如果 Point3d 没有定义 copy assignment operator，编译器就必须合成一个。类似于这样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Pseudo C++ Code: synthesized copy assignment operator</span></span><br><span class="line"><span class="keyword">inline</span> Point3d&amp;</span><br><span class="line">Point3d::<span class="keyword">operator</span>=( Point3d *<span class="keyword">const</span> <span class="keyword">this</span>, <span class="keyword">const</span> Point3d &amp;p ) &#123;</span><br><span class="line">  <span class="comment">// invoke the base class instance</span></span><br><span class="line">  <span class="keyword">this</span>-&gt;Point::<span class="keyword">operator</span>=( p );</span><br><span class="line">  <span class="comment">// memberwise copy the derived class members</span></span><br><span class="line">  _z = p._z;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>copy assignment operator 有一个不够理想、严谨的地方，那就是它缺乏一个 member assignment list（也就是类似于 member initialization list 的东西）。必须写成以下两种形式，才能调用 base class 的 copy assignment operator：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Point::<span class="keyword">operator</span>=(p3d);</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line">(*(Point*)<span class="keyword">this</span>) = p3d;</span><br></pre></td></tr></table></figure></p>
<p>因为缺少了 copy assignment list，所以编译器就没法压抑上一层 base class 的 copy operator 被调用。例如，下面是 Vertex（虚拟继承自 Point） 的 copy operator：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// class Vertex : virtual public Point</span></span><br><span class="line"><span class="keyword">inline</span> Vertex&amp; Vertex::<span class="keyword">operator</span>=( <span class="keyword">const</span> Vertex &amp;v ) &#123;</span><br><span class="line">  <span class="keyword">this</span>-&gt;Point::<span class="keyword">operator</span>=( v );</span><br><span class="line">  _next = v._next;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在从 Point3d 和 Vertex 中派生出 Vertex3d，下面为其 copy assignment operator：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> Vertex3d&amp;</span><br><span class="line">Vertex3d::<span class="keyword">operator</span>=( <span class="keyword">const</span> Vertex3d &amp;v ) &#123;</span><br><span class="line">  <span class="keyword">this</span>-&gt;Point::<span class="keyword">operator</span>=( v );</span><br><span class="line">  <span class="keyword">this</span>-&gt;Point3d::<span class="keyword">operator</span>=( v );</span><br><span class="line">  <span class="keyword">this</span>-&gt;Vertex::<span class="keyword">operator</span>=( v );</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译器怎样才能在 Point3d 和 Vertex 的 copy assignment operator 中压抑 Point 的 copy assignment operator ？编译器不能使用 constructor 的解决方案（附上额外的参数）。因为和 constructor、destructor 不同，取 copy assignment operator 的地址是合法的，下边的代码是合法的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> Point3d&amp; (Point3d::*pmfPoint3d) (<span class="keyword">const</span> Point3d&amp;) ;</span><br><span class="line"></span><br><span class="line">pmfPoint3d pmf = &amp;Point3d::<span class="keyword">operator</span>=;</span><br><span class="line">(x.*pmf)(x);</span><br></pre></td></tr></table></figure></p>
<p>然而我们无法支持它，仍然需要根据继承体系安插任何可能数目的参数给copy assignment operator。</p>
<p>另一个方法是，编译器为 copy assignment operator 产生分化函数（split functions），用来支持这个 class 成为 most-derived class 或成为中间的 base class。（这里没有说具体如何做，不是很懂这个方法）</p>
<p>事实上，copy assignment operator 在虚拟继承情况下行为不佳，需要小心设计和说明。许多编译器甚至并不尝试取得正确的语义，导致 virtual base class copy assignment operator 多次被调用。</p>
<p>有一种方法可以保证 most-derived class 会完成 virtual base class subobject 的 copy 行为，就是在 derived class 的 copy assignment operator 函数实体的最后，明确调用那个 operator：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> Vertex3d&amp;</span><br><span class="line">Vertex3d::<span class="keyword">operator</span>=( <span class="keyword">const</span> Vertex3d &amp;v ) &#123;</span><br><span class="line">  <span class="keyword">this</span>-&gt;Point3d::<span class="keyword">operator</span>=( v );</span><br><span class="line">  <span class="keyword">this</span>-&gt;Vertex::<span class="keyword">operator</span>=( v );</span><br><span class="line">  <span class="comment">// must place this last if your compiler does</span></span><br><span class="line">  <span class="comment">// not suppress intermediate class invocations</span></span><br><span class="line">  <span class="keyword">this</span>-&gt;Point::<span class="keyword">operator</span>=( v );</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这不能省略 subobject 的多重拷贝，但可以保证语义正确。另一个解决方案要求把 virtual subobject 拷贝到一个分离的函数中，并根据 call path 条件化的调用它。</p>
<p>作者的建议是：不要允许 virtual base class 的拷贝操作，甚至不要在任何 virtual base class 中声明数据。</p>
<h2 id="对象的功能（Object-Efficiency）"><a href="#对象的功能（Object-Efficiency）" class="headerlink" title="对象的功能（Object Efficiency）"></a>对象的功能（Object Efficiency）</h2><p>在下面的效率测试中，对象构造和拷贝所需的成本是以 Point3d class 声明为基准，从简单到复杂，依次声明为：Plain Ol’ Data、抽象数据类型（ADT）、单一继承、多重继承、虚拟继承。以下为测试主角：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Point3d <span class="title">lots_of_copies</span><span class="params">( Point3d a, Point3d b )</span> </span>&#123;</span><br><span class="line">  Point3d pC = a;</span><br><span class="line">  pC = b; <span class="comment">// 1</span></span><br><span class="line">  b = a; <span class="comment">// 2</span></span><br><span class="line">  <span class="keyword">return</span> pC;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中有四个 memberwise 初始化操作，包括两个参数，一个返回值以及一个局部对象 pC，还带有两个 memberwise 拷贝操作，在第 3、第 4 行。main 函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">main() &#123;</span><br><span class="line">  <span class="function">Point3d <span class="title">pA</span><span class="params">( <span class="number">1.725</span>, <span class="number">0.875</span>, <span class="number">0.478</span> )</span></span>;</span><br><span class="line">  <span class="function">Point3d <span class="title">pB</span><span class="params">( <span class="number">0.315</span>, <span class="number">0.317</span>, <span class="number">0.838</span> )</span></span>;</span><br><span class="line">  Point3d pC;</span><br><span class="line">  <span class="keyword">for</span> ( <span class="keyword">int</span> iters = <span class="number">0</span>; iters &lt; <span class="number">10000000</span>; iters++ )</span><br><span class="line">    pC = lots_of_copies( pA, pB );</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在最初的两个程序中，数据类型是一个 struct 和一个拥有 public 数据的 class：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point3d</span> &#123;</span> <span class="keyword">float</span> x, y, z; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3d</span> &#123;</span> <span class="keyword">public</span>: <span class="keyword">float</span> x, y, z; &#125;;</span><br></pre></td></tr></table></figure></p>
<p>对 pA 和 pB 的初始化操作通过 explicit initialization list 来完成：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Point3d pA = &#123; <span class="number">1.725</span>, <span class="number">0.875</span>, <span class="number">0.478</span> &#125;;</span><br><span class="line">Point3d pB = &#123; <span class="number">0.315</span>, <span class="number">0.317</span>, <span class="number">0.838</span> &#125;;</span><br></pre></td></tr></table></figure></p>
<p>结果如下：<br><img src="/img/1606880320.jpg" alt></p>
<p>下个测试，唯一的改变是数据的封装（public 变 private）以及 inline 函数的使用，以及一个 inline constructor，用以初始化每个 object，class 仍然展现 bitwise copy 语义，常识告诉我们效率应该相同，然而是有一些距离的：<br><img src="/img/1606880362.jpg" alt></p>
<p>所有测试都表现了 bitwise copy 语义，所以效率相似。然而一旦导入虚拟继承：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point1d</span> &#123;</span> ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point2d</span> :</span> <span class="keyword">public</span> <span class="keyword">virtual</span> Point1d &#123; ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3d</span> :</span> <span class="keyword">public</span> Point2d &#123; ... &#125;;</span><br></pre></td></tr></table></figure></p>
<p>则不再拥有 bitwise copy 语义，编译器将会合成 inline copy constructor 和 copy assignment operator。结果如下：<br><img src="/img/1606880419.jpg" alt></p>
<p>然后是有着封装和 virtual function 的 class，这种情况也是不允许 bitwise copy 语义的，inline copy constructor 和 copy assignment operator 被合成并调用。结果如下：<br><img src="/img/1606880455.jpg" alt></p>
<p>下面的测试是采用其他有着 bitwise copy 语义的表现方式，取代合成的 inline copy constructor 和 copy assignment operator。结果如下：<br><img src="/img/1606880485.jpg" alt></p>
<h2 id="解构语义学（Semantics-of-Destruction）"><a href="#解构语义学（Semantics-of-Destruction）" class="headerlink" title="解构语义学（Semantics of Destruction）"></a>解构语义学（Semantics of Destruction）</h2><p>如果 class 没有定义 destructor，那么只有在 class 内带的 member object （或是 class 自己的 base class）拥有 destructor 的情况下，编译器才会自动合成出一个。否则，destructor 被视为不需要，所以不会合成。</p>
<p>当我们从Point派生出一个Point3d时，如果没有声明一个destructor，编译器就没有必要合成一个destructor。</p>
<p>如果一个 class 确实不需要 destructor，还为其定义 destructor 是不符合效率的，应该拒绝那种“对称策略”的奇怪想法：“已经定义了一个 constructor，那么当然需要提供一个 destructor”。</p>
<p>为了决定 class 是否需要 destructor（或 constructor），应该想想一个 class object 的声明在哪里结束（或开始），需要什么操作才能保证对象的完整？例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  Point pt;</span><br><span class="line">  Point *p = <span class="keyword">new</span> Point3d;</span><br><span class="line">  foo(&amp;pt, p);</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">delete</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到<code>pt</code>和<code>p</code>作为<code>foo()</code>函数的参数前，必须先初始化其坐标，这时候就需要一个 constructor。</p>
<p>当明确 delete 一个 p 时会如何？是否有必要这么做：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;x(<span class="number">0</span>);</span><br><span class="line">p-&gt;y(<span class="number">0</span>);</span><br></pre></td></tr></table></figure></p>
<p>当然没必要，没有理由在 delete 前将对象内容清除干净，也无需归还任何资源，所以完全不需要一个 destructor。在结束pt和p的生命之前没有任何class使用者层面的程序操作是绝对必要的。因此也就不一定需要一个destructor。</p>
<p>当我们从Point3d和Vertex派生出Vertex3d时，如果我们不供应一个explicit Vertex3d destructor，那么我们还是希望Vertex destructor被调用，以结束一个Vertex3d object。因此，编译器必须合成一个Vertex3d destructor，其唯一任务就是调用Vertex destructor。如果我们提供一个Vertex3d destructor，编译器会扩展它，使它调用Vertex destructor（在我们所供应的程序代码之后）。一个由程序员定义的 destructor 被扩展的方式类似 constructor 被扩展的方式，但顺序相反（这里的destructor扩展形式似乎应为2，3，1，4，5）：</p>
<ol>
<li>如果 object 内带有一个 vptr，那么首先重设相关的 virtual table。</li>
<li>destructor 的函数本身现在被执行，也就是说 vptr 会在程序员的代码执行前被重设。</li>
<li>如果 class 拥有 member class objects，而后者拥有 destructor，那么它们会以其声明顺序相反的顺序被调用。</li>
<li>如果有任何直接的（上一层）nonvirtual base class 拥有 destructor，它们会以其声明顺序相反的顺序被调用。</li>
<li>如果有任何 virtual base class 拥有 destructor，而当前讨论的这个 class 是最尾端（most-derived）的 class，那么它们会以原来的构造顺序的相反顺序被调用。</li>
</ol>
<p>如 constructor 一样，目前对于 destructor 的一种最佳实现策略就是维护两个 destructor 实体：</p>
<ol>
<li>一个 complete 实体，总是设定好 vptr，并调用 virtual base class destructor。</li>
<li>一个 base class subobject 实体；除非在 destructor 函数中调用一个 virtual function，否则它绝不会调用 virtual base class destructor 并设定 vptr。</li>
</ol>
<p>一个object的生命结束于其destructor开始执行之时。由于每一个base class destructor都轮番被调用，所以derived object实际变成了一个完整的object。例如一个PVertex对象归还其内存空间之前，会依次变成一个Vertex3d对象、一个Vertex对象、一个Point3d对象，最后成为一个Point对象。当我们在destructor中调用member functions时，对象的蜕变会因为vptr的重新设定（在每一个destructor中，在程序员所供应的码执行之前）而受到影响。在程序中施行destructors的真正语意将在第6章详述。 </p>
<h1 id="第六章-执行期语义学（Runtime-Semantics）"><a href="#第六章-执行期语义学（Runtime-Semantics）" class="headerlink" title="第六章 执行期语义学（Runtime Semantics）"></a>第六章 执行期语义学（Runtime Semantics）</h1><p>想象一下我们有下面这个简单的式子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (yy == xx.getValue())</span><br></pre></td></tr></table></figure></p>
<p>其中xx和yy定义为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X xx; y yy;</span><br></pre></td></tr></table></figure></p>
<p>class Y定义为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Y</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>: </span><br><span class="line">    Y();</span><br><span class="line">    ~Y();</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>== (<span class="keyword">const</span> Y&amp;) <span class="keyword">const</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>class X定义为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>: x();</span><br><span class="line">  ~X();</span><br><span class="line">  <span class="function"><span class="keyword">operator</span> <span class="title">Y</span><span class="params">()</span> <span class="keyword">const</span></span>; /／译注：conversion运算符</span><br><span class="line">  <span class="function">X <span class="title">getValue</span><span class="params">()</span></span>; </span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>让我们看看本章一开始的那个表达式该如何处理。</p>
<p>首先，让我们决定equality〔等号）运算符所参考到的真正实体。在这个例子中，它将被决议（resolves）为“被overloaded的Y成员实体”。下面是该式子的第一次转换：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//resolution of intended operator</span></span><br><span class="line"><span class="keyword">if</span> (yy.<span class="keyword">operator</span>==(xx.getValue()))</span><br></pre></td></tr></table></figure></p>
<p>Y的equality〔等号〕运算符需要一个类型为Y的参数，然而<code>getValue()</code>传回的却是一个类型为X的object。若非有什么方法可以把一个X object转换为一个Y object，那么这个式子就算错。</p>
<p>本例中x提供一个conversion运算符，把一个X object转换为一个Y object。它必须施行于<code>getValue()</code>的返回值身上。下面是该式子的第二次转换：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//conversion of getValue()'s return value</span></span><br><span class="line"><span class="keyword">if</span>(yy.<span class="keyword">operator</span>==(xx.getValue().<span class="keyword">operator</span> Y()))</span><br><span class="line">``` </span><br><span class="line">到目前为止所发生的一切都是编译器根据<span class="class"><span class="keyword">class</span>的隐含语意，对我们的程序代码所做的“增胖”操作．如果我们需要，我们也可以明确地写出那样的式子。</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">接下来我们必须产生一个临时对象，用来放置函数调用所传回的值：</span></span><br><span class="line"><span class="class">- 产生一个临时的<span class="title">class</span> <span class="title">X</span> <span class="title">object</span>，放置`<span class="title">getValue</span>()`的返回值：`<span class="title">X</span> <span class="title">temp1</span> = <span class="title">xx</span>.<span class="title">getValue</span>()`</span></span><br><span class="line"><span class="class">- 产生一个临时的<span class="title">class</span> <span class="title">Y</span> <span class="title">object</span>，放置`<span class="title">operator</span> <span class="title">Y</span>()`的返回值：`<span class="title">Y</span> <span class="title">temp2</span> = <span class="title">temp1</span>.<span class="title">operator</span> <span class="title">Y</span>()`</span></span><br><span class="line"><span class="class">- 产生一个临时的<span class="title">int</span> <span class="title">object</span>，放置等号运算符的返回值：`<span class="title">int</span> <span class="title">temp3</span> = <span class="title">yy</span>.<span class="title">operator</span>==(<span class="title">temp2</span>)`</span></span><br><span class="line"><span class="class">- 最后适当的<span class="title">destructor</span>将被施行于每一个临时性的<span class="title">class</span> <span class="title">object</span>身上，这导致式子最后被转换为以下形式:</span></span><br><span class="line"></span><br><span class="line">```C++</span><br><span class="line">以下是条件句<span class="keyword">if</span> (yy == xx.getValue()) 的转换</span><br><span class="line">X temp1 = xx.getValue()</span><br><span class="line">Y temp2 = temp1.<span class="keyword">operator</span> Y()</span><br><span class="line"><span class="keyword">int</span> temp3 = yy.<span class="keyword">operator</span>==(temp2)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (temp3) ...</span><br><span class="line"></span><br><span class="line">temp2.Y::~Y();</span><br><span class="line">temp1.X::~X();</span><br></pre></td></tr></table></figure></p>
<h2 id="对象的构造和解构（Object-Construction-and-Destruction）"><a href="#对象的构造和解构（Object-Construction-and-Destruction）" class="headerlink" title="对象的构造和解构（Object Construction and Destruction）"></a>对象的构造和解构（Object Construction and Destruction）</h2><p>如果一个区段（以 {} 括起来的区域）或函数有一个以上的离开点，情况会复杂一些，destructor必须放在每一个离开点之前，如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Point point; </span><br><span class="line"><span class="comment">// constructor 在这里行动</span></span><br><span class="line"><span class="keyword">switch</span>( <span class="keyword">int</span>( point.x() ) ) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">-1</span> : </span><br><span class="line">    <span class="comment">// mumble; </span></span><br><span class="line">    <span class="comment">// destructor 在这里行动</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span> :</span><br><span class="line">    <span class="comment">// mumble; </span></span><br><span class="line">    <span class="comment">// destructor 在这里行动</span></span><br><span class="line">    <span class="keyword">return</span>; </span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span> :</span><br><span class="line">    <span class="comment">// mumble; </span></span><br><span class="line">    <span class="comment">// destructor 在这里行动</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">default</span> :</span><br><span class="line">    <span class="comment">// mumble; </span></span><br><span class="line">    <span class="comment">// destructor 在这里行动</span></span><br><span class="line">    <span class="keyword">return</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// destructor 在这里行动</span></span><br></pre></td></tr></table></figure></p>
<p>在上述例子中，destructor 的调用操作必须放在switch指令四个出口的return之前，另外也很有可能在这个区段的结束符号之前被生成出来，即使程序分析的结果发现绝不会到那里。</p>
<p>goto指令也可能需要多个destructor调用操作：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( cache )</span><br><span class="line">    <span class="comment">// check cache; if match, return 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  </span><br><span class="line">  Point xx;</span><br><span class="line">  <span class="comment">// constructor goes here</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">while</span> ( cvs.iter( xx ))</span><br><span class="line">    <span class="keyword">if</span> ( xx == value )</span><br><span class="line">      <span class="keyword">goto</span> found;</span><br><span class="line">  <span class="comment">// destructor goes here</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">found:</span><br><span class="line">  <span class="comment">// cache item</span></span><br><span class="line">  <span class="comment">// destructor goes here</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在上述例子中，destructor 的调用操作必须放在最后两个 return 之前，但是却不必放在最初的 return 之前，因为 object 还没有被定义。所以，在程序当中，我们应该<strong>把object 尽可能放置在它的那个程序区段附近，这样可以节省不必要的对象产生操作和摧毁操作</strong>。如果在检查cache之前就定义了Point object，那就不够理想。</p>
<h3 id="全局对象（Global-Objects）"><a href="#全局对象（Global-Objects）" class="headerlink" title="全局对象（Global Objects）"></a>全局对象（Global Objects）</h3><p>如果有以下程序片段：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Matrix identity;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// identity 必须在此处被初始化</span></span><br><span class="line">  Matrix m1 = identity;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>C++ 必须保证<code>main()</code>函数中第一次用到<code>identity</code>之前必须把<code>identity</code>构造出来。并在<code>main()</code>函数结束之前把<code>identity</code>摧毁掉。像<code>identity</code>这样的 global object，如果有 constructor 和 destructor，必须要静态的初始化和释放操作。</p>
<p>C++ 程序中所有的 global object 都放在 data segment 中，如果不给初值，那么所配置的内存内容为 0。因此在下面这段码中：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> v1 = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">int</span> v2;</span><br></pre></td></tr></table></figure></p>
<p>v1和v2都被配置于程序的data segment，vi值为1024，v2值为0（这和C略有不同，C并不自动设定初值）。在C语言中一个global object只能够被 一个常量表达式（可在编译时期求其值的那种）设定初值。当然，constructor并不是常量表达式。虽然class object在编译时期可以被放置于data segment中并且内容为0，但constructor一直要到程序激活（startup）时才会实施。必须对一个“放置于program data segment中的object的初始化表达式”做评估 (evaluate)，这正是为什么一个object需要静态初始化的原因。 </p>
<h3 id="局部静态对象（Local-Static-Objects）"><a href="#局部静态对象（Local-Static-Objects）" class="headerlink" title="局部静态对象（Local Static Objects）"></a>局部静态对象（Local Static Objects）</h3><p>有如下程序片段：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Matrix&amp; identity &#123;</span><br><span class="line">  <span class="keyword">static</span> Matrix mat_identity;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> mat_identity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Local static class object 保证以下语义：</p>
<ul>
<li><code>mat_identity</code>的constructor必须只能执行一次，虽然上述函数可能会被调用多次。</li>
<li><code>mat_identity</code>的destructor必须只能执行一次，虽然上述函数可能会被调用多次。</li>
</ul>
<p>编译器的策略之一事，无条件地在程序起始时构造出对象来。然而这会导致所有的local static class object都在程序起始时被初始化，即使它们所在的那个函数从不曾被调用。因此，只在<code>identity()</code>被调用时才把<code>mat_identity</code>构造起来是比较好的做法。</p>
<p>cfront 的做法是引入一个临时性对象以保护<code>mat_identity</code>的初始化操作，第一次处理<code>identity()</code>时，这个临时对象被评估为 false，于是 constructor 会被调用，然后临时对象被改为 true。而在相反的那一端，destructor也需要有条件地施行于<code>mat_identity</code>身上，但只有在<code>mat_identity</code>已经被构造起来时才算数。要判断<code>mat_identity</code>是否被构造起来，很简单。如果那个临时对象为true，就表示构造好了。困难的是，由于cfront产生C码，<code>mat_identity</code>对函数而言仍然是local，因此我没办法在静态的内存释放函数（static deallocation function）中存取它。解决的方法有点诡异：取出local object的地址。下面是cfront的输出（经过轻微的修润）:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 被产生出来的临时对象，作为戒护用</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span> *__0__<span class="title">F3</span> = 0;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// identity() 的名称会被 mangled</span></span><br><span class="line"><span class="function">struct Matrix* <span class="title">identity_Fv</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span> __1<span class="title">mat_identity</span>;</span></span><br><span class="line">  <span class="comment">// 如果临时性的保护对象已被设立，那就什么也别做，否则：</span></span><br><span class="line">  <span class="comment">// (a) 调用constructor：__ct__6MatrixFv</span></span><br><span class="line">  <span class="comment">// (b) 设定保护对象，使它指向目标对象</span></span><br><span class="line"></span><br><span class="line">  __0__F3 </span><br><span class="line">    ? <span class="number">0</span></span><br><span class="line">    :(__ct__1MatrixFv ( &amp; __1mat_identity ),</span><br><span class="line">     (__0__F3 = (&amp;__1mat_identity)));</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后，destructor必须在与text program file有关联的静态内存释放函数中被有条件调用：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> __std__stat_0_c () &#123;</span><br><span class="line">  __0__F3</span><br><span class="line">    ? __dt__6MatrixFv( __0__F3, <span class="number">2</span>)</span><br><span class="line">    : <span class="number">0</span> ;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="对象数组（Array-of-Object）"><a href="#对象数组（Array-of-Object）" class="headerlink" title="对象数组（Array of Object）"></a>对象数组（Array of Object）</h3><p>假设有这样的数组定义：<code>Point knots[10];</code>。</p>
<p>如果 Point 没有定义 constructor 和 destructor，那么只需配置足够的内存即可，不需要做其他事。</p>
<p>如果 Point 明确定义了 default constructor，那么 这个 constructor 必须轮流施行于每个元素之上。在 cfront 中，使用了一个名为<code>vec_new()</code>的函数产生出以 class object 构造而成的数组。函数类型通常如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span>* vec_new &#123;</span><br><span class="line">  <span class="keyword">void</span> *<span class="built_in">array</span>,      <span class="comment">// address of start of array</span></span><br><span class="line">  <span class="keyword">size_t</span> elem_size, <span class="comment">// size of each class object</span></span><br><span class="line">  <span class="keyword">int</span> elem_count,   <span class="comment">// number of elements in array</span></span><br><span class="line">  <span class="keyword">void</span> (*constructor)( <span class="keyword">void</span>* ),</span><br><span class="line">  <span class="keyword">void</span> (*destructor)( <span class="keyword">void</span>*, <span class="keyword">char</span> )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中 constructor 和 destructor 参数是这个 class 的 default constructor 和 default destructor 的函数指针。参数array带有的若不是具名数组的地址，就是0。若 array 的地址为 0，那么数组将经由应用程序的 new 运算符动态的配置于 heap 中。elem_size 表示数组中的元素数目。在<code>vec_new()</code>中，constructor施行于<code>elem_count</code>个元素之上。对于支持exception handling的编译器而言，destructor的提供是必要的。下面是编译器可能针对我们的10个Point元素所做的<code>vec_new()</code>调用操作：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Point knots[<span class="number">10</span>];</span><br><span class="line">vec_new(&amp;knots, <span class="keyword">sizeof</span>(Point), <span class="number">10</span>, &amp;Point::Point, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></p>
<p>如果 Point 也定义了 destructor，那么当 knots 的生命结束时，destructor 会施行于那 10 个 Point 元素身上。这会经由类似的一个<code>vec_delete()</code>来完成，其函数类型通常如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span>*</span><br><span class="line">vec_delete &#123;</span><br><span class="line">  <span class="keyword">void</span> *<span class="built_in">array</span>,      <span class="comment">// address of start of array</span></span><br><span class="line">  <span class="keyword">size_t</span> elem_size, <span class="comment">// size of each class object</span></span><br><span class="line">  <span class="keyword">int</span> elem_count,   <span class="comment">// number of elements in array</span></span><br><span class="line">  <span class="keyword">void</span> (*destructor)( <span class="keyword">void</span>*, <span class="keyword">char</span> )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>若程序员提供一个或多个初值给这个数组：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Point knots[<span class="number">10</span>] = &#123;</span><br><span class="line">  Point(),</span><br><span class="line">  Point(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">0.5</span>),</span><br><span class="line">  <span class="number">-1.0</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>那么对于明显获得初值的元素，<code>vec_new()</code>就不需要了，但对于尚未被初始化的元素，<code>vec_new()</code>的施行方式就像面对“由class elements组成的数组，而该数组没有explicit initialization list”一样，定义可能会被转换为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Point knots[ <span class="number">10</span> ];</span><br><span class="line"><span class="comment">// Pseudo C++ Code</span></span><br><span class="line"><span class="comment">// initialize the first 3 with explicit invocations</span></span><br><span class="line">Point::Point( &amp;knots[<span class="number">0</span>]);</span><br><span class="line">Point::Point( &amp;knots[<span class="number">1</span>], <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">0.5</span> );</span><br><span class="line">Point::Point( &amp;knots[<span class="number">2</span>], <span class="number">-1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span> );</span><br><span class="line"><span class="comment">// initialize last 7 with vec_new ...</span></span><br><span class="line">vec_new( &amp;knots+<span class="number">3</span>, <span class="keyword">sizeof</span>( Point ), <span class="number">7</span>, &amp;Point::Point, <span class="number">0</span> );</span><br></pre></td></tr></table></figure></p>
<h3 id="Default-Constructors和数组"><a href="#Default-Constructors和数组" class="headerlink" title="Default Constructors和数组"></a>Default Constructors和数组</h3><p>如果你想要在程序中取出一个constructor的地址，这是不可以的。当然啦， 这是编译器在支持<code>vec_new()</code>时该做的事清然而，经由一个指针来激活constructor，将无法（不被允许）存取default argument values。</p>
<p>举个例子，在cfront 2.0之前，声明一个由class objects所组成的数组，意味着这个class必须没有声明constructors或一个default constructor（没有参数那种）。一个constructor不可以取一个或一个以上的默认参数值。这是违反直觉的，会导致以下的大错。下面是在cfront1.0中对于复数函数库（complex library）的声明，你能够看出其中的错误吗？<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">complex</span> </span></span><br><span class="line"><span class="class"><span class="title">Complex</span> (<span class="title">double</span> = 0.0, <span class="title">double</span> = 0.0);</span></span><br></pre></td></tr></table></figure></p>
<p>在当时的语言规则下，此复数函数库的使用者没办法声明一个由complex class objects组成的数组．显然我们在语言的一个陷阱上被绊倒了．在1.1版我们修改的是class library；然而在2.0版，我们修改了语言本身。</p>
<p>再一次地，让我们花点时间想想，如何支持以下句子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Complex::<span class="keyword">complex</span> (<span class="keyword">double</span>=<span class="number">0.0</span>, <span class="keyword">double</span>=<span class="number">0.0</span>);</span><br></pre></td></tr></table></figure></p>
<p>当程序员写出：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">complex</span> c_array[<span class="number">10</span>];</span><br></pre></td></tr></table></figure></p>
<p>时，而编译器最终需要调用：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vec_new(&amp;c_array, <span class="keyword">sizeof</span>(<span class="keyword">complex</span>), <span class="number">10</span>, &amp;<span class="keyword">complex</span>::<span class="keyword">complex</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></p>
<p>默认的参数如何能够对<code>vec_new()</code>而言有用？ 很明显，有多种可能的实现方法。cfront所采用的方法是产生一个内部的stub constructor，没有参数。在其函数内调用由程序员提供的constructor，并将default参数值明确地指定过去（由于constructor的地址已被取得，所以它不能够成为一个inline):<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 内部产生的stub constructor </span></span><br><span class="line"><span class="comment">// 用以支持数组的构造 </span></span><br><span class="line"><span class="keyword">complex</span>::<span class="keyword">complex</span>() &#123;</span><br><span class="line">  <span class="keyword">complex</span>(<span class="number">0.0</span>, <span class="number">0.0</span>)</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line">编译器自己又一次违反了一个明显的语言规则：<span class="class"><span class="keyword">class</span>如今支持了两个没有带参数的<span class="title">constructors</span>。当然，只有当<span class="title">class</span> <span class="title">object</span>：数组真正被产生出来时，<span class="title">stub</span>实体才会被产生以及被使用。</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">## <span class="title">new</span> 和 <span class="title">delete</span> 运算符</span></span><br><span class="line"><span class="class">运算符 <span class="title">new</span> 是由以下两步完成的：</span></span><br><span class="line"><span class="class">1. 通过适当的 <span class="title">new</span> 运算符函数实体，配置所需内存：</span></span><br><span class="line"><span class="class">```<span class="title">C</span>++</span></span><br><span class="line"><span class="class">// 调用函数库中的 <span class="title">new</span> 运算符</span></span><br><span class="line"><span class="class"><span class="title">int</span> *<span class="title">pi</span> = __<span class="title">new</span>(<span class="title">sizeof</span>(<span class="title">int</span>));</span></span><br></pre></td></tr></table></figure></p>
<ol start="2">
<li>给配置得来的对象设立初值：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*pi = <span class="number">5</span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>其中，初始化操作应该在内存配置成功后才执行：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// new 运算符的两个分离步骤</span></span><br><span class="line"><span class="comment">// given: int *pi = new int(5);</span></span><br><span class="line"><span class="keyword">int</span> *pi;</span><br><span class="line"><span class="keyword">if</span> (pi = __new(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)))</span><br><span class="line">  *pi = <span class="number">5</span>;</span><br></pre></td></tr></table></figure></p>
<p>delete 的情况类似，如果 pi 的值是 0，c++ 要求 delete 不要有操作：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (pi != <span class="number">0</span>)</span><br><span class="line">  __delete(pi);</span><br></pre></td></tr></table></figure></p>
<p>pi并不会自动被清除为0，因此像这样的后继行为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (pi &amp;&amp; *pi == <span class="number">5</span>)</span><br></pre></td></tr></table></figure></p>
<p>虽然没有良好定义，但是可能（也可能不）被评估为真。这是因为对于pi所指向的内存的变更或再使用没有肯定的答案。</p>
<p>pi所指对象之生命会因delete而结束・所以后继任何对pi的参考操作就不再保证有良好的行为，并因此被视为是一种不好的程序风格。然而，把pi继续当做一个指针来用，仍然是可以的（虽然其使用受到限制），例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ok: p1仍然指向合法空间 </span></span><br><span class="line"><span class="comment">// 甚至即使储存于其中的object已经不再合法 </span></span><br><span class="line"><span class="keyword">if</span>(p1==sentinel)</span><br></pre></td></tr></table></figure></p>
<p>在这里，使用指针pi和使用pi所指的对象、其差别在于哪一个的生命已经结束了。虽然该地址上的对象不再合法，但地址本身却仍然代表一个合法的程序空间。因此pi能够继续被使用，但只能在受限制的情况下，很像一个<code>void*</code>指针的情况。 </p>
<p>以constructor来配置一个class object，情况类似。例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Point3d *origin = <span class="keyword">new</span> Point3d</span><br></pre></td></tr></table></figure></p>
<p>被转换为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Point3d *origin;</span><br><span class="line"><span class="comment">// C++ 伪码</span></span><br><span class="line"><span class="keyword">if</span> (origin = __new(<span class="keyword">sizeof</span>(Point3d)))</span><br><span class="line">  origin = Point3d::Point3d(origin);</span><br></pre></td></tr></table></figure></p>
<p>如果实现出exception handling，那么转换结果会更复杂：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ 伪码</span></span><br><span class="line"><span class="keyword">if</span> (origin = __new(<span class="keyword">sizeof</span>(Point3d)))</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    origin = Point3d::Point3d(origin);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span>( ... ) &#123;</span><br><span class="line">    <span class="comment">// 调用delete library function以释放new配置的内存</span></span><br><span class="line">    __delete(origin);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将原来的exception上传</span></span><br><span class="line">    <span class="keyword">throw</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>如果以new配置object，而其constructor丢出一个exception，配置得来的内存就会被释放掉，然后exception再被丢出去。</p>
<p>destructor得应用极为类似：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> origin;</span><br></pre></td></tr></table></figure></p>
<p>会变成：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (origin != <span class="number">0</span>) &#123;</span><br><span class="line">  Point3d::~Point3d(origin);</span><br><span class="line">  __delete(origin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一般的 library 对于 new 运算符的实现如下（略去了 exception handling 的版本）：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (size == <span class="number">0</span>) </span><br><span class="line">    size = <span class="number">1</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">void</span> *last_alloc;</span><br><span class="line">  <span class="keyword">while</span> (!(last_alloc = <span class="built_in">malloc</span>(size))) &#123;</span><br><span class="line">    <span class="keyword">if</span> (_new_handler)</span><br><span class="line">      (*_new_handler)();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> last_alloc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>虽然<code>new T[0];</code>是合法的，但语言要求每一次对 new 的调用都必须传回一个独一无二的指针，所以程序中会<strong>有一个默认的 size 被设为 1</strong>。并且这个实现还允许使用者提供一个属于自己的<code>_new_handler()</code>函数。</p>
<p><code>new</code>和<code>delete</code>运算符实际上都是由标准的 C <code>malloc()</code>和<code>free()</code>完成的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* ptr)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (ptr)</span><br><span class="line">    <span class="built_in">free</span>( (<span class="keyword">char</span>*)ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="针对数组的-new-语义"><a href="#针对数组的-new-语义" class="headerlink" title="针对数组的 new 语义"></a>针对数组的 new 语义</h3><p>当我们这么写：<code>int *p_array = new int[5];</code>时，<code>vec_new()</code>不会被调用，因为<code>vec_new()</code>的主要功能是把 default constructor 施行于 class object 所组成的数组的每个元素上。被调用的是 new 运算符：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p_array = (<span class="keyword">int</span>*)__new(<span class="number">5</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br></pre></td></tr></table></figure></p>
<p>对于没有定义 default constructor 的 class 也是一样。只有在 class 定义了一个 default constructor 时，某些版本的<code>vec_new()</code>才会被调用。例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Point3d *p_array = <span class="keyword">new</span> Point3d[<span class="number">10</span>];</span><br></pre></td></tr></table></figure></p>
<p>会被编译为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Point3d *p_array;</span><br><span class="line">p_array = vec_new(<span class="number">0</span>, <span class="keyword">sizeof</span>(Point3d), <span class="number">10</span>, &amp;Point3d::Point3d, &amp;Point3d::~Point3d);</span><br></pre></td></tr></table></figure></p>
<p>还记得吗，在个别的数组元素构造过程中，如果发生exception，destructor就会被传递给<code>vec_new()</code>。只有已经构造妥当的元素才需要destructor的施行，因为它们的内存已经被配置出来了，<code>vec_new()</code>有责任在exception发生的时候把那些内存释放掉。 </p>
<p>在 C++ 2.0 之前，程序员需要将数组的真正大小提供给 delete 运算符。所以删除一个数组应该这样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> [array_size] p_array;</span><br></pre></td></tr></table></figure></p>
<p>在 2.1 版中，程序员无需提供数组元素数目了，所以可以这样写：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> [] p_array;</span><br></pre></td></tr></table></figure></p>
<p><strong>只有在中括号出现时，编译器才会寻找数组的维度，否则就认为只有单独一个 object 要被删除</strong>。</p>
<p>各家编译器存在一个有趣的差异，那就是元素数目如果被明显指定，是否会被拿去使用。在某个版本中，优先采用使用者（程序员）明确指定的值。下面是程序代码的虚拟版本（pseudo-version)，附带注释：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先检查是否最后一个被配置的项目（__cache_key)</span></span><br><span class="line"><span class="comment">// 是当前要被delete的项目</span></span><br><span class="line"><span class="comment">// 如果是，就不需要做搜寻操作了</span></span><br><span class="line"><span class="comment">// 如果不是，就寻找元素数目</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> elem_count = __cache_key == pointer </span><br><span class="line">  ? ((_cache_key = <span class="number">0</span>), __cache_cout)</span><br><span class="line">  : <span class="comment">// 取出元素数目</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// num_elem：元素数，将传递给vec_new()</span></span><br><span class="line"><span class="comment">// 对于配置于heap中的数组，只有针对以下形式，才会设定一个值：</span></span><br><span class="line"><span class="comment">// delete [10] ptr;</span></span><br><span class="line"><span class="comment">// 否则cfront会传-1以表示取出</span></span><br><span class="line"><span class="keyword">if</span> (num_elem == <span class="number">-1</span>)</span><br><span class="line">  <span class="comment">// prefer explicit user size if choice !</span></span><br><span class="line">  num_elem = ans;</span><br></pre></td></tr></table></figure></p>
<p>然而儿乎晚近所有的C++编译器都不考虑程序员的明确指定（如果有的话）:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"x.C"</span>, line <span class="number">3</span>: warning(<span class="number">467</span>) </span><br><span class="line">  <span class="function"><span class="keyword">delete</span> <span class="built_in">array</span> size expression <span class="title">ignored</span><span class="params">(anachronism)</span></span></span><br><span class="line"><span class="function">  <span class="title">foo</span><span class="params">()</span> </span>&#123;<span class="keyword">delete</span> [<span class="number">12</span>] pi; &#125;</span><br></pre></td></tr></table></figure></p>
<p>为什么这里优先采用程序员所指定的值，而新近的编译器却不这么做呢？因为这个性质刚被导入的时候，没有仟何程序代码会不“明确指定数组大小”。时代演化到cfront 4.0的今天，我们已经给这个习惯贴上“落伍”的标记，并且产生一个类似的警告消息。</p>
<p>应该如何记录元素数目？一个明显的方法就是为<code>vec_new()</code>所传回的每一个内存区块配置一个额外的word，然后把元素数目包藏在那个word之中。通常这种被包藏的数值称为所谓的cookie（小甜饼）。然而，某些编译器决定维护一个“联合数组（associative array)”，放置指针及大小，也把destructor的地址维护于此数组之中。</p>
<p>cookie策略有一个普遍引起忧虑的话题，那就是如果一个坏指针应该被交给<code>delete_vec()</code>，取出来的cookie自然是不合法的。一个不合法的元素数目和一个坏的起始地址，会导致destructor以非预期的次数被施行于一段非预期的区域，然而在联合数组的政策下，坏指针的可能结果只是取出错误的元素数目而已。</p>
<p>在原始编译器中，有两个主要函数用来存储和取出所谓的cookie：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// array_key是新数组的地址</span></span><br><span class="line"><span class="comment">// mustn't either be 0 or already entered</span></span><br><span class="line"><span class="comment">// elem_count is the count; it may be 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> *PV;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> __insert_new_array(PV array_key, <span class="keyword">int</span> elem_count);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从表格中取出并去除array_key</span></span><br><span class="line"><span class="comment">// 若不是传回elem_count，就是传回-1</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> __remove_old_array(PV array_key);</span><br></pre></td></tr></table></figure></p>
<p>对于 delete 操作，<code>vec_delete()</code>行为并不一定符合程序员的预期，比如对于这样一个 class :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  Point();</span><br><span class="line">  <span class="keyword">virtual</span> ~Point();</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3d</span> :</span> <span class="keyword">public</span> Point &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  Point3d();</span><br><span class="line">  ~Point3d();</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果我们这样配置一个数组：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Point *ptr = <span class="keyword">new</span> Point3d[<span class="number">10</span>];</span><br></pre></td></tr></table></figure></p>
<p>我们预期 Point 和 Point3d 的constructor 会各被调用 10 次。当我们 delete 这个 ptr 所指向的 10 个 Point3d 元素时，很显然需要虚拟机制的帮助，以获得 Point 和 Point3d 的 destructor 的各 10 次调用。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> [] ptr;</span><br></pre></td></tr></table></figure></p>
<p>然而，施行于数组上的 destructor 是根据<code>vec_delete()</code>函数之“被删除的指针类型的 destructor”——本例中为 Point destructor。所以这个程序就会出错。不仅仅是因为执行了错误的 destructor，而且从第一个元素开始往后，destructor 会被施行于不正确的内存区块中（因为元素大小不对）。</p>
<p>所以，我们应该避免以一个 base class 指针指向一个 derived class object class 所组成的数组。如果一定这样写程序，解决之道在于程序员层面，而非语言层面：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> ix = <span class="number">0</span>; ix &lt; elem_count; ++ix) &#123;</span><br><span class="line">  Point3d *p = &amp; ((Point <span class="number">3</span>d*)ptr)[ix];</span><br><span class="line">  <span class="keyword">delete</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>基本上，程序员必须迭代走过整个数组，把delete达算符实施于每一个元素身上．以此方式，调用操作将是virtual，因此，Point3d和Point的destructor都会施行于数组中的每一个objects身上。 </p>
<h3 id="Placement-Operator-new-的语义"><a href="#Placement-Operator-new-的语义" class="headerlink" title="Placement Operator new 的语义"></a>Placement Operator new 的语义</h3><p>有一个预先定义好的重载的 new 运算符，称为 placement operator new。它需要第二个参数，类型为<code>void*</code>，调用方式如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Point2w *ptw = <span class="keyword">new</span> (arena) Point2w;</span><br></pre></td></tr></table></figure></p>
<p>其中 arena 指向内存中的一个区块，用来放置新产生出来的 Point2w object。其实现方式出乎意料的平凡，它只要将获得的指针所指的地址传回即可：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span>, <span class="keyword">void</span>* p)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>看起来没啥用，只是传回第二个参数，但其实还有另一半操作，placement new operator 所扩充的另一半是<strong>将 Point2w constructor 自动实施于 arena 所指的地址上</strong>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Pseudo C++ code</span></span><br><span class="line">Point2w ptw = (Point2w *)arena;</span><br><span class="line"><span class="keyword">if</span> (ptw != <span class="number">0</span>) ptw-&gt;Point2w::Point2w();</span><br></pre></td></tr></table></figure></p>
<p>这份代码决定了objects被放置于哪里：编译系统保证 object 的 constructor 会施行于其上。但却有一个轻微的不良行为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// let arena be globally defined</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fooBar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Point2w *p2w = <span class="keyword">new</span> (arena) Point2w;</span><br><span class="line">  <span class="comment">// ... do it ...</span></span><br><span class="line">  <span class="comment">// ... now manipulate a new object ...</span></span><br><span class="line">  p2w = <span class="keyword">new</span> (arena) Point2w;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>如果 placement new 在原已存在的一个 object 上构造新的 object，而该 object 有一个 destructor，则这个 destructor 是不会被调用的。调用该 destructor 的方法之一是将那个指针 delete 掉，不过在此例中这样做是错误的，因为 delete 还会释放 p2w 所指内存，而我们马上还需要用这块内存。因此，我们应该显式调用 destructor（现在有一个 placement operator delete，无需手动调用 destructor 了）：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p2w-&gt;~Point2w;</span><br><span class="line">p2w = <span class="keyword">new</span> (arena) Point2w;</span><br></pre></td></tr></table></figure></p>
<p>还有一个问题是：如何知道 arena 所指的内存区块是否需要先解构？这在语言层面上没有解答，合理的习俗是令执行 new 的这一端也要负责执行 destructor。</p>
<p>另一个问题是 arena 所表现的真正指针类型，它必须指向相同类型的 class，或者是一块“新鲜”的内存，足够容纳该类型的 object。注意，derived class 很明显不在被支持之列。对于一个derived class，或是其他没有关联的类型，其行为虽然并非不合法，却也未经定义。</p>
<p>新鲜额存储空间可以这样配置而来：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *arena = <span class="keyword">new</span> <span class="keyword">char</span> [ <span class="keyword">sizeof</span>(Point2w) ];</span><br></pre></td></tr></table></figure></p>
<p>相同类型的object则可以这样获得：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Point2w *arena = <span class="keyword">new</span> Point2w;</span><br></pre></td></tr></table></figure></p>
<p>不论哪一种情况，新的Point2w的储存空间的确是覆盖了arena的位置，而此行为已在良好控制之下。然而，一般而言，placement new operator并不支持多态（polymorphism）。<strong>被交给new的指针，应该适当地指向一块预先配置好的内存</strong>。如果derived class比其base class大，例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Point2w *p2w = <span class="keyword">new</span> (arena) Point3w;</span><br></pre></td></tr></table></figure></p>
<p>Poit3w的constructor将会导致严重的破坏。</p>
<p>Placement new perator被引入C++ 2.0时，最晦涩隐暗的问题就是下面这个：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">strcut Base &#123; <span class="keyword">int</span> j; <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived</span> :</span> Base &#123; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fooBar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Base b;</span><br><span class="line">  b.f(); <span class="comment">// Base::f()被调用</span></span><br><span class="line">  b.~Base();</span><br><span class="line">  <span class="keyword">new</span> (&amp;b) Derived; <span class="comment">// 1</span></span><br><span class="line">  b.f(); <span class="comment">// 哪一个f()被调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述两个classes有相同的大小，故把derived object放在为base class配置的内存中是安全的，然而，要支持这一点，或许必须放弃对于“经由object静态调用所有virtual function”通常都会有的优化处理。结果，placement new operator的这种使用方式在C++中未能获得支持。于是上述程序的行为没有定义，大部分编译器调用的是Base::f()。</p>
<p>一般而言，placement new operator 并不支持多态。被交给 new 的指针应该是预先配置好的。</p>
<h2 id="临时性对象（Temporary-Objects）"><a href="#临时性对象（Temporary-Objects）" class="headerlink" title="临时性对象（Temporary Objects）"></a>临时性对象（Temporary Objects）</h2><p>如果找们有一个函数，形式如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T <span class="keyword">operator</span>+(<span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T&amp;);</span><br></pre></td></tr></table></figure></p>
<p>以及两个T objects，a和b，那么：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a + b</span><br></pre></td></tr></table></figure></p>
<p>可能会导致一个临时性对象，以放置传回的对象。是否会导致一个临时性对象，视编译器的进取性（aggressiveness)以及上述操作发生时的程序上下关系（program context)而定，例如下面这个片段：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">T a, b;</span><br><span class="line">T c = a + b;</span><br></pre></td></tr></table></figure></p>
<p>编译器会产生一个临时性对象，放置<code>a + b</code>的结果，然后再使用T的copy constructor，把该临时性对象当做c的初始值。然而比较更可能的转换是直接以拷贝构造的方式，将<code>a + b</code>的值放到c中（2.3节对于加法运算符的转换曾有讨论），于是就不需要临时性对象，以及对其constructor和destructor的调用了。</p>
<p>此外，视<code>operator+()</code>的定义而定，named return value (NRV）优化（请看2.3 节）也可能实施起来。这将导致直接在上述c对象中求表达式结果，避免执行copy constructor和具名对象（named object）的destructor。</p>
<p>三种方式所获得的c对象，结果都一样。其间的差异在于初始化的成本。一个编译器可能给我们任何保证吗？严格地说没有。C++ Standard允许编译器对于临时性对象的产生有完全的自由度。由于市场竞争，几乎保证任何表达式如果有这种形式：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T c = a + b;</span><br></pre></td></tr></table></figure></p>
<p>而其中的加法运算符被定义为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T <span class="keyword">operator</span>+(<span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T&amp;);</span><br></pre></td></tr></table></figure></p>
<p>或<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T T::<span class="keyword">operator</span>+(<span class="keyword">const</span> T&amp;);</span><br></pre></td></tr></table></figure></p>
<p>那么实现时根本不产生一个临时性对象。</p>
<p>然而请你注意，意义相当的assignment叙述句（statement）：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c = a + b;</span><br></pre></td></tr></table></figure></p>
<p>不能够忽略临时性对象。相反，它会导致下面的结果：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++伪码</span></span><br><span class="line"><span class="comment">// T temp = a + b;</span></span><br><span class="line">T temp;</span><br><span class="line">temp.<span class="keyword">operator</span>+(a, b); <span class="comment">// (1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// c = temp</span></span><br><span class="line">c.<span class="keyword">operator</span>=(temp); <span class="comment">//(2)</span></span><br><span class="line">temp.T::~T();</span><br></pre></td></tr></table></figure></p>
<p>标示为（1）的那一行，未构造的临时对象被赋值给<code>operator+()</code>。这意思是要不是“表达式的结果被copy constructed至临时对象中”，就是“以临时对象取代NRV”：在后者中，原本要施行于NRV的constructor，现在将施行于该临时对象。 </p>
<p>不管哪一种情况，直接传递c（上例赋值操作的目标对象）到运算符函数中是有问题的。由于运算符函数并不为其外加参数调用一个destructor（它期望一块 “新鲜的”内存），所以必须在此调用之前先调用destructor。然而，“转换”语意将被用来将下面的assignment操作：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c = a + b; <span class="comment">// c.operator=( a + b );</span></span><br></pre></td></tr></table></figure></p>
<p>取代为其copy assignment运算符的隐含调用操作，以及一系列的destructor和copy construction：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++伪码</span></span><br><span class="line">c.T::~T()</span><br><span class="line">c.T::T(a + b);</span><br></pre></td></tr></table></figure></p>
<p>copy constructor、destructor以及copy assignment operator都可以由使用者供应，所以不能够保证上述两个操作会导致相同的语意．因此，以一连串的destruction和copy construction来取代assignment，一般而言是不安全的，而且会产生临时对象。所以这样的初始化操作：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T c = a + b;</span><br></pre></td></tr></table></figure></p>
<p>总是比下面的操作更有效率地被编译器转换：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c = a + b;</span><br></pre></td></tr></table></figure></p>
<p>第三种运算形式是没有出现目标对象：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a + b;</span><br></pre></td></tr></table></figure></p>
<p>这时候有必要产生一个临时对象放置运算后的结果。例如如果：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s("hello"), t("world"), u("!");</span><br></pre></td></tr></table></figure></p>
<p>那么不论：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String v;</span><br><span class="line">v = s + t + u;</span><br></pre></td></tr></table></figure></p>
<p>或<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, s + t);</span><br></pre></td></tr></table></figure></p>
<p>都会导致产生一个临时对象，与<code>s + t</code>相关联。</p>
<p>“临时对象的生命期”论题颇值得深入探讨。在Standard C++之前，临时对象的生命（也就是说它的destructor何时实施）并没有明确指定，而是由编译厂商自行决定。换句话说，上述的printf并不保证安全，因为它的正确性与<code>s + t</code>何时被摧毁有关。本例的一个可能性是，String class定义了一个conversion运算符如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String::<span class="keyword">operator</span> <span class="keyword">const</span> <span class="keyword">char</span>*()&#123;<span class="keyword">return</span> _str; &#125;</span><br></pre></td></tr></table></figure></p>
<p>其中，_str是一个private member addressing storage，在String object构造时配置，在其destructor中被释放。</p>
<p>因此，如果果临时对象在调用<code>printf</code>之前就被解构了，经由convertion运算符交给它的地址就是不合法的．真正的结果视底部的delete运算符在释放内存时的进取性而定。某些编译器可能会把这块内存标示为free，不以任何方式改变其内容。在这块内存被其它地方宣称主权之前，只要它还没有被deleted掉，它就可以被使用。像这样在内存被释放之后又再被使用，并非罕见。事实上<code>malloc()</code>的许多编译器会提供一个特殊的调用操作：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">malloc</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure></p>
<p>下面是对于该算式的一个可能的pre-Standard转化。虽然在pre-Standard语言定义中是合法的，但可能造成重大灾难。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++伪码：pre-Standard的合法转换</span></span><br><span class="line"><span class="comment">// 临时性对象被摧毁得太快（太早）了</span></span><br><span class="line">String temp1 = <span class="keyword">operator</span>+(s, t);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *temp2 = temp1.<span class="keyword">operator</span> <span class="keyword">const</span> <span class="keyword">char</span>*();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合法但是有欠考虑，太过轻率 </span></span><br><span class="line">temp1.~String();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这时候并未定义temp2指向何方</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, temp2);</span><br></pre></td></tr></table></figure></p>
<p>另一种（比较被喜欢的）转换方式是在调用<code>printf()</code>之后实施String destructor。在C++ Standard之下，这正是该表达式的必须转换方式。标准规格上这么说： </p>
<blockquote>
<p>临时性对象的被摧毁，应该是对完整表达式〔full-expression）求值过程中的最后一个步骤。该完整表达式造成临时对象的产生。</p>
</blockquote>
<p>什么是一个完整表达式（full-expression)？非正式地说，它是被涵括的表达式中最外围的那个。下面这个式子；<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(( objA &gt; <span class="number">1024</span>) &amp;&amp; (objB &gt; <span class="number">1024</span> )) ? objA + objB : foo(objA, objB);</span><br></pre></td></tr></table></figure></p>
<p>一共有五个子算式（subexpressions），内带在一个“?：完整表达式”中。<strong>任何一个子表达式所产生的任何一个临时对象，都应该在完整表达式被求值完成后，才可以毁去</strong>。 </p>
<p>当临时性对象是根据程序的执行期语意有条件地被产生出来时，临时性对象的生命规则就显得有些复杂了。举个例子，像这样的表达式：<code>if (s + t || u + v)</code>，其中的<code>u + v</code>子算式只有在<code>s + t</code>被评估为false时，才会开始被评估。与第二个子算式有关的临时性对象必须被摧毁。但是，很明显地，不可以被无条件地摧毁。也就是说，我们希望只有在临时性对象被产生出来的情况下才去摧毁它。</p>
<p>在讨论临时对象的生命规则之前，标准编译器将临时对象的构造和解构附着于第二个子算式的评估程序中。例如，对于以下的class声明：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    x();</span><br><span class="line">    ~X();</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">X <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="keyword">private</span>: </span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>以及对于class X的两个objects的条件测试：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">main() &#123;</span><br><span class="line">  X xx;</span><br><span class="line">  X yy;</span><br><span class="line">  <span class="keyword">if</span>( xx.foo() || yy.foo() )</span><br><span class="line">  ;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>cfront对于<code>main()</code>产生出以下的转换结果（已经过轻微的修润和注释）：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">X</span> __<span class="title">lxx</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">X</span> __<span class="title">lyy</span>;</span></span><br><span class="line">  <span class="keyword">int</span> __0_result;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// name_mangled default constructor:</span></span><br><span class="line">  <span class="comment">// X:X( X *this)</span></span><br><span class="line">  __ct__1xFv( &amp;__lxx);</span><br><span class="line">  __ct__1xFv( &amp;__lyy);</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 被产生出来的临时性对象</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">X</span> __0__<span class="title">Q1</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">X</span> __0__<span class="title">Q2</span>;</span></span><br><span class="line">    <span class="keyword">int</span> __0__Q3;</span><br><span class="line">    <span class="comment">/* 每一端变成一个附逗点的表达式</span></span><br><span class="line"><span class="comment">     * 有着以下的次序:</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * tempQ1 = xx.foo(); </span></span><br><span class="line"><span class="comment">     * tempQ3 = tempQ1.operator int();</span></span><br><span class="line"><span class="comment">     * tempQ1.X::-X();</span></span><br><span class="line"><span class="comment">     * tempQ3;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// __opi__1xFv ==&gt; X::operator int() </span></span><br><span class="line">    <span class="keyword">if</span> (((( </span><br><span class="line">      __0__Q3 = __opi__1xFv(((</span><br><span class="line">      __0__Q1 = foo__1xFv( &amp;__1xx )), ( &amp;__0__Q1 )))), </span><br><span class="line">      __dt__1xFv( &amp;__0__Q1, <span class="number">2</span> )), __0__Q3)</span><br><span class="line">    || (((</span><br><span class="line">      __0__Q3 = __opi__1xFv(((</span><br><span class="line">      __0__Q2 = foo__1xFv( &amp;__1yy )), ( &amp;__0__Q2)))),</span><br><span class="line">      __dt__1xFv( &amp;__0__Q2, <span class="number">2</span> )), __0__Q3 ))</span><br><span class="line">    &#123; </span><br><span class="line">      __0_result = <span class="number">0</span>;</span><br><span class="line">      __dt_1xFv( &amp;__lyy, <span class="number">2</span> );</span><br><span class="line">      __dt_1xFv( &amp;__lxx, <span class="number">2</span> ); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> __0_result; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>把临时性对象的destructor放在每一个子算式的求值过程中，可以免除“努力追踪第二个子算式是否真的需要被评估”。然而在C++ Standard的临时对象生命规则中，这样的策略不再被允许。临时性对象在完整表达式尚未评估完全之前，不得被摧毁。也就是说，某些形式的条件测试现在必须被安插进来，以决定是否要摧毁和第二算式有关的临时对象。</p>
<p>临时性对象的生命规则有两个例外。第一个例外发生在表达式被用来初始化一个object时。例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> verbose;</span><br><span class="line">...</span><br><span class="line">String progNameVersion = !verbose ? <span class="number">0</span> : progName + progVersion;</span><br></pre></td></tr></table></figure></p>
<p>其中progName和progVersion都是String objects。这时候会生出一个临时对象，放置加法运算符的运算结果：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String <span class="keyword">operator</span>+(<span class="keyword">const</span> String&amp;, <span class="keyword">const</span> String&amp;);</span><br></pre></td></tr></table></figure></p>
<p>临时对象必须根据对verbose的测试结果有条件地解构。在临时对象的生命规则之下，它应该在完整的“? : 表达式”结束评估之后尽快被摧毁。然而，如果progNameVersion的初始化需要调用一个copy constructor:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++伪码</span></span><br><span class="line">progNameVersion.String::String(temp);</span><br></pre></td></tr></table></figure></p>
<p>那么临时性对象的解构（在“?：完整表达式”之后）当然就不是我们所期望的。</p>
<p>C++ Standard要求说： </p>
<blockquote>
<p>凡含有表达式执行结果的临时性对象，应该存留到object的初始化操作完成为止。</p>
</blockquote>
<p>甚至即使每一个人都坚守C++ Standard中的临时对象生命规则，程序员还是有可能让一个临时对象在他们的控制中被摧毁。其间的主要差异在于这时候的行为有明确的定义。例如，在新的临时对象生命规则中，下面这个初始化操作保证失败：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不是个好主意 </span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *progNameversion = progName + progVersion;</span><br></pre></td></tr></table></figure></p>
<p>其中progName和progVersion都是String objects。产生出来的程序代码看起来像这样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ pseudo Code </span></span><br><span class="line">String temp; </span><br><span class="line"><span class="keyword">operator</span>+(temp, progName, progVersion); </span><br><span class="line">progNameVersion = temp.String::<span class="keyword">operator</span> <span class="keyword">char</span>*(); </span><br><span class="line">temp.String::~String();</span><br></pre></td></tr></table></figure></p>
<p>此刻progNameVersion指向未定义的heap内存！ </p>
<p>临时性对象的生命规则的第二个例外是“当一个临时性对象被一个reference绑定”时，例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> String &amp;space = ;</span><br></pre></td></tr></table></figure></p>
<p>产生出这样的程序代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++ pseudo Code </span></span><br><span class="line">String temp; </span><br><span class="line">temp.String::String(<span class="string">" "</span>); </span><br><span class="line"><span class="keyword">const</span> String &amp;space = temp;</span><br></pre></td></tr></table></figure></p>
<p>很明显，如果临时性对象现在被摧毁，那个reference也就差不多没什么用了。所以规则上说： </p>
<blockquote>
<p>如果一个临时性对象被绑定于一个reference，对象将残留，直到被初始化之reference的生命结束，或直到临时对象的生命范畴(scope)结束―视哪一种情况先到达而定。 </p>
</blockquote>
<h3 id="临时性对象的迷思（神话、传说）"><a href="#临时性对象的迷思（神话、传说）" class="headerlink" title="临时性对象的迷思（神话、传说）"></a>临时性对象的迷思（神话、传说）</h3><p>有一种说法是，由于当前的C++编译器会产生临时性对象，导致程序的执行比较没有效率。更有人认为，这种效率上的不彰足以掩盖C++在“抽象化”上的贡献。</p>
<h1 id="第七章-站在对象模型的尖端（On-the-Cusp-of-the-Object-Model）"><a href="#第七章-站在对象模型的尖端（On-the-Cusp-of-the-Object-Model）" class="headerlink" title="第七章 站在对象模型的尖端（On the Cusp of the Object Model）"></a>第七章 站在对象模型的尖端（On the Cusp of the Object Model）</h1><h2 id="template"><a href="#template" class="headerlink" title="template"></a>template</h2><p>下面是有关 template 的三个主要讨论方向：</p>
<ol>
<li>template 的声明。基本上来说就是当你声明一个 template class、template class member function 等等时，会发生什么事情。</li>
<li>如何“具现（instantiates）”出 class object 以及 inline nonmember，以及 member template functions，这些是“每一个编译单位都会拥有一份实体”的东西。</li>
<li>如何“具现（instantiates）”出 nonmember 以及 member template functions，以及 static template class members，这些都是“每一个可执行文件中只需要一份实体”的东西。这也就是一般而言 template 所带来的问题。</li>
</ol>
<p>“具现（instantiation）”表示“将真正的类型和表达式绑定到 template 相关形式参数（formal parameters）上头”的操作。下面是一个template function：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">Type</span></span></span><br><span class="line"><span class="class"><span class="title">min</span> (<span class="title">const</span> <span class="title">Type</span> &amp;<span class="title">t1</span>, <span class="title">const</span> <span class="title">Type</span> &amp;<span class="title">t2</span>) &#123;</span> ... &#125;</span><br></pre></td></tr></table></figure></p>
<p>用法如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">min(<span class="number">1.0</span>, <span class="number">2.0</span>);</span><br></pre></td></tr></table></figure></p>
<p>进程把Type绑定为double并产生<code>min()</code>的一个程序实体，其中<code>t1</code>和<code>t2</code>的类型都是double</p>
<h3 id="Template-的“具现”行为（Template-Instantiation）"><a href="#Template-的“具现”行为（Template-Instantiation）" class="headerlink" title="Template 的“具现”行为（Template Instantiation）"></a>Template 的“具现”行为（Template Instantiation）</h3><p>有如下 template Point class：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">enum</span> Status &#123; unallocated, normalized &#125;;</span><br><span class="line">  Point(Type x = <span class="number">0.0</span>, Type y = <span class="number">0.0</span>, Type z = <span class="number">0.0</span>);</span><br><span class="line">  ~Point();</span><br><span class="line">  <span class="function"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span>)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *, <span class="keyword">size_t</span>)</span></span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">static</span> Point&lt;Type&gt; *freeList;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> chunkSize;</span><br><span class="line">  Type _x, _y, _z;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>当编译器看得到<code>template class</code>声明时，什么也不会做，其 static data members 也并不可用，nested enum 也一样。</p>
<p>虽然 enum Status 的真正类型在所有的 Point instantiation 中都一样，其 enumerators 也是，但它们依然只能通过 template Point class 的某个实体来存取或操作：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ok:</span></span><br><span class="line">Point&lt;<span class="keyword">float</span>&gt;::Status s;</span><br><span class="line"><span class="comment">// error:</span></span><br><span class="line">Point::Status s;</span><br></pre></td></tr></table></figure></p>
<p>对于 freeList 和 chunkSize 也是一样的道理：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ok:</span></span><br><span class="line">Point&lt;<span class="keyword">float</span>&gt;::freeList;</span><br><span class="line"><span class="comment">// error:</span></span><br><span class="line">Point::freeList;</span><br></pre></td></tr></table></figure></p>
<p>像这样使用 static member，会产生一份类型为 float 的 Point class 实体，如果写下：<code>Point&lt;double&gt;::freeList;</code>，则会出现第二个实体。</p>
<p>如果定义一个指针，指向特定的实体： <code>Point&lt;float&gt;* ptr = 0;</code>，则什么也不会发生，因为 class object 的指针，本身并不是一个 class object，编译器无需知道与该 class 有关的任何 members 的数据或 object 布局数据，所以没有具现的必要。</p>
<p>如果不是 pointer 而是 reference：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Point&lt;<span class="keyword">float</span>&gt;&amp; ref = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></p>
<p>则真的会具现出一个“Point 的 float 实体”来。这个定义会被扩展为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Point&lt;<span class="keyword">float</span>&gt; temporary(<span class="keyword">float</span>(<span class="number">0</span>));</span><br><span class="line"><span class="keyword">const</span> Point&lt;<span class="keyword">float</span>&gt;&amp; ref = temporary;</span><br></pre></td></tr></table></figure></p>
<p>因为reference并不是无物的代名词，0被视作整数，必须要转换为以下类型的一个对象：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Point&lt;<span class="keyword">float</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>所以，一个 class object 的定义（隐含或明确的）就会导致 template class 的具现。也就是说，像上面的语句，会让 Type 绑定为 float，所以 temporary 会配置出能够容纳三个 float 成员的空间。</p>
<p><strong>对于 member functions， 只有在使用它们的时候才会被具现</strong>。当前的编译器并不精确遵循这项要求。之所以由使用者来主导“具现”<br>(instantiarition）规则，有两个主要原因：</p>
<ol>
<li>空间和时间效率的考虑。如果ctass中有100个member functions，但你的程序只针对某个类型使用其中两个，针对另一个类型使用其中五个，那么将其它193个函数都“具现”将会花费大量的时间和空间。</li>
<li>尚未实现的机能。并不是一个template具现出来的所有类型就一定能够完整支持一组member functions所需要的所有运算符。如果只“具现”那些真正用到的member functions，template就能够支持那些原本可能会造成编译时期错误的类型（types）。</li>
</ol>
<p>举个例子，origin的定义需要调用Point的default constructor和destructor，那么只有这两个函数需要被“具现”。类似的道理，当程序员写：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Point&lt;<span class="keyword">float</span>&gt; *p = <span class="keyword">new</span> Point&lt;<span class="keyword">float</span>&gt;;</span><br></pre></td></tr></table></figure></p>
<p>时，只有(1)Point template的float实例，(2) new运算符，(3) default constructor 需要被“具现”化。有趣的是，虽然new运算符是这个class的一个implicitly static member，以至于它不能够直接处理其任何一个nonstatic members，但它还是依赖真正的template参数类型，因为它的第一参数<code>size_t</code>代表class的大小。</p>
<p>这些函数在什么时候“具现”出来呢？当前流行两种策略：</p>
<ul>
<li>在编译时候。那么函数将“具现”于origin和p存在的那个文件中；</li>
<li>在链接时候。那么编译器会被辅助工具重新激活。template函数实体可能被放在这个文件中、别的文件中，或一个分离的储存位置上，</li>
</ul>
<p>在“int和long一致”（或“double和long double一致”）的结构之中，两个类型具现操作：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Point&lt;<span class="keyword">int</span>&gt; pi;</span><br><span class="line">Point&lt;<span class="keyword">long</span>&gt; pl;</span><br></pre></td></tr></table></figure></p>
<p>应该产生一个还是两个实体呢？目前我知道的所有编译器都产生两个实体（可能有两组完整的member functions)。C++ Standard并未对此有什么强制规定。 </p>
<h3 id="Template-的错误报告（Error-Reporting-within-a-Template）"><a href="#Template-的错误报告（Error-Reporting-within-a-Template）" class="headerlink" title="Template 的错误报告（Error Reporting within a Template）"></a>Template 的错误报告（Error Reporting within a Template）</h3><p>在 template class 中，所有与类型有关的检验，如果牵涉到 template 参数，都必须延迟到真正的具现操作（instantiation）发生，才可以进行。</p>
<p>在编译器处理 template 声明时，cfront 对 template 的处理是完全解析（parse）但不做类型检验，只有在每一个具现操作（instantiation）发生时才做类型检验。所以，对于语汇（lexing）错误和解析（parsing）错误都会在处理 template 声明的过程中被标示出来。</p>
<p>还有一种普遍的做法是，template 的声明被收集成为一系列的“lexical tokens”，而 parsing 操作延迟，直到真正有具现操作（instantiation）发生时才开始，在这之前，很少有错误会被指出。每当看到一个instantiation发生，这组token就被推往parser，然后调用类型检验等等。</p>
<p>目前的编译器，面对一个 template 声明，在被一组实际参数具现之前，只能施行有限的错误检查，template 中与语法无关的错误，编译器都会通过，只有在特定实体被定义之后，才会报错。</p>
<h3 id="Template-中的名称决议方式（Name-Resolution-within-a-Template）"><a href="#Template-中的名称决议方式（Name-Resolution-within-a-Template）" class="headerlink" title="Template 中的名称决议方式（Name Resolution within a Template）"></a>Template 中的名称决议方式（Name Resolution within a Template）</h3><p>要区分出以下两种意义，一种是“scope of the template definition”，也就是定义出 template 的程序，另一种是“scope of the template instantiation”，也就是具现出 template 的程序。例如第一种情况：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// scope of the template definition</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">double</span> <span class="title">foo</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">ScopeRules</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">invariant</span><span class="params">()</span> </span>&#123; _member = foo(_val); &#125;</span><br><span class="line">  <span class="function">type <span class="title">type_dependent</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> foo(_member); &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> _val;</span><br><span class="line">  type _member;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>第二种情况：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// scope of the template instantiation</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">ScopeRules&lt;<span class="keyword">int</span>&gt; sr0</span><br></pre></td></tr></table></figure></p>
<p>在 ScopeRules template 中有两个<code>foo()</code>调用操作。在“scope of template definition”中，只有一个<code>foo()</code>函数声明位于 scope 内，而“scope of template instantiation”中，有两个<code>foo()</code>函数声明位于 scope 内。如果我们有一个函数调用操作，<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sr0.invariant();</span><br></pre></td></tr></table></figure></p>
<p>那么，在<code>invariant()</code>中调用的是哪一个<code>foo()</code>函数实体呢？在调用操作的那一点上，程序中的两个函数实体是：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">double</span> <span class="title">foo</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>而<code>_val</code>的类型是int，被选中的是：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">double</span> <span class="title">foo</span><span class="params">(<span class="keyword">double</span>)</span></span></span><br></pre></td></tr></table></figure></p>
<p>实际上，在 template 之中，对于一个 nonmember name 的决议结果，是<strong>根据这个 name 的使用是否与 template 的类型参数有关而决定的</strong>。如果互不相关，就以“scope of the template declaration”来决定 name。否则，以“scope of the template instantiation”来决定 name。</p>
<p>那么对于以下两个调用操作：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sr0.invariant();</span><br><span class="line">sr0.type_dependent();</span><br></pre></td></tr></table></figure></p>
<p>第一行的调用，<code>invariant()</code>中的<code>foo()</code>与用以具现 ScopeRules 的参数类型无关，<code>_val</code>的类型是int，是<strong>不会变的</strong>，此外，<strong>函数的决议结果只和函数的原型（signature）有关，与函数的返回值无关</strong>，所以<code>_member</code>的类型不影响哪个<code>foo()</code>实体被选中，<code>foo()</code>的调用与 template 参数毫无关联，所以必须根据“scope of the template declaration”来决议。</p>
<p>对于第二行的调用，很明显与 template 参数有关，template 参数将决定<code>_member</code>的真正类型。所以这一次<code>foo()</code>必须在“scope of the template instantiation”中决议，本例中，这个 scope 有两个<code>foo()</code>，所以如果<code>_member</code>的类型为 int，就会调用 int 版的<code>foo()</code>，如果是 double 则调用 double 版本的<code>foo()</code>，如果是 long，那么就会产生歧义了。</p>
<p>所以编译器必须保持两个 scope contexts：</p>
<ol>
<li>“scope of the template declaration”，用以专注于一般的 template class。</li>
<li>“scope of the template instantiation”，用以专注于特定的实体。</li>
</ol>
<h3 id="Member-Function-的具现行为（Member-Function-Instantiation）"><a href="#Member-Function-的具现行为（Member-Function-Instantiation）" class="headerlink" title="Member Function 的具现行为（Member Function Instantiation）"></a>Member Function 的具现行为（Member Function Instantiation）</h3><p>下面是编译器设计者必须回答的三个主要问题：</p>
<ol>
<li>编译器如何找出函数的定义？答案之一是包含template program text file，就好像它是个header文件一样。Borland编译器就是遵循这个策略。另一种方法是要求一个文件命名规则，例如，我们可以要求，在<code>Point.h</code>文件中发现的函数声明，其template program text一定要放置于文件<code>Point.C</code>或<code>Point.cpp</code>中，依此类推。cfront就是遵循这个策略。Edison Design Group编译器对此两种策略都支持。</li>
<li>编译器如何能够只具现出程序中用到的member functions？解决办法之一就是，根本忽略这项要求，把一个已经具现出来的class的所有member functions都产生出来。Borland就是这么做的，虽然它也提供<code>#pragmas</code>让你压制特定实体。另一种策略是仿真链接操作，检测看看那一个函数真正需要，然后只为它们产生实体。cfront就是这么做的。</li>
<li>编译器如何阻止 member definition 在多个 .o 文件中都被具现呢？解决办法之一就是产生多个实体，然后从链接器中提供支持，只留下其中一个实体，其余都忽略。另一个办法就是由使用者来导引“仿真链接阶段”的具现策略，决定哪些实体（instances）才是所需求的。</li>
</ol>
<p>目前，不论编译时期或链接时期的具现(instantiation）策略，其弱点就是，当template实体被产生出来时，有时候会大量增加编译时间。很显然，这将是template functions第一次具现时的必要条件。然而当那些函数被非必要地再次具现，或是当“决定那些函数是否需要再具现”所花的代价太大时，编译器的表现令人失望！</p>
<p>C++支持template的原始意图可以想见是一个由使用者导引的自动具现机制（use-directed automatic instantiation mechanism），既不需要使用者的介入，也不需要相同文件有多次的具现行为。但是这已被证明是非常难以达成的任务。</p>
<p>Edison Design Group 开发出一套第二代的 directed-instantiation 机制，主要过程如下：</p>
<ol>
<li>一个程序代码被编译时，最初不会产生任何“template具现体”。然而，相关信息已经产生于 object files 之中。</li>
<li>当 object file 被链接在一块时，会执行一个 prelinker 程序，它会检查 object files，寻找 template 实体的相互参考以及对应的定义。</li>
<li>对于每个“参考到 template 实体”而“该实体却没有定义”的情况，prelinker 将该文件视为与另一个文件（在其中，实体已经具现）同类。以这种方法，就可以将必要的程序具现操作指定给特定的文件。这些都会注册到 prelinker 所产生的 .ii 文件中。</li>
<li>prelinker 重新执行编译器，重新编译每个“.ii 文件被改变过”的文件。这个过程不断重复，直到所有必要的具现操作都已完成。</li>
<li>所有的 object files 被链接成一个可执行文件。</li>
</ol>
<h2 id="异常处理（Exception-Handling）"><a href="#异常处理（Exception-Handling）" class="headerlink" title="异常处理（Exception Handling）"></a>异常处理（Exception Handling）</h2><p>欲支持exception handling，编译器的主要工作就是找出catch子句，以处理被丢出来的exception。这多少需要追踪程序堆栈中的每一个函数的当前作用区域（包括追踪函数中的local class objects当时的情况）。同时，编译器必须提供某种查询exception objects的方法，以知道其实际类型（这直接导致某种形式的执行期类型识别，也就是RTTI）。最后，还需要某种机制用以管理被丢出的 object, 包括它的产生、储存、可能的解构（如果有相关的destructor）、清理（clean up）以及一般存取。也可能有一个以上的objects同时起作用。一般而言，exception handling机制需要与编译器所产生的数据结构以及执行期的一个exception library紧密合作。在程序大小和执行速度之间，编译器必须有所抉择：</p>
<ol>
<li>为了维持执行速度，编译器可以在编译时期建立起用于支持的数据结构。这会使程序的大小膨胀，但编译器可以几乎忽略这些结构，直到有个exception被丢出来。</li>
<li>为了维护程序大小，编译器可以在执行期建立起用于支持的数据结构。这会影响程序的执行速度，但意味着编译器只有在必要的时候才建立那些数据结构（并目可以抛弃之） </li>
</ol>
<h3 id="Exception-Handling-快速检阅"><a href="#Exception-Handling-快速检阅" class="headerlink" title="Exception Handling 快速检阅"></a>Exception Handling 快速检阅</h3><p>C++ 的 exception 由三个主要的语汇组件构成：</p>
<ol>
<li>一个 throw 子句。它在程序某处发出一个 exception。被丢出的 exception 可以是内建类型，也可以是使用者自定类型。</li>
<li>一个或多个 catch 子句。每一个 catch 子句都是一个 exception handler。它用来表示说，这个子句准备处理某种类型的 exception，并且在封闭的大括号区段中提供实际的处理程序。</li>
<li>一个 try 区段。它被围绕以一系列的 statements，这些语句可能会引发 catch 子句起作用。</li>
</ol>
<p>当一个 exception 被丢出时，控制权会从函数调用中被释放，并寻找吻合的 catch 子句。如果都没有吻合者，那么默认的处理例程<code>terminate()</code>会被调用。当控制权被放弃后，堆栈中的每个函数调用就被推离。这个程序称为<strong>unwinding the stack</strong>。在每个函数被推离堆栈之前，函数的 local class objects 的 destructor 会被调用。</p>
<p>在程序员层面，exception handling 也改变了函数在资源管理上的语义。例如下列程序，在 exception handling 下并不能保证正确运行：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mumble</span><span class="params">(<span class="keyword">void</span> *arena)</span> </span>&#123;</span><br><span class="line">  Point *p = <span class="keyword">new</span> Point;</span><br><span class="line">  smLock(arena);  <span class="comment">// function call</span></span><br><span class="line">  <span class="comment">// 如果有一个 exception 在此发生，问题就来了</span></span><br><span class="line">  <span class="comment">// ...;</span></span><br><span class="line">  smUnLock(arena);  <span class="comment">// function call</span></span><br><span class="line">  <span class="keyword">delete</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>本例中，exception handling 机制把整个函数视为单一区域，不需要操心“将函数从程序堆栈中unwinding”的事情。然而从语义上来说，在函数推出堆栈前，需要 unlock 共享内存，并<code>delete p</code>。所以应该像这样安插一个default cache：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mumble</span><span class="params">(<span class="keyword">void</span> *arena)</span> </span>&#123;</span><br><span class="line">  Point *p;</span><br><span class="line">  p = <span class="keyword">new</span> Point;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    smLock(arena);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (...) &#123;</span><br><span class="line">    smUnLock(arena);</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    <span class="keyword">throw</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  smUnLock(arena);</span><br><span class="line">  <span class="keyword">delete</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意，new 运算符的调用并非在 try 区段内。因为 new 运算符丢出一个 exception，那么就不需要配置 heap 中的内存，Point constructor 也不需要被调用。所以没有理由调用 delete 运算符。然而如果在 Point constructor 中发生 exception，此时内存已配置完成，那么 Point 之中任何构造好的合成物或子对象都将自动解构，然后 heap 内存也会被释放。不论哪种情况，都无需调用 delete 运算符。类似的，如果一个exception是在new运算符执行过程中被丢出，arena所指向的内存就绝不会被locked。因此也没有必要unlock。</p>
<p>对于这些资源管理问题，有一个办法就是将资源需求封装于一个 class object 体内，并由 destructor 来释放资源。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mumble</span><span class="params">( <span class="keyword">void</span> *arena)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">auto_ptr</span>&lt;Point&gt; ph ( <span class="keyword">new</span> Point);</span><br><span class="line">    <span class="function">SMLock <span class="title">sm</span><span class="params">(arena&#125;;</span></span></span><br><span class="line"><span class="function"><span class="params">    </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment">// 如果这里丢出一个exception，现在就没有问题了</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment">// ...</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment">// 不需要明确地unlock和delete</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment">// local destructors在这里被调用</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment">// sm.SMLock::~SMLock();</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment">// ph.auto_ptr&lt;Point&gt;::~auto_ptr&lt;Point&gt;();</span></span></span></span><br><span class="line"><span class="function"><span class="params">&#125;</span></span></span><br></pre></td></tr></table></figure></p>
<p>从exception handling的角度看，这个函数现在有三个区段：</p>
<ul>
<li>第一区段是<code>auto_ptr</code>被定义之处。</li>
<li>第二区段是<code>SMLock</code>被定义之处。</li>
<li>上述两个定义之后的整个函数。</li>
</ul>
<p>如果exception是在auto_ptr中被丢出的，那么就没有active local objects需要被EH机制摧毁。然而如果SMLock constructor中丢出一个exception，则auto_ptr object必须在“unwinding”之前先被摧毁。至于在第三个区段中，两个local objects当然必须被摧毁。</p>
<p>支持 EH，会使那些拥有 member class subobject 或 base class subobject 的 class 的 constructor 更复杂。一个 class 如果被部分构造，则其 destructor 必须只施行于那些已被构造的 subobject 和 member object 身上。这些事情都是编译器的责任。例如，假设class X有member objects A、B和C，都各有一对constructor和destructor，如果A的constructor丢出一个exception，不论A或B或C都不需要调用其destructor，如果B的constructor丢出一个exception，则A的destructor必须被调用，但C不用。</p>
<p>同样的道理，如果程序员写下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Point3d *cvs = <span class="keyword">new</span> Point3d[<span class="number">512</span>];</span><br></pre></td></tr></table></figure></p>
<p>会发生两件事：</p>
<ol>
<li>从 heap 中配置足以给 512 个 Point3d objects 所用的内存。</li>
<li>如果成功，先是 Point2d constructor，然后是 Point3d constructor，会施行于每个元素身上。</li>
</ol>
<p>如果 # 27 元素的 Point3d constructor 丢出一个 exception，对于 #27 元素，只有 Point2d destructor 需要调用。前 26 个元素 Point2d 和 Point3d 的destructor 都需要调用，然后释放内存。</p>
<h3 id="对-Exception-Handling-的支持"><a href="#对-Exception-Handling-的支持" class="headerlink" title="对 Exception Handling 的支持"></a>对 Exception Handling 的支持</h3><p>当一个 exception 发生时，编译系统必须完成以下事情：</p>
<ol>
<li>检验发生 throw 操作的函数；</li>
<li>决定 throw 操作是否发生在 try 区段中；</li>
<li>若是，编译系统必须把 exception type 拿来和每一个 catch 子句比较；</li>
<li>如果比较吻合，流程控制应该交到 catch 子句手中；</li>
<li>如果 throw 的发生并不在 try 区段中，或没有一个 catch 子句吻合，那么系统必须 (a) 摧毁所有 active local objects，(b) 从堆栈中将当前的函数“unwind”掉，(c) 进行到程序堆栈中的下一个函数中去，然后重复上述步骤 2~5。</li>
</ol>
<p>一个函数可以被想象成是好几个区域：</p>
<ul>
<li>try区段以外的区域，而且没有active local objects</li>
<li>try区段以外的区域，但有一个（以上）的active local objects需要解构</li>
<li>try区段以内的区域。</li>
</ul>
<p>编译器必须标示出以上各区域，并使它们对执行期的exception handling系统有所作用。一个很棒的策略就是构造出program counter-range表格。</p>
<p>program counter（译注：在Intel CPU中为EIP缓存器）内含下一个即将执行的程序指令。为了在一个内含try区段的函数中标示出某个区域，可以把program counter的起始值和结束值（或是起始值和范围）储存在一个表格中。</p>
<p>当throw操作发生时，当前的program counter值被拿来与对应的“范围表格”进行比较，以决定当前作用中的区域是否在一个try区段中。如果是，就需要找出相关的catch子句（稍后我们再来看这一部分）。如果这个exception无法被处理（或者它被再次丢出），当前的这个函数会从程序堆栈中被推出（popped)，而program counter会被设定为调用端地址，然后这样的循环再重新开始。</p>
<h4 id="将exception的类型和每一个catch子句的类型做比较"><a href="#将exception的类型和每一个catch子句的类型做比较" class="headerlink" title="将exception的类型和每一个catch子句的类型做比较"></a>将exception的类型和每一个catch子句的类型做比较</h4><p>对于每一个被丢出来的exception，编译器必须产生一个类型描述器，对exception的类型进行编码。如果那是一个derived type，则编码内容必须包括其所有base class的类型信息。只编进public base class的类型是不够的，因为这个exception可能被一个member function捕捉，而在一个member function的范围（scope）之中，在derived class和nonpublic base class之间可以转换。</p>
<p>类型描述器（type descriptor)是必要的，因为真正的exception是在执行期 被处理，其object必须有自己的类型信息。RTTI正是因为支持EFI而获得的副产品。</p>
<p>编译器还必须为每一个catch子句产生一个类型描述器。执行期的exception handler会对“被丢出之object的类型描述器”和“每一个cause子句的类型描述器”进行比较，直至找到吻合的一个，或是直到堆栈已经被”unwound”而<code>terminate()</code>已被调用。</p>
<p>每一个函数会产生出一个exception表格，它描述与函数相关的各区域、任何必要的善后码（cleanup code、被local class object destructors调用），以及catch子句的位置（如果某个区域是在try区段之中）。 </p>
<h4 id="当一个实际对象在程序执行时被丢出，会发生什么事"><a href="#当一个实际对象在程序执行时被丢出，会发生什么事" class="headerlink" title="当一个实际对象在程序执行时被丢出，会发生什么事"></a>当一个实际对象在程序执行时被丢出，会发生什么事</h4><p>当一个exception被丢出时，exception object会被产生出来并通常放置在相同形式的exception数据堆栈中。从throw端传给catch子句的是exception object的地址、类型描述器（或是一个函数指针，该函数会传回与该exception type 有关的类型描述器对象），以及可能会有的exception object描述器（如果有人定义它的话）。</p>
<p>考虑如下 catch 子句：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">catch</span>(exPoint p) &#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">  <span class="keyword">throw</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以及一个 exception object，类型为 exVertex，派生自 exPoint。这两种类型都吻合，于是 catch 子句会作用起来：</p>
<ul>
<li>p 将以 exception object 作为初值，就像是一个函数参数一样。这意味着 copy constructor 和 destructor（如果有）都会实施于local copy 身上。</li>
<li>由于 p 是一个 object 而非 reference，所以拷贝时，non-exPoint 部分会被切掉（sliced off）。此外，如果有 virtual function，那么 p 的 vptr 会被设为 exPoint 的 virtual table，exception object 的 vptr 不会被拷贝。</li>
</ul>
<p>当这个 exception 再一次被丢出时，p 将是一个 local object，在 catch 子句的末端被摧毁，且丧失了原来 exception 的 exVertex 部分。任何对 p 的修改都会被抛弃。</p>
<p>如下 catch 子句：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">catch</span>(exPoint&amp; rp) &#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">  <span class="keyword">throw</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>则是参考到真正的 exception object，且任何虚拟调用都会发生作用。任何对此 object 的改变都会被繁殖到下一个 catch 子句中。</p>
<p>最后，如果 throw 出一个 object：<code>throw errVer;</code>，是一个复制品被构造出来，全局的 errVer 并没有被繁殖。<strong>catch 语句中对于 exception object 的任何改变都是局部性的，不会影响 errVer</strong>。</p>
<h2 id="执行期类型识别（Runtime-Type-Identification，RTTI）"><a href="#执行期类型识别（Runtime-Type-Identification，RTTI）" class="headerlink" title="执行期类型识别（Runtime Type Identification，RTTI）"></a>执行期类型识别（Runtime Type Identification，RTTI）</h2><p>在cfront中，用以表现出一个程序的所谓“内部类型体系”，看起来像这样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 程序层次结构的根类（root class)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">node</span> &#123;</span> ... &#125;;</span><br><span class="line"><span class="comment">// root of the'type'subtree: basic types </span></span><br><span class="line"><span class="comment">// 'derived'types: pointers, arrays,</span></span><br><span class="line"><span class="comment">// functions, classes,enums</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">type</span>:</span> <span class="keyword">public</span> node &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//two representations for functions </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fct</span> :</span> <span class="keyword">public</span> type &#123; ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">gen</span> :</span> <span class="keyword">public</span> type &#123; ... &#125;;</span><br></pre></td></tr></table></figure></p>
<p>其中gen是generic的简写，用来表现一个overloaded function。</p>
<p>于是只要你有一个变量，或是类型为<code>type*</code>的成员（并知道它代表一个函数），你就必须决定其特定的derived type是否为fct或是gen。在2.0之前，除了destructor之外唯一不能够被overloaded的函数就是conversion运算符，例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>: </span><br><span class="line">  <span class="keyword">operator</span> <span class="keyword">char</span>*(); </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在2.0入const member functions之前，conversion运算符不能够被overloaded，因为它们不使用参数。直到引进了const member functions后，情况才有所变化。现在，像下面这样的声明就有可能了：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>: </span><br><span class="line">  <span class="comment">//ok with Release 2.0</span></span><br><span class="line">  <span class="keyword">operator</span> <span class="keyword">char</span>*(); </span><br><span class="line">  <span class="keyword">operator</span> <span class="keyword">char</span>*()<span class="keyword">const</span>; <span class="comment">// </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>也就是说，在2.0版之前，以一个explicit cast来存取derived object总是安全（而且比较快速）的，像下面这样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> type *ptype;</span><br><span class="line"><span class="keyword">typedef</span> fct *pfct;</span><br><span class="line"></span><br><span class="line">simplify_conv_op(ptype Pt) </span><br><span class="line">&#123; </span><br><span class="line">  <span class="comment">//ok: conversion operators can only be fcts </span></span><br><span class="line">  pfct pf = pfct(pt); </span><br><span class="line">  <span class="comment">// </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在const member functicns引入之前，这份码是正确的。请注意其中甚至有一个批注，说明这样的转型的安全。但是在const member functions引进之后，不论程序批注或程序代码都不对了。程序代码之所以失败，非常不幸是因为String class声明的改变．因为<code>char *</code> cnversion运算符现在被内部视为一个gen而不是一个fct。</p>
<p>下面这徉的转型形式：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pfct pf = pfct(pt);</span><br></pre></td></tr></table></figure></p>
<p>被称为downcast（向下转型），因为它有效地把一个base class转换至继承结构的末端，变成其derived classes中的某一个。downcast有潜在性的危险，因为它遏制了类型系统的作用，不正确的使用可能会带来错误的解释（如果它是一个read操作）或腐蚀掉程序内存（如果它是一个write操作）。在我们的例子中，一个指向gen object的指针被不正确地转型为一个指向fct object的指针pf。有后续对pf的使用都是不正确的（除非只是检查它是否为0，或只是把它拿来和其它指针作比较）。</p>
<h3 id="Type-Safe-Downcast（保证安全的向下转型操作）"><a href="#Type-Safe-Downcast（保证安全的向下转型操作）" class="headerlink" title="Type-Safe Downcast（保证安全的向下转型操作）"></a>Type-Safe Downcast（保证安全的向下转型操作）</h3><p>C++ 缺乏一个保证安全的 downcast（向下转型操作）。只有在“类型真的可以被适当转型”的情况下，才能执行 downcast。一个 type-safe downcast 必须在执行期对指针有所查询，看看它是否指向它所展现之 object 的真正类型，于是在 object 空间和执行时间上都需要一些额外负担：</p>
<ul>
<li>需要额外的空间以存储类型信息（type information），通常是一个指针，指向某个类型信息节点。</li>
<li>需要额外的时间以决定执行期的类型（runtime type），因为，正如其名所示，这需要在执行期才能决定。</li>
</ul>
<p>这样的机制面对下而这样平常的C结构，会如何影响其大小、效率、以及 链接兼容性呢？<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *winnie_tbl[] = &#123;<span class="string">"rumbly in my tummy"</span>, <span class="string">"oh, bother"</span>&#125;;</span><br></pre></td></tr></table></figure></p>
<p>很明显，它所导致的空间和效率上的不良报应甚为可观。</p>
<p>冲突发生在两组使用者之间； </p>
<ol>
<li>程序员大量使用多态（polymorphism），并因而需要正统而合法的大量downcast操作。</li>
<li>程序员使用内建数据类型以及非多态设备，因而不受各种额外负担所带来的报应。 </li>
</ol>
<p>理想的解决方案是，为两派使用者提供正统而合法的需要―虽然或许得牺牲一些设计上的纯度与优雅性。你知道要怎么做吗？</p>
<p>C++ 的 RTTI 机制提供一个安全的 downcast 设备，但只对那些展现“多态”的类型有效。如何分辨一个 class 是否展现多态？ RTTI 所采用的策略是<strong>经由声明一个或多个 virtual function 来区别 class 声明</strong>，优点是透明化地将旧有程序转换过来，只要重新编译就好，缺点则是可能会将一个其实并非必要的virtual function强迫导入继承体系的base class身上。在 C++ 中，一个具备多态性质的 class 正是内含继承而来（或直接声明）的 virtual functions。</p>
<p>从编译器角度看，这个策略还有其他优点，就是大量降低额外负担。所有多态类的 object 都维护了一个指针，指向 virtual function table。只要把与该 class 相关的 RTTI object 地址放进 virtual table 中（通常放在第一个 slot），那么额外负担就降低为：每个 class object 只多花费一个指针。这个指针只需要被设定一次，他是被编译器静态设定而不是在执行期由class constructor设定。</p>
<h3 id="Type-Safe-Dynamic-Cast（保证安全的动态转型）"><a href="#Type-Safe-Dynamic-Cast（保证安全的动态转型）" class="headerlink" title="Type-Safe Dynamic Cast（保证安全的动态转型）"></a>Type-Safe Dynamic Cast（保证安全的动态转型）</h3><p>dynamic_cast 运算符可以在执行期决定真正的类型。如果 downcast 是安全的（也就是 base type pointer 确实指向一个 derived class object），这个运算符会传回被适当转型过的指针。如果 downcast 不安全，则会传回 0。</p>
<p><code>type_info</code>是 C++ 所定义的类型描述器的 class 名称，该 class 中放置着待索求的类型信息。virtual table 的第一个 slot 内含 type_info object 的地址。此type_info object与pt所指之class type有关。这两个类型描述器被交给一个runtime library函数，比较之后告诉我们是否吻合。很显然这比static cast昂贵得多，但却安全得多（如果我们把一个fct类型 “downcast”为一个gen类型的话）。</p>
<p>最初对runtime cast的支持提议中，并未引进任何关键词或额外的语法。下面这样的转型操作：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最初对runtime cast的提议语法</span></span><br><span class="line">pfct pf = pfct(pt);</span><br></pre></td></tr></table></figure></p>
<p>究竟是static还是dynamic，必须视pt是否指向一个多态class object而定。</p>
<h3 id="Reference-并不是-Pointers"><a href="#Reference-并不是-Pointers" class="headerlink" title="Reference 并不是 Pointers"></a>Reference 并不是 Pointers</h3><p>对指针类型实施<code>dynamic_cast</code>运算符，会获得 true 或 false：</p>
<ul>
<li>如果传回真正的地址，表示这个 object 的动态类型被确认了，一些与类型有关的操作现在可以施行于其上。</li>
<li>如果传回 0，表示没有指向任何 object，意味着应该以另一种逻辑施行于这个动态类型未确定的 object 身上。</li>
</ul>
<p><code>dynamic_cast</code>运算符也适用于reference身上。然而对于一个non-type-safe-cast，其结果不会与施行于指针的情况相同．为什么？一个reference不可以像指针那样“把自己设为0便代表了”no object”；若将一个reference设为0，会引起一个临时性对象（拥有被参考到的类型）被产生出来，该临时对象的初值为 0，这个reference然后被设定成为该临时对象的一个别名（alias)。但如果对 reference 实施 dynamic_cast 运算符：</p>
<ul>
<li>如果 reference 真正参考到适当的 derived class，downcast 会被执行而程序可以继续进行。</li>
<li>如果 reference 并不真正是某一种 derived class，那么，由于不能够传回 0，遂丢出一个 bad_cast exception。</li>
</ul>
<h3 id="Typeid-运算符"><a href="#Typeid-运算符" class="headerlink" title="Typeid 运算符"></a>Typeid 运算符</h3><p>使用<code>typeid</code>运算符，就可能以一个 reference 达到相同的执行期替代路线：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">simplify_conv_op(<span class="keyword">const</span> type &amp;rt) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeid</span>(rt) == <span class="keyword">typeid</span>(fct)) &#123;</span><br><span class="line">    fct &amp;rf = <span class="keyword">static_cast</span>&lt;fct &amp;&gt;(rt);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>typeid</code>运算符传回一个 const reference，类型为<code>type_info</code>。在先前测试的equality于是暖夫其实是一个被overloaded的函数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> type_info::<span class="keyword">operator</span> == ( <span class="keyword">const</span> type_info &amp;) <span class="keyword">const</span>;</span><br></pre></td></tr></table></figure></p>
<p>如果两个 type_info objects 相等，这个 equality 运算符就传回 true。</p>
<p>type_info object由什么组成？C++ Standard (Section 18.5.1）中对<code>type_info</code>的定义如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">type_info</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~type_info();</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> type_info&amp;) <span class="keyword">const</span>; </span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> type_info&amp;) <span class="keyword">const</span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">before</span><span class="params">(<span class="keyword">const</span> type_info&amp;)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">// 译注：传回class原始名称 </span></span><br><span class="line">  <span class="keyword">private</span>: </span><br><span class="line"><span class="comment">//prevent memberwise init and copy</span></span><br><span class="line">  type_info( <span class="keyword">const</span> type_info&amp;);</span><br><span class="line">  type_info&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> type info&amp;); </span><br><span class="line"><span class="comment">//data members </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>编译器必须提供的最小量信息是class的真实名称、以及在type_info objects 之间的某些排序算法（这就是before()函数的目的）、以及某些形式的描述器，用来表现explicit class type和这个class的任何subtypes。在描述exception handling 字符串的原始文章中，曾建议实现出一种描述器：编码后的字符串。</p>
<p>虽然RTTI提供的<code>type_info</code>对于exception handling的支持来说是必要的，但对于exception handling的完整支持而言，还不够。如果再加上额外的一些 type_info derived classes，就可以在exception发生时提供有关于指针、函数及类等等的更详细信息。例如MetaWare就定义了以下的额外类：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pointer_type_info</span> :</span> <span class="keyword">public</span> type_info &#123; ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Member_pointer_info</span> :</span> <span class="keyword">public</span> type_info &#123; ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Modified_type_info</span> :</span> <span class="keyword">public</span> type_info &#123; ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Array_type_info</span> :</span> <span class="keyword">public</span> type_info &#123; ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Func_type_info</span> :</span> <span class="keyword">public</span> type_info &#123; ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Class_type_info</span> :</span> <span class="keyword">public</span> type info &#123; ... &#125;;</span><br><span class="line">``` </span><br><span class="line">并允许使用者取用它们。不幸的是，那些derived classes的大小以及命名习惯都没有标准。</span><br><span class="line"></span><br><span class="line">type_info objects 也适用于内建类型，以及非多态的使用者自定类型，这对于exception handling的支持有必要，例如：</span><br><span class="line">```C++</span><br><span class="line"><span class="keyword">int</span> ex_errno;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">throw</span> ex_errno;</span><br></pre></td></tr></table></figure></p>
<p>其中int类型也有其自己的type_info object：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *ptr;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeid</span>(ptr) == <span class="keyword">typeid</span>(<span class="keyword">int</span>*))</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure></p>
<p>在程序中使用<code>typeid(expression)</code>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ival;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">typeid</span>(ival) ...;</span><br></pre></td></tr></table></figure></p>
<p>或是使用<code>typeid(type)</code>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeid</span>(<span class="keyword">double</span>) ...;</span><br></pre></td></tr></table></figure></p>
<p>这会传回一个<code>const type_info&amp;</code>，这时候的 type_info object 是静态取得，而非执行期取得。一般的实现策略是在需要时才产生 type_info object，而非程序一开头就产生。</p>
<h2 id="效率有了，弹性呢"><a href="#效率有了，弹性呢" class="headerlink" title="效率有了，弹性呢"></a>效率有了，弹性呢</h2><h3 id="动态共享库（Dynamic-Shared-Libraries）"><a href="#动态共享库（Dynamic-Shared-Libraries）" class="headerlink" title="动态共享库（Dynamic Shared Libraries）"></a>动态共享库（Dynamic Shared Libraries）</h3><p>理想中，一个动态链接的 shared library 应该会透明化的取用新的 library 版本。新的 library 问世不应该对旧的应用程序产生侵略性，应用程序不应该需要为此重新 build 一次。然而目前 C++ 对象模型中，class 的大小及其每个直接（或继承而来）的 members 的偏移量（offset）都在编译时期固定（虚拟继承的 members 除外）。这虽然带来效率，却在二进制层面影响了弹性。如果 object 布局改变，就得重新编译。</p>
<h3 id="共享内存（Shared-Memory）"><a href="#共享内存（Shared-Memory）" class="headerlink" title="共享内存（Shared Memory）"></a>共享内存（Shared Memory）</h3><p>当一个 shared library 被加载，它在内存中的位置由 runtime linker 决定，一般而言与执行中的行程（process）无关。然而在 C++ 对象模型中，当一个动态的 shared library 支持一个 class object，其中含有 virtual function（被放在 shared memory 中），上述说法便不正确。</p>
<p>问题在于“想要经由这个 shared object 附着并调用一个 virtual function”的第二个或更后继的行程（我感觉这里可能想表达的是“进程”而非“行程”）。除非 dynamic shared library 被放置于完全相同的内存位置上，就像当初加载这个 shared object 的行程一样，否则 virtual function 会死的很难看，可能的错误包含 segment fault 或 bus error。</p>
<p>病灶出在每个 virtual function 在 virtual table 中的位置已经被写死了。目前的解决办法属于程序层面，程序员必须保证让跨越行程的 shared libraries 有相同的坐落地址（在 SGI 中，使用者可以指定每个 shared library 的精确位置）。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/C/" rel="tag"># C++</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/11/26/Perf简介/" rel="next" title="Perf简介">
                <i class="fa fa-chevron-left"></i> Perf简介
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/12/11/STL源码剖析 笔记1/" rel="prev" title="STL 源码剖析 笔记1">
                STL 源码剖析 笔记1 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/header.jpg" alt="Hao Yu">
            
              <p class="site-author-name" itemprop="name">Hao Yu</p>
              <p class="site-description motion-element" itemprop="description">Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author</p>
          </div>
          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">303</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>
        	<audio controls="controls" loop="loop" preload="auto" src="/resource/xiaomeihao.mp3">
	        </audio>
	

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yuhao0102" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:yuh18@mails.tsinghua.edu.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#构造、解构、拷贝语义学（Semantics-of-Construction-Destruction-and-Copy）"><span class="nav-number">1.</span> <span class="nav-text">构造、解构、拷贝语义学（Semantics of Construction, Destruction, and Copy）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#纯虚函数的存在（Presence-of-a-Pure-Virtual-Function）"><span class="nav-number">1.1.</span> <span class="nav-text">纯虚函数的存在（Presence of a Pure Virtual Function）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#虚拟规格的存在（Presence-of-a-Virtual-Specification）"><span class="nav-number">1.1.1.</span> <span class="nav-text">虚拟规格的存在（Presence of a Virtual Specification）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#虚拟规格中-const-的存在"><span class="nav-number">1.1.2.</span> <span class="nav-text">虚拟规格中 const 的存在</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重新考虑-class-的声明"><span class="nav-number">1.1.3.</span> <span class="nav-text">重新考虑 class 的声明</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#“无继承”情况下的对象构造"><span class="nav-number">1.2.</span> <span class="nav-text">“无继承”情况下的对象构造</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#抽象数据类型（Abstract-Data-Type）"><span class="nav-number">1.2.1.</span> <span class="nav-text">抽象数据类型（Abstract Data Type）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#为继承做准备"><span class="nav-number">1.2.2.</span> <span class="nav-text">为继承做准备</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#继承体系下的对象构造"><span class="nav-number">1.3.</span> <span class="nav-text">继承体系下的对象构造</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#虚拟继承（Virtual-Inheritance）"><span class="nav-number">1.3.1.</span> <span class="nav-text">虚拟继承（Virtual Inheritance）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#vptr-初始化语义学（The-Semantics-of-the-vptr-Initialization）"><span class="nav-number">1.3.2.</span> <span class="nav-text">vptr 初始化语义学（The Semantics of the vptr Initialization）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对象复制语义学（Object-Copy-Semantics）"><span class="nav-number">1.4.</span> <span class="nav-text">对象复制语义学（Object Copy Semantics）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对象的功能（Object-Efficiency）"><span class="nav-number">1.5.</span> <span class="nav-text">对象的功能（Object Efficiency）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解构语义学（Semantics-of-Destruction）"><span class="nav-number">1.6.</span> <span class="nav-text">解构语义学（Semantics of Destruction）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第六章-执行期语义学（Runtime-Semantics）"><span class="nav-number">2.</span> <span class="nav-text">第六章 执行期语义学（Runtime Semantics）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#对象的构造和解构（Object-Construction-and-Destruction）"><span class="nav-number">2.1.</span> <span class="nav-text">对象的构造和解构（Object Construction and Destruction）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#全局对象（Global-Objects）"><span class="nav-number">2.1.1.</span> <span class="nav-text">全局对象（Global Objects）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#局部静态对象（Local-Static-Objects）"><span class="nav-number">2.1.2.</span> <span class="nav-text">局部静态对象（Local Static Objects）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对象数组（Array-of-Object）"><span class="nav-number">2.1.3.</span> <span class="nav-text">对象数组（Array of Object）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Default-Constructors和数组"><span class="nav-number">2.1.4.</span> <span class="nav-text">Default Constructors和数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#针对数组的-new-语义"><span class="nav-number">2.1.5.</span> <span class="nav-text">针对数组的 new 语义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Placement-Operator-new-的语义"><span class="nav-number">2.1.6.</span> <span class="nav-text">Placement Operator new 的语义</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#临时性对象（Temporary-Objects）"><span class="nav-number">2.2.</span> <span class="nav-text">临时性对象（Temporary Objects）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#临时性对象的迷思（神话、传说）"><span class="nav-number">2.2.1.</span> <span class="nav-text">临时性对象的迷思（神话、传说）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第七章-站在对象模型的尖端（On-the-Cusp-of-the-Object-Model）"><span class="nav-number">3.</span> <span class="nav-text">第七章 站在对象模型的尖端（On the Cusp of the Object Model）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#template"><span class="nav-number">3.1.</span> <span class="nav-text">template</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Template-的“具现”行为（Template-Instantiation）"><span class="nav-number">3.1.1.</span> <span class="nav-text">Template 的“具现”行为（Template Instantiation）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Template-的错误报告（Error-Reporting-within-a-Template）"><span class="nav-number">3.1.2.</span> <span class="nav-text">Template 的错误报告（Error Reporting within a Template）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Template-中的名称决议方式（Name-Resolution-within-a-Template）"><span class="nav-number">3.1.3.</span> <span class="nav-text">Template 中的名称决议方式（Name Resolution within a Template）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Member-Function-的具现行为（Member-Function-Instantiation）"><span class="nav-number">3.1.4.</span> <span class="nav-text">Member Function 的具现行为（Member Function Instantiation）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#异常处理（Exception-Handling）"><span class="nav-number">3.2.</span> <span class="nav-text">异常处理（Exception Handling）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Exception-Handling-快速检阅"><span class="nav-number">3.2.1.</span> <span class="nav-text">Exception Handling 快速检阅</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对-Exception-Handling-的支持"><span class="nav-number">3.2.2.</span> <span class="nav-text">对 Exception Handling 的支持</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#将exception的类型和每一个catch子句的类型做比较"><span class="nav-number">3.2.2.1.</span> <span class="nav-text">将exception的类型和每一个catch子句的类型做比较</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#当一个实际对象在程序执行时被丢出，会发生什么事"><span class="nav-number">3.2.2.2.</span> <span class="nav-text">当一个实际对象在程序执行时被丢出，会发生什么事</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#执行期类型识别（Runtime-Type-Identification，RTTI）"><span class="nav-number">3.3.</span> <span class="nav-text">执行期类型识别（Runtime Type Identification，RTTI）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Type-Safe-Downcast（保证安全的向下转型操作）"><span class="nav-number">3.3.1.</span> <span class="nav-text">Type-Safe Downcast（保证安全的向下转型操作）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Type-Safe-Dynamic-Cast（保证安全的动态转型）"><span class="nav-number">3.3.2.</span> <span class="nav-text">Type-Safe Dynamic Cast（保证安全的动态转型）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Reference-并不是-Pointers"><span class="nav-number">3.3.3.</span> <span class="nav-text">Reference 并不是 Pointers</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Typeid-运算符"><span class="nav-number">3.3.4.</span> <span class="nav-text">Typeid 运算符</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#效率有了，弹性呢"><span class="nav-number">3.4.</span> <span class="nav-text">效率有了，弹性呢</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#动态共享库（Dynamic-Shared-Libraries）"><span class="nav-number">3.4.1.</span> <span class="nav-text">动态共享库（Dynamic Shared Libraries）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#共享内存（Shared-Memory）"><span class="nav-number">3.4.2.</span> <span class="nav-text">共享内存（Shared Memory）</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>
  <div id="DvelopmentTarget">     
  </div>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart" aria-hidden="false"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>

  
</div>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_uv"> 
  本站访客数<span id="busuanzi_value_site_uv"></span>人次
</span>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  


  <script type="text/javascript" src="/js/src/love.js"></script>

</body>
</html>
