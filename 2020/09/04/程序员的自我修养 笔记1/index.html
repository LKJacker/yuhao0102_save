<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zn-ch">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-center-simple.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="积累,">










<meta name="description" content="温故而知新1.1 从Hello World说起 12345#include &amp;lt;studio.h&amp;gt;int main() &amp;#123;    printf(&quot;Hello World\n&quot;);    return 0;&amp;#125;  1.2 万变不离其宗 计算机中三个关键的部件:中央处理器CPU,内存和I/O控制芯片  早期CPU和内存频率较低，且频率一样，它们连在一个总线(Bus)上。但其">
<meta name="keywords" content="积累">
<meta property="og:type" content="article">
<meta property="og:title" content="程序员的自我修养笔记1">
<meta property="og:url" content="http://yoursite.com/2020/09/04/程序员的自我修养 笔记1/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="温故而知新1.1 从Hello World说起 12345#include &amp;lt;studio.h&amp;gt;int main() &amp;#123;    printf(&quot;Hello World\n&quot;);    return 0;&amp;#125;  1.2 万变不离其宗 计算机中三个关键的部件:中央处理器CPU,内存和I/O控制芯片  早期CPU和内存频率较低，且频率一样，它们连在一个总线(Bus)上。但其">
<meta property="og:locale" content="zn-ch">
<meta property="og:image" content="http://yoursite.com/img/1-HelloWorld.png">
<meta property="og:image" content="http://yoursite.com/img/1-早期的计算机结构.png">
<meta property="og:image" content="http://yoursite.com/img/1-南北桥结构.png">
<meta property="og:image" content="http://yoursite.com/img/1-软件体系.png">
<meta property="og:image" content="http://yoursite.com/img/1-段地址空间映射.png">
<meta property="og:image" content="http://yoursite.com/img/1-页的映射关系.png">
<meta property="og:image" content="http://yoursite.com/img/1-虚拟地址到物理地址的转换.png">
<meta property="og:image" content="http://yoursite.com/img/1-进程和线程关系.png">
<meta property="og:image" content="http://yoursite.com/img/1-线程私有和共享数据.png">
<meta property="og:image" content="http://yoursite.com/img/1-线程状态切换.png">
<meta property="og:image" content="http://yoursite.com/img/1-读写锁.png">
<meta property="og:image" content="http://yoursite.com/img/1-多对一线程模型.png">
<meta property="og:image" content="http://yoursite.com/img/1-多对多的线程模型.png">
<meta property="og:image" content="http://yoursite.com/img/2-gcc编译过程.png">
<meta property="og:image" content="http://yoursite.com/img/2-编译过程.png">
<meta property="og:image" content="http://yoursite.com/img/2-词法分析1.png">
<meta property="og:image" content="http://yoursite.com/img/2-词法分析2.png">
<meta property="og:image" content="http://yoursite.com/img/2-语法树.png">
<meta property="og:image" content="http://yoursite.com/img/2-标识语义后的语法树.png">
<meta property="og:image" content="http://yoursite.com/img/2-优化后的语法树.png">
<meta property="og:image" content="http://yoursite.com/img/2-模块间的拼合.png">
<meta property="og:image" content="http://yoursite.com/img/2-链接过程.png">
<meta property="og:image" content="http://yoursite.com/img/2-传送指令.png">
<meta property="og:image" content="http://yoursite.com/img/2-ELF文件类型1.png">
<meta property="og:image" content="http://yoursite.com/img/2-ELF文件类型2.png">
<meta property="og:image" content="http://yoursite.com/img/2-简单目标文件结构.png">
<meta property="og:image" content="http://yoursite.com/img/3-Simplesection目标文件结构.png">
<meta property="og:image" content="http://yoursite.com/img/3-Simplesection段结构.png">
<meta property="og:image" content="http://yoursite.com/img/3-Simplesection目标文件的十六进制和汇编表示.png">
<meta property="og:image" content="http://yoursite.com/img/3-Simplesection中字符串常量的存放.png">
<meta property="og:image" content="http://yoursite.com/img/3-Simplesection目标文件的bss段.png">
<meta property="og:image" content="http://yoursite.com/img/3-目标文件其他段.png">
<meta property="og:image" content="http://yoursite.com/img/3-ELF结构.png">
<meta property="og:image" content="http://yoursite.com/img/3-ELF文件头1.png">
<meta property="og:image" content="http://yoursite.com/img/3-ELF文件头2.png">
<meta property="og:image" content="http://yoursite.com/img/3-ELF变量体系.png">
<meta property="og:image" content="http://yoursite.com/img/3-ELF头文件成员的含义1.png">
<meta property="og:image" content="http://yoursite.com/img/3-ELF头文件成员的含义2.png">
<meta property="og:image" content="http://yoursite.com/img/3-ELF文件类型常量.png">
<meta property="og:image" content="http://yoursite.com/img/3-ELF文件的机器类型.png">
<meta property="og:image" content="http://yoursite.com/img/3-ELF真正的段表结构.png">
<meta property="og:image" content="http://yoursite.com/img/3-段的字段的含义.png">
<meta property="og:image" content="http://yoursite.com/img/3-SimpleSection.o的SectionTable及所有段的位置和长度.png">
<meta property="og:image" content="http://yoursite.com/img/3-段类型1.png">
<meta property="og:image" content="http://yoursite.com/img/3-段类型2.png">
<meta property="og:image" content="http://yoursite.com/img/3-段的标志位.png">
<meta property="og:image" content="http://yoursite.com/img/3-系统保留段的属性1.png">
<meta property="og:image" content="http://yoursite.com/img/3-系统保留段的属性2.png">
<meta property="og:image" content="http://yoursite.com/img/3-段的链接信息.png">
<meta property="og:image" content="http://yoursite.com/img/3-字符串表.png">
<meta property="og:image" content="http://yoursite.com/img/3-Elf32_Sym结构.png">
<meta property="og:image" content="http://yoursite.com/img/3-Elf32_Sym结构_符号类型.png">
<meta property="og:image" content="http://yoursite.com/img/3-Elf32_Sym结构_符号绑定.png">
<meta property="og:image" content="http://yoursite.com/img/3-Elf32_Sym结构_符号所在段.png">
<meta property="og:image" content="http://yoursite.com/img/3-Elf32_Sym结构_值1.png">
<meta property="og:image" content="http://yoursite.com/img/3-Elf32_Sym结构_值2.png">
<meta property="og:image" content="http://yoursite.com/img/3-符号表详情.png">
<meta property="og:image" content="http://yoursite.com/img/3-ELF真正的段表结构.png">
<meta property="og:image" content="http://yoursite.com/img/3-链接过程中的特殊符号.png">
<meta property="og:updated_time" content="2020-09-05T07:24:30.222Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="程序员的自我修养笔记1">
<meta name="twitter:description" content="温故而知新1.1 从Hello World说起 12345#include &amp;lt;studio.h&amp;gt;int main() &amp;#123;    printf(&quot;Hello World\n&quot;);    return 0;&amp;#125;  1.2 万变不离其宗 计算机中三个关键的部件:中央处理器CPU,内存和I/O控制芯片  早期CPU和内存频率较低，且频率一样，它们连在一个总线(Bus)上。但其">
<meta name="twitter:image" content="http://yoursite.com/img/1-HelloWorld.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/09/04/程序员的自我修养 笔记1/">





  <title>程序员的自我修养笔记1 | Hao Yu's blog</title>
  








 
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zn-ch">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hao Yu's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">The program monkey was eaten by the siege lion.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-mybetterhalf">
          <a href="/mybetterhalf/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>
            
            mybetterhalf
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="Searching..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/04/程序员的自我修养 笔记1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">程序员的自我修养笔记1</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-09-04T21:09:04+08:00">
                2020-09-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="温故而知新"><a href="#温故而知新" class="headerlink" title="温故而知新"></a>温故而知新</h2><h3 id="1-1-从Hello-World说起"><a href="#1-1-从Hello-World说起" class="headerlink" title="1.1 从Hello World说起"></a>1.1 从Hello World说起</h3> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;studio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello World\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/img/1-HelloWorld.png" alt></p>
<h3 id="1-2-万变不离其宗"><a href="#1-2-万变不离其宗" class="headerlink" title="1.2 万变不离其宗"></a>1.2 万变不离其宗</h3><ol>
<li><p>计算机中三个关键的部件:中央处理器CPU,内存和I/O控制芯片</p>
</li>
<li><p>早期CPU和内存频率较低，且频率一样，它们连在一个总线(Bus)上。但其他I/O设备比CPU和内存速度要慢，所以为了协调I/O设备和总线之间的速度，所以每个I/O设备都有一个相应的I/O控制器</p>
<p><img src="/img/1-早期的计算机结构.png" alt></p>
</li>
<li><p>随着CPU的提升,以及内存和硬件的发展。出现了北桥(Northbridge, PCI Bridge)，其运算速度非常高。用于连接高速设备。南桥(Southbridge, ISA Bridge)用于连接低速设备(磁盘，USB等)。高速设备采用PCI总线，低速设备采用ISA总线，然后在通过南北桥连接。</p>
<p><img src="/img/1-南北桥结构.png" alt></p>
</li>
<li><p>PCI最高级为133MHZ，还是不能满足人们需求，于是又发明了AGP,PCI Express等诸多总线结构和相应的控制芯片。虽然结构越来越复杂，但我们先可以简单的将其按最初的模型进行理解</p>
</li>
</ol>
<h4 id="SMP与多核"><a href="#SMP与多核" class="headerlink" title="SMP与多核"></a>SMP与多核</h4><ol>
<li>SMP: 对称多处理器( Symmetrical Muti-Processing)，也就是多个CPU。<ul>
<li>理论上速度的提高和cpu的数量成正比，但是程序的任务之间是有依赖关系的。就如一个女人花10个月生一个孩子，但是10个女人不能一个月生一个孩子</li>
<li>多处理器用来处理不相干的任务的时候，效果比较显著</li>
</ul>
</li>
<li>多核:多核处理器(Muti-core processing)。一个处理器上有多个核心，这样成本减少了。可以简单的将多核处理器理解为和SMP功能几乎一样。但是成本更低。</li>
</ol>
<h3 id="1-3-站得高，望的远"><a href="#1-3-站得高，望的远" class="headerlink" title="1.3 站得高，望的远"></a>1.3 站得高，望的远</h3><ol>
<li><p>系统软件一般分为两个部分</p>
<ul>
<li>平台性的:操作系统内核，驱动程序，运行库和系统工具。</li>
<li>程序开发的: 编译器,汇编器,链接器等开发工具和开发库。(重点)</li>
</ul>
</li>
<li><p>计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决。</p>
</li>
<li><p>系统软件体系结构中，各种软件的位置。</p>
<p><img src="/img/1-软件体系.png" alt></p>
</li>
<li><p>各层次之间用API接口进行通信。API由下层定义和实现，由上层来使用。上次并不关心下层的实现细节。只要下层遵循定义好的API，那么下层可以随意被替换。</p>
</li>
</ol>
<p>上层应用通过 Operating System API来访问运行时库。运行时库通过系统调用接口(system call interface)来访问系统内核，系统调用接口在实现上往往以软件终端的方式提供操作系统内核通过硬件规格(hardware specification)来操作硬件，硬件规格由硬件厂商负责提供。</p>
<h3 id="1-4-操作系统做什么"><a href="#1-4-操作系统做什么" class="headerlink" title="1.4 操作系统做什么"></a>1.4 操作系统做什么</h3><ol>
<li>提供抽象的接口</li>
<li>管理硬件资源</li>
</ol>
<h4 id="1-4-1-不要让CPU打盹"><a href="#1-4-1-不要让CPU打盹" class="headerlink" title="1.4.1 不要让CPU打盹"></a>1.4.1 不要让CPU打盹</h4><ol>
<li>早期, 为了不让CPU空闲下来，编写了一个监控程序,当进行磁盘读写操作等IO操作的时候。此时CPU空闲，将CPU交给另外等待的程序，使CPU能够充分利用起来，这种方法调度策略虽然粗糙但也提高了CPU的利用率，叫做<code>多道程序(mutiprogramming)</code>。</li>
<li>接着，改进成协作模式，即为每个程序运行一段时间后主动让出CPU给其他程序，使的一段时间内每个程序都有机会运行一小段时间。这种方式叫做<code>分时系统(Time-Sharing System)</code>。但任何一个程序死循环都会造成CPU无法被释放，系统死机。</li>
<li>现在，操作系统接管了所有的硬件资源，并且本身运行在一个受硬件保护的级别。所有的应用程序都以进程的方式运行在比操作系统权限更低的级别，每个进程都有自己独立的地址空间。使进程之间的地址空间相互隔离。CPU由操作系统统一进行分配。每个进程根据优先级的高低都有机会得到CPU,但是如果运行超出一定的时间，操作系统会暂停该进程，将CPU资源分配给其他等待运行的进程。这种CPU分配方式即所谓的抢占式(preemptive).操作系统可以强行剥夺CPU资源并且分配给它认为目前最需要的进程。这就是现在的<code>多任务(Muti-tasking)系统</code></li>
</ol>
<h4 id="1-4-2-设备驱动"><a href="#1-4-2-设备驱动" class="headerlink" title="1.4.2 设备驱动"></a>1.4.2 设备驱动</h4><ul>
<li>操作系统是硬件层的上层，它是对硬件的管理和抽象。</li>
<li>在 Windows系统中,<code>图形硬件</code>被抽象成了<code>GDI</code>,<code>声音和多媒体设备</code>被抽象成了 <code>DirectX对象</code>;<code>磁盘</code>被抽象成了<code>普通文件系统</code></li>
<li>繁琐的硬件细节全都交给了操作系统,具体地讲是操作系统中的硬件驱动( Device Driver)程序来完成。</li>
<li>驱动程序可以看作是操作系统的一部分,它往往跟操作系统内核一起<code>运行在特权级</code>,但它又与操作系统内核之间有一定的独立性,使得驱动程序有比较好的灵活性</li>
<li>硬盘结构:<ul>
<li>有多个盘片,每个盘片分两面,每面按照同心圆划分为若干个磁道,每个磁道划分为若干个扇区。</li>
<li>比如一个硬盘有2个盘片,每个盘面分65536磁道,每个磁道分1024个扇区,那么硬盘的容量就是2·2“65536“1024*512 = 137438953472字节(128GB但是我们可以想象,每个盘面上同心圆的周长不一样,如果按照每个磁道都拥有相同数量的扇区,那么靠近盘面外围的磁道密度肯定比内圈更加稀疏,这样是比较浪费空间的。但是如果不同的磁道扇区数又不同,计算起来就十分麻烦。</li>
<li>为了屏蔽这些复杂的硬件细节,现代的硬盘普遍使用一种叫做LBA( Logical Block Address)的方式,即整个硬盘中所有的扇区从0开始编号,一直到最后一个扇区,这个扇区编号叫做逻辑扇区号</li>
<li>逻辑扇区号抛弃了所有复杂的磁道、盘面之类的概念。当我们给出一个逻辑的扇区号时,硬盘的电子设备会将其转换成实际的盘面、磁道等这些位置</li>
</ul>
</li>
</ul>
<h3 id="1-5-内存不够怎么办"><a href="#1-5-内存不够怎么办" class="headerlink" title="1.5 内存不够怎么办"></a>1.5 内存不够怎么办</h3><ul>
<li>在早期的计算机中,程序是直接运行在物理内存上的,也就是说,程序在运行时所访问的地址都是物理地址。</li>
<li>直接运行在物理内存中存在问题<ul>
<li>地址空间不隔离:地址容易被恶意修改。所有程序都直接访问物理地址,程序所使用的内存空间不是相互隔离的恶意的程序可以很容易改写其他程序的内存数据,以达到破坏的目的;有些非恶意的、但是有bug的程序可能不小心修改了其他程序的数据,就会使其他程序也崩溃</li>
<li>内存使用效率低:程序间切换开销太大。由于没有有效的内存管理机制,通常需要一个程序执行时,监控程序就将整个程序装入内存中然后开始执行。如果我们忽然需要运行程序C,那么这时内存空间其实已经不够了,这时候我们可以用的一个办法是将其他程序的数据暂时写到磁盘里面,等到需要用到的时候再读回来。由于程序所需要的空间是连续的,那么这个例子里中,如果我们将程序A换出到磁盘所释放的内存空间是不够的,所以只能将B换出到磁盘,然后将C读入到内存开始运行。可以看到整个过程中有大量的数据在换入换出,导致效率十分低下</li>
<li>程序运行的地址不确定。因为程序每次需要装入运行时,我们都需要给它从内存中分配一块足够大的空闲区域,这个空闲区域的位置是不确定的。这给程序的编写造成了一定的麻烦,因为程序在编写时,它访问数据和指令跳转时的目标地址很多都是固定的,这涉及程序的重定位问题</li>
</ul>
</li>
</ul>
<p>解决方案:<strong>增加中间层</strong>,即使用一种<code>间接的地址访问方法</code>。把程序给出的地址看作是一种虚拟地址( Virtual Address),然后通过某些映射的方法,将这个虚拟地址转换成实际的物理地址。这样,只要我们能够妥善地控制这个虚拟地址到物理地址的映射过程,就可以保证任意一个程序所能够访问的物理内存区域跟另外个程序相互不重叠,以达到地址空间隔离的效果。</p>
<h4 id="1-5-1-关于隔离"><a href="#1-5-1-关于隔离" class="headerlink" title="1.5.1 关于隔离"></a>1.5.1 关于隔离</h4><p>地址空间是个比较抽象的概念,你可以把它想象成一个很大的数组,每个数组的元素是一个字节,而这个数组大小由地址空间的地址长度决定。32位的地址空间的大小为2^32=4294967296字节,即4GB,地址空间有效的地址是0~4294967295,用十六进制表示就是0x00000000~0xFFFFFFFF</p>
<p>地址空间分两种:</p>
<ul>
<li>物理地址空间( Physical Address Space)<ul>
<li>物理地址空间是实实在在存在的,存在于计算机中,而且对于每一台计算机来说只有唯一的个,你可以把物理空间想象成物理内存,比如你的计算机用的是 Intel的 Pentium4的处理器,那么它是32位的机器,即计算机地址线有32条(实际上是36条地址线,不过我们暂时认为它只是32条),那么物理空间就有4GB。但是你的计算机上只装了512MB的内存,那么其实物理地址的真正有效部分只有0x0000000~0x1FFFFFFF,其他部分都是无效的(实际上还有一些外部IO设备映射到物理空间的,也是有效的,但是我们暂时无视其存在)</li>
</ul>
</li>
<li>虚拟地址空间(Ⅴirtual Address Space)<ul>
<li>人们想象出来的地址空间,其实它并不存在,每个进程都有自己独立的虚拟空间,而且每个进程只能访问自己的地址空间,这样就有效地做到了进程的隔离</li>
</ul>
</li>
</ul>
<h4 id="1-5-2-分段-Segmentation"><a href="#1-5-2-分段-Segmentation" class="headerlink" title="1.5.2  分段( Segmentation)"></a>1.5.2  分段( Segmentation)</h4><p>最开始人们使用的是一种叫做分段( Segmentation)的方法,基本思路是把一段与程序所需要的内存空间大小的虚拟空间映射到某个地址空间。各程序都有自己的虚拟地址空间，当程序加载到内存中，访问自己的地址时，操作系统通过CPU将虚拟地址转换为实际的物理地址。<br><img src="/img/1-段地址空间映射.png" alt></p>
<p>分段机制基本解决了上面提到”地址空间不隔离”和”程序运行的地址不确”的问题。</p>
<ul>
<li>首先它做到了地址隔离，因为程序A和程序B被映射到了两块不同的物理空间区域,它们之间没有任何重叠如果程序A访问虚拟空间的地址超出了0x00A0这个范围,那么硬件就会判断这是一个非法的访问,拒绝这个地址请求,并将这个请求报告给操作系统或监控程序,由它来决定如何处理</li>
<li>再者,对于每个程序来说,无论它们被分配到物理地址的哪一个区域,对于程序来说都是透明的,它们不需要关心物理地址的变化,它们只需要按照从地址0x000000到0x00A0000编写程序、放置变量,所以程序不再需要重定位。</li>
</ul>
<p>但还没有解决内存使用率的问题</p>
<ol>
<li>分段对内存区域的映射还是按照程序为单位,如果内存不足,被换入换出到磁盘的都是整个程序,这样势必会造成大量的磁盘访问操作,从而严重影响速度,这种方法还是显得粗糙,粒度比较大</li>
<li>根据程序的局部性原理,当一个程序在运行时,在某个时间段内,它只是频繁地用到了一小部分数据,也就是说,程序的很多数据其实在一个时间段内都是不会被用到的。人们很自然地想到了更小粒度的内存分割和映射的方法,使得程序的局部性原理得到充分的利用,大大提高了内存的使用率。这种方法就是分页(Paging)</li>
</ol>
<h4 id="1-5-3-分页-Paging"><a href="#1-5-3-分页-Paging" class="headerlink" title="1.5.3 分页( Paging)"></a>1.5.3 分页( Paging)</h4><p>每一页的大小由硬件决定。如果硬件支持多种页，那么由操作系统选择决定页的大小， 同一时刻只能选择一种大小。目前几乎所有的PC上的操作系统都使用4KB大小的页。我们使用的PC机是32位的虚拟地址空间,也就是4GB,那么按4KB每页分的话,总共有1048576个页。在进程中，我们把进程的虚拟地址空间按页分割,把常用的数据和代码页装载到内存中把不常用的代码和数据保存在磁盘里,当需要用到的时候再把它从磁盘里取出来即可</p>
<p>页的映射关系:<br><img src="/img/1-页的映射关系.png" alt></p>
<ul>
<li>虚拟空间的页就叫虚拟页(VP, Virtual Page)</li>
<li>物理内存中的页叫做物理页(PP, Physical Page)</li>
<li>磁盘中的页叫做磁盘页(DP, Disk Page)</li>
<li>VP0,VP1，VP7映射到物理内存页面</li>
<li>两个进程的VP7都映射到同一个PP3，则实现了内存共享</li>
<li>VP4、VP5和VP6可能尚未被用到或访问到,它们暂时处于未使用的状态</li>
<li>有部分页面却在磁盘中比如VP2和VP3位于磁盘的DP0和DP1中</li>
<li>Process1的VP2和VP3不在内存中,但是当进程需要用到这两个页的时候，硬件会捕获到这个消息,就是所谓的页错误( Page ),然后操作系统接管进程,负责将VP2和VP3从磁盘中读出来并且装入内存,然后将内存中的这两个页与VP2和VP3之间建立映射关系。以页为单位来存取和交换这些数据非常方便,硬件本身就支持这种以页为单位的操作方式</li>
</ul>
<p>保护也是页映射的目的之一。简单地说就是每个页可以设置权限属性,谁可以修改,谁可以访问等,而只有操作系统有权限修改这些属性,那么操作系统就可以做到保护自己和保护进程</p>
<p>虚拟存储的实现需要依靠硬件的支持,对于不同的CPU来说是不同的。但是几乎所有的硬件都用一个叫MMU( Memory Management Unit)的部件来进行页映射</p>
<p><img src="/img/1-虚拟地址到物理地址的转换.png" alt></p>
<p>在页映射模式下,CPU发出的是 Virtual Address,即我们的程序看到的是虚拟地址。经过MMU转换以后就变成了 Physical Address。一般MMU都集成在CPU内部了,不会以独立的部件存在</p>
<h3 id="1-6-众人拾柴火焰高"><a href="#1-6-众人拾柴火焰高" class="headerlink" title="1.6  众人拾柴火焰高"></a>1.6  众人拾柴火焰高</h3><h4 id="1-6-1-线程基础"><a href="#1-6-1-线程基础" class="headerlink" title="1.6.1 线程基础"></a>1.6.1 线程基础</h4><h5 id="1-6-1-1-什么是线程"><a href="#1-6-1-1-什么是线程" class="headerlink" title="1.6.1.1 什么是线程"></a>1.6.1.1 什么是线程</h5><p>一个标准的线程由<code>线程ID</code>、<code>当前指令指针(PC)</code>、<code>寄存器集合</code>和<code>堆栈</code>组成。一个进程由一个到多个线程组成,各个线程之间共享程序的内存空间(包括代码段、数据段、堆等)及一些进程级的资源(如打开文件和信号)<br><img src="/img/1-进程和线程关系.png" alt></p>
<p>使用多线程的场景</p>
<ul>
<li>某个操作可能会陷入长时间等待<ul>
<li>等待的线程会进入睡眠状态,无法继续执行。多线程执行可以有效利用等待的时间。典型的例子是等待网络响应,这可能要花费数秒甚至数十秒</li>
</ul>
</li>
<li>某个操作(常常是计算)会消耗大量的时间<ul>
<li>如果只有一个线程,程序和用户之间的交互会中断。多线程可以让一个线程负责交互,另一个线程负责计算</li>
</ul>
</li>
<li>程序逻辑本身就要求并发操作<ul>
<li>一个多端下载软件(例如 Bittorrent)</li>
</ul>
</li>
<li>利用多CPU或多核计算机的优势<ul>
<li>本身具备同时执行多个线程的能力,因此单线程程序无法全面地发挥计算机的全部计算能力</li>
</ul>
</li>
<li>相对于多进程应用,多线程在数据共享方面效率要高很多</li>
</ul>
<h5 id="1-6-1-2-线程的访问权限"><a href="#1-6-1-2-线程的访问权限" class="headerlink" title="1.6.1.2 线程的访问权限"></a>1.6.1.2 线程的访问权限</h5><ol>
<li><p>线程也拥有自己的私有存储空间</p>
<ul>
<li>栈(尽管并非完全无法被其他线程访问,但一般情况下仍然可以认为是私有的数据)</li>
<li>线程局部存储( Thread Local Storage,TLS)。线程局部存储是某些操作系统为线程单独提供的私有空间,但通常只具有很有限的容量。</li>
<li>寄存器(包括PC寄存器),寄存器是执行流的基本数据,因此为线程私有。</li>
</ul>
<p><img src="/img/1-线程私有和共享数据.png" alt></p>
</li>
</ol>
<h5 id="1-6-1-3-线程调度和优先级"><a href="#1-6-1-3-线程调度和优先级" class="headerlink" title="1.6.1.3 线程调度和优先级"></a>1.6.1.3 线程调度和优先级</h5><ul>
<li>当线程数量小于等于处理器数量时(并且操作系统支持多处理器),线程的并发是真正的并发</li>
<li>但对于线程数量大于处理器数量的情况, 此时至少有一个处理器会运行多个线程</li>
<li>处理器上切换不同的线程的行为称之为线程调度( Thread Schedule)</li>
<li><p>在线程调度中,线程通常拥有至少三种状态</p>
<ul>
<li>运行( Running):此时线程正在执行。</li>
<li>就绪( Ready):此时线程可以立刻运行,但CPU经被占用。</li>
<li><p>等待( Waiting):此时线程正在等待某一事件(通常是IO或同步)发生,无法执行</p>
<p><img src="/img/1-线程状态切换.png" alt></p>
</li>
</ul>
</li>
</ul>
<p>处于运行中线程拥有一段可以执行的时间,这段时间称为时间片( Time Slice),当时间片用尽的时候,该进程将进入就绪状态。如果在时间片用尽之前进程就开始等待某事件那么它将进入等待状态。每当一个线程离开运行状态时,调度系统就会选择一个其他的就绪线程继续执行。在一个处于等待状态的线程所等待的事件发生之后,该线程将进入就绪状态</p>
<p>线程调度方案: 优先级调度( Priority Schedule)和轮转法( Round robin)</p>
<ul>
<li>优先级调度( Priority Schedule)<ul>
<li>具有高优先级的线程会更早地执行,而低优先级的线程常常要等待到系统中已经没有高优先级的可执行的线程存在时才能够执行</li>
</ul>
</li>
<li>轮转法( Round robin) <ul>
<li>所谓轮转法,即是之前提到的让各个线程轮流执行一小段时间的方法。这决定了线程之间交错执行的特点</li>
</ul>
</li>
</ul>
<p>根据线程的表现自动调整优先级</p>
<ol>
<li>I/O密集型线程频繁进入等待，放弃时间片段，优先级更容易提升</li>
<li>CPU密集型线程很少等待</li>
<li>一个线程被饿死,是说它的优先级较低，一直得不到执行。会逐渐提高其优先级以免其被饿死。</li>
<li>一个高优先级的IO密集型线程由于大部分时间都处于等待状态,因此相对不容易造成其他线程饿死</li>
</ol>
<p>优先级调度环境下，线程的优先级改变有三种方式</p>
<ul>
<li>用户指定优先级</li>
<li>根据进入等待状态的频繁程度提升或降低优先级</li>
<li>长时间得不到执行而被提升优先级</li>
</ul>
<h5 id="1-6-1-4-可抢占线程和不可抢占线程"><a href="#1-6-1-4-可抢占线程和不可抢占线程" class="headerlink" title="1.6.1.4 可抢占线程和不可抢占线程"></a>1.6.1.4 可抢占线程和不可抢占线程</h5><ul>
<li>抢占( Preemption): 线程在用尽时间片之后会被强制剥夺继续执行的权利,而进入就绪状态</li>
<li>不可抢占: 早期的一些系统(例如 Windows3.1)里,线程是不可抢占的。线程必须手动发出一个放弃执行的命令,才能让其他的线程得到执行</li>
</ul>
<p>线程主动放弃:</p>
<ol>
<li>当线程试图等待某事件时(I/O等)</li>
<li>线程主动放弃时间片</li>
</ol>
<h5 id="1-6-1-5-Linux的多线程"><a href="#1-6-1-5-Linux的多线程" class="headerlink" title="1.6.1.5 Linux的多线程"></a>1.6.1.5 Linux的多线程</h5><ul>
<li>Windows内核有明确的线程和进程的概念。windows中使用,CreateProcess和 Create Thread来创建进程和线程,并且有一系列的AP来操纵它们</li>
<li>Linux对多线程的支持颇为贫乏,事实上,在 Linux内核中并不存在真正意义上的线程概念</li>
<li>Linux将所有的执行实体(无论是线程还是进程)都称为<code>任务(Task)</code><ul>
<li>每一个任务概念上都类似于一个单线程的进程,具有内存空间、执行实体、文件资源等。</li>
<li>不过, Linux下不同的任务之间可以选择共享内存空间,因而在实际意义上,共享了同一个内存空间的多个任务构成了一个进程,这些任务也就成了这个进程里的线程</li>
</ul>
</li>
</ul>
<h4 id="1-6-2-线程安全"><a href="#1-6-2-线程安全" class="headerlink" title="1.6.2 线程安全"></a>1.6.2 线程安全</h4><p>多线程处于一个多变的环境中，可访问的全局变量和堆数据随时可能被线程改变。因此多线程程序在并发时数据的一致性变得非常重要</p>
<h5 id="1-6-2-1-竞争和原子操作"><a href="#1-6-2-1-竞争和原子操作" class="headerlink" title="1.6.2.1 竞争和原子操作"></a>1.6.2.1 竞争和原子操作</h5><ol>
<li>多个线程同时访问一个共享数据，可能造成很恶劣的后果</li>
<li>可以对简单数据进行原子操作，保证数据的一致性。但是对复杂数据，原子操作指令就力不从心了</li>
</ol>
<h5 id="1-6-2-2-同步与锁"><a href="#1-6-2-2-同步与锁" class="headerlink" title="1.6.2.2 同步与锁"></a>1.6.2.2 同步与锁</h5><ul>
<li>对共享的数据进行同步访问</li>
<li>最简单的同步就是<code>锁</code>,访问之前要获取锁，访问之后释放锁。锁已经被占用时，尝试获取锁的线程会等待，直到获取到锁</li>
<li><code>二元信号量( Binary Semaphore)</code>是最简单的一种锁<ul>
<li>只有两种状态:占用与非占用。</li>
<li>它适合只能被唯一一个线程独占访问的资源。</li>
<li>当二元信号量处于非占用状态时,第一个试图获取该二元信号量的线程会获得该锁,并将二元信号量置为占用状态,此后其他的所有试图获取该二元信号量的线程将会等待,直到该锁被释放</li>
</ul>
</li>
</ul>
<p>对于允许<strong>多个线程并发访问</strong>的资源,多元信号量简称<code>信号量( Semaphore)</code>,它是一个很好的选择。如果信号量的值小于0,则进入等待状态,否则继续执行。</p>
<p><code>互斥量( Mutex)</code>和二元信号量很类似</p>
<ul>
<li>相同点: 资源仅同时允许一个线程访问</li>
<li>不同点: 信号量可以被一个线程获取，被另一个线程释放。互斥量只能被同一个线程获取和释放。</li>
</ul>
<p><code>临界区( Critical Section)</code>是比互斥量更加严格的同步手段：</p>
<ul>
<li>把临界区的锁的获取称为进入临界区,而把锁的释放称为离开临界区</li>
<li>临界区和互斥量与信号量的区别在于,互斥量和信号量在系统的任何”进程”里都是可见的,也就是说,一个”进程”创建了一个互斥量或信号量,另一个”进程”试图去获取该锁是合法的</li>
<li>临界区的作用范围仅限于本进程</li>
<li>临界区具有和互斥量相同的性质</li>
</ul>
<p>读写锁( Read-Write Lock)致力于一种更加特定的场合的同步</p>
<ul>
<li>对于读取频繁,而仅仅偶尔写入的情况,用上述的锁方案会显得非常低效</li>
<li><code>读操作</code>用<code>共享</code>的方式获取锁，<code>写操作</code>用<code>独占</code>的方式获取锁。是最高效的<ul>
<li>对于同一个锁,读写锁有两种获取方式,共享的( Shared)或独占的( Exclusive)</li>
<li>当锁处于自由的状态时,试图以任何一种方式获取锁都能成功,并将锁置于对应的状态。如果锁处于共享状态,其他线程以共享的方式获取锁仍然会成功,此时这个锁分配给了多个线程。然而,如果其他线程试图以独占的方式获取</li>
<li>已经处于共享状态的锁,那么它将必须等待锁被所有的线程释放。相应地,处于独占状态的锁将阻止任何其他线程获取该锁,不论它们试图以哪种方式获取</li>
</ul>
</li>
</ul>
<p><img src="/img/1-读写锁.png" alt></p>
<p>条件变量( Condition variable)作为一种同步手段,作用类似于一个栅栏。</p>
<ul>
<li>一个条件变量可以被多个线程等待</li>
<li>一旦条件变量被唤醒，那么这多个等待的线程一起恢复执行。</li>
</ul>
<h5 id="1-6-2-3-可重入-Reentrant-与线程安全"><a href="#1-6-2-3-可重入-Reentrant-与线程安全" class="headerlink" title="1.6.2.3 可重入( Reentrant)与线程安全"></a>1.6.2.3 可重入( Reentrant)与线程安全</h5><ul>
<li>一个函数被重入,表示这个函数没有执行完成,由于外部因素或内部调用,又一次进入该函数执行</li>
<li>一个函数要被重入,只有两种情况:<ul>
<li>多个线程同时执行这个函数。</li>
<li>函数自身(可能是经过多层调用之后)调用自身。</li>
</ul>
</li>
<li>一个函数被称为可重入的,表明该函数被重入之后不会产生任何不良后果。可重入是并发安全的强力保障。</li>
</ul>
<h5 id="1-6-2-4-过度优化"><a href="#1-6-2-4-过度优化" class="headerlink" title="1.6.2.4 过度优化"></a>1.6.2.4 过度优化</h5><p>案例1 编译器优化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = 0;</span><br><span class="line">Thread1 Thread2</span><br><span class="line">lock()  lock()</span><br><span class="line">x++;     x++;</span><br><span class="line">unlock();  unlock();</span><br></pre></td></tr></table></figure></p>
<p>x最终的值可能为1.</p>
<p>不同线程使用独立的寄存器。当某个线程计算完x++后，编译器为了提高速度，并没有将1写回到内存中。所以另一个线程执行完x++后。最终写回到变量x的值为1</p>
<p>案例2  CPU动态调度或编译器优化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = y = 0;</span><br><span class="line">Thread1 Thread2</span><br><span class="line">x =1;     y=1;</span><br><span class="line">r1=y;   r2=x;</span><br></pre></td></tr></table></figure></p>
<p>很显然，r1和r2至少一个为1。逻辑上不可能同时为0.然而，实际上r1=r2=0的情况可能发生。</p>
<p>原因在于</p>
<ol>
<li>早在几十年前,CPU就发展出了动态调度,在执行程序的时候为了提高效率有可能交换指令的顺序</li>
<li>编译器在进行优化的时候,也可能为了效率而交换毫不相干的两条相邻指令(如x=1和rl=y)的执行顺序。从而造成r1=r2=0</li>
</ol>
<p>可以使用volatile关键字试图阻止过度优化</p>
<ol>
<li>阻止编译器为了提高速度将一个变量缓存到寄存器内而不写回</li>
<li>阻止编译器调整操作 volatile变量的指令顺序</li>
</ol>
<p>调用CPU提供的一条指令,这条指令常常被称为 barrier。barrier指令会阻止CPU将该指令之前的指令交换到 barrier之后</p>
<h4 id="1-6-3-多线程内部情况"><a href="#1-6-3-多线程内部情况" class="headerlink" title="1.6.3 多线程内部情况"></a>1.6.3 多线程内部情况</h4><h5 id="1-6-3-1-三种线程模型"><a href="#1-6-3-1-三种线程模型" class="headerlink" title="1.6.3.1 三种线程模型"></a>1.6.3.1 三种线程模型</h5><ul>
<li>线程的并发执行是由多处理器或操作系统调度来实现的</li>
<li>大多数操作系统,包括 Windows和 Linux,都在内核里提供线程的支持</li>
<li>这里的内核线程和Linux里的kernel_thread不是同一回事</li>
<li>实际上用户使用的并不是内核线程，而是存在于用户态的用户线程。</li>
<li>用户线程并不一定在操作系统内核中对应同等数量的内核线程</li>
</ul>
<p>一对一模型:</p>
<ol>
<li>1个用户线程对应一个内核线程</li>
<li>内核线程的数量可能比用户线程的数量多</li>
</ol>
<ul>
<li>优点:<ul>
<li>线程之间的并发是真正的并发，一个线程出问题，其他不受影响</li>
</ul>
</li>
<li>缺点:<ul>
<li>由于许多操作系统限制了内核线程的数量，因此一对一线程会让用户线程数量受到限制</li>
<li>内核线程调度时，上下文切换的开销较大，导致用户线程执行效率下降</li>
</ul>
</li>
</ul>
<p>多对一模型<br><img src="/img/1-多对一线程模型.png" alt></p>
<p>多对1模型，将多个用户线程映射到一个内核线程上，线程之间的切换由用户态的代码进行，切换速度要快的多</p>
<ul>
<li>优点:<ul>
<li>高效的上下文切换和几乎无限制的线程数量</li>
</ul>
</li>
<li>缺点:<ul>
<li>一个用户线程阻塞，则内核线程就会被阻塞，造成所有用户线程被阻塞</li>
</ul>
</li>
</ul>
<p>多对多模型是1对1和多对1线程模型的结合。<br><img src="/img/1-多对多的线程模型.png" alt></p>
<h2 id="​编译和链接"><a href="#​编译和链接" class="headerlink" title="​编译和链接"></a>​编译和链接</h2><h3 id="2-1-被隐藏了的过程"><a href="#2-1-被隐藏了的过程" class="headerlink" title="2.1 被隐藏了的过程"></a>2.1 被隐藏了的过程</h3><p>编译分为4个过程</p>
<ul>
<li>预处理( Prepressing)</li>
<li>编译( Compilation)</li>
<li>汇编( Assembly)</li>
<li>链接( Linking)</li>
</ul>
<p><img src="/img/2-gcc编译过程.png" alt></p>
<h4 id="2-2-1-预处理-预编译"><a href="#2-2-1-预处理-预编译" class="headerlink" title="2.2.1 预处理(预编译)"></a>2.2.1 预处理(预编译)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$gcc -E hello.c -o hello.i</span><br><span class="line">或者</span><br><span class="line">$cpp hello.c &gt; hello.i</span><br></pre></td></tr></table></figure>
<p>预处理(预编译)过程主要处理那些源代码文件中的以“#”开始的预编译指令</p>
<ul>
<li>将所有的”#define”删除,并且展开所有的宏定义</li>
<li>处理所有条件预编译指令,比如”#if”、”#ifdef”、”#elif”、”#else”、 “#endif”</li>
<li>处理”#include”预编译指令,将被包含的文件插入到该预编译指令的位置。注意,这个过程是递归进行的,也就是说被包含的文件可能还包含其他文件</li>
<li>删除所有的注释”//“和”/**/“</li>
<li>添加行号和文件名标识,比如#2  “helo.c” 2,以便于编译时编译器产生调试用的行号信息及用于编译时产生编译错误或警告时能够显示行号</li>
<li>保留所有的#pragma编译器指令,因为编译器需要使用它们</li>
</ul>
<h4 id="2-1-2-编译"><a href="#2-1-2-编译" class="headerlink" title="2.1.2 编译"></a>2.1.2 编译</h4><p><code>编译过程</code>就是把预处理完的文件进行一系列<strong>词法分析</strong>、<strong>语法分析</strong>、<strong>语义分析</strong>及<strong>优化后</strong>生产相应的汇编代码文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -s hello. i -o hello.s</span><br></pre></td></tr></table></figure>
<p>gcc这个命令只是相应后台程序的包装(例如c语言的预编译和编译程序都是cc1,c++对应的是cc1plus),它会根据不同的参数要求去调用预编译，编译程序cc1、汇编器as、链接器ld</p>
<h4 id="2-1-3-汇编"><a href="#2-1-3-汇编" class="headerlink" title="2.1.3 汇编"></a>2.1.3 汇编</h4><p>汇编器是将汇编代码转变成机器可以执行的指令,每一个汇编语句几乎都对应一条机器</p>
<p>指令, 只是根据汇编指令和机器指令的对照表一一翻译就可以了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$as hello.s -o hello.o</span><br><span class="line">$gcc -c hello.s -o hello.o</span><br></pre></td></tr></table></figure>
<h4 id="2-1-4-链接"><a href="#2-1-4-链接" class="headerlink" title="2.1.4 链接"></a>2.1.4 链接</h4><p>调用ld才可以产生一个能够正常运行的Hello world程序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ld -static /usr/lib/crt1.o /usr/lib/crti.o /usr/lib/gcc/i486-linux-gun/4.1.3/crtbeginT.o -L/usr/lib/gcc/i486-linux-gun/4.1.3 -L/usr/lib -L/lib hello.o --start-group -lgcc -lgcc_eh -lc --end-group /usr/lib/gcc/i486-linux-gun/4.1.3/crtend.o /usr/lib/crtn.o</span><br></pre></td></tr></table></figure></p>
<p>可以看到,我们需要将一大堆文件链接起来才可以得到最终的可执行文件</p>
<h3 id="2-2-编译器做了什么"><a href="#2-2-编译器做了什么" class="headerlink" title="2.2 编译器做了什么?"></a>2.2 编译器做了什么?</h3><ol>
<li>编译器将高级语言翻译成机器语言，大大提高了编程的效率。程序员不用考虑特定的机器，字长，内存大小等等限制</li>
<li><p>编译的过程可以分为6步: 扫描，语法分析，语义分析，源代码优化，代码生成和目标代码优化。</p>
<p><img src="/img/2-编译过程.png" alt></p>
</li>
<li><p>以下面代码为例做相关的分析</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array[index] = (index + 4) * (2 + 6)</span><br><span class="line">ComplierExpression.c</span><br></pre></td></tr></table></figure>
<h4 id="2-2-1-词法分析-扫描"><a href="#2-2-1-词法分析-扫描" class="headerlink" title="2.2.1 词法分析(扫描)"></a>2.2.1 词法分析(扫描)</h4><ol>
<li>首先源代码程序被输入到扫描器( Scanner)</li>
<li>扫描器只是简单地进行词法分析,运用一种类似于有限状态机( Finite state Machine)的算法可以很轻松地将源代码的字符序列分割成一系列的记号( Token)</li>
<li><p>上面的那行程序,总共包含了28个非空字符,经过扫描以后,产生了16个记号</p>
<p><img src="/img/2-词法分析1.png" alt><br><img src="/img/2-词法分析2.png" alt></p>
</li>
<li><p>词法分析产生的记号一般可以分为如下几类</p>
<ol>
<li>关键字</li>
<li>标识符，存放到符号表</li>
<li>字面量(包含数字、字符串等)，数字、字符串常量存放到文字表</li>
<li>特殊符号(如加号、等号)</li>
</ol>
</li>
<li><p>有一个叫做lex的程序可以实现词法扫描,它会按照用户之前描述好的词法规则将输入的字符串分割成一个个记号。因为这样个程序的存在,编译器的开发者就无须为每个编译器开发一个独立的词法扫描器,而是根据需要改变词法规则就可以了</p>
</li>
<li>对于一些有预处理的语言,比如C语言,它的宏替换和文件包含等工作一般不归入编译器的范围而交给一个独立的预处理器</li>
</ol>
<h4 id="2-2-2-语法分析"><a href="#2-2-2-语法分析" class="headerlink" title="2.2.2 语法分析"></a>2.2.2 语法分析</h4><ol>
<li><p>接下来语法分析器( Grammar Parser)将对由扫描器产生的记号进行语法分析,从而产生语法树( Syntax Tree)</p>
</li>
<li><p>整个分析过程釆用了上下文无关语法( Context-free Grammar)的分析手段,简单地讲,由语法分析器生成的语法树就是以表达式( Expression)为节点的树</p>
</li>
<li><p>上面例子中的语句就是一个由赋值表达式、加法表达式、乘法表达式、数组表达式、括号表达式组成的复杂语句</p>
<p><img src="/img/2-语法树.png" alt></p>
<ul>
<li>整个语句被看作是一个<code>赋值表达式</code>;赋值表达式的左边是个数组表达式,它的右边是一个乘法表达式;数组表达式又由两个符号表达式组成,等等</li>
<li><code>符号</code>和<code>数字</code>是最小的表达式,作为整个语法树的<code>叶节点</code></li>
<li>如果出现了表达式不合法,比如各种括号不匹配、表达式中缺少操作符等,编译器就会报告<code>语法分析阶段的错误</code></li>
</ul>
</li>
<li><p>语法分析也有一个现成的工具叫做yacc( Yet Another Compiler Compiler), 可以根据用户给定的语法规则对输入的记号序列进行解析,从而构建出一棵语法树。</p>
</li>
<li>如lex一样，对于不同的编程语言,编译器的开发者只须改变语法规则,而无须为每个编译器编写一个语法分析器,所以它又被称为“编译器编译器( Compiler Compiler)”</li>
</ol>
<h4 id="2-2-3-语义分析"><a href="#2-2-3-语义分析" class="headerlink" title="2.2.3 语义分析"></a>2.2.3 语义分析</h4><ol>
<li>语义分析,由语义分析器( Semantic Analyzer)来完成</li>
<li>语法分析仅仅是完成了对表达式的语法层面的分析,但是它并不了解这个语句是否真正有意义。比如C语言里面两个指针做乘法运算是没有意义的,但是这个语句在语法上是合法的;比如同样一个指针和一个浮点数做乘法运算是否合法等。</li>
<li><p>编译器所能分析的语义是静态语义(Satc Semantic),所谓静态语义是指在编译期可以确定的语义。</p>
<ul>
<li>静态语义通常包括声明和类型的匹配,类型的转换</li>
<li>当一个浮点型的表达式赋值给一个整型的表达式时,其中隐含了一个浮点型到整型转换的过程,语义分析过程中需要完成这个步骤<br>+将一个浮点型赋值给一个指针的时候,语义分析程序会发现这个类型不匹配，编译器将会报错</li>
</ul>
</li>
<li><p>对应的动态语义( Dynamic Semantic)，就是只有运行期才能确定的语义</p>
<ol>
<li>将0作为除数是个运行期语义错误</li>
</ol>
</li>
<li><p>经过语义分析阶段以后,整个语法树的表达式都被标识了类型,如果有些类型需要做隐式转换,语义分析程序会在语法树中插入相应的转换节点</p>
<p><img src="/img/2-标识语义后的语法树.png" alt></p>
<ul>
<li>每个表达式(包括符号和数字)都被标识了类型</li>
<li>语义分析器还对符号表里的符号类型也做了更新</li>
</ul>
</li>
</ol>
<h4 id="2-2-4-中间语言生成-源代码优化"><a href="#2-2-4-中间语言生成-源代码优化" class="headerlink" title="2.2.4 中间语言生成(源代码优化)"></a>2.2.4 中间语言生成(源代码优化)</h4><ul>
<li><p>源代码级优化器(Source Code Optimizer)会在源代码级别进行优化。(2+6)这个表达式可以被优化掉,因为它的值在编译期就可以被确定</p>
<p><img src="/img/2-优化后的语法树.png" alt></p>
<ul>
<li><p>我们看到(2+6)这个表达式被优化成8</p>
</li>
<li><p>直接在语法树上作优化比较困难,源代码优化器往往将整个语法树转换成<code>中间代码( intermediate Code)</code>,它是语法树的顺序表示,其实它已经非常接近目标代码了</p>
</li>
<li><p>它一般跟目标机器和运行时环境是无关的,比如它不包含数据的尺寸、变量地址和寄存器的名字等</p>
</li>
</ul>
</li>
<li><p>中间代码有很多种类型,在不同的编译器中有着不同的形式</p>
<ul>
<li>比较常见的有:三地址码(Thee-address Code)和P代码( P-Code)</li>
</ul>
</li>
<li><p>中间代码使得编译器可以被分为前端和后端</p>
<ul>
<li>编译器前端负责产生机器无关的中间代码</li>
<li>编译器后端将中间代码转换成目标机器代码。</li>
<li>这样对于一些可以跨平台的编译器而言,它们可以针对不同的平台使用同一个前端和针对不同机器平台的数个后端</li>
</ul>
</li>
</ul>
<h4 id="2-2-5-代码生成与优化"><a href="#2-2-5-代码生成与优化" class="headerlink" title="2.2.5 代码生成与优化"></a>2.2.5 代码生成与优化</h4><ol>
<li><p>源代码级优化器产生中间代码标志着下面的过程都属于编译器后端</p>
</li>
<li><p>编译器后端主要包括:</p>
<ul>
<li><p>代码生成器( Code Generator)</p>
<ul>
<li>代码生成器将中间代码转换成目标机器代码,这个过程十分依赖于目标机器,因为不同的机器有着不同的字长、寄存器、整数数据类型和浮点数数据类型等</li>
</ul>
</li>
<li><p>代码优化器( Target Code Optimizer)。</p>
<ul>
<li>最后目标代码优化器对上述的目标代码进行优化,比如选择合适的寻址方式、使用位移来代替乘法运算、删除多余的指令等</li>
</ul>
</li>
</ul>
</li>
<li><p>这个目标代码中有一个问题是: index和array的地址还没有确定。</p>
<ul>
<li>如果index和array定义在跟上面的源代码同一个编译单元里面,那么编译器可以为 index和array分配空间,确定它们的地址。</li>
<li>如果是定义在其他的程序模块，那么定义其他模块的全局变量和函数在最终运行时的绝对地址都要在最终链接的时候才能确定</li>
<li>现代的编译器可以将一个源代码文件编译成一个<code>未链接的目标文件</code>,然后由<code>链接器</code>最终将这些目标文件链接起来形成<code>可执行文件</code></li>
</ul>
</li>
</ol>
<blockquote>
<p>代码生成</p>
<p>最后把中间代码转换为汇编语言，这个阶段称为代码生成(code generation)。负责代码生 成的程序模块称为代码生成器(code generator)。</p>
<p>代码生成的关键在于如何来填补编程语言和汇编语言之间的差异。一般而言，比起编程语 言，汇编语言在使用上面的限制要多一些。例如，C 和 Java 可以随心所欲地定义局部变量，而 汇编语言中能够分配给局部变量的寄存器只有不到 30 个而已。处理流程控制方面也只有和 goto语句功能类似的跳转指令。在这样的限制下，还必须以不改变程序的原有语义为前提进行转换</p>
<p>代码优化</p>
<p>现实的编译器还包括优化(optimization)阶段。</p>
<p>现在的计算机，即便是同样的代码，根据编译器优化性能的不同，运行速度也会有数倍的 差距。由于编译器要处理相当多的程序，因此在制作编译器时，最重要的一点就是要尽可能地 提高编译出来的程序的性能。</p>
<p>优化可以在编译器的各个环节进行。可以对抽象语法树进行优化，可以对中间代码的代码 进行优化，也可以对转换后的机器语言进行优化。进一步来说，不仅是编译器，对链接以及运 行时调用的程序库的代码也都可以进行优化。</p>
</blockquote>
<h3 id="2-3-链接年龄比编译器长"><a href="#2-3-链接年龄比编译器长" class="headerlink" title="2.3 链接年龄比编译器长"></a>2.3 链接年龄比编译器长</h3><ol>
<li><p>一开始人们直接使用机器指令进行编程，当程序修改的时候十分的麻烦。</p>
</li>
<li><p>人们把相关的指令和函数符号化后产生了汇编语言。每次指令跳转函数时自动计算函数对应的地址。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jmp divide 跳转到除法程序</span><br><span class="line">假如0001为跳转指令，变成汇编后为jmp</span><br><span class="line">divide表示除法程序的地址</span><br></pre></td></tr></table></figure>
</li>
<li><p>人们将日益庞大的软件，按功能或性质划分为不同的模块。通过模块之间的通信将不同的模块组合成一个完整的软件</p>
</li>
<li><p>每个模块可以单独开发，编译，测试，改变部分代码不需要编译整个程序</p>
</li>
<li><p>模块之间的通信方式一般为:模块之间的函数调用，模块之间的变量访问。需要知道对应函数和变量的地址。统称为<code>模块间符号的引用</code></p>
</li>
<li><p>模块间通过符号来通信类似于拼图，其拼接的过程就是链接(Linking)。</p>
<p><img src="/img/2-模块间的拼合.png" alt></p>
</li>
</ol>
<h3 id="2-4-模块拼装——静态链接"><a href="#2-4-模块拼装——静态链接" class="headerlink" title="2.4 模块拼装——静态链接"></a>2.4 模块拼装——静态链接</h3><ol>
<li><p>人们把每个源代码模块独立的编译。然后按照需要把它们组装起来，这个组装模块的过程就是链接</p>
</li>
<li><p>链接的主要内容就是把各个模块之间相互引用的部分都处理好,使得各个模块之间能够正确地衔接</p>
</li>
<li><p>链接过程主要包括了</p>
<ul>
<li>地址和空间分配( Address and Storage Allocation)</li>
<li>符号决议( Symbol Resolution)<ul>
<li>符号决议有时候也被叫做符号绑定( Symbol Binding)、名称绑定( Name Binding),名称决议( Name Resolution),甚至还有叫做地址绑定( Address Binding), 指令绑定( Instruction Binding)的</li>
<li>大体上它们的意思都一样,但从细节角度来区分,它们之间还是存在一定区别的,比如“决议”更倾向于静态链接,而“绑定”更倾向于动态链接,即它们所使用的范围不一样。</li>
<li>在静态链接,我们将统一称为符号决议</li>
</ul>
</li>
<li>重定位( Relocation)等这些步骤</li>
</ul>
</li>
<li><p>最基本的静态链接过程:</p>
<p> <img src="/img/2-链接过程.png" alt></p>
<ul>
<li>每个模块的源代码文件(如.c)文件经过编译器编译成目标文件( Object File,一般扩展名为o或.obj)。</li>
<li>目标文件和库( Library)一起链接形成最终可执行文件<ul>
<li>最常见的库就是运行时库( Runtime Library), </li>
<li>库其实是一组目标文件的包,就是一些最常用的代码编译成目标文件后打包存放</li>
</ul>
</li>
</ul>
</li>
<li><p>链接过程的理解</p>
<ul>
<li>比如我们在程序模块 main.c中使用另外一个模块 func.c中的函数foo。我们在main.c模块中每一处调用foo的时候都必须确切知道foo这个函数的地址,但是由于每个模块都是单独编译的,在编译器编译main.c的时候它并不知道foo函数的地址,所以它暂时把这些调用foo的指令的目标地址搁置,等待最后链接的时候由链接器去将这些指令的目标地址修正。如果没有链接器,须要我们手工把每个调用foo的指令进行修正,则填入正确的foo函数地址。当func.c模块被重新编译,foo函数的地址有可能改变时,那么我们在main.c中所有使用到foo的地址的指令将要全部重新调整。这些繁琐的工作将成为程序员的噩梦。</li>
<li>使用链接器,你可以直接引用其他模块的函数和全局变量而无须知道它们的地址,因为链接器在链接的时候,会根据你所引用的符号foo,自动去相应的func.c模块査找foo的地址,然后将main.c模块中所有引用到foo的指令重新修正,让它们的目标地址为真止的foo函数的地址。这就是静态链接的最基本的过程和作用</li>
</ul>
</li>
<li><p>引用其他模块的变量，在链接时如何修正变量的地址》假设我们有个全局变量叫做var,它在目标文件A里面。我们在目标文件B里面要访问这个全局变量</p>
<ol>
<li>我们在目标文件B里面有这么一条指令<code>movl $0x2a, var</code></li>
<li>这条指令就是给这个var变量赋值0x2a,相当于C语言里面的语句var=42</li>
<li><p>我们编译目标文件B,得到这条指令机器码</p>
<p><img src="/img/2-传送指令.png" alt></p>
</li>
<li><p>由于在编译目标文件B的时候,编译器并不知道变量var的目标地址,所以编译器在没法确定地址的情况下,将这条mov指令的目标地址置为0, 等待链接器在将目标文件A和B链接起来的时候再将其修正</p>
</li>
<li>我们假设A和B链接后,变量var的地址确定下来为0x1000, 那么链接器将会把这个指令的目标地址部分修改成0x10000。</li>
<li>这个地址修正的过程也被叫做<code>重定位( Relocation)</code>, 每个要被修正的地方叫一个<code>重定位入口( Relocation Entry)</code>。重定位所做的就是给程序中每个这样的绝对地址引用的位置“打补丁”,<strong>使它们指向正确的地址</strong></li>
</ol>
</li>
</ol>
<h2 id="目标文件里有什么"><a href="#目标文件里有什么" class="headerlink" title="目标文件里有什么"></a>目标文件里有什么</h2><ol>
<li>目标文件从结构上讲,它是已经编译后的可执行文件格式,只是还没有经过链接的过程其中可能有些符号或有些地址还没有被调整</li>
<li>目标文件本身就是按照可执行文件格式存储的,只是跟真正的可执行文件在结构上稍有不同</li>
<li>可执行文件格式涵盖了程序的编译、链接、装载和执行的各个方面</li>
<li>从广义上看,目标文件与可执行文件的格式其实几乎是一样的,所以我们可以广义地将目标文件与可执行文件看成是一种类型的文件,在 Windows下,我们可以统称它们为 PE-COFF文件格式， 在 Linux下,我们可以将它们统称为ELF文件</li>
</ol>
<h3 id="3-1-目标文件的格式"><a href="#3-1-目标文件的格式" class="headerlink" title="3.1  目标文件的格式"></a>3.1  目标文件的格式</h3><ol>
<li><p>可执行文件格式( Executable)主要是 Windows下的PE( Portable Executable)和 Linux的ELF( Executable Linkable format),它们都是<strong>COFF( Common file format)格式的变种</strong>。</p>
</li>
<li><p>COFF的主要贡献是在目标文件里面引入了”段”的机制,不同的目标文件可以拥有不同数量及不同类型的“段”。另外,它还定义了调试数据格式</p>
</li>
<li><p>目标文件就是源代码编译后但未进行链接的那些中间文件( Windows的.obj和 Linux下的.o)</p>
</li>
<li><p>按可执行文件格式存储:</p>
<ol>
<li>可执行文件( Windows的.exe和 Linux下的ELF可执行文件)</li>
<li>动态链接库(DLL, Dynamic Linking Library)( Windows的dll和 Linux的.so)</li>
<li>静态链接库( Static Linking Library)( Windows的lib和 Linux的a)文件</li>
</ol>
</li>
<li><p>静态链接库稍有不同,它是把很多目标文件捆绑在一起形成一个文件,再加上一些索引,可以简单理解为一个包含有很多目标文件的文件包</p>
</li>
<li><p>采用ELF格式的文件类型</p>
<p><img src="/img/2-ELF文件类型1.png" alt></p>
<p><img src="/img/2-ELF文件类型2.png" alt></p>
</li>
</ol>
<h3 id="3-2-目标文件是什么样的"><a href="#3-2-目标文件是什么样的" class="headerlink" title="3.2 目标文件是什么样的"></a>3.2 目标文件是什么样的</h3><ol>
<li><p>目标文件内的内容:</p>
<ol>
<li>编译后的机器指令代码、数据</li>
<li>链接时所须要的一些信息,比如符号表、调试信息、字符串等</li>
</ol>
</li>
<li><p>一般目标文件将这些信息按不同的属性,以”节”( Section)的形式存储,有时候也叫“段”(Segment)。</p>
</li>
<li><p>简单的目标文件结构</p>
<p><img src="/img/2-简单目标文件结构.png" alt></p>
<ul>
<li><p>ELF文件的开头是一个“文件头”,它描述了整个文件的文件属性</p>
<ul>
<li>包括文件是否可执行、是静态链接还是动态链接及入口地址(如果是可执行文件)、目标文件、目标操作系统等信息</li>
<li>文件头还包括个段表(Section Table),段表其实是一个描述文件中各个段的数组</li>
<li>段表描述了文件中各个段在文件中的偏移位置及段的属性等,从段表里面可以得到每个段的所有信息</li>
<li>文件头后面就是各个段的内容,比如代码段保存的就是程序的指令,数据段保存的就是程序的静态变量等</li>
</ul>
</li>
<li><p>程序源代码编译后的机器指令经常被放在代码段( Code Section)里,代码段常见的名字有“.code”或“.text”</p>
</li>
<li><p>已经初始化的全局变量和局部静态变量数据经常放在数据段( Data Section),数据段的一般名字都叫“.data”</p>
</li>
<li><p>未初始化的全局变量和局部静态变量数据经常放在.bss段, 只是为未初始化的全局变量和局部静态变量预留位置而已,它并没有内容,所以它在文件中也不占据空间</p>
<ul>
<li>我们知道未初始化的全局变量和局部静态变量默认值都为0,本来它们也可以被放在data段的但是因为它们都是0,所以为它们在data段分配空间并且存放数据0是没有必要的。</li>
<li>程序运行的时候它们的确是要占内存空间的,并且可执行文件必须记录所有未初始化的全局变量和局部静态变量的大小总和, 记为.bss段</li>
<li>Bss( Block Started by Symbol)最初用于定义符号并且为该符号预留给定数量的未初始化空间</li>
</ul>
</li>
<li><p>程序源代码被编译以后主要分成两种段:<code>程序指令</code>和<code>程序数据</code>。<strong>代码段</strong>属于<code>程序指令</code>,而<strong>数据段和.bss段</strong>属于<code>程序数据</code></p>
</li>
<li><p>将数据和指令分段存放的好处:将数据置成可读写，程序的指令设置为只读，防止指令被改写</p>
<ul>
<li>当程序被装载后,数据和指令分别被映射到两个虚存区域。由于数据区域</li>
<li>对于进程来说是可读写的,而指令区域对于进程来说是只读的,所以这两个虚存区</li>
<li>域的权限可以被分别设置成可读写和只读。这样可以防止程序的指令被有意或无意地改写</li>
</ul>
</li>
<li><p>程序的指令和数据被分开存放对CPU的缓存命中率提高有好处</p>
<ul>
<li>现代CPU的缓存一般都被设计成数据缓存和指令缓存分离,所以程序的指令和数据被分开存放对CPU的缓存命中率提高有好处。</li>
</ul>
</li>
<li><p>如果系统中有多个副本时，将指令部分共享内存。</p>
<ul>
<li>如果系统中运行了数百个进程,可以想象共享的方法来节省大量空间</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="3-3-挖掘-SimpleSection-o"><a href="#3-3-挖掘-SimpleSection-o" class="headerlink" title="3.3 挖掘 SimpleSection.o"></a>3.3 挖掘 SimpleSection.o</h3><blockquote>
<p>如不加说明, 则以下所有分析的都是32位的Intel x86平台的ELF格式</p>
</blockquote>
<ol>
<li><p>SimpleSection代码清单</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br><span class="line"><span class="keyword">int</span> global_init_val = <span class="number">84</span>;</span><br><span class="line"><span class="keyword">int</span> global_uninit_val;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">int</span> static_var = <span class="number">85</span>;</span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">int</span> static_var2;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> b ;</span><br><span class="line">  func1(static_var + static_var2 + a+b);</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p><code>$ gcc -c Simplesection.c</code>得到目标文件<code>Simplesection.o</code>，参数-c表示只编译不链接</p>
</li>
<li><p><code>$ objdump -h Simplesection.o</code> 查看目标文件的结构和内容</p>
<p><img src="/img/3-Simplesection目标文件结构.png" alt></p>
<ul>
<li><p>readelf是linux下专门针对ELF文件格式的解析器</p>
</li>
<li><p>参数“h”就是把ELF文件的各个段的基本信息打印出来</p>
</li>
<li><p>上面的结果来看, SimpleSection.o的段包括了:</p>
<ol>
<li>最基本的代码段(.text)</li>
<li>数据段(.data)</li>
<li>BSS段(.bss)</li>
<li>只读数据段(.rodata)</li>
<li>注释信息段(.comment)</li>
<li>堆栈提示段(.note. GNU-stack)</li>
</ol>
</li>
<li><p>各种信息的含义</p>
<ol>
<li><p>Size: 段的长度</p>
</li>
<li><p>File offset:段所在的位置</p>
</li>
<li><p>CONTENTS:表示该段在文件中存在</p>
<ol>
<li>BSS段没有“ CONTENTS”,表示它实际上在ELF文件中不存在</li>
<li>“noe.GNU-Stack” 段虽然有”CONTENTS”,但它的长度为0,这是个很古怪的段, 我们暂且忽略它,认为它在ELF文件中也不存在</li>
</ol>
</li>
</ol>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<p><img src="/img/3-Simplesection段结构.png" alt></p>
<ol start="3">
<li><p><code>$size SimpleSection.o</code> ，size命令用来查看ELF文件的代码段，数据段和BSS段的长度</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">text data bss dec hex filename</span><br><span class="line"> 95   8     4  107  6d  SimpleSection.o</span><br><span class="line"> </span><br><span class="line"> dec表示3个段长度的和的十进制</span><br><span class="line"> hexdec表示3个段长度的和的十六进制</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="3-3-1-代码段"><a href="#3-3-1-代码段" class="headerlink" title="3.3.1 代码段"></a>3.3.1 代码段</h4><ol>
<li><p><code>$ objdump -s -d Simplesection.o</code>, <code>-s</code>参数可以将所有段的内容以十六进制的方式打印出来,<code>-d</code>参数可以<code>将所有包含指令的段反汇编</code></p>
<p><img src="/img/3-Simplesection目标文件的十六进制和汇编表示.png" alt></p>
<ol>
<li>func1和main的内容是.text的对应的汇编表示</li>
<li>最左面一列是偏移量， 中间4列是十六进制内容， 最右面一列是text段的ASCI码形式</li>
<li>.text段的第一个字节“0x55”就是“ func1”函数的第一条“push %ebp”指令,而最后一个字节0xc3正是 main()函数的最后一条指令“ret”。</li>
</ol>
</li>
</ol>
<h4 id="3-3-2-数据段和只读数据段"><a href="#3-3-2-数据段和只读数据段" class="headerlink" title="3.3.2 数据段和只读数据段"></a>3.3.2 数据段和只读数据段</h4><p><img src="/img/3-Simplesection中字符串常量的存放.png" alt></p>
<ol>
<li><p><code>.data段</code>保存的是那些已经初始化了的<code>全局静态变量</code>和<code>局部静态变量</code>。</p>
<ul>
<li>前面的Simple Sectionc代码里面一共有两个这样的变量,分别是 global_init_varabal与 static_val这两个变量每个4个字节,共刚好8个字节,所以“.data”这个段的大小为8个字节:54000000即为84, 55000000即为85</li>
</ul>
</li>
<li><p><code>.rodata</code>存放只读数据, 一般是程序里面的只读变量(如const修饰的变量)和字符串常量</p>
<ol>
<li>我们在调用“printf”的时候,用到了一个字符串常量“%d\n”,它是一种只读数据,所以它被放到了“.rodata”段,我们可以从输出结果看到”.rodata”这个段的4个字节刚好是这个字符串常量的ASCI字节序,最后以\0结尾</li>
<li>单独设立“.rodata”段有很多好处:<ol>
<li>不光是在语义上支持了C++的 const关键字,<br>2.操作系统在加载的时候可以将“.rodata”段的属性映射成只读这样对于这个段的任何修改操作都会作为非法操作处理,保证了程序的安全性</li>
<li>另外在某些嵌入式平台下,有些存储区域是采用只读存储器的,如ROM,这样将”.rodata”段放在该存储区域中就可以保证程序访问存储器的正确性。</li>
</ol>
</li>
</ol>
</li>
<li><p>有时候编译器会把字符串常量放到<code>.data</code>段,而不会单独放在<code>.rodata</code>段</p>
</li>
</ol>
<h4 id="3-3-3-BSS段"><a href="#3-3-3-BSS段" class="headerlink" title="3.3.3 BSS段"></a>3.3.3 BSS段</h4><ol>
<li><p>bss段存放的是<code>未初始化的全局变量</code>和<code>未初始化的局部静态变量</code></p>
<ul>
<li>上述代码中global_uninit_var和static_var2就是应该被存放在bss段, bss段为它们预留了空间</li>
<li><p>但是我们可以看到该段的大小只有4个字节,这与 global_uninit_var和 static_var2的大小的8个字节不符</p>
</li>
<li><p>可以通过符号表( Symbol Table)(后面章节介绍符号表)看到,只有static_var2被存放在了.bss段,而 global_uninit_var却没有被存放在任何段,只是一个未定义的<code>COMMON</code>符号</p>
</li>
<li>这其实是跟不同的语言与不同的编译器实现有关,有些编译器会将全局的未初始化变量存放在目标文件.bss段</li>
<li>有些则不存放,只是预留一个未定义的全局变量符号,等到最终链接成可执行文件的时候再在.bss段分配空间</li>
<li>编译单元内部可见的静态变量的确是放在.bss段的(例如: global_uninit_var加上static修饰)</li>
</ul>
</li>
<li><p><code>$ objdump -x -s -d SimpleSection.o</code>, 查看bss段</p>
<p><img src="/img/3-Simplesection目标文件的bss段.png" alt></p>
</li>
<li><p>示例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">static int x1 =0;</span><br><span class="line">static int x2 =1;</span><br></pre></td></tr></table></figure>
<p>x1和x2会被放在什么段中呢?</p>
<ol>
<li>x1会被放在bss中,x2会被放在data中。</li>
<li>x1为0,可以认为是未初始化的,因为未初始化的都是0,所以被优化掉了可以放在.bss, 这样可以节省磁盘空间,因为.bss不占磁盘空间。</li>
<li>另外一个变量x2初始化值为1,是初始化</li>
</ol>
</li>
</ol>
<h4 id="3-3-4-其他段"><a href="#3-3-4-其他段" class="headerlink" title="3.3.4 其他段"></a>3.3.4 其他段</h4><p><img src="/img/3-目标文件其他段.png" alt></p>
<ol>
<li>由“.”作为前缀,表示这些表的名字是系统保留的</li>
<li>一个ELF文件也可以拥有几个相同段名的段,比如一个ELF文件中可能有两个或两个以上叫做“text”的段</li>
<li>可以插入自定义的段，但是不能用.作为段名的前缀</li>
<li>.sdata、.tdesc、 .sbss、. ita4、.lit8、 .reginfo、 .grab、.lbis、.conflict可以不用理会这些段,它们已经被遗弃了</li>
</ol>
<h5 id="3-3-4-1-自定义段"><a href="#3-3-4-1-自定义段" class="headerlink" title="3.3.4.1 自定义段"></a>3.3.4.1 自定义段</h5><p>你可能希望变量或某些部分的代码放到指定的段中，以实现某些特定的功能， 我们在全局变量或函数之前加上<code>__attribute__((section(&quot;name&quot;)))</code>属性就可以把相应的变量或函数以<code>name</code>作为段名的段中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">将global变量放到Foo段中</span><br><span class="line">__attribute__((section(&quot;Foo&quot;))) int global = 42;</span><br><span class="line">将foo方法放到BAR段中</span><br><span class="line">__attribute__((section(&quot;BAR&quot;))) void foo()&#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-4-ELF文件结构描述"><a href="#3-4-ELF文件结构描述" class="headerlink" title="3.4 ELF文件结构描述"></a>3.4 ELF文件结构描述</h3><p><img src="/img/3-ELF结构.png" alt></p>
<ol>
<li>最前部是<code>ELF文件头( ELF Header)</code>,它包含了描述整个文件的基本属性,比如ELF文件版本、目标机器型号、程序入口地址等</li>
<li>ELF文件中与段有关的重要结构就是<code>段表( Section Header Table)</code>,该表描述了ELF文件包含的所有段的信息,比如每个段的段名、段的长度、在文件中的偏移、读写权限及段的其他属性</li>
<li>ELF中辅助的结构,比如字符串表、符号表等</li>
</ol>
<h4 id="3-4-1-文件头"><a href="#3-4-1-文件头" class="headerlink" title="3.4.1 文件头"></a>3.4.1 文件头</h4><ol>
<li><p>查看文件头, <code>$ readelf -h SimpleSection.o</code></p>
<p><img src="/img/3-ELF文件头1.png" alt><br><img src="/img/3-ELF文件头2.png" alt></p>
</li>
</ol>
<p>ELF的文件头中定义了ELF魔数、文件机器字节长度、数据存储方式、版本、运行平台、AB版本、ELF重定位类型、硬件平台、硬件平台版本、入口地址、程序头入口和长度、段表的位置和长度及段的数量等</p>
<ol start="2">
<li><p>elf的变量体系</p>
<p><img src="/img/3-ELF变量体系.png" alt></p>
</li>
<li><p>文件头结构体<code>Elf32_Ehdr</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">  unsigned char e_ident[16];</span><br><span class="line">  Elf32_Half e_type;    //ELF文件类型</span><br><span class="line">  Elf32_Half e_machine; //ELF文件的CPU平台属性</span><br><span class="line">  Elf32_Word e_version; //ELF版本号</span><br><span class="line">  Elf32_Addr e_entry;   //EFL文件的入口虚拟地址。重定向文件入口地址为0</span><br><span class="line">  Elf32_Off  e_phoff;   //</span><br><span class="line">  Elf32_Off  e_shoff;   //段表在文件中的偏移</span><br><span class="line">  Elf32_Word e_flags;   //文件头标志位</span><br><span class="line">  Elf32_Half e_ehsize;  //文件头本身的大小</span><br><span class="line">  Elf32_Half e_phentsize; </span><br><span class="line">  Elf32_Half e_phnum;</span><br><span class="line">  Elf32_Half e_shentisize; //段表描述符大小 sizeof(ELF32_Shdr)</span><br><span class="line">  Elf32_Half e_shnum;      //段表描述符数量</span><br><span class="line">  Elf32_Half e_shstrndx;   //段表字符串表所在的段在段表中的下标</span><br><span class="line">&#125; Elf32_Ehdr;</span><br></pre></td></tr></table></figure>
<p><img src="/img/3-ELF头文件成员的含义1.png" alt></p>
<p><img src="/img/3-ELF头文件成员的含义2.png" alt></p>
</li>
</ol>
<ul>
<li>ELF的文件头结构及相关常数被定义在”/usr/include/elf.h”</li>
</ul>
<ol start="4">
<li><p>ELF魔数</p>
<p> Magic:  7f  45  4c  46  01  01 01  00  00  00  00 00  00  00 00  00</p>
<ul>
<li><p>最开始的4个字节是所有ELF文件都必须相同的标识码,分别为0x7F、0x45、0x4c , 0x46</p>
<ol>
<li>第一个字节对应ASCI字符里面的DEL控制符,后面3个字节刚好是ELF这3个字母的ASCI码</li>
<li>a.out格式最开始两个字节为0x01、0x07; PE/COFF文件最开始两个个字节为0x4d、0x5a,即ASCI字符MZ</li>
<li>这种魔数用来确认文件的类型,操作系统在加载可执行文件的时候会确认魔数是否正确,如果不正确会拒绝加载。</li>
</ol>
</li>
<li><p>第5个字节是用来标识ELF的文件类的,0x01表示是32位的,0x02表示是64位</p>
</li>
<li><p>第6个字是字节序,规定该ELF文件是大端的还是小端的 ,0x01表示是小端的,0x02表示是大端</p>
</li>
<li><p>第7个字节规定ELF文件的主版本号,一般是1。因为ELF标准自12版以后就再也没有更新了</p>
</li>
<li><p>后面的9个字节ELF标准没有定义,一般填0,有些平台会使用这9个字节作为扩展标志</p>
</li>
</ul>
</li>
<li><p>文件类型</p>
<ul>
<li><p>e_type成员表示ELF文件类型,即前面提到过的3种ELF文件类型,每个文件类型对应一个常量。</p>
</li>
<li><p>系统通过这个常量来判断ELF的真正文件类型,而不是通过文件的扩展名</p>
</li>
<li><p>ELF文件类型常量</p>
<p><img src="/img/3-ELF文件类型常量.png" alt></p>
</li>
</ul>
</li>
<li><p>机器类型</p>
<ul>
<li><p>ELF文件格式在不同平台下遵循同一套ELF标准，但同一个ELF文件在不同平台下并不能使用。</p>
</li>
<li><p>e_machine表示该ELF文件的平台属性</p>
<p><img src="/img/3-ELF文件的机器类型.png" alt></p>
</li>
</ul>
</li>
</ol>
<h4 id="3-4-2-段表"><a href="#3-4-2-段表" class="headerlink" title="3.4.2 段表"></a>3.4.2 段表</h4><ol>
<li>段表( Section Header Table)就是保存ELF中段的基本属性的结构</li>
<li>段表是ELF文件中除了文件头以外最重要的结构,它描述了ELF的各个段的信息,比如每个段的段名、段的长度、在文件中的偏移、读写权限及段的其他属性。</li>
<li>ELF文件的段结构就是由段表决定的,<code>编译器、链接器和装载器都是依靠段表来定位和访问各个段的属性的</code></li>
<li><p>段表在ELF文件中的位置由ELF文件头的”e_shoff”成员决定</p>
</li>
<li><p><code>objdump -h</code>命令只是把ELF文件中关键的段显示了出来,而省略了其他的辅助性的段</p>
<ul>
<li>使用了“ objudmp -h”来查看ELF文件中包含的段,结果是 SimpleSection</li>
<li>里面看到了总共有6个段,分别是“.code”“.data””、””.bss”、“ rodata”、“ .comment”和 “note.GNU-stack”</li>
</ul>
</li>
<li><p>使用<code>$ readelf -S SimpleSection.o</code>查看ELF真正的段表结构</p>
<p><img src="/img/3-ELF真正的段表结构.png" alt></p>
<ul>
<li>段表是一个以”ELF32_Shdr”结构体为元素的数组。</li>
<li>每个”ELF32_Shdr”结构体对应一个段。</li>
<li>“ELF32_Shdr”被称为段描述符( Section Descriptor)</li>
<li>对于 SimpleSection.o来说,段表就是有11个元素的数组。ELF段表的这个数组的第一个元素是无效的段描述符,它的类型为“NULL”,除此之外每个段描述符都对应一个段。也就是说 SimpleSection.o共有10个有效的段</li>
</ul>
</li>
<li><p>段的描述符结构Elf32_Shdr</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">  Elf32_Word  sh_name;  //段名在字符串表 &quot;.shstrtab&quot;的偏移量</span><br><span class="line">  Elf32_Word  sh_type;  //段的类型</span><br><span class="line">  Elf32_Word  sh_flags; //段的标志位</span><br><span class="line">  Elf32_Addr  sh_addr;  //段虚拟地址:如果可以被加载，则为加载后的虚拟地址。否则为0</span><br><span class="line">  Elf32_Off   sh_offset;//段在文件中的偏移</span><br><span class="line">  Elf32_Word  sh_size;  //段的大小</span><br><span class="line">  Elf32_Word  sh_link;  //段链接信息</span><br><span class="line">  Elf32_Word  sh_info;  //段链接信息</span><br><span class="line">  Elf32_Word  sh_addralign; //段地址对齐</span><br><span class="line">  Elf32_Word  sh_entsize;   //项的长度</span><br><span class="line">&#125; Elf32_Shdr;</span><br></pre></td></tr></table></figure>
<p><img src="/img/3-段的字段的含义.png" alt></p>
</li>
<li><p>SimpleSection.o的SectionTable 及所有段的位置和长度</p>
<p><img src="/img/3-SimpleSection.o的SectionTable及所有段的位置和长度.png" alt></p>
</li>
</ol>
<ul>
<li>Section Table长度为0x1b8,也就是440个字节，包含了11个段的描述，每个段为40个字符<code>sizeof(Elf32_Shdr)</code></li>
</ul>
<ul>
<li><p>最后一个段<code>.rel.text</code>结束后为0x450,即1104个字节，刚好是SimpleSection.o的长度。</p>
</li>
<li><p>Section Table和.rel.text都是因为对齐的原因，与前面的段之间分别有一个字节和两个字节的间隔</p>
</li>
</ul>
<ol start="9">
<li><p>段的类型:<code>sh_type</code></p>
<ul>
<li>段的名字只是在链接和编译过程中有意义,但它不能真正地表示段的类型</li>
<li><p>我们也可以将一个数据段命名为“.text”,对于编译器和链接器来说,主要决定段的属性的是段的类型( sh_type)和段的标志位( sh_flags)</p>
<p><img src="/img/3-段类型1.png" alt></p>
</li>
</ul>
<p><img src="/img/3-段类型2.png" alt></p>
</li>
<li><p>段的标志位:<code>sh_flag</code></p>
<ul>
<li><p>表示该段在进程虚拟地址空间中的属性,比如是否可写,是否可执行等</p>
<p><img src="/img/3-段的标志位.png" alt></p>
</li>
</ul>
</li>
<li><p>系统保留段的属性</p>
<p><img src="/img/3-系统保留段的属性1.png" alt><br><img src="/img/3-系统保留段的属性2.png" alt></p>
</li>
<li><p>段的链接信息:<code>sh_link</code>, <code>sh_info</code></p>
<ul>
<li><p>如果段的类型是与链接相关的(不论是动态链接或静态链接),比如重定位表、符号表等,那么 sh_link和 sh_info这两个成员所包含的意义如表3-11所示</p>
</li>
<li><p>对于其他类型的段,这两个成员没有意义</p>
<p><img src="/img/3-段的链接信息.png" alt></p>
</li>
</ul>
</li>
</ol>
<h4 id="3-4-3-重定位表"><a href="#3-4-3-重定位表" class="headerlink" title="3.4.3 重定位表"></a>3.4.3 重定位表</h4><ol>
<li>Simplesection.o中有一个叫做“.rel.text”的段,它的类型(sh_type)为<code>SHT_REL</code>,也就是说它是一个重定位表( Relocation Table)</li>
<li>对于每个须要重定位的代码段或数据段,都会有一个相应的重定位表</li>
<li>SimpleSection.o中的<code>.rel.text</code>就是针对<code>.text</code>段的重定位表,因为<code>.text</code>段中至少有一个绝对地址的引用,那就是对“ printf”函数的调用</li>
<li>一个重定位表同时也是ELF的一个段，那么这个段的类型就是<code>SHT_REL</code>, 它的“ sh_link”表示符号表的下标,它的“ sh_info”表示它作用于哪个段</li>
<li>比如<code>.rel.text</code>作用于<code>.text</code>段,而<code>.text</code>段的下标为1,那么“ rel. text”的<code>sh_info</code>为1</li>
</ol>
<h4 id="3-4-4-字符串表"><a href="#3-4-4-字符串表" class="headerlink" title="3.4.4 字符串表"></a>3.4.4 字符串表</h4><ol>
<li><p>因为字符串的长度往往是不定的,所以用周定的结构来表示它比较困难。</p>
</li>
<li><p>把字符串集中起来存放到一个表,然后使用字符串在表中的偏移来引用字符串,不用考虑字符串长度问题</p>
<p><img src="/img/3-字符串表.png" alt></p>
</li>
<li><p>字符串表(String Table)<code>.strtab</code>用来保存普通的字符串，段表字符串表(Section Header String Table)<code>.shstrtab</code>用来保存段表中用到的字符串，比如段名。</p>
</li>
<li>ELF文件头中的<code>c_shstrndx</code>就表示<code>.shstrtab</code>在段表数组中的下标。</li>
</ol>
<h3 id="3-5-链接的接口——符号"><a href="#3-5-链接的接口——符号" class="headerlink" title="3.5 链接的接口——符号"></a>3.5 链接的接口——符号</h3><ol>
<li><p>链接过程的本质就是要把多个不同的目标文件之间相互“粘”到一起</p>
</li>
<li><p>在链接中,目标文件之间相互拼合实际上是目标文件之间对地址的引用,<code>即对函数和变量的地址的引用</code>。</p>
<ul>
<li>目标文件B要用到了目标文件A中的函数“foo”,那么我们就称目标文件A定义( Define)了函数“foo”,称目标文件B引用( Reference)了目标文件A中的函数“foo”</li>
</ul>
</li>
<li><p>每个函数或变量都有自己独特的名字,才能避免链接过程中不同变量和函数之间的混淆</p>
</li>
<li><p>在链接中,我们将函数和变量统称为符号( Symbol),函数名或变量名就是符号名( Symbol Name)</p>
</li>
<li><p>我们可以将符号看作是链接中的粘合剂,整个链接过程正是基于符号才能够正确完成</p>
</li>
<li><p>链接过程中很关键的一部分就是<code>符号的管理</code>,每一个目标文件都会有一个相应的符号表( Symbol Table),这个表里面记录了目标文件中所用到的所有符号。</p>
</li>
<li><p>每个定义的符号有个对应的值,叫做符号值( Symbol Value),对于变量和函数来说,符号值就是它们的地址</p>
</li>
<li><p>符号表中所有的符号进行分类,它们有可能是下面这些类型中的一种</p>
<ul>
<li><p><code>全局符号</code>: 定义在本目标文件的<code>全局符号</code>,可以被其他目标文件引用。</p>
<ul>
<li>比如 SimpleSection.o里面的“func1”、“main”和“global_init_var”</li>
</ul>
</li>
<li><p><code>外部符号</code>：在本目标文件中引用的全局符号,却没有定义在本目标文件,这般叫做<code>外部符号( External Symbol)</code>,也就是我们前面所讲的符号引用，比如 SimpleSection.o里面的printf</p>
</li>
<li><p><code>段名</code>：这种符号往往由编译器产生,它的值就是该段的起始地址。比如 SimpleSection.o里面的“.text”、“.data”等</p>
</li>
<li><p><code>局部符号</code>：这类符号只在编译单元内部可见</p>
<ul>
<li>比如 SimpleSection.o里面的“static_var”和“static_var2”。调试器可以使用这些符号来分析程序或崩溃时的核心转储文件。这些局部符号对于链接过程没有作用,链接器往往也忽略它们</li>
</ul>
</li>
<li><p><code>行号信息</code>：即目标文件指令与源代码中代码行的对应关系,它也是可选的</p>
<ol>
<li>对链接过程来说，最值得关注的就是全局符号，也就是前两个分类，因为链接过程中只关心符号的相互粘合。</li>
<li>段名，局部符号，行号信息，对于其他目标文件是不可见的，所以在链接过程中无关紧要。</li>
</ol>
</li>
</ul>
</li>
<li><p>使用很多工具来查看ELF文件的符号表,比如 readelf、 objdump、nm等</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">使用“nm”来查看</span><br><span class="line">$ nm Simplesection.o</span><br><span class="line"></span><br><span class="line">00000000 T func1</span><br><span class="line">00000000 D g1oba1_init_var</span><br><span class="line">00000004 C global_uninit_var</span><br><span class="line">0000001b T main</span><br><span class="line">         U printf</span><br><span class="line">00000004 d static_var.1286</span><br><span class="line">00000000 b static_var2.1287</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="3-5-1-ELF符号表结构"><a href="#3-5-1-ELF符号表结构" class="headerlink" title="3.5.1 ELF符号表结构"></a>3.5.1 ELF符号表结构</h4><ol>
<li><p>符号表往往是文件中的一个段,段名一般叫<code>.symtab</code></p>
</li>
<li><p>符号表是一个Elf32_Sym结构(32位ELF文件)的数组, 每个Elf32_Sym结构对应一个符号</p>
</li>
<li><p>Elf32_Sym结构定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  Elf32_Word    st_name; <span class="comment">//符号名在字符串表中的下标</span></span><br><span class="line">  Elf32_Addr    st_value; <span class="comment">//符号相对应的值。</span></span><br><span class="line">  Elf32_Word    st_size; <span class="comment">//符号大小</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> st_info; <span class="comment">//符号类型和绑定信息</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> st_other;<span class="comment">//目前为0，暂时没用</span></span><br><span class="line">  Elf32_Half    st_shndx;<span class="comment">//符号所在的段</span></span><br><span class="line">&#125; Elf32_Sym;</span><br></pre></td></tr></table></figure>
<p><img src="/img/3-Elf32_Sym结构.png" alt></p>
</li>
</ol>
<ul>
<li><p>符号类型和绑定信息(st_info)</p>
<ol>
<li>该成员低4位表示符号的类型( Symbol Type)</li>
<li>高28位表示符号绑定信息( Symbol Binding)</li>
</ol>
<p><img src="/img/3-Elf32_Sym结构_符号类型.png" alt></p>
<p><img src="/img/3-Elf32_Sym结构_符号绑定.png" alt></p>
</li>
<li><p>符号所在的段（st_shndx）</p>
<ol>
<li>如果符号定义在本目标文件中,那么这个成员表示符号所在的段在段表中的下标</li>
<li>但是如果符号不是定义在本目标文件中,或者对于有些特殊符号,sh_shndx的值有些特殊,如下图</li>
</ol>
<p><img src="/img/3-Elf32_Sym结构_符号所在段.png" alt></p>
</li>
<li><p>符号值(st_value)</p>
<ol>
<li>每个符号都有一个对应的值,如果这个符号是一个函数或变量的定义,那么符号的值就是这个函数或变量的地址</li>
<li>应该按下面这几种情况区别对待:</li>
</ol>
<p><img src="/img/3-Elf32_Sym结构_值1.png" alt><br><img src="/img/3-Elf32_Sym结构_值2.png" alt></p>
</li>
</ul>
<ol start="4">
<li><p>使用readelf查看符号表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ readelf -s SimpleSection.o</span><br></pre></td></tr></table></figure>
<p><img src="/img/3-符号表详情.png" alt></p>
<p><img src="/img/3-ELF真正的段表结构.png" alt></p>
<ul>
<li><p>第一列Num表示符号表数组的下标,从0开始,共15个符号</p>
</li>
<li><p>第二列 Value就是符号值,即 st_value;</p>
</li>
<li><p>第三列Size为符号大小,即 st_size</p>
</li>
<li><p>第四列和第五列分别为符号类型和绑定信息,即对应 st_info的低4位和高28位</p>
</li>
<li><p>第六列vis目前在C/C++语言中未使用,以暂时忽略</p>
</li>
<li><p>第七列Ndx即 st_shndx,表示该符号所属的段</p>
</li>
<li><p>当然最后一列即符号名称</p>
</li>
<li><p>从上面的输出可以看出</p>
<ul>
<li><p>第一个符号,即下标为0的符号, 永远是一个未定义的符号</p>
</li>
<li><p>对于另外几个符号的解释</p>
<ol>
<li>func1和main函数都是定义在 SimpleSection.c里面的,它们所在的位置都为代码段所以Ndx为1,即 Simple Sectiono里面.text段的下标为1。它们是函数,所以类型是 <code>STT_FUNC</code>；它们是全局可见的,所以是 <code>STB_GLOBAL</code>；Size表示函数指令所占的字节数； Value表示函数相对于代码段起始位置的偏移量</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><p>通过readelf -a 或 objdump-x可知.text的下标为1</p>
</li>
<li><p>再来看 printf这个符号,该符号在 SimpleSection.c里面被引用,但是没有被定义。所以它的Ndx是 SHN_UNDEF</p>
</li>
<li><p>global_init_var是已初始化的全局变量,它被定义在.data段,即下标为3。<a href>3.4.2 段表结构</a></p>
</li>
<li><p>global_uninit_var是未初始化的全局变量,它是一个 SHN_COMMON类型的符号,它本身并没有存在于BSS段;关于未初始化的全局变量具体请参见”COMMON块”</p>
</li>
<li><p><code>static_var.1533</code>和 <code>static_var2.1534</code>是两个静态变量,它们的绑定属性是STB_ LOCAL,即只是编译单元内部可见。至于为什么它们的变量名从“ static_var”和“ static_var2”变成了现在这两个“ static_var.1533”和“ statIc_var2.1534”,我们在下面一节“符号修饰”中将会详细介绍</p>
</li>
<li><p>对于那些 STT_SECTION类型的符号,它们表示下标为Ndx的段的段名。它们的符号名没有显示,其实它们的符号名即它们的段名。比如2号符号的Ndx为1,那么它即表示.text段的段名,该符号的符号名应该就是“.text”。如果我们使用“ objdump -t”就可以清楚地看到这些段名符号</p>
</li>
<li><p>“SimpleSection.c”这个符号表示编译单元的源文件名</p>
</li>
</ol>
<h4 id="3-5-2-特殊符号"><a href="#3-5-2-特殊符号" class="headerlink" title="3.5.2 特殊符号"></a>3.5.2 特殊符号</h4><ol>
<li><p>当我们使用ld作为链接器来链接生产可执行文件时,它会为我们定义很多特殊的符号</p>
</li>
<li><p>这些符号并没有在你的程序中定义,但是你可以直接声明并且引用它,我们称之为特殊符号</p>
</li>
<li><p>其实这些符号是被定义在ld链接器的链接脚本的,你无须定义它们,但可以声明它们并且使用。</p>
</li>
<li><p>链接器会在将程序最终链接成可执行文件的时候将其解析成正确的值</p>
</li>
<li><p>只有使用ld链接生产最终可执行文件的时候这些符号才会存在</p>
</li>
<li><p>几个特殊符号:</p>
<ul>
<li><p>__executable_start,该符号为程序起始地址,注意,不是入冂地址,是程序的最开始的地址</p>
</li>
<li><p>__etext或 _etext或 etext,该符号为代码段结束地址,即代码段最末尾的地址</p>
</li>
<li><p>_edata或 edata,该符号为数据段结束地址,即数据段最末尾的地址</p>
</li>
<li><p>_end或end,该符号为程序结束地址</p>
</li>
<li><p>以上地址都为程序被装载时的虚拟地址</p>
</li>
<li><p>我们可以在程序中直接使用这些符号</p>
<p><img src="/img/3-链接过程中的特殊符号.png" alt></p>
</li>
</ul>
</li>
</ol>
<h4 id="3-5-3-符号修饰与函数签名"><a href="#3-5-3-符号修饰与函数签名" class="headerlink" title="3.5.3 符号修饰与函数签名"></a>3.5.3 符号修饰与函数签名</h4><ul>
<li>约在20世纪70年代以前, 编译器编译源代码产生目标文件时,符号名与相应的变量和函数的名字是一样的</li>
<li>但随着库越来越多，项目越来越大名字重复的原来越多，所以就会造成目标文件中符号名冲突</li>
<li>为了防止类似的符号名冲突,UNIX下的C语言就规定,C语言源代码文件中的所有全局的变量和函数经过编译以后,相对应的符号名前加上下划线<code>_</code>。而 Fortran语言的源代码经过编译以后,所有的符号名前加上<code>_</code>,后面也加上<code>_</code></li>
<li>这种简单而原始的方法的确能够暂时减少多种语言目标文件之间的符号冲突的概率,但还是没有从根本上解决符号冲突的问题</li>
<li>像C++这样的后来设计的语言开始考虑到了这个问题,增加了名称空间( Namespace)的方法来解决多模块的符号冲突问题</li>
</ul>
<h5 id="3-5-3-1-c-符号修饰"><a href="#3-5-3-1-c-符号修饰" class="headerlink" title="3.5.3.1 c++符号修饰"></a>3.5.3.1 c++符号修饰</h5><ul>
<li><p>为了支持C++这些复杂的特性,人们发明了符号修饰( Name Decoration)或符号改编( Name Mangling)的机制</p>
</li>
<li><p>C++允许多个不同参数类型的函数拥有一样的名字,就是所谓的函数重载;另外C++还在语言级别支持名称空间,即允许在不同的名称空间有多个同样名字的符号</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">func</span><span class="params">(<span class="keyword">float</span>)</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">C2</span>&#123;</span></span><br><span class="line">       <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> N &#123;</span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">C</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码中有6个同名函数叫func,只不过它们的返回类型和参数及所在的名称空间不同。我们引入一个术语叫做函数签名( Function Signature),函数签名包含了一个函数的信息,包括函数名、它的参数类型、它所在的类和名称空间及其他信息。</p>
</li>
<li><p>在编译器及链接器处理符号时,它们使用某种名称修饰的方法,使得每个函数签名对应一个修饰后名称( Decorated name)</p>
</li>
<li><p>签名和名称修饰机制不光被使用到函数上,C++中的全局变量和静态变量也有同样的修饰机制</p>
</li>
<li><p>名称修饰机制也可以防止静态变量的冲突</p>
</li>
</ul>
<h4 id="3-5-4-弱符号和强符号"><a href="#3-5-4-弱符号和强符号" class="headerlink" title="3.5.4 弱符号和强符号"></a>3.5.4 弱符号和强符号</h4><ul>
<li><p>对于C/C++语言来说,编译器默认函数和初始化了的全局变量为强符号,未初始化的全局变量为弱符号</p>
</li>
<li><p>我们也可以通过GCC的“ attribute(weak)”来定义任何一个强符号为弱符号</p>
</li>
<li><p>注意,强符号和弱符号都是针对定义来说的,不是针对符号的引用</p>
</li>
<li><p>对于下面的程序</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> ext;</span><br><span class="line"><span class="keyword">int</span> weak;</span><br><span class="line"><span class="keyword">int</span> strong = <span class="number">1</span>;</span><br><span class="line">__attribute__((weak)) weak2=<span class="number">2</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>“weak”和“weak2”是弱符号</p>
</li>
<li><p>“ strong”和“main”是强符号</p>
</li>
<li><p>“ext”既非强符号也非弱符号,因为它是一个外部变量的引用</p>
</li>
<li><p>针对强弱符号的概念,链接器就会按如下规则处理与选择被多次定义的全局符号</p>
<ul>
<li><p>规则1: 不允许强符号被多次定义(即不同的目标文件中不能有同名的强符号);如果有多个强符号定义,则链接器报符号重复定义错误</p>
</li>
<li><p>规则2: 如果一个符号在某个目标文件中是强符号,在其他文件中都是弱符号,那么选择强符号</p>
</li>
<li><p>规则3: 如果一个符号在所有目标文件中都是弱符号,那么选择其中占用空间最大的一个。</p>
<ul>
<li>比如目标文件A定义全局变量 global为int型,占4个字节;目标文件B定义 global为 double型,占8个字节,那么目标文件A和B链接后,符号gobl占8个字节(尽量不要使用多个不同类型的弱符号,否则容易导致很难发现的程序错误)。</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<h5 id="3-5-4-1-弱引用和强引用"><a href="#3-5-4-1-弱引用和强引用" class="headerlink" title="3.5.4.1 弱引用和强引用"></a>3.5.4.1 弱引用和强引用</h5><ul>
<li><p>强引用( Strong Reference): 对外部目标文件的符号引用在目标文件被最终链接成可执行文件时,它们须要被正确决议,如果没有找到该符号的定义,链接器就会报符号未定义错误</p>
</li>
<li><p>弱引用(Weak Reference): 在处理弱引用时,如果该符号有定义,则链接器将该符号的引用决议;如果该符号来被定义,则链接器对于该引用不报错</p>
</li>
<li><p>链接器处理强引用和弱引用的过程几乎一样,只是对于未定义的弱引用,链接器不认为它是一个错误</p>
</li>
<li><p>这种弱符号和弱引用对于库来说十分有用,</p>
<ul>
<li><p>程序可以对某些扩展功能模块的引用定义为<code>弱引用</code>,当我们将扩展模块与程序链接在一起时,功能模块就可以正常使用如果我们去掉了某些功能模块,那么程序也可以正常链接,只是缺少了相应的功能,这使得程序的功能更加容易裁剪和组合。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">通过使用__attribute__(weakref)”这个扩展关键字来声明对一个外部函数的引用为弱引用</span><br><span class="line">__attribute__((weakref)) <span class="function"><span class="keyword">void</span> <span class="title">foo</span> <span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (foo) &#123;</span><br><span class="line">      foo();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">此时编译，不会报错。运行时，也不会crash,如果foo未定义，则不执行。如果定义，则执行。</span><br></pre></td></tr></table></figure>
</li>
<li><p>库中定义的<code>弱符号</code>可以被用户定义的强符号所覆盖,从而使得程序可以使用自定义版本的库函数</p>
</li>
</ul>
</li>
</ul>
<h3 id="3-6-调试信息"><a href="#3-6-调试信息" class="headerlink" title="3.6 调试信息"></a>3.6 调试信息</h3><ul>
<li>目标文件里面还有可能保存的是调试信息</li>
<li>调试信息在目标文件和可执行文件中占用很大的空间,往往比程序的代码和数据本身大好几倍,所以当我们开发完程序并要将它发布的时候,须要把这些对于用户没有用的调试信息去掉,以节省大量的空间</li>
</ul>
<h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><ol>
<li>文件头中<code>e_shoff</code>字段表明了段表(Section Header Table)在整个文件中的位置</li>
<li>段表字符串表(Section Header String Table)<code>.shstrtab</code>用来保存段表中用到的字符串，比如段名</li>
<li>文件头中<code>e_shstrndx</code>字段表明了<code>.shstrtab</code>在段表(Section Header Table)中的位置</li>
<li>段表描述符(<code>Elf32_Shdr</code>)中的字段<code>sh_name</code>, 表明段名在段表字符串表 “.shstrtab”的偏移量</li>
<li>字符串表(String Table)<code>.strtab</code>用来保存普通的字符串</li>
<li>对于每个须要重定位的代码段或数据段,都会有一个相应的重定位表，例如<code>rel.text</code></li>
<li>通常来说<strong>符号即为变量名和函数名</strong>，<strong>符号值即为变量和函数对应的地址</strong>  (重点)</li>
<li>符号表里的符号是该模块的全局符号，而不是在函数内部定义的局部符号，因为局部符号是放在函数栈内的，地址是无法确定的。  (重点)</li>
<li>进行链接的时候，只需要关注<code>本文件定义的全局符号</code>以及<code>引用的外部的符号</code> (重点)</li>
<li>如果是<code>本文件定义的全局符号</code>，其st_shndx为该符号在本文件中的所在段的下标</li>
<li>如果是<code>引用的外部的符号</code>,其st_shndx为0,即为<code>SHN_UNDET</code>,表示未定义。</li>
</ol>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/积累/" rel="tag"># 积累</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/08/28/Effective_STL读书笔记/" rel="next" title="《Effective STL》读书笔记">
                <i class="fa fa-chevron-left"></i> 《Effective STL》读书笔记
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/09/04/程序员的自我修养 笔记2/" rel="prev" title="程序员的自我修养笔记2">
                程序员的自我修养笔记2 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/header.jpg" alt="Hao Yu">
            
              <p class="site-author-name" itemprop="name">Hao Yu</p>
              <p class="site-description motion-element" itemprop="description">Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author</p>
          </div>
          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">261</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>
        	<audio controls="controls" loop="loop" preload="auto" src="/resource/xiaomeihao.mp3">
	        </audio>
	

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yuhao0102" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:yuh18@mails.tsinghua.edu.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#温故而知新"><span class="nav-number">1.</span> <span class="nav-text">温故而知新</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-从Hello-World说起"><span class="nav-number">1.1.</span> <span class="nav-text">1.1 从Hello World说起</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-万变不离其宗"><span class="nav-number">1.2.</span> <span class="nav-text">1.2 万变不离其宗</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#SMP与多核"><span class="nav-number">1.2.1.</span> <span class="nav-text">SMP与多核</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-站得高，望的远"><span class="nav-number">1.3.</span> <span class="nav-text">1.3 站得高，望的远</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-操作系统做什么"><span class="nav-number">1.4.</span> <span class="nav-text">1.4 操作系统做什么</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-1-不要让CPU打盹"><span class="nav-number">1.4.1.</span> <span class="nav-text">1.4.1 不要让CPU打盹</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-2-设备驱动"><span class="nav-number">1.4.2.</span> <span class="nav-text">1.4.2 设备驱动</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-内存不够怎么办"><span class="nav-number">1.5.</span> <span class="nav-text">1.5 内存不够怎么办</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-5-1-关于隔离"><span class="nav-number">1.5.1.</span> <span class="nav-text">1.5.1 关于隔离</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-5-2-分段-Segmentation"><span class="nav-number">1.5.2.</span> <span class="nav-text">1.5.2  分段( Segmentation)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-5-3-分页-Paging"><span class="nav-number">1.5.3.</span> <span class="nav-text">1.5.3 分页( Paging)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-众人拾柴火焰高"><span class="nav-number">1.6.</span> <span class="nav-text">1.6  众人拾柴火焰高</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-6-1-线程基础"><span class="nav-number">1.6.1.</span> <span class="nav-text">1.6.1 线程基础</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-6-1-1-什么是线程"><span class="nav-number">1.6.1.1.</span> <span class="nav-text">1.6.1.1 什么是线程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-6-1-2-线程的访问权限"><span class="nav-number">1.6.1.2.</span> <span class="nav-text">1.6.1.2 线程的访问权限</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-6-1-3-线程调度和优先级"><span class="nav-number">1.6.1.3.</span> <span class="nav-text">1.6.1.3 线程调度和优先级</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-6-1-4-可抢占线程和不可抢占线程"><span class="nav-number">1.6.1.4.</span> <span class="nav-text">1.6.1.4 可抢占线程和不可抢占线程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-6-1-5-Linux的多线程"><span class="nav-number">1.6.1.5.</span> <span class="nav-text">1.6.1.5 Linux的多线程</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-6-2-线程安全"><span class="nav-number">1.6.2.</span> <span class="nav-text">1.6.2 线程安全</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-6-2-1-竞争和原子操作"><span class="nav-number">1.6.2.1.</span> <span class="nav-text">1.6.2.1 竞争和原子操作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-6-2-2-同步与锁"><span class="nav-number">1.6.2.2.</span> <span class="nav-text">1.6.2.2 同步与锁</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-6-2-3-可重入-Reentrant-与线程安全"><span class="nav-number">1.6.2.3.</span> <span class="nav-text">1.6.2.3 可重入( Reentrant)与线程安全</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-6-2-4-过度优化"><span class="nav-number">1.6.2.4.</span> <span class="nav-text">1.6.2.4 过度优化</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-6-3-多线程内部情况"><span class="nav-number">1.6.3.</span> <span class="nav-text">1.6.3 多线程内部情况</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-6-3-1-三种线程模型"><span class="nav-number">1.6.3.1.</span> <span class="nav-text">1.6.3.1 三种线程模型</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#​编译和链接"><span class="nav-number">2.</span> <span class="nav-text">​编译和链接</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-被隐藏了的过程"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 被隐藏了的过程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-1-预处理-预编译"><span class="nav-number">2.1.1.</span> <span class="nav-text">2.2.1 预处理(预编译)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-2-编译"><span class="nav-number">2.1.2.</span> <span class="nav-text">2.1.2 编译</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-3-汇编"><span class="nav-number">2.1.3.</span> <span class="nav-text">2.1.3 汇编</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-4-链接"><span class="nav-number">2.1.4.</span> <span class="nav-text">2.1.4 链接</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-编译器做了什么"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 编译器做了什么?</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-1-词法分析-扫描"><span class="nav-number">2.2.1.</span> <span class="nav-text">2.2.1 词法分析(扫描)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-2-语法分析"><span class="nav-number">2.2.2.</span> <span class="nav-text">2.2.2 语法分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-3-语义分析"><span class="nav-number">2.2.3.</span> <span class="nav-text">2.2.3 语义分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-4-中间语言生成-源代码优化"><span class="nav-number">2.2.4.</span> <span class="nav-text">2.2.4 中间语言生成(源代码优化)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-5-代码生成与优化"><span class="nav-number">2.2.5.</span> <span class="nav-text">2.2.5 代码生成与优化</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-链接年龄比编译器长"><span class="nav-number">2.3.</span> <span class="nav-text">2.3 链接年龄比编译器长</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-模块拼装——静态链接"><span class="nav-number">2.4.</span> <span class="nav-text">2.4 模块拼装——静态链接</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#目标文件里有什么"><span class="nav-number">3.</span> <span class="nav-text">目标文件里有什么</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-目标文件的格式"><span class="nav-number">3.1.</span> <span class="nav-text">3.1  目标文件的格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-目标文件是什么样的"><span class="nav-number">3.2.</span> <span class="nav-text">3.2 目标文件是什么样的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-挖掘-SimpleSection-o"><span class="nav-number">3.3.</span> <span class="nav-text">3.3 挖掘 SimpleSection.o</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-1-代码段"><span class="nav-number">3.3.1.</span> <span class="nav-text">3.3.1 代码段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-2-数据段和只读数据段"><span class="nav-number">3.3.2.</span> <span class="nav-text">3.3.2 数据段和只读数据段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-3-BSS段"><span class="nav-number">3.3.3.</span> <span class="nav-text">3.3.3 BSS段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-4-其他段"><span class="nav-number">3.3.4.</span> <span class="nav-text">3.3.4 其他段</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-3-4-1-自定义段"><span class="nav-number">3.3.4.1.</span> <span class="nav-text">3.3.4.1 自定义段</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-ELF文件结构描述"><span class="nav-number">3.4.</span> <span class="nav-text">3.4 ELF文件结构描述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-1-文件头"><span class="nav-number">3.4.1.</span> <span class="nav-text">3.4.1 文件头</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-2-段表"><span class="nav-number">3.4.2.</span> <span class="nav-text">3.4.2 段表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-3-重定位表"><span class="nav-number">3.4.3.</span> <span class="nav-text">3.4.3 重定位表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-4-字符串表"><span class="nav-number">3.4.4.</span> <span class="nav-text">3.4.4 字符串表</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-链接的接口——符号"><span class="nav-number">3.5.</span> <span class="nav-text">3.5 链接的接口——符号</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-1-ELF符号表结构"><span class="nav-number">3.5.1.</span> <span class="nav-text">3.5.1 ELF符号表结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-2-特殊符号"><span class="nav-number">3.5.2.</span> <span class="nav-text">3.5.2 特殊符号</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-3-符号修饰与函数签名"><span class="nav-number">3.5.3.</span> <span class="nav-text">3.5.3 符号修饰与函数签名</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-5-3-1-c-符号修饰"><span class="nav-number">3.5.3.1.</span> <span class="nav-text">3.5.3.1 c++符号修饰</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-4-弱符号和强符号"><span class="nav-number">3.5.4.</span> <span class="nav-text">3.5.4 弱符号和强符号</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-5-4-1-弱引用和强引用"><span class="nav-number">3.5.4.1.</span> <span class="nav-text">3.5.4.1 弱引用和强引用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-调试信息"><span class="nav-number">3.6.</span> <span class="nav-text">3.6 调试信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#理解"><span class="nav-number">3.7.</span> <span class="nav-text">理解</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>
  <div id="DvelopmentTarget">     
  </div>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart" aria-hidden="false"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>

  
</div>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_uv"> 
  本站访客数<span id="busuanzi_value_site_uv"></span>人次
</span>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  


  <script type="text/javascript" src="/js/src/love.js"></script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
