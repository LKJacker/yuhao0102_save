<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zn-ch">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-center-simple.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="C++,">










<meta name="description" content="数据基本数据类型整型包括字符、短整型、整型和长整型，它们都分为有符号(singed)和无符号（皿sied）两种版本。长整型至少应该和整型一样长，而整型至少应该和短整型一样长。 字符在本质上是小整型值。缺省的char要么是signed char，要么是unsigned char，这取决于编译器，只有当程序所使用的char型变量的值位于signed char和unsigned char的交集中，这个程">
<meta name="keywords" content="C++">
<meta property="og:type" content="article">
<meta property="og:title" content="C和指针笔记1">
<meta property="og:url" content="http://yoursite.com/2020/09/04/C和指针笔记1/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="数据基本数据类型整型包括字符、短整型、整型和长整型，它们都分为有符号(singed)和无符号（皿sied）两种版本。长整型至少应该和整型一样长，而整型至少应该和短整型一样长。 字符在本质上是小整型值。缺省的char要么是signed char，要么是unsigned char，这取决于编译器，只有当程序所使用的char型变量的值位于signed char和unsigned char的交集中，这个程">
<meta property="og:locale" content="zn-ch">
<meta property="og:image" content="http://yoursite.com/img/20200826161100.png">
<meta property="og:image" content="http://yoursite.com/img/1598433687.jpg">
<meta property="og:image" content="http://yoursite.com/img/1598668146.png">
<meta property="og:image" content="http://yoursite.com/img/1598684046.png">
<meta property="og:image" content="http://yoursite.com/img/1598684046.jpg">
<meta property="og:image" content="http://yoursite.com/img/1598685148.jpg">
<meta property="og:image" content="http://yoursite.com/img/1598686875.jpg">
<meta property="og:image" content="http://yoursite.com/img/1598686941.jpg">
<meta property="og:image" content="http://yoursite.com/img/1598687123.jpg">
<meta property="og:image" content="http://yoursite.com/img/1598687150.jpg">
<meta property="og:image" content="http://yoursite.com/img/1598690605.jpg">
<meta property="og:image" content="http://yoursite.com/img/1598953892.jpg">
<meta property="og:image" content="http://yoursite.com/img/1598960562.jpg">
<meta property="og:image" content="http://yoursite.com/img/1598964423.jpg">
<meta property="og:image" content="http://yoursite.com/img/1598964923.jpg">
<meta property="og:image" content="http://yoursite.com/img/1599132186.png">
<meta property="og:image" content="http://yoursite.com/img/1599134018.jpg">
<meta property="og:image" content="http://yoursite.com/img/1599140980.jpg">
<meta property="og:image" content="http://yoursite.com/img/1599141020.jpg">
<meta property="og:image" content="http://yoursite.com/img/1599141290.jpg">
<meta property="og:image" content="http://yoursite.com/img/1599210301.jpg">
<meta property="og:image" content="http://yoursite.com/img/1599212143.jpg">
<meta property="og:image" content="http://yoursite.com/img/1599212244.jpg">
<meta property="og:image" content="http://yoursite.com/img/">
<meta property="og:image" content="http://yoursite.com/img/">
<meta property="og:image" content="http://yoursite.com/img/">
<meta property="og:image" content="http://yoursite.com/img/">
<meta property="og:image" content="http://yoursite.com/img/">
<meta property="og:image" content="http://yoursite.com/img/">
<meta property="og:image" content="http://yoursite.com/img/">
<meta property="og:updated_time" content="2020-09-04T13:29:55.626Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="C和指针笔记1">
<meta name="twitter:description" content="数据基本数据类型整型包括字符、短整型、整型和长整型，它们都分为有符号(singed)和无符号（皿sied）两种版本。长整型至少应该和整型一样长，而整型至少应该和短整型一样长。 字符在本质上是小整型值。缺省的char要么是signed char，要么是unsigned char，这取决于编译器，只有当程序所使用的char型变量的值位于signed char和unsigned char的交集中，这个程">
<meta name="twitter:image" content="http://yoursite.com/img/20200826161100.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/09/04/C和指针笔记1/">





  <title>C和指针笔记1 | Hao Yu's blog</title>
  








 
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zn-ch">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hao Yu's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">The program monkey was eaten by the siege lion.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/resume.pdf" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-mybetterhalf">
          <a href="/mybetterhalf/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>
            
            mybetterhalf
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/04/C和指针笔记1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">C和指针笔记1</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-09-04T21:29:55+08:00">
                2020-09-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h1><h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><p>整型包括字符、短整型、整型和长整型，它们都分为有符号(singed)和无符号（皿sied）两种版本。长整型至少应该和整型一样长，而整型至少应该和短整型一样长。<br><img src="/img/20200826161100.png" alt></p>
<p>字符在本质上是小整型值。缺省的char要么是<code>signed char</code>，要么是<code>unsigned char</code>，这取决于编译器，只有当程序所使用的char型变量的值位于<code>signed char</code>和<code>unsigned char</code>的交集中，这个程序才是可移植的。</p>
<p>字符串常量：书写方式是<code>&quot;Hello&quot;</code>、<code>&quot;\aWarning!\a&quot;</code>、<code>&quot;Line1\nLine2&quot;</code>，</p>
<h2 id="链接属性"><a href="#链接属性" class="headerlink" title="链接属性"></a>链接属性</h2><p>一共有三种，<strong>external</strong>、<strong>internal</strong>、<strong>none</strong>，none被当作单独的个体，该标识符的多个声明被当作独立不同的实体。属于internal链接属性的标识符在同一个源文件内的所有声明中都指向同一个实体。属于external属性的标识符不管位于几个源文件都表示同一个实体。关键字<code>external</code>和<code>static</code>用于在声明中修改标识符的链接属性，external可以访问在其他任何位置定义的这个实体。在C中，static主要<strong>定义全局静态变量、定义局部静态变量、定义静态函数</strong>。</p>
<ul>
<li>定义全局静态变量：在全局变量前面加上关键字static，该全局变量变成了全局静态变量。全局静态变量有以下特点。<ul>
<li>在全局区分配内存。</li>
<li>如果没有初始化，其默认值为0.</li>
<li>该变量在本文件内从定义开始到文件结束可见。</li>
</ul>
</li>
<li>定义局部静态变量：在局部变量前面加上关键字static，其特点如下：<ul>
<li>该变量在全局数据区分配内存。</li>
<li>它始终驻留在全局数据区，直到程序运行结束。</li>
<li>其作用域为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束。</li>
</ul>
</li>
<li>定义静态函数：在函数返回类型前加上static关键字，函数即被定义为静态函数，其特点如下：<ul>
<li>静态函数只能在本源文件中使用</li>
<li>在文件作用域中声明的inline函数默认为static类型</li>
</ul>
</li>
</ul>
<p>总结：用static定义的全局和局部静态变量的区别是，<strong>全局的静态变量的作用域和可见域都是从文件的定义开始到整个文件结束</strong>；而<strong>局部的静态变量可见域是从文件的定义开始到整个文件结束，作用域是从该语句块的定义开始到该语句块结束</strong>。</p>
<p>extern的用法：</p>
<ul>
<li>声明一个全局（外部）变量。当用extern声明一个全局变量的时候，首先应明确一点：extern的作用范围是整个工程，也就是说当我们在.h文件中写了<code>extern int a;</code>链接的时候链接器会去其他的.c文件中找有没有<code>int a</code>的定义，如果没有，链接报错；当<code>extern int a;</code>写在.c文件中时，链接器会在这个.c文件该声明语句之后找有没有<code>int a</code>的定义，然后去其他的.cpp文件中找，如果都找不到，链接报错。值得注意的一点：当extern语句出现在头文件中时，不要将声明和定义在一条语句中给出，也就是不要在头文件中写类似于这样的语句：<code>extern int a = 1;</code>，这种写法，在gcc编译时会给出一个警告：<code>warning: &#39;a&#39; initialized and declared &#39;extern&#39;</code>， </li>
<li>所有一般（提倡）的做法是：<strong>只在头文件中通过extern给出全局变量的声明（即external int a; 而不要写成external int a = 1;），并在源文件中给出定义（并且只能定义一次）</strong></li>
<li><code>extern “C” { /*用C实现的内容（通常写在另外的.c文件中）*/ }</code>。C++完全兼容C，当extern与“C”连用时，作用是告诉编译器用C的编译规则去解析extern “C”后面的内容。最常见的差别就是C++支持函数重载，而标准C是不支持的。如果不指明<code>extern “C”</code>，C++编译器会根据自己的规则在编译函数时为函数名加上特定的后缀以区别不同的重载版本，而如果是按C的标准来编译的话，则不需要。</li>
</ul>
<p>static和external定义的全局变量区别：</p>
<ul>
<li>static修饰全局变量时，声明和定义是同时给出的；而extern一般是定义和声明分开，且定义只能一次</li>
<li>static的全局作用域只是自身编译单元（即一个.c文件以及这个.c文件所包含的.h文件）；而extern的全局作用域是整个工程（一个工程可以包含很多个.h和.c文件）。即区别就在于“全局”的范围是整个工程，还是自身编译单元。</li>
</ul>
<h2 id="存储类型"><a href="#存储类型" class="headerlink" title="存储类型"></a>存储类型</h2><p>变量的存储类型(storagecs）是指<strong>存储变量值的内存类型</strong>。变量的存储类型决定变量何时创建、何时销毁以及它的值将保持多久。有三个地方可以用于存储变量：<strong>普通内存</strong>、<strong>运行时堆栈</strong>、<strong>硬件寄存器</strong>。凡是在任何代码块之外声明的变量总是存储于静态内存中，也就是不属于堆栈的内存，这类变量称为<strong>静态（static）变量</strong>。静态变量在程序运行之前创建，在程序的整个执行期间始终存在。它始终保持原先的值，除非给它赋一个不同的值或者程序结束。</p>
<p>在代码块内部声明的变量的缺省存储类型是<strong>自动</strong>(automatic),也就是说它<strong>存储于堆栈中</strong>，称为自动（auto）变量。在程序执行到声明自动变量的代码块时，自动变量才被创建，当程序的执行流离开该代码块时，这些自动变量便自行销毁。如果该代码块被数次执行，这些自动变量每次都将重新创建。对于在代码块内部声明的变量，如果给它加上关键字<code>static</code>，可以使它的存储类型从自动变为静态。<strong>具有静态存储类型的变量在整个程序执行过程中一直存在，而不仅仅在声明它的代码块的执行时存在</strong>。<strong>函数的形式参数不能声明为静态</strong>，因为实参总是在堆栈中传递给函数，用于支持递归。最后，关键字<code>register</code>可以用于自动变量的声明，提示它们应该存储于机器的硬件寄存器而不是内存中，这类变量称为<strong>寄存器变量</strong>。通常，寄存器变量比存储于内存的变量访问起来效率更高。</p>
<h2 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h2><p>当它用于函数定义时，或用于代码块之外的变量声明时，static关键字用于修改标识符的链接属性，从external到internal，但标识符的存储类型和作用域不受影响。当它用于代码块内部的变量声明时，static关键字用于修改变量的存储类型，从自动变量修改为静态变量，但变量的链接属性和作用域不受影响。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>具有external链接属性的实体在其他语言的术语中成为全局实体，所有源文件中的所有函数均可以访问它。只要变量并非声明于代码块或函数定义内部，它在缺省情况下的链接属性即为external。如果一个变量声明于代码块内部，在它前面添加extern关键字将使它所引用的是全局变量而非局部变量。</p>
<p>具有extemal链接属性的实体总是具有静态存储类型。全局变量在程序开始执行前创建，并在程序整个执行过程中始终存在。从属于函数的局部变量在函数开始执行时创建，在函数执行完毕后销毁，但用于执行函数的机器指令在程序的生命期内一直存在。局部变量由函数内部使用，不能被其他函数通过名字引用。它在缺省情况下的存储类型为自动，这是基于两个原因：其一，当这些变量需要时才为它们分配存储，这样可以减少内存的总需求量。其二，在堆栈上为它们分配存储可以有效地实现递归。如果你觉得让变量的值在函数的多次调用中始终保持原先的值非常重要的话，你可以修改它的存储类型，把它从自动变量改为静态变量。<br><img src="/img/1598433687.jpg" alt></p>
<h1 id="操作符和表达式"><a href="#操作符和表达式" class="headerlink" title="操作符和表达式"></a>操作符和表达式</h1><h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><p>移位操作简单地把一个值的位向左或向右移动。在左移位中，值最左边的几位被丢弃掉，右边多出来的几个空位则由0补齐。算术左移和逻辑左移是一样的。右移位时，一种是逻辑移位，左边移入的位用0填充，另一种是算术移位，左边移入的位由原先的符号位决定，保证原数的正负形式不变。<br><img src="/img/1598668146.png" alt></p>
<p>无符号值的所有移位操作都是逻辑移位，对于有符号值，采用逻辑移位还是算术移位取决于编译器。</p>
<p>第一个把指定的位设置为1：<code>value = value | 1 &lt;&lt; bit_number</code>，第二个把指定的位清0：<code>value = value &amp; ~ (1 &lt;&lt; bit_number)</code>。</p>
<p>前缀和后缀形式的增值操作符都是复制一份变量值的拷贝，用于递增表达式的值正是这份拷贝，前缀操作符在进行复制之前增加变量的值，后缀操作符在进行复制之后才增加变量的值。这些操作符的结果是<strong>变量值的拷贝</strong>。</p>
<p>逻辑操作符（&amp;&amp;和||）具有短路性质，如果表达式的值根据左操作数即可决定，它就不再对右操作数进行求值。</p>
<h2 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h2><p>零是假，任何非零值皆为真。</p>
<h2 id="左值和右值"><a href="#左值和右值" class="headerlink" title="左值和右值"></a>左值和右值</h2><p>左值就是能够出现在赋值符号左边的东西，右值就是能够出现在赋值符号右边的东西。如<code>a = b + 25</code>，a是个左值，因为它表示了一个可以存储结果值的地点，b + 25是个右值，因为它指定了一个值。</p>
<h2 id="表达式求值"><a href="#表达式求值" class="headerlink" title="表达式求值"></a>表达式求值</h2><h3 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h3><p>C的整形算术运算至少以缺省整型类型的精度来进行，为了达到这个精度，表达式中的字符型和短整型操作数在使用之前需要被转换成普通整型。如果某个操作符的各个操作数属于不同类型，那么一个操作数转换为另一个操作数的类型。</p>
<h3 id="操作符的属性"><a href="#操作符的属性" class="headerlink" title="操作符的属性"></a>操作符的属性</h3><p>两个相邻的操作符哪个先执行取决于它们的优先级，如果优先级相同，则执行顺序由结合性决定。每个操作符的所有属性都在优先级表中。<br><img src="/img/1598684046.png" alt><br><img src="/img/1598684046.jpg" alt></p>
<h2 id="警告"><a href="#警告" class="headerlink" title="警告"></a>警告</h2><p>有操作符的右移位操作是不可移植的。移位操作的位数不可以是个负值。连续赋值中各个变量的长度需要一致。</p>
<h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><h2 id="内存和地址"><a href="#内存和地址" class="headerlink" title="内存和地址"></a>内存和地址</h2><p>尽管一个字包含了4个字节，但是它仍然只有一个地址，至于它的地址是最左边的字节的位置还是最右边的字节的位置，取决于机器。另一个需要注意的是<strong>边界对齐</strong>，整型值存储的起始位置只能是某些特定的字节，通常是2或4的倍数。硬件仍然通过地址访问内存位置。</p>
<h2 id="值和类型"><a href="#值和类型" class="headerlink" title="值和类型"></a>值和类型</h2><p>不能简单地通过检查一个值的位来判断它的类型，必须观察这个值的使用方式。比如<code>01100111011011000110111101100010</code>这个值，可能被解释成多种：<br><img src="/img/1598685148.jpg" alt></p>
<h2 id="间接访问操作符"><a href="#间接访问操作符" class="headerlink" title="间接访问操作符"></a>间接访问操作符</h2><p>通过指针访问所指向的地址的过程称为<strong>间接访问</strong>或<strong>解引用指针</strong>，这个用于执行间接访问的操作符是<code>*</code>。</p>
<h2 id="未初始化和非法的指针"><a href="#未初始化和非法的指针" class="headerlink" title="未初始化和非法的指针"></a>未初始化和非法的指针</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *a;</span><br><span class="line">*a = <span class="number">12</span>;</span><br></pre></td></tr></table></figure>
<p>这个声明创建了一个名叫a的指针变量，后边那条赋值语句把12存储在a所指的内存位置，但是不知道a具体指向的位置，声明一个指向int的指针也不会创建用于存储整型值的空间。在UNIX中，这个错误被称为<strong>段违例（segmentation violation）</strong>，它提示程序试图访问一个并未分配给程序的内存位置。</p>
<h2 id="指针常量"><a href="#指针常量" class="headerlink" title="指针常量"></a>指针常量</h2><p>NULL表示指针未指向任何东西。</p>
<p><code>*100 = 25</code>是错误的，间接访问操作只能作用于指针类型表达式，如果确实想把25存于位置100，需要使用强制类型转换<code>*(int*)100 = 25</code>。</p>
<h2 id="指针表达式"><a href="#指针表达式" class="headerlink" title="指针表达式"></a>指针表达式</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> ch = <span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">char</span> *cp = &amp;ch;</span><br></pre></td></tr></table></figure>
<p>如<code>ch</code>表达式，当它作为右值使用时，表达式的值为<code>&#39;a&#39;</code>，当这个表达式作为左值使用时，它是这个内存的地址而不是该地址所包含的值。</p>
<p>作为右值，这个表达式的值是变量ch的地址。<br><img src="/img/1598686875.jpg" alt></p>
<p>*的优先级高于+，所以首先执行间接访问操作，可以得到它的值，取这个值的一份拷贝并把它与1相加，最终结果是’b’，<br><img src="/img/1598686941.jpg" alt></p>
<p><img src="/img/1598687123.jpg" alt><br><img src="/img/1598687150.jpg" alt></p>
<p>使用后缀++操作符产生的结果不同，它的右值和左值分别是变量ch的值和ch的内存位置，也就是cp原先所指。间接访问操作符和后缀++的组合令人费解，这里涉及三个步骤：</p>
<ul>
<li>++操作符产生cp的一份拷贝</li>
<li>++操作符增加cp的值</li>
<li>在cp的拷贝上执行间接访问</li>
</ul>
<p>当一个指针和一个整数量执行算术运算时，整数在执行加法运算前始终会根据<strong>指针所指向类型的大小</strong>进行调整，“调整”就是把整数值和“合适的大小”相乘。如果两个指针所指向的不是同一个数组的元素，那么他们之间相减的结果是未定义的，如果是，则结果为两个指针之间的距离。<br><img src="/img/1598690605.jpg" alt></p>
<p>对指针执行关系运算也是有限制的，用关系操作符对两个指针值进行比较是可能的，不过前提是他们指向同一个数组的元素。下边的循环使数组以相反的次序清除，让vp指向数组最后那个元素后边的内存位置，但在对它进行间接访问之前先执行自减操作，当vp指向数组第一个元素时，循环便告终止，不过这发生在第一个数组元素被清除之后。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(vp = &amp;value[N_VALUE]; vp &gt; &amp;value[<span class="number">0</span>];)</span><br><span class="line">    *--vp = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></p>
<p>如果对其简化，现在vp指向数组最后一个元素，它的自减操作放在for的调整部分执行，在第一个元素被清除之后，vp的值还将减去1，而接下去的一次比较是用于结束循环的，比较表达式<code>vp &gt;= &amp;value[0]</code>的值未定义，因为vp移动到了数组边界之外。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(vp = &amp;value[N_VALUE<span class="number">-1</span>]; vp &gt;= &amp;value[<span class="number">0</span>]; vp --)</span><br><span class="line">    *vp = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></p>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h2><p>C函数的所有参数均以<strong>传值调用</strong>方式进行传递，这意味着函数将<strong>获得参数值的一份拷贝</strong>。如果被传递的参数是一个数组名，函数将访问调用程序的数组元素，数组并不会被复制。这个行为被称为<strong>传址调用</strong>。数组名的值实际上是一个指针，<strong>传递给函数的就是这个指针的一份拷贝</strong>。下标引用实际上是间接访问的另一种形式，它可以对指针执行间接访问操作，访问指针指向的内存位置。只要记住两个规则：</p>
<ol>
<li>传递给函数的标量参数是传值调用的。</li>
<li>传递给函数的数组参数在行为上就像它们是通过传址调用的那样。</li>
</ol>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="指针的效率"><a href="#指针的效率" class="headerlink" title="指针的效率"></a>指针的效率</h2><ol>
<li>当你根据某个固定数目的增量在一个数组中移动时，<strong>使用指针变量将比使用下标产生效率更高的代码</strong>。当这个增量是1并且机器具有地址自动增量模型时，这点表现得更为突出。</li>
<li>声明为寄存器变量的指针通常比位于静态内存和堆栈中的指针效率更高（具体提高的幅度取决于你所使用的机器）。</li>
<li>如果你可以通过测试一些己经初始化并经过调整的内容来判断循环是否应该终止，那么你就不需要使用一个单独的计数器。</li>
<li>那些必须在运行时求值的表达式较之诸如<code>&amp;array[SIZE]</code>或<code>array+SIZE</code>这样的常量表达式往往代价更高。</li>
</ol>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><h3 id="静态和自动初始化"><a href="#静态和自动初始化" class="headerlink" title="静态和自动初始化"></a>静态和自动初始化</h3><p>数组初始化的方式取决于它们的存储类型。<strong>存储于静态内存的数组只初始化一次</strong>，也就是在程序开始执行之前。程序并不需要执行指令把这些值放到合适的位置，这由链接器完成的，它用包含可执行程序的文件中合适的值对数组元素进行初始化。如果数组未被初始化，数组元素的初始值将会自动设置为零。当这个文件载入到内存中准备执行时，初始化后的数组值和程序指令一样也被载入到内存中。自动变量在缺省情况下是未初始化的。如果自动变量的声明中给出了初始值，则每次执行流执行到这里时都会初始化。</p>
<p>如果初始化不完整，如<code>int vector[5] = {1, 2, 3}</code>，则之后的元素都会被初始化为0。如果声明中没有给出长度，编译器就把数组的长度设置为刚好容纳所有的初始值的长度。</p>
<p><code>char message1[] = &quot;hello&quot;</code>和<code>char *message2 = &quot;hello&quot;</code>具有不同的含义，前者初始化一个字符数组的元素，后者则是一个真正的字符串常量。</p>
<h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>C中，多维数组的元素存储按照最右边的下标率先变化的原则，称为<strong>行主序</strong>。作为函数参数的多维数组的实际传递的是个指向数组第一个元素的指针，但是编译器需要知道维数。如<code>void func(int matrix[][10])</code>，</p>
<h1 id="字符串、字符和字节"><a href="#字符串、字符和字节" class="headerlink" title="字符串、字符和字节"></a>字符串、字符和字节</h1><h2 id="不受限制的字符串函数"><a href="#不受限制的字符串函数" class="headerlink" title="不受限制的字符串函数"></a>不受限制的字符串函数</h2><p>常用的字符串函数都是“不受限制”的，只是通过寻找字符串参数结尾的NULL字节来判断长度。必须保证字符串不会溢出。如<code>strcmp</code>，<code>strcpy</code>，<code>strcat</code>。标准库还包含了一类函数，接收一个显式的长度参数用于限定进行复制或比较的字符数，如<code>strncmp</code>，<code>strncpy</code>，<code>strncat</code>。</p>
<p>和<code>strcpy</code>一样，<code>strncpy</code>把源字符串的字符复制到目标数组。然而，它总是正好向dst写入len个字符。如果<code>strlen(src0)</code>的值小于len，dst数组就用额外的NUL字节填充到len长度。如果<code>strlen(src)</code>的值大于或等于len，那么只有len个字符被复制到dst中。<strong>注意！它的结果将不会以NUL字节结尾</strong>。</p>
<h2 id="字符串查找基础"><a href="#字符串查找基础" class="headerlink" title="字符串查找基础"></a>字符串查找基础</h2><p>在字符串中查找字符最简单的方法是<code>char *strchr(char const *str, int ch)</code>或<code>char *strrchr(char const *str, int ch)</code>，在str中查找ch第一次出现的位置。<code>strrchr</code>返回最后一次出现的位置。</p>
<p><code>strpbrk</code>查找任何一组字符第一次在字符串中出现的位置，<code>char *strpbrk(char const *str, char const *group)</code>，返回一个指向str中第一个匹配group中任何一个字符的字符位置。<code>strstr</code>查找s1在整个s2中第一次出现的位置。</p>
<h2 id="高级字符串查找"><a href="#高级字符串查找" class="headerlink" title="高级字符串查找"></a>高级字符串查找</h2><p><code>strspn</code>和<code>strcspn</code>用于在字符串的起始位置对字符计数，计算字符串str中连续有几个字符都属于字符串accept，原型为<code>size_t strspn(const char *str, const char * accept);</code>。</p>
<ul>
<li>【函数说明】strspn() 从参数 str 字符串的开头计算连续的字符，而这些字符都完全是 accept 所指字符串中的字符。简单的说，若 strspn() 返回的数值为n，则代表字符串 str 开头连续有 n 个字符都是属于字符串 accept 内的字符。</li>
<li><p>【返回值】返回字符串 str 开头连续包含字符串 accept 内的字符数目。所以，如果 str 所包含的字符都属于 accept，那么返回 str 的长度；如果 str 的第一个字符不属于 accept，那么返回 0。</p>
</li>
<li><p>注意：检索的字符是区分大小写的。</p>
</li>
<li>提示：函数 strcspn() 的含义与 strspn() 相反，可以对比学习。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">char</span> str[] = <span class="string">"129th"</span>;</span><br><span class="line">  <span class="keyword">char</span> accept[] = <span class="string">"1234567890"</span>;</span><br><span class="line">  i = <span class="built_in">strspn</span>(str, accept);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"str 前 %d 个字符都属于 accept\n"</span>,i);</span><br><span class="line">  system(<span class="string">"pause"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>执行结果：<code>str 前 3 个字符都属于 accept</code></p>
<p>C语言<code>strcspn()</code>函数：计算字符串str中连续有几个字符都不属于字符串accept，头文件：<code>#inclued&lt;string.h&gt;</code>。strcspn() 用来计算字符串 str 中连续有几个字符都不属于字符串 accept，其原型为：<code>int strcspn(char *str, char *accept);</code></p>
<ul>
<li>【参数说明】str、accept为要进行查找的两个字符串。strcspn() 从字符串 str 的开头计算连续的字符，而这些字符都完全不在字符串 accept 中。简单地说，若 strcspn() 返回的数值为 n，则代表字符串 str 开头连续有 n 个字符都不含字符串 accept 中的字符。</li>
<li>【返回值】返回字符串 str 开头连续不含字符串 accept 内的字符数目。</li>
<li>注意：如果 str 中的字符都没有在 accept 中出现，那么将返回 atr 的长度；检索的字符是区分大小写的。</li>
<li>提示：函数 strspn() 的含义与 strcspn() 相反，可以对比学习。</li>
</ul>
<p>【示例】返回s1、s2包含的相同字符串的位置。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span>* s1 = <span class="string">"http://c.biancheng.net/cpp/u/biaozhunku/"</span>;</span><br><span class="line">  <span class="keyword">char</span>* s2 = <span class="string">"c is good"</span>;</span><br><span class="line">  <span class="keyword">int</span> n = <span class="built_in">strcspn</span>(s1,s2);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"The first char both in s1 and s2 is :%c\n"</span>,s1[n]); </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"The position in s1 is: %d\n"</span>,n);</span><br><span class="line">  system(<span class="string">"pause"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>strtok</code>从字符串中隔离各个单独的称为标记的部分，并丢弃分隔符。<code>char * strtok(char *s, const char *delim);</code>strtok()用来将字符串分割成一个个片段。参数s 指向欲分割的字符串，参数delim 则为分割字符串，当strtok()在参数s 的字符串中发现到参数delim 的分割字符时则会将该字符改为\0 字符。在第一次调用时，strtok()必需给予参数s 字符串，往后的调用则将参数s 设置成NULL。每次调用成功则返回下一个分割后的字符串指针。</p>
<p>返回值：返回下一个分割后的字符串指针，如果已无从分割则返回NULL。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line">main()&#123;</span><br><span class="line">    <span class="keyword">char</span> s[] = <span class="string">"ab-cd : ef;gh :i-jkl;mnop;qrs-tu: vwx-y;z"</span>;</span><br><span class="line">    <span class="keyword">char</span> *delim = <span class="string">"-: "</span>;</span><br><span class="line">    <span class="keyword">char</span> *p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s "</span>, strtok(s, delim));</span><br><span class="line">    <span class="keyword">while</span>((p = strtok(<span class="literal">NULL</span>, delim)))</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s "</span>, p);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="字符操作"><a href="#字符操作" class="headerlink" title="字符操作"></a>字符操作</h2><p>以下函数位于<code>ctype.h</code>中。<br><img src="/img/1598953892.jpg" alt></p>
<p>转换函数用于把大写字符转化为小写，<code>tolower</code>和<code>toupper</code>。</p>
<h2 id="内存操作"><a href="#内存操作" class="headerlink" title="内存操作"></a>内存操作</h2><p>非字符串数据内部包含0值时，无法用字符串函数来处理。不过可以使用另一组相关的函数，他们的操作与字符串函数类似。</p>
<ul>
<li><code>void *memcpy(void *dst, void const *src, size_t length)</code>从src的起始位置复制length个字节到dst的内存起始位置。</li>
<li><code>void *memmove(void *dst, void const *src, size_t length)</code>和memcpy的行为差不多，不过它的源和目标操作数可以重叠。</li>
<li><code>void *memcmp(void const *a, void const *b, size_t length)</code>对两端内存的内容进行比较，这些值按照无符号字符逐字节比较。</li>
<li><code>void *memchr(void const *a, int ch, size_t length)</code>从a的起始位置开始查找字符ch第一次出现的位置，并返回一个指向该位置的指针。</li>
<li><code>void *memset(void *a, int ch, size_t length)</code>把从a开始的length个字节都设置为字符值ch。</li>
</ul>
<h1 id="结构和联合"><a href="#结构和联合" class="headerlink" title="结构和联合"></a>结构和联合</h1><h2 id="结构的存储分配"><a href="#结构的存储分配" class="headerlink" title="结构的存储分配"></a>结构的存储分配</h2><p>考虑这个结构<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ALIGN</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>如果某机器的整型值长度为4个字节，并且它的起始存储位置必须被4整除，那么这个结构在内存中将如下：<br><img src="/img/1598960562.jpg" alt></p>
<p>所有结构起始存储位置必须是结构中边界要求最严格的数据类型所要求的。成员a必须存储于一个能被4整除的地址。下一个成员是整型值，所以必须跳过3个字节到达合适的边界。可以在声明中对结构的成员列表重新排列，让那些<strong>对边界要求最严格的成员首先出现</strong>。</p>
<p><code>sizeof</code>操作符能够得出一个结构的整体长度，包括因边界对齐而跳过的那些字节。如果你必须确定结构某个成员的实际位置，应该考虑边界对齐因素，可以使用<code>offsetof</code>宏（定义于stddef.h)。<code>offsetof(type,member)</code>，type就是结构的类型，member就是你需要的那个成员名。表达式的结果是一个size_t值，表示这个指定成员开始存储的位置距离结构开始存储的位置偏移几个字节。例如，对前面那个声明而言<code>offsetof(struct ALIGN, b)</code>的返回值是4。</p>
<h2 id="位段"><a href="#位段" class="headerlink" title="位段"></a>位段</h2><p>位段的成员是一个或多个位的字段，让这些不同长度的字段其实存在于一个或多个整型变量中。位段成员必须声明为<code>int</code>，<code>signed int</code>，<code>unsigned int</code>三种，其次，在成员名后边是一个冒号和一整数，整数指定为该位段所占用的位的数目。</p>
<p>注重可移植性的程序应该避免使用位段。由于下面这些与实现有关的依赖性，位段在不同的系统中可能有不同的结果。</p>
<ol>
<li>int位段被当作有符号数还是无符号数。</li>
<li>位段中位的最大数目。许多编译器把位段成员的长度限制在一个整型值的长度之内，所以一个能够运行于32位整数的机器上的位段声明可能在16位整数的机器上无法运行。</li>
<li>位段中的成员在内存中是从左向右分配的还是从右向左分配的。</li>
<li>当一个声明指定了两个位段，第2个位段比较大，无法容纳于第1个位段剩余的位时，编译器有可能把第2个位段放在内存的下一个字，也可能直接放在第1个位段后面，从而在两个内存位置的边界上形成重叠。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CHAR</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> ch : <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> font : <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> size : <span class="number">19</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>位段能够利用存储ch和font所剩余的位来增加size的位数，这样避免了声名一个32位的整数来存储size位段。它也可以很方便的访问一个整型值的部分内容。假定磁盘控制器其中一个寄存器是如下定义的：<br><img src="/img/1598964423.jpg" alt></p>
<p>前五个位段每个都占1位，其余几个位段长些，在一个从右向左分配位段的机器上，下面这个声明允许方便地对寄存器的不同位段进行访问：<br><img src="/img/1598964923.jpg" alt></p>
<h1 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a>动态内存分配</h1><h2 id="malloc和free"><a href="#malloc和free" class="headerlink" title="malloc和free"></a>malloc和free</h2><p>C函数库提供了两个函数，<code>malloc</code>和<code>free</code>，分别用于<strong>执行动态内存分配和释放</strong>。这些函数维护一个可用内存池。malloc从内存池中提取一块合适的内存，并向该程序返回一个指向这块内存的指针。当一块以前分配的内存不再使用时，程序调用free函数把它归还给内存池供以后之需。<br><code>void* malloc(size_t size)</code>的参数就是需要分配的内存字节（字符）数。如果内存池中的可用内存可以满足这个需求，malloc就返回一个指向被分配的内存块起始位置的指针。<strong>maloc所分配的是一块连续的内存</strong>。如果内存池的可用内存无法满足你的请求，malloc函数向操作系统请求，要求得到更多的内存，并在这块新内存上执行分配任务。如果操作系统无法向malloc提供更多的内存，maloc就返回一个NULL指针。因此，<strong>对每个从malloc返回的指针都进行检查，确保它并非NULL是非常重要的</strong>。</p>
<p><code>void free(void *pointer)</code>的参数必须要么是NULL，要么是一个先前从malloc、calloc或realloc（稍后描述）返回的值。向free传递一个NULL参数不会产生任何效果。</p>
<p>对于要求边界对齐的机器，malloc所返回的内存的起始位置将始终能够满足对边界对齐要求最严格的类型的要求。</p>
<h2 id="calloc和realloc"><a href="#calloc和realloc" class="headerlink" title="calloc和realloc"></a>calloc和realloc</h2><p>另外还有两个内存分配函数，calloc和realloco它们的原型如下所示：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">calloc</span><span class="params">(<span class="keyword">size_t</span> num_elements, <span class="keyword">size_t</span> element_size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">realloc</span><span class="params">(<span class="keyword">void</span>* ptr, <span class="keyword">size_t</span> new_size)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>calloc也用于分配内存，在返回指向内存的指针之前把它初始化为0。realloc用于修改一个原先已经分配的内存块的大小，如果它用于扩大一个内润康，那么这块内存原先的内容依然保留，新添加的内存块在原先内存块后边，如果原先内存块无法改变大小，realloc会分配另一块正确大小的内存。</p>
<p>动态内存分配最常见的错误就是忘记检查所请求的内存是否成功分配。动态内存分配的第二大错误来源是操作内存时超出了分配内存的边界。例如，如果你得到一个25个整型的数组，进行下标引用作时如果下标值小于0或大于24将引起两种类型的问题。</p>
<ul>
<li>第1种问题显而易见：被访问的内存可能保存了其他变量的值。对它进行修改将破坏那个变量，修改那个变量将破坏你存储在那里的值。这种类型的bug非常难以发现。</li>
<li>第2种问题不是那么明显。在malloc和free的有些实现中，它们以链表的形式维护可用的内存池。对分配的内存之外的区域进行访问可能破坏这个链表，这有可能产生异常，从而终止程序。</li>
</ul>
<p>动态分配的内存不再需要时，它应该被释放，分配内存但在使用完毕后不释放将引起内存泄漏。</p>
<h1 id="预处理器"><a href="#预处理器" class="headerlink" title="预处理器"></a>预处理器</h1><h2 id="预定义符号"><a href="#预定义符号" class="headerlink" title="预定义符号"></a>预定义符号</h2><p>预处理器定义了一些符号：<br><img src="/img/1599132186.png" alt></p>
<h2 id="define"><a href="#define" class="headerlink" title="#define"></a><code>#define</code></h2><p><code>#define</code>的正式描述为<code>#define name stuff</code>，每当有符号name出现在这条指令之后时，预处理器就会把它替换为stuff。如果定义中的stuff很长，可以加上<code>\</code>：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG_PRINT printf(<span class="meta-string">"File %s line %d"</span> \</span></span><br><span class="line">                            <span class="string">"x = %d, y = %d, z = %d"</span>, \</span><br><span class="line">                            __FILE__, __LINE__, \</span><br><span class="line">                            x, y, z)</span><br></pre></td></tr></table></figure></p>
<p><code>#define</code>机制包括了一个规定，允许把参数替换到文本中，这种方法叫做<strong>宏</strong>，所有用于对数值表达式进行求值的宏定义都应该加上括号，避免使用宏时参数中的操作符或邻近的操作符之间的相互作用。</p>
<p><strong>**</strong> 识别结果 1<strong>**</strong></p>
<p>在程序中扩展<code>#define</code>定义符号和宏时，需要涉及儿个步骤。</p>
<ol>
<li>在调用宏时，首先对参数进行检查，看看是否包含了任何由<code>#define</code>定义的符号。如果是，它们首先被替换。</li>
<li>替换文本随后被插入到程序中原来文本的位置。对于宏，参数名被它们的值所替代。</li>
<li>最后，再次对结果文本进行扫描，看看它是否包含了任何由<code>#define</code>定义的符号。如果是，就重复上述处理过程。</li>
</ol>
<p>这样，宏参数和<code>#define</code>定义可以包含其他<code>#define</code>定义的符号。但是，宏不可以出现递归。当预处理器搜索<code>#define</code>定义的符号时，字符串常量的内容并不进行检查。你如果想把宏参数插入到字符串常量中，可以使用两种技巧。</p>
<ul>
<li>首先，邻近字符串自动连接的特性使我们很容易把一个字符串分成几段，每段实际上都是一个宏参数。</li>
<li>使用预处理器把一个宏参数转换为一个字符串，<code>#argument</code>这种结构会被预处理器翻译为<code>argument</code>：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRINT(FORMAT, VALUE)   \</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"The value of #VALUE  \</span></span><br><span class="line"><span class="string">        "</span> is <span class="string">" FORMAT "</span>\n<span class="string">", VALUE)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">PRINT("</span>%d<span class="string">", x + 3);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">生成：</span></span><br><span class="line"><span class="string">The value of x + 3 is 25</span></span><br></pre></td></tr></table></figure>
<p><code>##</code>结构把位于两边的符号连接成一个符号，允许宏定义从分离的文本片段创建标识符。</p>
<p><img src="/img/1599134018.jpg" alt></p>
<p>许多C编译器允许在命令行中定义符号，用于启动编译过程，在UNIX编译器中，<code>-D</code>可以完成，如<code>-Dname</code>和<code>-Dname=stuff</code>。</p>
<h2 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h2><p>条件编译可以选择代码的一部分是被正常编译还是完全忽略。用于支持条件编译的基本结构是<code>#if</code>指令和与其匹配的<code>#endif</code>指令。下面显示了它最简单的语法形式。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> constant-expression</span></span><br><span class="line">    statements</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>其中，constant-expression（常量表达式）由预处理器进行求值。如果它的值是非零值（真），那么statements部分就被正常编译，否则预处理器就安静地删除它们。所谓常量表达式，就是说它或者是字面值常量，或者是一个由<code>#define</code>定义的符号。如果变量在执行期之前无法获得它们的值，那么它们如果出现在常量表达式中就是非法的，因为它们的值在编译时是不可预测的。</p>
<p><code>#include</code>指令用于实现文件包含。它具有两种形式。</p>
<ul>
<li>如果文件名位于一对尖括号中，编译器将在由编译器定义的标准位置查找这个文件。这种形式通常用于包含函数库头文件时。</li>
<li>另一种形式，文件名出现在一对双引号内。不同的编译器可以用不同的方式处理这种形式。</li>
<li>但是，如果用于处理本地头文件的任何特殊处理方法无法找到这个头文件，那么编译器接下来就使用标准查找过程来寻找它。</li>
</ul>
<p><code>#error</code>指令在编译时产生一条错误信息，信息中包含的是你所选择的文本。<code>#line</code>指令允许你告诉编译器下一行输入的行号，如果它加上了可选内容，它还将告诉编译器输入源文件的名字。因编译器而异的<code>#progma</code>指令允许编译器提供不标准的处理过程，比如向一个函数插入内联的汇编代码。</p>
<h1 id="输入输出函数"><a href="#输入输出函数" class="headerlink" title="输入输出函数"></a>输入输出函数</h1><h2 id="错误报告"><a href="#错误报告" class="headerlink" title="错误报告"></a>错误报告</h2><p>perror函数可以报告错误。原型是<code>void perror(char const * msg)</code>，如果msg不是NULL并且指向一个非空的字符串，perror会打印出这个字符串，并打印当前错误代码的信息。</p>
<p>另一个有用的函数是exit，它用于终止一个程序的执行。它的原型定义于<code>stdlib.h</code>，如下所示：<code>void exit(int status)</code>，status参数返回给操作系统，用于提示程序是否正常完成。这个值和main函数返回的整型状态值相同。预定义符号<code>EXIT_SUCCESS</code>和<code>EXIT_FAILURE</code>分别提示程序的终止是成功还是失败。这个函数没有返回值。当exit函数结束时，程序己经消失，所以它无处可返。</p>
<h2 id="标准IO函数库"><a href="#标准IO函数库" class="headerlink" title="标准IO函数库"></a>标准IO函数库</h2><p>K&amp;R C最早的编译器的函数库在支持输入和输出方面功能甚弱。其结果是，程序员如果需要使用比函数库所提供的I/O更为复杂的功能时，他不得不自己实现。<br>有了标准I/O函数之后，这种情况得到了极大的改观。标准IO函数库具有一组IO函数，实现了在原先的IO库基础上许多程序员自行添加实现的额外功能。这个函数库对现存的函数进行了扩展，例如为printf创建了不同的版本，可以用于各种不同的场合。</p>
<p>头文件<code>stdio.h</code>包含了与ANSI函数库的I/O部分有关的声明。ANSI进一步对IO的概念进行了抽象。就C程序而言，所有的1/0操作只是简单地从程序移进或移出字节的事情。因此，毫不惊奇的是，这种字节流便被称为流（stream）。</p>
<p>绝大多数流是完全缓冲的(fully buffered)，这意味着“读取”和“写入”实际上是从一块被称为<strong>缓冲区</strong>的内存区域来回复制数据。从内存中来回复制数据是非常快速的。用于输出流的缓冲区只有当它写满时才会被刷新（flush，物理写入）到设备或文件中。一次性把写满的缓冲区写入和逐片把程序产生的输出分别写入相比效率更高。类似，输入缓冲区当它为空时通过从设备或文件读取下一块较大的输入，重新填充缓冲区。</p>
<p>如果程序失攸，缓冲输出可能不会被实际写入，这就可能使程序员得到关于错误出现位置的不正确结论。这个问题的解决方法就是在每个用于调试的printf函数之后立即调用fflush，如下所示：<code>printf(&quot;something or other&quot;); fflush(stdout)</code></p>
<h2 id="流IO总览"><a href="#流IO总览" class="headerlink" title="流IO总览"></a>流IO总览</h2><p>标准库函数使我们在C程序中执行与文件相关的IO任务非常方便。</p>
<ol>
<li>程序为必须同时处于活动状态的每个文件声明一个指针变量，其类型为<code>FILE*</code>。这个指针指向这个FILE结构，当它处于活动状态时由流使用。</li>
<li>流通过调用fopen函数打开。为了打开一个流，你必须指定需要访问的文件或设备以及它们的访问方式（例如，读、写或者既读又写）。fopen和操作系统验证文件或设备确实存在并初始化FILE结构。</li>
<li>然后，根据需要对该文件进行读取或写入。</li>
<li>最后，调用fclose函数关闭流。关闭一个流可以防止与它相关联的文件被再次访问，保证任何存储于缓冲区的数据被正确地写到文件中，并且释放FILE结构使它可以用于另外的文件。</li>
</ol>
<p>I/O函数以三种基本的形式处理数据：<strong>单个字符</strong>、<strong>文本行</strong>和<strong>二进制数据</strong>。对于每种形式，都有一组特定的函数对它们进行处理。<br><img src="/img/1599140980.jpg" alt></p>
<p>这些函数的区别在于获得输入的来源或输出写入的地方不同。这些变种用于执行下面的任务：</p>
<ol>
<li>只用于stdin或stdout</li>
<li>随作为参数的流使用。</li>
<li>使用内存中的字符串而不是流。</li>
</ol>
<p><img src="/img/1599141020.jpg" alt></p>
<h2 id="打开流"><a href="#打开流" class="headerlink" title="打开流"></a>打开流</h2><p><code>fopen</code>函数打开一个特定的文件，并把一个流和这个文件相关联。它的原型下所示：<code>FILE *fopen(char ccnst *name, char const *mode);</code>。两个参数都是字符串。name是你希望打开的文件或设备的名字。创建文件名的规则在不同的系统中可能各不相同，所以fopen把文件名作为一个字符串而不是作为路径名、驱动器字母、文件扩展名等各准备一个参数。mode（模式）参数提示流是用于只读、只写还是既读又写，以及它是文本流还是二进制流。下面的表格列出了一些常用的模式。<br><img src="/img/1599141290.jpg" alt></p>
<p>mode以r、w或a开头，分别表示打开的流用于读取、写入还是添加。如果一个文件打开是用于读取的，那么它必须是原先已经存在的。但是，如果一个文件打开是用于写入的，如果它原先己经存在，那么它原来的内容就会被删除。如果它原先不存在，那么就创建一个新文件。如果一个打开用于添加的文件原先并不存在，那么它将被创建。如果它原先己经存在，它原先的内容并不会被删除。</p>
<p>如果fopen函数执行成功，它返回一个指向FILE结构的指针，该结构代表这个新创建的流。如果函数执行失败，它就返回一个NULL指针，errno会提示问题的性质。</p>
<p>流使用函数<code>fclose</code>关闭的，<code>int fclose(FILE* f)</code>，fclose在文件关闭之前刷新缓冲区，如果它执行成功则返回0，否则返回EOF。</p>
<h2 id="字符IO"><a href="#字符IO" class="headerlink" title="字符IO"></a>字符IO</h2><p>字符输入是由<code>getchar</code>函数家族执行的，它们的原型如下所示。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fgetc</span><span class="params">(FILE *stream)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getc</span><span class="params">(FILE *strearn)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getchar</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>需要操作的流作为参数传递给getc和fgetc，但getchar始终从标准输入读取。每个函数从流中读取下一个字符，并把它作为函数的返回值返回。如果流中不存在更多的字符，函数就返回常量值EOF。返回int型值的真正原因是为了允许报告文件的末尾(EOF)。如果返回值是char型，那么在256个字符中必须有一个被指定用于表示EOF。如果这个字符出现在文件内部，那么这个字符以后的内容将不会被读取，因为它被解释为EOF标志。</p>
<p>EOF被定义为一个整型，它的值在任何可能出现的字符范围之外。这种解决方法允许我们使用这些函数来读取二进制文件。</p>
<p>为了把单个字符写入到流中，你可以使用putchar函数家族。它们的原型如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputc</span><span class="params">(<span class="keyword">int</span> character, FILE *stream)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">putc</span><span class="params">(<span class="keyword">int</span> character, FILE *stream)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">putchar</span><span class="params">(<span class="keyword">int</span> character)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>第1个参数是要被打印的字符。在打印之前，函数把这个整型参数裁剪为一个无符号字符型值，所以<code>putchar(&#39;abc&#39;）</code>仅仅打印一个字符。</p>
<p><code>fgetc</code>和<code>fputc</code>都是真正的函数，但<code>getc</code>、<code>putc</code>、<code>getchar</code>和<code>putchar</code>都是通过<code>#define</code>指令定义的宏。之所以提供两种类型的方法，是为了允许你根据程序的长度和执行速度哪个更重要选择正确的方法。</p>
<h2 id="未格式化的行IO"><a href="#未格式化的行IO" class="headerlink" title="未格式化的行IO"></a>未格式化的行IO</h2><p>未格式化的IO（unformatted line IO）简单读取或写入字符串，而格式化的IO则执行数字和其他变量的内部和外部表示形式之间的转换。gets和puts函数家族是用于操作字符串而不是单个字符。这个特征使它们在那些处理一行行文本输入的程序中非常有用。这些函数的原型如下所示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">char *fgets(char *buffer, int buffer_size, FILE *stream);</span><br><span class="line">char *gets(char *buffer);</span><br><span class="line">int fputs(char const *buffer, FILE *stream);</span><br><span class="line">int puts(char const *buffer);</span><br></pre></td></tr></table></figure></p>
<p>fgets从指定的stream读取字符并把它们复制到buffer中。当它读取一个换行符并存储到缓冲区之后就不再读取。如果缓冲区内存储的字符数达到buffer_size-1个时它也停止读取。在这种情况下，并不会出现数据丢失的情况，因为下一次调用fgets将从流的下一个字符开始读取。在任何一种情况<br>下，一个NULL字节将被添加到缓冲区所存储数据的末尾，使它成为一个字符串。如果在任何字符读取前就到达了文件尾，缓冲区就未进行修改，fgets函数返回一个NULL指针。否则，fgets返回它的第1个参数（指向缓冲区的指针）。这个返回值通常只用于检查是否到达了文件尾。</p>
<h2 id="二进制IO"><a href="#二进制IO" class="headerlink" title="二进制IO"></a>二进制IO</h2><p>fread用于读取二进制数据，fwrite用于写入二进制数据：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> fread(<span class="keyword">void</span> *buffer, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> count, FILE *stream);</span><br><span class="line"><span class="keyword">size_t</span> fwrite(<span class="keyword">void</span> *buffer, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> count, FILE *stream);</span><br></pre></td></tr></table></figure></p>
<p>buffer是一个指向用于保存数据的内存位置的指针，size是缓冲区中每个元素的字节数，count是读取或写入的元素数，当然stream是数据读取或写入的流。buffer参数被解释为一个或多个值的数组。count参数指定数组中有多少个值，所以读取或写入一个标量时，count的值应为函数的返回值是实际读取或写入的元素（并非字节）数目。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">VALUE</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> a;</span><br><span class="line">    <span class="keyword">float</span> b;</span><br><span class="line">    <span class="keyword">char</span> c[SIZE];</span><br><span class="line">&#125; values[ARRAY_SIZE]；</span><br><span class="line">n_value = fread(values, <span class="keyword">sizeof</span>(struct VALUE), ARRAY_SIZE, input_stream);</span><br><span class="line">（处理数组中的数据）</span><br><span class="line">fwrite(values, <span class="keyword">sizeof</span>(struct VALUE), n_value, output_stream);</span><br></pre></td></tr></table></figure></p>
<p>这个程序从一个输入文件读取二进制数据，对它执行某种类型的处理，把结果写入到一个输出文件。这种类型的IO效率很高，因为每个值中的位直接从流读取或向流写入，不需要任何转换。</p>
<h2 id="刷新和定位函数"><a href="#刷新和定位函数" class="headerlink" title="刷新和定位函数"></a>刷新和定位函数</h2><p>fflush迫使一个输出流的缓冲区内的数据进行物理写入，不管它是不是已经写满。<code>int fllush(FILE *stream)</code>。</p>
<p>C同时支持随机访问I/O，也就是以任意顺序访问文件的不同位置。随机访问是通过在读取或写入先前定位到文件中需要的位置来实现的。有两个函数用于执行这项操作：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">ftell</span><span class="params">(FILE *stream)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fseek</span><span class="params">(FILE *stream, <span class="keyword">long</span> offset, <span class="keyword">int</span> from)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>ftell函数返回流的当前位置，也就是说，下一个读取或写入将要开始的位置距离文件起始位置的偏移量。这个函数允许你保存一个文件的当前位置，这样你可能在将来会返回到这个位置。在二进制流中，这个值就是当前位置距离文件起始位置之间的字节数。在文本流中，这个值表示一个位置，但它并不一定准确地表示当前位置和文件起始位置之间的字符数，因为有些系统将对行末字符进行翻译转换。</p>
<p>fseek函数允许你在一个流中定位。这个操作将改变下一个读取或写入操作的位置。它的第1个参数是需要改变的流。它的第2和第3个参数标识文件中需要定位的位置。<br><img src="/img/1599210301.jpg" alt></p>
<p>试图定位到一个文件的起始位置之前是一个错误。定位到文件尾之后并进行写入将扩展这个文件。定位到文件尾之后并进行读取将导致返回一条“到达文件尾”的信息。在二进制流中，从SEEK_END进行定位可能不被支持，所以应该避免。在文本流中，如果from是SEEK_CUR或SEEK_END，offset必须是零。如果from是SEEK_SET，offset必须是一个从同一个流中以前调用ftell所返回的值。</p>
<p>用fseek改变一个流的位置会带来三个副作用。</p>
<ul>
<li>首先，行末指示字符被清除。</li>
<li>其次，如果在fseek之前使用ungetc把一个字符返回到流中，那么这个被退回的字符会被丢弃，因为在定位操作以后，它不再是“下一个字符”。</li>
<li>最后，定位允许你从写入模式切换到读取模式，或者回到打开的流以便更新。</li>
</ul>
<p>另外还有三个额外的函数，用一些限制更严的方式执行相同的任务。它们的原型如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rewind</span><span class="params">(FILE *stream)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fgetpos</span><span class="params">(FILE *stream, <span class="keyword">fpos_t</span> *positicn)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fsetpos</span><span class="params">(FILE *streamr, <span class="keyword">fpos_t</span> <span class="keyword">const</span> *possiton)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>rewind函数将读/写指针设置回指定流的起始位置。它同时清除流的错误提示标志。fgetpos和fsetpos函数分别是ftell和fseek函数的替代方案。它们的主要区别在于这对函数接受一个指向fpos_t的指针作为参数。fgetpos在这个位置存储文件的当前位置，fsetpos把文件位置设置为存储在这个位置的值。</p>
<h2 id="改变缓冲方式"><a href="#改变缓冲方式" class="headerlink" title="改变缓冲方式"></a>改变缓冲方式</h2><p>下面两个函数可以用于对缓冲方式进行修改。这两个函数只有当指定的流被打开但还没有在它上面执行任何其他操作前才能被调用。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setbuf</span><span class="params">(FILE *stream, <span class="keyword">char</span> *buf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setvbuf</span><span class="params">(FILE *stream, <span class="keyword">char</span> *buf)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>setbuf设置了另一个数组，用于对流进行缓冲。这个数组的字符长度必须为BUFSIZ（它在stdio.h中定义）。为一个流自行指定缓冲区可以防止IO函数库为它动态分配一个缓冲区。如果用一个NULL参数调用这个函数，setbuf函数将关闭流的所有缓冲方式。字符准确地将程序所规引的方式进行读取和写入。</p>
<p>为流缓冲区使用一个自动数组是很危险的。如果在流关闭之前，程序的执行流离开了数组声明所在的代码块，流就会继续使用这块内存，但此时它可能已经分配给了其他函数另作它用。</p>
<p>setvbuf函数更为通用。mode参数用于指定缓冲的类型。_IOFBF指定一个完全缓冲的流，_IONBF指定一个不缓冲的流，_IOLBF指定一个行缓冲流。所谓行缓冲，就是每当一个换行符写入到缓冲区时，缓冲区便进行刷新。buf和size参数用于指定需要使用的缓冲区。如果buf为NULL，那么size的值必须是0。一般<br>而言，最好用一个长度为BUFSIZ的字符数组作为缓冲区。尽管使用一个非常大的缓冲区可能可以稍稍提高程序的效率，但如果使用不当，它也有可能降低程序的效率。</p>
<h2 id="流错误函数"><a href="#流错误函数" class="headerlink" title="流错误函数"></a>流错误函数</h2><p>下面的函数用于判断流的状态：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">feof</span><span class="params">(FILE *stream)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ferror</span><span class="params">(FILE *stream)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearerr</span><span class="params">(FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>如果流当前处于文件尾，feof函数返回真。这个状态可以通过对流执行fseek、rewind或fsetpos函数来清除。ferror函数报告流的错误状态，如果出现任何读／写错误函数就返回真。最后，clearerr函数对指定流的错误标志进行重置。</p>
<h2 id="临时文件"><a href="#临时文件" class="headerlink" title="临时文件"></a>临时文件</h2><p>tmpfile函数用于创建临时文件。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FILE *<span class="title">tmpfile</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>这个函数创建了一个文件，当文件被关闭或程序终止时这个文件便自动删除。该文件以<code>wb+</code>模式打开，这使它可用于二进制和文本数据。如果临时文件必须以其他模式打开或者由一个程序打开但由另一个程序读取，就不适合用tmpfile函数创建。</p>
<h2 id="文件操纵函数"><a href="#文件操纵函数" class="headerlink" title="文件操纵函数"></a>文件操纵函数</h2><p>有两个函数用于操纵文件但不执行任何输入/输出操作。它们的原型如下所示。如果执行成功，这两个函数都返回零值。如果失败，它们都返回非零值。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">remove</span><span class="params">(<span class="keyword">char</span> <span class="keyword">const</span> *filename)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rename</span><span class="params">(<span class="keyword">char</span> <span class="keyword">const</span> *oldname, <span class="keyword">char</span> <span class="keyword">const</span> *newname)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>remove函数删除一个指定文件，如果当remove被调用时文件处于打开状态，其结果将取决于编译器。rename用于改变一个文件的名字。</p>
<h1 id="标准函数库"><a href="#标准函数库" class="headerlink" title="标准函数库"></a>标准函数库</h1><h2 id="整型函数"><a href="#整型函数" class="headerlink" title="整型函数"></a>整型函数</h2><h3 id="算数"><a href="#算数" class="headerlink" title="算数"></a>算数<stdlib.h></stdlib.h></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">abs</span><span class="params">(<span class="keyword">int</span> value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">int</span> <span class="title">labs</span><span class="params">(<span class="keyword">long</span> <span class="keyword">int</span> value)</span></span>;</span><br><span class="line"><span class="keyword">div_t</span> div(<span class="keyword">int</span> numerator,<span class="keyword">int</span> denominator);</span><br><span class="line"><span class="keyword">ldiv_t</span> ldiv(<span class="keyword">long</span> <span class="keyword">int</span> number,<span class="keyword">long</span> <span class="keyword">int</span> denom);</span><br></pre></td></tr></table></figure>
<p>abs函数返回绝对值。labs用于长整数。div函数把第二个参数除以第1个参数，产生商和余数，用一个div_t结构返回。这个结构包含<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> quot;     <span class="comment">//商</span></span><br><span class="line"><span class="keyword">int</span> rem;      <span class="comment">//余数</span></span><br></pre></td></tr></table></figure></p>
<h3 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数<stdlib.h></stdlib.h></h3><p>下面两个函数合在一起使用能够产生伪随机数pseudo-random number。他们通过计算差生随机数，因此有可能重复出现，并不是真正的随机数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int rand(void);</span><br><span class="line">void srand(unsigned int seed);</span><br></pre></td></tr></table></figure></p>
<p>rand返回一个范围在0和RAND_MAX（至少为32767）之间的伪随机数。当它重复调用时，函数返回这个范围内的其他数。为了得到一个更小范围的伪随机数，首先把这个函数的返回值根据所需范围的大小进行取模，然后通过加上或减去一个偏移量对它进行调整。</p>
<p>为了避免程序每次运行时获得相同的随机数序列，可以调用srand函数。它用它的参数值对随机数发生器进行初始化。一个常用的技巧是使用每天的时间作为随机数产生器的种子seed。<code>srand((unsigned int)time(0))</code></p>
<h3 id="字符串转换"><a href="#字符串转换" class="headerlink" title="字符串转换"></a>字符串转换<stdlib.h></stdlib.h></h3><p>把字符串转换为数值。atoi和atol执行基数为10的转换。strtol和strtoul允许在转换时指定基数，同时还允许访问字符串的剩余部分。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">atoi</span><span class="params">(<span class="keyword">char</span> <span class="keyword">const</span> *<span class="built_in">string</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">int</span> <span class="title">atol</span><span class="params">(<span class="keyword">char</span> <span class="keyword">const</span> *<span class="built_in">string</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">int</span> <span class="title">strtol</span><span class="params">(<span class="keyword">char</span> <span class="keyword">const</span> *<span class="built_in">string</span>,<span class="keyword">char</span> **unused,<span class="keyword">int</span> base)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">strtoul</span><span class="params">(<span class="keyword">char</span> <span class="keyword">const</span> *<span class="built_in">string</span>,<span class="keyword">char</span> **unused,<span class="keyword">int</span> base)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>如果任何一个上述函数的的第一个参数包含了前导空白字符，他们将被跳过。然后函数把合法的字符转换为指定类型的值。如果存在任何非法缀尾字符，他们也将被忽略。</p>
<p>atoi和atol分别把字符转换为整数和长整数值。strtol和atol同样把参数字符串转换为long。但是strtol保存一个指向转换至后面第1个字符的指针。如果函数的第二个参数并非NULL，这个指针便保存在第二个参数所指向的位置。这个指针允许字符串的剩余部分进行处理而无需推测转换在字符串的哪个位置终止。strtoul和strtol的执行方式仙童，但它产生一个无符号长整数。</p>
<p>这两个函数的第3个参数是转换所执行的基数。如果基数为0，任何在程序中用于书写整数字面值的形式都将被接受，包括指定数字基数的形式。否则基数值应该在2到36的范围内——然后转换根据这个给定的基数进行。对于基数11到36，字母A到Z分别被解释为10到35.在这个上下文环境中，小写字母a-z被解释为与对应的大写字母相同的意思。</p>
<p>如果这些函数的string参数中并不包含一个合法的值，函数就返回0。如果被转换的值无法表示，函数便在errno中存储ERANGE这个值，并返回以下一个值。</p>
<ul>
<li>strtol 返回值如果太大且为负返回LONG_MIN。如果值太大且为正返回LONG_MAX</li>
<li>strtoul如果值太大返回ULONG_MAX</li>
</ul>
<h2 id="浮点型函数"><a href="#浮点型函数" class="headerlink" title="浮点型函数"></a>浮点型函数</h2><p>math.h包含了函数库中剩余的数学函数的声明。</p>
<h3 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数<math.h></math.h></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sin</span><span class="params">(<span class="keyword">double</span> angle)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">cos</span><span class="params">(<span class="keyword">double</span> angle)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">tan</span><span class="params">(<span class="keyword">double</span> angle)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">asin</span><span class="params">(<span class="keyword">double</span> value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">acos</span><span class="params">(<span class="keyword">double</span> value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">atan</span><span class="params">(<span class="keyword">double</span> value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">atan2</span><span class="params">(<span class="keyword">double</span> x,<span class="keyword">double</span> y)</span></span>;</span><br></pre></td></tr></table></figure>
<p>sin、cos、tan参数是一个用弧度表示的角度，返回正弦余弦正切。asin、acos、atan返回反正弦、反余弦、反正切。如果asin和acos的参数不位于-1和1之间，就出现一个定义域错误。asin和atan的返回值是在-π/2和π/2之间的一个弧度，acos的返回值是一个返回在0和π之间的弧度。</p>
<h3 id="双曲函数"><a href="#双曲函数" class="headerlink" title="双曲函数"></a>双曲函数<math.h></math.h></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sinh</span><span class="params">(<span class="keyword">double</span> angle)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">cosh</span><span class="params">(<span class="keyword">double</span> angle)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">tanh</span><span class="params">(<span class="keyword">double</span> angle)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="对数和指数函数"><a href="#对数和指数函数" class="headerlink" title="对数和指数函数"></a>对数和指数函数<math.h></math.h></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">exp</span><span class="params">(<span class="keyword">double</span> x)</span></span>;     <span class="comment">//e的x次幂     </span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">log</span><span class="params">(<span class="keyword">double</span> x)</span></span>;      <span class="comment">//x的自然对数</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">log10</span><span class="params">(<span class="keyword">double</span> x)</span></span>;   <span class="comment">//x以10为低的对数</span></span><br></pre></td></tr></table></figure>
<h3 id="浮点表示形式"><a href="#浮点表示形式" class="headerlink" title="浮点表示形式"></a>浮点表示形式<math.h></math.h></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">double frexp(double value,int *exponet);</span><br><span class="line">double ledexp(doub fraction,int exponet);</span><br><span class="line">double modf(double value,double *ipart);</span><br></pre></td></tr></table></figure>
<p>frexp函数计算一个指数exponent和小数fraction，这样fraction × 2^exponent = value，函数返回fraction。ledexp返回值是fraction × 2^exponent。modf把一个浮点值分成整数和小数两个部分，整数部分以double类型存储在第二个参数所指向的内存位置，小数部分作为函数的返回值返回。</p>
<h3 id="幂"><a href="#幂" class="headerlink" title="幂"></a>幂<math.h></math.h></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">pow</span><span class="params">(<span class="keyword">double</span> x,<span class="keyword">double</span> y)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sqrt</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="底数、顶数、绝对值和余数"><a href="#底数、顶数、绝对值和余数" class="headerlink" title="底数、顶数、绝对值和余数"></a>底数、顶数、绝对值和余数<math.h></math.h></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">floor</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">ceil</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">fabs</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">fmod</span><span class="params">(<span class="keyword">double</span> x,<span class="keyword">double</span> y)</span></span>;</span><br></pre></td></tr></table></figure>
<p>floor函数返回不大于其参数的最大整数值，这个值以double返回，ceil函数返回不小于其参数的最小整数值。fabs返回其参数的绝对值。fmod返回x除以y所产生的余数。</p>
<h3 id="字符串转换-1"><a href="#字符串转换-1" class="headerlink" title="字符串转换"></a>字符串转换<stdlib.h></stdlib.h></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">atof</span><span class="params">(<span class="keyword">char</span> <span class="keyword">const</span> *<span class="built_in">string</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">strtod</span><span class="params">(<span class="keyword">char</span> <span class="keyword">const</span> *<span class="built_in">string</span>,<span class="keyword">char</span> **unused)</span></span>;</span><br></pre></td></tr></table></figure>
<p>如果任一函数的参数包含了前导的空白字符，这些字符将被忽略。函数随后把合法的字符转换为一个double值，忽略任何缀尾的非法字符。这两个函数都接受程序中所有浮点数字面值的书写形式。strtod函数把参数字符串转换为一个double值，其方法和atof类似，但它保存一个指向字符串中被转换的值后面的第1个字符的指针。如果函数的第2个参数不是NULL，那么这个被保存的指针就存储于第2个参数所指向的内存位置。这个指针允许对字符串的剩余部分进行处理，而不用猜测转换会在字符串中的什么位置结束。</p>
<p>如果这两个函数的字符串参数并不包含任何合法的数值字符，函数就返回零。如果转换值太大或太小，无法用double表示，那么函数就在errno中存储ERANGE这个值，如果值太大（无论是正数还是负数），函数返回HUGE_VALO如果值太小，函数返回零。</p>
<h2 id="日期和时间函数"><a href="#日期和时间函数" class="headerlink" title="日期和时间函数"></a>日期和时间函数</h2><h3 id="处理器时间"><a href="#处理器时间" class="headerlink" title="处理器时间"></a>处理器时间<time.h></time.h></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">clock_t</span> clock(<span class="keyword">void</span>);</span><br></pre></td></tr></table></figure>
<p>返回从程序开始执行器处理器所消耗的时间，应该把它除以常量CLOCKS_PER_SEC。</p>
<h3 id="当天时间"><a href="#当天时间" class="headerlink" title="当天时间"></a>当天时间<time.h></time.h></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">time_t</span> time(<span class="keyword">time_t</span> *returned_value);</span><br></pre></td></tr></table></figure>
<p>返回当前的日期和时间</p>
<h3 id="日期和时间的转换"><a href="#日期和时间的转换" class="headerlink" title="日期和时间的转换"></a>日期和时间的转换<time.h></time.h></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">ctime</span><span class="params">(<span class="keyword">time_t</span> <span class="keyword">const</span> *time_value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">difftime</span><span class="params">(<span class="keyword">time_t</span> time1,<span class="keyword">time_t</span> time2)</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tm</span> *<span class="title">gmtime</span>（<span class="title">time_t</span> <span class="title">const</span> *<span class="title">time</span>)<span class="title">value</span>);</span></span><br><span class="line"><span class="function">struct tm *<span class="title">localtime</span><span class="params">(<span class="keyword">time_t</span> <span class="keyword">const</span> *time_value)</span></span>;</span><br></pre></td></tr></table></figure>
<p>ctime的参数是一个指向time_t的指针，并返回一个指向字符串的指针：<code>Sun Jul 4 04:02:28 1976\n\0</code>。difftime计算两个时间之差，并把结果转换成秒。gmtime把时间值转换为世界协调时间Coordinated Universal Time，UTC。以前被称为格林尼治标准时间Greenwich Mean Time，返回值为tm结构：<br><img src="/img/1599212143.jpg" alt></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">asctime</span><span class="params">(struct tm <span class="keyword">const</span> *tm_ptr)</span></span>;</span><br><span class="line"><span class="keyword">size_t</span> strftime(<span class="keyword">char</span> *<span class="built_in">string</span> ,<span class="keyword">size_t</span> maxsize,<span class="keyword">char</span> <span class="keyword">const</span> *format, struct tm <span class="keyword">const</span> *tm_ptr);</span><br></pre></td></tr></table></figure>
<p>asctime将tm表示的时间值转换成ctime函数所用的一样的格式。</p>
<p>strftime函数把一个tm结构体转换为一个根据某个格式字符串而定的字符串。如果转换结果字符串的长度小于maxsize参数，返回字符串长度，否则返回-1且数组内容未定义。格式字符串包含了普通字符和格式代码。普通字符被复制到它们原先在字符串中出现的位置。格式代码则被一个日期或时间值代替。格式代码包括一个%字符，后面跟一个表示所需值的字符。<br><img src="/img/1599212244.jpg" alt></p>
<p>最后，mktime函数用于把tm结构转换为一个time_t的值。tm结构中的tm_wday和tm_yday值被忽略，其他字段的值也无需限制在它们的通常范围内。转换之后，该tm结构会进行规格化。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">time_t</span> mktime( struct tm *tm_ptr );</span><br></pre></td></tr></table></figure></p>
<h3 id="非本地跳转"><a href="#非本地跳转" class="headerlink" title="非本地跳转"></a>非本地跳转<setjmp.h></setjmp.h></h3><p>setjmp和longjmp函数提供一种类似goto语句的机制，但它并不局限于一个函数的作用域之内。这些函数常用于深层嵌套的函数调用链。如果在某个底层的函数中检测到一个错误，可以立即返回顶层的函数，不必向调用链中的每个中间层函数返回一个错误标志。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setjmp</span><span class="params">( jmp_buf state )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">longjmp</span><span class="params">( jmp_buf state, <span class="keyword">int</span> value )</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>声明一个jmp_buf变量，并调用setjmp函数初始化，返回值为0。setjmp把程序的状态信息（例如，堆栈指针的当前位置和程序的计数器）保存到跳转缓冲区。调用该函数的函数成为“顶层”函数。以后，在顶层函数或者其他任何它所调用的函数（无论是直接调用还是间接调用）内调用longjmp函数，将会导致这个被保存的状态重新恢复。longjmp的效果是使执行流通过再次从setjmp返回，从而立即跳转回顶层函数中，此时，setjmp返回的值是longjmp的第2个参数。</p>
<h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><p>信号（signal）表示一种事件，它可能异步的发生，也就是并不与程序执行过程的任何事件同步。</p>
<h3 id="信号名"><a href="#信号名" class="headerlink" title="信号名"></a>信号名<signal.h></signal.h></h3><div class="table-container">
<table>
<thead>
<tr>
<th>信号</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>SIGABRT</td>
<td>程序请求异常终止，由abort函数引发。</td>
</tr>
<tr>
<td>SIGFPE</td>
<td>具体错误由编译器确定，常见有算术上溢、下溢以及除零错误</td>
</tr>
<tr>
<td>SIGILL</td>
<td>检测到非法指令，可能由不正确的编译器设置导致</td>
</tr>
<tr>
<td>SIGSEGV</td>
<td>检测到内存的非法访问，程序访问未分配内存或者访问超过内存访问的边界（segmentation violation）</td>
</tr>
<tr>
<td>SIGINT</td>
<td>程序外部产生，通常是用户尝试中断程序时发生，一般定义处理函数来执行日常维护和退出前保存数据（interrupt）</td>
</tr>
<tr>
<td>SIGTERM</td>
<td>程序外部产生，请求终止程序的信号（terminate）</td>
</tr>
</tbody>
</table>
</div>
<h3 id="处理信号"><a href="#处理信号" class="headerlink" title="处理信号"></a>处理信号<signal.h></signal.h></h3><p>raise函数用于显示的引发参数所指定的信号。当一个信号发生时，程序可以使用三种方式对其作出反应。默认的反应由编译器定义，一般是终止程序。程序也可以指定其他对信号的反应行为：忽略或者信号处理函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">raise</span><span class="params">( <span class="keyword">int</span> sig )</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>调用这个函数将引发它的参数所指定的信号。</p>
<p>signal函数将用于指定程序希望采取的反应。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> ( *signal( <span class="keyword">int</span> sig, <span class="keyword">void</span> ( *handler )( <span class="keyword">int</span> ) ) )( <span class="keyword">int</span> );</span><br></pre></td></tr></table></figure></p>
<p>signal接收2个参数，第1个参数是信号，第2个参数是希望为这个信号设置的信号处理函数的指针。返回值是一个接收1个整型参数返回值是空的函数指针。事实上，signal函数返回一个指向该信号以前的处理函数的指针。如果因为非法信号导致调用失败，signal返回SIG_ERR。SIG_DEF和SIG_IGN可以用作signal函数的第2个参数。</p>
<h3 id="信号处理函数"><a href="#信号处理函数" class="headerlink" title="信号处理函数"></a>信号处理函数</h3><p>当一个已经设置了信号处理函数的信号发生时，系统为了防止如果信号处理函数内部也产生这个信号可能导致的无限循环，将首先恢复对该信号的默认行为，然后调用信号处理函数。</p>
<p>信号处理函数可能执行的工作类型是很有限的。如果信号是异步的，也就是说不是由于调用abort或raise函数引起的，信号处理函数就不应调用除signal之外的任何的库函数，因为在这种情况下其结果是未定义的。而且，信号处理函数除了能向一个类型为volatile sig_atomic_t的静态变量赋一个值以外，可能无法访问其他静态数据。（信号处理函数修改的变量值可能会在任何时候发生改变，因此可能在两条相邻的程序语句语句中变量的值不同，volatile关键字将告诉编译器这个事实。即当要求使用volatile声明变量值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。精确地说就是，遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问）</p>
<p>从一个信号处理函数返回导致程序的执行流从信号发生的地点恢复执行（SIGFPE例外）。如果希望捕捉将来同种信号，从当前这个信号的处理函数返回之前注意要调用signal函数重新设置信号处理函数。否则，只有第1个信号才会被捕捉，接下来的同种信号将按默认处理。</p>
<h2 id="打印可变参数列表"><a href="#打印可变参数列表" class="headerlink" title="打印可变参数列表"></a>打印可变参数列表<stdarg.h></stdarg.h></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vprintf</span><span class="params">( <span class="keyword">char</span> <span class="keyword">const</span> *format, va_list arg )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfprintf</span><span class="params">( FILE *stream, <span class="keyword">char</span> <span class="keyword">const</span> *format, va_list arg )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vsprintf</span><span class="params">( <span class="keyword">char</span> *buffer, <span class="keyword">char</span> <span class="keyword">const</span> *format, va_list arg )</span></span>;</span><br></pre></td></tr></table></figure>
<p>这组函数用于可变参数列表必须被打印的场合。必须包含<code>&lt;stdio.h&gt;</code>和<code>&lt;stdarg.h&gt;</code>。在调用这些函数之前，arg参数必须使用va_start进行初始化，这些函数不需要调用va_end。</p>
<h2 id="执行环境"><a href="#执行环境" class="headerlink" title="执行环境"></a>执行环境</h2><p>这些函数与程序的执行环境进行通信或者对程序的执行环境施加影响。</p>
<h3 id="终止执行"><a href="#终止执行" class="headerlink" title="终止执行"></a>终止执行<stdlib.h></stdlib.h></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">abort</span><span class="params">( <span class="keyword">void</span> )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">atexit</span><span class="params">( <span class="keyword">void</span> (func)( <span class="keyword">void</span> ) )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exit</span><span class="params">( <span class="keyword">int</span> status )</span></span>;</span><br></pre></td></tr></table></figure>
<p>abort函数用于不正常地终止一个正在执行的程序，将触发SIGABRT信号，若设置了信号处理函数，在程序终止前可以采取任何措施，哪怕不终止程序。atexit函数可以把一些函数注册为退出函数（exit function）。当程序将要正常终止（或者由于调用exit，或者由于main函数返回），退出函数将被调用。当exit函数被调用时，所有被atexit函数注册为退出函数的函数将按照它们所注册的顺序被反序调用。然后，所有用于流的缓冲区被刷新，所有打开文件被关闭。用tmpfile函数创建的文件被删除。然后退出状态返回给宿主环境，程序停止执行。</p>
<h3 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言<assert.h></assert.h></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">assert</span><span class="params">( <span class="keyword">int</span> expression )</span></span>;</span><br></pre></td></tr></table></figure>
<p>assert宏由ANSIC实现，常用于调试程序。当assert被执行时，这个宏对表达式参数进行测试。如果参数表达式值为0，它就向标准错误打印一条诊断信息并终止程序，这个消息格式由编译器定义，但会包含这个表达式和源文件的名字以及这个断言所在行号。</p>
<p>该宏提供了一个对应该为真的东西进行检查的方便方法，例如函数在对一个不能为NULL的指针参数进行调用前用assert进行验证。当程序被完整地测试完毕之后，可以在编译时通过定义NDEBUG消除所有断言（使用-DNDEBUG编译器命令行选项或在源文件assert.h被包含之前增加<code>#define NDEBUG</code>语句）。</p>
<h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境<stdlib.h></stdlib.h></h3><p>环境是一个由编译器定义的名字/值对的列表，由操作系统进行维护。getenv函数在这个列表中查找一个特定的名字，如果找到，返回一个指向其对应值的指针，程序不能修改返回的字符串。如果名字未找到，函数就返回NULL指针。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">getenv</span><span class="params">( <span class="keyword">char</span> <span class="keyword">const</span> *name )</span></span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="执行系统命令"><a href="#执行系统命令" class="headerlink" title="执行系统命令"></a>执行系统命令<stdlib.h></stdlib.h></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">system</span><span class="params">( <span class="keyword">char</span> <span class="keyword">const</span> *command )</span></span>;</span><br></pre></td></tr></table></figure>
<p>system函数把它的字符串参数传递给宿主操作系统，由系统的命令处理器执行。如果参数是NULL，则system用于询问命令处理器是否实际存在。在这种情况下，如果存在一个可用的命令处理器，system返回非0值，否则返回0。</p>
<h3 id="排序和查找"><a href="#排序和查找" class="headerlink" title="排序和查找"></a>排序和查找<stdlib.h></stdlib.h></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qsort</span><span class="params">( <span class="keyword">void</span> *base, <span class="keyword">size_t</span> n_elements, <span class="keyword">size_t</span> el_size, <span class="keyword">int</span> (*compare)(<span class="keyword">void</span> <span class="keyword">const</span> *, <span class="keyword">void</span> <span class="keyword">const</span> *) )</span></span>;</span><br></pre></td></tr></table></figure>
<p>qsort函数在一个数组中以升序的方式对数据进行排序，与类型无关，只是数组内元素的长度需固定。第1个参数指向需要排序的数组，第2个参数指定数组中元素的数目，第3个参数指定每个元素的长度（以字节为单位）。第4个参数是一个函数指针，用于对需要排序的元素类型进行比较。比较函数应该返回一个整数，大于0、等于0和小于0表示第1个参数大于、等于和小于第2个参数。</p>
<p>bsearch函数在一个己经排好序的数组中用二分法查找一个特定的元素。如果数组尚未排序，其结果是未定义的。第1个参数指向你需要查找的值，第2个参数指向查找所在的数组，第3个参数指定数组中元素的数目，第4个参数是每个元素的长度（以字符为单位）。最后一个参数是和qsort中相同的指向比较函数的指针。bsech函数返回一个指向查找到的数组元素的指针。如果需要查找的值不存在，函数返回一个NULL指针。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">bsearch</span><span class="params">( <span class="keyword">void</span> <span class="keyword">const</span> *key, coid <span class="keyword">const</span> *base, <span class="keyword">size_t</span> n_elements, <span class="keyword">size_t</span> el_size, <span class="keyword">int</span> (*compare)(<span class="keyword">void</span> <span class="keyword">const</span> *, <span class="keyword">void</span> <span class="keyword">const</span> *) )</span></span>;</span><br></pre></td></tr></table></figure></p>
<h2 id="locale"><a href="#locale" class="headerlink" title="locale"></a>locale</h2><p>为了使C语言在全世界的范围内更为通用，标准定义了locale，这是一组特定的参数，每个国家可能各不相同。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">setlocale</span><span class="params">( <span class="keyword">int</span> category, <span class="keyword">char</span> <span class="keyword">const</span> *locale )</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>setlocale常用于修改整个或部分locale，可能影响库函数的运行方式。category参数指定locale的哪个部分需要进行修改，允许出现的值列于下表。如果第2个参数locale为NULL，函数将返回一个指向给定类型的当前locale的名字的指针。这个值可能被保存并继续在后续的setlocale中使用用以恢复。如果第2个参数不是NULL，它指定需要使用的新locale。如果函数调用成功，它将返回新locale的值，否则返回一个NULL指针，原来的locale不受影响。</p>
<h3 id="数值和货币格式"><a href="#数值和货币格式" class="headerlink" title="数值和货币格式"></a>数值和货币格式</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct lconv *<span class="title">localeconv</span><span class="params">( <span class="keyword">void</span> )</span></span>;</span><br></pre></td></tr></table></figure>
<p>localeconv函数用于获得根据当前的locale对非货币值和货币值进行合适的格式化所需要的信息。该函数不实际执行格式化任务，只是提供一些如何进行格式化的信息。lconv结构包含两种类型的参数：字符和字符指针。字符参数为非负值，如果一个字符参数为CHAR_MAX，那么这个值就在当前的locale中不可用（不使用）。对于字符指针，如果指向一个空字符串，与前者同意。</p>
<p>格式化非货币数值的参数</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>字段和类型</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>char *decimal_point</td>
<td>用作小数点的字符。这个值绝不能是个空字符串。例如：”.”</td>
</tr>
<tr>
<td>char *thousands_sep</td>
<td>用作分隔小数点左边各组数字的符号。例如：”,”</td>
</tr>
<tr>
<td>char *grouping</td>
<td>指定小数点左边多少数字组成。例如：”\3”</td>
</tr>
</tbody>
</table>
</div>
<p>格式化本地货币值的参数</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>字段和类型</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>char *currency_symbol</td>
<td>本地货币符号</td>
</tr>
<tr>
<td>char *mon_decimal_point</td>
<td>小数点字符</td>
</tr>
<tr>
<td>char *mon_thousands_sep</td>
<td>用于分隔小数点左边各组数字的字符</td>
</tr>
<tr>
<td>char *mon_group</td>
<td>指定出现在小数点左边各组数字的数字个数</td>
</tr>
<tr>
<td>char *postive_sign</td>
<td>用于提示非负值的字符串</td>
</tr>
<tr>
<td>char *negative_sign</td>
<td>用于提示负值的字符串</td>
</tr>
<tr>
<td>char frac_digits</td>
<td>出现在小数点右边的数字个数</td>
</tr>
<tr>
<td>char p_cs_precedes</td>
<td>如果currency_symbol出现在一个非负值之前，其值为’\1’；如果出现在后面，其值为’\0’</td>
</tr>
<tr>
<td>char n_cs_precedes</td>
<td>如果currency_symbol出现在一个负值之前，其值为’\1’；如果出现在后面，其值为’\0’</td>
</tr>
<tr>
<td>char p_sep_by_space</td>
<td>如果currency_symbol和非负值之间用一个空格字符分隔，其值为’\1’；否则其值为’\0’</td>
</tr>
<tr>
<td>char n_sep_by_space</td>
<td>如果currency_symbol和负值之间用一个空格字符分隔，其值为’\1’；否则其值为’\0’</td>
</tr>
<tr>
<td>char n_sign_posn</td>
<td>提示negative_sign出现在一个负值中的位置。用于p_sign_posn的值也可用于此处</td>
</tr>
<tr>
<td>char p_sign_posn</td>
<td>提示positive_sign出现在一个非负值的位置</td>
</tr>
</tbody>
</table>
</div>
<h3 id="符号串和locale"><a href="#符号串和locale" class="headerlink" title="符号串和locale"></a>符号串和locale<string.h></string.h></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strcoll</span><span class="params">( <span class="keyword">char</span> <span class="keyword">const</span> *s1, <span class="keyword">char</span> <span class="keyword">const</span> *s2 )</span></span>;</span><br><span class="line"><span class="keyword">size_t</span> strcfrm( <span class="keyword">char</span> *s1, <span class="keyword">char</span> <span class="keyword">const</span> *s2, <span class="keyword">size_t</span> size );</span><br></pre></td></tr></table></figure>
<p>一个机器的字符集的对照序列是固定的。但setlocale提供了一种方法指定不同的序列,当使用一个并非默认的对照列表时，可以采用上面两个函数。strcoll函数对两个根据当前locale的LC_COLLATE类型参数指定的字符串进行比较，比较可能比strcmp需要多得多的计算了，因为其需要遵循一个并非本地机器的对照序列。当字符串必须以这种方式反复进行比较时，使用strcfrm函数可以减少计算量。strcfrm把根据当前locale解释的第2个参数转换成一个不依赖于locale的字符串，尽管转换后的字符串内容不确定，但比较结果和strcoll相同。</p>
<h3 id="改变locale的效果"><a href="#改变locale的效果" class="headerlink" title="改变locale的效果"></a>改变locale的效果</h3><p>locale可能向正在执行的程序所使用的字符集增加字符（但可能不会改变现存字符的含义）。例如，许多欧洲语言使用了能够提示重音、货币符号和其他特殊符号的扩展字符集。</p>
<p>打印的方向可能会改变。尤其，locale决定一个字符应该根据前面一个被打印的字符的哪个方向进行打印。printf和scanf函数机组使用当前locale定义的小数点符号。如果locale扩展了正在使用的字符集，isalpha、islower、isspace和isupper函数可能比以前包含更多的字符。正在使用的字符集的对照序列可能会改变。这个序列有strcoll函数使用，用于字符串之间的相互比较。strftime函数产生的日期和时间格式的很多方面都是特定于locale的。</p>
<h1 id="运行时环境"><a href="#运行时环境" class="headerlink" title="运行时环境"></a>运行时环境</h1><h2 id="判断运行时环境"><a href="#判断运行时环境" class="headerlink" title="判断运行时环境"></a>判断运行时环境</h2><p>第一步骤是从你的编译器获得一个汇编语言代码列表。</p>
<ul>
<li>测试程序</li>
<li>静态变量和初始化</li>
<li>堆栈帧<ul>
<li>一个函数分成三个部分：函数序、函数体、函数跋。</li>
</ul>
</li>
<li>寄存器变量</li>
<li>外部标识符的长度</li>
<li>判断堆栈帧布局<ul>
<li>运行时堆栈保存了每个函数运行时所需要的数据，包括它的自动变量和返回地址。<ul>
<li>传递函数参数</li>
<li>函数序</li>
<li>堆栈中的参数次序</li>
<li>最终的堆栈帧布局</li>
<li>函数跋</li>
<li>返回值</li>
<li>表达式的副作用</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="C和汇编语言的接口"><a href="#C和汇编语言的接口" class="headerlink" title="C和汇编语言的接口"></a>C和汇编语言的接口</h2><p>编写能够调用C程序或者被C程序调用的汇编语言程序所需的内容。与这个环境相关的结果总结如下—你的环境肯定在某些方面与它不同！</p>
<ul>
<li>首先，汇编程序中的名字必须遵循外部标识符的规则。</li>
<li>其次，汇编程序必须遵循正确的函数调用/返回协议。有两种情况：从一个汇编语言程序调用一个C程序和从一个程序调用一个汇编程序。为了从汇编程序调用C程序：</li>
<li>如果寄存器d0、d1、a0或a1保存了重要的值，它们必须在调用C程序之前进行保存，因为C函数不会保存它们的值。</li>
<li>任何函数的参数必须以参数列表相反的顺序压入到堆栈中。</li>
<li>函数必须由一条“跳转子程序”类型的指令调用，它会把返回地址压入到堆栈中。</li>
<li>当C函数返回时，汇编程序必须清除堆栈中的任何参数。</li>
<li>如果汇编程序期望接受一个返回值，它将保持在d0(如果返回值的类型为double，它的另一半将位于d1)。</li>
<li>任何在调用之前进行过保存的寄存器此时可以恢复。</li>
<li>为了编写一个由C程序调用的汇编程序：<ul>
<li>保存任何你希望修改的寄存器(除d0、d1、a0或a1之外)。</li>
<li>参数值从堆栈中获得，因为调用它的C函数把参数压入到堆栈中。</li>
<li>如果函数应该返回一个值，它的值应该保存在d0中(在这种情况下，d0不能进行保存和恢复)。</li>
<li>在返回之前，函数必须清除任何它压入到堆栈中的内容。</li>
</ul>
</li>
</ul>
<h2 id="运行时效率"><a href="#运行时效率" class="headerlink" title="运行时效率"></a>运行时效率</h2><p>即使在一些现代的机器上，一个必须存储于ROM的程序必须相当小才有可能装入到有限的内存空间中。但许多现代计算机系统在这方面的限制大不如前，这是因为它们提供了<strong>虚拟内存。虚拟内存是由操作系统实现的，它在需要时把程序活动部分放入内存并把不活动的部分复制到磁盘中</strong>，这样就允许系统运行大型的程序。但程序越大，需要进行的复制就越多。所以大型程序不是想以前那样根本无法运行，而是随着程序的增大，它的执行效率逐渐降低。</p>
<p>如果一个程序太大或太慢，较之专研每个变量，看看把它们声明为register能不能提高效率，选一种效率更高的算法或数据结构往往效果要满意得多。然而这并不是说你可以在代码中胡作非为，因为风格恶劣的代码总是会把事情弄得更糟。</p>
<p>如果一个程序太大，很容易想到的着手方向：最大的函数和数据结构。如果程序太慢，着手方向：对程序进行性能测评，花费时间最多的部分程序和使用最频繁的那部分代码显然是需要优化的目标。如果这方面能够提升，将能大大提高程序的整体运行速度。<br>三个努力方向：</p>
<ul>
<li>在耗时最多的函数中，有些是库函数。如果能减少或不用可帮助大大提升性能。</li>
<li>有效函数之所以耗费了大量的时间是因为它们被调用的<strong>次数非常多</strong>。</li>
<li>有些函数调用次数不多，但每次调用耗费时间却很长。寻找更优质的算法重构是努力的方向。</li>
<li>可以对单个函数进行汇编语言重新编码，函数越小，重新编码越容易。</li>
</ul>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>绝大多数环境都创建某种类型的堆栈帧，函数用它来保存它们的数据，堆栈帧的细节可能各不相同，但它们的基本思路是相当一致的。</p>
<p>提高效率的最好方法是为它选择一种更好的算法，接下来的一种提高程序执行速度的最佳手段是对程序进行性能测评，看看程序在哪个地方花费的时间最多，把优化措施集中在程序的这部分将产生最好的结果。</p>
<h2 id="警告总结"><a href="#警告总结" class="headerlink" title="警告总结"></a>警告总结</h2><ul>
<li>是链接器而不是编译器决定外部标识符的最大长度；</li>
<li>你无法链接由不同编译器产生的程序；</li>
</ul>
<p><img src="/img/" alt></p>
<p><img src="/img/" alt></p>
<p><img src="/img/" alt></p>
<p><img src="/img/" alt></p>
<p><img src="/img/" alt></p>
<p><img src="/img/" alt></p>
<p><img src="/img/" alt></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/C/" rel="tag"># C++</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/09/04/程序员的自我修养 笔记2/" rel="next" title="程序员的自我修养笔记2">
                <i class="fa fa-chevron-left"></i> 程序员的自我修养笔记2
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/09/04/程序员的自我修养 笔记3/" rel="prev" title="程序员的自我修养 笔记3">
                程序员的自我修养 笔记3 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/header.jpg" alt="Hao Yu">
            
              <p class="site-author-name" itemprop="name">Hao Yu</p>
              <p class="site-description motion-element" itemprop="description">Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author</p>
          </div>
          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">301</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>
        	<audio controls="controls" loop="loop" preload="auto" src="/resource/xiaomeihao.mp3">
	        </audio>
	

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yuhao0102" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:yuh18@mails.tsinghua.edu.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#数据"><span class="nav-number">1.</span> <span class="nav-text">数据</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#基本数据类型"><span class="nav-number">2.</span> <span class="nav-text">基本数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#链接属性"><span class="nav-number">2.1.</span> <span class="nav-text">链接属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#存储类型"><span class="nav-number">2.2.</span> <span class="nav-text">存储类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#static关键字"><span class="nav-number">2.3.</span> <span class="nav-text">static关键字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">2.4.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#操作符和表达式"><span class="nav-number">3.</span> <span class="nav-text">操作符和表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#操作符"><span class="nav-number">3.1.</span> <span class="nav-text">操作符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#布尔值"><span class="nav-number">3.2.</span> <span class="nav-text">布尔值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#左值和右值"><span class="nav-number">3.3.</span> <span class="nav-text">左值和右值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#表达式求值"><span class="nav-number">3.4.</span> <span class="nav-text">表达式求值</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#隐式类型转换"><span class="nav-number">3.4.1.</span> <span class="nav-text">隐式类型转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#操作符的属性"><span class="nav-number">3.4.2.</span> <span class="nav-text">操作符的属性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#警告"><span class="nav-number">3.5.</span> <span class="nav-text">警告</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#指针"><span class="nav-number">4.</span> <span class="nav-text">指针</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#内存和地址"><span class="nav-number">4.1.</span> <span class="nav-text">内存和地址</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#值和类型"><span class="nav-number">4.2.</span> <span class="nav-text">值和类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#间接访问操作符"><span class="nav-number">4.3.</span> <span class="nav-text">间接访问操作符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#未初始化和非法的指针"><span class="nav-number">4.4.</span> <span class="nav-text">未初始化和非法的指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#指针常量"><span class="nav-number">4.5.</span> <span class="nav-text">指针常量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#指针表达式"><span class="nav-number">4.6.</span> <span class="nav-text">指针表达式</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#函数"><span class="nav-number">5.</span> <span class="nav-text">函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#函数的参数"><span class="nav-number">5.1.</span> <span class="nav-text">函数的参数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#数组"><span class="nav-number">6.</span> <span class="nav-text">数组</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#指针的效率"><span class="nav-number">6.1.</span> <span class="nav-text">指针的效率</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#初始化"><span class="nav-number">6.2.</span> <span class="nav-text">初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#静态和自动初始化"><span class="nav-number">6.2.1.</span> <span class="nav-text">静态和自动初始化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多维数组"><span class="nav-number">6.3.</span> <span class="nav-text">多维数组</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#字符串、字符和字节"><span class="nav-number">7.</span> <span class="nav-text">字符串、字符和字节</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#不受限制的字符串函数"><span class="nav-number">7.1.</span> <span class="nav-text">不受限制的字符串函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字符串查找基础"><span class="nav-number">7.2.</span> <span class="nav-text">字符串查找基础</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#高级字符串查找"><span class="nav-number">7.3.</span> <span class="nav-text">高级字符串查找</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字符操作"><span class="nav-number">7.4.</span> <span class="nav-text">字符操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内存操作"><span class="nav-number">7.5.</span> <span class="nav-text">内存操作</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#结构和联合"><span class="nav-number">8.</span> <span class="nav-text">结构和联合</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#结构的存储分配"><span class="nav-number">8.1.</span> <span class="nav-text">结构的存储分配</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#位段"><span class="nav-number">8.2.</span> <span class="nav-text">位段</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#动态内存分配"><span class="nav-number">9.</span> <span class="nav-text">动态内存分配</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#malloc和free"><span class="nav-number">9.1.</span> <span class="nav-text">malloc和free</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#calloc和realloc"><span class="nav-number">9.2.</span> <span class="nav-text">calloc和realloc</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#预处理器"><span class="nav-number">10.</span> <span class="nav-text">预处理器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#预定义符号"><span class="nav-number">10.1.</span> <span class="nav-text">预定义符号</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#define"><span class="nav-number">10.2.</span> <span class="nav-text">#define</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#条件编译"><span class="nav-number">10.3.</span> <span class="nav-text">条件编译</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#输入输出函数"><span class="nav-number">11.</span> <span class="nav-text">输入输出函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#错误报告"><span class="nav-number">11.1.</span> <span class="nav-text">错误报告</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#标准IO函数库"><span class="nav-number">11.2.</span> <span class="nav-text">标准IO函数库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#流IO总览"><span class="nav-number">11.3.</span> <span class="nav-text">流IO总览</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#打开流"><span class="nav-number">11.4.</span> <span class="nav-text">打开流</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字符IO"><span class="nav-number">11.5.</span> <span class="nav-text">字符IO</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#未格式化的行IO"><span class="nav-number">11.6.</span> <span class="nav-text">未格式化的行IO</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二进制IO"><span class="nav-number">11.7.</span> <span class="nav-text">二进制IO</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#刷新和定位函数"><span class="nav-number">11.8.</span> <span class="nav-text">刷新和定位函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#改变缓冲方式"><span class="nav-number">11.9.</span> <span class="nav-text">改变缓冲方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#流错误函数"><span class="nav-number">11.10.</span> <span class="nav-text">流错误函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#临时文件"><span class="nav-number">11.11.</span> <span class="nav-text">临时文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件操纵函数"><span class="nav-number">11.12.</span> <span class="nav-text">文件操纵函数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#标准函数库"><span class="nav-number">12.</span> <span class="nav-text">标准函数库</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#整型函数"><span class="nav-number">12.1.</span> <span class="nav-text">整型函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#算数"><span class="nav-number">12.1.1.</span> <span class="nav-text">算数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#随机数"><span class="nav-number">12.1.2.</span> <span class="nav-text">随机数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字符串转换"><span class="nav-number">12.1.3.</span> <span class="nav-text">字符串转换</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#浮点型函数"><span class="nav-number">12.2.</span> <span class="nav-text">浮点型函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#三角函数"><span class="nav-number">12.2.1.</span> <span class="nav-text">三角函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#双曲函数"><span class="nav-number">12.2.2.</span> <span class="nav-text">双曲函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对数和指数函数"><span class="nav-number">12.2.3.</span> <span class="nav-text">对数和指数函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#浮点表示形式"><span class="nav-number">12.2.4.</span> <span class="nav-text">浮点表示形式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#幂"><span class="nav-number">12.2.5.</span> <span class="nav-text">幂</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#底数、顶数、绝对值和余数"><span class="nav-number">12.2.6.</span> <span class="nav-text">底数、顶数、绝对值和余数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字符串转换-1"><span class="nav-number">12.2.7.</span> <span class="nav-text">字符串转换</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#日期和时间函数"><span class="nav-number">12.3.</span> <span class="nav-text">日期和时间函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#处理器时间"><span class="nav-number">12.3.1.</span> <span class="nav-text">处理器时间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#当天时间"><span class="nav-number">12.3.2.</span> <span class="nav-text">当天时间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#日期和时间的转换"><span class="nav-number">12.3.3.</span> <span class="nav-text">日期和时间的转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#非本地跳转"><span class="nav-number">12.3.4.</span> <span class="nav-text">非本地跳转</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#信号"><span class="nav-number">12.4.</span> <span class="nav-text">信号</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#信号名"><span class="nav-number">12.4.1.</span> <span class="nav-text">信号名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#处理信号"><span class="nav-number">12.4.2.</span> <span class="nav-text">处理信号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#信号处理函数"><span class="nav-number">12.4.3.</span> <span class="nav-text">信号处理函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#打印可变参数列表"><span class="nav-number">12.5.</span> <span class="nav-text">打印可变参数列表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#执行环境"><span class="nav-number">12.6.</span> <span class="nav-text">执行环境</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#终止执行"><span class="nav-number">12.6.1.</span> <span class="nav-text">终止执行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#断言"><span class="nav-number">12.6.2.</span> <span class="nav-text">断言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#环境"><span class="nav-number">12.6.3.</span> <span class="nav-text">环境</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#执行系统命令"><span class="nav-number">12.6.4.</span> <span class="nav-text">执行系统命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#排序和查找"><span class="nav-number">12.6.5.</span> <span class="nav-text">排序和查找</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#locale"><span class="nav-number">12.7.</span> <span class="nav-text">locale</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数值和货币格式"><span class="nav-number">12.7.1.</span> <span class="nav-text">数值和货币格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#符号串和locale"><span class="nav-number">12.7.2.</span> <span class="nav-text">符号串和locale</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#改变locale的效果"><span class="nav-number">12.7.3.</span> <span class="nav-text">改变locale的效果</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#运行时环境"><span class="nav-number">13.</span> <span class="nav-text">运行时环境</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#判断运行时环境"><span class="nav-number">13.1.</span> <span class="nav-text">判断运行时环境</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C和汇编语言的接口"><span class="nav-number">13.2.</span> <span class="nav-text">C和汇编语言的接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#运行时效率"><span class="nav-number">13.3.</span> <span class="nav-text">运行时效率</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结-1"><span class="nav-number">13.4.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#警告总结"><span class="nav-number">13.5.</span> <span class="nav-text">警告总结</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>
  <div id="DvelopmentTarget">     
  </div>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart" aria-hidden="false"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>

  
</div>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_uv"> 
  本站访客数<span id="busuanzi_value_site_uv"></span>人次
</span>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  


  

  


  <script type="text/javascript" src="/js/src/love.js"></script>

</body>
</html>
