<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zn-ch">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-center-simple.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="积累,">










<meta name="description" content="第8章 Linux共享库的组织从文件的结构上来讲，共享库和共享对象没什么区别 8.1 共享库兼容性 共享库的更新分为： 1 兼容更新； 2 不兼容更新    导致C语言的共享库ABI（接口）改变的行为有：  导出函数的行为发生改变，也就是调用该函数产生的结果和以前不一致； 导出函数被删除； 导出数据的结构发生变化； 导出函数的接口发生变化；  解决共享库的兼容性问题的有效办法之一是使用共享库版本的">
<meta name="keywords" content="积累">
<meta property="og:type" content="article">
<meta property="og:title" content="程序员的自我修养 笔记3">
<meta property="og:url" content="http://yoursite.com/2020/09/04/程序员的自我修养 笔记3/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="第8章 Linux共享库的组织从文件的结构上来讲，共享库和共享对象没什么区别 8.1 共享库兼容性 共享库的更新分为： 1 兼容更新； 2 不兼容更新    导致C语言的共享库ABI（接口）改变的行为有：  导出函数的行为发生改变，也就是调用该函数产生的结果和以前不一致； 导出函数被删除； 导出数据的结构发生变化； 导出函数的接口发生变化；  解决共享库的兼容性问题的有效办法之一是使用共享库版本的">
<meta property="og:locale" content="zn-ch">
<meta property="og:image" content="http://yoursite.com/img/10.01.png">
<meta property="og:image" content="http://yoursite.com/img/10.02.png">
<meta property="og:image" content="http://yoursite.com/img/10.03.png">
<meta property="og:image" content="http://yoursite.com/img/20161209002406635.png">
<meta property="og:image" content="http://yoursite.com/img/20161209003057738.png">
<meta property="og:image" content="http://yoursite.com/img/20161209003627796.png">
<meta property="og:image" content="http://yoursite.com/img/20161209003839953.png">
<meta property="og:image" content="http://yoursite.com/img/20161209010512894.png">
<meta property="og:updated_time" content="2020-09-09T03:12:34.110Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="程序员的自我修养 笔记3">
<meta name="twitter:description" content="第8章 Linux共享库的组织从文件的结构上来讲，共享库和共享对象没什么区别 8.1 共享库兼容性 共享库的更新分为： 1 兼容更新； 2 不兼容更新    导致C语言的共享库ABI（接口）改变的行为有：  导出函数的行为发生改变，也就是调用该函数产生的结果和以前不一致； 导出函数被删除； 导出数据的结构发生变化； 导出函数的接口发生变化；  解决共享库的兼容性问题的有效办法之一是使用共享库版本的">
<meta name="twitter:image" content="http://yoursite.com/img/10.01.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/09/04/程序员的自我修养 笔记3/">





  <title>程序员的自我修养 笔记3 | Hao Yu's blog</title>
  








 
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zn-ch">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hao Yu's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">The program monkey was eaten by the siege lion.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/resume.pdf" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-mybetterhalf">
          <a href="/mybetterhalf/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>
            
            mybetterhalf
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/04/程序员的自我修养 笔记3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">程序员的自我修养 笔记3</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-09-04T22:04:00+08:00">
                2020-09-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="第8章-Linux共享库的组织"><a href="#第8章-Linux共享库的组织" class="headerlink" title="第8章 Linux共享库的组织"></a>第8章 Linux共享库的组织</h2><p>从文件的结构上来讲，共享库和共享对象没什么区别</p>
<h3 id="8-1-共享库兼容性"><a href="#8-1-共享库兼容性" class="headerlink" title="8.1 共享库兼容性"></a>8.1 共享库兼容性</h3><ul>
<li>共享库的更新分为：<ul>
<li>1 兼容更新；</li>
<li>2 不兼容更新</li>
</ul>
</li>
</ul>
<p>导致C语言的共享库ABI（接口）改变的行为有：</p>
<ol>
<li>导出函数的行为发生改变，也就是调用该函数产生的结果和以前不一致；</li>
<li>导出函数被删除；</li>
<li>导出数据的结构发生变化；</li>
<li>导出函数的接口发生变化；</li>
</ol>
<p>解决共享库的兼容性问题的有效办法之一是使用<strong>共享库版本</strong>的方法。文件名规则：<strong>libname.so.x.y.z</strong></p>
<ul>
<li>x：主版本号。库的重大升级，不同主版本号之间不兼容</li>
<li>y：次版本号。库的增量升级，主版本号相同，高的次版本号的库向后兼容低的次版本号</li>
<li>z：发布版本号。错误修正，性能改进，相同主版本号、次版本号的共享库，不同的发布版本号之间相互完全兼容</li>
</ul>
<p>采用SO-NAME的命名机制来记录共享库的依赖关系。每个共享库都有对应的“SO-NAME“，即共享库的文件名去掉次版本号和发布版本号，保留主版本号。在Linux系统中，系统会为每个共享库在它所在的目录创建一个跟”SO-NAME“相同的并且指向它的软链接，使得所有依赖某个共享库的模块，在编译时都使用共享库的SO-NAME，而不依赖具体版本号。SO-NAME表示一个库的接口，接口不向后兼容，SO-NAME就发生变化。如果需要一个libXXX.so.2.6.1的共享库，只需要加上<code>-lXXX</code>，这个XXX叫做<strong>链接名</strong>，不同类型的库可能会有同样的链接名。</p>
<h3 id="8-2-符号版本"><a href="#8-2-符号版本" class="headerlink" title="8.2 符号版本"></a>8.2 符号版本</h3><ul>
<li>次版本交会问题：低次版本号不兼容高次版本号，高次版本号兼容低次版本号  —- 解决方式：符号版本机制</li>
<li>基于符号的版本机制方案的基本思路：让每个导入和导出的符号都有一个相关联的版本号，它的实际做法类似于名称修饰的方法</li>
<li>链接器在链接时根据符号版本脚本中指定的关系来产生共享库，并且设置符号的集合与它们之间的关系</li>
</ul>
<h3 id="8-3-共享库系统路径"><a href="#8-3-共享库系统路径" class="headerlink" title="8.3 共享库系统路径"></a>8.3 共享库系统路径</h3><p>FHS(File Hierarchy Standard)标准规定一个系统的系统文件应该如何存放，包括各个目录的结构、组织和作用，这有利于促进各个开源操作系统之间的兼容性。FHS规定，系统中存放共享库的主要位置：</p>
<ol>
<li>/lib 存放系统最关键和基础的共享库</li>
<li>/usr/lib 保存一些非系统运行时所需要的关键性的共享库</li>
<li>/usr/local/lib 存放一些和操作系统本身并不十分相关的库</li>
</ol>
<h3 id="8-4-共享库查找过程"><a href="#8-4-共享库查找过程" class="headerlink" title="8.4 共享库查找过程"></a>8.4 共享库查找过程</h3><p>动态链接器对于模块的查找规则：如果“.dynamic”的DT_NEED里面保存的事绝对路口，那动态链接器就按照路径查找；如果DT_NEED里面保存的是相对路径，那么动态链接器会在/lib、/usr/lib和由/etc/Id.so.conf配置文件指定的目录中查找共享库。为了程序的可移植性和兼容性，共享库的路径往往是相对的</p>
<p>ld.so.conf是一个文本配置文件，指定的目录有：</p>
<ul>
<li>/uer/local/lib；</li>
<li>/lib/i486-linux-gnu；</li>
<li>/usr/lib/i486-linux-gnu</li>
</ul>
<p>Linux系统都有一个ldconfig程序，作用是为共享库目录下的各个共享库创建、删除和更新相应的SO-NAME，并且把这些SO-NAME收集起来，集中存放到/etc/Id.so.cache文件里面，建立一个SO-NAME缓存，加快共享库的查找过程</p>
<p>如果动态链接器在/etc/Id.so.cache里面没有找到所需要的共享库，那么还会遍历/lib和/usr/lib这两个目录，如果还没有宣告失败</p>
<h3 id="8-5-环境变量"><a href="#8-5-环境变量" class="headerlink" title="8.5 环境变量"></a>8.5 环境变量</h3><p><code>LD_LIBRARY_PATH</code>：可以临时改变某个应用程序的共享库查找路径，而不会影响系统中的其他程序。动态链接器会按照下列顺序依次装载或者查找共享对象：</p>
<ul>
<li>由环境变量LD_LIBRARY_PATH指定的路径</li>
<li>由路径缓存文件/etc/Id.so.cache指定的路径</li>
<li>默认共享库目录，先/usr/lib，后/lib</li>
</ul>
<p><code>LD_PRELOAD</code>：指定预先装载的一些共享库或者目标文件（比LD_LIBRARY_PATH优先，无论是否依赖，都会装载），由于全局符号介入这个机制的存在，LD_PRELOAD里面指定的共享库或目标文件中的全局符号，这使得我们可以方便地改写标准库中的函数。</p>
<p><code>LD_DEBUG</code>：可以打开动态链接器的调试功能，设置这个变量时，动态链接器会在调试信息中打印出有用的信息。</p>
<h1 id="LD-DEBUG-help-ls"><a href="#LD-DEBUG-help-ls" class="headerlink" title="LD_DEBUG=help ls"></a>LD_DEBUG=help ls</h1><p>Valid options for the LD_DEBUG environment variable are:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">libs        display library search paths</span><br><span class="line">reloc       display relocation processing</span><br><span class="line">files       display progress for input file</span><br><span class="line">symbols     display symbol table processing</span><br><span class="line">bindings    display information about symbol binding</span><br><span class="line">versions    display version dependencies</span><br><span class="line">all         all previous options combined</span><br><span class="line">statistics  display relocation statistics</span><br><span class="line">unused      determined unused DSOs</span><br><span class="line">help        display this help message and exit</span><br></pre></td></tr></table></figure></p>
<p>To direct the debugging output into a file instead of standard output<br>a filename can be specified using the LD_DEBUG_OUTPUT environment variable.</p>
<h3 id="8-6-共享库的创建和安装"><a href="#8-6-共享库的创建和安装" class="headerlink" title="8.6 共享库的创建和安装"></a>8.6 共享库的创建和安装</h3><p>共享库的创建，和共享对象的创建过程基本一致</p>
<ul>
<li>最关键的使用GCC的两个参数：“-shared”和“-fPIC”</li>
<li>“-shared”表示输出结果是共享库类型</li>
<li>“-fPIC”表示使用地址无关代码技术来生产输出文件</li>
<li>“-Wl, -soname, my_soname”将指定参数传递给链接器</li>
</ul>
<p>清除符号信息：strip：清除共享库或者可执行文件的所有符号和调试信息</p>
<p>共享库安装：</p>
<ul>
<li>将共享库复制到某个标准的共享库目录，如/lib、/usr/lib等，然后运行Idconfig即可，需要系统root权限</li>
<li>建立相应的SO_NAME软链接，并告诉编译器和程序如何查找该共享库<ol>
<li>建立软链接，ldconfig -n  shared_library-directory</li>
<li>编译程序时，指定共享库的位置，“-L”:指定共享库搜索目录；“-l”:指定共享库路径</li>
</ol>
</li>
</ul>
<p>共享库构造和析构函数</p>
<ul>
<li>在函数声明时加上<code>__attribute__ ((constructor))</code>的属性，指定该函数为共享库构造函数</li>
<li>在函数声明时加上<code>__attribute__ ((destructor))</code>的属性，指定该函数为共享库析构函数</li>
<li>多个构造函数，默认情况下执行顺序没有规定，需要可以使用优先级参数定义<code>__attribute__((constructor(degree)))</code></li>
</ul>
<p>共享库脚本：共享库普遍时动态链接的ELF共享对象文件（.so）,事实上，共享库还可以是符号一定格式的链接脚本文件</p>
<p>系统存在大量的共享库，随着更新和升级形成不同的相互兼容和不兼容的版本。如何管理和维护这些共享库，让它们不同的版本之间不会相互冲突时使用共享库的一个重要问题</p>
<h2 id="第10章-内存"><a href="#第10章-内存" class="headerlink" title="第10章 内存"></a>第10章 内存</h2><p>内存是装载程序运行的介质，也是程序进行各种运算和表达的场所。</p>
<h3 id="10-1-程序的内存布局"><a href="#10-1-程序的内存布局" class="headerlink" title="10.1 程序的内存布局"></a>10.1 程序的内存布局</h3><p>在32位系统里，内存空间拥有4GB的寻址能力。相对于16位时代i386的短地址加段内偏移的寻址模式，如今的应用程序可以直接使用32位的地址进行寻址，这被称为平坦的内存模型。</p>
<p>尽管当前的内存空间号称是平坦的，但实际上内存仍然在不同的地址区间上有着不同的地位，例如，大多数操作系统会将4GB的内存空间上的一部分挪给内核使用，应用程序无法直接访问这一段内存，这一部分内存地址被称为内核空间。Windows在默认情况下会将高地址的2GB空间分配给内核，而Linux默认情况下将高地址的1GB空间分配给内核。</p>
<p>用户使用的剩下2GB或3GB的内存空间称为用户空间。在用户空间里，有许多地址区间有特殊的地位：</p>
<ul>
<li>栈： 栈用于维护函数调用的上下文，离开了栈函数调用就没法实现。栈通常在用户空间的最高地址处分配。</li>
<li>堆：堆是用来容纳应用程序动态分配的内存区域，当程序使用malloc或new分配内存时，得到的内存来自堆里。堆通常存在于栈的下方，在某些时候，堆也可能没有固定统一的存储区域。堆一般比栈大很多。</li>
<li>可执行文件映像：这里存储着可执行文件在内存里的映像，由装载器在装载时将可执行文件的内存读取或映射到这里。</li>
<li>保留区：保留区并不是一个单一的内存区域，而是对内存中受到保护而禁止访问的内存区域的总称。例如，大多数操作系统里，极小的地址通常都是不允许访问的，如NULL。</li>
</ul>
<p><img src="/img/10.01.png" alt></p>
<p>动态链接库映射区用于映射装载的动态链接库。在Linux下，如果可执行文件依赖其他共享库，那么系统就会为它在从0x40000000开始的地址分配相应的空间，并将共享库载入到该空间。</p>
<blockquote>
<p>段错误是怎么回事？</p>
<p>这是典型的非法指针解引用造成的错误。当指针指向一个不允许读或写的内存地址，而程序却试图利用指针来读或写该地址的时候，就会出现这个错误。<br>在Linux或Windows的内存布局中，有些地址是始终不能读写的，例如0地址。还有些地址是一开始不允许读写，应用程序必须事先请求获取这些地址的读写权，或者某些地址一开始并没有映射到实际的物理内存，应用程序必须事先请求将这些地址映射到实际的物理地址，之后才能够自由地读写这片内存。当一个指针指向这些区域的时候，对它指向的内存进行读写就会引发错误。造成这样的最普遍的原因有两种：</p>
<ol>
<li><p>程序员将指针初始化为NULL，之后却没有给它一个合理的值就开始使用指针。</p>
</li>
<li><p>程序员没有初始化栈上的指针，指针的值一般会是随机数，之后就直接开始使用指针。（野指针）</p>
</li>
</ol>
</blockquote>
<h3 id="10-2-栈与调用惯例"><a href="#10-2-栈与调用惯例" class="headerlink" title="10.2 栈与调用惯例"></a>10.2 栈与调用惯例</h3><h4 id="10-2-1-什么是栈"><a href="#10-2-1-什么是栈" class="headerlink" title="10.2.1 什么是栈"></a>10.2.1 什么是栈</h4><p>在经典的计算机科学中，栈被定义为一个特殊的容器，用户可以将数据压入栈中，也可以将已经压入栈中的数据弹出，但栈这个容器必须遵守一条规则：先入栈的数据后出栈（FIFO）。</p>
<p>在计算机系统中，栈则是一个具有以上属性的动态内存区域。程序可以将数据压入栈中，也可以将数据从栈顶弹出。压栈操作使得栈增大，而弹出操作使栈减小。</p>
<p>在经典的操作系统里，栈总是向下增长的。在i386下，栈顶由称为esp的寄存器进行定位。压栈的操作使栈顶的地址减小，弹出的操作使栈顶地址增大。</p>
<p>栈在程序运行中具有举足轻重的地位。最重要的，栈保存了一个函数调用所需要的维护信息，这常常被称为堆栈帧（Stack Frame）或活动记录（Active Record）。堆栈帧一般包括如下几方面内容：</p>
<ul>
<li>函数的返回地址和参数。</li>
<li>临时变量：包括函数的非静态局部变量以及编译器自动生成的其他临时变量。</li>
<li>保存的上下文：包括在函数调用前后需要保持不变的寄存器。</li>
</ul>
<p>在i386中，一个函数的活动记录用ebp和esp这两个寄存器划定范围。esp寄存器始终指向栈的顶部，同时也就指向了当前函数的活动记录的顶部。而相对的，ebp寄存器指向了函数活动记录的一个固定位置，ebp寄存器又被称为帧指针（Frame Pointer）。一个很常见的活动记录实例如下所示：</p>
<p><img src="/img/10.02.png" alt></p>
<p>在参数之后的数据（包括参数）即是当前函数的活动记录，ebp固定在图中所示的位置，不随这个函数的执行而变化，相反地，esp始终指向栈顶，因此随着函数的执行，esp会不断变化。固定不变的ebp可以用来定位函数活动记录的各个数据。在ebp之前首先是这个函数的返回地址，它的地址是ebp-4，再往前是压入栈中的参数，它们的地址分别是ebp-8、ebp-12等，视参数数量和大小而定。ebp所直接指向的数据是调用该函数前ebp的值，这样在函数返回的时候，ebp可以通过读取这个值恢复到调用前的值。之所以函数的活动记录会形成这样的结构，是因为函数调用本身是如此书写的：一个i386下的函数总是这样调用的：</p>
<ul>
<li>把所有或一部分参数压入栈中，如果有其它参数没有入栈，那么使用某些特定的寄存器传递。</li>
<li>把当前指令的下一个指令的地址压入栈中。</li>
<li>跳转到函数体执行。</li>
</ul>
<p>其中第2步和第3步由指令call一起执行。跳转到函数体之后即开始执行函数，而i386函数体的“标准”开头是这样的（但也可以不一样）：</p>
<ul>
<li>push ebp：把ebp压入栈中（称为old ebp）。</li>
<li>mov ebp, esp：ebp = esp（这时ebp指向栈顶，而此时栈顶就是old ebp）。</li>
<li>【可选】sub esp, xxx：在栈上分配xxx字节的临时空间。</li>
<li>【可选】push xxx：如有必要，保存名为xxx寄存器（可重复多个）。</li>
</ul>
<p>把ebp压入栈中，是为了在函数返回的时候便于恢复以前的ebp值。而之所以可能要保存一些寄存器，在于编译器可能要求某些寄存器在调用前后保持不变，那么函数就可以在调用开始时将这些寄存器的值压入栈中，在结束后再取出。函数返回则正好相反：</p>
<ul>
<li>【可选】pop xxx：如有必要，恢复保存过的寄存器（可重复多个）。</li>
<li>mov esp, ebp：恢复esp同时回收局部变量空间。</li>
<li>pop ebp：从栈中恢复保存的ebp的值。</li>
<li>ret：从栈中取得返回地址，并跳转到该位置。</li>
</ul>
<h4 id="10-2-2-调用惯例"><a href="#10-2-2-调用惯例" class="headerlink" title="10.2.2 调用惯例"></a>10.2.2 调用惯例</h4><p>函数的调用方和被调用方对于函数如何调用须要有一个明确的规定，只要双方遵守同样的规定，函数才能被正确地调用，这样的规定被称为调用惯例。一个调用惯例一般会规定如下几个方面的内容：</p>
<ul>
<li><strong>函数参数的传递顺序和方式</strong> 函数参数的传递有很多种方式，最常见的一种是通过栈传递。函数的调用方将参数压入栈中，函数自己再从栈中将参数取出。对于有多个参数的函数，调用惯例要规定函数调用方将参数压栈的顺序：是从左到右，还是从右到左。有些调用惯例还允许使用寄存器传递参数，以提高性能。</li>
<li><strong>栈的维护方式</strong> 在函数将参数压栈之后，函数体会被调用，伺候需要被压入栈中的参数全部弹出，以使得栈在函数调用前后保持一致。这个弹出的工作可以由函数的调用方来完成，也可以由函数本身来完成。</li>
<li><strong>名字修饰的策略</strong> 为了链接的时候对调用惯例进行区分，调用惯例要对函数本身的名字进行修饰。不同的调用惯例有不同的修饰策略。</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>调用惯例</th>
<th>出栈方</th>
<th>参数传递</th>
<th>名字修饰</th>
</tr>
</thead>
<tbody>
<tr>
<td>cdecl</td>
<td>函数调用方</td>
<td>从右至左的顺序压参数入栈</td>
<td>下划线+函数名</td>
</tr>
<tr>
<td>stdcall</td>
<td>函数本身</td>
<td>从右至左的顺序压参数入栈</td>
<td>下划线+函数名+@+参数的字节数</td>
</tr>
<tr>
<td>fastcall</td>
<td>函数本身</td>
<td>头两个DWORD类型或者占更少字节的参数被放入寄存器，其他剩下的参数按从右至左的顺序压入栈中</td>
<td>@+函数名+@+参数的字节数</td>
</tr>
<tr>
<td>pascal</td>
<td>函数本身</td>
<td>从左至右的顺序压参数入栈</td>
<td>较为复杂，参见pascal文档</td>
</tr>
</tbody>
</table>
</div>
<h4 id="10-2-3-函数返回值传递"><a href="#10-2-3-函数返回值传递" class="headerlink" title="10.2.3 函数返回值传递"></a>10.2.3 函数返回值传递</h4><p>函数将返回值存储在eax中，返回后函数的调用方再读取eax。但是eax本身只有4个字节，对于返回5~8字节对象的情况，几乎所有的调用惯例都是采用eax和edx联合返回的方式进行的。其中eax存储返回值要低4字节，而edx存储返回值要高1~4字节。而对于超过8字节的返回类型，一般会栈上额外开辟一片空间，并将这片空间的一部分作为传递返回值的临时对象，并将对象的地址作为隐藏参数传递给函数。</p>
<h3 id="10-3-堆与内存管理"><a href="#10-3-堆与内存管理" class="headerlink" title="10.3 堆与内存管理"></a>10.3 堆与内存管理</h3><h4 id="10-3-1-什么是堆"><a href="#10-3-1-什么是堆" class="headerlink" title="10.3.1 什么是堆"></a>10.3.1 什么是堆</h4><p>堆是一块巨大的内存空间，常常占据整个虚拟空间的绝大部分。在这片空间里，程序可以请求一块连续内存，并自由地使用，这块内存在程序主动放弃之前都会一直保持有效。</p>
<h4 id="10-3-2-Linux进程堆管理"><a href="#10-3-2-Linux进程堆管理" class="headerlink" title="10.3.2 Linux进程堆管理"></a>10.3.2 Linux进程堆管理</h4><p>Linux提供了两种堆空间分配方式：brk()系统调用和mmap()系统调用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">brk</span><span class="params">(<span class="keyword">void</span> *end_data_segment)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mmap</span><span class="params">(<span class="keyword">void</span> *start, <span class="keyword">size_t</span> length, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags, <span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset)</span></span>;</span><br></pre></td></tr></table></figure>
<p>glibc的malloc函数是这样处理用户的空间请求的：对于小于128KB的请求来说，它会在现有的堆空间里，按照堆分配算法为它分配一块空间并返回；对于大于128KB的请求来说，它会使用mmap()函数为它分配一块匿名空间，然后在这个匿名空间中为用户分配空间。</p>
<h4 id="10-3-3-Windows进程堆管理"><a href="#10-3-3-Windows进程堆管理" class="headerlink" title="10.3.3 Windows进程堆管理"></a>10.3.3 Windows进程堆管理</h4><p><img src="/img/10.03.png" alt></p>
<p>Windows进程将地址空间分配给了各种EXE、DLL文件、堆、栈。其中EXE文件一般位于0x00400000起始地址；而一部分DLL位于0x10000000起始地址，如运行库DLL；还有一部分DLL位于接近0x80000000位置，如系统DLL、NTDLL.DLL、Kernel32.DLL。</p>
<p>Windows提供了一个API叫做VirtualAlloc()，用于向系统申请空间，它与Linux下的mmap非常相似。实际上VirtualAlloc()申请的空间不一定只用于堆，它仅仅是向系统预留了一块虚拟地址，应用程序可以按照需要随意使用。在使用VirtualAlloc()函数申请空间时，系统要求空间大小必须为页的整数倍，即对于x86系统来说，必须是4096字节的整数倍。为了避免造成大量的浪费，需要实现一个分配的算法。Windows堆管理器提供了与堆相关的API用来创建、分配、释放和销毁堆空间（HeapCreate、HeapAlloc、HeapFree和HeapDestroy）。</p>
<h4 id="10-3-4-堆分配算法"><a href="#10-3-4-堆分配算法" class="headerlink" title="10.3.4 堆分配算法"></a>10.3.4 堆分配算法</h4><h5 id="1-空闲链表"><a href="#1-空闲链表" class="headerlink" title="1. 空闲链表"></a>1. 空闲链表</h5><p>把堆中各个空闲的块按照链表的方式连接起来，当用户请求一块空间时，可以遍历整个链表，知道找到合适大小的块并且将它拆分；当用户释放空间时将它合并到空闲链表中。</p>
<h5 id="2-位图"><a href="#2-位图" class="headerlink" title="2. 位图"></a>2. 位图</h5><p>将整个堆划分为大量的块，每个块的大小相同。当用户请求内存的时候，总是分配整数个块的空间给用户，第一个块我们称为已分配区域的头，其余的称为已分配区域的主体。而我们可以使用一个整数数组来记录块的使用情况，由于每个块只有头/主体/空闲三种状态，因此仅仅需要两位即可表示一个块。</p>
<h5 id="3-对象池"><a href="#3-对象池" class="headerlink" title="3. 对象池"></a>3. 对象池</h5><p>如果每一次分配的大小都一样，那么就可以按照这个每次请求分配的大小作为一个单位，把整个堆空间划分为大量的小块，每次请求时只需要找到一个小块就可以了。</p>
<h2 id="第11章-运行库"><a href="#第11章-运行库" class="headerlink" title="第11章 运行库"></a>第11章 运行库</h2><h3 id="11-1-入口函数和程序初始化"><a href="#11-1-入口函数和程序初始化" class="headerlink" title="11.1 入口函数和程序初始化"></a>11.1 入口函数和程序初始化</h3><p>入口函数和入口点（Entry Point）：首先运行的代码不是main函数，而是负责准备main函数执行所需要的环境、调用main函数的函数；在main函数返回后，它会记录main函数的返回值，并调用atexit函数注册的函数，然后结束进程。</p>
<p>程序运行典型步骤：</p>
<ol>
<li>操作系统创建进程后，把控制权交到了程序的入口，这个入口往往是运行库中的某个入口函数；</li>
<li>入口函数对运行库和程序运行环境进行初始化，包括堆、I/O、线程、全局变量构造等等；</li>
<li>入口函数在完成初始化后，调用 main 函数，正式开始执行程序主体部分；</li>
<li>main 函数执行完毕后，返回到入口函数，入口函数进行清理工作，包括全局变量析构、堆销毁、关闭 I/O 等，然后进行系统调用结束进程。</li>
</ol>
<h4 id="11-1-2-入口函数"><a href="#11-1-2-入口函数" class="headerlink" title="11.1.2 入口函数"></a>11.1.2 入口函数</h4><p>glibc的启动过程在不同的情况下差别较大，比如静态glibc和动态glibc，glibc用于可执行文件和用于共享库，这样的差别可组合出4种情况，在此以最简单的可执行文件+静态glibc为例进行说明。</p>
<p>glibc的入口函数为_start（由ld链接器默认的链接脚本指定，可通过参数人为设定自己的入口）。_start由汇编实现，平台相关。书中以i386为例<br><img src="/img/20161209002406635.png" alt></p>
<p>这省略了不重要代码，可以看到_start最终调用了<strong>libc_start_main。加粗部分为对该部分的完整调用过程：前7个push完成给</strong>libc_start_main（有7个形参）传递参数的任务。在看回最开始的三条指令前，必须清楚的知道：在调用_start前，装载器会把用户的参数和环境变量压入栈中。</p>
<ul>
<li>xor指令（异或）的作用是将ebp寄存器置0，目的是表明当前是程序的最外层函数。</li>
<li>pop指令将argc值（即参数个数）传递给esi寄存器</li>
<li>mov指令将arg0的地址存放到ecx寄存器</li>
</ul>
<p><img src="/img/20161209003057738.png" alt></p>
<p>通过以上分析，可将_start简化成如下可读性代码：<br><img src="/img/20161209003627796.png" alt></p>
<p>接着分析__libc_start_main，接口如下：<br><img src="/img/20161209003839953.png" alt></p>
<p>与上述push的七个参数正好一致，并且参数由右至左入栈（涉及调用惯例问题）。其中:</p>
<ul>
<li>ubp_av为arg0的地址</li>
<li>init为main调用前的初始化函数</li>
<li>fini为main调用后的收尾工作</li>
<li>rtld_fini处理与动态加载有关的收尾工作（rtld = runtime loader）</li>
<li>stack_end为栈底地址，即栈空间的起始地址（栈空间由高地址往地址增长），__libc_start_main内部将会保存栈底地址以备他用。</li>
</ul>
<p>exit的代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exit</span> <span class="params">(<span class="keyword">int</span> status)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (__exit_funcs != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// __exit_funcs是存储由__cxa_atexit和atexit注册的函数链表</span></span><br><span class="line">        <span class="comment">// 执行注册函数</span></span><br><span class="line">        __exit_funcs = __exit_funcs-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    _exit(status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中<code>__exit_funcs</code>是存储由<code>__cxa_atexit</code>和atexit注册的函数的链表。最后的<code>_exit</code>的作用是调用了exit这个系统调用。<br><img src="/img/20161209010512894.png" alt></p>
<p>_exit调用后，进程就结束了。由此可见，进程正常结束有两种情况：</p>
<ul>
<li>main正常返回即未调用exit系统调用，在__libc_start_main执行完main后会主动调用exit</li>
<li>若main里主动调用exit，则不执行进程直接结束，不返回到__libc_start_main</li>
<li>亦即，无论如何，exit必然会被执行到，它是进程结束的必经之路。</li>
</ul>
<h3 id="11-2-C-C-运行库"><a href="#11-2-C-C-运行库" class="headerlink" title="11.2 C/C++ 运行库"></a>11.2 C/C++ 运行库</h3><p>任何一个C程序，它的背后都有一套庞大的代码来进行支撑，以使得该程序能够正常运行。这套代码至少包括入口函数，及其所依赖的函数所构成的函数集合。当然，它还理应包括各种标准库函数的实现。这样的一个代码集合称之为<strong>运行时库</strong>(Runtime Library)。而C语言的运行库，即被称为<strong>C运行库</strong>(CRT)。</p>
<p>一个C语言运行库大致包含了如下功能：</p>
<ol>
<li>启动与退出：包括入口函数及入口函数所依赖的其他函数等。</li>
<li>标准函数：由C语言标准规定的C语言标准库所拥有的函数实现。</li>
<li>I/O：I/O功能的封装和实现，参见上一节中I/O初始化部分。</li>
<li>堆：堆的封装和实现，参见上一节中堆初始化部分。</li>
<li>语言实现：语言中一些特殊功能的实现。</li>
<li>调试：实现调试功能的代码。</li>
</ol>
<p>在这些运行库的组成成分中，C语言标准库占据了主要地位并且大有来头。C语言标准库是C语言标准化的基础函数库，我们平时使用的printf、exit等都是标准库中的一部分。标准库定义了C语言中普遍存在的函数集合。</p>
<h4 id="11-2-2-C语言标准库"><a href="#11-2-2-C语言标准库" class="headerlink" title="11.2.2 C语言标准库"></a>11.2.2 C语言标准库</h4><p>C语言标准库还有一些特殊的库，用于执行一些特殊的操作，例如：</p>
<ul>
<li>变长参数(stdarg.h)。</li>
<li>非局部跳转(setjmp.h)。</li>
</ul>
<p>变长参数是C语言的特殊参数形式，例如如下函数声明：<code>int printf(const char* format, ...);</code>。如此的声明表明，printf函数除了第一个参数类型为const char*之外，其后可以追加任意数量、任意类型的参数。在函数的实现部分，可以使用stdarg.h里的多个宏来访问各个额外的参数：假设lastarg是变长参数函数的最后一个具名参数(例如printf里的format)，那么在函数内部定义类型为va_list的变量：<code>va_list ap;</code>，该变量以后将会依次指向各个可变参数。ap必须用宏va_start初始化一次，其中lastarg必须是函数的最后一个具名的参数。</p>
<p><code>va_start(ap, lastarg);</code>此后，可以使用va_arg宏来获得下一个不定参数(假设已知其类型为type)：<code>type next = va_arg(ap, type);</code>。在函数结束前，还必须用宏va_end来清理现场。在这里我们可以讨论这几个宏的实现细节。在研究这几个宏之前，我们要先了解变长参数的实现原理。变长参数的实现得益于C语言默认的cdecl调用惯例的自右向左压栈传递方式。</p>
<p>下面让我们来看va_list等宏应该如何实现。</p>
<ul>
<li><code>va_list</code>实际是一个指针，用来指向各个不定参数。由于类型不明，因此这个<code>va_list</code>以<code>void*</code>或<code>char*</code>为最佳选择。</li>
<li><code>va_start</code>将<code>va_list</code>定义的指针指向函数的最后一个参数后面的位置，这个位置就是第一个不定参数。</li>
<li><code>va_arg</code>获取当前不定参数的值，并根据当前不定参数的大小将指针移向下一个参数。</li>
<li><code>va_end</code>将指针清0。</li>
</ul>
<p>按照以上思路，va系列宏的一个最简单的实现就可以得到了，如下所示：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> va_list char*</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> va_start(ap,arg) (ap=(va_list)&amp;arg+sizeof(arg))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> va_arg(ap,t) (*(t*)((ap+=sizeof(t))-sizeof(t)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> va_end(ap) (ap=(va_list)0)</span></span><br></pre></td></tr></table></figure></p>
<p>变长参数宏：在很多时候我们希望在定义宏的时候也能够像print一样可以使用变长参数，即宏的参数可以是任意个，这个功能可以由编译器的变长参数宏实现。在GCC编译器下，变长参数宏可以使用“##”宏字符串连接操作实现，比如：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> printf(args…) fprintf(stdout, ##args)</span></span><br></pre></td></tr></table></figure></p>
<p>那么<code>printf(“%d %s”, 123, “hello”)</code>就会被展开成：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, “%d %s”, <span class="number">123</span>, “hello”)</span><br></pre></td></tr></table></figure></p>
<p>非局部跳转即使在C语言里也是一个备受争议的机制。使用非局部跳转，可以实现从一个函数体内向另一个事先登记过的函数体内跳转，而不用担心堆栈混乱。下面让我们来看一个示例：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	longjmp(b, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (setjmp(b))</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"World\n"</span>);</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Hello "</span>);</span><br><span class="line">		f();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这段代码按常理不论setjmp返回什么，也只会打印出“Hello ”和“World!”之一，然而事实上的输出是：<code>Hello World!</code></p>
<p>实际上，当setjmp正常返回的时候，会返回0，因此会打印出“Hello ”的字样。而longjmp的作用，就是让程序的执行流回到当初setjmp返回的时刻，并且返回由longjmp指定的返回值(longjmp的参数2)，也就是1，自然接着会打印出“World!”并退出。换句话说，longjmp可以让程序“时光倒流”回setjmp返回的时刻，并改变其行为，以至于改变了未来。</p>
<h4 id="11-2-3-glibc与MSVC-CRT"><a href="#11-2-3-glibc与MSVC-CRT" class="headerlink" title="11.2.3 glibc与MSVC CRT"></a>11.2.3 glibc与MSVC CRT</h4><p>　运行库是平台相关的，因为它与操作系统结合得非常紧密。C语言的运行库从某种程度上来讲是C语言的程序和不同操作系统平台之间的抽象层，它将不同的操作系统API抽象成相同的库函数。比如我们可以在不同的操作系统平台下使用fread来读取文件，而事实上fread在不同的操作系统平台下的实现是不同的，但作为运行库的使用者我们不需要关心这一点。</p>
<p>glibc即GNU C Library，是GNU旗下的C标准库。发布版本主要由两部分组成，一部分是头文件，比如stdio.h、stdlib.h等，它们往往位于/usr/include;另外一部分则是库的二进制文件部分。二进制部分主要的就是C语言标准库，它有静态和动态两个版本。动态的标准库我们及在本书的前面章节中碰到过了，它位于/lib/libc.so.6;而静态标准库位于/usr/lib/libc.a。事实上glibc除了C标准库之外，还有几个辅助程序运行的运行库，这几个文件可以称得上是真正的“运行库”。它们就是/usr/lib/crt1.o、/usr/lib/crti.o和/usr/lib/crtn.o。是不是对这几个文件还有点印象呢?我们在第2章讲到静态库链接的时候已经碰到过它们了，虽然它们都很小，但这几个文件都是程序运行的最关键的文件。</p>
<p>glibc启动文件：crt1.o里面包含的就是程序的入口函数_start，由它负责调用<code>__libc_start_main</code>初始化libc并且调用main函数进入真正的程序主体。实际上最初开始的时候它并不叫做crt1.o，而是叫做crt.o，包含了基本的启动、退出代码。由于当时有些链接器对链接时目标文件和库的顺序有依赖性，crt.o这个文件必须被放在链接器命令行中的所有输入文件中的第一个，为了强调这一点，crt.o被更名为crt0.o，表示它是链接时输入的第一个文件。</p>
<p>后来由于C++的出现和ELF文件的改进，出现了必须在main()函数之前执行的全局/静态对象构造和必须在main()函数之后执行的全局/静态对象析构。为了满足类似的需求，运行库在每个目标文件中引入两个与初始化相关的段“.init”和“.finit”。运行库会保证所有位于这两个段中的代码会先于/后于main()函数执行，所以用它们来实现全局构造和析构就是很自然的事情了。链接器在进行链接时，会把所有输入目标文件中的“.init”和“.finit”按照顺序收集起来，然后将它们合并成输出文件中的“.init”和“.finit”。但是这两个输出的段中所包含的指令还需要一些辅助的代码来帮助它们启动(比如计算GOT之类的)，于是引入了两个目标文件分别用来帮助实现初始化函数的crti.o和crtn.o。</p>
<p>与此同时，为了支持新的库和可执行文件格式，crt0.o也进行了升级，变成了crt1.o。crt0.o和crt1.o之间的区别是crt0.o为原始的，不支持“.init”和“.finit”的启动代码，而crt1.o是改进过后，支持“.init”和“.finit”的版本。这一点我们从反汇编crt1.o可以看到，它向libc启动函数<strong>libc_start_main()传递了两个函数指针`</strong>libc_csu_init<code>和</code>__libc_csu_fini`，这两个函数负责调用_init()和_finit()，我们在后面“C++全局构造和析构”的章节中还会详细分析。</p>
<p>在默认情况下，ld链接器会将libc、crt1.o等这些CRT和启动文件与程序的模块链接起来，但是有些时候，我们可能不需要这些文件，或者希望使用自己的libc和crt1.o等启动文件，以替代系统默认的文件，这种情况在嵌入式系统或操作系统内核编译的时候很常见。GCC提高了两个参数“-nostartfile”和“-nostdlib”，分别用来取消默认的启动文件和C语言运行库。</p>
<p>其实C++全局对象的构造函数和析构函数并不是直接放在.init和.finit段里面的，而是把一个执行所有构造/析构的函数的调用放在里面，由这个函数进行真正的构造和析构。</p>
<p>除了全局对象构造和析构之外，.init和.finit还有其他的作用。由于它们的特殊性(在main之前/后执行)，一些用户监控程序性能、调试等工具经常利用它们进行一些初始化和反初始化的工作。当然我们也可以使用<code>__attribute__((section(“.init”)))</code>将函数放到.init段里面，但是要注意的是普通函数放在“.init”是会破坏它们的结构的，因为函数的返回指令使得_init()函数会提前返回，必须使用汇编指令，不能让编译器产生“ret”指令。</p>
<p>在第2章中我们在链接时碰到过的诸多输入文件中，已经解决了crt1.o、crti.o和crtn.o，剩下的还有几个crtbeginT.o、libgcc.a、libgcc_eh.a、crtend.o。严格来讲，这几个文件实际上不属于glibc，它们是GCC的一部分，它们都位于GCC的安装目录下：</p>
<ul>
<li>/usr/lib/gcc/i486-Linux-gnu/4.1.3/crtbeginT.o</li>
<li>/usr/lib/gcc/i486-Linux-gnu/4.1.3/libgcc.a</li>
<li>/usr/lib/gcc/i486-Linux-gnu/4.1.3/libgcc_eh.a</li>
<li>/usr/lib/gcc/i486-Linux-gnu/4.1.3/crtend.o</li>
</ul>
<p>首先是crtbeginT.o及crtend.o，这两个文件是真正用于实现C++全局构造和析构的目标文件。是crti.o和crtn.o中的“.init”和“.finit”提供一个在main()之前和之后运行代码的机制，而真正全局构造和析构则由crtbeginT.o和crtend.o来实现。我们在后面的章节还会详细分析它们的实现机制。</p>
<p>libgcc.a里面包含的函数主要包括整数运算、浮点数运算(不同的CPU对浮点数的运算方法很不相同)等，而libgcc_eh.a则包含了支持C++的异常处理(Exception Handling)的平台相关函数。另外GCC的安装目录下往往还有一个动态链接版本的libgcc.a，为libgcc_s.so。</p>
<h3 id="11-3-运行库与多线程"><a href="#11-3-运行库与多线程" class="headerlink" title="11.3 运行库与多线程"></a>11.3 运行库与多线程</h3><h4 id="11-3-1-CRT的多线程困扰"><a href="#11-3-1-CRT的多线程困扰" class="headerlink" title="11.3.1 CRT的多线程困扰"></a>11.3.1 CRT的多线程困扰</h4><p>实际运行的线程拥有自己的私有存储空间</p>
<ul>
<li>栈（尽管并非无法被其他线程访问，但一般情况下仍然可以认为是私有的数据）。</li>
<li>线程局部存储（Thread Local Storage， TLS）。线程局部存储是某些操作系统为线程单独提供的私有空间，但是通常只是具有很有限的尺寸。</li>
<li>寄存器（包括PC寄存器），寄存器是执行流的基本数据，因此为线程私有。</li>
</ul>
<p>从C程序员角度：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">线程私有</th>
<th style="text-align:left">线程之间共享(进程所有)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">局部变量</td>
<td style="text-align:left">全局变量</td>
</tr>
<tr>
<td style="text-align:left">函数的参数</td>
<td style="text-align:left">推上的数据</td>
</tr>
<tr>
<td style="text-align:left">TLS数据</td>
<td style="text-align:left">函数里的静态变量<br>程序代码，任何线程都有权力读取并执行任何代码<br>打开文件，A线程打开的文件可以由B线程读写</td>
</tr>
</tbody>
</table>
</div>
<p>C/C++运行库在多线程下的问题：</p>
<ul>
<li>(1) errno: 在C标准库里，大多数错误代码是在函数返回之前赋值在名为errno的全局变量里的。多线程并发的时候，有可能A线程的errno的值在获取之前就被B线程给覆盖了。</li>
<li>(2) strtok()等函数都会使用函数内部的静态变量来存储字符串的位置，不同的线程调用这个函数将会把它内部的局部静态变量弄混。</li>
<li>(3) malloc/new 与free/delete：堆分配/释放函数或关键字在不加锁的情况下是线程不安全的。由于这些函数或关键字的调用十分频繁，因此在保证线程安全的时候显得十分繁琐。</li>
<li>(4) 异常处理：在早期的C++运行库里，不同的线程抛出异常会彼此冲突，从而造成信息丢失的情况。</li>
<li>(5) printf/fprintf及其他I/O函数：流输出函数同样是线程不安全的，因为它们共享了同一个控制台或文件输出。不同的输出并发时，信息会混杂在一起。</li>
<li>(6) 其他线程不安全因素：包括与信号相关的一些函数。</li>
</ul>
<p>通常情况下，C标准库中在不进行线程安全保护的情况下自然地具有线程安全的属性的函数有（不考虑errno因素）：</p>
<ul>
<li>(1) 字符处理(ctype.h)，包括isdigit，toupper等，这些函数同时还是可重入的。</li>
<li>(2) 字符串处理函数(string.h) 包括strlen，strcmp等，但其中涉及对参数中的数组进行写入的函数(如strcpy)仅在参数中的数组各不相同时，可以并发。</li>
<li>(3) 数学函数(math.h)，包括sin， pow等，这些函数同时还是可重入的。</li>
<li>(4) 字符串转整数/浮点数（stdlib.h)，包括atof, atoi, atol, strtod, strtol, strtoul。</li>
<li>(5) 获取环境变量(stdlib.h), 包括getenv, 可重入</li>
<li>(6) 变长数组辅助函数(stdarg.h)</li>
<li>(7) 非局部跳转函数(setjmp.h)，包括setjmp和longjmp，前提是longjmp仅跳转到本线程设置的jumpbuf上。</li>
</ul>
<h4 id="11-3-2-CRT改进"><a href="#11-3-2-CRT改进" class="headerlink" title="11.3.2 CRT改进"></a>11.3.2 CRT改进</h4><ul>
<li>使用TLS</li>
<li>加锁</li>
<li>改进函数调用方式</li>
</ul>
<h4 id="11-3-3-线程局部存储实现"><a href="#11-3-3-线程局部存储实现" class="headerlink" title="11.3.3 线程局部存储实现"></a>11.3.3 线程局部存储实现</h4><p>在一个线程中使用全局变量，且该全局变量只能在当前线程中可访问，这就需要线程局部存储(TLS, Thread Local Storage)。对于GCC，加关键字<code>__thread</code></p>
<p><code>__thread int thread</code></p>
<p>对于MSVC，加关键字 <code>__declspec(thread)</code></p>
<p><code>__declspec(thread) int number</code></p>
<p>一旦一个全局变量被定义称TLS，那么每个线程都会拥有这个变量的副本，任何线程对这个变量的修改，都不会影响其他线程中，该变量的副本。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/积累/" rel="tag"># 积累</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/09/04/C和指针笔记1/" rel="next" title="C和指针笔记1">
                <i class="fa fa-chevron-left"></i> C和指针笔记1
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/09/06/more_effective_cpp/" rel="prev" title="More Effective C++笔记">
                More Effective C++笔记 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/header.jpg" alt="Hao Yu">
            
              <p class="site-author-name" itemprop="name">Hao Yu</p>
              <p class="site-description motion-element" itemprop="description">Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author</p>
          </div>
          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">271</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>
        	<audio controls="controls" loop="loop" preload="auto" src="/resource/xiaomeihao.mp3">
	        </audio>
	

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yuhao0102" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:yuh18@mails.tsinghua.edu.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#第8章-Linux共享库的组织"><span class="nav-number">1.</span> <span class="nav-text">第8章 Linux共享库的组织</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8-1-共享库兼容性"><span class="nav-number">1.1.</span> <span class="nav-text">8.1 共享库兼容性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-2-符号版本"><span class="nav-number">1.2.</span> <span class="nav-text">8.2 符号版本</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-3-共享库系统路径"><span class="nav-number">1.3.</span> <span class="nav-text">8.3 共享库系统路径</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-4-共享库查找过程"><span class="nav-number">1.4.</span> <span class="nav-text">8.4 共享库查找过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-5-环境变量"><span class="nav-number">1.5.</span> <span class="nav-text">8.5 环境变量</span></a></li></ol></li></ol><li class="nav-item nav-level-1"><a class="nav-link" href="#LD-DEBUG-help-ls"><span class="nav-number"></span> <span class="nav-text">LD_DEBUG=help ls</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8-6-共享库的创建和安装"><span class="nav-number">0.1.</span> <span class="nav-text">8.6 共享库的创建和安装</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第10章-内存"><span class="nav-number">1.</span> <span class="nav-text">第10章 内存</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#10-1-程序的内存布局"><span class="nav-number">1.1.</span> <span class="nav-text">10.1 程序的内存布局</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-2-栈与调用惯例"><span class="nav-number">1.2.</span> <span class="nav-text">10.2 栈与调用惯例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#10-2-1-什么是栈"><span class="nav-number">1.2.1.</span> <span class="nav-text">10.2.1 什么是栈</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-2-2-调用惯例"><span class="nav-number">1.2.2.</span> <span class="nav-text">10.2.2 调用惯例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-2-3-函数返回值传递"><span class="nav-number">1.2.3.</span> <span class="nav-text">10.2.3 函数返回值传递</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-3-堆与内存管理"><span class="nav-number">1.3.</span> <span class="nav-text">10.3 堆与内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#10-3-1-什么是堆"><span class="nav-number">1.3.1.</span> <span class="nav-text">10.3.1 什么是堆</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-3-2-Linux进程堆管理"><span class="nav-number">1.3.2.</span> <span class="nav-text">10.3.2 Linux进程堆管理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-3-3-Windows进程堆管理"><span class="nav-number">1.3.3.</span> <span class="nav-text">10.3.3 Windows进程堆管理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-3-4-堆分配算法"><span class="nav-number">1.3.4.</span> <span class="nav-text">10.3.4 堆分配算法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-空闲链表"><span class="nav-number">1.3.4.1.</span> <span class="nav-text">1. 空闲链表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-位图"><span class="nav-number">1.3.4.2.</span> <span class="nav-text">2. 位图</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-对象池"><span class="nav-number">1.3.4.3.</span> <span class="nav-text">3. 对象池</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第11章-运行库"><span class="nav-number">2.</span> <span class="nav-text">第11章 运行库</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#11-1-入口函数和程序初始化"><span class="nav-number">2.1.</span> <span class="nav-text">11.1 入口函数和程序初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#11-1-2-入口函数"><span class="nav-number">2.1.1.</span> <span class="nav-text">11.1.2 入口函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-2-C-C-运行库"><span class="nav-number">2.2.</span> <span class="nav-text">11.2 C/C++ 运行库</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#11-2-2-C语言标准库"><span class="nav-number">2.2.1.</span> <span class="nav-text">11.2.2 C语言标准库</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-2-3-glibc与MSVC-CRT"><span class="nav-number">2.2.2.</span> <span class="nav-text">11.2.3 glibc与MSVC CRT</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-3-运行库与多线程"><span class="nav-number">2.3.</span> <span class="nav-text">11.3 运行库与多线程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#11-3-1-CRT的多线程困扰"><span class="nav-number">2.3.1.</span> <span class="nav-text">11.3.1 CRT的多线程困扰</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-3-2-CRT改进"><span class="nav-number">2.3.2.</span> <span class="nav-text">11.3.2 CRT改进</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-3-3-线程局部存储实现"><span class="nav-number">2.3.3.</span> <span class="nav-text">11.3.3 线程局部存储实现</span></a></li></ol></li></ol></li></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>
  <div id="DvelopmentTarget">     
  </div>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart" aria-hidden="false"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>

  
</div>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_uv"> 
  本站访客数<span id="busuanzi_value_site_uv"></span>人次
</span>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  


  

  


  <script type="text/javascript" src="/js/src/love.js"></script>

</body>
</html>
