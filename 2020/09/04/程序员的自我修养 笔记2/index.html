<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zn-ch">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-center-simple.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="积累,">










<meta name="description" content="静态链接如何将多个目标文件链接起来，形成一个可执行文件? 链接的核心内容:静态链接 定义两个文件a.c, b.c 123456789101112/* a.c */                        extern int shared;int main() &amp;#123;int a = 100;  swap(&amp;amp;a, &amp;amp;shared);&amp;#125;/* b.c */int s">
<meta name="keywords" content="积累">
<meta property="og:type" content="article">
<meta property="og:title" content="程序员的自我修养笔记2">
<meta property="og:url" content="http://yoursite.com/2020/09/04/程序员的自我修养 笔记2/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="静态链接如何将多个目标文件链接起来，形成一个可执行文件? 链接的核心内容:静态链接 定义两个文件a.c, b.c 123456789101112/* a.c */                        extern int shared;int main() &amp;#123;int a = 100;  swap(&amp;amp;a, &amp;amp;shared);&amp;#125;/* b.c */int s">
<meta property="og:locale" content="zn-ch">
<meta property="og:image" content="http://yoursite.com/img/4-按序叠加.png">
<meta property="og:image" content="http://yoursite.com/img/4-相似段合并.png">
<meta property="og:image" content="http://yoursite.com/img/4-链接前后各个段的属性.png">
<meta property="og:image" content="http://yoursite.com/img/4-链接前后过程.png">
<meta property="og:image" content="http://yoursite.com/img/4-符号的虚拟地址.png">
<meta property="og:image" content="http://yoursite.com/img/4-a.o反汇编结果.png">
<meta property="og:image" content="http://yoursite.com/img/4-重定位后的ab反汇编结果.png">
<meta property="og:image" content="http://yoursite.com/img/4-a.o的重定位表.png">
<meta property="og:image" content="http://yoursite.com/img/4-重定位表字段含义.png">
<meta property="og:image" content="http://yoursite.com/img/4-a.o的符号表.png">
<meta property="og:image" content="http://yoursite.com/img/4-查看静态库.png">
<meta property="og:image" content="http://yoursite.com/img/4-libc.a中查找printf.png">
<meta property="og:image" content="http://yoursite.com/img/4-hello.c与printf.o链接.png">
<meta property="og:image" content="http://yoursite.com/img/4-hello.c与printf.o链接的依赖.png">
<meta property="og:image" content="http://yoursite.com/img/4-hello.c的编译链接过程1.png">
<meta property="og:image" content="http://yoursite.com/img/4-hello.c的编译链接过程2.png">
<meta property="og:image" content="http://yoursite.com/img/6-Linux空间地址分布.png">
<meta property="og:image" content="http://yoursite.com/img/6-简单的覆盖载入.png">
<meta property="og:image" content="http://yoursite.com/img/6-复杂的覆盖载入.png">
<meta property="og:image" content="http://yoursite.com/img/6-页映射页编号.png">
<meta property="og:image" content="http://yoursite.com/img/6-页映射与装载.png">
<meta property="og:image" content="http://yoursite.com/img/6-可执行文件与进程虚拟空间.png">
<meta property="og:image" content="http://yoursite.com/img/6-页错误过程.png">
<meta property="og:image" content="http://yoursite.com/img/6-ELF_Section结构0.png">
<meta property="og:image" content="http://yoursite.com/img/6-ELF_Section结构1.png">
<meta property="og:image" content="http://yoursite.com/img/6-ELF_Segment程序头.png">
<meta property="og:image" content="http://yoursite.com/img/6-ELF_按Segment划分.png">
<meta property="og:image" content="http://yoursite.com/img/6-Elf32_Phdr.png">
<meta property="og:image" content="http://yoursite.com/img/6-Elf32_Phdr各字段含义.png">
<meta property="og:image" content="http://yoursite.com/img/6-虚拟空间分布.png">
<meta property="og:image" content="http://yoursite.com/img/6-ELF与进程虚拟空间映射关系.png">
<meta property="og:image" content="http://yoursite.com/img/6-申请内存代码.png">
<meta property="og:image" content="http://yoursite.com/img/6-段对齐0.png">
<meta property="og:image" content="http://yoursite.com/img/6-段对齐1.png">
<meta property="og:image" content="http://yoursite.com/img/6-段对齐2.png">
<meta property="og:image" content="http://yoursite.com/img/6-段对齐3.png">
<meta property="og:image" content="http://yoursite.com/img/6-Linux进程初始化堆栈.png">
<meta property="og:image" content="http://yoursite.com/img/6-ELF与进程虚拟空间映射关系.png">
<meta property="og:image" content="http://yoursite.com/img/7-动态链接时文件在内存中的副本.png">
<meta property="og:image" content="http://yoursite.com/img/7-动态链接示例代码0.png">
<meta property="og:image" content="http://yoursite.com/img/7-动态链接示例代码1.png">
<meta property="og:image" content="http://yoursite.com/img/7-动态链接过程.png">
<meta property="og:image" content="http://yoursite.com/img/7-进程的虚拟地址空间分布.png">
<meta property="og:image" content="http://yoursite.com/img/7-Lib.so的装载属性0.png">
<meta property="og:image" content="http://yoursite.com/img/7-Lib.so的装载属性1.png">
<meta property="og:image" content="http://yoursite.com/img/7-四种寻址方式.png">
<meta property="og:image" content="http://yoursite.com/img/7-模块内部函数调用0.png">
<meta property="og:image" content="http://yoursite.com/img/7-模块内部函数调用1.png">
<meta property="og:image" content="http://yoursite.com/img/7-bar反汇编表示0.png">
<meta property="og:image" content="http://yoursite.com/img/7-bar反汇编表示1.png">
<meta property="og:image" content="http://yoursite.com/img/7-通过GOT机制引用其他模块的全局变量.png">
<meta property="og:image" content="http://yoursite.com/img/7-通过GOT机制引用其他模块的函数.png">
<meta property="og:image" content="http://yoursite.com/img/7-地址无关小结.png">
<meta property="og:image" content="http://yoursite.com/img/7-bar函数对应的PLT项.png">
<meta property="og:image" content="http://yoursite.com/img/7-PLT的结构.png">
<meta property="og:image" content="http://yoursite.com/img/7-.interp内容.png">
<meta property="og:image" content="http://yoursite.com/img/7-.dynamic结构对应的含义.png">
<meta property="og:image" content="http://yoursite.com/img/7-dynamic结构0.png">
<meta property="og:image" content="http://yoursite.com/img/7-dynamic结构1.png">
<meta property="og:image" content="http://yoursite.com/img/7-查看主模块或共享库所依赖的模块.png">
<meta property="og:image" content="http://yoursite.com/img/7-动态链接符号表.png">
<meta property="og:image" content="http://yoursite.com/img/7-动态链接的重定位表.png">
<meta property="og:image" content="http://yoursite.com/img/7-Lib.so的.got.plt结构.png">
<meta property="og:image" content="http://yoursite.com/img/7-动态链接器辅助信息0.png">
<meta property="og:image" content="http://yoursite.com/img/7-动态链接器辅助信息1.png">
<meta property="og:image" content="http://yoursite.com/img/7-dl四个函数的简单应用.png">
<meta property="og:updated_time" content="2020-09-05T07:24:29.818Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="程序员的自我修养笔记2">
<meta name="twitter:description" content="静态链接如何将多个目标文件链接起来，形成一个可执行文件? 链接的核心内容:静态链接 定义两个文件a.c, b.c 123456789101112/* a.c */                        extern int shared;int main() &amp;#123;int a = 100;  swap(&amp;amp;a, &amp;amp;shared);&amp;#125;/* b.c */int s">
<meta name="twitter:image" content="http://yoursite.com/img/4-按序叠加.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/09/04/程序员的自我修养 笔记2/">





  <title>程序员的自我修养笔记2 | Hao Yu's blog</title>
  








 
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zn-ch">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hao Yu's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">The program monkey was eaten by the siege lion.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/resume.pdf" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-mybetterhalf">
          <a href="/mybetterhalf/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>
            
            mybetterhalf
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/04/程序员的自我修养 笔记2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">程序员的自我修养笔记2</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-09-04T21:09:05+08:00">
                2020-09-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h2><p>如何将多个目标文件链接起来，形成一个可执行文件? 链接的核心内容:静态链接</p>
<p>定义两个文件<code>a.c</code>, <code>b.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* a.c */</span>                        </span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> shared;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line">  swap(&amp;a, &amp;shared);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* b.c */</span></span><br><span class="line"><span class="keyword">int</span> shared = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b)</span> </span>&#123;</span><br><span class="line">   *a ^= *b ^= *a ^= *b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>将两个源文件编译后，形成目标文件a.o, b.o 。</li>
<li>“b.c”总共定义了两个全局符号,一个是变量“ shared”,另外一个是函数“swap”</li>
<li>“a,c”里面定义了一个全局符号就是“main”</li>
</ol>
<h3 id="4-1-空间与地址分配"><a href="#4-1-空间与地址分配" class="headerlink" title="4.1 空间与地址分配"></a>4.1 空间与地址分配</h3><ul>
<li>对于链接器来说,整个链接过程中,它就是将几个输入目标文件加工后合并成一个输出文件</li>
<li>链接器如何将它们的各个段合并到输出文件?或者说,输出文件中的空间如何分配给输入文件?</li>
</ul>
<h4 id="4-1-1-按序叠加"><a href="#4-1-1-按序叠加" class="headerlink" title="4.1.1 按序叠加"></a>4.1.1 按序叠加</h4><p>最简单的方案就是将输入的目标文件按照次序叠加起来</p>
<p><img src="/img/4-按序叠加.png" alt></p>
<ul>
<li>在有很多输入文件的情况下,输出文件将会有很多零散的段</li>
<li>这种做法非常浪费空间,因为每个段都须要有一定的地址和空间对齐要求</li>
<li>对于x86的硬件来说,段的装载地址和空间的对齐单位是页,也就是4096字节,那么就是说如果一个段的长度只有1个字节,它也要在内存中占用4096字节。这样会造成内存空间大量的内部碎片,所以这并不是一个很好的方案</li>
</ul>
<h4 id="4-1-2-相似段合并"><a href="#4-1-2-相似段合并" class="headerlink" title="4.1.2 相似段合并"></a>4.1.2 相似段合并</h4><p>更实际的方法是将相同性质的段合并到一起<br><img src="/img/4-相似段合并.png" alt></p>
<ul>
<li>“.bss”段在目标文件和可执行文件中并不占用文件的空间,但是它在装载时占用地址空间。所以链接器在合并各个段的同时,也将“.bss”合并,并且分配虚拟空间</li>
<li><p>“链接器为目标文件分配地址和空间”这句话中的“地址和空间”其实有两个含义:</p>
<ul>
<li>在输出的可执行文件中的空间</li>
<li><p>在装载后的虚拟地址中的虚拟地址空间</p>
<ul>
<li>对于有实际数据的段,比如“.text”和“.data”来说,它们在文件中和虚拟地址中都要分配空间,因为它们在这两者中都存在</li>
<li>对于“.bss”这样的段来说,分配空间的意义只局限于虚拟地址空间,因为它在文件中并没有内容</li>
<li>事实上,我们在这里谈到的空间分配只关注于虚拟地址空间的分配,因为这个关系到链接器后面的关于地址计算的步骤,而可执行文件本身的空间分配与链接过程关系并不是很大</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>链接器空间分配的策略基本上都采用上述方法中的第二种,使用这种方法的链接器一般都采用一种叫两步链接( Two-pass Linking)的方法</p>
<ul>
<li><p>第一步: 空间与地址分配</p>
<ol>
<li>扫描所有的输入目标文件,并且获得它们的各个段的长度属性和位置</li>
<li>将输入目标文件中的符号表中所有的符号定义和符号引用收集起来,统放到一个全局符号表</li>
<li>通过上面的过程, 链接器将能够获得所有输入目标文件的段长度,并且将它们合并,计算出输出文件中各个段合并后的长度与位置,并建立映射关系</li>
</ol>
</li>
<li><p>第二步: 符号解析与重定位</p>
<ol>
<li>使用上面第一步中收集到的所有信息,读取输入文件中段的数据、重定位信息,并且进行符号解析与重定位、调整代码中的地址等</li>
<li>事实上第二步是链接过程的核心,特别是重定位过程</li>
</ol>
</li>
</ul>
</li>
<li><p>a.o和b.o链接成可执行文件的过程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ld a.o b.o -e main -o ab</span><br><span class="line"></span><br><span class="line">-e main 表示将main函数作为程序的入口。ld默认的程序入口为_start。</span><br><span class="line">-o ab   表示链接输出文件名为ab, 默认为a.out。</span><br></pre></td></tr></table></figure>
<p><img src="/img/4-链接前后各个段的属性.png" alt></p>
<ol>
<li>VMA表示 Virtual Memory Address,即虚拟地址,LMA表示 Load Memory Address即加载地址。正常情况下这两个值应该是一样的,但是在有些嵌入式系统中,特别是在那些程序放在ROM的系统中时,LMA和VMA是不相同的。这里我们只要关注VMA即可。</li>
<li>链接后程序使用的地址已经是在程序在进程中的虚拟地址了。</li>
<li>因此我们关心上面各个段中的VMA( Virtual Memory Address)和Size,而忽略文件偏移(File off)。<ol>
<li>在链接之前,目标文件中的所有段的ⅤMA都是0,因为虚拟空间还没有被分配,所<br>以它们默认都为0</li>
<li>链接之后,可执行文件“ab”中的各个段都被分配到了相应的虚拟地址</li>
</ol>
</li>
<li><p>整个链接过程前后,目标文件各段的分配、程序虚拟地址如下图</p>
<p><img src="/img/4-链接前后过程.png" alt></p>
<ul>
<li>“a.o”和“bo”的代码段被先后叠加起来,合并成“ab”的一个.text段,加起来的长度为0x72</li>
</ul>
</li>
</ol>
</li>
</ul>
<h4 id="4-1-3-符号地址的确定"><a href="#4-1-3-符号地址的确定" class="headerlink" title="4.1.3 符号地址的确定"></a>4.1.3 符号地址的确定</h4><ol>
<li>在第一步的扫描和空间分配阶段时,链接器将目标文件按照相似段合并后，输入文件中的各个段在链接后的虚拟地址就已经确定了</li>
<li><p>然后链接器开始计算各个符号的虚拟地址，因为各个符号在段内容的地址是相对固定的。所以链接器须要给每个符号加上一个相对于对应段的偏移量,使它们能够调整到正确的虚拟地址。</p>
<p> 从前面“objdump”的输出看到,“main”位于“a.o”的“.text”段的最开始,也就是偏移为0,所以“main”这个符号在最终的输出文件中的地址应该是0x08048094+0,即0x08048094</p>
</li>
</ol>
<p>​     <img src="/img/4-符号的虚拟地址.png" alt></p>
<h3 id="4-2-符号解析和重定位"><a href="#4-2-符号解析和重定位" class="headerlink" title="4.2 符号解析和重定位"></a>4.2 符号解析和重定位</h3><h4 id="4-2-1-重定位"><a href="#4-2-1-重定位" class="headerlink" title="4.2.1 重定位"></a>4.2.1 重定位</h4><blockquote>
<p> 在a.o中是怎样使用shared，swap这两个外部指令的。</p>
</blockquote>
<h5 id="4-2-1-1-重定位前"><a href="#4-2-1-1-重定位前" class="headerlink" title="4.2.1.1 重定位前"></a>4.2.1.1 重定位前</h5><p>通过objdump中的-d参数查看a.o的反汇编结果</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> objdump -d a.o</span></span><br></pre></td></tr></table></figure>
<p><img src="/img/4-a.o反汇编结果.png" alt></p>
<ol>
<li>在未进行前面提到过的空间分配之前,目标文件代码段中的起始地址以0x0000000开始,等到空间分配完成以后,各个函数才会确定自己在虚拟地址空间中的位置</li>
<li>main函数总共由于17条指令组成，偏移为0x18的mov指令，总共8个字节。前4个字节是指令，后面4个字节为shared的地址，此时为0x0000000</li>
<li>偏移为0x26的call指令，总共5个字节。第一个字节是指令，后面4个字节为swap的地址，此时为0xFFFFFFFC，这也是一个假的地址，因为编译的时候是不知道swap的地址的</li>
</ol>
<h5 id="4-2-1-2-重定位后"><a href="#4-2-1-2-重定位后" class="headerlink" title="4.2.1.2 重定位后"></a>4.2.1.2 重定位后</h5><ul>
<li>编译器把把真正的地址计算工作留给了链接器</li>
<li>通过前面的空间与地址分配可以得知,链接器在完成地址和空间分配之后就已经可以确定所有符号的虚拟地址了</li>
<li>那么链接器就可以根据符号的地址对每个需要重定位的指令进行地址修正</li>
<li><p>用 objdump来反汇编输出程序“ab”的代码段,可以看到main函数的两个重定位入口都已经被修正到正确的位置</p>
<p><img src="/img/4-重定位后的ab反汇编结果.png" alt></p>
<p>经过修正以后,“ shared”和“swap”的地址分别为0x08049108和0x00000009</p>
</li>
</ul>
<h4 id="4-2-2-重定位表"><a href="#4-2-2-重定位表" class="headerlink" title="4.2.2 重定位表"></a>4.2.2 重定位表</h4><ul>
<li>链接器是通过重定位表知道哪些指令是要被调整，以及这些指令怎么调整。</li>
<li><p>重定位表( Relocation Table)是可重定位的ELF文件中一个或多个段(也叫重定位段)，专门用来保存与重定位相关的信息</p>
<ol>
<li>比如代码段“text”如有要被重定位的地方,那么会有一个相对应叫“.rel.text”的段保存了代码段的重定位表;</li>
<li>如果代码段“data”有要被重定位的地方,就会有一个相对应叫“.rel.data”的段保存了数据段的重定位表</li>
</ol>
</li>
<li><p>使用objdump来查看a.o的重定位表</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> objdump -r a.o</span></span><br></pre></td></tr></table></figure>
<p><img src="/img/4-a.o的重定位表.png" alt></p>
<ul>
<li>可以看到“a.o”里面有两个重定位入口</li>
<li>重定位入口的偏移( Offset)表示该入口在要被重定位的段中的位置</li>
<li>“ RELOCATION RECORDS FOR [.tex]”表示这个重定位表是代码段的重定位表</li>
<li>对照前面的反汇编结果可以知道,这里的0x1c和0x27，分别就是代码段中“shared”和“swap”的地址</li>
<li><p><code>重定位表是一个Elf32_Rel结构的数组</code>,每个数组元素对应一个重定位入口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">   Elf32_Addr r_offset; //重定位入口在对应段中的偏移</span><br><span class="line">   Elf32_Word r_info;   //重定位入口的类型和符号</span><br><span class="line">&#125; Elf32_Rel;</span><br></pre></td></tr></table></figure>
<p><img src="/img/4-重定位表字段含义.png" alt></p>
</li>
</ul>
</li>
</ul>
<h4 id="4-2-3-符号解析"><a href="#4-2-3-符号解析" class="headerlink" title="4.2.3 符号解析"></a>4.2.3 符号解析</h4><ul>
<li>重定位过程也伴随着符号的解析过程,每个目标文件都可能定义一些符号,也可能引用到定义在其他目标文件的符号</li>
<li>重定位的过程中,每个重定位的入口都是对一个符号的引用,那么当链接器须要对某个符号的引用进行重定位时,它就需要确定这个符号的目标地址。</li>
<li><p>这时候链接器就会去查找由所有输入目标文件的符号表组成的<code>全局符号表</code>,找到相应的符号后进行重定位</p>
</li>
<li><p>查看a.o的符号表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ readelf -s a.o</span><br></pre></td></tr></table></figure>
<p><img src="/img/4-a.o的符号表.png" alt></p>
<ol>
<li>“ GLOBAL”类型的符号,除了“main”函数是定义在代码段之外,其他两个“ shared和“swap”都是“UND”,即“ undefined”未定义类型</li>
<li>这种未定义的符号都是因为该目标文件中有关于它们的重定位项</li>
<li>所以在链接器扫描完所有的输入目标文件之后,所有这些未定义的符号都应该能够在全局符号表中找到,否则链接器就报符号未定义错误</li>
</ol>
</li>
</ul>
<h4 id="4-2-4-指令修正方式"><a href="#4-2-4-指令修正方式" class="headerlink" title="4.2.4 指令修正方式"></a>4.2.4 指令修正方式</h4><ul>
<li>不同的处理器指令对于地址的格式和方式都不一样</li>
<li>寻址方式:<ol>
<li>近址寻址或远址寻址</li>
<li>绝对寻址或相对寻址</li>
<li>寻址长度为8位、16位、32位或64位</li>
<li>绝对近址32位寻址</li>
<li>相对近址32位寻址</li>
</ol>
</li>
</ul>
<h3 id="4-3-COMMON块"><a href="#4-3-COMMON块" class="headerlink" title="4.3 COMMON块"></a>4.3 COMMON块</h3><ul>
<li><p>COMMON机制</p>
<p>现在的编译器和链接器都支持一种叫 COMMON块(Common block)的机制,<br>这种机制最早来源于 Fortran,早期的 Fortran没有动态分配空间的机制,程序员必须事先声明它所需要的临时使用空间的大小。 Fortran把这种空间叫 COMMON块,当不同的目标文件需要的COMMON块空间大小不一致时,以最大的那块为准。</p>
</li>
<li><p>现代的链接机制在处理弱符号的时候,采用的就是与 COMMON块一样的机制</p>
</li>
<li><p>链接器对同一个符号在不同目标文件中的定义分为三种情况</p>
<ol>
<li><p>两个或两个以上强符号类型不同<br>多个强符号定义本身就是非法的,链接器会报符号多重定义错误</p>
</li>
<li><p>有一个强符号,其他都是弱符号,出现类型不一致;</p>
<ol>
<li>输出文件中，以强符号的类型为准。</li>
<li>如果某个弱符号类型大小大于强符号，则ld链接器会报警告<br>ld: warning: alignment 4 of symbol <code>global</code> in a.o smaller tha n 8 in b.o</li>
</ol>
</li>
<li><p>两个或两个以上弱符号类型不一致<br>以类型最大的符号为准</p>
</li>
</ol>
</li>
<li><p>编译器将未初始化的全局变量定义作为弱符号处理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">在 SimpleSection.c这个例子中, global_uninit_val并没有被放在.bbs段，而是被标记为common, 它在符号表中的值如下</span><br><span class="line"></span><br><span class="line">st_name = &quot;global_uninit_var&quot;</span><br><span class="line">st_value = 4</span><br><span class="line">st_size = 4</span><br><span class="line">st_info = 0x11 STB_GLOBAL STT_OBUECT</span><br><span class="line">st_other = 0</span><br><span class="line">st_shndx = 0xfff2 SHN_COMMON</span><br></pre></td></tr></table></figure>
</li>
<li><p>为什么需要COMMON机制?</p>
<p>编译器和链接器允许不同类型的弱符号存在, 但是链接器无法判断各个符号的类型是否一致，从而导致链接的时候不知道怎么分配空间</p>
</li>
<li><p>目标文件中,编译器为什么不直接把未初始化的全局变量也当作未初始化的局部静态变量一样处理,为它在BSS段分配空间,而是将其标记为一个 COMMON类型的变量?</p>
<ol>
<li>当编译器将一个编译单元编译成目标文件的时候,如果该编译单元包含了弱符号(未初始化的全局变量就是典型的弱符号),那么该弱符号最终所占空间的大小在此时是未知的,因为有可能其他编译单元中该符号所占的空间比本编译单元该符号所占的空间要大</li>
<li>所以编译器此时无法为该弱符号在BSS段分配空间,因为所须要空间的大小未知</li>
<li>但是链接器在链接过程中可以确定弱符号的大小，因为当链接器读取所有输入目标文件以后,任何一个弱符号的最终大小都可以确定了,所以它可以在最终输出文件的BSS段为其分配空间。所以总体来看,未初始化全局变量最终还是被放在BSS段的。</li>
</ol>
</li>
<li><p>当我们在gcc中使用”-fno-common”时，那么所有未初始化的全局变量不以 COMMON块的形式处理。或者使用“<strong>attribute</strong>”扩展:<code>int global __attribute__((nocommon))</code></p>
</li>
<li>一个未初始化的全局变量不是以 COMMON块的形式存在,那么它就相当于一个强符号,如果其他目标文件中还有同一个变量的强符号定义,链接时就会发生符号重复定义错误</li>
</ul>
<h3 id="4-4-C-相关问题"><a href="#4-4-C-相关问题" class="headerlink" title="4.4 C++相关问题"></a>4.4 C++相关问题</h3><ul>
<li>C++的一些语言特性使之必须由编译器和链接器共同支持才能完成工作,主要有两个方面：<ul>
<li>C++的重复代码消除</li>
<li>全局构造与析构</li>
</ul>
</li>
<li>C++复杂的结构往往在不同的编译器和链接器之间相互不能通用，使得它还需要进行二进制的兼容</li>
</ul>
<h4 id="4-4-1-重复代码消除"><a href="#4-4-1-重复代码消除" class="headerlink" title="4.4.1 重复代码消除"></a>4.4.1 重复代码消除</h4><p>C++编译器在很多时候会产生重复的代码,比如模板( Templates)、外部内联函数(Exern inline function)和虚函数表(Ⅴirtual Function Table)都有可能在不同的编译单元里生成相同的代码。如果直接将重复代码保留下来，会造成下面几个问题</p>
<ul>
<li>空间浪费<ul>
<li>可以想象一个有几百个编译单元的工程同时实例化了许多个模板,最后链接的时候必须将这些重复的代码消除掉,否则最终程序的大小肯定会膨胀得很厉害</li>
</ul>
</li>
<li>地址较易出错<ul>
<li>有可能两个指向同一个函数的指针会不相等</li>
</ul>
</li>
<li>指令运行效率较低<ul>
<li>因为现代的CPU都会对指令和数据进行缓存,如果同样一份指令有多份副本,那么指令Cache的命中率就会降低</li>
</ul>
</li>
</ul>
<p>主流做法是不同编译单元内将模板，外部内联函数，虚函数表等各自单独的放在一个段中，等到在链接时丢弃重复的段，然后合并到代码段中。</p>
<p>模板函数是<code>add&lt;T&gt;()</code>,某个编译单元以int类型和foat类型实例化了该模板函数,那么该编译单元的日标文件中就包含了两个该模板实例的段。为了简单起见,我们假设这两个段的名字分别叫 .temp.add<int>、和 .temp.add<float>。这样,当别的编译单元也以int或float类型实例化该模板函数后,也会生成同样的名字,这样链接器在最终链接的时候可以区分这些相同的模板实例段,然后将它们合并入最后的代码段</float></int></p>
<ul>
<li>GCC把这种类似的须要在最终链接时合并的段叫“ Link once”,它的做法是将这种类型的段命名为“ .gnu.linkonce.name”</li>
<li>VISUAL C++编译器做法稍有不同,它把这种类型的段叫做“COMDAT”</li>
<li>相同名称的段可能拥有不同的内容,此时链接器随意选择其中任何一个副本作为链接的输入,然后同时提供一个警告信息。</li>
</ul>
<p>这可能由于不同的编译单元使用了不同的编译器版本或者编译优化选项,导致同一个函数编译出来的实际代码有所不同</p>
<h5 id="4-1-1-1函数级别链接"><a href="#4-1-1-1函数级别链接" class="headerlink" title="4.1.1.1函数级别链接"></a>4.1.1.1函数级别链接</h5><p>一个目标文件可能包含成千上百个函数或变量。使用某个目标文件中的任意一个函数或变量时,就须要把它整个地链接进来,也就是说那些没有用到的函数也被一起链接了进来。这样的后果是链接输出文件会变得很大。</p>
<p>VISUAL C++编译器提供了一个编译选项叫函数级别链接( Functional-Level Linking,/Gy),这个选项的作用就是让所有的函数都像前面模板函数一样,单独保存到一个段里。当链接器须要用到某个函数时,它就将它合并到输出文件中,对于那些没有用的函数则将它们抛弃。</p>
<p>这种做法可以很大程度上减小输出文件的长度,减少空间浪费。但是这个优化选项会减慢编译和链接过程。</p>
<p>因为链接器须要计算各个函数之间的依赖关系,并且所有函数都保持到独立的段中,目标函数的段的数量大大增加,重定位过程也会因为段的数目的增加而变得复杂,目标文件随着段数目的增加也会变得相对较大。GCC编译器也提供了类似的机制,它有两个选择分别是<code>-ffunction- sections</code>和<code>-fdata-sections</code>,这两个选项的作用就是将每个函数或变量分别保持到独立的段中</p>
<h4 id="4-4-2-全局构造与析构"><a href="#4-4-2-全局构造与析构" class="headerlink" title="4.4.2 全局构造与析构"></a>4.4.2 全局构造与析构</h4><p>C++的全局对象的构造函数在main之前被执行,C++全局对象的析构函数在main之后被执行。<code>.init</code>该段里面保存的是可执行指令,它构成了进程的初始化代码。当一个程序开始运行时,在main函数被调用之前,Gibc的初始化部分安排执行这个段的中的代码。<code>.fini</code>该段保存着进程终止代码指令。因此,当一个程序的main函数正常退出时, Glibc会安排执行这个段中的代码。C++的全局对象的构造函数放在.init段里。C++的全局对象的析构函数放在.fini段里</p>
<h4 id="4-4-3-C-与ABI"><a href="#4-4-3-C-与ABI" class="headerlink" title="4.4.3 C++与ABI"></a>4.4.3 C++与ABI</h4><ul>
<li><p>使两个编译器编译出来的目标文件能够相互链接,那么这两个目标文件必须满足下面这些条件:</p>
<ol>
<li>采用同样的目标文件格式</li>
<li>拥有同样的符号修饰标准</li>
<li>变量的内存分布方式相同</li>
<li>函数的调用方式相同</li>
</ol>
</li>
</ul>
<ul>
<li>把<code>符号修饰标准</code>、<code>变量内存布局</code>、<code>函数调用方式</code>等这些跟可执行代码二进制兼容性相关的内容称为ABI(Application Binary Interface)<ul>
<li>ABI:指的是二进制层面的接口</li>
<li>API:指的是源码层面的接口</li>
</ul>
</li>
</ul>
<ul>
<li><p>影响ABI的因素非常多,硬件、编程语言、编译器、链接器、操作系统等都会影响ABI</p>
</li>
<li><p>对于C语言的目标代码来说,以下几个方面会决定目标文件之间是否二进制兼容</p>
<ol>
<li>内置类型(如int、 float、char等)的大小和在存储器中的放置方式(大端、小端、对齐方式等)</li>
<li>组合类型(如 struct、 union、数组等)的存储方式和内存分布。</li>
<li>外部符号( external-linkage)与用户定义的符号之间的命名方式和解析方式,如函数名func在C语言的目标文件中是否被解析成外部符号_func</li>
<li>函数调用方式,比如参数入栈顺序、返回值如何保持等。</li>
<li>堆栈的分布方式,比如参数和局部变量在堆栈里的位置,参数传递方法等。</li>
<li>寄存器使用约定,函数调用时哪些寄存器可以修改,哪些须要保存,等等。</li>
</ol>
</li>
<li><p>C++增添了更多额外的内容，使C++要做到二进制兼容比C来得更为不易</p>
<ol>
<li>继承类体系的内存分布,如基类,虚基类在继承类中的位置等。</li>
<li>指向成员函数的指针( pointer-to-member)的内存分布,如何通过指向成员函数的指针来调用成员函数,如何传递this指针</li>
<li>如何调用虚函数, vtable的内容和分布形式, vtable指针在 object中的位置等。</li>
<li><p>template如何实例化。</p>
</li>
<li><p>外部符号的修饰</p>
</li>
<li>全局对象的构造和析构</li>
<li>异常的产生和捕获机制</li>
<li>标准库的细节问题,RTTI如何实现等</li>
<li>内嵌函数访问细节</li>
</ol>
</li>
<li><p>C++一直为人诟病的一大原閃是它的二进制兼容性不好, 目前情况还是不容乐观,基本形成以微软的 VISUAL C++和GNU阵营的GCC(采用 Intel Itanium C++ABI标准)为首的两大派系,各持己见互不兼容</p>
<p>不仅不同的编译器编译的二进制代码之间无法相互兼容,有时候连同一个编译器的不同版本之间兼容性也不好</p>
<p>比如我有一个库A是公司 Company A用 Compiler A编译的,我有另外一个库B是公司 Company B用 Compiler B编译的,当我想写一个C++程序来同时使用厍A和B将会很是棘手</p>
</li>
</ul>
<h3 id="4-5-静态链接"><a href="#4-5-静态链接" class="headerlink" title="4.5 静态链接"></a>4.5 静态链接</h3><ul>
<li><p>静态库可以简单地看成一组目标文件的集合,即很多目标文件经过压缩打包后形成的一个文件。(里面也包含文件的索引)</p>
</li>
<li><p>gibc本身是用C语言开发的,它由成百上千个C语言源代码文件组成,也就是说,编译完成以后有相同数量的目标文件。比如输入输出有printf.o, scanf.o:文件操作有 fread o, fwrite.o;时间日期有 date.o, time.o;内存管理有 malloc.o</p>
</li>
<li><p>把这些零散的目标文件直接提供给库的使用者,很大程度上会造成文件传输、管理和组织方面的不便,于是通常人们使用“ar”压缩程序将这些目标文件压缩到一起,并且对其进行编号和索引，以便于查找和检索，就形成了libc.a这个静态库文件。</p>
<p><img src="/img/4-查看静态库.png" alt></p>
</li>
<li><p>libc.a里面总共包含了1400个目标文件,如何查找’printf”函数所在的目标文件?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使用“objdump”或“readelf”加上文本查找工具如“grep&quot;”</span><br><span class="line">$ objdump -t libc.a</span><br></pre></td></tr></table></figure>
<p><img src="/img/4-libc.a中查找printf.png" alt></p>
</li>
<li><p>那么我们写一个hello.c程序，编译成hello.o与printf.o链接是不是就可以了呢?</p>
<ol>
<li><p><code>$gcc -c -fno-builtin hello.c</code>得到hello.o。GCC会自作聪明地将“ Hello world”程序中只使用了一个字符串参数的“pinf”替换成“puts”函数,以提高运行速度,我们要使用“-fno-builtin”关闭这个内置函数优化选项</p>
</li>
<li><p>通过<code>ar</code>工具解压出“ printf.o”, <code>ar -x libc.a</code></p>
</li>
<li><p><code>$ hello.o printf.o</code>,链接失败了，缺少了两个外部符号定义</p>
<p><img src="/img/4-hello.c与printf.o链接.png" alt><br><img src="/img/4-hello.c与printf.o链接的依赖.png" alt></p>
</li>
<li><p>当我们找到这两个外部符号定义的文件时，发现它们还依赖其他目标文件，依赖似乎无穷尽，所以直接链接很难成功。</p>
</li>
</ol>
</li>
<li><p>通过gcc将整个编译链接过程的中间步骤打印出来</p>
<p><img src="/img/4-hello.c的编译链接过程1.png" alt><br><img src="/img/4-hello.c的编译链接过程2.png" alt></p>
</li>
</ul>
<ul>
<li>第一步是调用<code>ccl</code>程序，这个程序实际上就是GCC的C语言编译器,它将“ hello. c”编译成一个临时的汇编文件“/tmp/ccUhtGSB.s”</li>
<li>第二步调用<code>as</code>程序，as程序是GNU的汇编器,它将“/tmp/ccUhtGSB.s”汇编成临时目标文件“/tmp/ccQZRPL5.o。”,这个“/tmp/ccQZRPL5.o”实际上就是前面的“ hello.o”</li>
<li>最关键的步骤是最后一步,GCC调用 <code>collect2</code>程序来完成最后的链接。<ul>
<li>collect2可以看作是ld链接器的一个包装</li>
<li>它会调用ld链接器来完成对目标文件的链接,然后再对链接结果进行一些处理, 主要是收集所有与程序初始化相关的信息并且构造初始化的结构</li>
</ul>
</li>
<li>最后一步中,至少有下列几个库和目标文件被链接入了最终可执行文件<ul>
<li>ctr1.o</li>
<li>ctri.o</li>
<li>crtbeginT.o</li>
<li>libgcc.a</li>
<li>libgcc_eh.a</li>
<li>libc.a</li>
<li>crtend.o</li>
<li>crtn.o</li>
</ul>
</li>
</ul>
<ul>
<li>之所以静态库中一个目标文件只包含一个函数，是为了减少引入的目标文件的数量从而减少输出文件的体积。</li>
</ul>
<h3 id="4-6-链接过程控制"><a href="#4-6-链接过程控制" class="headerlink" title="4.6  链接过程控制"></a>4.6  链接过程控制</h3><h4 id="4-6-1-链接控制脚本"><a href="#4-6-1-链接控制脚本" class="headerlink" title="4.6.1  链接控制脚本"></a>4.6.1  链接控制脚本</h4><ul>
<li><p>链接器一般提供多种控制链接过程的方法，以用来产生用户所需要的文件。</p>
<ol>
<li>使用命令行来给链接器指定参数,我们前面所使用的ld的-o、-e参数就属于这类。</li>
<li>将链接指令存放在目标文件里面,编译器经常会通过这种方法向链接器传递指令。VISUAL C++编译器会把链接参数放在PE目标文件的 drectve段以用来传递参数</li>
<li>使用链接控制脚本—最为灵活、最为强大的链接控制方法</li>
</ol>
</li>
<li><p>VISUAL C++也允许使用脚本来控制整个链接过程, VISUAL C+把这种控制脚本叫做模块定义文件( Module- Definition File),它们的扩展名一般为.def</p>
</li>
<li><p>我们以ld的链接脚本来进行介绍</p>
<ol>
<li><code>$ ld verbose</code>查看默认的链接脚本</li>
<li>ld链接脚本默认存放在/usr/lib/ldscripts/下, 不同的机器平台、输出文件格式都有相应的链接脚本。Intel IA32下的普通可执行ELF文件链接脚本文件为elf_i386.x;IA32下共享库的链接脚本文件为elf_i386.xs</li>
<li>为了更加精确地控制链接过程,我们可以自己写一个脚本,然后指定该脚本为链接控制脚本。然后通过<code>$ ld -T link.script</code>,指定链接脚本。</li>
</ol>
</li>
<li><p>链接脚本相关的内容用到时可以去参考书，暂时先不管；</p>
</li>
</ul>
<h3 id="4-7-BFD库"><a href="#4-7-BFD库" class="headerlink" title="4.7  BFD库"></a>4.7  BFD库</h3><ul>
<li>BFD库( Binary File Descriptor library)目标是希望通过一种统一的接口来处理不同的目标文件格式。</li>
<li>现在GCC(更具体地讲是GNU汇编器GAS, GNU Assembler)、链接器ld、调试器GDB及 binutils的其他工具都通过BFD库来处理目标文件,而不是直接操作目标文件。</li>
<li>这样做最大的好处是<strong>将编译器和链接器本身同具体的目标文件格式隔离开来</strong>,一旦我们须要支持一种新的目标文件格式,只须要在BFD库里面添加一种格式就可以了,而不须要修改编译器和链接器。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>在链接之前,指令内所使用的<strong>外部符号对应的地址</strong>是<strong>不正确的</strong>(例如<strong>0x00000000</strong>等)</li>
<li>链接器，通过相似段合并将所有的.o文件链接在一起</li>
<li>链接的两大过程：静态链接过程<ul>
<li>空间与地址分配<ol>
<li>将所有目标文件进行相似段合并时，就能确定原来目标文件的段，在最终的输出文件的位置</li>
<li>将输入目标文件中的符号表中所有的符号定义和符号引用收集起来,统放到一个<strong>全局符号表</strong></li>
<li>此时已经可以确定，各个段在虚拟地址空间的地址，以及各个符号在虚拟地址空间的地址<ul>
<li>各个指令和数据段等内容的虚拟地址都会被重新确定</li>
<li>此时唯一没有被确定的是外部符号的地址</li>
</ul>
</li>
</ol>
</li>
<li>符号解析与重定位<ul>
<li>符号解析过程<ul>
<li>通过符号在全局符号表中查找对应符号的虚拟地址</li>
</ul>
</li>
<li>重定位过程<ul>
<li>通过重定位表，知道哪些位置的指令地址需要进行重新调整，以及怎么调整。</li>
<li>重定位表中一系列的重定位入口，通过重定位入口可以得到需要重定位的符号，以及符号位于哪条指令</li>
<li>得到符号后，通过符号解析得到对应的地址，然后修改对应指令中该符号的地址即可。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="可执行文件的装载与进程"><a href="#可执行文件的装载与进程" class="headerlink" title="可执行文件的装载与进程"></a>可执行文件的装载与进程</h2><p>可执行文件只有装载到内存以后才能被CPU执行。</p>
<h3 id="6-1-进程虚拟地址空间"><a href="#6-1-进程虚拟地址空间" class="headerlink" title="6.1 进程虚拟地址空间"></a>6.1 进程虚拟地址空间</h3><ul>
<li><p>程序和进程的区别</p>
<ol>
<li>程序(或者狭义上讲可执行文件)是一个静态的概念,它就是一些预先编译好的指令和数据集合的一个文件</li>
<li>进程则是一个动态的概念,它是程序运行时的一个过程,很多时候把动态库叫做运行时( Runtime)也有一定的含义</li>
</ol>
</li>
<li><p>程序被运行起来以后,它将拥有自己独立的虚拟地址空间( Virtual Address Space)</p>
</li>
<li><p>虚拟地址空间的大小由计算机的硬件平台决定,具体地说是由CPU的位数决定的。</p>
<ol>
<li>硬件决定了地址空间的最大理论上限,即硬件的寻址空间大小</li>
<li>32位的硬件平台决定了虚拟地址空间的地址为0到2^32-1,即为4GB</li>
<li>64位的硬件平台具有64位寻址能力,即为2^64-1，为17179869184GB</li>
</ol>
</li>
<li><p>从程序的角度，c语言指针所占的位数和虚拟空间的位数相同</p>
</li>
<li><p>操作系统为了达到监控程序运行等一系列目的,进程的虚拟空间都在操作系统的掌握之中</p>
</li>
<li><p>进程只能使用那些操作系统分配给进程的地址,如果访问未经允许的空间,那么操作系统就会捕获到这些访问,将进程的这种访问当作非法操作,强制结束进程</p>
</li>
<li><p>Linux操作系统中，虚拟地址的空间分配</p>
<p><img src="/img/6-Linux空间地址分布.png" alt></p>
<ol>
<li>操作系统本身用了1GB:从地址0xC000000到0XFFFFFFFF,共1GB。剩下的从0x000000址开始到0xBFFFFFFF共3GB的空间都是留给进程使用的</li>
<li>进程并不能完全使用这3GB的虚拟空间,其中有一部分是预留给其他用途的</li>
</ol>
</li>
<li><p>对于 Windows操作系统来说,它的进程虚拟地址空间划分是操作系统占用2GB,那么</p>
<p>进程只剩下2GB空间。但可以修改为操作系统占用1GB, 进程占3GB。</p>
</li>
</ul>
<h5 id="6-1-1-PAE"><a href="#6-1-1-PAE" class="headerlink" title="6.1.1 PAE"></a>6.1.1 PAE</h5><ul>
<li><p>32位虚拟空间地址是4GB，这个是无法改变的。</p>
</li>
<li><p>但从硬件层面上来讲,将原先的32位地址先扩展至36位地址线之后, Intel修改了页映射的方式,使得新的映射方式可以访问到更多的物理内存(64G)。 Intel把这个地址扩展方式叫做PAE( Physical Address Extension)。</p>
</li>
<li><p>一个应用程序中0x10000000x2000000一段256MB的虚拟地址空间用来做窗口,程序可以从高于4GB的物理空间中申请多个大小为256MB的物理空间,编号成A、B、C等,然后根据需要将这个窗口映射到不同的物理空间块,用到A时将0x1000000-0x2000000映射到A,用到B、C时再映射过去,如此重复操作即可</p>
</li>
</ul>
<p>在 Windows下,这种访问内存的操作方式叫做AWE( Address windowing Extensions)在Linux等类unix操作系统则采用mmap()系统调用来实现。</p>
<h3 id="6-2-装载方式"><a href="#6-2-装载方式" class="headerlink" title="6.2 装载方式"></a>6.2 装载方式</h3><ul>
<li><p>程序执行时所需要的指令和数据必须在内存中才能够正常运行,所以最简单的方法是直接把程序整个载入内存。但是很多时候物理内存是不够，扩展更大的内存代价又是昂贵的。</p>
</li>
<li><p>人们发现程序运行时是有局部性原理的,所以将程序最常用的部分驻留在内存中,而将一些不太常用的数据存放在磁盘里面,这就是<code>动态装入的基本原理</code></p>
</li>
<li><p><code>覆盖载入(Overlay)</code>和<code>页映射(Paging)</code>是两种典型的载入方法</p>
</li>
<li>动态装入的思想是程序用到哪个模块,就将哪个模块装入内存,如果不用就暂时不装入,存放在磁盘中。</li>
</ul>
<h4 id="6-2-1-覆盖载入"><a href="#6-2-1-覆盖载入" class="headerlink" title="6.2.1 覆盖载入"></a>6.2.1 覆盖载入</h4><ul>
<li><p>覆盖装入在没有发明虚拟存储之前使用比较广泛,现在已经几乎被淘汰了</p>
</li>
<li><p>程序员在编写程序的时候需要手工将程序分割成若干块，然后编写一个小的辅助代码()来管理这些模块何时应该驻留内存而何时应该被替换掉。</p>
</li>
<li><p>这个小的辅助代码就是所谓的覆盖管理器( Overlay Manager)</p>
</li>
<li><p>例如main模块会调用A,B模块。但A,B模块不会互相调用。整个程序需要1792个字节</p>
<p><img src="/img/6-简单的覆盖载入.png" alt></p>
<ol>
<li>当main调用A时将A载入。当main调用B时将B载入覆盖A。所以整个程序只需要1536个字节</li>
<li>覆盖管理器比较小，一般是数十到数百个字节，常驻内存</li>
</ol>
</li>
<li><p>真实的项目比较复杂，序员需要手工将模块按照它们之间的调用依赖关系组织成树状结构</p>
<p><img src="/img/6-复杂的覆盖载入.png" alt></p>
<ul>
<li><p>这个树状结构中从仼何一个模块到树的根(也就是main)模块都叫调用路径</p>
<ul>
<li>当该模块被调用时,整个调用路径上的模块必须都在内存中。比如程序正在模块E中执行代<br>码,那么模块B和模块mai必须都在内存中,以确保模块E执行完毕以后能够正确返回至模块B和模块main</li>
</ul>
</li>
<li><p>禁止跨树间调用</p>
<ul>
<li>任意一个模块不允许跨过树状结构进行调用。比如上面例子中,模块A不可以调用模块B、E、F;模块C不可以调用模块D、B、E、F等。因为覆盖管理器不能够保证跨树间的模块能够存在于内存中。不过很多时候可能两个子模块都需要依赖于某个模块,比如模块E和模块C都需要另外一个模块G,那么最方便的做法是将模块G并入到main模块中,这样G就在E和C的调用路径上了。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="6-2-2-页映射"><a href="#6-2-2-页映射" class="headerlink" title="6.2.2 页映射"></a>6.2.2 页映射</h4><ul>
<li><p>页映射是虚拟存储机制的一部分，它随着虚拟存储的发明而诞生。</p>
</li>
<li><p>页映射将内存和所有磁盘中的数据和指令按照“页(Page)”为单位划分成若干个页,以后所有的装载和操作的单位就是页</p>
<p>硬件规定的页的大小有4096字节、8192字节、2MB、4MB等,最常见的 Intel IA32处理器一般都使用4096字节的页,<br>那么512MB的物理内存就拥有512<em>1024</em>1024/4096=131072个页。</p>
</li>
<li><p>页映射装载过程</p>
<ol>
<li><p>假设我们的32位机器有16KB的内存,每个页大小为4096字节,则共有4个页</p>
<p><img src="/img/6-页映射页编号.png" alt></p>
</li>
<li><p>设程序所有的指令和数据总和为32KB,那么程序总共被分为8个页。我们将它们编号为P0~P7</p>
</li>
<li><p>16KB的内存无法同时将32KB的程序装入,那么我们将按照动态装入的原理来进行整个装入过程</p>
<p><img src="/img/6-页映射与装载.png" alt></p>
</li>
<li><p>此时P0, P3,P5,P6已经装载到内存了，然后接下来要装载P4。可以按照先进先出算法将F0分配给P4。或者如果发现F2很少被访问到，可以按照最少使用算法，选择F2分配给P4.</p>
</li>
<li><p>页映射机制由<code>操作系统的存储管理器</code>进行管理。</p>
</li>
</ol>
</li>
</ul>
<h3 id="6-3-从操作系统角度看可执行文件的装载"><a href="#6-3-从操作系统角度看可执行文件的装载" class="headerlink" title="6.3 从操作系统角度看可执行文件的装载"></a>6.3 从操作系统角度看可执行文件的装载</h3><h4 id="6-3-1-进程的建立"><a href="#6-3-1-进程的建立" class="headerlink" title="6.3.1 进程的建立"></a>6.3.1 进程的建立</h4><ul>
<li><p>一个进程最关键的特征是它拥有独立的虚拟地址空间,这使得它有别于其他进程</p>
</li>
<li><p>创建一个进程,然后装载相应的可执行文件并且执行。在有虚拟存储的情况下,上述过程最开始只需要做三件事情:</p>
<ol>
<li>创建一个独立的虚拟地址空间</li>
<li>读取可执行文件头,并且建立虚拟空间与可执行文件的映射关系</li>
<li>将CPU的指令寄存器设置成可执行文件的入口地址,启动运行</li>
</ol>
</li>
<li><p>创建虚拟地址空间</p>
<ol>
<li>一个虚拟空间由一组页映射函数将虚拟空间的各个页映射至相应的物理空间</li>
<li>创建一个虚拟空间实际上是<strong>创建映射函数所需要的相应的数据结构</strong></li>
<li>在i386的Linux下，创建虚拟地址空间实际上只是分配一个页目录( Page Directory)， 映射关系等到后面程序发生页错误的时再进行设置</li>
<li>页映射关系函数是虚拟空间到物理内存的映射关系。</li>
</ol>
</li>
<li><p>读取可执行文件头,并且建立虚拟空间与可执行文件的映射关系</p>
<ol>
<li><p>这一步是建立虚拟空间与可执行文件的映射关系。</p>
</li>
<li><p>当程序执行发生页错误时,操作系统将从物理内存中分配一个物理页,然后将该“缺页”从磁盘中读取到内存中,再设置缺页的虚拟页和物理贞的映射关系。</p>
</li>
<li><p>当操作系统捕获到缺页错误时,它应知道程序当前所需要的页在可执行文件中的哪一个位置。这就是虚拟空间与可执行文件之间的映射关系。</p>
</li>
<li><p>由于可执行文件在装载时实际上是被映射到虚拟空间,所以可执行文件很多时候又被叫做<strong>映像文件( Image)</strong></p>
</li>
<li><p>假设我们的ELF可执行文件只有一个代码段“.text“,它的虚拟地址为0x08048000,它在文件中的大小为0x000e1,对齐为0x1000</p>
<p>由于虚拟存储的贞映射都是以页为单位的,在32位的 Intel IA32下一般为4096字节,所以32位ELF<br>的对齐粒度为0x1000。由于该.text段大小不到一个页,考虑到对齐该段占用一个段</p>
<p><img src="/img/6-可执行文件与进程虚拟空间.png" alt></p>
</li>
<li><p>Linux将进程虚拟空间中的一个段叫做虚拟内存区域(VMA, Virtual Memory Area)。在windows中叫虚拟段</p>
<p>操作系统创建进程后,会在进程相应的数据结构中设置有一个.text段的VMA:它在虚拟空间中的地址为<br>0x08048000~0x08049000,它对应ELF文件中偏移为0的.text,它的属性为只读(一般代码段都是只读的),还有一些其他的属性。</p>
</li>
<li><p>上面描述的数据结构，即为映射关系，该映射关系在操作系统内部保存。</p>
</li>
</ol>
</li>
<li><p>将CPU指令寄存器设置成可执行文件入口,启动运行</p>
<ol>
<li>操作系统通过设置CPU的指令寄存器将控制权转交给进程,由此进程开始执行</li>
<li>这一步看似简单,实际上在操作系统层面上比较复杂,它涉及内核堆栈和用户堆栈的切换、CPU运行权限的切换</li>
<li>可以简单地认为操作系统执行了一条跳转指令,直接跳转到可执行文件的入口地址</li>
<li>该入口地址即为<strong>ELF文件头中保存有入口地址</strong></li>
</ol>
</li>
</ul>
<h4 id="6-3-2-页错误"><a href="#6-3-2-页错误" class="headerlink" title="6.3.2 页错误"></a>6.3.2 页错误</h4><ul>
<li>进程建立后，其实可执行文件的真正指令和数据都没有被装入到内存中</li>
<li>操作系统只是通过可执行文件头部的信息建立起可执行文件和进程虚存之间的映射关系而已</li>
<li>当CPU开始打算执行入口地址的指令时,发现该页面0x08048000~0x0804900是个空页面，于是发生页错误。CPU将控制权交给操作系统</li>
<li><p>操作系统通过查询前面建立的数据结构(虚拟空间与可执行文件之间的关系),找到该页面所在的VMA，并在物理内存中分配一个物理页面，将进程中该虚拟页与分配的物理页之间建立映射关系</p>
<p><img src="/img/6-页错误过程.png" alt></p>
</li>
<li><p>然后再把控制权还给进程，进程共刚才页错误的位置重新开始执行。</p>
</li>
<li>随着进程执行， 页错误也会不断地产生，当所需要的内存会超过可用的内存时，操作系统进行虚拟内存的管理。</li>
</ul>
<h3 id="6-4-进程虚拟空间分布"><a href="#6-4-进程虚拟空间分布" class="headerlink" title="6.4 进程虚拟空间分布"></a>6.4 进程虚拟空间分布</h3><h4 id="6-4-1-ELF文件链接视图和执行视图"><a href="#6-4-1-ELF文件链接视图和执行视图" class="headerlink" title="6.4.1 ELF文件链接视图和执行视图"></a>6.4.1 ELF文件链接视图和执行视图</h4><ul>
<li>当段的数量增多时,如果按照每个段都映射为系统页的整数倍，会产生空间浪费的问题。</li>
<li><p>段的权限组合:</p>
<ol>
<li>以代码段为代表的权限为可读可执行的段</li>
<li>以数据段和BSS段为代表的权限为可读可写的段</li>
<li>以只读数据段为代表的权限为只读的段</li>
</ol>
</li>
<li><p>新方案就是:对于相同权限的段,把它们合并到一起当作一个段进行映射。</p>
</li>
<li>ELF可执行文件引入了一个概念叫做<code>Segment</code>,一个<code>Segment</code>包含一个或多个属性类似的<code>Section</code><ul>
<li>比如有两个段分别叫“.text”和“.init”,它们包含的分别是程序的可执行代码和初始化代码,并且它们的权限相同,都是可读并且可执行的。假设.text为4097字节,.init为512字节,这两个段分别映射的话就要占用三个页面,但是,如果将它们合并成一起映射的话只须占用两个页面</li>
</ul>
</li>
<li>“ Segment’”的概念实际上是从装载的角度重新划分了ELF的各个段。系统正是按照segment而不是按照section来映射可执行文件的。</li>
<li><p>在将目标文件链接成可执行文件的时候,链接器会尽量把相同权限属性的段分配在同一空间。以便将它们当成一个段来进行映射</p>
</li>
<li><p>segment结构，有一段代码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">       sleep(<span class="number">1000</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>使用静态链接编译成可执行文件 <code>$ gcc -static SectionMapping.c -o SectionMapping.elf</code></li>
<li><p>通过<code>$ readelf -S SectionMapping.elf</code> 可知共有33个section</p>
<p><img src="/img/6-ELF_Section结构0.png" alt></p>
<p><img src="/img/6-ELF_Section结构1.png" alt></p>
</li>
<li><p>描述<code>segment</code>的结构叫程序头(Program Header), 它描述了ELF如何被操作系统映射到进程的虚拟空间</p>
</li>
<li><p>通过<code>$ readelf -l SectionMapping.elf</code>查看<code>segment</code></p>
<p><img src="/img/6-ELF_Segment程序头.png" alt></p>
</li>
<li><p>这个可执行文件中共有5个 Segment.。从装载的角度看,我们目前只关心两个“LOAD”类型的 Segment,因为只有它是需要被映射的,其他的装载时起辅助作用的。</p>
</li>
<li>从Section的角度看ELF文件是<strong>链接视图</strong>,从Segment的角度看ELF文件是<strong>执行视图</strong></li>
<li><p>所有相同属性的<code>Section</code>被归类到一个<code>Segmen</code>t中，并被映射到同一个<code>VMA</code></p>
<p><img src="/img/6-ELF_按Segment划分.png" alt></p>
</li>
<li><p>ELF可执行文件中有一个专门的数据结构叫做程序头表(Program Header Table)用来保存<code>Segmetn</code>的信息。</p>
</li>
<li>ELF目标文件不需要被装载，所以它没有程序头表，ELF可执行文件和共享库文件都有。</li>
</ol>
</li>
<li><p>程序头表是一个结构体(ELF32_Phdr)数组</p>
<p><img src="/img/6-Elf32_Phdr.png" alt><br><img src="/img/6-Elf32_Phdr各字段含义.png" alt></p>
<ul>
<li>如果 <code>p_memse</code>大于 <code>p_filesz</code>,就表示该“ Segment”在内存中所分配的空间大小超过文件中实际的大小。</li>
<li>“多余”的部分则全部填充为“0”。这样做的好处是,我们在构造ELF可执行文件时不需要再额外设立BSS的“ Segment”了,可以把数据“ Segment”的 p_memse扩大,那些额外的部分就是BSS</li>
<li>在前面的例子中只看到了两个“LOAD”类型的Segment,是因为BSS已经被合并到了数据类型的段里面了</li>
</ul>
</li>
</ul>
<h4 id="6-4-2-堆和栈"><a href="#6-4-2-堆和栈" class="headerlink" title="6.4.2 堆和栈"></a>6.4.2 堆和栈</h4><ul>
<li>操作系统通过使用VMA来对进程的地址空间进行管理</li>
<li>一个进程中的<strong>栈和堆</strong>分别都有一个对应的VMA</li>
<li><p>在 Linux下,通过“/pro”来查看进程的虚拟空间分布:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./SectionMapping elf&amp;</span><br><span class="line">[1]21963</span><br><span class="line">$ cat /proc/21963/maps</span><br></pre></td></tr></table></figure>
<p><img src="/img/6-虚拟空间分布.png" alt></p>
<ol>
<li>第一列是VMA的地址范围</li>
<li>第二列是VMA的权限<br>   “r”表示可读<br>   “w”表示可写<br>   “x”表示可执行<br>   “p”表示私有（COW, Copy on Write）<br>   “s”表示共享</li>
<li>第三列是偏移,表示VMA对应的 Segment在映像文件中的偏移</li>
<li>第四列表示映像文件所在设备的主设备号和次设备号</li>
<li>第五列表示映像文件的节点号</li>
<li>最后列是映像文件的路径</li>
</ol>
<ul>
<li><p>前两个是映射到可执行文件中的两个 Segment</p>
</li>
<li><p>另外三个段的文件所在设备主设备号和次设备号及文件节点号都是0,则表示它们没有映射</p>
<p>到文件中,这种VMA叫做<code>匿名虚拟内存区域( Anonymous Virtual Memory Area)</code></p>
</li>
<li><p>有两个区域分别是堆(Heap)和栈( Stack), 这两个VMA几乎在所有的进程中存在</p>
</li>
<li><p>C语言程序里面最常用的 malloc()内存分配函数就是从<strong>堆</strong>里面分配的,堆由系统库管理</p>
</li>
<li><p><strong>栈</strong>一般般也叫做堆栈,我们知道每个线程都有属于自己的堆栈,对于单线程的程序来讲,这个</p>
<p>VMA堆栈就全都归它使用</p>
</li>
<li><p>特殊VIMA叫做<code>vdso</code>, 它的地址己经位于内核空间了(即大于0xC00000的地址), 事实上它是一个内核的模块,进程可以通过访问这个MA来跟内核进行一些通信</p>
</li>
</ul>
</li>
<li><p>操作系统通过给进程空间划分出一个个VMA来管理进程的虚拟空间</p>
</li>
<li><p>一个进程基本上可以分为如下几种ⅤMA区域</p>
<ol>
<li>代码VMA,权限只读、可执行;；有映像文件。</li>
<li>数据VMA,权限可读写、可执行；有映像文件。</li>
<li>堆VMA,权限可读写、可执行；无映像文件,匿名,可向上扩展。</li>
<li>栈VMA,权限可读写、不可执行；无映像文件,匿名,可向下扩展</li>
</ol>
</li>
<li><p>进程虚拟空间的图示</p>
<p><img src="/img/6-ELF与进程虚拟空间映射关系.png" alt></p>
<ol>
<li><p>VMA2的结束地址，计算出应该是0x080bc00,但实际上是0x080bb000。</p>
</li>
<li><p>Linux规定一个VMA可以映射到某个文件的一个区域,或者是没有映射到任何文件</p>
</li>
<li><p>VMA2从“ tdata”段到“data”段部分要建立从虚拟空间到文件的映射， 而“.bss”和“_ libcfreeres_ptrs”部分没有映射到文件。</p>
</li>
</ol>
</li>
</ul>
<h4 id="6-4-3-堆的最大申请数量"><a href="#6-4-3-堆的最大申请数量" class="headerlink" title="6.4.3  堆的最大申请数量"></a>6.4.3  堆的最大申请数量</h4><ul>
<li><p>通过下面程序测试malloc()能够申请多大内存</p>
<p><img src="/img/6-申请内存代码.png" alt></p>
<ul>
<li>在Linux(可分配的空间为3G)机器上运行结果大约在2.9G左右， windows(可分配的空间为2G)下运行结果大约是1.5个G</li>
<li>具体的数值会受到操作系统版本、程序本身大小、用到的动态/共享库数量、大小、程序栈数量、大小等影响</li>
<li>甚至有可能每次运行的结果都会不同,因为有些操作系统使用了一种叫做随机地址空间分布的技术(主要是出于安全考虑,防止程序受恶意攻击),使得进程的堆空间变小</li>
</ul>
</li>
</ul>
<h4 id="6-4-4-段地址对齐"><a href="#6-4-4-段地址对齐" class="headerlink" title="6.4.4 段地址对齐"></a>6.4.4 段地址对齐</h4><ul>
<li><p>对于Inter 80x86处理器来说，默认页大小为4096。所以映射时内存空间长度必须是页的整数倍</p>
</li>
<li><p>段对齐讨论</p>
<ol>
<li><p>假设我们有一个ELF可执行文件,它有三个段( Segment)需要装载,我们将它们命名为SEG0、SEG1和SEG2。</p>
<p><img src="/img/6-段对齐0.png" alt></p>
</li>
<li><p>每个段分开映射,对于长度不足个页的部分则占一个页。通常ELF可执行文件的起始虚拟地址为0x08048000</p>
<p><img src="/img/6-段对齐1.png" alt></p>
<p>这种对齐方式在文件段的内部会有很多内部碎片,浪费磁盘空间</p>
</li>
<li><p>为了解决这种问题,有些UNIX系统采用了一个很取巧的办法,就是让那些各个段接壤</p>
<p>部分共享一个物理页面,然后将该物理页面分别映射两次</p>
<p>SEG1的接壤部分的那个物理页,系统将它们映射两份到虚拟地址空间,一份为SEGO,另外一份为SEGI,其他的页都按照正常的页粒度进行映射.</p>
<p><img src="/img/6-段对齐2.png" alt></p>
</li>
<li><p>在这种情况下，内存空间得到了充分的利用,本来要用到5个物理页面,也就是20480字节的内存,现在只有3个页面,即12288字节。</p>
</li>
<li><p>这种映射方式下,对于一个物理页面来说,它可能同时包含了两个段的数据,甚至可能是多于两个段</p>
</li>
<li><p>因为段地址对齐的关系,各个段的虚拟地址就往往不是系统页面长度的整数倍了</p>
<p><img src="/img/6-段对齐3.png" alt></p>
</li>
</ol>
</li>
</ul>
<h4 id="6-4-5-进程栈初始化"><a href="#6-4-5-进程栈初始化" class="headerlink" title="6.4.5 进程栈初始化"></a>6.4.5 进程栈初始化</h4><ul>
<li>操作系统在进程启动前将进程运行环境相关的信息提前保存到进程的虚拟空间的栈中(也就是VMA中的 Stack VMA)</li>
<li><p>Linux的进程初始化后栈的结构</p>
<ol>
<li><p>假设系统中有两个环境变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HOME=/home/user</span><br><span class="line">PATH=/usr/bin</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行命令行 <code>$ prog 123</code></p>
</li>
<li><p>假设堆栈段底部地址为0xBF802000,那么进程初始化后的堆栈就如图</p>
<p><img src="/img/6-Linux进程初始化堆栈.png" alt></p>
<p>栈顶寄存器esp指向的位置是初始化以后堆栈的顶部,最前面的4个字节表示命令行参数的数量,我们的例子里面是两个,即“prog”和“123”,紧接的就是分布指向这两个参数字符串的指针:后面跟了一个0;接着是两个指向环境变量字符串的指针,它们分别指向字符串“HOME=/home/user”和“PATH=/usr/bin”;后面紧跟一个0表示结束。</p>
</li>
<li><p>进程在启动以后,程序的库部分会把堆栈里的初始化信息中的参数信息传递给 main()函数的argc(命令行参数数量) 和 argv(命令行参数字符串指针数组)两个参数。</p>
</li>
</ol>
</li>
</ul>
<h3 id="6-5-Linux-内核装载ELF过程"><a href="#6-5-Linux-内核装载ELF过程" class="headerlink" title="6.5 Linux 内核装载ELF过程"></a>6.5 Linux 内核装载ELF过程</h3><p>在bash执行一个命令执行ELF程序时，ELF文件装载过程</p>
<ul>
<li><p>用户层面,bash进程会调用fork()系统调用创建一个新的进程</p>
</li>
<li><p>然后新的进程调用 execve()系统调用执行指定的ELF文件,原先的bash进程继续返回等待刚才启动的新进程结束,然后继续等待用户输入命令</p>
<ul>
<li>execveo系统调用被定义在 unistd.h,它的原型如下</li>
<li><code>int execve(const char *filename, char *const argv[], char *const envp[]);</code></li>
<li>它的三个参数分别是被执行的程序文件名、执行参数和环境变量</li>
<li>Glibc对 execvpo系统调用进行了包装,提供了 execl、 execl、 execl、 execvo和 execvp0等5个不同形式的exec系列API,它们只是在调用的参数形式上有所区别,但最终都会调用到 execve()这个系统中</li>
</ul>
</li>
<li><p>在进入 execve()系统调用之后, Linux内核就开始进行真正的装载工作</p>
</li>
<li><p>在内核中execve()系统调用相应的入口是 sys_execve(), sys_execve()进行一些参数的检查复制之后,调用do_execve()</p>
</li>
<li><p>do_execve()会首先查找被执行的文件,如果找到文件,则读取文件的前128个字节来判断文件的格式</p>
<ol>
<li>每种可执行文件的格式的开头几个字节都是很特殊的,特别是开头4个字节,常常被称做魔数( Magic Number),通过对魔数的判断可以确定文件的格式和类型</li>
<li>ELF的可执行文件格式的头4个字节为0x7F、’e’、‘l’、’f’;</li>
<li>而Java的可执行文件格式的头4个字节为’c’、’a’、’f’、’e’</li>
</ol>
</li>
<li><p>然后调用 search_binary_handle()去搜索和匹配合适的可执行文件装载处理过程，search_binary_handle会通过判断文件头部的魔数确定文件的格式,并且调用相应的装载处理过程</p>
</li>
<li><p>ELF可执行文件的装载处理过程叫做 load_elf_binary(),其主要步骤为:</p>
<ol>
<li>检査ELF可执行文件格式的有效性,比如魔数、程序头表中段( Segment)的数量</li>
<li>寻找动态链接的“ .interp”段,设置动态链接器路径(与动态链接有关,具体请参考第9章）</li>
<li>根据ELF可执行文件的程序头表的描述,对ELF文件进行映射,比如代码、数据、只读数据</li>
<li>初始化ELF进程环境,比如进程启动时EDX寄存器的地址应该是DT_FINI的地址(参照动态链接)</li>
<li>将系统调用的返回地址修改成ELF可执行文件的入口点,这个入口点取决于程序的链接方式,对于静态链接的ELF可执行文件,这个程序入口就是ELF文件的文件头中e_eny所指的地址;对于动态链接的ELF可执行文件,程序入口点是动态链接器</li>
</ol>
</li>
<li><p>当 load_elf_binary执行完毕,返回至 do_execve()再返回至 sys_execve()时, 上面的第5步已经把系统调用的返回地址改成了被装载的ELF程序的入口地址了</p>
</li>
<li>所以当 sys_execve()系统调用从内核态返回到用户态时,EIP寄存器直接跳转到了ELF程序的入口地址,于是新的程序开始执行,ELF可执行文件装载完成。</li>
</ul>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul>
<li>虚拟地址空间<ul>
<li>程序被运行起来,系统为它创建一个进程,它将拥有自己独立的虚拟地址空间( Virtual Address Space)</li>
<li>进程只能使用一部分虚拟地址空间 ，因为一部分是给操作系统和其他用途的</li>
</ul>
</li>
<li>程序的局部性原理<ul>
<li>利用<strong>程序的局部性原理</strong>,所以将程序最常用的部分驻留在内存中,而将一些不太常用的数据存放在磁盘里面,这就引入了动态载入。</li>
</ul>
</li>
<li>动态载入的原理<ul>
<li>程序用到哪个模块,就将哪个模块装入内存,如果不用就暂时不装入,存放在磁盘中</li>
</ul>
</li>
<li>装载方式: 页映射</li>
<li>虚拟地址空间<ul>
<li>实际上是⼀组<strong>⻚映射关系函数</strong></li>
<li><strong>⻚映射关系函数</strong>是虚拟空间到物理内存的映射关系。</li>
</ul>
</li>
<li>进程的建立<ul>
<li>创建⼀个独立的虚拟地址空间</li>
<li>读取可执⾏⽂件头,并且建⽴虚拟空间与可执⾏⽂件的映射关系</li>
<li>将CPU的指令寄存器设置成可执⾏⽂件的⼊⼝地址,启动运⾏</li>
</ul>
</li>
<li><p>页错误：不断的通过页错误将可执行程序装入到内存中</p>
<ul>
<li>进程建立后，其实可执行文件的真正指令和数据都没有被装入到内存中</li>
<li>操作系统只是通过可执⾏⽂件头部的信息建⽴起可执⾏⽂件和进程虚存之间的映射关系⽽已</li>
<li>当CPU开始打算执⾏⼊⼝地址的指令时,发现该⻚⾯是个空⻚⾯，于是发<br>⽣⻚错误。CPU将控制权交给操作系统。</li>
<li>操作系统通过查询虚拟空间与可执⾏⽂件之间的映射关系,在磁盘中找到该⻚⾯，将该页面载入到内存中，在物理内存中分配⼀个物理⻚⾯，将进程中该虚拟⻚与分配的物理⻚之间建⽴映射关系</li>
<li>然后再把控制权还给进程，进程共刚才⻚错误的位置重新开始执⾏。</li>
<li>随着进程执⾏， ⻚错误也会不断地产⽣，当所需要的内存会超过可⽤的内存时，操作系统进⾏虚<br>拟内存的管理</li>
</ul>
</li>
<li><p>进程虚拟空间分布</p>
<ul>
<li>当段的数量增多时,如果按照每个段都映射为系统⻚的整数倍，会产⽣空间浪费的问题。因此，对于相同权限的段,把它们合并到⼀起当作⼀个段进⾏映射</li>
<li>进程ⅤMA权限划分<ul>
<li>代码VMA,权限只读、可执⾏;；有映像⽂件</li>
<li>数据VMA,权限可读写、可执⾏；有映像⽂件</li>
<li>堆VMA,权限可读写、可执⾏；⽆映像⽂件,匿名,可向上扩展。</li>
<li>栈VMA,权限可读写、不可执⾏；⽆映像⽂件,匿名,可向下扩展</li>
</ul>
</li>
</ul>
<ul>
<li><p>虚拟空间分布图示</p>
<p><img src="/img/6-ELF与进程虚拟空间映射关系.png" alt></p>
</li>
</ul>
</li>
</ul>
<h2 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h2><h3 id="7-1-为什么要动态链接"><a href="#7-1-为什么要动态链接" class="headerlink" title="7.1 为什么要动态链接"></a>7.1 为什么要动态链接</h3><ul>
<li><p>内存和磁盘空间</p>
<ul>
<li>如果只使用静态链接，静态连接的方式对于计算机内存和磁盘的空间浪费非常严重</li>
<li>每个程序内部除了都保留着 printf()函数、 scanf()函数、 strlen()等这样的公用库函数,还有数量相当可观的其他库函数及它们所需要的辅助数据结构。</li>
<li>这些重复的库和结构造成了内存和磁盘空间的严重浪费</li>
</ul>
</li>
<li><p>程序开发和发布</p>
<ul>
<li>静态链接对程序的更新、部署和发布也会带来很多麻烦</li>
<li>当一个程序中使用了某个库，当这个库更新时。如果使用的是静态链接，那么需要将最新的库，重新静态链接生成可执行文件，然后用户只能更新整个应用。</li>
</ul>
</li>
<li><p>动态链接</p>
<ul>
<li>要解决空间浪费和更新困难这两个问题最简单的办法就是把程序的模块相互分割开来,形成独立的文件,而不再将它们静态地链接在一起</li>
<li>不对那些组成程序的目标文件进行链接,等到程序要运行时才进行链接</li>
<li><p>假设Program1.o, Program12.o都依赖Lib.o，那么动态链接过程：</p>
<ol>
<li>要运行 Program1这个程序时,系统首先加载 Program1.o</li>
<li>当系统发现Program1.o中用到了Lib.o,即 Program1.o依赖于Lib.o,那么系统接着加载Lib.o,然后重复该过程直到所有的依赖都加入进来</li>
<li>然后系统开始进行链接工作， 原理与静态链接非常相似,包括符号解析、地址重定位等</li>
<li>链接完成后，系统开始把控制权交给 Program1.o的程序入口处,程序开始运行</li>
<li>此后如果我们需要运行 Program2，则只需要加载 Program2.o,而不需要重新加载Lib.o</li>
<li>因为内存中已经存在了一份Lib.o的副本,系统要做的只是将 Program2.o和Lib.o链接起来</li>
</ol>
</li>
<li><p>动态链接解决了共享的目标文件多个副本浪费磁盘和内存空间的问题,可以看到,磁盘和内存中只存在一份Lib.o,而不是两份。</p>
<p><img src="/img/7-动态链接时文件在内存中的副本.png" alt></p>
</li>
<li><p>在内存中共享一个目标文件模块的好处不仅仅是节省内存,它还可以减少物理页面的换入换出,也可以增加CPU缓存的命中率,因为不同进程间的数据和指令访问都集中在了同一个共享模块上</p>
</li>
<li><p>使程序的升级变得更加容易,当我们要升级程序库或程序共享的某个模块时,理论上只要简单地将旧的目标文件覆盖掉,而无须将所有的程序再重新链接一遍。当程序下一次运行的时候,新版本的目标文件会被自动装载到内存并且链接起来，程序就完成了升级的目标。</p>
</li>
<li><p>动态链接的方式使得开发过程中各个模块更加独立,耦合度更小</p>
</li>
</ul>
</li>
<li><p>程序可扩展性和兼容性</p>
<ol>
<li>动态链接还有一个特点就是程序<strong>在运行时可以动态地选择加载各种程序模块</strong>，这个优点就是后来被人们用来制作程序的<strong>插件( Plug-in)</strong></li>
<li>动态链接还可以加强程序的兼容性。一个程序在不同的平台运行时可以动态地链接到由操作系统提供的动态链接库。</li>
</ol>
</li>
<li><p>动态链接的基本实现</p>
<ol>
<li>在 Linux系统中,ELF动态链接文件被称为<strong>动态共享对象(DSO,</strong>，<strong>Dynamic Shared Objects),</strong>简称共享对象,是以“.so”为扩展名的文件</li>
<li>在 Windows系统中,动态链接文件被称为动态链接库( Dynamical Linking Library),是以“.dll”为扩展名的文件</li>
<li>在 Linux中,常用的C语言库的运行库glibc,它的动态链接形式的版本保存在“/lib”, 文件名叫做“libc.so”</li>
<li>整个系统只保留一份C语言库的动态链接文件“libc.so”,而所有的C语言编写的、动态链接的程序都可以在运行时使用它</li>
<li>当程序被装载的时候,系统的动态链接器会将程序所需要的所有动态链接库(最基本的就是libc.so)装载到进程的地址空间,并且将程序中所有未决议的符号绑定到相应的动态链接库中,并进行重定位工作</li>
<li>程序与libc.so之间真正的链接工作是由<strong>动态链接器</strong>完成的</li>
<li>动态链接会导致程序在性能的一些损失,但是对动态链接的链接过程可以进行优化，延迟绑定( Lazy Binding)等方法</li>
<li>动态链接与静态链接相比,性能损失大约在5%以下, 这点性能损失用来换取程序在空间上的节省和程序构建和升级时的灵活性,是相当值得的</li>
</ol>
</li>
</ul>
<h3 id="7-2-简单的动态链接例子"><a href="#7-2-简单的动态链接例子" class="headerlink" title="7.2 简单的动态链接例子"></a>7.2 简单的动态链接例子</h3><ol>
<li><p>以Program1和Program2进行演示。 相关源代码如下</p>
<p><img src="/img/7-动态链接示例代码0.png" alt></p>
<p><img src="/img/7-动态链接示例代码1.png" alt></p>
</li>
<li><p><code>$ gcc -fPIC -shared -o Lib.so Lib.c</code>得到Lib.so</p>
</li>
<li><p>分别编译链接Program1.c和Program2.c</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -o Program1 Program1.C  ./Lib.so</span><br><span class="line">$ gcc -o Program2 Program2.C  ./Lib.so</span><br></pre></td></tr></table></figure>
<p>其编译和链接过程如下图</p>
<p><img src="/img/7-动态链接过程.png" alt></p>
<ol>
<li>如果是静态链接， Program1.o被连接成可执行文件的过程中，Program1.o会和Lib.o连接在一起，生成可执行文件Program1</li>
<li>这里是动态链接，Lib.o没有链接进来, 链接的输入目标文件只有Program1.o</li>
<li>如果 foobar是一个定义与其他静态目标模块中的函数,那么链接器将会按照静态链接的规则,将 Program1.o中的 foobar地址引用重定位</li>
<li>如果 foobar是一个定义在某个动态共享对象中的函数,那么链接器就会将这个符号的引用标记为一个动态链接的符号,不对它进行地址重定位,把这个过程留到装载时再进行</li>
<li>Lib.so中保存了完整的符号信息(因为运行时进行动态链接还须使用符号信息),把Lib.so也作为链接的输入文件之一,链接器在解析符号时就可以知道: foobar是一个定义在Lib.so的动态符号。这样链接器就可以对 foobar的引用做特殊的处理,使它成为一个对动态符号的引用</li>
</ol>
</li>
</ol>
<h4 id="7-2-1-动态链接程序运行时地址空间分布"><a href="#7-2-1-动态链接程序运行时地址空间分布" class="headerlink" title="7.2.1 动态链接程序运行时地址空间分布"></a>7.2.1 动态链接程序运行时地址空间分布</h4><ol>
<li><p>对Lib.c的foobar()进行修改，使运行Program1时不立马结束</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foobar</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">   print(<span class="string">"printing from Lib.so %d\n"</span>, i);</span><br><span class="line">   sleep(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看进程的虚拟地址空间分布</p>
<p><img src="/img/7-进程的虚拟地址空间分布.png" alt></p>
<ol>
<li>Lib.so， Program1，libc-2.6.1.so，ld-2.6.so被映射至进程的虚拟地址空间</li>
<li>libc-2.6.1.so是c语言运行库</li>
<li>ld-2.6.so是Linux下的动态链接器</li>
<li>系统开始运行Program1之前,首先会把控制权交给动态链接器,由它完成所有的动态链接工作以后再把控制权交给 Program1,然后开始执行。</li>
</ol>
</li>
<li><p>通过<code>$ readelf -l Lib.so</code>查看Lib.so的装载属性</p>
<p><img src="/img/7-Lib.so的装载属性0.png" alt></p>
<p><img src="/img/7-Lib.so的装载属性1.png" alt></p>
<ul>
<li>动态链接模块的装载地址是从地址0x000000开始的,这个地址是无效地</li>
<li><strong>共享对象的最终装载地址在编译时是不确定的</strong>,而是在装载时,装载器根据当前地址空间的空闲情况,动态分配一块足够大小的虚拟地址空间给相应的共享对象</li>
</ul>
</li>
</ol>
<h3 id="7-3-地址无关代码"><a href="#7-3-地址无关代码" class="headerlink" title="7.3 地址无关代码"></a>7.3 地址无关代码</h3><h4 id="7-3-1-固定装载地址的困扰"><a href="#7-3-1-固定装载地址的困扰" class="headerlink" title="7.3.1 固定装载地址的困扰"></a>7.3.1 固定装载地址的困扰</h4><ul>
<li>共享对象在编译时不能假设自己在进程虚拟地址空间中的位置</li>
<li>与此不同的是,可执行文件基本可以确定自己在进程虚拟空间中的起始位置,因为可执行文件往往是第一个被加载的文件,它可以选择一个固定空闲的地址,比如 Linux下般都是0x08040000, Windows下一般都是0x0040000</li>
</ul>
<h4 id="7-3-2-装载时重定位"><a href="#7-3-2-装载时重定位" class="headerlink" title="7.3.2 装载时重定位"></a>7.3.2 装载时重定位</h4><ul>
<li>为了能够使共享对象在任意地址装载,在链接时,对所有绝对地址的引用不作重定位,而把这一步推迟到装载时再完成</li>
<li>模块装载地址确定,即目标地址确定,那么系统就对程序中所有的绝对地址引用进行重定位</li>
<li>静态链接的重定位叫做链接时重定位(Link Time Relocation)，此时对绝对地址的重定位处理叫装载时重定位(Load Time Relocation)</li>
</ul>
<h4 id="7-3-3-地址无关代码"><a href="#7-3-3-地址无关代码" class="headerlink" title="7.3.3 地址无关代码"></a>7.3.3 地址无关代码</h4><ul>
<li>装载时重定位是解决动态模块中有绝对地址引用的办法之一</li>
<li>但是它有一个很大的缺点是指令部分无法在多个进程之间共享,这样就失去了动态链接节省内存的一大优势</li>
<li>解决方案是: 把共享模块指令部分那些需要被修改的部分分离出来,跟数据部分放在一起,这样指令部分就可以保持不变,而数据部分可以在每个进程中拥有一个副本。这种方案就是目前被称为<strong>地址无关代码(PIC, Position-independent Code)</strong>的技术</li>
</ul>
<p>下面说的都是虚拟地址：</p>
<p>动态库数据部分为什么要在每个进程中有个副本(要分配真实的物理地址空间)？假如动态库的数据部分，有全局变量，当某个进行修改这个全局变量时，不应该对其他的进程造成影响。对于动态库中，假如引用外部的变量和函数，此时在其内部是绝对地址。为啥要把这部分指令也在使用该动态库的进程中放置一份(要分配真实的物理空间)？在多个进程中，某个动态库引用的外部的变量和函数的地址,不是固定的。例如该动态库访问的其他动态库中的外部变量的地址就不能固定。</p>
<ul>
<li><p>共享对象模块中的地址引用类型:</p>
<ul>
<li>按照是否为跨模块分成两类:模块内部引用和模块外部引用</li>
<li>按照不同的引用方式又可以分为指令引用和数据访问,</li>
</ul>
<ol>
<li>第一种是模块内部的函数调用、跳转等(相对地址)</li>
<li>第二种是模块内部的数据访问,比如模块中定义的全局变量、静态变量(相对地址)</li>
<li>第三种是模块外部的函数调用、跳转等(绝对地址)</li>
<li><p>第四种是模块外部的数据访问,比如其他模块中定义的全局变量(绝对地址)</p>
<p><img src="/img/7-四种寻址方式.png" alt></p>
</li>
</ol>
</li>
</ul>
<p>模块内部和模块外部的定义</p>
<ol>
<li>在上面的文件被编译时，不能确定b和ext()是模块外部还是模块内部</li>
<li>因为它们有可能被定义在同一个共享对象的其他目标文件中</li>
<li>由于没法确定，所以编译器只能把它们当做模块外部的函数和变量处理</li>
<li>MSVC编译器提供了__declspec(dllimport)编译器扩展来表示一个符号是符号内部的还是模块内部的</li>
</ol>
<p>总结: </p>
<ol>
<li>模块内部整个共享模块的内部</li>
<li>模块外部整个共享模块的外部</li>
</ol>
<ul>
<li><p>类型一 ： 模块内部调用或跳转</p>
<ol>
<li>即为被调用的函数或变量处于同一个模块，它们之间的相对位置固定</li>
<li>模块内部的跳转，函数调用都可以是相对地址调用，或者是基于寄存器的相对调用，所以这种指令是不需要重定位的。</li>
<li><p>例如foo函数调用bar函数</p>
<p><img src="/img/7-模块内部函数调用0.png" alt></p>
<p><img src="/img/7-模块内部函数调用1.png" alt></p>
</li>
<li><p>foo对bar的调用实际上是一条相对地址调用指令</p>
</li>
</ol>
</li>
<li><p>类型二 模块内部数据访问</p>
<ol>
<li>指令中不能直接包含数据的绝对地址，那么唯一的办法就是相对寻址</li>
<li>一个模块前面一般是若干个页的代码后面紧跟着若干个页的数据, 这些页之间的相对位置是固定的</li>
<li>任何一条指令与它需要访问的模块内部数据之间的相对位置是固定的,那么只需要相对于当前指令加上固定的偏移量就可以访问模块内部数据了</li>
<li>现代的体系结构中,数据的相对寻址往往没有相对与当前指令地址(PC)的寻址方式</li>
<li>ELF先找到PC的值，然后在加上一个偏移量就可以访问到相应的变量了</li>
<li><p>ELF获取PC值的常用方法</p>
<p><img src="/img/7-bar反汇编表示0.png" alt></p>
<p><img src="/img/7-bar反汇编表示1.png" alt></p>
</li>
</ol>
</li>
<li><p>类型三  模块间数据访问</p>
<ol>
<li>模块间的数据访问目标地址要等到装载时才决定</li>
<li>这些其他模块的全局变量的地址是跟模块装载地址有关的</li>
<li>ELF的做法是在数据段里面建立一个指向这些变量的指针数组,也被称为全局偏移表(Global offset Table,GOT)</li>
<li>当代码需要引用该全局变量时,可以通过GOT中相对应的项间接引用</li>
<li><p>通过GOT机制引用其他模块的全局变量</p>
<p><img src="/img/7-通过GOT机制引用其他模块的全局变量.png" alt></p>
<ol>
<li>每个变量都对应一个4个字节的地址,链接器在装载模块的时候会查找每个变量所在的地址,然后填充GOT中的各个项,以确保每个指针所指向的地址正确</li>
<li>当指令中需要访问变量b时,程序会先找到GOT,然后根据GOT中变量所对应的项找到变量的目标地址</li>
<li>GOT本身是放在数据段的,所以它可以在模块装载时被修改,并且每个进程都可以有独立的副本,相互不受影响</li>
<li>从第二中类型的数据访问我们了解到,模块在编译时可以确定模块内部变量相对与当前指令的偏移，那么同样可以确定GOT的位置</li>
<li>而GOT中的每个地址对应哪个变量是编译器决定的，所以我们找到GOT后就可以找到对应的变量的地址</li>
</ol>
</li>
</ol>
</li>
<li><p>类型四: 模块间调用,跳转</p>
<ol>
<li>与类型三的方法一样，也是采用GOT来找到函数。</li>
<li>GOT中保存的是目标函数的地址。</li>
<li><p>通过GOT机制引用其他模块的函数</p>
<p><img src="/img/7-通过GOT机制引用其他模块的函数.png" alt></p>
</li>
</ol>
</li>
<li><p>地址无关代码小结</p>
<p><img src="/img/7-地址无关小结.png" alt></p>
</li>
<li><p>gcc一般使用<code>-fPIC</code>产生地址无关代码，<code>-fpic</code>也可以产生地址无关代码，而且代码更少，速度更快。但地址无关代码跟硬件平台相关， <code>-fpic</code>在某些硬件平台上会有一些限制。</p>
</li>
<li>地址无关代码技术除了可以用在共享对象上面，也可以用于执行文件。这样的执行文件叫做地址无关可执行文件(PIE,Position-Independent Executable )</li>
</ul>
<h4 id="7-3-4-共享模块的全局变量问题"><a href="#7-3-4-共享模块的全局变量问题" class="headerlink" title="7.3.4 共享模块的全局变量问题"></a>7.3.4 共享模块的全局变量问题</h4><ul>
<li>ELF共享库在编译时,默认都把定义在模块内部的全局变量当作定义在其他模块的全局变量,也就是说当作前面的类型四,通过GOT来实现变量的访问</li>
</ul>
<h4 id="7-3-5-数据段地址无关性"><a href="#7-3-5-数据段地址无关性" class="headerlink" title="7.3.5 数据段地址无关性"></a>7.3.5 数据段地址无关性</h4><ul>
<li>对于共享对象来说,如果数据段中有绝对地址引用,那么编译器和链接器就会产生一个重定位表,这个重定位表里面包含了“R_386_RELATIVE”类型的重定位入口</li>
<li>当动态链接器装载共享对象时,如果发现该共享对象有这样的重定位入口,那么动态链接器就会对该共享对象进行重定位</li>
</ul>
<h3 id="7-4-延迟绑定"><a href="#7-4-延迟绑定" class="headerlink" title="7.4 延迟绑定"></a>7.4 延迟绑定</h3><ul>
<li>动态链接比静态链接慢的主要原因<ol>
<li>动态链接下对于全局和静态的数据访问都要进行复杂的GOT定位,然后间接寻址</li>
<li>对于模块间的调用也要先定位GOT,然后再进行间接跳转</li>
</ol>
</li>
<li><p>动态链接减慢程序的启动速度</p>
<ol>
<li>程序开始执行时,动态链接器都要进行一次链接工作</li>
<li>,动态链接器会寻找并装载所需要的共享对象,然后进行符号査找地址重定位等工作</li>
</ol>
</li>
<li><p>延迟绑定实现</p>
<ol>
<li>在程序运行过程中，可能很多函数在程序执行完时都不会被用到</li>
<li>如果一开始把所有函数都链接好实际上是一种浪费。所以ELF采用了一种叫<code>延迟绑定(Lazy Binding)</code>的做法</li>
<li><code>延迟绑定(Lazy Binding)</code>基本思想:当函数第一次被用到时才进行绑定(符号查找，重定位等)，如果没有用到则不进行绑定</li>
<li>程序开始执行时,模块间的函数调用都没有进行绑定,而是需要用到时才由<code>动态链接器</code>来负责绑定</li>
<li>ELF使用<code>PLT(Procedure Linkage Table)</code>机制来实现延迟绑定， 这种机制使用了很精巧的指令序列。</li>
</ol>
</li>
<li><p>PLT的基本原理：假设liba.so需要调用libc.so的bar()函数</p>
<ol>
<li><p>PLT并不直接通过GOT跳转来实现函数绑定，而是通过PLT项的结构进行跳转。而每个外部函数在PLT中都有一个相应的项。比如bar()函数对应的项</p>
<p><img src="/img/7-bar函数对应的PLT项.png" alt></p>
</li>
<li><p>bar@plt的第一条指令是一条通过GOT间接跳转的指令, bar@GOT表示GOT中保存bar()这个函数相应的项</p>
</li>
<li>为了实现延迟绑定,链接器在初始化阶段并没有将bar()的地址填入到该项</li>
<li>而是将上面代码中第二条指令“ push n”的地址填入到bar@GOT中</li>
<li>第二条指令将一个数字n压入堆栈中,这个数字是bar这个符号引用在重定位表“ rel.plt”中的下标</li>
<li>第三条指令将模块的ID压入到堆栈</li>
<li>第四条跳转到动态链接器的<code>_dl_ runtime_resolve()</code>函数，来完成符号解析和重定位工作</li>
<li><code>_dl_ runtime_resolve()</code>函数进行一系列工作之后将bar()真正的地址填入到bar@GOT中。</li>
<li>一旦解析完毕后，再次调用第一条指令直接就能跳转到真正的bar()函数中，不需要再往下执行了。</li>
</ol>
</li>
<li><p>ELF中将GOT分成两个表分别叫做<code>.got</code>和<code>.got.plt</code>。</p>
<ol>
<li><code>.got</code>用来保存全局变量引用的地址</li>
<li><code>.got.plt</code>用来保存外部函数引用的地址</li>
<li><code>.got.plt</code>的前三项是有特殊意义的<ul>
<li>第一项保存的是<code>.dynamic</code>段的地址,这个段描述了本模块动态链接相关的信息</li>
<li>第二项保存的是本模块的ID</li>
<li>第三项保存的是 <code>_dl_runtime_resolve</code>的地址</li>
</ul>
</li>
<li><code>.got.plt</code>的第二项和第三项由动态链接器在装载共享模块的时候负责将它们初始化</li>
<li><code>.got.plt</code>的其余项对应每个外部函数的引用</li>
</ol>
</li>
<li><p>GOT中的PLT数据结构</p>
<p><img src="/img/7-PLT的结构.png" alt></p>
</li>
<li><p>PLT在ELF文件中以独立的段存放,段名通常叫做“.plt”,因为它本身是一些地址无关的代码,所以可以跟代码段等一起合并成同一个可读可执行的“ Segment”被装载入内存</p>
</li>
</ul>
<h3 id="7-5-动态链接相关结构"><a href="#7-5-动态链接相关结构" class="headerlink" title="7.5 动态链接相关结构"></a>7.5 动态链接相关结构</h3><ul>
<li>首先操作系统会读取可执行文件的头部检查文件的合法性,然后从头部中的“ ProgramHeader”中读取每个“ Segment”的虚拟地址、文件地址和属性,并将它们映射到进程虚拟空间的相应位置</li>
<li><p>静态链接情况下,操作系统接着就可以把控制权转交给可执行文件的入口地址,然后程序开始执行</p>
</li>
<li><p>动态链接情况下,操作系统还不能在装载完可执行文件之后就把控制权交给可执行文件，还需要链接共享对象</p>
</li>
<li>在映射完可执行文件之后,操作系统会先启动个<strong>动态链接器( Dynamic Linker)</strong></li>
<li>在 Linux下,动态链接器ld.so实际上是一个共享对象,操作系统同样通过映射的方式将它加载到进程的地址空间</li>
<li>操作系统在加载完动态链接器之后,就将控制权交给动态链接器的入口地址(与可执行文件一样,共享对象也有入口地址)</li>
<li>动态链接器得到控制权之后,它开始执行一系列自身的初始化操作,然后根据当前的环境参数,开始对可执行文件进行动态链接工作</li>
<li>当所有动态链接工作完成以后,动态链接器会将控制权转交到可执行文件的入口地址,程序开始正式执行</li>
</ul>
<h4 id="7-5-1-“-interp”段"><a href="#7-5-1-“-interp”段" class="headerlink" title="7.5.1 “.interp”段"></a>7.5.1 “.interp”段</h4><ul>
<li>动态链接器的位置既不是由系统配置指定,也不是由环境参数决定,而是由ELF可执行文件决定</li>
<li>动态链接的ELF可执行文件中,有一个专门的段叫做<code>.interp(interpreter解释器)</code>段,里面存储了动态链接器的路径。</li>
<li><p>查看<code>.interp</code>的内容</p>
<p><img src="/img/7-.interp内容.png" alt></p>
</li>
<li><p>在 Linux的系统中, lib/d-linux.so.2通常是一个软链接，比如在我的机器上,它指向/lib/ld-2.6.1.so,这个才是真正的动态链接器。</p>
</li>
<li>Linux中,操作系统在对可执行文件的进行加载的时候,会先查询<code>.interp</code>段保存的路径，然后去加载动态链接器。</li>
</ul>
<h4 id="7-5-2-“-dynamic”段"><a href="#7-5-2-“-dynamic”段" class="headerlink" title="7.5.2 “.dynamic”段"></a>7.5.2 “.dynamic”段</h4><p><code>.dynamic</code>是动态链接最重要的段。保存了动态链接所需要的基本信息</p>
<ol>
<li>依赖于哪些共享对象</li>
<li>动态链接符号表的位置</li>
<li>动态链接重定位表的位置</li>
<li>共享对象初始化代码的地址等</li>
</ol>
<ul>
<li><p><code>.dynamic</code>是Elf32_Dyn为元素的数组, Elf32_Dyn由一个类型值，和一个附加的数值或指针组成</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  Elf32_Sword d_tag;</span><br><span class="line">  <span class="keyword">union</span> &#123;</span><br><span class="line">    Elf32_Word d_val;</span><br><span class="line">    Elf32_Addr d_ptr;</span><br><span class="line">  &#125;  d_un;</span><br><span class="line">&#125; Elf32_Dyn;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对应字段的含义</p>
<p><img src="/img/7-.dynamic结构对应的含义.png" alt></p>
</li>
<li><p>使用readelf工具查看<code>.dynamic段的内容</code></p>
<p><img src="/img/7-dynamic结构0.png" alt></p>
<p><img src="/img/7-dynamic结构1.png" alt></p>
</li>
<li><p>查看主模块或共享库依赖了哪些模块</p>
<p><img src="/img/7-查看主模块或共享库所依赖的模块.png" alt></p>
</li>
</ul>
<h4 id="7-5-3-动态符号表"><a href="#7-5-3-动态符号表" class="headerlink" title="7.5.3 动态符号表"></a>7.5.3 动态符号表</h4><p>Program1程序依赖于Lib.so的 foobar()函数。foobar()是Program1的导入函数(Import Function)，foobar()是Lib.so的导出函数(Export Function)。ELF专门有一个叫做动态符号表( Dynamic Symbol Table)的段用来保存这些导入导出关系,段名叫<code>.dynsym(Dynamic Symbol)</code>。与<code>.symtab</code>不同的是,<code>.dynsym</code>只保存了与动态链接相关的符号, 对于那些模块内部的符号,比如模块私有变量则不保存。很多时候动态链接的模块同时拥有<code>.dynsym</code>和<code>. symtab</code>两个表<code>.symtab</code>中往往保存了所有符号,包括<code>.dynsym</code>中的符号。与<code>.symtab</code>类似,动态符号表也需要一些辅助的表,比如用于保存符号名的字符串表。静态链接时叫做符号字符串表<code>.strtab</code>( String Table),在这里就是动态符号字符串表<code>.dynstr( Dynamic String Table)</code>。动态链接下,我们需要在程序运行时查找符号,为了加快符号的查找过程,往往还有辅助的符号哈希表(<code>&quot;.hash&quot;</code>)。用readelf工具查看ELF文件的动态符号表及它的哈希表</p>
<p>  <img src="/img/7-动态链接符号表.png" alt></p>
<h4 id="7-5-4-动态链接重定位表"><a href="#7-5-4-动态链接重定位表" class="headerlink" title="7.5.4 动态链接重定位表"></a>7.5.4 动态链接重定位表</h4><p>对于使用了PIC技术的可执行文件或共享对象，代码段是不需要重定位。但是数据段需要重定位。静态链接中, <code>.rel.text</code>表示代码段的重定位。 <code>.rel.data</code>是数据段的重定位表。动态链接中, <code>.rel.dyn</code>是对数据引用的修正，它修正的位置位于<code>.got</code>以及数据段。<code>rel.plt</code>是对函数引用的修正，它修正的位置位于<code>.got.plt</code>。</p>
<ul>
<li><p>查看动态链接文件的重定位表</p>
<p><img src="/img/7-动态链接的重定位表.png" alt></p>
<p><img src="/img/7-Lib.so的.got.plt结构.png" alt></p>
<ol>
<li>上面可以看到R_386_RELATIVE, R_386_GLOB_DAT和R_386_JUMP_SLOT这三种重定位入口类型</li>
<li>R_386_GLOB_DAT和R_386_JUMP_SLOT表示被修正的位置只需要直接填入符号的地址即可。以printf为例, printf的偏移为0x00005d8。 当动态链接器需要进行重定位时，它会查找printf的地址。假设链接器在全局符号表里面找到“ printf”的地址为0x08801234。那么链接器就会将这个地址填入到“got.plt”中的偏移为0x00005d8的位置中去,从而实现了地址的重定位。</li>
<li><code>.got.plt</code>的前三项被系统占据，从第四项开始存放导入函数的地址。</li>
<li>R386_RELATIVE类型的重定位入口,这种类型的重定位实际上就是基址重置( Rebasing)</li>
<li>another something xxxx</li>
</ol>
</li>
</ul>
<h4 id="7-5-5-动态链接时进程堆栈初始化信息"><a href="#7-5-5-动态链接时进程堆栈初始化信息" class="headerlink" title="7.5.5 动态链接时进程堆栈初始化信息"></a>7.5.5 动态链接时进程堆栈初始化信息</h4><ul>
<li>进程初始化的时候,堆栈里面保存了关于进程执行环境和命令行参数等信息</li>
<li>堆栈里面还保存了动态链接器所需要的一些<code>辅助信息数组( Auxiliary Vector)</code></li>
<li><p>辅助信息的格式是一个结构数组,它的结构被定义在”elf.h”</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">uint_32_t</span> a_type;</span><br><span class="line">  <span class="keyword">union</span> </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">uint_32_t</span> a_val;</span><br><span class="line">  &#125; a_un;</span><br><span class="line">&#125; Elf32_auxv_t</span><br></pre></td></tr></table></figure>
<ol>
<li><p>事实上这个unon没什么用,只是历史遗留而已,可以当作不存在</p>
</li>
<li><p>字段的含义</p>
<p><img src="/img/7-动态链接器辅助信息0.png" alt></p>
<p><img src="/img/7-动态链接器辅助信息1.png" alt></p>
</li>
</ol>
</li>
</ul>
<h3 id="7-6-动态链接的步骤和实现"><a href="#7-6-动态链接的步骤和实现" class="headerlink" title="7.6 动态链接的步骤和实现"></a>7.6 动态链接的步骤和实现</h3><ul>
<li>基本分为3步<ol>
<li>启动动态连接器本身</li>
<li>装载所有需要的共享对象</li>
<li>重定位和初始化</li>
</ol>
</li>
</ul>
<h4 id="7-6-1-动态链接器自举-bootstrap-gt-引导程序"><a href="#7-6-1-动态链接器自举-bootstrap-gt-引导程序" class="headerlink" title="7.6.1 动态链接器自举(bootstrap-&gt;引导程序)"></a>7.6.1 动态链接器自举(bootstrap-&gt;引导程序)</h4><ul>
<li>对于普通共享对象文件来说,它的重定位工作由动态链接器来完成;它也可以依赖于其他共亨对象,其中的被依赖的共享对象由动态链接器负责链接和装载</li>
<li>动态链接器本身也是一个共享对象, 它不可以依赖于其他任何共享对象。 其次是动态链接器本身所需要的全局和静态变量的重定位工作由它本身完成</li>
<li>动态链接器必须在启动时有段非常精巧的代码可以完成这项艰巨的工作而同时又不能用到全局和静态变量。这种具有一定限制条件的启动代码往往被称为<code>自举( Bootstrap)。</code></li>
<li>动态链接器入口地址即是自举代码的入口,当操作系统将进程控制杈交给动态链接器时,动态链接器的自举代码即开始执行.<ol>
<li>自举代码首先会找到它自己的GOT</li>
<li>GOT的第一个入口保存的即是“ .dynamic”段的偏移地址,由此找到了动态连接器本身的”.dynamic”段。</li>
<li>通过“.dynamic”中的信息,自举代码便可以获得动态链接器本身的重定位表和符号表等,从而得到动态链接器本身的重定位入口,先将它们全部重定位。</li>
<li>从这一步开始,动态链接器代码中才可以开始使用自己的全局变量和静态变量</li>
</ol>
</li>
<li>在动态链接器的自举代码中,除了不可以使用全局变量和静态变量之外,甚至不能调用函数,即动态链接器本身的函数也不能调用。<ol>
<li>使用PIC模式编译的共享对象,对于模块内部的函数调用也是采用跟模块外部函数调用一样的方式,即使用 GOT/PLT的方式</li>
<li>在GOT/PLT没有被重定位之前,自举代码不可以使用任何全局变量,也不可以调用函数</li>
</ol>
</li>
</ul>
<h4 id="7-6-2-装载共享对象"><a href="#7-6-2-装载共享对象" class="headerlink" title="7.6.2 装载共享对象"></a>7.6.2 装载共享对象</h4><ul>
<li>完成基本自举以后,动态链接器将可执行文件和链接器本身的符号表都合并到一个符号表当中,我们可以称它为全局符号表( Global Symbol Table)</li>
<li>然后通过可执行文件中的<code>.dynamic</code>查看可执行文件依赖的共享库。</li>
<li>将所有依赖的所有共享对象名字装载到一个集合中。</li>
<li>然后开始遍历去装载共享对象，当装载共享对象的时候，查看ELF文件头和<code>.dynamic</code>段， 然后将它相应的代码段和数据段映射到地址空间。查看要装载共享对象的<code>.dynamic</code>看其是否还依赖其他共享对象。如果依赖，则把依赖的共享对象的名字继续放在集合中。如此循环直到所有的共享对象都装载到集合中。</li>
<li>一般将这种依赖关系当做一个图，动态链接器一般采用广度优先遍历进行装载</li>
<li><p>当一个新的共享对象被装载时，它的符号表会被合并到全局符号表中。所以装载完之后，全局符号表里面包含进程中所有的动态链接所需的符号。</p>
</li>
<li><p>当一个符号需要被加入全局符号表时，如果相同的符号名已经存在，那么后面加入的符号将被忽略。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a1.so定义了一个a函数</span><br><span class="line">a2.so定义了一个a函数(两个a函数实现不同)</span><br><span class="line">b1.so的b1函数调用了a1.so的a函数</span><br><span class="line">b2.so的b2函数调用了a2.so的a函数</span><br><span class="line"></span><br><span class="line">当在main函数中，调用b1(), b2()时，全部执行的是a1.so中定义的a函数</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="7-6-3-重定位和初始化"><a href="#7-6-3-重定位和初始化" class="headerlink" title="7.6.3 重定位和初始化"></a>7.6.3 重定位和初始化</h4><p>重定位：上面步骤完成后，链接器开始重新遍历可执行文件和每个共享对象的重定位表，将他们的GOT/PLT中的每个需要重定位的位置进行修正。</p>
<p>初始化：</p>
<ol>
<li>如果某个共享对象有<code>.init</code>段，那么动态链接器会执行<code>.init</code>段中代码，实现共享对象的初始化</li>
<li>进程退出的时候对执行共享对象中的<code>.finit</code>段中的代码</li>
<li>动态链接器不执行可执行文件中的<code>.init</code>段中代码。</li>
<li>可执行文件中的<code>.init</code>和<code>.finit</code>由程序初始化部分代码负责执行</li>
</ol>
<ul>
<li>转移控制权：完成了共享对象的重定位和初始化之后，动态链接器将控制权转移给程序的入口。</li>
</ul>
<h4 id="7-6-4-Linux动态链接器实现"><a href="#7-6-4-Linux动态链接器实现" class="headerlink" title="7.6.4 Linux动态链接器实现"></a>7.6.4 Linux动态链接器实现</h4><ul>
<li><p>Linux动态链接器本身是一个共享对象,它的路径是<code>/lib/ld-linux.so.2</code>,这实际上是个软链接,它指向<code>/lib/d-x.y.z.so,</code>这个才是真正的动态连接器文件。</p>
</li>
<li><p>动态链接器是个非常特殊的共享对象,它不仅是个共享对象,还是个可执行的程序</p>
</li>
<li><p>动态链接器本身是动态链接的还是静态链接的？</p>
</li>
</ul>
<p>动态链接器本身应该是静态链接的,它不能依赖于其他共享对象,动态链接器本身是用来帮助其他ELF文件解决共享对象依赖问题的,如果它也依赖于其他共享对象,那么谁来帮它解决依赖问题?所以它本身必须不依赖于其他共享对象。</p>
<p>  这一点可以使用ldd来判断<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ldd /lib/ld-linux.so.2</span><br><span class="line">  statically linked</span><br></pre></td></tr></table></figure></p>
<ul>
<li>动态链接器本身必须是PIC的吗?</li>
</ul>
<p>是不是PIC对于动态链接器来说并不关键,动态链接器可以是PIC的也可以不是,但往往使用PIC会更加简单一些。一方面,如果不是PIC的话,会使得代码段无法共享,浪费内存;另一方面也会使ld.o本身初始化更加复杂,因为自举时还需要对代码段进行重定位。</p>
<p>  实际上的 Id-linux.so.2是PIC的</p>
<ul>
<li><p>动态链接器可以被当作可执行文件运行,那么的装载地址应该是多少?</p>
<p>ld.so的装载地址跟一般的共享对象没区别,即为0x00000这个装载地址是一个无效的装载地址,作为一个共亨库,内核在装载它时会为其选择一个合适的装载地址</p>
</li>
</ul>
<h3 id="7-7-显式运行时链接"><a href="#7-7-显式运行时链接" class="headerlink" title="7.7 显式运行时链接"></a>7.7 显式运行时链接</h3><ul>
<li>显式运行时链接( Explicit Run- time Linking),有时候也叫做运行时加载 ，让程序自己在运行时控制加载指定的模块,并且可以在不需要该模块时将其卸载。</li>
<li>动态装载库( Dynamic Loading Library): 动态链接器可以在运行时将共享模块装载进内存并且可以进行重定位等操作。 </li>
<li>动态装载库实质上就是共享对象，只是开发者使用的角度不同</li>
<li><p>两者的区别在于</p>
<ul>
<li>共享对象是由动态链接器在程序启动之前负责装载和链接的,这一系列步骤都由动态连接器自动完成,对于程序本身是透明的</li>
<li>动态库的装载则是通过一系列由动态链接器提供的API,共有4个函数<ol>
<li>打开动态库( dlopen)</li>
<li>查找符号( dlsym)</li>
<li>错误处理( dlerror)</li>
<li>关闭动态库( dlclose)</li>
</ol>
</li>
</ul>
</li>
<li><p>运行时加载可以用来实现一些诸如插件、驱动等功能，当程序需要用到某个插件或者驱动的时候,才将相应的模块装载进来,而不需要从程序一启动就加载</p>
</li>
</ul>
<h4 id="7-7-1-dlopen"><a href="#7-7-1-dlopen" class="headerlink" title="7.7.1 dlopen()"></a>7.7.1 dlopen()</h4><ul>
<li><code>dlopen()</code>函数用来打开一个动态库,并将其加载到进程的地址空间,完成初始化过程</li>
<li><p>其c原型定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void * dlopen(const char *filename, int flag )</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>第一个参数是被加载动态库的路径<ul>
<li>如果这个路径是绝对路径(以“/”开始的路径),则该函数将会尝试直接打开该动态库</li>
<li>如果是相对路径,那么 dlopen会尝试在以一定的顺序去查找该动态库文件<ul>
<li>查找有环境变量 LD_LIBRARY_PATH指定的一系列目录</li>
<li>查找由/etc/ld.so.cache里面所指定的共享库路径</li>
<li>/lib、/usr/lib  注意:这个查找顺序与旧的aout装载器的顺序刚好相反,旧的aout的装载器在装载共享库的时候会先查找/usr/lib,然后是/lib</li>
</ul>
</li>
<li>如果我们将 filename这个参数设置为0,那么 dlopen返回的将是全局符号表的句柄,并且可以执行它们</li>
</ul>
</li>
</ul>
<p>全局符号表包括了</p>
<ol>
<li>程序的可执行文件本身</li>
<li>被动态链接器加载到进程中的所有共享模块</li>
<li>在运行时通过 dlopen打开并且使用了 RTLD_GLOBAL方式的模块中的符号</li>
</ol>
<ul>
<li><p>第二个参数fag表示函数符号的解析方式</p>
<ul>
<li>RTLD_LAZY表示使用延迟绑定,当函数第一次被用到时才进行绑定,即PLT机制</li>
<li>RTLD_NOW表示当模块被加载时即完成所有的函数绑定工作,如果有任何未定义的符号引用的绑定工作没法完成,那么 dlopen返回错误</li>
<li>RTLD_GLOBAL跟上面的两者中任意一个一起使用(通过“或”操作),它表示将被加载的模块的全局符号合并到进程的全局符号表中,使得以后加载的模块可以使用这些符号</li>
<li>调试程序的时候我们可以使用 RTLD_NOW作为加载参数,因为如果模块加载时有任何符号未被绑定的话,我们可以使用 dlerroro立即捕获到相应的错误信息</li>
<li>如果使用 RTLD_LAZY的话,这种符号未绑定的错误会在加载后发生,则难以捕获</li>
<li>当然使用 RTLD_NOW会导致加载动态库的速度变慢</li>
</ul>
</li>
<li><p>dlopen的返回值是被加载的模块的句柄</p>
<ul>
<li>这个句柄在后面使用dsym或者 dlclose时需要用到。</li>
<li>如果加载模块失败,则返回NUL。</li>
<li>如果模块已经通过 dlopen被加载过了,那么返回的是同一个句柄</li>
<li>如果被加载的模块之间有依赖关系,那么需要先手动加载被依赖的模块。比如模块A依赖与模块B,那么程序员需要手工加载被依赖的模块,比如先加载B,再加载A</li>
</ul>
</li>
<li><p>dlopen的加载过程基本跟动态链接器一致,在完成装载、映射和重定位以后,就会执行“.init”段的</p>
</li>
</ul>
<h4 id="7-7-2-dlsym"><a href="#7-7-2-dlsym" class="headerlink" title="7.7.2 dlsym()"></a>7.7.2 dlsym()</h4><p>dlsym函数基本上是运行时装载的核心部分,我们可以通过这个函数找到所需要的符号。它的定义如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void * dlsym(void *handle, char *symbol)</span><br></pre></td></tr></table></figure></p>
<ul>
<li>第一个参数是由 dlopen返回的动态库的句柄</li>
<li>第二个参数即所要查找的符号的名字,一个以“\0”结尾的C字符串</li>
<li>dlsym返回的值对于不同类型的符号,意义是不同的<ul>
<li>如果查找的符号是个函数,如果找到返回函数的地址，否则返回NULL</li>
<li>如果查找的符号是个变量,如果找到返回变量的地址，否则返回NULL</li>
<li>如果查找的符号是个常量,如果找到返回的是该常量的值,  否则返回NULL</li>
</ul>
</li>
</ul>
<p>如果常量的值刚好是NULL或者0呢,我们如何判断dlsym是否找到了该符号呢?</p>
<ul>
<li>如果符号找到了，dlerror返回为NULL</li>
<li>如果符号没有找到，dlerror返回为错误信息</li>
</ul>
<blockquote>
<p>注意</p>
<ol>
<li>符号不仅仅是函数和变量,有时还是常量,比如表示编译单元文件名的符号等,这一般由编译器和链接器产生,而且对外不可见, 但它们的确存在于模块的符号表中</li>
<li>dlsym是可以查找到这些符号的</li>
<li>我们也可以通过”objdump  -t”来查看符号表,常量在符号表里面的类型是<code>*ABS*</code></li>
</ol>
</blockquote>
<ul>
<li>当多个共享模块的符号名冲突时，先装入的符号优先,我们把这种优先级方式称为<code>装载序列(LoadOrdering)</code></li>
<li>不论是动态链接器装载共享对象，还是dlopen装载动态库，它们进行符号的解析和重定位时都是采用的是<code>装载序列</code></li>
<li><p>dlsym对符号的查找优先级分两种类</p>
<ol>
<li>第一种情况: 如果我们是在全局符号表中进行符号查找,即 dlopen()时,参数 filename为NULL,那么由于全局符号表使用的装载序列,所以 dlsym使用的也是装载序列</li>
<li><p>第二种情况是如果我们是对某个通过 dlopen打开的共享对象进行符号查找的话,那么采用的是一种叫做依赖序列( Dependency Ordering)的优先级</p>
<p>依赖序列( Dependency Ordering)是以被dlopen打开的那个共享对象为根节点,对它所有依赖的共享对象进行广度优先遍历,直到找到符号为止</p>
</li>
</ol>
</li>
</ul>
<h4 id="7-7-3-dlerror"><a href="#7-7-3-dlerror" class="headerlink" title="7.7.3 dlerror()"></a>7.7.3 dlerror()</h4><p>每次我们调用 dlopen、 dlsym或 dlclose以后,我们都可以调用 dlerror函数来判断上一次调用是否成功。dlerror的返回值类型是char*,如果返回NUL,则表示上一次调用成功;如果不是,则返回相应的错误消息</p>
<h4 id="7-7-4-dlclose"><a href="#7-7-4-dlclose" class="headerlink" title="7.7.4 dlclose()"></a>7.7.4 dlclose()</h4><p>dlclose的作用跟 dlopen刚好相反,它的作用是将一个已经加载的模块卸载。系统会维持一个加载引用计数器,每次使用dlopen加载某模块时,相应的计数器加一;每次使用dlcloseo卸载某模块时,相应计数器减一。 只有当计数器值减到0时,模块才被真正地卸载掉。</p>
<p>卸载的过程跟加载刚好相反,先执行<code>. finit</code>段的代码,然后将相应的符号从符号表中去除,取消进程空间跟模块的映射关系,然后关闭模块文件</p>
<p>下面的例子将数学库模块用运行时的方法加载到内存中，然后获取sin()符号地址，使用sin()<br>  <img src="/img/7-dl四个函数的简单应用.png" alt></p>
<p>-ldl 表示使用了DL库(Dynamical Loading)，它位于/lib/libdl.so.2</p>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ul>
<li>为什么要动态链接?<ul>
<li>如果使用静态链接，那些公有的函数在每个程序中都存在一份，极大的浪费空间</li>
<li>使用动态链接，那些公有的库在内存和磁盘上只有一份，极大节省了空间</li>
</ul>
</li>
<li><p>如果某个模块(可执行文件或动态库)使用了某个动态库中的函数或变量?</p>
<ul>
<li>链接器进行链接时，发现某个模块引用的外部符号(函数或变量)，被定义在某个动态库的符号表中，则把这个外部符号标记为动态链接的符号，在此时不对该符号进行重定位。而将重定位的过程放到装载阶段去完成。</li>
</ul>
</li>
<li><p>装载时重定位</p>
<ul>
<li>当动态库被装载时，该动态库的地址确定，此时其定义的符号和函数的地址也确定了，因此可以对引用该动态库符号的模块进行重定位了</li>
</ul>
</li>
<li>地址无关代码(PIC)<ul>
<li>把共享模块指令部分那些需要被修改的部分分离出来,跟数据部分放在一起,这样指令部分就可以保持不变,而数据部分可以在每个进程中拥有一个副本</li>
</ul>
</li>
<li>延迟绑定<ul>
<li>当函数第一次被用到时才进行绑定(符号查找，重定位等)，如果没有用到则不进行绑定</li>
</ul>
</li>
<li><p>动态符号表</p>
<ul>
<li>.dynsym(Dynamic Symbol)</li>
<li>只保存了与动态链接相关的符号</li>
</ul>
</li>
<li><p>动态链接重定位表</p>
<ul>
<li>对于使⽤了PIC技术的可执⾏⽂件或共享对象，代码段是不需要重定位。但是数据段需要重定位</li>
</ul>
</li>
<li><p>动态链接加载的过程</p>
<ol>
<li>动态连接器本身<ol>
<li>操作系统先加载可执行文件</li>
<li>然后在映射完可执行文件之后，操作系统启动<code>动态链接器( Dynamic Linker)</code></li>
<li><code>动态链接器( Dynamic Linker)</code>通过自举的方式加载自身。</li>
<li>完成基本⾃举以后,动态链接器将<strong>可执⾏⽂件和链接器本身的符号表</strong>都合并到⼀个符号表当中,我们<br>可以称它为<strong>全局符号表( Global Symbol Table)</strong>。 同时把控制权交给动态链接器</li>
</ol>
</li>
<li>装载所有需要的共享对象<ol>
<li>然后通过可执⾏⽂件中的 .dynamic 查看可执⾏⽂件依赖的共享库</li>
<li>遍历加载共享库，同时查看要装载共享对象的<code>.dynamic</code>看其是否还依赖其他<br>共享对象, 直到所有的共享库都被加载(<strong>采⽤⼴度优先遍历进⾏装载</strong>)</li>
<li>当⼀个新的共享对象被装载时，<strong>它的符号表会被合并到全局符号表中</strong>。所以装载完之后，全局符号<br>表⾥⾯包含进程中所有的动态链接所需的符号。</li>
</ol>
</li>
<li>重定位<ol>
<li>链接器开始重新遍历可执⾏⽂件和每个共享对象的重定位表,进行地址的修正。</li>
<li>然后将控制权转交给程序入口</li>
</ol>
</li>
</ol>
</li>
<li><p>显式运⾏时链接</p>
<ul>
<li>程序⾃⼰在运⾏时控制加载指定的模块(动态库),并且可以在不需要该模块时将其卸载</li>
<li>与动态链接器加载动态库的区别是:<ol>
<li>动态链接器是在程序真正开始执行前，自动进行动态库的装载和链接</li>
<li>程序运行时加载是指，程序通过一些API来装载，链接，使用动态库<ul>
<li>打开动态库( dlopen)</li>
<li>查找符号( dlsym)</li>
<li>错误处理( dlerror)</li>
<li>关闭动态库( dlclose)</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/积累/" rel="tag"># 积累</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/09/04/程序员的自我修养 笔记1/" rel="next" title="程序员的自我修养笔记1">
                <i class="fa fa-chevron-left"></i> 程序员的自我修养笔记1
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/09/04/程序员的自我修养 笔记3/" rel="prev" title="程序员的自我修养 笔记3">
                程序员的自我修养 笔记3 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/header.jpg" alt="Hao Yu">
            
              <p class="site-author-name" itemprop="name">Hao Yu</p>
              <p class="site-description motion-element" itemprop="description">Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author</p>
          </div>
          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">250</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>
        	<audio controls="controls" loop="loop" preload="auto" src="/resource/xiaomeihao.mp3">
	        </audio>
	

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yuhao0102" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:yuh18@mails.tsinghua.edu.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#静态链接"><span class="nav-number">1.</span> <span class="nav-text">静态链接</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-空间与地址分配"><span class="nav-number">1.1.</span> <span class="nav-text">4.1 空间与地址分配</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-1-按序叠加"><span class="nav-number">1.1.1.</span> <span class="nav-text">4.1.1 按序叠加</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-2-相似段合并"><span class="nav-number">1.1.2.</span> <span class="nav-text">4.1.2 相似段合并</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-3-符号地址的确定"><span class="nav-number">1.1.3.</span> <span class="nav-text">4.1.3 符号地址的确定</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-符号解析和重定位"><span class="nav-number">1.2.</span> <span class="nav-text">4.2 符号解析和重定位</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-1-重定位"><span class="nav-number">1.2.1.</span> <span class="nav-text">4.2.1 重定位</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#4-2-1-1-重定位前"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">4.2.1.1 重定位前</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-2-1-2-重定位后"><span class="nav-number">1.2.1.2.</span> <span class="nav-text">4.2.1.2 重定位后</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-2-重定位表"><span class="nav-number">1.2.2.</span> <span class="nav-text">4.2.2 重定位表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-3-符号解析"><span class="nav-number">1.2.3.</span> <span class="nav-text">4.2.3 符号解析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-4-指令修正方式"><span class="nav-number">1.2.4.</span> <span class="nav-text">4.2.4 指令修正方式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-COMMON块"><span class="nav-number">1.3.</span> <span class="nav-text">4.3 COMMON块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-C-相关问题"><span class="nav-number">1.4.</span> <span class="nav-text">4.4 C++相关问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-1-重复代码消除"><span class="nav-number">1.4.1.</span> <span class="nav-text">4.4.1 重复代码消除</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#4-1-1-1函数级别链接"><span class="nav-number">1.4.1.1.</span> <span class="nav-text">4.1.1.1函数级别链接</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-2-全局构造与析构"><span class="nav-number">1.4.2.</span> <span class="nav-text">4.4.2 全局构造与析构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-3-C-与ABI"><span class="nav-number">1.4.3.</span> <span class="nav-text">4.4.3 C++与ABI</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-静态链接"><span class="nav-number">1.5.</span> <span class="nav-text">4.5 静态链接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-6-链接过程控制"><span class="nav-number">1.6.</span> <span class="nav-text">4.6  链接过程控制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-6-1-链接控制脚本"><span class="nav-number">1.6.1.</span> <span class="nav-text">4.6.1  链接控制脚本</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-7-BFD库"><span class="nav-number">1.7.</span> <span class="nav-text">4.7  BFD库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结"><span class="nav-number">1.8.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#可执行文件的装载与进程"><span class="nav-number">2.</span> <span class="nav-text">可执行文件的装载与进程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-进程虚拟地址空间"><span class="nav-number">2.1.</span> <span class="nav-text">6.1 进程虚拟地址空间</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#6-1-1-PAE"><span class="nav-number">2.1.0.1.</span> <span class="nav-text">6.1.1 PAE</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-装载方式"><span class="nav-number">2.2.</span> <span class="nav-text">6.2 装载方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-1-覆盖载入"><span class="nav-number">2.2.1.</span> <span class="nav-text">6.2.1 覆盖载入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-2-页映射"><span class="nav-number">2.2.2.</span> <span class="nav-text">6.2.2 页映射</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-从操作系统角度看可执行文件的装载"><span class="nav-number">2.3.</span> <span class="nav-text">6.3 从操作系统角度看可执行文件的装载</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3-1-进程的建立"><span class="nav-number">2.3.1.</span> <span class="nav-text">6.3.1 进程的建立</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3-2-页错误"><span class="nav-number">2.3.2.</span> <span class="nav-text">6.3.2 页错误</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-进程虚拟空间分布"><span class="nav-number">2.4.</span> <span class="nav-text">6.4 进程虚拟空间分布</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-4-1-ELF文件链接视图和执行视图"><span class="nav-number">2.4.1.</span> <span class="nav-text">6.4.1 ELF文件链接视图和执行视图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-4-2-堆和栈"><span class="nav-number">2.4.2.</span> <span class="nav-text">6.4.2 堆和栈</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-4-3-堆的最大申请数量"><span class="nav-number">2.4.3.</span> <span class="nav-text">6.4.3  堆的最大申请数量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-4-4-段地址对齐"><span class="nav-number">2.4.4.</span> <span class="nav-text">6.4.4 段地址对齐</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-4-5-进程栈初始化"><span class="nav-number">2.4.5.</span> <span class="nav-text">6.4.5 进程栈初始化</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-5-Linux-内核装载ELF过程"><span class="nav-number">2.5.</span> <span class="nav-text">6.5 Linux 内核装载ELF过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结-1"><span class="nav-number">2.6.</span> <span class="nav-text">总结</span></a></li></ol><li class="nav-item nav-level-2"><a class="nav-link" href="#动态链接"><span class="nav-number">3.</span> <span class="nav-text">动态链接</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-为什么要动态链接"><span class="nav-number">3.1.</span> <span class="nav-text">7.1 为什么要动态链接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-简单的动态链接例子"><span class="nav-number">3.2.</span> <span class="nav-text">7.2 简单的动态链接例子</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#7-2-1-动态链接程序运行时地址空间分布"><span class="nav-number">3.2.1.</span> <span class="nav-text">7.2.1 动态链接程序运行时地址空间分布</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-地址无关代码"><span class="nav-number">3.3.</span> <span class="nav-text">7.3 地址无关代码</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#7-3-1-固定装载地址的困扰"><span class="nav-number">3.3.1.</span> <span class="nav-text">7.3.1 固定装载地址的困扰</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-3-2-装载时重定位"><span class="nav-number">3.3.2.</span> <span class="nav-text">7.3.2 装载时重定位</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-3-3-地址无关代码"><span class="nav-number">3.3.3.</span> <span class="nav-text">7.3.3 地址无关代码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-3-4-共享模块的全局变量问题"><span class="nav-number">3.3.4.</span> <span class="nav-text">7.3.4 共享模块的全局变量问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-3-5-数据段地址无关性"><span class="nav-number">3.3.5.</span> <span class="nav-text">7.3.5 数据段地址无关性</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-4-延迟绑定"><span class="nav-number">3.4.</span> <span class="nav-text">7.4 延迟绑定</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-5-动态链接相关结构"><span class="nav-number">3.5.</span> <span class="nav-text">7.5 动态链接相关结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#7-5-1-“-interp”段"><span class="nav-number">3.5.1.</span> <span class="nav-text">7.5.1 “.interp”段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-5-2-“-dynamic”段"><span class="nav-number">3.5.2.</span> <span class="nav-text">7.5.2 “.dynamic”段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-5-3-动态符号表"><span class="nav-number">3.5.3.</span> <span class="nav-text">7.5.3 动态符号表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-5-4-动态链接重定位表"><span class="nav-number">3.5.4.</span> <span class="nav-text">7.5.4 动态链接重定位表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-5-5-动态链接时进程堆栈初始化信息"><span class="nav-number">3.5.5.</span> <span class="nav-text">7.5.5 动态链接时进程堆栈初始化信息</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-6-动态链接的步骤和实现"><span class="nav-number">3.6.</span> <span class="nav-text">7.6 动态链接的步骤和实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#7-6-1-动态链接器自举-bootstrap-gt-引导程序"><span class="nav-number">3.6.1.</span> <span class="nav-text">7.6.1 动态链接器自举(bootstrap-&gt;引导程序)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-6-2-装载共享对象"><span class="nav-number">3.6.2.</span> <span class="nav-text">7.6.2 装载共享对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-6-3-重定位和初始化"><span class="nav-number">3.6.3.</span> <span class="nav-text">7.6.3 重定位和初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-6-4-Linux动态链接器实现"><span class="nav-number">3.6.4.</span> <span class="nav-text">7.6.4 Linux动态链接器实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-7-显式运行时链接"><span class="nav-number">3.7.</span> <span class="nav-text">7.7 显式运行时链接</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#7-7-1-dlopen"><span class="nav-number">3.7.1.</span> <span class="nav-text">7.7.1 dlopen()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-7-2-dlsym"><span class="nav-number">3.7.2.</span> <span class="nav-text">7.7.2 dlsym()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-7-3-dlerror"><span class="nav-number">3.7.3.</span> <span class="nav-text">7.7.3 dlerror()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-7-4-dlclose"><span class="nav-number">3.7.4.</span> <span class="nav-text">7.7.4 dlclose()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结-2"><span class="nav-number">3.8.</span> <span class="nav-text">总结</span></a></li></ol></li></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>
  <div id="DvelopmentTarget">     
  </div>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart" aria-hidden="false"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>

  
</div>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_uv"> 
  本站访客数<span id="busuanzi_value_site_uv"></span>人次
</span>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  


  

  


  <script type="text/javascript" src="/js/src/love.js"></script>

</body>
</html>
