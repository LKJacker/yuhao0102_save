<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zn-ch">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-center-simple.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="C++,">










<meta name="description" content="使用C++11消除重复，提高代码质量type_traits——类型萃取type_traits的类型判断功能在编译期就可以检查出是否是正确的类型，以便能编写更安全的代码。 基本的type_traits在之前的C++中，在类中定义编译期常量的方法是：1234template&amp;lt;typename T&amp;gt;struct GetLeftSize &amp;#123;	static const int valu">
<meta name="keywords" content="C++">
<meta property="og:type" content="article">
<meta property="og:title" content="C++11特性笔记2——模板、内存泄漏">
<meta property="og:url" content="http://yoursite.com/2020/01/30/cpp11_2/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="使用C++11消除重复，提高代码质量type_traits——类型萃取type_traits的类型判断功能在编译期就可以检查出是否是正确的类型，以便能编写更安全的代码。 基本的type_traits在之前的C++中，在类中定义编译期常量的方法是：1234template&amp;lt;typename T&amp;gt;struct GetLeftSize &amp;#123;	static const int valu">
<meta property="og:locale" content="zn-ch">
<meta property="og:updated_time" content="2020-02-02T03:56:54.651Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="C++11特性笔记2——模板、内存泄漏">
<meta name="twitter:description" content="使用C++11消除重复，提高代码质量type_traits——类型萃取type_traits的类型判断功能在编译期就可以检查出是否是正确的类型，以便能编写更安全的代码。 基本的type_traits在之前的C++中，在类中定义编译期常量的方法是：1234template&amp;lt;typename T&amp;gt;struct GetLeftSize &amp;#123;	static const int valu">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/01/30/cpp11_2/">





  <title>C++11特性笔记2——模板、内存泄漏 | Hao Yu's blog</title>
  








 
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zn-ch">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hao Yu's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">The program monkey was eaten by the siege lion.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/resume.pdf" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-mybetterhalf">
          <a href="/mybetterhalf/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>
            
            mybetterhalf
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/30/cpp11_2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">C++11特性笔记2——模板、内存泄漏</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-01-30T20:13:00+08:00">
                2020-01-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="使用C-11消除重复，提高代码质量"><a href="#使用C-11消除重复，提高代码质量" class="headerlink" title="使用C++11消除重复，提高代码质量"></a>使用C++11消除重复，提高代码质量</h1><h2 id="type-traits——类型萃取"><a href="#type-traits——类型萃取" class="headerlink" title="type_traits——类型萃取"></a>type_traits——类型萃取</h2><p>type_traits的类型判断功能在编译期就可以检查出是否是正确的类型，以便能编写更安全的代码。</p>
<h3 id="基本的type-traits"><a href="#基本的type-traits" class="headerlink" title="基本的type_traits"></a>基本的type_traits</h3><p>在之前的C++中，在类中定义编译期常量的方法是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">struct GetLeftSize &#123;</span><br><span class="line">	static const int value = 1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在C++11中定义编译期常量，无需自己定义<code>static const int</code>或<code>enum</code>类型，只需要从<code>std::integral_constant</code>派生：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">struct GetLeftSize : std::integral_constant&lt;int, 1&gt; &#123; &#125;;</span><br></pre></td></tr></table></figure></p>
<p>将编译期常量包装为一个类型的type_trait——integral_constant：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T, T v&gt;</span><br><span class="line">struct integral_constant &#123;</span><br><span class="line">	static const T value = v;</span><br><span class="line">	typedef T value_type;</span><br><span class="line">	typedef integral_constant&lt;T, v&gt; type;</span><br><span class="line">	operator value_type() &#123; return value;&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>常见的用法是从integral_constant派生从而可以通过继承得到value</p>
<p>派生的type_traits可用于检查模板类型是否为某种类型，通过这些trait可以获取编译期检查的bool值结果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T&gt;</span><br><span class="line">struct is_integral;</span><br></pre></td></tr></table></figure></p>
<p>这是用来检查T是否为bool、char、int、long、long long等整型类型的，派生于std::integral_constant，因此可以通过std::is_xxx::value是否为true判断模板类型是否为目标类型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;type_traits&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; &quot;int&quot; &lt;&lt; std::is_const&lt;int&gt;::value &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;const int&quot; &lt;&lt; std::is_const&lt;const int&gt;::value &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;const int*&quot; &lt;&lt; std::is_const&lt;const int*&gt;::value &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;const int&amp;&quot; &lt;&lt; std::is_const&lt;const int&amp;&gt;::value &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>C++提供了判断类型之间的关系的traits：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T, class U&gt;</span><br><span class="line">struct is_same        // 判断两个类型是否相同 </span><br><span class="line">struct is_base_of     // 判断base类型是否是derived类型的积累</span><br><span class="line">struct is_convertible // 判断模板参数类型是否能转换</span><br></pre></td></tr></table></figure></p>
<p>C++提供了类型转换traits，包括对const的修改，引用的移除和添加，指针和数组的修改等。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">struct remove_const</span><br><span class="line">strcut add_const</span><br></pre></td></tr></table></figure></p>
<p>有时需要添加引用类型，比如从智能指针中获取对象的引用时<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;type_traits&gt;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt; </span><br><span class="line">struct Construct &#123;</span><br><span class="line">	typedef typename std::remove_reference&lt;T&gt;::type U;</span><br><span class="line">	Construct() : m_ptr(new U) &#123; &#125;</span><br><span class="line"></span><br><span class="line">	typename std::add_lvalue_reference&lt;U&gt;:: type</span><br><span class="line">	Get() const &#123; return *m_ptr.get(); &#125;</span><br><span class="line">private:</span><br><span class="line">	std::unique_ptr&lt;U&gt; m_ptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	Construct&lt;int&gt; c;</span><br><span class="line">	int a = c.Get();</span><br><span class="line">	cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>移除引用和cv符：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt; </span><br><span class="line">typename std::remove_cv&lt;typename std::remove_reference&lt;T&gt;::type&gt;::type*</span><br><span class="line">Create() &#123;</span><br><span class="line">	typedef typename std::remove_cv&lt;typename std::remove_reference&lt;T&gt;::type&gt;::type U;</span><br><span class="line">	return new U();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>先移除引用，再移除cv符，最终获得原始类型，这样可以解决问题，但是较为繁琐，用<code>decay</code>来简化代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt; </span><br><span class="line">typename std::decay&lt;T&gt;::type* Create() &#123;</span><br><span class="line">	typedef typename std::decay&lt;T&gt;::type U;</span><br><span class="line">	return new U();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于普通类型来说，<code>std::decay</code>是移除引用和cv符，大大简化了我们的书写。除了普通类型之外，<code>std::decay</code>还可以用于数组和函数，具体的转换规则如下：</p>
<ul>
<li>先移除T类型的引用，得到类型U，U定义为<code>remove_reference&lt;T&gt;::type</code></li>
<li>如果<code>is_array&lt;U&gt;::value</code>为true，修改类型type为<code>remove_extent&lt;U&gt;::type*</code></li>
<li>否则，如果<code>is_function&lt;U&gt;::value</code>为true，修改类型type为<code>add_pointer&lt;U&gt;::type</code></li>
<li>否则，修改类型type为<code>remove_cv&lt;U&gt;::type</code></li>
</ul>
<p>根据上面的规则，再对照用法示例，就能清楚地理解<code>std::decay</code>的含义了。下面是<code>std::decay</code>的基本用法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef std::decay&lt;int&gt;::type A; // int</span><br><span class="line">typedef std::decay&lt;int&amp;&gt;::type B; // int</span><br><span class="line">typedef std::decay&lt;int&amp;&amp;&gt;::type C; // int</span><br><span class="line">typedef std::decay&lt;const int&amp;&gt;::type D; // int</span><br><span class="line">typedef std::decay&lt;int[2]&gt;::type E; //int*</span><br><span class="line">typedef std::decay&lt;int(int)&gt;::type F: //int(*)(int)</span><br></pre></td></tr></table></figure></p>
<p>由于std::decay对于函数来说是添加指针，利用这一点，我们可以将函数变成函数指针类型，从而将函数指针变量保存起来，以便在后面延迟执行。</p>
<p><code>std::conditional</code>在编译期根据一个判断式选择两个类型中的一个，和条件表达式的语义类似，类似一个三元表达式。它的原型如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template&lt; bool B, class T, class F&gt;</span><br><span class="line">struct conditional</span><br></pre></td></tr></table></figure></p>
<p><code>std::conditional</code>模板参数中，如果B为true，则conditional::type为T，否则为F。<br><code>std::conditional</code>测试代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef std::conditional&lt;true, int, float&gt;::type A; // int</span><br><span class="line">typedef std::conditional&lt;false, int, float&gt;::type B, // float</span><br><span class="line"></span><br><span class="line">typedef std::conditional&lt;std::is_integral&lt;A&gt;::value, long, int&gt;:: type C; // long</span><br><span class="line">typedef std::conditional&lt;std::is_integral&lt;B&gt;::value, long, int&gt;:: type D; // int</span><br></pre></td></tr></table></figure></p>
<p>比较两个类型，输出较大的那个类型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typedef std::conditional&lt;(sizeof(long long) &gt; sizeof(long double)), long long, long double&gt;::type max_size_t;</span><br><span class="line">cout&lt;&lt;typeid(max_size_t).name()&lt;&lt;endl;</span><br></pre></td></tr></table></figure></p>
<p>将会输出： <code>long double</code><br>我们可以通过编译期的判断式来选择类型，这给我们动态选择类型提供了很大的灵活性，在后面经常和其他的C++11特性配合起来使用，是比较常用的特性之一。</p>
<p>有时要获取函数的返回类型是一件比较困难的事情，C++提供了std::result_of，用来在编译期获取一个可调用对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::result_of&lt;A(int)&gt;::type i = 4;</span><br></pre></td></tr></table></figure></p>
<p>等价于<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">decltype(std::declval&lt;A&gt;()(std::declval&lt;int&gt;()));</span><br></pre></td></tr></table></figure></p>
<p><code>std::result_of</code>原型如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class F, class ... ArgTypes&gt;</span><br><span class="line">class result_of&lt;F(ArgTypes...)&gt;;</span><br></pre></td></tr></table></figure></p>
<p>第一个模板参数为可调用对象的类型，第二个模板参数为参数的类型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int fn(int) &#123; return int(); &#125;</span><br><span class="line">typedef int(&amp;fn_ref)(int);</span><br><span class="line">typedef int(*fn_ref)(int);</span><br><span class="line">struct fn_class &#123; int operator()(int i) &#123;return i;&#125; &#125;;</span><br><span class="line"></span><br><span class="line">int main &#123;</span><br><span class="line">	typedef std::result_of&lt;decltype(fn)&amp;(int)&gt;:: type A; // int</span><br><span class="line">	typedef std::result_of&lt;fn_ref(int)&gt;::type B;         // int</span><br><span class="line">	typedef std::result_of&lt;fn_ptr(int)&gt;::type C;         // int</span><br><span class="line">	typedef std::result_of&lt;fn_class(int)&gt;::type D;       // int</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>std::result_of&lt;Fn(ArgTypes...)&gt;</code>要求Fn为一个可调用对象（不能是个函数类型，因为函数类型不是一个可调用对象，因此，下面这种方式是错误的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef std::result_of&lt;decltype(fn)(int)&gt;::type A;</span><br></pre></td></tr></table></figure></p>
<p>如果要对某个函数使用std::result_of，要先将函数转换为可调用对象。可以通过以下方式来获取函数返回类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef std::result_of&lt;decltype(fn)&amp;(int)&gt;::type A;</span><br><span class="line">typedef std::result_of&lt;decltype(fn)*(int)&gt;::type B;</span><br><span class="line">typedef std::result_of&lt;typename std::decay&lt;decltype(fn)&gt;::type(int)&gt;::type C;</span><br><span class="line">A B C 类型相同</span><br></pre></td></tr></table></figure></p>
<h2 id="可变参数模板"><a href="#可变参数模板" class="headerlink" title="可变参数模板"></a>可变参数模板</h2><p>声明可变参数模板时需要在typename或class后边带上’…’。</p>
<ul>
<li>声明一个参数包，这个参数包中可以包含0到任意个模板参数</li>
<li>在模板定义的右边，可以把参数包展开成一个一个独立的参数</li>
</ul>
<h3 id="可变参数模板函数"><a href="#可变参数模板函数" class="headerlink" title="可变参数模板函数"></a>可变参数模板函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class ... T&gt;</span><br><span class="line">void f(T... args) &#123;</span><br><span class="line">	cout &lt;&lt; sizeof...(args) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">f(); // 0</span><br><span class="line">f(1, 2); // 2</span><br><span class="line">f(1, 2.5, &quot;&quot;); // 3</span><br></pre></td></tr></table></figure>
<p>如果要用参数包中的参数，则一定要将参数包展开，有两种展开参数包的方法，一种是递归的模板函数展开，一种是通过逗号表达式和初始化列表方式展开。</p>
<p>通过递归函数展开参数包，需要提供一个参数包展开的函数和一个递归终止函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//递归终止函数</span><br><span class="line">void print() &#123;</span><br><span class="line">	cout &lt;&lt; &quot;Empty&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">//展开函数</span><br><span class="line">template &lt;class T, class... Args&gt;</span><br><span class="line">void print(T head, Args... rest) &#123;</span><br><span class="line">	cout &lt;&lt; &quot;parameter &quot; &lt;&lt; head &lt;&lt; endl;</span><br><span class="line">	print(rest...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	print(1,2,3,4);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">parameter 1</span><br><span class="line">parameter 2</span><br><span class="line">parameter 3</span><br><span class="line">parameter 4</span><br><span class="line">Empty</span><br></pre></td></tr></table></figure></p>
<p>递归终止函数可以写成如下形式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T, typename T1, typename T2&gt;</span><br><span class="line">void print(T t, T1 t1) &#123;</span><br><span class="line">	cout &lt;&lt; t &lt;&lt; &quot; &quot; &lt;&lt; t1 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;typename T, typename T1, typename T2&gt;</span><br><span class="line">void print(T t, T1 t1, T2 t2) &#123;</span><br><span class="line">	cout &lt;&lt; t &lt;&lt; &quot; &quot; &lt;&lt; t1 &lt;&lt; &quot; &quot; &lt;&lt; t2 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>另一种方法是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class T&gt; </span><br><span class="line">void printarg(T t) &#123;</span><br><span class="line">	cout &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">template &lt;class ...Args&gt;</span><br><span class="line">void expand(Args... args) &#123;</span><br><span class="line">	int arr[] = &#123; (printarg(args), 0)...&#125;</span><br><span class="line">&#125;</span><br><span class="line">expand(1,2,3,4);</span><br></pre></td></tr></table></figure></p>
<p>这种就地展开参数包的方式关键是<strong>逗号表达式</strong>，它会按顺序执行逗号前边的表达式。<code>expand()</code>函数中的<code>(printarg(args), 0)</code>，先执行<code>printarg(args)</code>，再得到逗号表达式的结果0。同时用到了初始化列表，通过初始化列表来初始化一个变长数组。<code>{(printargs(args), 0)...}</code>将会展开成<code>((printargs(arg1), 0), (printargs(arg2), 0), (printargs(arg3), 0), etc...)</code>，最终会创建一个所有元素为0的数组<code>int arr[sizeof(Args)]</code>，会先执行表达式前面的printarg打印出参数。</p>
<h3 id="可变参数模板类"><a href="#可变参数模板类" class="headerlink" title="可变参数模板类"></a>可变参数模板类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class... Types&gt;</span><br><span class="line">class tuple;</span><br></pre></td></tr></table></figure>
<p>这个可变参数模板类可以携带任意类型任意个数的模板参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::tuple&lt;int&gt; tp1 = std::make_tuple(1);</span><br><span class="line">std::tuple&lt;int, double&gt; tp2 = std::make_tuple(1, 2.5);</span><br><span class="line">std::tuple&lt;int, double, string&gt; tp3 = std::make_tuple(1, 2.5, &quot;hello&quot;);</span><br></pre></td></tr></table></figure></p>
<h4 id="模板递归和特化方式展开参数包"><a href="#模板递归和特化方式展开参数包" class="headerlink" title="模板递归和特化方式展开参数包"></a>模板递归和特化方式展开参数包</h4><p>可变参数模板类的展开一般需要定义2 ~ 3个类，包含类声明和特化的模板类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename... nums&gt; struct Sum;// 变长模板的声明</span><br><span class="line"></span><br><span class="line">template &lt;typename First, typename... last&gt;</span><br><span class="line">struct Sum&lt;first, last...&gt; // 变长模板类</span><br><span class="line">&#123;</span><br><span class="line">    static const long val = first * Sum&lt;last...&gt;::val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;&gt;</span><br><span class="line">struct Sum&lt;&gt; // 边界条件</span><br><span class="line">&#123;</span><br><span class="line">    static const long val = 1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>一个基本的可变参数模板应用类由三部分组成：</p>
<p>第一个是<code>template&lt;typename... Args&gt; struct Sum</code>，这是前向声明，声明这个类是可变参数模板类</p>
<p>第二个是类的定义，它定义了一个部分展开的可变参数模板类，告诉编译器如何递归展开参数包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename First, typename... last&gt; </span><br><span class="line">struct Sum&lt;first, last...&gt; // 变长模板类</span><br><span class="line">&#123;</span><br><span class="line">    static const long val = first * Sum&lt;last...&gt;::val;</span><br><span class="line">&#125;;`</span><br></pre></td></tr></table></figure></p>
<p>第三个是特化的递归终止类，这是在展开到0个参数时终止，也可以在展开到2个时终止。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">template&lt;&gt;</span><br><span class="line">struct Sum&lt;&gt; // 边界条件</span><br><span class="line">&#123;</span><br><span class="line">    static const long val = 1;</span><br><span class="line">&#125;;</span><br><span class="line">template&lt;typename First, typename Last&gt;</span><br><span class="line">struct sum&lt;First, Last&gt; &#123;</span><br><span class="line">	static const long val = First * Last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="可变参数消除重复代码"><a href="#可变参数消除重复代码" class="headerlink" title="可变参数消除重复代码"></a>可变参数消除重复代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">void Print(T t) &#123;</span><br><span class="line">	cout &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;typename T, typename ... Args&gt;</span><br><span class="line">void Print(T t) &#123;</span><br><span class="line">	cout &lt;&lt; t ;</span><br><span class="line">	Print(args...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过可变模板参数可以消除重复，同时去掉参数个数限制：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename ... Args&gt;</span><br><span class="line">T* Instance(Args... args) &#123;</span><br><span class="line">	return new T(args...);</span><br><span class="line">&#125;</span><br><span class="line">A* pa = Instance&lt;A&gt;(1);</span><br><span class="line">B* pb = Instance&lt;B&gt;(1, 2);</span><br></pre></td></tr></table></figure></p>
<p>上边的代码<code>T* Instance(Args... args)</code>的Args是值拷贝的，存在性能损耗，可以通过完美转发来消除损耗：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename ... Args&gt;</span><br><span class="line">T* Instance(Args&amp;&amp;... args) &#123;</span><br><span class="line">	return new T(std::forward&lt;Args &gt;(args)...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="可变参数模板和type-traits的综合应用"><a href="#可变参数模板和type-traits的综合应用" class="headerlink" title="可变参数模板和type_traits的综合应用"></a>可变参数模板和type_traits的综合应用</h2><h3 id="optional的实现"><a href="#optional的实现" class="headerlink" title="optional的实现"></a>optional的实现</h3><p>C+14中将包含一个<code>std::optional</code>类，它的功能及用法和boost的optional类似。<code>optional&lt;T&gt;</code>内部存储空间可能存储了T类型的值也可能没有存储T类型的值，只有当optional被T初始化之后，这个optional才是有效的，否则是无效的，它实现了未初始化的概念。</p>
<p>optional可以用于解决函数返回无效值的问题，有时根据某个条件去查找对象时，如果查找不到对象，就会返回一个无效值，这不表明函数执行失败，而是表明函数正确执行了，只是结果不是有用的值。这时就可以返回一个未初始化的optional对象，判断这个optional对象是否是有效对象需要判断它是否被初始化，如果没有被初始化就表明这个值是无效的。boost中的optional就实现了这种未初始化的概念。 boost.optional的基本用法很简单：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">optional&lt;int&gt; op;</span><br><span class="line">if(op)</span><br><span class="line">	cout &lt;&lt; *op &lt;&lt; endl;</span><br><span class="line">optional&lt;int&gt; op1 = 1;</span><br><span class="line">if(op1)</span><br><span class="line">	cout &lt;&lt; *op1 &lt;&lt; endl;</span><br></pre></td></tr></table></figure></p>
<p>第一个op由于没有被初始化，所以它是一个无效值，将不会输出打印信息；第二个op被初始化为1，所以它是一个有效值，将会输出1。optional经常用于函数返回值。</p>
<p>由于optional<t>需要容纳T的值，所以需要一个缓冲区保存这个T，这个缓冲区不可用普通的char数组，需要使用内存对齐的缓冲区<code>std::aligned_storage</code>，原型如下，其中，Len表示所存储类型的size，Align表示该类型内存对齐的大小，通过sizeof(T)可以获取T的size，通过alignof(T)可以获取T内存对齐的大小：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template&lt; std::size_t Len, std::size_t Align = /* default-alignment */ &gt;</span><br><span class="line">struct aligned_storage;</span><br><span class="line"></span><br><span class="line">std::aligned_storage&lt;sizeof(T), alignof(T)&gt; 或</span><br><span class="line">std::aligned_storage&lt;sizeof(T), std::alignment_of&lt;T&gt;::value&gt;</span><br></pre></td></tr></table></figure></t></p>
<p>需要注意拷贝和赋值时，内部状态和缓冲区销毁的问题。内部状态用来标示该optional是否被初始化，当已经初始化时需要先将缓冲区清理一下。需要增加右值版本优化效率。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;type_traits&gt;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">class Optional</span><br><span class="line">&#123;</span><br><span class="line">    using data_t = typename std::aligned_storage&lt;sizeof(T), std::alignment_of&lt;T&gt;::value&gt;::type;</span><br><span class="line">public:</span><br><span class="line">    Optional() : m_hasInit(false) &#123;&#125;</span><br><span class="line">    Optional(const T&amp; v)</span><br><span class="line">    &#123;</span><br><span class="line">        Create(v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Optional(T&amp;&amp; v) : m_hasInit(false)</span><br><span class="line">    &#123;</span><br><span class="line">        Create(std::move(v));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Optional()</span><br><span class="line">    &#123;</span><br><span class="line">        Destroy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Optional(const Optional&amp; other) : m_hasInit(false)</span><br><span class="line">    &#123;</span><br><span class="line">        if (other.IsInit())</span><br><span class="line">            Assign(other);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Optional(Optional&amp;&amp; other) : m_hasInit(false)</span><br><span class="line">    &#123;</span><br><span class="line">        if (other.IsInit())</span><br><span class="line">        &#123;</span><br><span class="line">            Assign(std::move(other));</span><br><span class="line">            other.Destroy();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Optional&amp; operator=(Optional &amp;&amp;other)</span><br><span class="line">    &#123;</span><br><span class="line">        Assign(std::move(other));</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Optional&amp; operator=(const Optional &amp;other)</span><br><span class="line">    &#123;</span><br><span class="line">        Assign(other);</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    template&lt;class... Args&gt;</span><br><span class="line">    void emplace(Args&amp;&amp;... args)</span><br><span class="line">    &#123;</span><br><span class="line">        Destroy();</span><br><span class="line">        Create(std::forward&lt;Args&gt;(args)...);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool IsInit() const &#123; return m_hasInit; &#125;</span><br><span class="line"></span><br><span class="line">    explicit operator bool() const &#123; return IsInit(); &#125;</span><br><span class="line"></span><br><span class="line">    T&amp; operator*()</span><br><span class="line">    &#123;</span><br><span class="line">        return *((T*) (&amp;m_data));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T const&amp; operator*() const</span><br><span class="line">    &#123;</span><br><span class="line">        if (IsInit())</span><br><span class="line">        &#123;</span><br><span class="line">            return *((T*) (&amp;m_data));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        throw std::exception(&quot;is not init&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool operator == (const Optional&lt;T&gt;&amp; rhs) const</span><br><span class="line">    &#123;</span><br><span class="line">        return (!bool(*this)) != (!rhs) ? false : (!bool(*this) ? true : (*(*this)) == (*rhs));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool operator &lt; (const Optional&lt;T&gt;&amp; rhs) const</span><br><span class="line">    &#123;</span><br><span class="line">        return !rhs ? false : (!bool(*this) ? true : (*(*this) &lt; (*rhs)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool operator != (const Optional&lt;T&gt;&amp; rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        return !(*this == (rhs));</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    template&lt;class... Args&gt;</span><br><span class="line">    void Create(Args&amp;&amp;... args)</span><br><span class="line">    &#123;</span><br><span class="line">        new (&amp;m_data) T(std::forward&lt;Args&gt;(args)...);</span><br><span class="line">        m_hasInit = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void Destroy()</span><br><span class="line">    &#123;</span><br><span class="line">        if (m_hasInit)</span><br><span class="line">        &#123;</span><br><span class="line">            m_hasInit = false;</span><br><span class="line">            ((T*) (&amp;m_data))-&gt;~T();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void Assign(const Optional&amp; other)</span><br><span class="line">    &#123;</span><br><span class="line">        if (other.IsInit()) &#123;</span><br><span class="line">            Copy(other.m_data);</span><br><span class="line">            m_hasInit = true;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            Destroy();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void Assign(Optional&amp;&amp; other)</span><br><span class="line">    &#123;</span><br><span class="line">        if (other.IsInit()) &#123;</span><br><span class="line">            Move(std::move(other.m_data));</span><br><span class="line">            m_hasInit = true;</span><br><span class="line">            other.Destroy();</span><br><span class="line">        &#125; </span><br><span class="line">        else &#123;</span><br><span class="line">            Destroy();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void Move(data_t&amp;&amp; val)</span><br><span class="line">    &#123;</span><br><span class="line">        Destroy();</span><br><span class="line">        new (&amp;m_data) T(std::move(*((T*)(&amp;val))));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void Copy(const data_t&amp; val)</span><br><span class="line">    &#123;</span><br><span class="line">        Destroy();</span><br><span class="line">        new (&amp;m_data) T(*((T*) (&amp;val)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    bool m_hasInit;</span><br><span class="line">    data_t m_data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="惰性求值类lazy的实现"><a href="#惰性求值类lazy的实现" class="headerlink" title="惰性求值类lazy的实现"></a>惰性求值类lazy的实现</h3><p>惰性求值（Lazy Evaluation）是相对常用的编程语言中的及早求值而言的另一种求值策略，也被称之为按需调用（call-by-need），或者叫延时求值。简单地讲，惰性求值是在谋求一种平衡，一种在节省开发与节约计算资源的一种平衡策略。一个庞大的类实例可能一次只有一小部分会发生更改，如果把其他的东西都盲目的添加进来，就会额外造成不少的计算资源的浪费。因此，在开发时，开发人员不仅要知道高级语言的语法糖，也需要一定的底层 AST 的实现原理，这样能够避免很多不必要的运行时开销。所以，这里的惰性，更多的是指等待的意思：一旦等到了明确的调用命令，自然会把运行结果正确送出。</p>
<p>借助lambda表达式，将函数封装到lambda表达式中，而不是马上求值，是在需要的时候再调用lambda表达式来求值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">struct Lazy &#123;</span><br><span class="line">	Lazy() &#123;&#125;</span><br><span class="line"></span><br><span class="line">	template &lt;typename Func, typename ... Args&gt;</span><br><span class="line">	Lazy(Func&amp; f, Args &amp;&amp; ... args) &#123;</span><br><span class="line">		m_func = [&amp;f, &amp;args...]&#123; return f(args...); &#125;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	T&amp; value() &#123;</span><br><span class="line">		if (!m_value.IsInit()) &#123;</span><br><span class="line">			m_vlaue = m_func(); </span><br><span class="line">		&#125;</span><br><span class="line">		return *m_value;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	bool IsValueCreated() const &#123;</span><br><span class="line">		return m_value.IsInit();</span><br><span class="line">	&#125;</span><br><span class="line">private:</span><br><span class="line">	std::function&lt;T()&gt; m_func;</span><br><span class="line">	Optional&lt;T&gt; m_value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;class Func, typename... Args&gt;</span><br><span class="line">Lazy&lt;typename std::result_of&lt;Func(Args...)&gt;::type&gt; lazy(Func &amp;&amp; fun, Args &amp;&amp; ... args) &#123;</span><br><span class="line">	return Lazy&lt;typename std::result_of&lt;Func(Args...)&gt;::type&gt;(std::forward&lt;Func&gt;(fun), std::forward&lt;Args&gt;(args)...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Lazy类用到了std::function和optional，其中std::function用来保存传入的函数，不马上执行，而是延迟到后面需要使用值的时候才执行，函数的返回值被放到一个optional对象中，如果不用optional，则需要增加一个标识符来标识是否已经求值，而使用optional对象可以直接知道对象是否已经求值，用起来更简便。</p>
<p>通过optional对象我们就知道是否已经求值，当发现已经求值时直接返回之前计算的结果，起到缓存的作用。<br>代码清单后一部分定义了一个辅助函数，该辅助函数的作用是更方便地使用Lazy，因为Lazy类需要一个模板参数来表示返回值类型，而type_traits中的std::result_of可以推断出函数的返回值类型，所以这个辅助函数结合std::result_of就无须显式声明返回类型了，同时可变参数模板消除了重复的模板定义和模板参数的限制，可以满足所有的函数入参，在使用时只需要传入一个函数和其参数就能实现延迟计算。</p>
<p>Lazy内部的std::function<t()>用来保存传入的函数，以便在后面延迟执行，这个function定义是没有参数的，因为可以通过一个lambda表达式去初始化一个function，而lambda表达式可以捕获参数，所以无须定义function的参数，当然还可以通过std::bind绑定器来将N元的入参函数变为sdtd::function<t()>。</t()></t()></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">struct BigObject &#123;</span><br><span class="line">	BigObject() &#123; cout &lt;&lt; &quot;lazy load big object&quot; &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">struct MyStruct &#123;</span><br><span class="line">	MyStruct() &#123;</span><br><span class="line">		m_obj = lazy( [] &#123; return std::make_shared&lt;BigObject&gt;(); &#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	void Load() &#123;</span><br><span class="line">		m_obj.Value();</span><br><span class="line">	&#125;</span><br><span class="line">	Lazy&lt; std::shared_ptr&lt;BigObject&gt; &gt; m_obj;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int Foo(int x) &#123; return x * 2; &#125;</span><br><span class="line"></span><br><span class="line">void TestLazy() &#123;</span><br><span class="line">	int y = 4;</span><br><span class="line">	auto lazyer1 = lazy(Foo, y);</span><br><span class="line">	cout &lt;&lt; lazyer1.Value() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	Lazy&lt;int&gt; lazyer2 = lazy([] &#123;return 12;&#125;);</span><br><span class="line">	cout &lt;&lt; lazyer2.Value() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	std::function &lt;int(int)&gt; f = [](int x) &#123; return x + 3; &#125;;</span><br><span class="line">	auto lazyer3 = lazy(f, 3);</span><br><span class="line">	cout &lt;&lt; lazyer3.Value() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	MyStruct t;</span><br><span class="line">	t.Load();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">12</span><br><span class="line">6</span><br><span class="line">lazy load big object</span><br></pre></td></tr></table></figure></p>
<h3 id="dll帮助类"><a href="#dll帮助类" class="headerlink" title="dll帮助类"></a>dll帮助类</h3><p>如果要按照<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ret CallDllFunc(const string&amp; funName, T arg)</span><br></pre></td></tr></table></figure></p>
<p>这种方式调用，则首先要把函数指针转换成一种函数对象或泛型函数，这样可以用std::function做这件事。</p>
<p>封装GetProcAddress，将函数指针转换成std::function<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">std::function&lt;T&gt; GetFunction(const string&amp; funName) &#123;</span><br><span class="line">	FARPROC funAddress = GetProcAddress(m_hMod, funcName.c_str());</span><br><span class="line">	return std::function&lt;T&gt;((T*)funAddress)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>T是std::function的模板参数，即函数类型的签名。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto fmax = GetFunction&lt;int(int, int)&gt;(&quot;Max&quot;);</span><br><span class="line">auto fget = GetFunction&lt;int(int)&gt;(&quot;Get&quot;);</span><br></pre></td></tr></table></figure></p>
<p>解决函数返回值与入参不一样的问题，通过result_of和可变参数模板解决：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T, typename ... Args&gt;</span><br><span class="line">typename std::result_of&lt;std::function&lt;T&gt;(Args...)&gt;::type ExecuteFunc(const string&amp; funcName, Args&amp;&amp; ... args) &#123;</span><br><span class="line">	return GetFunction&lt;T&gt;(funcName)(args...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">auto max = ExecuteFunc&lt;int(int, int)&gt;(&quot;Max&quot;, 5, 8);</span><br><span class="line">auto ret = ExecuteFunc&lt;int(int)&gt;(&quot;Get&quot;, 5);</span><br></pre></td></tr></table></figure></p>
<h3 id="lambda链式调用"><a href="#lambda链式调用" class="headerlink" title="lambda链式调用"></a>lambda链式调用</h3><p>将多个函数按照前一个的输出作为下一个输入串起来再推迟到某个时刻计算。</p>
<p>首先创建一个task对象，然后连续调用then的函数，只需要保证前一个函数的输出为后一个的输入即可。最后在需要的时候调用计算结果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">class Task;</span><br><span class="line"></span><br><span class="line">template&lt;typename R, typename...Args&gt;</span><br><span class="line">class Task&lt;R(Args...)&gt;</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Task(std::function&lt;R(Args...)&gt;&amp;&amp; f) : m_fn(std::move(f)) &#123;&#125;</span><br><span class="line">    Task(std::function&lt;R(Args...)&gt;&amp; f) : m_fn(f) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    R run(Args&amp;&amp;... args)</span><br><span class="line">    &#123;</span><br><span class="line">        return m_fn(std::forward&lt;Args&gt;(args)...);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    template &lt;typename F&gt;</span><br><span class="line">    auto Then(F&amp;&amp; f) -&gt; Task&lt;typename std::result_of&lt;F(R)&gt;::type(Args...)&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        using return_type = typename std::result_of&lt;F(R)&gt;::type;</span><br><span class="line"></span><br><span class="line">        auto func = std::move(m_fn);</span><br><span class="line">        return Task&lt;return_type(Args...)&gt;([func, &amp;f](Args&amp;&amp;...args) &#123;</span><br><span class="line">            return f(func(std::forward&lt;Args&gt;(args)...));</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    std::function&lt;R(Args...)&gt; m_fn;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void tesk()</span><br><span class="line">&#123;</span><br><span class="line">    Task&lt;int(int)&gt; task([](int i) &#123;return i; &#125;);</span><br><span class="line"></span><br><span class="line">    auto f = task</span><br><span class="line">        .Then([](int i) &#123;return i + 1; &#125;)</span><br><span class="line">        .Then([](int i) &#123;return i + 2; &#125;)</span><br><span class="line">        .Then([](int i) &#123;return i + 3; &#125;);</span><br><span class="line"></span><br><span class="line">    auto result = f.run(0);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;run task result:&quot; &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run task result:6</span><br></pre></td></tr></table></figure></p>
<h3 id="any类的实现"><a href="#any类的实现" class="headerlink" title="any类的实现"></a>any类的实现</h3><p>boost库有一个Any类，是一个特殊的只能容纳一个元素的容器，他可以擦除类型，给任何类型赋值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">boost::any a = 1;</span><br><span class="line">boost::any a = 1.1;</span><br><span class="line"></span><br><span class="line">std::vector&lt;boost::any&gt; v;</span><br><span class="line">v.push_back(a);</span><br><span class="line">v.push_back(b);</span><br><span class="line"></span><br><span class="line">int va = boost::any_cast&lt;int&gt;(a); // 1</span><br><span class="line">double vb = boost::any_cast&lt;double&gt;(b); // 2.5</span><br></pre></td></tr></table></figure></p>
<p>vector中可以存放int和double，因为any擦除了int和double的类型，当通过any_cast<t>取出实际类型时，如果T不是原来的类型，会报错。</t></p>
<p>any能容纳所有类型的数据，因此，当赋值给any时，需要将值的类型擦除，即以一种通用的方式保存所有类型的数据。这里可以通过继承去擦除类型，基类是不含模板参数的，派生类中才有模板参数，这个模板参数类型正是赋值的类型。在赋值时，将创建的派生类对象赋值给基类指针，基类的派生类携带了数据类型，基类只是原始数据的一个占位符，通过多态的隐式转换擦除了原始数据类型，因此，任何数据类型都可以赋值给它，从而实现能存放所有类型数据的目标。当取数据时需要向下转换成派生类型来获取原始数据，当转换失败时打印详情，并抛出异常。由于向any赋值时需要创建一个派生类对象，所以还需要管理该对象的生命周期，这里用unique_ptr智能指针去管理对象的生命周期。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">class Any</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    //默认构造函数</span><br><span class="line">    Any() : m_tpIndex(std::type_index(typeid(void))) &#123;&#125;</span><br><span class="line">    Any(const Any&amp; other) : m_ptr(other.clone()), m_tpIndex(other.m_tpIndex) &#123;&#125;</span><br><span class="line">    Any(Any&amp;&amp; other) : m_ptr(std::move(other.m_ptr)), m_tpIndex(std::move(other.m_tpIndex)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    //通用的右值构造</span><br><span class="line">    template&lt;typename T, class = typename std::enable_if&lt;!std::is_same&lt;typename std::decay&lt;T&gt;::type, Any&gt;::value, T&gt;::type&gt;</span><br><span class="line">    Any(T &amp;&amp; value) : m_ptr(new Derived&lt;typename std::decay&lt;T&gt;::type&gt;(std::forward&lt;T&gt;(value)))</span><br><span class="line">        , m_tpIndex(std::type_index(typeid(std::decay&lt;T&gt;::type))) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    //判断是否为空</span><br><span class="line">    bool isNull() &#123;</span><br><span class="line">        return !bool(m_ptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //是否可以类型转换</span><br><span class="line">    template&lt;class T&gt;</span><br><span class="line">    bool is() const &#123;</span><br><span class="line">        return m_tpIndex == std::type_index(typeid(T));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //类型转换</span><br><span class="line">    template&lt;class T&gt;</span><br><span class="line">    T&amp; cast()</span><br><span class="line">    &#123;</span><br><span class="line">        if (!is&lt;T&gt;())</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; &quot;can not cast &quot; &lt;&lt; typeid(T).name() &lt;&lt; &quot; to &quot;</span><br><span class="line">                &lt;&lt; m_tpIndex.name() &lt;&lt; endl;</span><br><span class="line">            throw bad_cast();</span><br><span class="line">        &#125;</span><br><span class="line">        auto ptr = dynamic_cast&lt;Derived&lt;T&gt;*&gt;(m_ptr.get());</span><br><span class="line">        return ptr-&gt;m_value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Any&amp; operator=(const Any&amp; other)</span><br><span class="line">    &#123;</span><br><span class="line">        if (m_ptr == other.m_ptr)</span><br><span class="line">        &#123;</span><br><span class="line">            return *this;</span><br><span class="line">        &#125;</span><br><span class="line">        m_ptr = other.clone();</span><br><span class="line">        m_tpIndex = other.m_tpIndex;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    struct Base;</span><br><span class="line">    using BasePtr = std::unique_ptr&lt;Base&gt;;</span><br><span class="line"></span><br><span class="line">    //非模板擦除类型</span><br><span class="line">    struct Base</span><br><span class="line">    &#123;</span><br><span class="line">        virtual BasePtr clone() const = 0;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    template&lt;typename T&gt;</span><br><span class="line">    struct Derived : public Base</span><br><span class="line">    &#123;</span><br><span class="line">        template&lt;typename...Args&gt;</span><br><span class="line">        Derived(Args&amp;&amp;...args) : m_value(std::forward&lt;Args&gt;(args)...)</span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        BasePtr clone() const</span><br><span class="line">        &#123;</span><br><span class="line">            return BasePtr(new Derived(m_value));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        T m_value;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    //拷贝使用</span><br><span class="line">    BasePtr clone() const</span><br><span class="line">    &#123;</span><br><span class="line">        if (m_ptr)</span><br><span class="line">        &#123;</span><br><span class="line">            return m_ptr-&gt;clone();</span><br><span class="line">        &#125;</span><br><span class="line">        return nullptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BasePtr         m_ptr;      //具体数据</span><br><span class="line">    std::type_index m_tpIndex;  //数据类型</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="function-traits"><a href="#function-traits" class="headerlink" title="function_traits"></a>function_traits</h3><p>可以获得普通函数、函数指针、std::function、函数对象和成员函数的函数类型、返回类型、参数个数和参数的具体类型。<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int func(int a, string b);</span><br><span class="line"></span><br><span class="line">//获取函数类型</span><br><span class="line">function_traits&lt;decltype(func)&gt;::function_type; //int __cdecl(int, string)</span><br><span class="line"></span><br><span class="line">//获取函数返回值</span><br><span class="line">function_traits&lt;decltype(func)&gt;::return_type; //int</span><br><span class="line"></span><br><span class="line">//获取函数的参数个数</span><br><span class="line">function_traits&lt;decltype(func)&gt;::arity; //2</span><br><span class="line"></span><br><span class="line">//获取函数第一个入参类型</span><br><span class="line">function_traits&lt;decltype(func)&gt;::arg_type&lt;0&gt;; //int</span><br><span class="line"></span><br><span class="line">//获取函数第二个入参类型</span><br><span class="line">function_traits&lt;decltype(func)&gt;::arg_type&lt;1&gt;; //string</span><br></pre></td></tr></table></figure></p>
<p>通过function_traits可以很方便地获取所有函数语义类型丰富的信息，对于实际开发很有用。</p>
<h4 id="实现-function-traits的关键技术"><a href="#实现-function-traits的关键技术" class="headerlink" title="实现 function_traits的关键技术"></a>实现 function_traits的关键技术</h4><p>实现function_traits关键是要通过模板特化和可变参数模板来获取函数类型和返回类型。<br>先定义一个基本的function_traits的模板类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">struct function traits</span><br></pre></td></tr></table></figure></p>
<p>再通过特化，将返回类型和可变参数模板作为模板参数，就可以获取函数类型、函数返回值和参数的个数了。基本的特化版本如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename Ret, typename... Args&gt;</span><br><span class="line">struct function_traits&lt;Ret(Args...)&gt; </span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	enum &#123; arity = sizeof...(Args) &#125;;</span><br><span class="line">	typedef Ret function_type(Args...);</span><br><span class="line">	typedef Ret return_type;</span><br><span class="line">	using stl_function_type = std::function&lt;function_type&gt;;</span><br><span class="line">	typedef Ret(*pointer)(Args...);</span><br><span class="line"></span><br><span class="line">	template&lt;size_t I&gt;</span><br><span class="line">	struct args &#123;</span><br><span class="line">		using type = typename std::tuple_element&lt;I, std::tuple&lt;Args...&gt;&gt;::type;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="variant的实现"><a href="#variant的实现" class="headerlink" title="variant的实现"></a>variant的实现</h3><p>variant类似于union，它能代表定义的多种类型，允许将不同类型的值赋给它。它的具体类型是在初始化赋值时确定。boost中的variant的基本用法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef variant&lt;int,char, double&gt; vt;</span><br><span class="line">vt v = 1;</span><br><span class="line">v = &apos;2&apos;;</span><br><span class="line">v = 12.32;</span><br></pre></td></tr></table></figure></p>
<p>用variant一个好处是可以擦除类型，不同类型的值都统一成一个variant，虽然这个variant只能存放已定义的类型，但这在很多时候已经够用了。 取值的时候，通过get<t>(v)来获取真实值。然而，当T类型与v的类型不匹配时，会抛出一个bad_cast的异常来。boost的variant抛出的异常往往没有更多的信息，不知道到底是哪个类型转换失败，导致发生异常调试时很不方便。因此，就考虑用c++11去实现一个vairiant, 这个variant可以很容易知道取值时，是什么类型转换失败了。</t></p>
<h4 id="打造variant需要解决的问题"><a href="#打造variant需要解决的问题" class="headerlink" title="打造variant需要解决的问题"></a>打造variant需要解决的问题</h4><p>第一，要在内部定义一个char缓冲区。缓冲区用来存放variant的值，这个值是variant定义的多种类型中的某种类型的值，因此，这个缓冲区要足够大，能够存放类型最大（sizeof(Type)）的值才可以，这个缓冲区的大小还必须在编译期计算出来。因此需要首先要解决的是variant值存放的缓冲区定义的问题。同时注意内存对齐，使用<code>std::aligned_storage</code>作为variant值存放的缓冲区。</p>
<p>第二，要解决赋值的问题。将值赋给vairiant时，需要将该值的类型ID记录下来，以便在后面根据类型取值。将值保存到内部缓冲区时，还需要用palcement new在缓冲区创建对象。另外，还要解决一个问题，就是赋值时需要检查variant中已定义的类型中是否含有该类型，如果没有则编译不通过，以保证赋值是合法的。</p>
<p>variant的赋值函数要做两件事：第一是从原来的variant中取出缓冲区中的对象；第二是通过缓冲区中取出的对象构造出当前variant中的对象。赋值函数的左值和右值的实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Variant(Variant&lt;Types...&gt;&amp;&amp; old) : m_typeIndex(old.m_typeIndex) &#123;</span><br><span class="line">	Helper_t::move(old.m_typeIndex, &amp;old.m_data, &amp;m_data);</span><br><span class="line">&#125;</span><br><span class="line">Variant(const Variant&lt;Types...&gt;&amp; old) : m_typeIndex(old.m_typeIndex) &#123;</span><br><span class="line">	Helper_t::copy(old.m_typeIndex, &amp;old.m_data, &amp;m_data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第三，解决取值的问题，通过类型取值时，要判断类型是否匹配，如果不匹配，将详情打印出来，方便调试。</p>
<h4 id="打造variant的关键技术："><a href="#打造variant的关键技术：" class="headerlink" title="打造variant的关键技术："></a>打造variant的关键技术：</h4><p>找出最大的typesize。第一个问题中需要解决的问题是如何找出多种类型中，size最大的那个类型的size。看看如何从多种类型中找出最大类型的size。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T, typename... Args&gt;</span><br><span class="line">struct MaxType : std::integral_constant&lt;int,</span><br><span class="line">(sizeof(T)&gt;MaxType&lt;Args...&gt;::value ? sizeof(T) : MaxType&lt;Args...&gt;::value) &gt; </span><br><span class="line"></span><br><span class="line">&#123;&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">struct MaxType&lt;T&gt; : std::integral_constant&lt;int, sizeof(T) &gt;&#123;&#125;;</span><br></pre></td></tr></table></figure></p>
<p>通过这个MaxType就可以在编译期获取类型中最大的maxsize了：<code>MaxType&lt;Types...&gt;::value</code>。</p>
<p>这里通过继承和递归方式来展开参数包，在展开参数包的过程中将第一个参数的size和后面一个参数的size做比较，获取较大的那个size，直到比较完所有的参数，从而获得所有类型中最大的size，比较的过程和冒泡排序的过程类似。内存对齐的缓冲区aligned_storage需要两个模版参数，第一个是缓冲区大小，第二个是内存对齐的大小。 variant中的aligned_storage中的缓冲区大小就是最大类型的sice，我们已经找出，下一步是找出最大的内存对齐大小。我们可以在MaxType的基础上来获取MaxAligin。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename... Args&gt;</span><br><span class="line">struct MaxAlign : std::integral_constant&lt;int, IntegreMax&lt;std::alignment_of&lt;Args&gt;::value...&gt;::value&gt;&#123;&#125;;</span><br><span class="line"></span><br><span class="line">enum &#123;</span><br><span class="line">	data_size = MaxType&lt;sizeof(Types)...&gt;::value;</span><br><span class="line">	align_size = MaxAlign&lt;Types...&gt;::value;</span><br><span class="line">&#125;;</span><br><span class="line">using data_t = typename std::aligned_storage&lt;data_size, align_size&gt;::type;</span><br></pre></td></tr></table></figure></p>
<h4 id="类型检查和缓冲区中创建对象"><a href="#类型检查和缓冲区中创建对象" class="headerlink" title="类型检查和缓冲区中创建对象"></a>类型检查和缓冲区中创建对象</h4><p>第二个问题中需要解决两个问题，1.检查赋值的类型是否在已定义的类型中；2.在缓冲区中创建对象及析构；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">template &lt; typename T, typename... List &gt;</span><br><span class="line">struct Contains : std::true_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line">template &lt; typename T, typename Head, typename... Rest &gt;</span><br><span class="line">struct Contains&lt;T, Head, Rest...&gt;</span><br><span class="line">    : std::conditional&lt; std::is_same&lt;T, Head&gt;::value, std::true_type, Contains&lt;T, Rest...&gt;&gt;::type&#123;&#125;;</span><br><span class="line"></span><br><span class="line">template &lt; typename T &gt;</span><br><span class="line">struct Contains&lt;T&gt; : std::false_type&#123;&#125;;</span><br></pre></td></tr></table></figure></p>
<p>通过bool值Contains<t, types>::vaule就可以判断是否含有某种类型。</t,></p>
<p>再看看如何在缓冲区中创建对象。</p>
<p>通过placement new在该缓冲区上创建对象，<code>new(data) T(value);</code>，其中data表示一个char缓冲区，T表示某种类型。在缓冲区上创建的对象还必须通过<code>~T</code>去析构，因此还需要一个析构vairiant的帮助类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T, typename... Args&gt;</span><br><span class="line">struct VariantHelper&lt;T, Args...&gt; &#123;</span><br><span class="line">	inline static void Destroy(type_index id, void * data) &#123;</span><br><span class="line">		if (id == type_index(typeid(T)))</span><br><span class="line">			((T*) (data))-&gt;~T();</span><br><span class="line">		else</span><br><span class="line">			VariantHelper&lt;Args...&gt;::Destroy(id, data);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;&gt; struct VariantHelper&lt;&gt;  &#123;</span><br><span class="line">	inline static void Destroy(type_index id, void * data) &#123; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="取值问题"><a href="#取值问题" class="headerlink" title="取值问题"></a>取值问题</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">typename std::decay&lt;T&gt;::type&amp; Get() &#123;</span><br><span class="line">	using U = typename std::decay&lt;T&gt;::type;</span><br><span class="line">	if (!Is&lt;U&gt;())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; typeid(U).name() &lt;&lt; &quot; is not defined. &quot; &lt;&lt; &quot;current type is &quot; &lt;&lt; m_typeIndex.name() &lt;&lt; endl;</span><br><span class="line">		throw std::bad_cast();</span><br><span class="line">	&#125;</span><br><span class="line">	return *(U*) (&amp;m_data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">int GetIndexOf() &#123;</span><br><span class="line">    return Index&lt;T, Types...&gt;::value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename F&gt;</span><br><span class="line">void Visit(F&amp;&amp; f)</span><br><span class="line">&#123;</span><br><span class="line">　　using T = typename function_traits&lt;F&gt;::arg&lt;0&gt;::type;</span><br><span class="line">　　if (Is&lt;T&gt;())</span><br><span class="line">　　　　f(Get&lt;T&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename F, typename... Rest&gt;</span><br><span class="line">void Visit(F&amp;&amp; f, Rest&amp;&amp;... rest)</span><br><span class="line">&#123;</span><br><span class="line">　　using T = typename function_traits&lt;F&gt;::arg&lt;0&gt;::type;</span><br><span class="line">　　if (Is&lt;T&gt;())</span><br><span class="line">　　　　Visit(std::forward&lt;F&gt;(f));</span><br><span class="line">　　else</span><br><span class="line">　　　　Visit(std::forward&lt;Rest&gt;(rest)...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void TestVariant()</span><br><span class="line">&#123;</span><br><span class="line">    typedef Variant&lt;int, char, double&gt; cv;</span><br><span class="line">    int x = 10;</span><br><span class="line"></span><br><span class="line">    cv v =x;</span><br><span class="line">    v = 1;</span><br><span class="line">    v = 1.123;</span><br><span class="line">    v = &quot;&quot;;//compile error</span><br><span class="line">    v.Get&lt;int&gt;(); //1</span><br><span class="line">    v.Get&lt;double&gt;(); //1.23</span><br><span class="line">    v.Get&lt;short&gt;(); //exception: short is not defined. current type is int</span><br><span class="line">    v.Is&lt;int&gt;();//true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="ScopeGuard"><a href="#ScopeGuard" class="headerlink" title="ScopeGuard"></a>ScopeGuard</h3><p>ScopeGuard的作用是确保资源面对异常时总能被成功释放，就算没有正常返回。惯用法让我们在构造函数里获取资源，当因为异常或者正常作用域结束，那么在析构函数里释放资源。总是能释放资源。如果没有异常抛出则正常结束，只是有异常发生或者没有正常退出时释放资源。</p>
<p>通过局部变量析构函数来管理资源，根据是否正常退出来确定是否需要清理资源。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename F&gt;</span><br><span class="line">class ScopeGuard</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    explicit ScopeGuard( F &amp;&amp; f) : m_func(std::move(f)), m_dismiss(false)&#123;&#125;</span><br><span class="line">    explicit ScopeGuard(const F&amp; f) : m_func(f), m_dismiss(false)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    ~ScopeGuard() &#123;</span><br><span class="line">        if (!m_dismiss &amp;&amp; m_func != nullptr)</span><br><span class="line">            m_func();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ScopeGuard(ScopeGuard &amp;&amp; rhs) : m_func(std::move(rhs.m_func)), m_dismiss(rhs.m_dismiss) &#123;rhs.Dismiss();&#125;</span><br><span class="line"></span><br><span class="line">    void Dismiss() &#123;</span><br><span class="line">        m_dismiss = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    F m_func;</span><br><span class="line">    bool m_dismiss;</span><br><span class="line"></span><br><span class="line">    ScopeGuard();</span><br><span class="line">    ScopeGuard(const ScopeGuard&amp;);</span><br><span class="line">    ScopeGuard&amp; operator=(const ScopeGuard&amp;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template &lt;typename F&gt;</span><br><span class="line">ScopeGuard&lt;typename std::decay&lt;F&gt;::type&gt; MakeGuard(F &amp;&amp; f)</span><br><span class="line">&#123;</span><br><span class="line">　　return ScopeGuard&lt;typename std::decay&lt;F&gt;::type&gt;(std::forward&lt;F&gt;(f));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="tuple-helper"><a href="#tuple-helper" class="headerlink" title="tuple_helper"></a>tuple_helper</h3><p><code>std::tuple</code>作为一个泛化的<code>std::pair</code>，它的一个独特特性是能容纳任意个数任意类型的元素。</p>
<p>tuple还需要一些常用操作，比如打印、遍历、根据元素值获取索引位置、反转和应用于函数。</p>
<ul>
<li>打印：由于tuple中的元素是可变参数模板，外面并不知道内部到底是什么数据，有时调试需要知道其具体值，希望能打印出tuple中所有的元素值。</li>
<li>根据元素值获取索引位置： tuple接口中有根据索引位置获取元素的接口，根据元素值来获取索引位置是相反的做法。</li>
<li>获取索引：在运行期根据索引获取索引位置的元素。</li>
<li>遍历：类似于std::for_each算法，可以将函数对象应用于tuple的每个元素。</li>
<li>反转：将tuple中的元素逆序。</li>
<li>应用于函数：将tuple中的元素进行一定的转换，使之成为函数的入参。</li>
</ul>
<h4 id="打印tuple"><a href="#打印tuple" class="headerlink" title="打印tuple"></a>打印tuple</h4><p>tuple不同于数组和集合，不能通过for循环的方式枚举并打印元素值，需要借助可变参数模板的展开方式来打印出元素值。但是 tuple又不同于可变参数模板不能直接通过展开参数包的方式来展开，因为tuple中的元素需要用<code>std::get&lt;T&gt;(tuple)</code>来获取，展开tuple需要带索引参数。有两种方法可以展开并打印tuple，第一种方法是通过模板类的特化和递归调用结合来展开 tuple；另一种方法是通过一个索引序列来展开tuple。</p>
<p>（1）通过模板特化和递归来展开并打印tuple<br>因为tuple内部的元素个数和类型是不固定的，如果要打印tuple中的元素，需要在展开tuple时一一打印，展开并打印tuple的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class Tuple, std::size_t N&gt;</span><br><span class="line">struct TuplerPrinter &#123;</span><br><span class="line">	static void print (const Tuple&amp; t) &#123;</span><br><span class="line">		TuplerPrinter&lt;Tuple, N - 1 &gt;::print(t);</span><br><span class="line">		std::cout &lt;&lt; &quot;, &quot; &lt;&lt; std::get&lt;N - 1&gt;(t);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;class Tuple&gt;</span><br><span class="line">struct TuplerPrinter&lt;Tuple, 1&gt; &#123;</span><br><span class="line">	static void print(const Tuple&amp; t) &#123;</span><br><span class="line">		std::cout &lt;&lt; std::get(0)&lt;t&gt;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;class... Args&gt;</span><br><span class="line">void PrintTuple(const std::tuple&lt;Args...&gt;&amp; t) &#123;</span><br><span class="line">	std::cout &lt;&lt; &quot;(&quot;;</span><br><span class="line">	TuplePrinter&lt;decltype(t), sizeof...(Args)&gt;::print(t);</span><br><span class="line">	std::cout &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>模板类TuplePrinter带有一个模板参数<code>std::size_t N</code>，这个N是用来控制递归调用的，每调用一次，这个N就减1，直到减为1为止。 PrintTuple是一个帮助函数，目的是为了更方便地调用TuplePrinter，因为Tupleprinter需要两个参数，一个是tuple，另一个是tuple的size。tuple的size是可以通过<code>sizeof</code>来获取的，在帮助函数中获取tuple的size并调用TuplePrinter，就可以减少外面调用的入参。测试代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void TestPrint() &#123;</span><br><span class="line">	std::tuple&lt;int, short, double, char&gt; tp = std: make tuple(1, 2, 3, &apos;a&apos;);</span><br><span class="line">	PrintTuple(tp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出：<code>(1, 2, 3, &#39;a&#39;)</code></p>
<p>调用过程如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Tupleprinter&lt;std::tuplecint, short, double, char&gt;, 4&gt;:: print(tp);</span><br><span class="line">TuplePrinter&lt;std::tuple&lt;int, short, double, char&gt;, 3&gt;:: print(tp);</span><br><span class="line">TuplePrintersstd::tuple&lt;int, short, double, char&gt;, 2&gt;:: print(tp);</span><br><span class="line">TuplePrintersstd::tuple&lt;int, short, double, char&gt;, 1&gt;:: print(tp);</span><br></pre></td></tr></table></figure></p>
<p>当递归终止时，打印第一个元素的值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; std::get&lt;0&gt;(t);</span><br></pre></td></tr></table></figure></p>
<p>接着返回上一层递归打印第二个元素：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; std::get&lt;1&gt;(t);</span><br><span class="line">std::cout &lt;&lt; std::get&lt;2&gt;(t);</span><br><span class="line">std::cout &lt;&lt; std::get&lt;3&gt;(t);</span><br></pre></td></tr></table></figure></p>
<p>（2）根据索引序列展开并打印tuple<br>将tuple变为一个可变参数模板需要一个可变索引序列：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template&lt;int...&gt;</span><br><span class="line">struct IndexTuple&#123;&#125;;</span><br></pre></td></tr></table></figure></p>
<p>再通过<code>std::get&lt;IndexTuple&gt;(tuple)...</code>来获取参数序列，从而将tuple转换为可变参数模板<code>Args...</code>。<br>先创建一个索引序列，通过这个索引序列来取tuple中对应位置的元素：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">template&lt;int...&gt;</span><br><span class="line">struct IndexTuple&#123;&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;int N, int... Indexes&gt;</span><br><span class="line">struct MakeIndexes : MakeIndexes&lt;N-1, N-1, Indexes...&gt;&#123;&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;int... indexes&gt;</span><br><span class="line">struct MakeIndexes&lt;0, indexes...&gt; &#123;</span><br><span class="line">	typedef IndexTuple&lt;indexes...&gt; type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在生成一个元素对应的索引位置序列之后，就可以通过<code>std::get</code>来获取tuple中的所有元素并将其变为可变参数模板。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">void Print(T t) &#123;</span><br><span class="line">	cout &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">template &lt;typename T, typename... Args&gt;</span><br><span class="line">void Print(T t, Args... args) &#123;</span><br><span class="line">	cout &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">	Print(args...);</span><br><span class="line">&#125;</span><br><span class="line">template &lt;typename Tuple, int... Indexes&gt;</span><br><span class="line">void Transform(IndexTuple&lt; Indexes... &gt;&amp; in, Tuple&amp; tp) &#123;</span><br><span class="line">	Print(get&lt;indexes&gt;(tp)...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	using Tuple = std::tuple&lt;int, double&gt;;</span><br><span class="line">	Tuple tp = std::make_tuple&lt;1, 2&gt;;</span><br><span class="line">	Transform(MakeIndexes&lt;std::tuple_size&lt;Tuple&gt;::value&gt;::type(), tp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="反转Tuple"><a href="#反转Tuple" class="headerlink" title="反转Tuple"></a>反转Tuple</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">template&lt;int I, int... Indexes, typename T, typename... Types&gt;</span><br><span class="line">struct make_indexes_reverse_impl&lt;I, IndexTuple&lt;Indexes...&gt;, T, Types...&gt;</span><br><span class="line">&#123;</span><br><span class="line">    using type = typename make_indexes_reverse_impl&lt;I-1, IndexTuple&lt;Indexes..., I-1&gt;, Types...&gt;::type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//递归终止</span><br><span class="line">template&lt;int I, int... Indexes&gt;</span><br><span class="line">struct make_indexes_reverse_impl&lt;I, IndexTuple&lt;Indexes...&gt;&gt;</span><br><span class="line">&#123;</span><br><span class="line">    using type = IndexTuple&lt;Indexes...&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//类型萃取</span><br><span class="line">//调用方法如：make_indexes&lt;double, char, int&gt;</span><br><span class="line">template&lt;typename... Types&gt; </span><br><span class="line">struct make_reverse_indexes : make_indexes_reverse_impl&lt;sizeof...(Types), IndexTuple&lt;&gt;, Types...&gt;</span><br><span class="line">&#123;&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;class... Args, int... Indexes&gt;</span><br><span class="line">auto reverse_impl(std::tuple&lt;Args...&gt;&amp;&amp; tup, IndexTuple&lt;Indexes...&gt;&amp;&amp;) -&gt;</span><br><span class="line">decltype(std::make_tuple(std::get&lt;Indexes&gt;(std::forward&lt;std::tuple&lt;Args...&gt;&gt;(tup))...))</span><br><span class="line">&#123;</span><br><span class="line">    return std::make_tuple(std::get&lt;Indexes&gt;forward&lt;tuple&lt;Args...&gt;&gt;(tup))...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class... Args&gt;</span><br><span class="line">auto tuple_reverse(std::tuple&lt;Args...&gt;&amp;&amp; tup)-&gt;</span><br><span class="line">decltype(reverse_impl(std::forward&lt;std::tuple&lt;Args...&gt;&gt;(tup),typename make_reverse_indexes&lt;Args...&gt;::type()))</span><br><span class="line">&#123;</span><br><span class="line">    return reverse_impl(std::forward&lt;std::tuple&lt;Args...&gt;&gt;(tup), typename make_reverse_indexes&lt;Args...&gt;::type());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="应用于函数"><a href="#应用于函数" class="headerlink" title="应用于函数"></a>应用于函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">template&lt;int...&gt;</span><br><span class="line">struct IndexTuple&#123;&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;int N, int... Indexes&gt;</span><br><span class="line">struct MakeIndexes : MakeIndexes&lt;N-1, N-1, Indexes...&gt;&#123;&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;int... indexes&gt;</span><br><span class="line">struct MakeIndexes&lt;0, indexes...&gt; &#123;</span><br><span class="line">	typedef IndexTuple&lt;indexes...&gt; type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;typename F, typename Tuple, int... Indexes&gt;</span><br><span class="line">auto apply_helper(F&amp;&amp; f, IndexTuple&lt;Indexes...&gt;&amp;&amp; in, Tuple&amp;&amp; tup)-&gt;</span><br><span class="line">decltype(std::forward&lt;F&gt;(f)(std::get&lt;Indexes&gt;(tup)...))</span><br><span class="line">&#123;</span><br><span class="line">    return std::forward&lt;F&gt;(f)(std::get&lt;Indexes&gt;(tup)...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void TestF(int a, double b) &#123;</span><br><span class="line">	cout &lt;&lt; a + b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Test() &#123;</span><br><span class="line">	apply_helper(TestF, MakeIndexes&lt;2&gt;::type(), std::make_tuple(1, 2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：3</p>
<h1 id="使用C-11解决内存泄漏的问题"><a href="#使用C-11解决内存泄漏的问题" class="headerlink" title="使用C++11解决内存泄漏的问题"></a>使用C++11解决内存泄漏的问题</h1><p>智能指针可以自动删除分配的内存，是存储指向动态分配（堆）对象指针的累，用于生存期控制，能够确保在离开指针所在作用域时能够自动正确地销毁动态分配的对象，防止内存泄漏。它的一种通用实现技术是<strong>引用计数</strong>，每使用它一次内部的引用计数加一，每析构一次内部的引用计数减一，减为0时，删除所指向的堆内存。</p>
<h2 id="shared-ptr共享的智能指针"><a href="#shared-ptr共享的智能指针" class="headerlink" title="shared_ptr共享的智能指针"></a>shared_ptr共享的智能指针</h2><p><code>shared_ptr</code>使用引用计数，每一个<code>shared_ptr</code>的拷贝都指向同一个内存，在最后一个<code>shared_ptr</code>析构时，内存才被释放。</p>
<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>通过构造函数、<code>std::make_shared&lt;T&gt;</code>辅助函数和reset方法来初始化。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;int&gt; p(new int(1));</span><br><span class="line">std::shared_ptr&lt;int&gt; p2 = p;</span><br><span class="line">std::shared_ptr&lt;int&gt; ptr;</span><br><span class="line">ptr.reset(new int(1));</span><br></pre></td></tr></table></figure></p>
<p>优先使用<strong><code>make_shared</code></strong>来构造智能指针。<br>不能将一个原始指针直接赋值给一个智能指针：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr p ＝ new int(1) ;　　　// 编译报错，不允许直接赋值</span><br></pre></td></tr></table></figure></p>
<p>通过get方法来返回原始指针<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;int&gt; ptr( new int(1) ) ;</span><br><span class="line">int* p = ptr.get() ;</span><br></pre></td></tr></table></figure></p>
<p>智能指针初始化可以指定删除器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void DeleteIntPtr ( int * p ) &#123;</span><br><span class="line">	delete p ;</span><br><span class="line">&#125;</span><br><span class="line">std::shared_ptr&lt;int&gt; p( new int , DeleteIntPtr ) ;</span><br></pre></td></tr></table></figure></p>
<p>当p的引用技术为０时，自动调用删除器来释放对象的内存。删除器也可以是一个lambda表达式，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;int&gt; p( new int , [](int * p)&#123;delete p&#125; ) ;</span><br></pre></td></tr></table></figure></p>
<p>当我们使用shared_ptr管理动态数组时，需要指定删除器，因为<code>std::shared_ptr</code>默认的删除器不能处理数组对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;int&gt; p(new int[10], [](int* p)&#123;delete[] p;&#125;);</span><br></pre></td></tr></table></figure></p>
<p>或者通过封装一个<code>make_shared_array</code>方法来让shared_ptr支持数组：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">shared_ptr&lt;T&gt; make_shared_array(size_t size) &#123;</span><br><span class="line">	return shared_ptr&lt;T&gt;(new T[size], default_delete&lt;T[]&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>不要用一个原始指针初始化多个shared_ptr，以下是错误的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int* ptr = new int;</span><br><span class="line">shared_ptr&lt;int&gt; p1(ptr);</span><br><span class="line">shared_ptr&lt;int&gt; p2(ptr);</span><br></pre></td></tr></table></figure></p>
<p>不要在函数实参中创建shared_ptr，在调用函数之前先定义以及初始化它。</p>
<p>不要将this指针作为shared_ptr返回出来，因为this指针是一个裸指针，这样做可能会重复析构。正确返回this的shared_ptr的做法是：让目标类通过派生<code>std::enable_shared_from_this&lt;A&gt;</code>类，然后使用基类的成员函数<code>shared_from_this</code>来返回this的shared_ptr：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class A : public std::enable_shared_from_this&lt;A&gt; &#123;</span><br><span class="line">	std::shared_ptr&lt;A&gt; GetSelf() &#123;</span><br><span class="line">		return shared_from_this();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>要避免循环引用，循环引用会导致内存泄漏。</p>
<h2 id="unique-ptr独占的智能指针"><a href="#unique-ptr独占的智能指针" class="headerlink" title="unique_ptr独占的智能指针"></a><code>unique_ptr</code>独占的智能指针</h2><p><code>unique_ptr</code>是一个独占的智能指针，他不允许其他的智能指针共享其内部的指针，不允许通过赋值将一个unique_ptr赋值给另外一个unique_ptr，虽然不允许复制，但可以通过函数返回给其他的unique_ptr，还可以通过std::move来转移到其他的unique_ptr，这样它本身就不再拥有原来指针的所有权了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">unique_ptr&lt;T&gt; my_ptr(new T);</span><br><span class="line">unique_ptr&lt;T&gt; my_other_ptr = std::move(my_ptr);</span><br><span class="line">unique_ptr&lt;T&gt; ptr = my_ptr; // ERROR</span><br></pre></td></tr></table></figure></p>
<p>可以自己实现一个make_unique，C++尚未提供这个函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T, class... Args&gt; inline</span><br><span class="line">typename enable_if&lt;!is_array&lt;T&gt;::value, unique_ptr&lt;T&gt;&gt;::type</span><br><span class="line">make_unique(Args&amp;&amp; ... args) &#123;</span><br><span class="line">	return unique_ptr&lt;T&gt;(new T(std::forward&lt;Args&gt;(args)...));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt; inline</span><br><span class="line">typename enable_if&lt;is_array&lt;T&gt;::value &amp;&amp; extent&lt;T&gt;::value==0, unique_ptr&lt;T&gt;&gt;::type</span><br><span class="line">make_unique(size_t size) &#123;</span><br><span class="line">	typedef typename remove_extent&lt;T&gt;::type U;</span><br><span class="line">	return unique_ptr&lt;T&gt;(new U[size]());</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T, class... Args&gt;</span><br><span class="line">typename enable_if&lt;extent&lt;T&gt;::value!=0, void&gt;::type</span><br><span class="line">make_unique(Args&amp;&amp;&amp; ...) = delete;</span><br></pre></td></tr></table></figure></p>
<p>如果不是数组，则直接创建unique_ptr，如果是数组，则先判断是否为定长数组，如果是定长数组则编译不通过，若为非定常数组，则获取数组中的元素类型，再根据入参size创建动态数组的unique_ptr。</p>
<p>unique_ptr还可指向一个数组：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::unique_ptr&lt;int []&gt; ptr(new int[10]);</span><br><span class="line">ptr[9] = 9;</span><br></pre></td></tr></table></figure></p>
<p>unique_ptr指定删除器需要确定删除器的类型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::unique_ptr&lt;int, void(*)(int*)&gt; ptr(new int(1), [](int* p)&#123; delete p; &#125;);</span><br></pre></td></tr></table></figure></p>
<p>如果lambda表达式没有捕获变量，这样写是对的，因为可以直接转换成函数指针。捕获了变量后：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::unique_ptr&lt;int, std::function&lt;void(int*)&gt;&gt; ptr(new int(1), [&amp;](int* p)&#123; delete p; &#125;);</span><br></pre></td></tr></table></figure></p>
<p>如果希望只有一个智能指针管理资源或管理数组就用unique_ptr，如果希望多个智能指针管理同一个资源就用shared_ptr。 </p>
<h2 id="weak-ptr弱引用的智能指针"><a href="#weak-ptr弱引用的智能指针" class="headerlink" title="weak_ptr弱引用的智能指针"></a><code>weak_ptr</code>弱引用的智能指针</h2><p>弱引用的智能指针<code>weak_ptr</code>是用来监视<code>shared_ptr</code>的，不会使引用计数加一，它不管理<code>shared_ptr</code>内部的指针，主要是为了监视<code>shared_ptr</code>的生命周期，更像是<code>shared_ptr</code>的一个助手。</p>
<p><code>weak_ptr</code>没有重载运算符<code>*</code>和<code>-&gt;</code>，因为它不共享指针，不能操作资源，主要是为了通过<code>shared_ptr</code>获得资源的监测权，它的构造不会增加引用计数，它的析构不会减少引用计数，纯粹只是作为一个旁观者来监视<code>shared_ptr</code>中管理的资源是否存在。weak_ptr还可以用来返回this指针和解决循环引用的问题。</p>
<h3 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h3><p>通过<code>use_count()</code>获得当前观测资源的引用计数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;int&gt; sp(new int(10));</span><br><span class="line">weak_ptr&lt;int&gt; wp(sp);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; wp.use_count() &lt;&lt; endl;</span><br></pre></td></tr></table></figure></p>
<p>通过<code>expired()</code>方法判断观测的资源是否已经释放：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;int&gt; sp(new int(10));</span><br><span class="line">weak_ptr&lt;int&gt; wp(sp);</span><br><span class="line">if (wp.expired())</span><br><span class="line">	cout &lt;&lt; &quot;weak_ptr useless&quot; &lt;&lt; endl;</span><br></pre></td></tr></table></figure></p>
<p>通过lock方法来获取所监视的<code>shared_ptr</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">std::weak_ptr&lt;int&gt; gw;</span><br><span class="line">void f() &#123;</span><br><span class="line">	if (gw.expired()) &#123;</span><br><span class="line">		cout &lt;&lt; &quot;already expired&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		auto spt = gw.lock();</span><br><span class="line">		cout &lt;&lt; *spt &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	&#123;</span><br><span class="line">		auto sp = std::make_shared&lt;int&gt;(43);</span><br><span class="line">		gw = sp;</span><br><span class="line">		f(); // 43</span><br><span class="line">	&#125;</span><br><span class="line">	f(); // already expired</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>之前提到不能直接将this指针返回为<code>shared_ptr</code>，需要通过派生<code>std::enable_shared_from_this</code>类，并通过其方法<code>shared_from_this</code>来返回智能指针，原因是<code>std::enable_shared_from_this</code>类中有一个<code>weak_ptr</code>，这个<code>weak_ptr</code>用来观测this智能指针，调用<code>shared_from_this()</code>方法时，会调用内部这个<code>weak_ptr</code>的<code>lock()</code>方法，将所观测的<code>shared_ptr</code>返回。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct A : public std::enable_shared_from_this&lt;A&gt; &#123;</span><br><span class="line">	std::shared_ptr&lt;A&gt; Getself() &#123;</span><br><span class="line">		return shared_from_this();</span><br><span class="line">	&#125;</span><br><span class="line">	~A() &#123;</span><br><span class="line">		cout &lt;&lt; &quot;A is delete&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">std::shared_ptr&lt;A&gt; spy(newA);</span><br><span class="line">std::shared_ptr&lt;A&gt; p = spy-&gt;Getself();</span><br></pre></td></tr></table></figure></p>
<h3 id="解决循环引用"><a href="#解决循环引用" class="headerlink" title="解决循环引用"></a>解决循环引用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">struct A;</span><br><span class="line">struct B;</span><br><span class="line">struct A &#123;</span><br><span class="line">	std::shared_ptr&lt;B&gt; bptr;</span><br><span class="line">	~A() &#123; cout &lt;&lt; &quot;A is deleted!&quot; &lt;&lt; endl; &#125;</span><br><span class="line">&#125;</span><br><span class="line">struct B &#123;</span><br><span class="line">	std::shared_ptr&lt;A&gt; aptr;</span><br><span class="line">	~B() &#123; cout &lt;&lt; &quot;B is deleted!&quot; &lt;&lt; endl; &#125; </span><br><span class="line">&#125;</span><br><span class="line">void TestPtr() &#123;</span><br><span class="line">	&#123;</span><br><span class="line">		std::shared_ptr&lt;A&gt; ap(new A);</span><br><span class="line">		std::shared_ptr&lt;B&gt; bp(new B);</span><br><span class="line">		ap-&gt;bptr = bp;</span><br><span class="line">		bp-&gt;aptr = ap;</span><br><span class="line">	&#125; // Objects should be destroyed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，由于循环引用导致ap和bp的引用计数都是2，离开作用域后减为1，不会去删除指针，导致内存泄漏，通过weak_ptr解决这个问题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">struct A;</span><br><span class="line">struct B;</span><br><span class="line">struct A &#123;</span><br><span class="line">	std::shared_ptr&lt;B&gt; bptr;</span><br><span class="line">	~A() &#123; cout &lt;&lt; &quot;A is deleted!&quot; &lt;&lt; endl; &#125;</span><br><span class="line">&#125;</span><br><span class="line">struct B &#123;</span><br><span class="line">	std::weak_ptr&lt;A&gt; aptr; // 改为weak_ptr</span><br><span class="line">	~B() &#123; cout &lt;&lt; &quot;B is deleted!&quot; &lt;&lt; endl; &#125; </span><br><span class="line">&#125;</span><br><span class="line">void TestPtr() &#123;</span><br><span class="line">	&#123;</span><br><span class="line">		std::shared_ptr&lt;A&gt; ap(new A);</span><br><span class="line">		std::shared_ptr&lt;B&gt; bp(new B);</span><br><span class="line">		ap-&gt;bptr = bp;</span><br><span class="line">		bp-&gt;aptr = ap;</span><br><span class="line">	&#125; // Objects should be destroyed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="通过智能指针管理第三方库分配的内存"><a href="#通过智能指针管理第三方库分配的内存" class="headerlink" title="通过智能指针管理第三方库分配的内存"></a>通过智能指针管理第三方库分配的内存</h2><p>第三方库分配的内存一般需要通过第三方库提供的释放接口才能释放，由于第三方库返回的指针一般都是原始指针，用完之后如果没有调用第三方库的释放接口，就很容易造成内存泄露。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void *p = GetHandle()-&gt;Create();</span><br><span class="line">//do something</span><br><span class="line">GetHandle()-&gt;Realease(p);</span><br></pre></td></tr></table></figure></p>
<p>用智能指针来管理第三方库的内存就比较方便，不用担心中途返回或者发生异常导致无法调用释放接口的问题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void *p = GetHandle()-&gt;Create();</span><br><span class="line">//do something</span><br><span class="line">std::shared_ptr&lt;void&gt; sp(p, [this](void* p) &#123;GetHandle()-&gt;Realease(p); &#125;);</span><br></pre></td></tr></table></figure></p>
<p>将其提炼成函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;void&gt; Guard(void*p)</span><br><span class="line">&#123;</span><br><span class="line">	 std::shared_ptr&lt;void&gt; sp(p, [this](void* p) &#123;GetHandle()-&gt;Realease(p); &#125;);</span><br><span class="line">	 return sp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//在使用时</span><br><span class="line">void* p = GetHandle()-&gt;Create();</span><br><span class="line">Guard(p); //危险，这句结束后p就被释放了</span><br><span class="line">//do something</span><br></pre></td></tr></table></figure></p>
<p>执行<code>Guard();</code>这句后，函数返回的是一个右值，没有被存储，用完就把p释放了。</p>
<p>可以用宏的方式来解决这个问题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#define GUARD(p) std::shared_ptr&lt;void&gt; p##p(p, [](void *p)&#123;release(p);&#125;)</span><br><span class="line"></span><br><span class="line">//使用时</span><br><span class="line">void* p = GetHandle()-&gt;Create();</span><br><span class="line">GUARD(p);  //安全</span><br></pre></td></tr></table></figure></p>
<p>也可以用unique_ptr来管理第三方的内存：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define GUARD(p) std::unique_ptr&lt;void&gt; p##p(p, [](void *p)&#123;release(p);&#125;)</span><br></pre></td></tr></table></figure></p>
<p>对于宏中的##，其实也很好理解，就是将##前后的字符串连接起来<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#define GUARD(p) std::shared_ptr&lt;void&gt; p##p(p, [](void *p)&#123;release(p);&#125;)</span><br><span class="line"></span><br><span class="line">//使用时</span><br><span class="line">void* p = GetHandle()-&gt;Create();</span><br><span class="line">GUARD(p);  //安全</span><br><span class="line">//会有一个std::shared_ptr&lt;void&gt; pp的智能指针，不信就进行测试。原因去找刚才的#define中有p##p</span><br><span class="line">std::cout &lt;&lt; pp.use_count() &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure></p>
<p>为了验证原作者的这些，写一些demo来帮助理解，也有利于更好掌握：<br>创建一个Base类：<br>Base.h文件中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">class Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	Base();</span><br><span class="line">	~Base();</span><br><span class="line"></span><br><span class="line">	void print();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>Base.cpp文件中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;Base.h&quot;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">Base::Base()</span><br><span class="line">&#123;</span><br><span class="line">	std::cout &lt;&lt; &quot;Base constructor&quot; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Base::~Base()</span><br><span class="line">&#123;</span><br><span class="line">	std::cout &lt;&lt; &quot;Base desctructor&quot; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Base::print()</span><br><span class="line">&#123;</span><br><span class="line">	std::cout &lt;&lt; &quot;print something&quot; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在main.cpp中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;Base.h&quot;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">#define GUARD(p) std::shared_ptr&lt;Base&gt; p##p(p, [](Base*p)&#123;release(p);&#125;)</span><br><span class="line"></span><br><span class="line">Base* create()</span><br><span class="line">&#123;</span><br><span class="line">	return new Base();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void release(Base* base)</span><br><span class="line">&#123;</span><br><span class="line">	delete base;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::shared_ptr&lt;Base&gt; Guard(Base *p)</span><br><span class="line">&#123;</span><br><span class="line">	 std::shared_ptr&lt;Base&gt; sp(p, [](Base*p) &#123;release(p); &#125;);</span><br><span class="line">	 return sp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	&#123;</span><br><span class="line">		Base* p = create();</span><br><span class="line">		</span><br><span class="line">		std::shared_ptr&lt;Base&gt; sp(p, [](Base*p) &#123;release(p); &#125;);</span><br><span class="line">		//Guard(p);</span><br><span class="line"></span><br><span class="line">		//GUARD(p);</span><br><span class="line">		//std::cout &lt;&lt; &quot;sp.use_count():&quot; &lt;&lt; sp.use_count() &lt;&lt; std::endl;;</span><br><span class="line">		p-&gt;print();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	getchar();</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此时的输出为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Base constructor</span><br><span class="line">print something</span><br><span class="line">Base desctructor</span><br></pre></td></tr></table></figure></p>
<p>【修改一】 当我们对main()中修改为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	&#123;</span><br><span class="line">		Base* p = create();</span><br><span class="line">		</span><br><span class="line">		//std::shared_ptr&lt;Base&gt; sp(p, [](Base*p) &#123;release(p); &#125;);</span><br><span class="line">		Guard(p);</span><br><span class="line"></span><br><span class="line">		//GUARD(p);</span><br><span class="line">		//std::cout &lt;&lt; &quot;sp.use_count():&quot; &lt;&lt; sp.use_count() &lt;&lt; std::endl;;</span><br><span class="line">		p-&gt;print();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	getchar();</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Base constructor</span><br><span class="line">Base desctructor</span><br><span class="line">print something</span><br></pre></td></tr></table></figure></p>
<p>发现这时候的p被提前释放了，print something已经是在Base类析构之后做的，此时已经出问题了。</p>
<p>【修改二】将main函数进行修改：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	&#123;</span><br><span class="line">		Base* p = create();</span><br><span class="line">		</span><br><span class="line">		//std::shared_ptr&lt;Base&gt; sp(p, [](Base*p) &#123;release(p); &#125;);</span><br><span class="line">		//Guard(p);</span><br><span class="line"></span><br><span class="line">		GUARD(p);</span><br><span class="line">		std::cout &lt;&lt; &quot;pp.use_count(): &quot; &lt;&lt; pp.use_count() &lt;&lt; std::endl;;</span><br><span class="line">		p-&gt;print();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	getchar();</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Base constructor</span><br><span class="line">pp.use_count(): 1</span><br><span class="line">print something</span><br><span class="line">Base desctructor</span><br></pre></td></tr></table></figure></p>
<p>果然如我们所想，一切正常。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/C/" rel="tag"># C++</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/01/28/cpp11_1/" rel="next" title="C++11特性笔记1——程序简化、改进性能">
                <i class="fa fa-chevron-left"></i> C++11特性笔记1——程序简化、改进性能
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/01/31/cpp11_3/" rel="prev" title="C++11特性笔记3——多线程">
                C++11特性笔记3——多线程 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/header.jpg" alt="Hao Yu">
            
              <p class="site-author-name" itemprop="name">Hao Yu</p>
              <p class="site-description motion-element" itemprop="description">Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author</p>
          </div>
          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">300</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>
        	<audio controls="controls" loop="loop" preload="auto" src="/resource/xiaomeihao.mp3">
	        </audio>
	

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yuhao0102" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:yuh18@mails.tsinghua.edu.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#使用C-11消除重复，提高代码质量"><span class="nav-number">1.</span> <span class="nav-text">使用C++11消除重复，提高代码质量</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#type-traits——类型萃取"><span class="nav-number">1.1.</span> <span class="nav-text">type_traits——类型萃取</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基本的type-traits"><span class="nav-number">1.1.1.</span> <span class="nav-text">基本的type_traits</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#可变参数模板"><span class="nav-number">1.2.</span> <span class="nav-text">可变参数模板</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#可变参数模板函数"><span class="nav-number">1.2.1.</span> <span class="nav-text">可变参数模板函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可变参数模板类"><span class="nav-number">1.2.2.</span> <span class="nav-text">可变参数模板类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#模板递归和特化方式展开参数包"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">模板递归和特化方式展开参数包</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可变参数消除重复代码"><span class="nav-number">1.2.3.</span> <span class="nav-text">可变参数消除重复代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#可变参数模板和type-traits的综合应用"><span class="nav-number">1.3.</span> <span class="nav-text">可变参数模板和type_traits的综合应用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#optional的实现"><span class="nav-number">1.3.1.</span> <span class="nav-text">optional的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#惰性求值类lazy的实现"><span class="nav-number">1.3.2.</span> <span class="nav-text">惰性求值类lazy的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dll帮助类"><span class="nav-number">1.3.3.</span> <span class="nav-text">dll帮助类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lambda链式调用"><span class="nav-number">1.3.4.</span> <span class="nav-text">lambda链式调用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#any类的实现"><span class="nav-number">1.3.5.</span> <span class="nav-text">any类的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#function-traits"><span class="nav-number">1.3.6.</span> <span class="nav-text">function_traits</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#实现-function-traits的关键技术"><span class="nav-number">1.3.6.1.</span> <span class="nav-text">实现 function_traits的关键技术</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#variant的实现"><span class="nav-number">1.3.7.</span> <span class="nav-text">variant的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#打造variant需要解决的问题"><span class="nav-number">1.3.7.1.</span> <span class="nav-text">打造variant需要解决的问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#打造variant的关键技术："><span class="nav-number">1.3.7.2.</span> <span class="nav-text">打造variant的关键技术：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#类型检查和缓冲区中创建对象"><span class="nav-number">1.3.7.3.</span> <span class="nav-text">类型检查和缓冲区中创建对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#取值问题"><span class="nav-number">1.3.7.4.</span> <span class="nav-text">取值问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ScopeGuard"><span class="nav-number">1.3.8.</span> <span class="nav-text">ScopeGuard</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tuple-helper"><span class="nav-number">1.3.9.</span> <span class="nav-text">tuple_helper</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#打印tuple"><span class="nav-number">1.3.9.1.</span> <span class="nav-text">打印tuple</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#反转Tuple"><span class="nav-number">1.3.9.2.</span> <span class="nav-text">反转Tuple</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#应用于函数"><span class="nav-number">1.3.9.3.</span> <span class="nav-text">应用于函数</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#使用C-11解决内存泄漏的问题"><span class="nav-number">2.</span> <span class="nav-text">使用C++11解决内存泄漏的问题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#shared-ptr共享的智能指针"><span class="nav-number">2.1.</span> <span class="nav-text">shared_ptr共享的智能指针</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基本用法"><span class="nav-number">2.1.1.</span> <span class="nav-text">基本用法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#unique-ptr独占的智能指针"><span class="nav-number">2.2.</span> <span class="nav-text">unique_ptr独占的智能指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#weak-ptr弱引用的智能指针"><span class="nav-number">2.3.</span> <span class="nav-text">weak_ptr弱引用的智能指针</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基本用法-1"><span class="nav-number">2.3.1.</span> <span class="nav-text">基本用法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#解决循环引用"><span class="nav-number">2.3.2.</span> <span class="nav-text">解决循环引用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#通过智能指针管理第三方库分配的内存"><span class="nav-number">2.4.</span> <span class="nav-text">通过智能指针管理第三方库分配的内存</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>
  <div id="DvelopmentTarget">     
  </div>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart" aria-hidden="false"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>

  
</div>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_uv"> 
  本站访客数<span id="busuanzi_value_site_uv"></span>人次
</span>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  


  

  


  <script type="text/javascript" src="/js/src/love.js"></script>

</body>
</html>
