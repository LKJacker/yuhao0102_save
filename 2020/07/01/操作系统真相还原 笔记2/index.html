<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zn-ch">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-center-simple.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="操作系统,">










<meta name="description" content="保护模式进阶，向内核迈进获取物理内存容量在Linux 中有多种方法获取内存容量，如果一种方法失败，就会试用其他方法。比如在Linux 2.6 内核中，是用detect_memory函数来获取内存容量的。其函数在本质上是通过调用BIOS中断0x15 实现的，分别是BIOS 中断0x15 的3 个子功能，子功能号要存放到寄存器EAX 或AX 中，如下。  EAX=0xE820：遍历主机上全部内存。 A">
<meta name="keywords" content="操作系统">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统真相还原5-7章">
<meta property="og:url" content="http://yoursite.com/2020/07/01/操作系统真相还原 笔记2/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="保护模式进阶，向内核迈进获取物理内存容量在Linux 中有多种方法获取内存容量，如果一种方法失败，就会试用其他方法。比如在Linux 2.6 内核中，是用detect_memory函数来获取内存容量的。其函数在本质上是通过调用BIOS中断0x15 实现的，分别是BIOS 中断0x15 的3 个子功能，子功能号要存放到寄存器EAX 或AX 中，如下。  EAX=0xE820：遍历主机上全部内存。 A">
<meta property="og:locale" content="zn-ch">
<meta property="og:image" content="http://yoursite.com/img/1593617828.jpg">
<meta property="og:image" content="http://yoursite.com/img/1593620340.jpg">
<meta property="og:image" content="http://yoursite.com/img/1593620777.jpg">
<meta property="og:image" content="http://yoursite.com/img/1593682604.jpg">
<meta property="og:image" content="http://yoursite.com/img/1593682860.jpg">
<meta property="og:image" content="http://yoursite.com/img/1593683057.jpg">
<meta property="og:image" content="http://yoursite.com/img/1593698361.jpg">
<meta property="og:image" content="http://yoursite.com/img/1593710779.jpg">
<meta property="og:image" content="http://yoursite.com/img/1593711197.jpg">
<meta property="og:image" content="http://yoursite.com/img/1593711313.jpg">
<meta property="og:image" content="http://yoursite.com/img/1593711357.jpg">
<meta property="og:image" content="http://yoursite.com/img/1593740354.jpg">
<meta property="og:image" content="http://yoursite.com/img/1593740513.jpg">
<meta property="og:image" content="http://yoursite.com/img/1593740580.jpg">
<meta property="og:image" content="http://yoursite.com/img/1593741243.jpg">
<meta property="og:image" content="http://yoursite.com/img/1593755336.jpg">
<meta property="og:image" content="http://yoursite.com/img/1593760525.jpg">
<meta property="og:image" content="http://yoursite.com/img/1593760544.jpg">
<meta property="og:image" content="http://yoursite.com/img/1593792617.jpg">
<meta property="og:image" content="http://yoursite.com/img/1593828572.jpg">
<meta property="og:image" content="http://yoursite.com/img/1593836299.jpg">
<meta property="og:image" content="http://yoursite.com/img/1593836453.jpg">
<meta property="og:image" content="http://yoursite.com/img/1593939376.jpg">
<meta property="og:image" content="http://yoursite.com/img/1593942767.png">
<meta property="og:image" content="http://yoursite.com/img/1593968345.jpg">
<meta property="og:image" content="http://yoursite.com/img/1593969804.jpg">
<meta property="og:image" content="http://yoursite.com/img/1594002593.jpg">
<meta property="og:image" content="http://yoursite.com/img/1594007235.jpg">
<meta property="og:image" content="http://yoursite.com/img/1594007310.jpg">
<meta property="og:image" content="http://yoursite.com/img/1594009669.jpg">
<meta property="og:image" content="http://yoursite.com/img/1594017978.jpg">
<meta property="og:image" content="http://yoursite.com/img/1594018210.jpg">
<meta property="og:updated_time" content="2020-07-06T06:26:55.960Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="操作系统真相还原5-7章">
<meta name="twitter:description" content="保护模式进阶，向内核迈进获取物理内存容量在Linux 中有多种方法获取内存容量，如果一种方法失败，就会试用其他方法。比如在Linux 2.6 内核中，是用detect_memory函数来获取内存容量的。其函数在本质上是通过调用BIOS中断0x15 实现的，分别是BIOS 中断0x15 的3 个子功能，子功能号要存放到寄存器EAX 或AX 中，如下。  EAX=0xE820：遍历主机上全部内存。 A">
<meta name="twitter:image" content="http://yoursite.com/img/1593617828.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/07/01/操作系统真相还原 笔记2/">





  <title>操作系统真相还原5-7章 | Hao Yu's blog</title>
  








 
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zn-ch">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hao Yu's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">The program monkey was eaten by the siege lion.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-mybetterhalf">
          <a href="/mybetterhalf/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>
            
            mybetterhalf
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="Searching..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/01/操作系统真相还原 笔记2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">操作系统真相还原5-7章</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-07-01T11:13:00+08:00">
                2020-07-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="保护模式进阶，向内核迈进"><a href="#保护模式进阶，向内核迈进" class="headerlink" title="保护模式进阶，向内核迈进"></a>保护模式进阶，向内核迈进</h1><h2 id="获取物理内存容量"><a href="#获取物理内存容量" class="headerlink" title="获取物理内存容量"></a>获取物理内存容量</h2><p>在Linux 中有多种方法获取内存容量，如果一种方法失败，就会试用其他方法。比如在Linux 2.6 内核中，是用<strong>detect_memory</strong>函数来获取内存容量的。其函数<strong>在本质上是通过调用BIOS中断0x15 实现的</strong>，分别是BIOS 中断0x15 的3 个子功能，子功能号要存放到寄存器EAX 或AX 中，如下。</p>
<ul>
<li><code>EAX=0xE820</code>：遍历主机上全部内存。</li>
<li><code>AX=0xE801</code>：分别检测低 15MB 和16MB～4GB 的内存，最大支持4GB。</li>
<li><code>AH=0x88</code>：最多检测出64MB 内存，实际内存超过此容量也按照64MB 返回。</li>
</ul>
<p><strong>BIOS 中断是实模式下的方法，只能在进入保护模式前调用</strong>。获取内存信息，其内部是通过<strong>连续调用硬件的应用程序接口</strong>来获取内存信息的。BIOS 0x15 中断提供了丰富的功能，具体要调用的功能，需要<strong>在寄存器ax 中指定</strong>。其中<strong>0xE8xx</strong>系列的子功能较为强大，0x15 中断的子功能0xE820 和0xE801 都可以用来获取内存，区别是0xE820 返回的是内存布局；而0xE801 直接返回的是内存容量。</p>
<p>BIOS 中断 <strong>0x15 的子功能0xE820 能够获取系统的内存布局</strong>，BIOS按照类型属性来划分这片系统内存，所以这种查询呈迭代式，每次BIOS 只返回一种类型的内存信息，直到将所有内存类型返回完毕。<strong>子功能0xE820 的强大之处是返回的内存信息较丰富，包括多个属性字段</strong>，内存信息的内容是用地址范围描述符来描述的，用于存储这种描述符的结构称之为地址范围描述符ARDS。。每次int 0x15 之后，BIOS就返回这样一个20个字节的数据。<br><img src="/img/1593617828.jpg" alt></p>
<p>其中的 Type 字段用来描述这段内存的类型，这里所谓的类型是说明这段内存的用途：</p>
<ul>
<li>AddressRangeMemory 这段内存可以被操作系统使用</li>
<li>AddressRangeReserved 内存使用中或者被系统保留，操作系统不可以用此内存</li>
<li>其他 将来会用到，目前保留。</li>
</ul>
<p>BIOS 中断只是一段函数例程，调用它就要为其提供参数：</p>
<ul>
<li>调用前输入<ul>
<li>EAX 子功能号：EAX 寄存器用来指定子功能号，此处输入为0xE820</li>
<li>EBX ARDS 后续值：内存信息需要按类型分多次返回，由于每次执行一次中断都只返回一种类型内存的ARDS 结构，所以要记录下一个待返回的内存ARDS，在下一次中断调用时通过此值告诉BIOS 该返回哪个ARDS，这就是后续值的作用。第一次调用时一定要置为0，EBX具体值我们不用关注，字取决于具体BIOS 的实现。每次中断返回后，BIOS 会更新此值</li>
<li>ES：DI ARDS缓冲区：BIOS 将获取到的内存信息写入此寄存器指向的内存，每次都以ARDS 格式返回</li>
<li>ECX ARDS 结构的字节大小：用来指示BIOS 写入的字节数。调用者和BIOS 都同时支持的大小是20 字节，将来也许会扩展此结构</li>
<li>EDX 固定为签名标记0x534d4150，此十六进制数字是字符串SMAP 的ASCII 码：BIOS 将调用者正在请求的内存信息写入ES：DI 寄存器所指向的ARDS 缓冲区后，再用此签名校验其中的信息</li>
</ul>
</li>
<li>返回后输出：<ul>
<li>CF 位若 CF 位为0 表示调用未出错，CF 为1，表示调用出错</li>
<li>EAX 字符串SMAP 的ASCII 码0x534d4150</li>
<li>ES:DI ARDS 缓冲区地址，同输入值是一样的，返回时此结构中已经被BIOS 填充了内存信息</li>
<li>CX BIOS 写入到ES:DI 所指向的ARDS 结构中的字节数，BIOS 最小写入20 字节</li>
<li>EBX 后续值：下一个ARDS 的位置。每次中断返回后，BIOS 会更新此值，BIOS 通过此值可以找到下一个待返回的ARDS 结构，咱们不需要改变EBX 的值，下一次中断调用时还会用到它。在CF 位为0 的情况下，若返回后的EBX 值为0，表示这是最后一个ARDS 结构</li>
</ul>
</li>
</ul>
<p>另一个获取内存容量的方法是BIOS0x15 中断的子功能0xE801。此方法最大只能识别4GB内存，此方法检测到的内存是分别存放到两组寄存器中的。低于15MB 的内存以1KB 为单位大小来记录，单位数量在寄存器AX 和CX 中记录，所以15MB 空间以下的<code>实际内存容量=AX*1024</code>。AX、CX 最大值为0x3c00，即<code>0x3c00*1024=15MB</code>。16MB～4GB是以64KB 为单位大小来记录的，单位数量在寄存器BX 和DX 中记录，所以16MB 以上空间的<code>内存实际大小=BX*64*1024</code>。</p>
<ul>
<li>调用前输入 <ul>
<li>AX：Function Code，子功能号：0xE801</li>
<li>CF位：Carry Flag， 若CF 位为0 表示调用未出错，CF 为1，表示调用出错</li>
<li>AX：Extended 1， 以1KB 为单位，只显示15MB 以下的内存容量，故最大值为0x3c00，即AX 表示的最大内存为0x3c00*1024=15MB</li>
<li>BX： Extended 2， 以64KB 为单位，内存空间16MB～4GB 中连续的单位数量，即内存大小为BX<em>64</em>1024 字节</li>
<li>CX： Configured 1， 同AX</li>
</ul>
</li>
<li>返回后输出<ul>
<li>DX： Configured 2， 同BX</li>
</ul>
</li>
</ul>
<p>最后一个获取内存的方法也同样是<strong>BIOS 0x15 中断，子功能号是0x88</strong>。该方法简单到只能识别最大64MB 的内存。即使内存容量大于64MB，也只会显示63MB，只会显示1MB之上的内存，不包括这1MB。</p>
<h2 id="启用内存分页机制，畅游虚拟空间"><a href="#启用内存分页机制，畅游虚拟空间" class="headerlink" title="启用内存分页机制，畅游虚拟空间"></a>启用内存分页机制，畅游虚拟空间</h2><p>CPU 在引用一个段时，都要先查看段描述符。<strong>CPU 允许在描述符表中已注册的段不在内存中存在</strong>，这就是它提供给软件使用的策略，我们利用它实现段式内存管理。</p>
<ul>
<li><strong>如果该描述符中的P 位为1，表示该段在内存中存在。访问过该段后，CPU 将段描述符中的A 位置1，表示近来刚访问过该段</strong>。</li>
<li>相反，如果P 位为0，说明内存中并不存在该段，CPU将会抛出异常，转而去执行中断处理程序将相应的段从外存中载入到内存，并将段描述符的P 位置1，中断处理函数结束后返回，CPU 重复执行这个检查，继续查看该段描述符的P 位，此时已经为1 了，在检查通过后，将段描述符的A 位置1。</li>
</ul>
<p>首先要做的是解除线性地址与物理地址一一对应的关系，然后将它们的关系重新建立。通过某种映射关系，可以将线性地址映射到任意物理地址。对于地址转换这种实时性较高的需求，通过一张表来实现，该表就是我们所说的页表。</p>
<p><strong>将段基址和段内偏移地址相加求和的工作是由CPU 的段部件自动完成的</strong>。整个访问内存的过程如图5-6 所示。分页机制要建立在分段机制的基础上。图 5-7 说明，<strong>CPU 在不打开分页机制的情况下，是按照默认的分段方式进行的</strong>，段基址和段内偏移地址经过段部件处理后所输出的线性地址，CPU 就认为是物理地址。<strong>如果打开了分页机制，段部件输出的线性地址就不再等同于物理地址了，我们称之为虚拟地址</strong>，CPU 必须要拿到物理地址才行，此虚拟地址对应的物理地址需要在页表中查找，这项查找工作是由页部件自动完成的。<br><img src="/img/1593620340.jpg" alt></p>
<p><strong>分页机制的思想是：通过映射，可以使连续的线性地址与任意物理内存地址相关联，逻辑上连续的线性地址其对应的物理地址可以不连续。</strong>分页机制的作用有两方面。</p>
<ul>
<li>将线性地址转换成物理地址。</li>
<li>用大小相等的页代替大小不等的段。</li>
</ul>
<p><img src="/img/1593620777.jpg" alt></p>
<p>上图表示的是一个进程的地址转换过程，从线性空间到虚拟空间再到物理地址空间，每个空间大小都是4GB。图上的4GB 物理地址空间属于所有进程包括操作系统在内的共享资源，其中标注为已分配页的内存块被分配给了其他进程，当前进程只能使用未分配页。此转换过程对任意一个进程都是一样的，也就是说，每个进程都有自己的4GB 虚拟空间。</p>
<p>在分页机制下，分配情形如图中所示的虚拟地址空间中的代码段和数据段。<strong>代码段和数据段在逻辑上被拆分成以页为单位的小内存块</strong>。这时的虚拟地址虚如其名，不能存放任何数据。接着操作系统开始为这些虚拟内存页分配真实的物理内存页，它查找物理内存中可用的页，然后<strong>在页表中登记这些物理页地址</strong>，这样就完成了虚拟页到物理页的映射，每个进程都以为自己独享4GB 地址空间。</p>
<p>线性地址对应物理地址的这种映射关系需要用<strong>页表</strong>（Page Table）存储。页表中的每一行（只有一个单元格）称为<strong>页表项</strong>（Page Table Entry，PTE），其大小是4字节，页表项的作用是<strong>存储内存物理地址</strong>。当访问一个线性地址时，实际上就是在访问页表项中所记录的物理内存地址。</p>
<p>页是地址空间的计量单位，线性地址的一页也要对应物理地址的一页。一页大小为4KB，这样一来，<strong>4GB地址空间被划分成4GB/4KB=1M 个页</strong>，也就是4GB 空间中可以容纳1048576 个页，页表中自然也要有1048576个页表项，这就是我们要说的一级页表。<br><img src="/img/1593682604.jpg" alt></p>
<p>经以上分析，<strong>虚拟地址的高20 位可用来定位一个物理页，低12 位可用来在该物理页内寻址</strong>。这是如何实现的呢？物理地址写在页表的页表项中，段部件输出的只是线性地址，所以问题就变成了：怎样用线性地址找到页表中对应的页表项。</p>
<p><strong>分页机制打开前要将页表地址加载到控制寄存器cr3中</strong>。一个页表项对应一个页，所以，用线性地址的高20 位作为页表项的索引，每个页表项要占用4 字节大小，所以这高20 位的索引乘以4 后才是该页表项相对于页表物理地址的字节偏移量。<strong>用cr3 寄存器中的页表物理地址加上此偏移量便是该页表项的物理地址</strong>，<strong>从该页表项中得到映射的物理页地址</strong>，然后<strong>用线性地址的低12 位与该物理页地址相加，所得的地址之和便是最终要访问的物理地址</strong>。拿<code>mov ax，[0x1234]</code>来说：<br><img src="/img/1593682860.jpg" alt></p>
<p>段基址为0，段内偏移地址为0x1234，经过段部件处理后，<strong>输出的线性地址是0x1234</strong>。页部件分析0x1234 的高20 位，用十六进制表示高20 位是0x00001。将此项作为页表项索引，再将该索引乘以4 后加上cr3 寄存器中页表的物理地址，这样便得到索引所指代的页表项的物理地址，从<strong>该物理地址处（页表项中）读取所映射的物理页地址：0x9000</strong>。线性地址的低12 位是0x234，它作为物理页的页内偏移地址与物理页地址0x9000 相加，和为<strong>0x9234</strong>，这就是线性地址0x1234 最终转换成的物理地址。</p>
<p>每个页表的物理地址在页目录表中都以<strong>页目录项</strong>（Page Directory Entry，PDE）的形式存储，页目录项大小同页表项一<br>样，<strong>都用来描述一个物理页的物理地址</strong>，其大小都是4字节，而且最多有1024 个页表，所以页目录表也是4KB 大小，同样也是标准页的大小。<br><img src="/img/1593683057.jpg" alt></p>
<p>页目录表中共1024 个页表，也就是有1024 个页目录项。<strong>一个页目录项中记录一个页表物理页地址</strong>，物理页地址是指页的物理地址，在页目录项及页表项中记录的都是页的物理地址。每个页表中有1024 个页表项，每个页表项中是一个物理页地址，最终数据写在这页表项中指定的物理页中。图中最粗的线存放页目录表物理页，稍细一点的线指向的是用来存放页表的物理页，其他最细的线是页表项中分配的物理页。</p>
<p>每个页表中可容纳1024个物理页，故每个页表可表示的内存容量是<code>1024*4KB=4MB</code>，所有页表可表示的内存容量是<code>1024*4MB=4GB</code>。页目录中1024 个页表，只需要10 位二进制就能够表示了，所以，<strong>虚拟地址的高10 位（第31～22 位）用来在页目录中定位一个页表，也就是这高10 位用于定位页目录中的页目录项PDE，PDE 中有页表物理页地址</strong>。由于页表中可容纳1024 个物理页，故只需要10 位二进制就能够表示了。所以<strong>虚拟地址的中间10 位（第21～12 位）用来在页表中定位具体的物理页</strong>。由于标准页都是4KB，12 位二进制便可以表达4KB 之内的任意地址，故<strong>线性地址中余下的12 位（第11～0 位）用于页内偏移量</strong>。二级页表地址转换原理是<strong>将32 位虚拟地址拆分成高10 位、中间10 位、低12 位三部分</strong>，</p>
<p>同一级页表一样，访问任何页表内的数据都要通过物理地址。由于页目录项PDE 和页表项PTE 都是4 字节大小，给出了PDE 和PTE 索引后，还需要在背后悄悄乘以4，再加上页表物理地址，这才是最终要访问的绝对物理地址。转换过程背后的具体步骤如下。</p>
<ul>
<li>用虚拟地址的高10 位乘以4，作为页目录表内的偏移地址，加上页目录表的物理地址，所得的和，便是页目录项的物理地址。读取该页目录项，从中获取到页表的物理地址。</li>
<li>用虚拟地址的中间10 位乘以4，作为页表内的偏移地址，加上在第1 步中得到的页表物理地址，所得的和，便是页表项的物理地址。读取该页表项，从中获取到分配的物理页地址。</li>
<li>虚拟地址的高10 位和中间10 位分别是PDE 和PTE 的索引值，所以它们需要乘以4。但低12 位就不是索引值啦，其表示的范围是0～0xfff，作为页内偏移最合适，所以虚拟地址的低12 位加上第2 步中得到的物理页地址，所得的和便是最终转换的物理地址。</li>
</ul>
<p>比如 mov ax，[0x1234567]：<br><img src="/img/1593698361.jpg" alt></p>
<p>指令mov ax，[0x1234567]经过段部件处理，输出的线性地址为0x1234567，页部件首先要把地址拆分成高10位、中间10 位、低12 位三部分。其实低12 位最容易得出，十六进制的每1 位代表4 位二进制，所以低12 位直接就是0x567。</p>
<ul>
<li>高 10 位是0000 0001 00，十六进制为0x4。</li>
<li>中间 10 位是10 0011 0100，十六进制为0x234。</li>
<li><p>低 12 位是0101 0110 0111，十六进制为0x567。</p>
</li>
<li><p>第一步：为了得到页表物理地址，页部件用<strong>虚拟地址高 10 位乘以4 的积与页目录表物理地址相加，所得的和便是页目录项地址</strong>，读取该页目录项，获取页表物理地址。这里是0x4*4=0x10，页表物理地址存储在cr3寄存器中。要找的页表位于物理地址0x1000。</p>
</li>
<li>第二步：为了得到具体的物理页，需要找到页表中对应的页表项。页部件用<strong>虚拟地址中间 10 位的值乘以4 的积与第一步中得到的页表地址相加，所得的和便是页表项物理地址</strong>。这里是<code>0x234*4=0x8d0</code>，页表项物理地址是<code>0x8d0+0x1000=0x18d0</code>。在该页表项中的值是0xfa000，这意味着分配的物理页地址是0xfa000。</li>
<li>第三步：为了得到最终的物理地址，用<strong>虚拟地址低12 位作为页内偏移地址与第二步中得到的物理页地址相加</strong>，所得的和便是最终的物理地址。这里是<code>0xfa000+0x567=0xfa567</code>。</li>
</ul>
<p>页目录项和页表项是4 字节大小，用来存储物理页地址，只有第12～31位才是物理地址，地址的低12位是0，所以只需要记录物理地址高20 位。其他位：</p>
<ul>
<li>P，Present，意为存在位。若为1 表示该页存在于物理内存中，若为0 表示该表不在物理内存中。</li>
<li>RW，Read/Write，意为读写位。若为1 表示可读可写，若为0 表示可读不可写。</li>
<li>US，User/Supervisor，意为普通用户/超级用户位。若为1 时，表示处于User 级，任意级别（0、1、2、3）特权的程序都可以访问该页。若为0，表示处于Supervisor 级，特权级别为3 的程序不允许访问该页，该页只允许特权级别为0、1、2 的程序可以访问。</li>
<li>PWT，Page-level Write-Through，意为页级通写位，也称页级写透位。若为1 表示此项采用通写方式，表示该页不仅是普通内存，还是高速缓存。</li>
<li>PCD，Page-level Cache Disable，意为页级高速缓存禁止位。若为1 表示该页启用高速缓存，为0 表示禁止将该页缓存。这里咱们将其置为0。</li>
<li>A，Accessed，意为访问位。若为1 表示该页被CPU 访问过，A 位也可以用来记录某一内存页的使用频率</li>
<li>D，Dirty，意为脏页位。当CPU 对一个页面执行写操作时，就会设置对应页表项的D 位为1。此项仅针对页表项有效，并不会修改页目录项中的D 位。</li>
<li>PAT，Page Attribute Table，意为页属性表位，能够在页面一级的粒度上设置内存属性。比较复杂，将此位置0 即可。</li>
<li>G，Global，意为全局位。将虚拟地址与物理地址转换结果存储在TLB（Translation Lookaside Buffer）中。此G 位用来指定该页是否为全局页，为1 表示是全局页，为0 表示不是全局页。若为全局页，该页将在高速缓存TLB 中一直保存，给出虚拟地址直接就出物理地址。</li>
<li>AVL，意为Available 位，表示可用，谁可以用？当然是软件，操作系统可用该位，CPU 不理会该位的值，那咱们也不理会吧。</li>
</ul>
<p>控制寄存器cr3 用于存储页表物理地址，所以cr3 寄存器又称为页目录基址寄存器（Page Directory Base Register，PDBR）。只要在cr3 寄存器的第31～12 位中写入物理地址的高20 位就行了。另外，cr3 寄存器的低12 位中，除第3 位的PWT 位和第4 位的PCD 位外，其余位都没用。启动分页机制的开关是将控制寄存器cr0 的PG 位置1，PG 位是cr0 寄存器的最后一位：第31 位。</p>
<p>处理器准备了一个高速缓存，可以匹配高速的处理器速率和低速的内存访问速度，它专门用来存放虚拟地址页框与物理地址页框的映射关系，这个调整缓存就是TLB，即Translation Lookaside Buffer，俗称快表。TLB 中的条目是虚拟地址的高20 位到物理地址高20 位的映射结果，实际上就是从虚拟页框到物理页框的映射。除此之外TLB中还有一些属性位，比如页表项的RW 属性。</p>
<p>有两种方法可以间接更新TLB，一个是针对TLB 中所有条目的方法—重新加载CR3，比如将CR3 寄存器的数据读出来后再写入CR3，这会使整个TLB 失效。另一个方法是针对TLB 中某个条目的更新。处理器提供了指令invlpg（invalidate page），它用于在TLB 中刷新某个虚拟地址对应的条目，处理器是用虚拟地址来检索TLB 的，因此很自然地，指令invlpg 的操作数也是虚拟地址，其指令格式为invlpg m。</p>
<h2 id="加载内核"><a href="#加载内核" class="headerlink" title="加载内核"></a>加载内核</h2><p>ELF 目标文件归纳见:<br><img src="/img/1593710779.jpg" alt></p>
<p>程序中最重要的部分就是<strong>段（segment）和节（section）</strong>，它们是真正的程序体，程序中有很多段，如代码段和数据段等，同样也有很多节，段是由节来组成的，<strong>多个节经过链接之后就被合并成一个段了</strong>，段和节的信息也是用 header 来描述的，程序头是program header，节头是section header。程序中段的大小和数量是不固定的，节的大小和数量也不固定，用程序头表（program header table）和节头表（section header table）描述。这两个表相当于数组，数组元素分别是程序头program header 和节头section header。在表中，每个成员（数组元素）都统称为条目，即 entry，一个条目代表一个段或一个节的头描述信息。对于程序头表，它本质上就是用来描述段（segment）的，所以您也可以称它为段头表。ELF header 是个用来描述各种“头”的“头”，程序头表和节头表中的元素也是程序头和节头。<br><img src="/img/1593711197.jpg" alt></p>
<p>无论是在待重定位文件，还是可执行文件中，文件最开头的部分必须是elf header。在ELF header之后紧挨着的是程序头表，这对于可执行文件是必须存在的，而对于待重定位文件是可选的。其他成员的位置要取决于各头表中的说明。</p>
<p>一些重要的数据结构中用到了自定义的数据类型：<br><img src="/img/1593711313.jpg" alt></p>
<p>C 语言中的结构体能够很直观地表示物理内存结构：<br><img src="/img/1593711357.jpg" alt></p>
<ul>
<li><p>e_ident[16]是16 字节大小的数组，用来表示elf 字符等信息，开头的4 个字节是固定不变的，是elf 文件的魔数，它们分别是0x7f，以及字符串ELF 的ascii码：0x45, 0x4c, 0x46。<br><img src="/img/1593740354.jpg" alt></p>
</li>
<li><p>e_type 占用2 字节，是用来指定elf 目标文件的类型，，ET_LOPROC和ET_HIPROC 这两个类型的取值跨度好大，显得似乎有些怪异，其实把它们搞得如此怪异，是为了突显它们的“与众不同”，它们是与硬件相关的参数，在它们之间的取值用来标识与处理器相关的文件格式。<br><img src="/img/1593740513.jpg" alt></p>
</li>
<li><p>e_machine 占用2 字节，用来描述elf 目标文件的体系结构类型，也就是说该文件要在哪种硬件平台（哪种机器）上才能运行。<br><img src="/img/1593740580.jpg" alt></p>
</li>
<li><p>e_version 占用4 字节，用来表示版本信息。</p>
</li>
<li>e_entry 占用4 字节，用来指明操作系统运行该程序时，将控制权转交到的虚拟地址。</li>
<li>e_phoff 占用4 字节，用来指明程序头表（program header table）在文件内的字节偏移量。如果没有程序头表，该值为0。</li>
<li>e_shoff 占用4 字节，用来指明节头表（section header table）在文件内的字节偏移量。若没有节头表，该值为0。</li>
<li>e_flags 占用4 字节，用来指明与处理器相关的标志</li>
<li>e_ehsize 占用2 字节，用来指明elf header 的字节大小。</li>
<li>e_phentsize 占用2 字节，用来指明程序头表（program header table）中每个条目（entry）的字节大小，即每个用来描述段信息的数据结构的字节大小，该结构是后面要介绍的struct Elf32_Phdr。</li>
<li>e_phnum 占用2 字节，用来指明程序头表中条目的数量。实际上就是段的个数。</li>
<li>e_shentsize 占用2 字节，用来指明节头表（section header table）中每个条目（entry）的字节大小，即每个用来描述节信息的数据结构的字节大小。</li>
<li>e_shnum 占用2 字节，用来指明节头表中条目的数量。实际上就是节的个数。</li>
<li>e_shstrndx 占用2 字节，用来指明string name table 在节头表中的索引index。</li>
</ul>
<p>程序头表中的条目的数据结构，这是用来描述各个段的信息用的，此段是指程序中的某个数据或代码的区域段落：<br><img src="/img/1593741243.jpg" alt></p>
<ul>
<li>p_type 占用4 字节，用来指明程序中该段的类型。</li>
<li>p_offset 占用4 字节，用来指明本段在文件内的起始偏移字节。</li>
<li>p_vaddr 占用4 字节，用来指明本段在内存中的起始虚拟地址。</li>
<li>p_paddr 占用4 字节，仅用于与物理地址相关的系统中，因为System V 忽略用户程序中所有的物理地址，所以此项暂且保留，未设定。</li>
<li>p_filesz 占用4 字节，用来指明本段在文件中的大小。</li>
<li>p_memsz 占用4 字节，用来指明本段在内存中的大小。</li>
<li>p_flags 占用4 字节，用来指明与本段相关的标志，本段具有可执行权限、可写权限、可读权限、与操作系统相关、处理器相关</li>
<li>p_align 占用4 字节，用来指明本段在文件和内存中的对齐方式。如果值为0 或1，则表示不对齐。否则p_align 应该是2 的幂次数。</li>
</ul>
<p>通过 dd 命令往磁盘上写，命令如下。<code>dd if= kernel.bin of=/your_path/hd60M.img bs=512 count=200 seek=9 conv=notrunc</code>，seek 为9，目的是跨过前9 个扇区（第0～8 个扇区），我们在第9 个扇区写入。count 为200，目的是一次往参数of 指定的文件中写入200 个扇区。</p>
<h2 id="特权级深入浅出"><a href="#特权级深入浅出" class="headerlink" title="特权级深入浅出"></a>特权级深入浅出</h2><p>操作系统位于最内环的0 级特权，它要直接控制硬件，掌控各种核心数据，所以它的权利必须最大。系统程序分别位于<br>1 级特权和2 级特权，运行在这两层的程序一般是虚拟机、驱动程序等系统服务。在最外层的是3 级特权，我们的用户程序<br>就运行在此层，用户程序被设计为“有需求时找操作系统”，所以它不需要太大的能力，能完成一般工作即可，因此它的权利最弱。</p>
<p>TSS，即Task State Segment，意为任务状态段，它是处理器在硬件上原生支持多任务的一种实现方式，TSS 是一种数据结构，它用于存储任务的环境。TSS 是每个任务都有的结构，它用于一个任务的标识，程序拥有此结构才能运行。<br><img src="/img/1593755336.jpg" alt></p>
<p>任务在特权级变换时，本质上<strong>是处理器的当前特权级在变换</strong>，由一个特权级变成了另外一个特权级。处理器在不同特权级下，应该<strong>用不同特权级的栈</strong>，原因是如果在同一个栈中容纳所有特权级的数据时，这种交叉引用会使栈变得非常混乱，并且，用一个栈容纳多个特权级下的数据，栈容量有限，这很容易溢出。</p>
<p>特权级转移分为两类，一类是由<strong>中断门、调用门等手段实现低特权级转向高特权级</strong>，另一类则相反，是由<strong>调用返回指令从高特权级返回到低特权级</strong>，这是唯一一种能让处理器降低特权级的情况。</p>
<ul>
<li>对于特权级由低到高的情况，<strong>由于不知道目标特权级对应的栈地址在哪里，所以要提前把目标栈的地址记录在某个地方</strong>，当处理器向高特权级转移时再从中取出来加载到SS 和ESP 中以更新栈，这个保存的地方就是TSS。处理器会自动地从TSS 中找到对应的高特权级栈地址。也就是说，<strong>除了调用返回外，处理器只能由低特权级向高特权级转移</strong>，TSS 中所记录的栈是转移后的高特权级目标栈，所以它一定比当前使用的栈特权级要高，只用于向更高特权级转移时提供相应特权的栈地址。</li>
</ul>
<p>所以，TSS 中不需要记录3 特权级的栈，因为3 特权级是最低的，没有更低的特权级会向它转移。<strong>不是每个任务都有4 个栈，一个任务可有拥有的栈的数量取决于当前特权级是否还有进一步提高的可能</strong>，即取决于它最低的特权级别。比如3 特权级的程序，它是最低的特权级，还能提升三级，所以可额外拥有2、1、0 特权级栈，用于将特权分别转移到2、1、0 级时使用。</p>
<p>对于由高特权返回到低特权级的情况，处理器是不需要在TSS 中去寻找低特权级目标栈的。TSS 中只记录2、1、0 特权级的栈，而且，低特权级栈的地址其实已经存在了，这是由处理器的向高特权级转移指令（如int、call 等）实现的机制决定的。</p>
<p>当处理器由低向高特权级转移时，它<strong>自动地把当时低特权级的栈地址（SS 和ESP）压入了转移后的高特权级所在的栈中</strong>，所以，当用返回指令如retf 或iret 从高特权级向低特权级返回时，处理器可以从当前使用的高特权级的栈中获取低特权级的栈段选择子及偏移量。当下次处理器再进入到高特权级时，它依然会在 TSS 中寻找对应的高特权级栈，而TSS 中栈指针值都是固定的，每次进入高特权级都会重复使用它们。</p>
<p>TSS 是硬件支持的系统数据结构，它和GDT 等一样，由软件填写其内容，由硬件使用。GDT 也要加载到寄存器GDTR 中才能被处理器找到，TSS 也是一样，它是由TR（Task Register）寄存器加载的，每次处理器执行不同任务时，将TR 寄存器加载不同任务的TSS 就成了。</p>
<p>计算机特权级的标签体现在DPL、CPL 和RPL，在 CPU 中运行的是指令，其运行过程中的指令总会属于某个代码段，该代码段的特权级，也就是<strong>代码段描述符中的DPL，便是当前CPU 所处的特权级</strong>，这个特权级称为<strong>当前特权级</strong>，即CPL（Current Privilege Level），它表示处理器正在执行的代码的特权级别。<strong>当前特权级实际上是指处理器当前所处的特权级</strong>，是指处理器的特权角色，在任意时刻，当前特权级CPL 保存在CS 选择子中的RPL 部分。</p>
<p>代码是资源的请求者，<strong>代码段寄存器CS所指向的是处理器中当前运行的指令，所以代码段寄存器CS 中选择子的RPL 位称为当前特权级CPL</strong>，<strong>只是代码段寄存器CS 中的RPL 是CPL，其他段寄存器中选择子的RPL 与CPL 无关</strong>，因为CPL 是针对具有“能动性”的访问者（执行者）来说的，代码是执行者，它表示访问的请求者，所以CPL 只存放在代码段寄存器CS 中低2 位的RPL 中。</p>
<p>DPL，即Descriptor Privilege Level，描述符特权级，DPL 字段在段描述符中占2位，表示4 个组合，00b、01b、10b、11b，所有特权级都齐了。<strong>DPL 是段描述符所代表的内存区域的“门槛”权限，访问者能否迈过此门槛访问到本描述符所代表的资源，其特权级至少要等于这个门槛</strong>。</p>
<p>对于受访者为数据段（段描述符中 type 字段中未有X 可执行属性）来说：<strong>只有访问者的权限大于等于该DPL 表示的最低权限才能够继续访问，否则连这个门槛都迈不过去</strong>。对于受访者为代码段（段描述符中 type 字段中含有X 可执行属性）来说：<strong>只有访问者的权限等于该DPL 表示的最低权限才能够继续访问</strong>，CPU 没有理由先自降等级后再去做某事。</p>
<p><strong>处理器从中断处理程序中返回到用户态的时候</strong>是唯一一种处理器会从高特权降到低特权运行的情况。<strong>中断处理都是在 0 特权级下进行的</strong>，因为中断的发生多半是外部硬件发生了某种状况或发生了某种不可抗力事件而必须要通知CPU 导致的，所以，在中断的处理过程中需要具备访问硬件的能力。再者，<strong>有些中断处理中需要的指令只能在0 特权级下使用，这部分指令称为特权指令</strong>。除了从中断处理过程返回外，任何时候CPU 都不允许从高特权级转移到低特权级。比目标代码段特权级低的访问者也会被拒绝访问目标代码段。综上所述，<strong>对于受访问者为代码段的情况，只能是平级访问</strong>。</p>
<p>一致性代码段也称为<strong>依从代码段</strong>，Conforming，<strong>用来实现从低特权级的代码向高特权级的代码转移</strong>。<strong>一致性代码段是指如果自己是转移后的目标段，自己的特权级（DPL）一定要大于等于转移前的CPL</strong>，即数值上<code>CPL≥DPL</code>，也就是一致性代码段的DPL 是权限的上限，任何在此权限之下的特权级都可以转到此代码段上执行。</p>
<p>该关系用公式表示如下：在数值上，<code>CPL≥一致性代码段的DPL</code>，一致性代码段的一大特点是<strong>转移后的特权级不与自己的特权级（DPL）为主，而是与转移前的低特权级一致，听从、依从转移前的低特权级</strong>，这就是它称为“依从、一致”的原因。</p>
<p>顺便说一句，代码段可以有一致性和非一致性之分，但所有的数据段总是非一致的，即数据段不允许被比本数据段特权级更低的代码段访问。</p>
<p>处理器只有通过“门结构”才能由低特权级转移到高特权级，是记录一段程序起始地址的描述符。<strong>门结构是记录一段程序起始地址的描述符</strong>。有一种称为“门描述符”的结构，用来描述一段程序。进入这种神奇的“门”，处理器便能转移到更高的特权级上。<br>门描述符同段描述符类似，都是 8 字节大小的数据结构，用来描述门中通向的代码。<br><img src="/img/1593760525.jpg" alt><br><img src="/img/1593760544.jpg" alt></p>
<p>除了任务门外，其他三种门都是对应到一段例程，即对应一段函数，而不是像段描述符对应的是一片内存区域。任务门描述符可以放在GDT、LDT 和IDT中，调用门可以位于GDT、LDT 中，中断门和陷阱门仅位于IDT 中。</p>
<p><strong>任务门、调用门都可以用call 和jmp 指令直接调用</strong>，原因是这两个门描述符都位于描述符表中，要么是GDT，要么是LDT，访问它们同普通的段描述符是一样的，也必须要通过选择子，因此只要在call 或jmp 指令后接任务门或调用门的选择子便可调用它们了。<strong>陷阱门和中断门只存在于IDT 中，因此不能主动调用，只能由中断信号来触发调用</strong>。任务门有点特殊，它用任务TSS 的描述符选择子来描述一个任务。</p>
<ol>
<li>调用门：call 和jmp 指令后接调用门选择子为参数，以调用函数例程的形式实现从低特权向高特权转移，可用来实现系统调用。call 指令使用调用门可以实现向高特权代码转移，jmp 指令使用调用门只能实现向平级代码转移。</li>
<li>中断门：以 int 指令主动发中断的形式实现从低特权向高特权转移，Linux 系统调用便用此中断门实现，就是那个著名的int 0x80。中断门只允许存在于IDT 中。</li>
<li>陷阱门：以 int3 指令主动发中断的形式实现从低特权向高特权转移，这一般是编译器在调试时用</li>
<li>任务门：任务以任务状态段TSS 为单位，用来实现任务切换，它可以借助中断或指令发起。当中断发生时，如果对应的中断向量号是任务门，则会发起任务切换。也可以像调用门那样，用call 或jmp 指令后接任务门的选择子或任务TSS 的选择子。</li>
</ol>
<p>门的“门槛”是访问者特权级的下限，访问者的特权级再低也不能比门描述符的特权级DPL 低，否则访问者连门都进不去，更谈不上使用调用门。门描述符的DPL 特权级要低于或等于当前特权级CPL，即<strong>数值上CPL≤门的DPL</strong>，此处可见，门描述符相当于数据段描述符一样，只允许比自己特权级高或相同特权级的程序访问。</p>
<p>门的“门框”是访问者特权级的上限，访问者的特权级再高也不能比门描述符中目标程序所在代码段的DPL 高。门中包含的目标程序所在的段的特权级DPL 要高于或等于当前特权级CPL，即数值上CPL≥目标代码段DPL，进门之后，处理器将以目标代码段DPL 为当前特权级CPL。</p>
<p><strong>各种门结构存在的目的就是为了让处理器提升特权级，这样处理器才能够做一些低特权级下无法完成的工作</strong>。调用门是一个描述符，称为门描述符，其中记录的是内核服务程序所在代码段的选择子及在代码段中的偏移地址。<strong>门描述符定义在全局描述符表GDT 和局部描述符表LDT 中</strong>，所以，要想使用调用门，就要通过门描述符的选择子。</p>
<p><img src="/img/1593792617.jpg" alt></p>
<ul>
<li>在用户程序中有一句代码<code>call 调用门选择子</code>，call 指令可以使用调用门，参数就是调用门的选择子，该选择子指向GDT 或LDT 中的某个门描述符，不管选择子中的TI 位是0，还是1，我们暂且认为它是指向GDT 中的调用门。处理器用门描述符选择子的高13 位（索引位）乘以8 作为该描述符在GDT 中的偏移量，再加上寄存器GDTR 中的GDT 基地址，最终找到了门描述符的地址，它位于GDT中从0 起的第3 个描述符位置。</li>
<li>在该描述符中记录的是内核例程的地址。我们知道，在保护模式下描述某个内存地址是离不开选择子和偏移量的，所以，门描述符中记录的是内核例程所在代码段的选择子及偏移量。处理器再用代码段选择子，重复之前的步骤，用选择子中高13位的索引值乘以8，再加上GDT 基址，所得到的地址为该代码段选择子所指向的内核代码段描述符地址，在该内核代码段描述符中找到内核代码段基址，用它加上门描述符中记录的内核例程在代码段中的偏移量，最终得到内核例程的起始地址。</li>
</ul>
<p>为了方便软件开发人员，<strong>处理器在固件上实现参数的自动复制</strong>，即，将用户进程压在3 特权级栈中的参数自动复制到0 特权级栈中。所以，在图中，其高32 位的起始处有个<strong>参数个数</strong>，这是处理器将用户提供的参数复制给内核时需要用到的，参数在栈中的顺序是挨着的，所以处理器只需要知道复制几个参数就行了，这就是调用门描述符中“参数个数”的作用，它是专门给处理器准备的。该位是用5 个BIT 来表示的，所以最多可传递31 个参数。</p>
<p>调用门可以用call 指令和jmp 指令调用，jmp 属于一去不回头的指令，基本上用在不需要从调用门返回的场合。call 指令由于会在栈中留下返回地址，所以在执行retf 指令时还能返回。</p>
<h3 id="调用门的过程保护"><a href="#调用门的过程保护" class="headerlink" title="调用门的过程保护"></a>调用门的过程保护</h3><p>假设用户进程要调用某个调用门，该门描述符中参数的个数是2，也就是用户进程需要为该调用门提供2 个参数才行。调用前的当前特权级为3，调用后的新特权级为0，所以调用门转移前用的是3 特权级栈，调用后用的是0 特权级栈。</p>
<ul>
<li>现在为此调用门提供2个参数，这是在使用调用门前完成的，目前是在3 特权级，所以要在特权级栈中压入参数，分别是参数1 和参数2</li>
<li>在这一步骤中要确定新特权级使用的栈，<strong>新特权级就是未来的CPL，它就是转移后的目标代码段的DPL</strong>。所以，根据门描述符中选择子对应的目标代码段的DPL，<strong>处理器自动在TSS 中找到合适的栈段选择子SS 和栈指针ESP，它们作为转移后新的栈</strong>，记作SS_new、ESP_new。</li>
<li>检查新栈段选择子对应的描述符的DPL 和TYPE，如果未通过检查则处理器引发异常。</li>
<li>如果转移后的目标代码段DPL 比CPL 要高，说明栈段选择子SS_new 是特权级更高的栈，这说明需要特权级转换，需要切换到新栈，将旧栈段选择子记作SS_old，旧栈指针记作ESP_old。<strong>由于转移前的旧栈段选择子SS_old 及指针ESP_old 得保存到新栈中，这样在高特权级的目标程序执行完成后才能通过retf 指令恢复旧栈</strong>。将SS_new 加载到栈段寄存器SS，esp_new 加载到栈指针寄存器esp，这样便启用了新栈。</li>
<li>在使用新栈后，将上一步中临时保存的SS_old 和ESP_old 压入到当前新栈中，也就是0 特权级栈。由于咱们讨论的是32 位模式，故栈操作数也是32 位，SS_old 只是16 位数据，将其高16 位用0 填充后入栈保存。</li>
</ul>
<p><img src="/img/1593828572.jpg" alt></p>
<ul>
<li>在这一步中要将用户栈中的参数复制到转移后的新栈中，根据调用门描述符中的“参数个数”决定复制几个参数。</li>
<li>由于调用门描述符中记录的是目标程序所在代码段的选择子及偏移地址，这意味着<strong>代码段寄存器CS要用该选择子重新加载</strong>，只要段寄存器被加载，段描述符缓冲寄存器就会被刷新，从而相当于切换到了新段上运行，这是<strong>段间远转移</strong>，所以需要将当前代码段CS 和EIP 都备份在栈中，这两个值分别记作CS_old 和EIP_old，由于CS_old 只是16 位数据，在32 位模式下栈操作数大小是32 位，故将其高16 位用0 填充后再入栈。这两个值是将来恢复用户进程的关键，也就是从内核进程中返回时用的地址。</li>
<li>一切就绪，只差运行调用门中指向的程序啦，于是，把门描述符中的代码段选择子装载到代码段寄存器CS，把偏移量装载到指令指针寄存器EIP。</li>
</ul>
<p>下面是利用 retf 指令从调用门返回的过程：</p>
<ul>
<li>当处理器执行到retf 指令时，它知道这是远返回，所以需要<strong>从栈中返回旧栈的地址及返回到低特权级的程序中</strong>。这时候它要进行特权级检查。先检查栈中CS选择子，根据其RPL位，即未来的CPL，判断在返回过程中是否要改变特权级。</li>
<li>此时栈顶应该指向栈中的EIP_old。在此步骤中获取栈中CS_old 和EIP_old，<strong>根据该CS_old 选择子对应的代码段的DPL 及选择子中的RPL 做特权级检查</strong>，规则不再赘述。如果检查通过，先从栈中弹出32 位数据，即EIP_old 到寄存器EIP，然后再弹出32 位数据CS_old，此时要临时处理一下，由于所有的段寄存器都是16 位的，当然包括CS，所以丢弃CS_old 的高16 位，将低16 位加载到CS 寄存器。此时栈指针ESP_new 指向最后一个参数。</li>
<li>如果返回指令retf 后面有参数，则增加栈指针ESP_new 的值，以跳过栈中参数，retf 后面的参数应该等于参数个数*参数大小。此时，栈指针ESP_new 便指向ESP_old。</li>
<li>如果在第1 步中判断出需要改变特权级，从栈中弹出32 位数据ESP_old 到寄存器ESP。同样寄存器 SS 也是16 位的，故再弹出32 位的SS_old，只将其低16 位加载到寄存器SS，此时恢复了旧栈。相当于丢弃寄存器SS 和ESP 中原有的SS_new 和ESP_new。</li>
</ul>
<p>RPL，Request Privilege Level，请求特权级，代表真正请求者的特权级，其实是代表真正资源需求者的CPL。<strong>在请求某特权级为DPL 级别的资源时，参与特权检查的不只是CPL，还要加上RPL</strong>，<strong>CPL 和RPL的特权必须同时大于等于受访者的特权DPL，即：数值上 CPL≥DPL 并且RPL≤DPL</strong></p>
<p>RPL 引入的目的是避免低特权级的程序访问高特权级的资源。<strong>DPL 相当于权限的门槛，它代表进入本描述符所对应内存区域的最低权限，任何想迈过这个门槛的人，它的RPL 和CPL 权限必须都要大于等于DPL，即数值上CPL≤DPL &amp;&amp; RPL≤DPL</strong>。用来检查当前请求者和真正的资源需求方是否都具有访问受访者的资格。处理器的特权检查，都是只发生在往段寄存器中加载选择子访问描述符的那一瞬间，所以，RPL 放在选择子中是多么的合理。</p>
<p>总结下不通过调用门、直接访问一般数据和代码时的特权检查规则，</p>
<ul>
<li>对于受访者为代码段时：<ul>
<li>如果目标为非一致性代码段，要求：数值上 CPL=RPL=目标代码段DPL</li>
<li>如果目标为一致性代码段，要求：数值上（CPL≥目标代码段DPL &amp;&amp; RPL≥目标代码段DPL）</li>
<li>受访者若为代码，只有在特权级转移时才会被用到，所以有关代码的特权检查都发生在能够改变代码段寄存器CS 和指令指针寄存器EIP 的指令中，即这些指令要么改变EIP，要么改变CS 和EIP。例如call、jmp、int、ret、sysexit 等能改变程序执行流的指令。</li>
</ul>
</li>
<li>对于受访者为数据段时：<ul>
<li>数值上（CPL ≤目标数据段DPL &amp;&amp; RPL ≤ 目标数据段 DPL）</li>
</ul>
</li>
<li>栈段的特权级检查比较特殊，因为在各个特权级下，处理器都要有相应的栈（后面会说到），也就是说栈的特权等级要和CPL 相同。所以往段寄存器SS 中赋予数据段选择子时，处理器要求CPL 等于栈段选择子对应的数据段的DPL，即数值上C<strong>PL = RPL = 用作栈的目标数据段DPL</strong>。</li>
<li>受访者若为数据，特权级检查会发生在往数据段寄存器中加载段选择子的时候，数据段寄存器包括DS 和附加段寄存器ES、FS、GS。</li>
</ul>
<p>RPL 是位于选择子中的，所以，要看当前运行的程序在访问数据或代码时用的是谁提供的选择子，如果用的<br>是自己提供的选择子，那肯定CPL 和RPL 都出自同一个程序；如果选择子是别人提供的，那就有可能RPL和CPL 出自两段程序。CPL 是对当前正在运行的程序而言的，而RPL 有可能是正在运行的程序。</p>
<p>在保护模式下，处理器中的“阶级”不仅体现在数据和代码的访问，还体现在指令中。</p>
<ul>
<li>一方面将指令分级的原因是有些指令的执行对计算机有着严重的影响，它们只有在0 特权级下被执行，因此被称为<strong>特权指令</strong>（Privilege Instruction）。</li>
<li>另一方面体现在I/O 读写控制上。IO 读写特权是由标志寄存器eflags 中的IOPL 位和TSS 中的IO 位图决定的，它们用来指定执行IO 操作的最小特权级。IO 相关的指令只有在当前特权级大于等于IOPL 时才能执行，所以它们称为<strong>IO 敏感指令</strong>（I/O Sensitive Instruction），如果当前特权级小于IOPL 时执行这些指令会引发处理器异常。这类指令有in、out、cli、sti。</li>
</ul>
<p>在eflags 寄存器中第12～13 位便是<strong>IOPL</strong>（I/O Privilege Level），即<strong>IO 特权级</strong>，它除了<strong>限制当前任务进行IO 敏感指令的最低特权级外，还用来决定任务是否允许操作所有的IO 端口</strong>，IOPL 位是打开所有IO 端口的开关。每个任务（内核进程或用户进程）都有自己的eflags 寄存器，所以每个任务都有自己的IOPL，它表示当前任务要想执行全部IO 指令的最低特权级，也就是处理器最低的CPL，只有任务的当前特权级大于等于IOPL才允许执行全部IO 指令，即数值上CPL≤IOPL。通过IO 位图来设置部分端口的访问权限。<br><img src="/img/1593836299.jpg" alt></p>
<p>I/O 位图是位于TSS 中的，它可以存在，也可以不存在，它只是用来设置对某些特定端口的访问，没有它的话便默认为禁止访问所有端口。有一项是“I/O 位图在TSS 中的偏移地址”，它在TSS 中偏移102 字节的地方，占2 个字节空间，就是图5-47 的左上角，此处用来存储I/O 位图的偏移地址，即此地址是I/O 位图在TSS 中以0 为起始的偏移量。如果某个TSS 存在I/O 位图的话，此处用来保存它的偏移地址。</p>
<p>TSS 中如果有I/O 位图的话，它将位于TSS 的顶端，这就是TSS 的实际尺寸并不固定的原因，当包括I/O 位图时，其大小是“I/O 位图偏移地址”+8192+1 字节，结尾这个1 字节是I/O 位图中最后的0xff。此字节有两个作用。</p>
<ul>
<li>第一，处理器允许I/O 位图中不映射所有的端口，即I/O 位图长度可以不足8KB，但位图的最后一字节必须为0xFF。如果在位图范围外的端口，处理器一律默认禁止访问。这样一来，<strong>如果位图最后一字节的0xFF 属于全部65536 个端口范围之内，字节各位全为1 表示禁止访问此字节代表的全部端口，这并没什么过错</strong>。</li>
<li>第二，<strong>如果该字节已经超过了全部端口的范围，它并不用来映射端口，只是用来作为位图的边界标记，用于跨位图最后一个字节时的“余量字节”。避免越界访问TSS 外的内存</strong>。</li>
</ul>
<p><img src="/img/1593836453.jpg" alt></p>
<h1 id="完善内核"><a href="#完善内核" class="headerlink" title="完善内核"></a>完善内核</h1><h2 id="函数调用约定简介"><a href="#函数调用约定简介" class="headerlink" title="函数调用约定简介"></a>函数调用约定简介</h2><p>在栈中保存、来传递参数：</p>
<ol>
<li>首先，每个进程都有自己的栈，这就是每个内存自己的专用内存空间。</li>
<li>其次，保存参数的内存地址不用再花精力维护，已经有栈机制来维护地址变化了，参数在栈中的位置可以通过栈顶的偏移量来得到。</li>
</ol>
<p>我们要解决的是参数压栈顺序问题，和栈空间的清理工作呢。我们按照由谁来清理栈空间分类，目前的调用约定见表<br><img src="/img/1593939376.jpg" alt></p>
<p>stdcall 的调用约定意味着：</p>
<ol>
<li>调用者将所有参数从右向左入栈。</li>
<li>被调用者清理参数所占的栈空间。</li>
</ol>
<p>主调用者：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">; 从右到左将参数入栈</span><br><span class="line"> push 2 ;压入参数b</span><br><span class="line"> push 3 ;压入参数a</span><br><span class="line"> call subtract ;调用函数subtract</span><br></pre></td></tr></table></figure></p>
<p>以上是主调函数，现在看下被调函数 subtract 中做了什么。<br>被调用者：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> push ebp ;压入ebp 备份</span><br><span class="line"> mov ebp,esp ;将esp 赋值给ebp</span><br><span class="line">;用ebp 作为基址来访问栈中参数</span><br><span class="line"> mov eax,[ebp+0x8] ;偏移8 字节处为第1 个参数a</span><br><span class="line"> add eax,[ebp+0xc] ;偏移0xc 字节处是第2 个参数b</span><br><span class="line">;参数a 和b 相加后存入eax</span><br><span class="line"> mov esp,ebp ;为防止中间有入栈操作,用ebp 恢复esp</span><br><span class="line">;本句在此例子中可有可无,属于通用代码</span><br><span class="line"> pop ebp ;将ebp 恢复</span><br><span class="line"> ret 8 ;数字8 表示返回后使esp+8</span><br><span class="line">;函数返回时由被调函数清理了栈中参数</span><br></pre></td></tr></table></figure></p>
<p>stdcall 是被调用者负责清理栈空间，subtract需要在返回前或返回时完成。在返回前清理栈相对困难一些，清理栈是指<strong>将栈顶回退到参数之前</strong>。因为返回地址在参数之下，ret 指令执行时必须保证当前栈顶是返回地址。所以通常在返回时“顺便”完成。于是ret 指令便有了这样的变体，其格式为：<code>ret 16 位立即数</code>，这是允许在返回时顺便再将栈指针 esp 修改的指令。</p>
<p>cdecl 调用约定由于起源于C 语言，所以又称为C 调用约定，是C 语言默认的调用约定，最大的亮点是它允许函数中参数的数量不固定。cdecl 的调用约定意味着。</p>
<ol>
<li>调用者将所有参数从右向左入栈。</li>
<li>调用者清理参数所占的栈空间。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int subtract(int a, int b); //被调用者</span><br><span class="line">int sub = subtract (3,2); // 主调用者</span><br></pre></td></tr></table></figure>
<p>主调用者：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">; 从右到左将参数入栈</span><br><span class="line">push 2 ;压入参数b</span><br><span class="line">push 3 ;压入参数a</span><br><span class="line">call subtract ;调用函数subtract</span><br><span class="line">add esp, 8 ;回收（清理）栈空间</span><br></pre></td></tr></table></figure></p>
<p>被调用者：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">push ebp ;压入ebp 备份</span><br><span class="line">mov ebp,esp ;将esp 赋值给ebp</span><br><span class="line">;用ebp 作为基址来访问栈中参数</span><br><span class="line">mov eax,[ebp+0x8] ;偏移8 字节处为第1 个参数a</span><br><span class="line">add eax,[ebp+0xc] ;偏移0xc 字节处是第2 个参数b</span><br><span class="line">;参数a 和b 相加后存入eax</span><br><span class="line">mov esp,ebp ;为防止中间有入栈操作，用ebp 恢复esp</span><br><span class="line">;本句在此例子中可有可无,属于通用代码</span><br><span class="line">pop ebp ;将ebp 恢复</span><br><span class="line">ret</span><br></pre></td></tr></table></figure></p>
<p>通过将esp 加上8 字节的方式回收了参数a 和参数b，本例中的其他代码都和stdcall 一样。</p>
<h2 id="汇编语言和-C-语言混合编程"><a href="#汇编语言和-C-语言混合编程" class="headerlink" title="汇编语言和 C 语言混合编程"></a>汇编语言和 C 语言混合编程</h2><p>BIOS 中断走的是中断向量表，所以有很多中断号给它用，而系统调用走的是中断描述符表中的一项而已，所以只用了第0x80 项中断。<strong>系统调用的子功能要用eax 寄存器来指定</strong>。我们要看看系统调用输入参数的传递方式：</p>
<ul>
<li>当输入的参数小于等于5 个时，Linux 用寄存器传递参数。当参数个数大于5 个时，把参数按照顺序放入连续的内存区域，并将该区域的首地址放到ebx 寄存器。这里我们只演示参数小于等于5 个的情况。</li>
<li>eax 寄存器用来存储子功能号（寄存器eip、ebp、esp 是不能使用的）。5 个参数存放在以下寄存器中，<br>传送参数的顺序如下。<ul>
<li>ebx 存储第1 个参数。</li>
<li>ecx 存储第2 个参数。</li>
<li>edx 存储第3 个参数。</li>
<li>esi 存储第4 个参数。</li>
<li>edi 存储第5 个参数。</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">section .data</span><br><span class="line">str_c_lib: db &quot;c library says: hello world!&quot;, 0xa ;0xa 为LF ASCII 码</span><br><span class="line">str_c_lib_len equ $-str_c_lib</span><br><span class="line">str_syscall: db &quot;syscall says: hello world!&quot;, 0xa</span><br><span class="line">str_syscall_len equ $-str_syscall</span><br><span class="line">section .text</span><br><span class="line">global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">;;;;;;;;;;;;; 方式1: 模拟C 语言中系统调用库函数write ;;;;;;;;;;;;;</span><br><span class="line">push str_c_lib_len ;按照C 调用约定压入参数</span><br><span class="line">push str_c_lib</span><br><span class="line">push 1</span><br><span class="line">call simu_write ;调用下面定义的simu_write</span><br><span class="line">add esp,12 ;回收栈空间</span><br><span class="line"></span><br><span class="line">;;;;;;;;;;;;; 方式2: 跨过库函数，直接进行系统调用 ;;;;;;;;;;;;;</span><br><span class="line">mov eax, 4 ;第4 号子功能是write 系统调用（不是C 库函数write）</span><br><span class="line">mov ebx, 1</span><br><span class="line">mov ecx, str_syscall</span><br><span class="line">mov edx, str_syscall_len</span><br><span class="line">int 0x80 ;发起中断，通知Linux 完成请求的功能</span><br><span class="line">;;;;;;;;;;;;; 退出程序 ;;;;;;;;;;;</span><br><span class="line">mov eax,1 ;第1 号子功能是exit</span><br><span class="line">int 0x80 ;发起中断，通知Linux 完成请求的功能</span><br><span class="line">;;;;;;;下面自定义的simu_write 用来模拟C 库中系统调用函数write</span><br><span class="line"></span><br><span class="line">;;;;;;这里模拟它的实现原理</span><br><span class="line">simu_write:</span><br><span class="line">push ebp ;备份ebp</span><br><span class="line">mov ebp,esp</span><br><span class="line">mov eax,4 ;第4 号子功能是write 系统调用（不是C 库函数write）</span><br><span class="line">mov ebx, [ebp+8] ;第1 个参数</span><br><span class="line">mov ecx, [ebp+12] ;第2 个参数</span><br><span class="line">mov edx, [ebp+16] ;第3 个参数</span><br><span class="line">int 0x80 ;发起中断，通知Linux 完成请求的功能</span><br><span class="line">pop ebp ;恢复ebp</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
<p>第 11～17 行是在模拟调用C 库函数write 的方式。这里是按照C 调用约定将参数从右到左依次入栈，随后调用simu_write 实现字符串打印功能。<br>第 19～24 行是在演示第2 种系统调用的方式，这是最简单直接可依赖的方式。第0～24 行是在eax中赋予子功能号，参数按照顺序依次写入对应的寄存器。第 31～40 行是simu_write 的实现，它内部在本质上和第2 种方式一样，都是在内部调用int 指令直接和系统通信实现系统调用。</p>
<h2 id="内联汇编"><a href="#内联汇编" class="headerlink" title="内联汇编"></a>内联汇编</h2><p>内联汇编称为inline assembly，GCC 支持在C 代码中直接嵌入汇编代码，所以称为GCC inline assembly。GCC只支持AT&amp;T汇编，下表是AT&amp;T汇编和Intel汇编的区别：<br><img src="/img/1593942767.png" alt></p>
<p>在 Intel 语法中，立即数就是普通的数字，如果让立即数成为内存地址，需要将它用中括号括起来，<code>[立即数]</code>这样才表示以“立即数”为地址的内存。而 AT&amp;T 认为，内存地址既然是数字，那数字也应该被当作内存地址，所以，数字被优先认为是内存<br>地址，也就是说，操作数若为数字，则统统按以该数字为地址的内存来访问。这样，立即数的地位比较次要了，如果想表示成单纯的立即数，需要额外在前面加个前缀$。</p>
<p>在 AT&amp;T 中的内存寻址有固定的格式。<code>segreg（段基址）：base_address(offset_address,index,size)</code>。该格式对应的表达式为：<code>segreg（段基址）：base_address+ offset_address+ index*size</code>。此表达式的格式和 Intel 32 位内存寻址中的基址变址寻址类似，Intel 的格式：<code>segreg:[base+index*size+offset]</code></p>
<p>不过与Intel 不同的是AT&amp;T 地址表达式的值是内存地址，直接被当作内存来读写，而不是普通数字。看上去格式有些怪异，但其实这是一种“通用”格式，格式中短短的几个成员囊括了它所有内存寻址的方式，任意一种内存寻址方式，其格式都是这个通用格式的子集，都是格式中各种成员的组合。下面介绍下这些成员项。</p>
<ul>
<li>base_address 是基地址，可以为整数、变量名，可正可负。</li>
<li>offset_address 是偏移地址，index 是索引值，这两个必须是那8 个通用寄存器之一。</li>
<li>size 是个长度，只能是1、2、4、8（Intel 语法中也是只能乘以这4 个数）。</li>
</ul>
<p>基本内联汇编是最简单的内联形式，其格式为：<code>asm [volatile] (&quot;assembly code&quot;)</code>，各关键字之间可以用空格或制表符分隔，也可以紧凑挨在一起不分隔，各部分意义如下：</p>
<ul>
<li>关键字 asm 用于声明内联汇编表达式，这是内联汇编固定的部分，不可少。</li>
<li>asm 和<strong>asm</strong>是一样的，是由gcc 定义的宏：<code>#define __asm__ asm</code>。</li>
<li>关键字volatile 是可选项，它告诉gcc：“不要修改我写的汇编代码，请原样保留”。<code>volatile</code>和<code>__volatile__</code>是一样的，是由gcc 定义的宏：<code>#define __volatile__ volatile</code>。</li>
<li>汇编代码必须位于圆括号中，而且必须用双引号引起来。<ul>
<li>指令必须用双引号引起来，无论双引号中是一条指令或多条指令。</li>
<li>一对双引号不能跨行，如果跨行需要在结尾用反斜杠’\’转义。</li>
<li>指令之间用分号’；’、换行符’\n’或换行符加制表符’\n’’\t’分隔。</li>
</ul>
</li>
</ul>
<p><code>asm [volatile] (“assembly code”:output : input : clobber/modify)</code>和前面的基本内联汇编相比，扩展内联汇编在圆括号中变成了4 部分，多了output、input 和clobber/modify 三项。其中的每一部分都可以省略，甚至包括assembly code。省略的部分要保留冒号分隔符来占位，如果省略的是后面的一个或多个连续的部分，分隔符也不用保留，比如省略了clobber/modify，不需要保留input 后面的冒号。</p>
<ul>
<li>assembly code：还是用户写入的汇编指令，和基本内联汇编一样。</li>
<li>output：<strong>output 用来指定汇编代码的数据如何输出给C 代码使用</strong>。内嵌的汇编指令运行结束后，如果想将运行结果存储到c 变量中，就用此项指定输出的位置。output 中每个操作数的格式为：<code>操作数修饰符约束名（C 变量名）</code></li>
<li>input：<strong>input 用来指定C 中数据如何输入给汇编使用</strong>。input 中每个操作数的格式为：<code>[操作数修饰符] 约束名</code><ul>
<li>单独强调一下，以上的output()和input()括号中的是C 代码中的变量，output(c 变量)和input(c 变量)就像C 语言中的函数，将C 变量转换成汇编代码的操作数。</li>
</ul>
</li>
<li>clobber/modify：汇编代码执行后会破坏一些内存或寄存器资源，通过此项通知编译器，可能造成寄存器或内存数据的破坏，这样gcc 就知道哪些寄存器或内存需要提前保护起来。</li>
</ul>
<p>上面所说的“要求”，在扩展内联汇编中称为“约束”，它所起的作用就是把C 代码中的操作数（变量、立即数）映射为汇编中所使用的操作数，实际就是描述C 中的操作数如何变成汇编操作数。这些约束的作用域是input 和output 部分，约束分为四种：</p>
<ul>
<li>寄存器约束就是要求gcc 使用哪个寄存器，将input 或output 中变量约束在某个寄存器中。常见的寄存器约束有：<ul>
<li>a：表示寄存器eax/ax/al</li>
<li>b：表示寄存器ebx/bx/bl</li>
<li>c：表示寄存器ecx/cx/cl</li>
<li>d：表示寄存器edx/dx/dl</li>
</ul>
</li>
</ul>
<p>先看下基本内联汇编，见文件 base_asm.c。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> in_a = <span class="number">1</span>, in_b = <span class="number">2</span>, out_sum;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">" pusha; \</span></span><br><span class="line"><span class="string">    movl in_a, %eax; \</span></span><br><span class="line"><span class="string">    movl in_b, %ebx; \</span></span><br><span class="line"><span class="string">    addl %ebx, %eax; \</span></span><br><span class="line"><span class="string">    movl %eax, out_sum; \</span></span><br><span class="line"><span class="string">    popa"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"sum is %d\n"</span>,out_sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>加法指令的两个输入操作数是in_a 和in_b，输出和存储在变量out_sum 中。<strong>在基本内联汇编中的寄存器用单个%做前缀，在扩展内联汇编中，单个%有了新的用途，用来表示占位符</strong>，所以在扩展内联汇编中的寄存器前面用两个%做前缀。再看下用扩展内联汇编是怎么做的，见文件 reg_constraint.c。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> in_a = <span class="number">1</span>, in_b = <span class="number">2</span>, out_sum;</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">"addl %%ebx, %%eax"</span>:<span class="string">"=a"</span>(out_sum):<span class="string">"a"</span>(in_a),<span class="string">"b"</span>(in_b));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"sum is %d\n"</span>,out_sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>in_a 和in_b 是在input 部分中输入的，用约束名a 为c 变量in_a 指定了用寄存器eax，用约束名b 为c 变量in_b 指定了用寄存器ebx。addl 指令的结果存放到了寄存器eax 中，在output 中用约束名a 指定了把寄存器eax 的值存储到c 变量out_sum 中。output 中的’=’号是操作数类型修饰符，表示只写，其实就是<code>out_sum=eax</code>的意思。</p>
<ul>
<li>内存约束是要求gcc 直接将位于input 和output 中的C 变量的内存地址作为内联汇编代码的操作数，不需要寄存器做中转，直接进行内存读写，也就是汇编代码的操作数是C 变量的指针。<ul>
<li>m：表示操作数可以使用任意一种内存形式。</li>
<li>o：操作数为内存变量，但访问它是通过偏移量的形式访问，即包含offset_address 的格式。</li>
</ul>
</li>
</ul>
<p>下面的文件 mem.c 用约束m 为例。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> in_a = <span class="number">1</span>, in_b = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"in_b is %d\n"</span>, in_b);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">"movb %b0, %1;"</span>::<span class="string">"a"</span>(in_a),<span class="string">"m"</span>(in_b));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"in_b now is %d\n"</span>, in_b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>mem.c 的作用是变量in_b 用in_a 的值替换。in_b 最终变成1。第 5 行是内联汇编，把in_a 施加寄存器约束a，告诉gcc 把变量in_a 放到寄存器eax 中，对in_b 施加内存约束m，告诉gcc 把变量in_b 的指针作为内联代码的操作数。第 5 行对寄存器eax 的引用：%b0，这是用的32 位数据的低8 位，在这里就是指al 寄存器。</p>
<p>立即数即常数，此约束要求gcc 在传值的时候不通过内存和寄存器，直接作为立即数传给汇编代码。由于立即数不是变量，只能作为右值，所以只能放在input 中。</p>
<ul>
<li>i：表示操作数为整数立即数</li>
<li>F：表示操作数为浮点数立即数</li>
<li>I：表示操作数为0～31 之间的立即数</li>
<li>J：表示操作数为0～63 之间的立即数</li>
<li>N：表示操作数为0～255 之间的立即数</li>
<li>O：表示操作数为0～32 之间的立即数</li>
<li><p>X：表示操作数为任何类型立即数</p>
</li>
<li><p>通用约束：0～9：此约束只用在input 部分，但表示可与output 和input 中第n 个操作数用相同的寄存器或内存。</p>
</li>
</ul>
<p>为方便对操作数的引用，扩展内联汇编提供了<strong>占位符</strong>，它的作用是代表约束指定的操作数（寄存器、内存、立即数），我们更多的是在内联汇编中使用占位符来引用操作数。<strong>占位符分为序号占位符和名称占位符两种</strong>。</p>
<ul>
<li>序号占位符：序号占位符是对在output 和input 中的操作数，按照它们从左到右出现的次序从0 开始编号，一直到9，也就是说最多支持10 个序号占位符。操作数用在 assembly code 中，引用它的格式是%0～9。<figure class="highlight plain"><figcaption><span>%%ebx, %%eax":"</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- &quot;=a&quot;(out_sum)序号为0，%0 对应的是eax。</span><br><span class="line">- &quot;a&quot;(in_a)序号为1，%1 对应的是eax。</span><br><span class="line">- &quot;b&quot;(in_b)序号为2，%2 对应的是ebx。</span><br><span class="line"></span><br><span class="line">必须要人为显式地告诉gcc 我们动了寄存器和内存，只要在clobber/modify部分明确写出来就行了，记得要用双引号把寄存器名称引起来，多个寄存器之间用逗号&apos;，&apos;分隔，这里的寄存器不用再加两个&apos;%&apos;啦，只写名称即可，如：```asm(&quot;movl %%eax, %0;movl %%eax,%%ebx&quot;:&quot;=m&quot; (ret_value)::&quot;bx&quot;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>机器模式</strong>用来在机器层面上指定数据的大小及格式。GCC 支持内联汇编，由于各种约束均不能确切地表达具体的操作数对象，所以引用了机器模式，用来从更细的粒度上描述数据对象的大小及其指定部分。GCC 根据不同的硬件平台，将机器模式定义在多个文件中，其中所有平台都通用的机器模式定义在gcc/machmode.def 文件中，其他与具体平台相关的机器模式定义在自己的平台路径下。</p>
<p>操作码就是<strong>指定操作数为寄存器中的哪个部分</strong>。寄存器按是否可单独使用，可分成几个部分，拿 eax 举例。</p>
<ul>
<li>低部分的一字节：al</li>
<li>高部分的一字节：ah</li>
<li>两字节部分：ax</li>
<li>四字节部分：eax</li>
<li>h：输出寄存器高位部分中的那一字节对应的寄存器名称，如ah、bh、ch、dh。</li>
<li>b：输出寄存器中低部分1 字节对应的名称，如al、bl、cl、dl。</li>
<li>w：输出寄存器中大小为2 个字节对应的部分，如ax、bx、cx、dx。</li>
<li>k：输出寄存器的四字节部分，如eax、ebx、ecx、edx。</li>
</ul>
<h1 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h1><p>操作系统是中断驱动的</p>
<h2 id="中断分类"><a href="#中断分类" class="headerlink" title="中断分类"></a>中断分类</h2><p>把中断按事件来源分类，来自CPU 外部的中断就称为外部中断，来自CPU 内部的中断称为内部中断。</p>
<h3 id="外部中断"><a href="#外部中断" class="headerlink" title="外部中断"></a>外部中断</h3><p>外部中断是指来自CPU 外部的中断，而外部的中断源必须是某个硬件，所以外部中断又称为硬件中断。<strong>所以一种可行的方案是CPU 提供统一的接口作为中断信号的公共线路，所有来自外设的中断信号都共享公共线路连接到CPU</strong>。CPU 为大家提供了两条信号线。外部硬件的中断是通过两根信号线通知CPU 的，这两根信号线就是INTR（INTeRrupt）和NMI（Non Maskable Interrupt）。<br><img src="/img/1593968345.jpg" alt></p>
<p>CPU 为了区分两种中断类型，<strong>通过不同的引脚加以区分</strong>，同一种类型的中断共用同一根信号线进入CPU，这样CPU 就不需要在每次收到中断时再辨析是哪种类型了。<strong>只要从INTR 引脚收到的中断都是不影响系统运行的</strong>，可以随时处理；而只要从NMI 引脚收到的中断，CPU 都没有运行下去的必要了。</p>
<p>可屏蔽的意思是此外部设备发出的中断，CPU 可以不理会，因为它不会让系统宕机，所以可以通过eflags寄存器的IF 位将所有这些外部设备的中断屏蔽。<strong>把中断处理程序分为上半部和下半部两部分，把中断处理程序中需要立即执行的部分划分到上半部，中断处理程序中那些不紧急的部分则被推迟到下半部中去完成</strong>。当上半部执行完成后就把中断打开了，下半部也属于中断处理程序，所以中断处理程序下半部则是在开中断的情况下执行的。<strong>不可屏蔽中断是通过NMI 引脚进入CPU 的，它表示系统中发生了致命的错误</strong>。不可屏蔽中断可以理解成“即将宕机”中断。</p>
<p>CPU 收到中断后，通过中断向量表或中断描述符表（中断向量表是实模式下的中断处理程序数组，在保护模式下已经被中断描述符表代替）来实现的：</p>
<ul>
<li><strong>首先为每一种中断分配一个中断向量号，中断向量号就是一个整数</strong>，它就是中断向量表或中断描述符表中的索引下标，用来索引中断项。</li>
<li>中断发起时，<strong>相应的中断向量号通过NMI 或INTR引脚被传入CPU</strong>，CPU 根据此中断向量号在中断向量表或中断描述符表中检索对应的中断处理程序并去执行。</li>
</ul>
<h3 id="内部中断"><a href="#内部中断" class="headerlink" title="内部中断"></a>内部中断</h3><p>内部中断可分为<strong>软中断</strong>和<strong>异常</strong>。</p>
<ul>
<li>软中断，就是<strong>由软件主动发起的中断</strong>，它是主观上的，并不是客观上的某种内部错误。以下是可以发起中断的指令。<ul>
<li><code>int 8位立即数</code>。8位立即数可表示256种中断，这与处理器所支持的中断数是相吻合的。</li>
<li><code>int3</code>。<code>int3</code>是调试断点指令，其所触发的中断向量号是3。<ul>
<li>我们用gdb 或bochs 调试程序时，实际上就是调试器fork 了一个子进程，<strong>子进程用于运行被调试的程序</strong>。</li>
<li>调试器中经常要设置断点，其原理就是<strong>父进程修改了子进程的指令，将其用int3指令替换</strong>，从而子进程调用了int3 指令触发中断。</li>
<li>用此指令实现调试的原理是int3 指令的机器码是0xcc，断点本质上是指令的地址，<strong>调试器（父进程）将被调试进程（子进程）断点起始地址的第1 个字节备份好之后，在原地将该指令的第1 字节修改为0xcc</strong>。</li>
<li>这样指令执行到断点处时，会去执行机器码为0xcc 的int3 指令，该指令会触发3 号中断，从而会去执行3 号中断对应的中断处理程序。</li>
<li>中断处理程序将当前的寄存器和相关内存单元压栈保存，用户在查看寄存器和变量时就是从栈中获取的。</li>
<li>当恢复执行所调试的进程时，中断处理程序需要将之前备份的1 字节还原至断点处，然后恢复各寄存器和内存单元的值，修改返回地址为断点地址，用iret 指令退出中断，返回到用户进程继续执行。</li>
</ul>
</li>
<li><strong>into</strong>。这是中断溢出指令，它所触发的中断向量号是4。不过，能否引发4 号中断是要看eflags 标志寄存器中的OF 位是否为1，如果是1 才会引发中断。</li>
<li><strong>bound</strong>。这是检查数组索引越界指令，它可以触发5 号中断，用于检查数组的索引下标是否在上下边界之内。该指令格式是<code>bound 16/32位寄存器, 16/32位内存</code>。目的操作数是用寄存器来存储的，其内容是待检测的数组下标值。源操作数是内存，其内容是数组下标的下边界和上边界。当执行bound 指令时，若<strong>下标处于数组索引的范围之外，则会触发5 号中断</strong>。</li>
<li><strong>ud2</strong>。未定义指令，这会触发第6 号中断。该指令表示指令无效，CPU 无法识别。</li>
</ul>
</li>
</ul>
<p>异常是另一种内部中断，是指令执行期间CPU 内部产生的错误引起的。由于是运行时错误，所以它不受标志寄存器eflags 中的IF 位影响，无法向用户隐瞒。对于中断是否无视eflags 中的IF 位，可以这么理解：</p>
<ul>
<li>首先，只要是导致运行错误的中断类型都会无视IF 位，不受IF 位的管束，如NMI、异常。</li>
<li>其次，由于int n 型的软中断用于实现系统调用功能，不能因为IF 位为0 就不顾用户请求，所以为了用户功能正常，软中断必须也无视IF 位。</li>
<li>总结：只要中断关系到“正常”运行，就不受IF 位影响。</li>
</ul>
<p>并不是所有的异常都很致命，按照轻重程度，可以分为以下三种。</p>
<ul>
<li><strong>Fault，也称为故障</strong>。这种错误是可以被修复的一种类型。当发生此类异常时CPU 将机器状态恢复到异常之前的状态，之后调用中断处理程序时，<strong>CPU 将返回地址依然指向导致fault 异常的那条指令</strong>。如操作系统课程中所说的缺页异常page fault，</li>
<li><strong>Trap，也称为陷阱</strong>。此异常通常用在调试中，比如int3 指令便引发此类异常，为了让中断处理程序返回后能够继续向下执行，CPU将中断处理程序的返回地址指向导致异常指令的下一个指令地址。</li>
<li><strong>Abort，也称为终止</strong>，这是最严重的异常类型，一旦出现，程序将无法继续运行。导致此异常的错误通常是硬件错误，或者某些系统数据结构出错。</li>
</ul>
<p><img src="/img/1593969804.jpg" alt></p>
<p><strong>中断机制的本质是来了一个中断信号后，调用相应的中断处理程序</strong>。为了统一中断管理，把来自外部设备、内部指令的各种中断类型统统归结为一种管理方式，即<strong>为每个中断信号分配一个整数，用此整数作为中断的ID，而这个整数就是所谓的中断向量</strong>，然后用此ID 作为中断描述符表中的索引，这样就能找到对应的表项，进而从中找到对应的中断处理程序。</p>
<h2 id="中断描述符表"><a href="#中断描述符表" class="headerlink" title="中断描述符表"></a>中断描述符表</h2><p><strong>中断描述符表（Interrupt Descriptor Table，IDT）是保护模式下用于存储中断处理程序入口的表</strong>，当CPU 接收一个中断时，需要用中断向量在此表中检索对应的描述符，在该描述符中找到中断处理程序的起始地址，然后执行中断处理程序。实模式下用于存储中断处理程序入口的表叫<strong>中断向量表（Interrupt Vector Table，IVT）</strong>。</p>
<p><strong>位于地址0～0x3ff 的是中断向量表IVT，它是实模式下用于存储中断处理程序入口的表</strong>。对比中断向量表，中断描述符表有两个区别。</p>
<ul>
<li>中断描述符表地址不限制，在哪里都可以。</li>
<li>中断描述符表中的每个描述符用8 字节描述。</li>
</ul>
<p>在CPU 内部有个<strong>中断描述符表寄存器</strong>（IDTR），该寄存器分为两部分：<strong>第0～15 位是表界限</strong>，即IDT 大小减1，第16～47 位是<strong>IDT 的基地址</strong>，只有寄存器IDTR指向了IDT，当CPU 接收到中断向量号时才能找到中断向量处理程序，这样中断系统才能正常运作。同加载GDTR 一样，加载IDTR 也有个专门的指令—lidt，其用法是：<code>lidt 48 位内存数据</code>，在这48 位内存数据中，前16 位是IDT 表界限，后32 位是IDT 线性基地址。</p>
<p>完整的中断过程分为CPU 外和CPU 内两部分。</p>
<ul>
<li>CPU 外：外部设备的中断由中断代理芯片接收，处理后将该中断的中断向量号发送到CPU。</li>
<li><p>CPU 内：CPU 执行该中断向量号对应的中断处理程序。</p>
</li>
<li><p><strong>处理器根据中断向量号定位中断门描述符</strong>，然后再去执行该中断描述符中的中断处理程序。<strong>由于中断描述符是8 个字节，所以处理器用中断向量号乘以8 后，再与IDTR 中的中断描述符表地址相加</strong>，所求的地址之和便是该中断向量号对应的中断描述符。</p>
</li>
<li><strong>处理器进行特权级检查</strong>。中断门的特权检查同调用门类似，对于软件主动发起的软中断，<strong>当前特权级CPL 必须在门描述符DPL 和门中目标代码段DPL 之间</strong>。这是为了防止位于3 特权级下的用户程序主动调用某些只为内核服务的例程。<ul>
<li>如果是由软中断<code>int n</code>、<code>int3</code>和<code>into</code>引发的中断，这些是用户进程中主动发起的中断，<strong>处理器要检查当前特权级CPL 和门描述符DPL</strong>，这是检查进门的特权下限，如果<code>CPL 权限大于等于DPL</code>，即<code>数值上CPL≤门描述符DPL</code>，特权级“门槛”检查通过，进入下一步的“门框”检查。否则，处理器抛出异常。</li>
<li>这一步<strong>检查特权级的上限</strong>（门框）：<strong>处理器要检查当前特权级CPL 和门描述符中所记录的选择子对应的目标代码段DPL</strong>，如果CPL 权限小于目标代码段DPL，即<strong>数值上CPL&gt;目标代码段DPL</strong>，检查通过。否则CPL 若大于等于目标代码段DPL，处理器将引发异常，也就是说，<strong>除了用返回指令从高特权级返回，特权转移只能发生在由低向高</strong>。</li>
<li>若中断是由外部设备和异常引起的，只直接检查CPL 和目标代码段的DPL，要求CPL 权限小于目标代码段DPL，即<strong>数值上CPL &gt;目标代码段DPL</strong>，否则处理器引发异常。</li>
</ul>
</li>
<li>执行中断处理程序。特权级检查通过后，<strong>将门描述符目标代码段选择子加载到代码段寄存器CS 中，把门描述符中中断处理程序的偏移地址加载到EIP</strong>，开始执行中断处理程序。</li>
</ul>
<p><img src="/img/1594002593.jpg" alt></p>
<p><strong>指令cli 使IF 位为0，这称为关中断，指令sti 使IF 位为1，这称为开中断。</strong></p>
<p><strong>进入中断时要把NT 位和TF 位置为0</strong>。TF 表示Trap Flag，也就是陷阱标志位，这用在调试环境中，<strong>当TF 为0 时表示禁止单步执行</strong>；NT 位表示Nest Task Flag，即<strong>任务嵌套标志位</strong>，也就是用来标记任务嵌套调用的情况。<strong>任务嵌套调用是指CPU 将当前正执行的旧任务挂起，转去执行另外的新任务，待新任务执行完后，CPU 再回到旧任务继续执行</strong>。</p>
<ul>
<li>将旧任务TSS 选择子写到了新任务TSS 中的“上一个任务TSS 的指针”字段中。</li>
<li>将新任务标志寄存器eflags 中的NT 位置1，表示新任务之所以能够执行，是因为有别的任务调用了它。</li>
</ul>
<p>当CPU 执行iret 时，它会去检查NT 位的值，<strong>如果NT 位为1，这说明当前任务是被嵌套执行的</strong>，因此会从自己TSS 中“上一个任务TSS 的指针”字段中获取旧任务，然后去执行该任务。如果NT 位的值为0，这表示当前是在中断处理环境下，于是就执行正常的中断退出流程。</p>
<p>处理器根据中断向量号在中断描述符表中<strong>找到相应的中断门描述符</strong>，<strong>门描述符中保存的是中断处理程序所在代码段的选择子及在段内偏移量</strong>，处理器从该描述符中加载目标代码段选择子到代码段寄存器CS 及偏移量到指令指针寄存器EIP。当前进程被中断打断后，为了从中断返回后能继续运行该进程，<strong>处理器自动把CS 和EIP 的当前值保存到中断处理程序使用的栈中</strong>。不同特权级别下处理器使用不同的栈，至于中断处理程序使用的是哪个栈，要视它当时所在的特权级别，因为中断是可以在任何特权级别下发生的。</p>
<p><strong>除了要保存CS、EIP 外，还需要保存标志寄存器EFLAGS</strong>，如果涉及到特权级变化，还要压入SS 和ESP 寄存器。</p>
<ul>
<li><strong>处理器根据中断向量号找到对应的中断描述符后，拿CPL 和中断门描述符中选择子对应的目标代码段的DPL 比对</strong>：<ul>
<li>若CPL 权限比DPL 低，即数值上CPL &gt; DPL，这表示要向高特权级转移，需要切换到高特权级的栈。这也意味着当执行完中断处理程序后，若要正确返回到当前被中断的进程，同样需要将栈恢复为此时的旧栈。保存当前旧栈SS 和ESP 的值，TSS 中找到同目标代码段DPL 级别相同的栈加载到寄存器SS 和ESP 中。</li>
<li>在新栈中压入EFLAGS 寄存器；</li>
<li>由于要切换到目标代码段，<strong>对于这种段间转移，要将CS 和EIP 保存到当前栈中备份</strong>，</li>
<li>某些异常会有错误码，此错误码用于报告异常是在哪个段上发生的，错误码会紧跟在EIP 之后入栈，记作ERROR_CODE。</li>
</ul>
</li>
</ul>
<p><img src="/img/1594007235.jpg" alt></p>
<p>如果在第1 步中判断未涉及到特权级转移，便不会到TSS 中寻找新栈，而是继续使用当前旧栈，因此也谈不上恢复旧栈，此时中断发生时栈中数据不包括SS_old 和ESP_old。<br><img src="/img/1594007310.jpg" alt></p>
<p>中断返回是用<code>iret</code>指令实现的，即interrupt ret，<strong>此指令专用于从中断处理程序返回</strong>，iret 指令并不清楚栈中数据的正确性，它只负责把栈顶处往上的数据，每次4 字节，<strong>一定要保证从栈顶往上的顺序是EIP、CS、EFLAGS</strong>，根据特权级是否有变化，还有ESP、SS。若处理器发现返回后特权级会变化，还会继续将两个双字数据返回到ESP、SS，其中SS也是16 位寄存器，所以同样也是弹出32 位数据后，只将其中的低16 位加载到SS。<strong>16 位模式下用iretw，32 位模式下用iretd</strong>。</p>
<p>假设栈顶已位于EIP_old：</p>
<ul>
<li>当处理器执行到iret 指令时，它知道要执行远返回，<strong>首先需要从栈中返回被中断进程的代码段选择子CS_old 及指令指针EIP_old</strong>。这时候它要进行特权级检查。先检查栈中CS 选择子CS_old，根据其RPL 位，即未来的CPL，判断在返回过程中是否要改变特权级。</li>
<li>栈中CS 选择子是CS_old，根据CS_old 对应的代码段的DPL 及CS_old 中的RPL 做特权级检查。<strong>如果检查通过，随即需要更新寄存器CS 和EIP</strong>。如果进入中断时未涉及特权级转移，此时栈指针是ESP_old，否则栈指针是ESP_new</li>
<li><strong>将栈中保存的EFLAGS 弹出到标志寄存器EFLAGS</strong>。如果在第1 步中判断返回后要改变特权级，此时栈指针是ESP_new，它指向栈中的ESP_old。否则进入中断时属于平级转移，用的是旧栈，此时栈指针是ESP_old，栈中已无因此次中断发生而入栈的数据，栈指针指向中断发生前的栈顶。</li>
<li>如果在第1 步中判断出返回时需要改变特权级，此时便需要<strong>将ESP_old和SS_old 分别加载到寄存器ESP 及SS</strong></li>
</ul>
<p>错误码的低2位不再是RPL，而<strong>是EXT和IDT</strong>。总之，<strong>错误码本质上就是个描述符选择子</strong>，通过低3 位属性来修饰此选择子指向是哪个表中的哪个描述符。</p>
<ul>
<li>EXT 表示EXTernal event，即外部事件，<strong>用来指明中断源是否来自处理器外部</strong>，如果中断源是不可屏蔽中断NMI 或外部设备，EXT 为1，否则为0。</li>
<li>IDT 表示<strong>选择子是否指向中断描述符表IDT</strong>，IDT 位为1，则表示此选择子指向中断描述符表，否则指向全局描述符表GDT 或局部描述符表LDT。</li>
<li><strong>TI为0时用来指明选择子是从GDT 中检索描述符，为1 时是从LDT 中检索描述符</strong>。</li>
</ul>
<p><img src="/img/1594009669.jpg" alt></p>
<p>中断返回时，iret 指令并不会把错误码从栈中弹出，所以在中断处理程序中需要手动用栈指针跨过错误码或将其弹出。否则栈顶处若不是EIP（EIP_old）的话，iret 返回时将会载入错误的值到后续寄存器。</p>
<h2 id="可编程中断控制器-8259A"><a href="#可编程中断控制器-8259A" class="headerlink" title="可编程中断控制器 8259A"></a>可编程中断控制器 8259A</h2><p>8259A 的作用是负责所有来自外设的中断。8259A 用于管理和控制可屏蔽中断，它表现在屏蔽外设中断，对它们实行优先级判决，向CPU 提供中断向量号等功能。将多个8259A级联，每一个8259A 就被称为1 片。<strong>n 片8259A 通过级联可支持7n+1 个中断源</strong>，级联时只能有一片8259A为主片master，其余的均为从片slave。来自从片的中断只能传递给主片，再由主片向上传递给CPU，也就是说<strong>只有主片才会向CPU 发送INT 中断信号</strong>。，8259A 在收到了中断后，对中断判优，将优先级最高的中断转发给CPU 处理。8259A 在收到了中断后，对中断判优，将优先级最高的中断转发给CPU 处理。<br><img src="/img/1594017978.jpg" alt></p>
<ul>
<li>INT：8259A 选出优先级最高的中断请求后，发信号通知CPU。</li>
<li>INTA：INT Acknowledge，中断响应信号。位于8259A 中的INTA 接收来自CPU 的INTA 接口的中断响应信号。</li>
<li>IMR：Interrupt Mask Register，中断屏蔽寄存器，宽度是8 位，用来屏蔽某个外设的中断。</li>
<li>IRR：Interrupt Request Register，中断请求寄存器，宽度是8 位。它的作用是接受经过IMR 寄存器过滤后的中断信号并锁存，此寄存器中全是等待处理的中断，“相当于”5259A 维护的未处理中断信号队列。</li>
<li>PR：Priority Resolver，优先级仲裁器。当有多个中断同时发生，或当有新的中断请求进来时，将<br>它与当前正在处理的中断进行比较，找出优先级更高的中断。</li>
<li>ISR：In-Service Register，中断服务寄存器，宽度是8 位。当某个中断正在被处理时，保存在此寄存器中。</li>
</ul>
<p><img src="/img/1594018210.jpg" alt><br>寄存器都是8 位，8259A 共8 个IRQ 接口，可以用8 位寄存器中的每一位代表8259A 的每个IRQ 接口。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/操作系统/" rel="tag"># 操作系统</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/06/29/Leetcode1201_1250/" rel="next" title="Leetcode1201 - 1250">
                <i class="fa fa-chevron-left"></i> Leetcode1201 - 1250
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/07/10/Leetcode1401_1450/" rel="prev" title="Leetcode1401 - 1450.md">
                Leetcode1401 - 1450.md <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/header.jpg" alt="Hao Yu">
            
              <p class="site-author-name" itemprop="name">Hao Yu</p>
              <p class="site-description motion-element" itemprop="description">Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author</p>
          </div>
          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">238</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>
        	<audio controls="controls" loop="loop" preload="auto" src="/resource/xiaomeihao.mp3">
	        </audio>
	

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yuhao0102" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:yuh18@mails.tsinghua.edu.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#保护模式进阶，向内核迈进"><span class="nav-number">1.</span> <span class="nav-text">保护模式进阶，向内核迈进</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#获取物理内存容量"><span class="nav-number">1.1.</span> <span class="nav-text">获取物理内存容量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#启用内存分页机制，畅游虚拟空间"><span class="nav-number">1.2.</span> <span class="nav-text">启用内存分页机制，畅游虚拟空间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#加载内核"><span class="nav-number">1.3.</span> <span class="nav-text">加载内核</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#特权级深入浅出"><span class="nav-number">1.4.</span> <span class="nav-text">特权级深入浅出</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#调用门的过程保护"><span class="nav-number">1.4.1.</span> <span class="nav-text">调用门的过程保护</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#完善内核"><span class="nav-number">2.</span> <span class="nav-text">完善内核</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#函数调用约定简介"><span class="nav-number">2.1.</span> <span class="nav-text">函数调用约定简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#汇编语言和-C-语言混合编程"><span class="nav-number">2.2.</span> <span class="nav-text">汇编语言和 C 语言混合编程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内联汇编"><span class="nav-number">2.3.</span> <span class="nav-text">内联汇编</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#中断"><span class="nav-number">3.</span> <span class="nav-text">中断</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#中断分类"><span class="nav-number">3.1.</span> <span class="nav-text">中断分类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#外部中断"><span class="nav-number">3.1.1.</span> <span class="nav-text">外部中断</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内部中断"><span class="nav-number">3.1.2.</span> <span class="nav-text">内部中断</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#中断描述符表"><span class="nav-number">3.2.</span> <span class="nav-text">中断描述符表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#可编程中断控制器-8259A"><span class="nav-number">3.3.</span> <span class="nav-text">可编程中断控制器 8259A</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>
  <div id="DvelopmentTarget">     
  </div>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart" aria-hidden="false"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>

  
</div>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_uv"> 
  本站访客数<span id="busuanzi_value_site_uv"></span>人次
</span>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  


  <script type="text/javascript" src="/js/src/love.js"></script>

</body>
</html>
