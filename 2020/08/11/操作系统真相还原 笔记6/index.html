<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zn-ch">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-center-simple.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="操作系统,">










<meta name="description" content="文件系统文件系统概念简介块是文件系统的读写单位，因此文件至少要占据一个块，在FAT文件系统中存储的文件，其所有的块被用于链式结构来组织，在每个块的最后存储下一个块的地址，从而块与块之间串联到一起，文件中的块可以分布在各个零散的空间中。算法效率低下，而且每访问一个结点，就要涉及一次硬盘寻道。 UNIX 文件系统将文件以索引结构来组织，文件中的块依然可以分散到不连续的零散空间中，保留了磁盘高利用率的优">
<meta name="keywords" content="操作系统">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统真相还原14-15章">
<meta property="og:url" content="http://yoursite.com/2020/08/11/操作系统真相还原 笔记6/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="文件系统文件系统概念简介块是文件系统的读写单位，因此文件至少要占据一个块，在FAT文件系统中存储的文件，其所有的块被用于链式结构来组织，在每个块的最后存储下一个块的地址，从而块与块之间串联到一起，文件中的块可以分布在各个零散的空间中。算法效率低下，而且每访问一个结点，就要涉及一次硬盘寻道。 UNIX 文件系统将文件以索引结构来组织，文件中的块依然可以分散到不连续的零散空间中，保留了磁盘高利用率的优">
<meta property="og:locale" content="zn-ch">
<meta property="og:image" content="http://yoursite.com/img/1597111542.jpg">
<meta property="og:image" content="http://yoursite.com/img/1597112699.jpg">
<meta property="og:image" content="http://yoursite.com/img/1597113023.jpg">
<meta property="og:image" content="http://yoursite.com/img/1597114214.jpg">
<meta property="og:image" content="http://yoursite.com/img/1597114393.jpg">
<meta property="og:image" content="http://yoursite.com/img/1597114449.jpg">
<meta property="og:image" content="http://yoursite.com/img/1597114582.jpg">
<meta property="og:image" content="http://yoursite.com/img/1597123037.jpg">
<meta property="og:image" content="http://yoursite.com/img/1597134858.jpg">
<meta property="og:image" content="http://yoursite.com/img/1597195068.jpg">
<meta property="og:image" content="http://yoursite.com/img/1597306002.jpg">
<meta property="og:image" content="http://yoursite.com/img/1597307751.jpg">
<meta property="og:image" content="http://yoursite.com/img/1597307924.png">
<meta property="og:image" content="http://yoursite.com/img/1597310235.jpg">
<meta property="og:updated_time" content="2020-08-13T09:37:31.050Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="操作系统真相还原14-15章">
<meta name="twitter:description" content="文件系统文件系统概念简介块是文件系统的读写单位，因此文件至少要占据一个块，在FAT文件系统中存储的文件，其所有的块被用于链式结构来组织，在每个块的最后存储下一个块的地址，从而块与块之间串联到一起，文件中的块可以分布在各个零散的空间中。算法效率低下，而且每访问一个结点，就要涉及一次硬盘寻道。 UNIX 文件系统将文件以索引结构来组织，文件中的块依然可以分散到不连续的零散空间中，保留了磁盘高利用率的优">
<meta name="twitter:image" content="http://yoursite.com/img/1597111542.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/08/11/操作系统真相还原 笔记6/">





  <title>操作系统真相还原14-15章 | Hao Yu's blog</title>
  








 
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zn-ch">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hao Yu's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">The program monkey was eaten by the siege lion.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/resume.pdf" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-mybetterhalf">
          <a href="/mybetterhalf/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>
            
            mybetterhalf
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/11/操作系统真相还原 笔记6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">操作系统真相还原14-15章</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-08-11T11:13:00+08:00">
                2020-08-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><h2 id="文件系统概念简介"><a href="#文件系统概念简介" class="headerlink" title="文件系统概念简介"></a>文件系统概念简介</h2><p>块是文件系统的读写单位，因此文件至少要占据一个块，在FAT文件系统中存储的文件，其所有的块被用于链式结构来组织，在每个块的最后存储下一个块的地址，从而块与块之间串联到一起，文件中的块可以分布在各个零散的空间中。算法效率低下，而且每访问一个结点，就要涉及一次硬盘寻道。<br><img src="/img/1597111542.jpg" alt></p>
<p>UNIX 文件系统将文件以<strong>索引结构</strong>来组织，文件中的块依然可以分散到不连续的零散空间中，保留了磁盘高利用率的优点，更重要的是<strong>文件系统为每个文件的所有块建立了一个索引表</strong>，索引表就是块地址数组，每个数组元素就是块的地址，数组元素下标是文件块的索引，第n 个数组元素指向文件中的第n 个块，这样访问任意一个块的时候，只要从索引表中获得块地址就可以了，速度大大提升。<strong>包含此索引表的索引结构称为inode</strong>，即<strong>index node</strong>，索引结点，用来<strong>索引、跟踪一个文件的所有块</strong>。在UINX文件系统中，一个文件必须对应一个inode。<br><img src="/img/1597112699.jpg" alt></p>
<p>每个索引表中共15 个索引项，前 12 个索引项是文件的前12个块的地址，它们是可直接获得地址的块。若文件大于 12 个块，那就再建立个新的块索引表，新索引表称为<strong>一级间接块索引表</strong>，表中可容纳256 个块的地址，该物理块的地址存储到老索引表的第13 个索引项中。有了一级间接块索引表，文件最大可达12+256=268 个块。再建立<strong>二级间接块索引表</strong>，此表中<strong>各表项存储的是一级间接块索引表</strong>，有了二级间接块索引表，文件最大可达<code>12+256+256*256</code>个块。<strong>三级间接块索引表</strong>所在块的地址记录在老索引表的第15 个索引项中，文件最大可达<code>12+256+256*256+256*256*256</code>个块，<br><img src="/img/1597113023.jpg" alt></p>
<p>i 结点编号是指此inode 的序号，这通常是指它在<strong>inode 数组中的下标</strong>。权限是指<strong>读、写、执行</strong>。属主是指<strong>文件的拥有者</strong>，时间是指<strong>创建时间、修改时间、访问时间</strong>等。文件大小是指文件的字节尺寸。下面这些连续的各种块指针及索引表指针是文件所有块的索引，也就是指向文件的实体部分。inode 是<strong>文件实体数据块的描述符</strong>。Linux 中每分区的inode 数量是固定的，可以用tune2fs 命令查看inode 数量。<strong>inode 的数量等于文件的数量</strong>，分区中所有文件的inode 通过<code>inode_table</code>表格来维护。一个分区的利用率分为<strong>inode的利用率</strong>和<strong>磁盘空间利用率</strong>两种，在Linux 中可以通过<code>df –i</code>命令查看inode 利用率，不加参数执行df 时，查看的是空间利用率。</p>
<p>在Linux 中，<strong>目录和文件都用inode 来表示</strong>，目录是包含文件的文件。如果该inode 表示的是普通文件，此inode指向的数据块中的内容应该是普通文件自己的数据。如果该inode表示的是目录文件，此inode 指向的数据块中的内容应该是<strong>该目录下的目录项</strong>。目录相当于个文件列表（或者是表格），每个文件在目录中都是一个entry（条目、项），这个entry 是<strong>目录中各个文件的描述</strong>，它称为<strong>目录项</strong>，目录项中至少要包括文件名、文件类型及文件对应的inode 编号。有了目录项后，通过文件名找文件实体数据块的流程是。</p>
<ol>
<li>在目录中找到文件名所在的目录项。</li>
<li>从目录项中获取inode 编号。</li>
<li>用inode 编号作为inode 数组的索引下标，找到inode。</li>
<li>从该inode 中获取数据块的地址，读取数据块。</li>
</ol>
<p><img src="/img/1597114214.jpg" alt><br><img src="/img/1597114393.jpg" alt></p>
<p>查找任意文件时，都直接到根目录的数据块中找相关的目录项，然后递归查找，最终可以找到任意子目录中的文件。<br><img src="/img/1597114449.jpg" alt></p>
<p><strong>超级块是保存文件系统元信息的元信息</strong>。用位图来管理inode 的使用情况，也要为这些空闲块准备个位图。一个简单的超级块结构如图。<br><img src="/img/1597114582.jpg" alt></p>
<p>魔数用来<strong>确定文件系统的类型的标志</strong>，超级块是在为分区创建文件系统时创建的，所有有关文件系统元信息的配置都在超级块中，因此它被<strong>固定存储在各分区的第2 个扇区</strong>，通常是占用一个扇区的大小。</p>
<p>图是一个典型的inode结构的文件系统布局。<strong>操作系统引导块</strong>就是<strong>操作系统引导记录OBR 所在的地址</strong>，即<strong>操作系统引导扇区</strong>，它位于各分区最开始的扇区。在操作系统引导块后面的依次是<strong>超级块、空闲块的位图</strong>、<strong>inode 位图</strong>、<strong>inode 数组</strong>、<strong>根目录</strong>、<strong>空闲块区域</strong>。根目录和空闲块区域是真正用于存储数据的区域。<br><img src="/img/1597123037.jpg" alt></p>
<h2 id="创建文件系统"><a href="#创建文件系统" class="headerlink" title="创建文件系统"></a>创建文件系统</h2><h3 id="创建超级块、i-结点、目录项"><a href="#创建超级块、i-结点、目录项" class="headerlink" title="创建超级块、i 结点、目录项"></a>创建超级块、i 结点、目录项</h3><p>有关文件操作的代码我们定义在fs 目录下，本节咱们新建这个目录，超级块所在的文件位于<code>fs/super_block.h</code>中：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 超级块 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> &#123;</span></span><br><span class="line">   <span class="keyword">uint32_t</span> magic;		    <span class="comment">// 用来标识文件系统类型,支持多文件系统的操作系统通过此标志来识别文件系统类型</span></span><br><span class="line">   <span class="keyword">uint32_t</span> sec_cnt;		    <span class="comment">// 本分区总共的扇区数</span></span><br><span class="line">   <span class="keyword">uint32_t</span> inode_cnt;		    <span class="comment">// 本分区中inode数量</span></span><br><span class="line">   <span class="keyword">uint32_t</span> part_lba_base;	    <span class="comment">// 本分区的起始lba地址</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">uint32_t</span> block_bitmap_lba;	    <span class="comment">// 块位图本身起始扇区地址</span></span><br><span class="line">   <span class="keyword">uint32_t</span> block_bitmap_sects;     <span class="comment">// 扇区位图本身占用的扇区数量</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">uint32_t</span> inode_bitmap_lba;	    <span class="comment">// i结点位图起始扇区lba地址</span></span><br><span class="line">   <span class="keyword">uint32_t</span> inode_bitmap_sects;	    <span class="comment">// i结点位图占用的扇区数量</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">uint32_t</span> inode_table_lba;	    <span class="comment">// i结点表起始扇区lba地址</span></span><br><span class="line">   <span class="keyword">uint32_t</span> inode_table_sects;	    <span class="comment">// i结点表占用的扇区数量</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">uint32_t</span> data_start_lba;	    <span class="comment">// 数据区开始的第一个扇区号</span></span><br><span class="line">   <span class="keyword">uint32_t</span> root_inode_no;	    <span class="comment">// 根目录所在的I结点号</span></span><br><span class="line">   <span class="keyword">uint32_t</span> dir_entry_size;	    <span class="comment">// 目录项大小</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">uint8_t</span>  pad[<span class="number">460</span>];		    <span class="comment">// 加上460字节,凑够512字节1扇区大小</span></span><br><span class="line">&#125; __attribute__ ((packed));</span><br></pre></td></tr></table></figure></p>
<p>超级块连1扇区都不到，但磁盘操作要以扇区为单位在超级块的最后定义了460字节的pad 数组填充扇区，凑够512字节。为了保证编译后的超级块实例大小为512 字节，添加了<code>__attribute__ ((packed));</code>。</p>
<p>inode 定义在<code>fs/inode.h</code>中：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* inode结构 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> &#123;</span></span><br><span class="line">   <span class="keyword">uint32_t</span> i_no;    <span class="comment">// inode编号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 当此inode是文件时,i_size是指文件大小,</span></span><br><span class="line"><span class="comment">若此inode是目录,i_size是指该目录下所有目录项大小之和*/</span></span><br><span class="line">   <span class="keyword">uint32_t</span> i_size;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">uint32_t</span> i_open_cnts;   <span class="comment">// 记录此文件被打开的次数</span></span><br><span class="line">   <span class="keyword">bool</span> write_deny;	   <span class="comment">// 写文件不能并行,进程写文件前检查此标识</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* i_sectors[0-11]是直接块, i_sectors[12]用来存储一级间接块指针 */</span></span><br><span class="line">   <span class="keyword">uint32_t</span> i_sectors[<span class="number">13</span>];</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span> <span class="title">inode_tag</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>inode 结构中：</p>
<ul>
<li><code>i_no</code>是inode编号，它是在inode 数组中的下标。</li>
<li><code>i_size</code>是此inode 指向的文件的大小。<ul>
<li>inode 指向的是普通文件时，i_size表示普通文件的大小，</li>
<li>inode 指向的是目录时，i_size 表示目录中所有目录项的大小之和。</li>
<li>i_size 是以字节为单位的大小，并不是以数据块为单位</li>
</ul>
</li>
<li><code>i_open_cnts</code>表示<strong>此文件被打开的次数</strong>。</li>
<li><code>write_deny</code>用于限制文件的并行写操作，必须保证文件在执行写操作时，该文件不能再有其他并行的写操作</li>
<li><code>i_sectors</code>是数据块的指针，<ul>
<li>数据的前12 个块i_sectors[0-11]是直接块，也就是它们中记录的是数据块的扇区地址</li>
<li>i_sectors[12]用来存储一级间接块索引表的扇区地址</li>
</ul>
</li>
<li><code>inode_tag</code> 是此inode 的标识，用于加入<strong>已打开的inode 列表</strong>作为缓存。</li>
</ul>
<p>目录项的定义在<code>fs/dir.h</code>中，如代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_FILE_NAME_LEN  16	 <span class="comment">// 最大文件名长度</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 目录结构 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dir</span> &#123;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">inode</span>* <span class="title">inode</span>;</span>   </span><br><span class="line">   <span class="keyword">uint32_t</span> dir_pos;	  <span class="comment">// 记录在目录内的偏移</span></span><br><span class="line">   <span class="keyword">uint8_t</span> dir_buf[<span class="number">512</span>];  <span class="comment">// 目录的数据缓存</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 目录项结构 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dir_entry</span> &#123;</span></span><br><span class="line">   <span class="keyword">char</span> filename[MAX_FILE_NAME_LEN];  <span class="comment">// 普通文件或目录名称</span></span><br><span class="line">   <span class="keyword">uint32_t</span> i_no;		      <span class="comment">// 普通文件或目录对应的inode编号</span></span><br><span class="line">   <span class="keyword">enum</span> file_types f_type;	      <span class="comment">// 文件类型</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>宏<code>MAX_FILE_NAME_LEN</code>便是文件名的最大长度，其值为16。<code>struct dir</code>是目录结构，它并不在磁盘上存在，只用于与目录相关的操作时，在内存中创建。其成员inode 是指针，用于指向内存中inode，该inode 必然是在<strong>已打开的inode 队列</strong>；成员<code>dir_pos</code>用于遍历目录时记录“游标”在目录中的偏移，也就是目录项的偏移量，所以<code>dir_pos</code>大小应为目录项大小的整数倍。成员<code>dir_buf</code>用于目录的数据缓存，如读取目录时，用来存储返回的目录项，这是后话了。</p>
<p>下面是目录项结构<code>struct dir_entry</code>，它是连接文件名与inode 的纽带，成员<code>filename</code>是文件名，这里只支持最大16 个字符的文件名。成员<code>i_no</code>是文件filename 对应的inode 编号。成员<code>f_type</code>是指filename 的类型，具体类型定义在<code>fs/fs.h</code> 中。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_FILES_PER_PART 4096	    <span class="comment">// 每个分区所支持最大创建的文件数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BITS_PER_SECTOR 4096	    <span class="comment">// 每扇区的位数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SECTOR_SIZE 512		    <span class="comment">// 扇区字节大小</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BLOCK_SIZE SECTOR_SIZE	    <span class="comment">// 块字节大小</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> file_types &#123;</span><br><span class="line">   FT_UNKNOWN,	  <span class="comment">// 不支持的文件类型</span></span><br><span class="line">   FT_REGULAR,	  <span class="comment">// 普通文件</span></span><br><span class="line">   FT_DIRECTORY	  <span class="comment">// 目录</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>完成格式化分区的函数是partition_format。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 格式化分区,也就是初始化分区的元信息,创建文件系统 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">partition_format</span><span class="params">(struct partition* part)</span> </span>&#123;</span><br><span class="line"><span class="comment">/* 为方便实现,一个块大小是一扇区 */</span></span><br><span class="line">   <span class="keyword">uint32_t</span> boot_sector_sects = <span class="number">1</span>;	  </span><br><span class="line">   <span class="keyword">uint32_t</span> super_block_sects = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">uint32_t</span> inode_bitmap_sects = DIV_ROUND_UP(MAX_FILES_PER_PART, BITS_PER_SECTOR);	   <span class="comment">// I结点位图占用的扇区数.最多支持4096个文件</span></span><br><span class="line">   <span class="keyword">uint32_t</span> inode_table_sects = DIV_ROUND_UP(((<span class="keyword">sizeof</span>(struct inode) * MAX_FILES_PER_PART)), SECTOR_SIZE);</span><br><span class="line">   <span class="keyword">uint32_t</span> used_sects = boot_sector_sects + super_block_sects + inode_bitmap_sects + inode_table_sects;</span><br><span class="line">   <span class="keyword">uint32_t</span> free_sects = part-&gt;sec_cnt - used_sects;  </span><br><span class="line"></span><br><span class="line"><span class="comment">/************** 简单处理块位图占据的扇区数 ***************/</span></span><br><span class="line">   <span class="keyword">uint32_t</span> block_bitmap_sects;</span><br><span class="line">   block_bitmap_sects = DIV_ROUND_UP(free_sects, BITS_PER_SECTOR);</span><br><span class="line">   <span class="comment">/* block_bitmap_bit_len是位图中位的长度,也是可用块的数量 */</span></span><br><span class="line">   <span class="keyword">uint32_t</span> block_bitmap_bit_len = free_sects - block_bitmap_sects; </span><br><span class="line">   block_bitmap_sects = DIV_ROUND_UP(block_bitmap_bit_len, BITS_PER_SECTOR); </span><br><span class="line"><span class="comment">/*********************************************************/</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* 超级块初始化 */</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> <span class="title">sb</span>;</span></span><br><span class="line">   sb.magic = <span class="number">0x19590318</span>;</span><br><span class="line">   sb.sec_cnt = part-&gt;sec_cnt;</span><br><span class="line">   sb.inode_cnt = MAX_FILES_PER_PART;</span><br><span class="line">   sb.part_lba_base = part-&gt;start_lba;</span><br><span class="line"></span><br><span class="line">   sb.block_bitmap_lba = sb.part_lba_base + <span class="number">2</span>;	 <span class="comment">// 第0块是引导块,第1块是超级块</span></span><br><span class="line">   sb.block_bitmap_sects = block_bitmap_sects;</span><br><span class="line"></span><br><span class="line">   sb.inode_bitmap_lba = sb.block_bitmap_lba + sb.block_bitmap_sects;</span><br><span class="line">   sb.inode_bitmap_sects = inode_bitmap_sects;</span><br><span class="line"></span><br><span class="line">   sb.inode_table_lba = sb.inode_bitmap_lba + sb.inode_bitmap_sects;</span><br><span class="line">   sb.inode_table_sects = inode_table_sects; </span><br><span class="line"></span><br><span class="line">   sb.data_start_lba = sb.inode_table_lba + sb.inode_table_sects;</span><br><span class="line">   sb.root_inode_no = <span class="number">0</span>;</span><br><span class="line">   sb.dir_entry_size = <span class="keyword">sizeof</span>(struct dir_entry);</span><br><span class="line"></span><br><span class="line">   printk(<span class="string">"%s info:\n"</span>, part-&gt;name);</span><br><span class="line">   printk(<span class="string">"   magic:0x%x\n   part_lba_base:0x%x\n   all_sectors:0x%x\n   inode_cnt:0x%x\n   block_bitmap_lba:0x%x\n   block_bitmap_sectors:0x%x\n   inode_bitmap_lba:0x%x\n   inode_bitmap_sectors:0x%x\n   inode_table_lba:0x%x\n   inode_table_sectors:0x%x\n   data_start_lba:0x%x\n"</span>, sb.magic, sb.part_lba_base, sb.sec_cnt, sb.inode_cnt, sb.block_bitmap_lba, sb.block_bitmap_sects, sb.inode_bitmap_lba, sb.inode_bitmap_sects, sb.inode_table_lba, sb.inode_table_sects, sb.data_start_lba);</span><br></pre></td></tr></table></figure></p>
<p>函数<code>partition_format</code>接受1 个参数，待创建文件系统的分区part。<strong>创建文件系统就是创建文件系统所需要的元信息</strong>，这包括超级块位置及大小、空闲块位图的位置及大小、inode 位图的位置及大小、inode 数组的位置及大小、空闲块起始地址、根目录起始地址。创建步骤如下：</p>
<ol>
<li>根据分区part 大小，计算分区文件系统各元信息需要的扇区数及位置。</li>
<li>在内存中创建超级块，将以上步骤计算的元信息写入超级块。</li>
<li>将超级块写入磁盘。</li>
<li>将元信息写入磁盘上各自的位置。</li>
<li>将根目录写入磁盘。</li>
</ol>
<p>为引导块和超级块占用的扇区数赋值，简单起见，它们均占用1 扇区大小。<code>inode_bitmap_sects</code>表示<code>inode</code>位图占用的扇区数，<code>MAX_FILES_PER_PART</code>定义在<code>fs.h</code>中，表示分区可创建的最大文件数，也就是<code>inode</code>数量，它的值为4096。<code>BITS_PER_SECTOR</code>同样定义在<code>fs.h</code>中，其值也为4096，经过宏<code>DIV_ROUND_UP</code>计算后<code>inode_bitmap_sects</code>的值为1，inode 位图占用1 扇区。</p>
<p><code>inode_table_sects</code>表示inode 数组占用的扇区数，这是由inode 的尺寸和数量决定的。先用<strong>空闲块数<code>free_sects</code></strong>除以每扇区的位数，这样便得到了空闲块位图<code>block_bitmap</code>占用的扇区数<code>block_bitmap_sects</code>。空闲块位图占用了一部分空闲扇区，因此现在真正的空闲块数得把<code>lock_bitmap_sects</code>从<code>free_sets</code>中减去，其结果也是位图中位的个数，把结果写入变量<code>block_bitmap_bit_len</code>，然后再用变量<code>lock_bitmap_bit_len</code>重新除以<code>BITS_PER_SECTOR</code>，这便是空闲块位图最终占用的扇区数<code>block_bitmap_sects</code>。</p>
<p>代码<code>sb.root_inode_no = 0</code>表示根目录的inode 编号为0，也就是说inode 数组中第0 个inode 我们留给了根目录。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">disk</span>* <span class="title">hd</span> = <span class="title">part</span>-&gt;<span class="title">my_disk</span>;</span></span><br><span class="line"><span class="comment">/*******************************</span></span><br><span class="line"><span class="comment"> * 1 将超级块写入本分区的1扇区 *</span></span><br><span class="line"><span class="comment"> ******************************/</span></span><br><span class="line">   ide_write(hd, part-&gt;start_lba + <span class="number">1</span>, &amp;sb, <span class="number">1</span>);</span><br><span class="line">   printk(<span class="string">"   super_block_lba:0x%x\n"</span>, part-&gt;start_lba + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 找出数据量最大的元信息,用其尺寸做存储缓冲区*/</span></span><br><span class="line">   <span class="keyword">uint32_t</span> buf_size = (sb.block_bitmap_sects &gt;= sb.inode_bitmap_sects ? sb.block_bitmap_sects : sb.inode_bitmap_sects);</span><br><span class="line">   buf_size = (buf_size &gt;= sb.inode_table_sects ? buf_size : sb.inode_table_sects) * SECTOR_SIZE;</span><br><span class="line">   <span class="keyword">uint8_t</span>* buf = (<span class="keyword">uint8_t</span>*)sys_malloc(buf_size);	<span class="comment">// 申请的内存由内存管理系统清0后返回</span></span><br><span class="line">   </span><br><span class="line"><span class="comment">/**************************************</span></span><br><span class="line"><span class="comment"> * 2 将块位图初始化并写入sb.block_bitmap_lba *</span></span><br><span class="line"><span class="comment"> *************************************/</span></span><br><span class="line">   <span class="comment">/* 初始化块位图block_bitmap */</span></span><br><span class="line">   buf[<span class="number">0</span>] |= <span class="number">0x01</span>;       <span class="comment">// 第0个块预留给根目录,位图中先占位</span></span><br><span class="line">   <span class="keyword">uint32_t</span> block_bitmap_last_byte = block_bitmap_bit_len / <span class="number">8</span>;</span><br><span class="line">   <span class="keyword">uint8_t</span>  block_bitmap_last_bit  = block_bitmap_bit_len % <span class="number">8</span>;</span><br><span class="line">   <span class="keyword">uint32_t</span> last_size = SECTOR_SIZE - (block_bitmap_last_byte % SECTOR_SIZE);	     <span class="comment">// last_size是位图所在最后一个扇区中，不足一扇区的其余部分</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 1 先将位图最后一字节到其所在的扇区的结束全置为1,即超出实际块数的部分直接置为已占用*/</span></span><br><span class="line">   <span class="built_in">memset</span>(&amp;buf[block_bitmap_last_byte], <span class="number">0xff</span>, last_size);</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* 2 再将上一步中覆盖的最后一字节内的有效位重新置0 */</span></span><br><span class="line">   <span class="keyword">uint8_t</span> bit_idx = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span> (bit_idx &lt;= block_bitmap_last_bit) &#123;</span><br><span class="line">      buf[block_bitmap_last_byte] &amp;= ~(<span class="number">1</span> &lt;&lt; bit_idx++);</span><br><span class="line">   &#125;</span><br><span class="line">   ide_write(hd, sb.block_bitmap_lba, buf, sb.block_bitmap_sects);</span><br></pre></td></tr></table></figure>
<p>获取分区part 自己所属的硬盘hd，hd 将作为后续参数。超级块已经构建完成，将其写到本分区开始的扇区加1 的地方，即<code>part-&gt;start_lba + 1</code>，也就是<strong>跨过引导扇区，把超级块写入引导扇区后面的扇区中</strong>。选出占用空间最大的元信息，使其尺寸作为申请的缓冲区大小，申请内存返回给指针buf，buf 是通用的缓冲区，接下来往磁盘中的数据写入操作都将buf 作为数据源，通过不同的类型转换，使buf 变成合适的缓冲区类型。</p>
<p>我们把第0 个空闲块作为根目录，因此我们需要在空闲块位图中将第0 位置1。<strong>把块位图最后一个扇区中不属于空闲块的位初始为1</strong>。在将位图持久化到硬盘之前，<strong>一定要将位图最后一扇区中的多余位初始为1，表示它们已被占用</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***************************************</span></span><br><span class="line"><span class="comment"> * 3 将inode位图初始化并写入sb.inode_bitmap_lba *</span></span><br><span class="line"><span class="comment"> ***************************************/</span></span><br><span class="line">   <span class="comment">/* 先清空缓冲区*/</span></span><br><span class="line">   <span class="built_in">memset</span>(buf, <span class="number">0</span>, buf_size);</span><br><span class="line">   buf[<span class="number">0</span>] |= <span class="number">0x1</span>;      <span class="comment">// 第0个inode分给了根目录</span></span><br><span class="line">   <span class="comment">/* 由于inode_table中共4096个inode,位图inode_bitmap正好占用1扇区,</span></span><br><span class="line"><span class="comment">    * 即inode_bitmap_sects等于1, 所以位图中的位全都代表inode_table中的inode,</span></span><br><span class="line"><span class="comment">    * 无须再像block_bitmap那样单独处理最后一扇区的剩余部分,</span></span><br><span class="line"><span class="comment">    * inode_bitmap所在的扇区中没有多余的无效位 */</span></span><br><span class="line">   ide_write(hd, sb.inode_bitmap_lba, buf, sb.inode_bitmap_sects);</span><br><span class="line"></span><br><span class="line"><span class="comment">/***************************************</span></span><br><span class="line"><span class="comment"> * 4 将inode数组初始化并写入sb.inode_table_lba *</span></span><br><span class="line"><span class="comment"> ***************************************/</span></span><br><span class="line"> <span class="comment">/* 准备写inode_table中的第0项,即根目录所在的inode */</span></span><br><span class="line">   <span class="built_in">memset</span>(buf, <span class="number">0</span>, buf_size);  <span class="comment">// 先清空缓冲区buf</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">inode</span>* <span class="title">i</span> = (<span class="title">struct</span> <span class="title">inode</span>*)<span class="title">buf</span>;</span> </span><br><span class="line">   i-&gt;i_size = sb.dir_entry_size * <span class="number">2</span>;	 <span class="comment">// .和..</span></span><br><span class="line">   i-&gt;i_no = <span class="number">0</span>;   <span class="comment">// 根目录占inode数组中第0个inode</span></span><br><span class="line">   i-&gt;i_sectors[<span class="number">0</span>] = sb.data_start_lba;	     <span class="comment">// 由于上面的memset,i_sectors数组的其它元素都初始化为0 </span></span><br><span class="line">   ide_write(hd, sb.inode_table_lba, buf, sb.inode_table_sects);</span><br><span class="line">   </span><br><span class="line"><span class="comment">/***************************************</span></span><br><span class="line"><span class="comment"> * 5 将根目录初始化并写入sb.data_start_lba</span></span><br><span class="line"><span class="comment"> ***************************************/</span></span><br><span class="line">   <span class="comment">/* 写入根目录的两个目录项.和.. */</span></span><br><span class="line">   <span class="built_in">memset</span>(buf, <span class="number">0</span>, buf_size);</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">dir_entry</span>* <span class="title">p_de</span> = (<span class="title">struct</span> <span class="title">dir_entry</span>*)<span class="title">buf</span>;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 初始化当前目录"." */</span></span><br><span class="line">   <span class="built_in">memcpy</span>(p_de-&gt;filename, <span class="string">"."</span>, <span class="number">1</span>);</span><br><span class="line">   p_de-&gt;i_no = <span class="number">0</span>;</span><br><span class="line">   p_de-&gt;f_type = FT_DIRECTORY;</span><br><span class="line">   p_de++;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 初始化当前目录父目录".." */</span></span><br><span class="line">   <span class="built_in">memcpy</span>(p_de-&gt;filename, <span class="string">".."</span>, <span class="number">2</span>);</span><br><span class="line">   p_de-&gt;i_no = <span class="number">0</span>;   <span class="comment">// 根目录的父目录依然是根目录自己</span></span><br><span class="line">   p_de-&gt;f_type = FT_DIRECTORY;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* sb.data_start_lba已经分配给了根目录,里面是根目录的目录项 */</span></span><br><span class="line">   ide_write(hd, sb.data_start_lba, buf, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">   printk(<span class="string">"   root_dir_lba:0x%x\n"</span>, sb.data_start_lba);</span><br><span class="line">   printk(<span class="string">"%s format done\n"</span>, part-&gt;name);</span><br><span class="line">   sys_free(buf);</span><br></pre></td></tr></table></figure>
<p>将inode 位图（buf）中第0 个inode 置为1，原因是<strong>我们把inode 数组中第0 个inode 分配给了根目录</strong>。接下来准备把<code>inode</code>数组写入<code>sb.inode_table_lba</code>。<code>inode_table_sects</code>是通过宏<code>DIV_ROUND_UP</code>除法向上取整得到的结果，因此<code>inode_table</code>最终在磁盘上占据的全部扇区中，并不是所有空间都是<code>inode_table</code>的内容。</p>
<p>我们把第0 个inode 已经分配给了根目录，因此现在要<strong>初始化第0 个inode 为根目录的信息</strong>。将<code>buf</code>转换为<code>inode</code>结构<code>struct inode</code>型指针后，通过<code>i-&gt;i_size = sb.dir_entry_ size * 2</code>将<code>i_size</code>赋值为两个目录项的大小。<code>i-&gt;i_no = 0</code>为inode 编号赋值为0，表示此inode 自己是inode 数组中第0 个inode。<code>i-&gt;i_sectors[0] = sb.data_start_lba</code>使<strong>此inode 的第0 个数据块指向<code>sb.data_start_lba</code></strong>，也就是我们把根目录安排在最开始的空闲块中。</p>
<p>memset清0 工作使<code>i_sectors</code>数组的其他元素也都被初始化为0。最后一项工作是在根目录中写目录项”.”和”..”。任何目录都有这两个目录项，”.”表示当前目录，”..”表示上一级目录。将<code>buf</code>转换为目录项<code>struct dir_entry</code>型指针，此时<code>p_de</code>指向buf，接下来先对第1 个目录项<code>.</code>初始化。通过<code>memcpy</code>函数把<code>.</code>写入目录项的<code>filename</code>成员，接下来分别为目录项的<code>i_no</code>赋值为0，使其指向根目录自己，为目录项的<code>f_type</code>赋值为<code>FT_DIRECTORY</code>，使其类型为目录。<code>p_de++</code>执行过后，<code>p_de</code>指向下一目录项<code>..</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 在磁盘上搜索文件系统,若没有则格式化分区创建文件系统 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">filesys_init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">uint8_t</span> channel_no = <span class="number">0</span>, dev_no, part_idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* sb_buf用来存储从硬盘上读入的超级块 */</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">super_block</span>* <span class="title">sb_buf</span> = (<span class="title">struct</span> <span class="title">super_block</span>*)<span class="title">sys_malloc</span>(<span class="title">SECTOR_SIZE</span>);</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (sb_buf == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      PANIC(<span class="string">"alloc memory failed!"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   printk(<span class="string">"searching filesystem......\n"</span>);</span><br><span class="line">   <span class="keyword">while</span> (channel_no &lt; channel_cnt) &#123;</span><br><span class="line">      dev_no = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span>(dev_no &lt; <span class="number">2</span>) &#123;</span><br><span class="line">	 <span class="keyword">if</span> (dev_no == <span class="number">0</span>) &#123;   <span class="comment">// 跨过裸盘hd60M.img</span></span><br><span class="line">	    dev_no++;</span><br><span class="line">	    <span class="keyword">continue</span>;</span><br><span class="line">	 &#125;</span><br><span class="line">	 <span class="class"><span class="keyword">struct</span> <span class="title">disk</span>* <span class="title">hd</span> = &amp;<span class="title">channels</span>[<span class="title">channel_no</span>].<span class="title">devices</span>[<span class="title">dev_no</span>];</span></span><br><span class="line">	 <span class="class"><span class="keyword">struct</span> <span class="title">partition</span>* <span class="title">part</span> = <span class="title">hd</span>-&gt;<span class="title">prim_parts</span>;</span></span><br><span class="line">	 <span class="keyword">while</span>(part_idx &lt; <span class="number">12</span>) &#123;   <span class="comment">// 4个主分区+8个逻辑</span></span><br><span class="line">	    <span class="keyword">if</span> (part_idx == <span class="number">4</span>) &#123;  <span class="comment">// 开始处理逻辑分区</span></span><br><span class="line">	       part = hd-&gt;logic_parts;</span><br><span class="line">	    &#125;</span><br><span class="line">	 </span><br><span class="line">	 <span class="comment">/* channels数组是全局变量,默认值为0,disk属于其嵌套结构,</span></span><br><span class="line"><span class="comment">	  * partition又为disk的嵌套结构,因此partition中的成员默认也为0.</span></span><br><span class="line"><span class="comment">	  * 若partition未初始化,则partition中的成员仍为0. </span></span><br><span class="line"><span class="comment">	  * 下面处理存在的分区. */</span></span><br><span class="line">	    <span class="keyword">if</span> (part-&gt;sec_cnt != <span class="number">0</span>) &#123;  <span class="comment">// 如果分区存在</span></span><br><span class="line">	       <span class="built_in">memset</span>(sb_buf, <span class="number">0</span>, SECTOR_SIZE);</span><br><span class="line"></span><br><span class="line">	       <span class="comment">/* 读出分区的超级块,根据魔数是否正确来判断是否存在文件系统 */</span></span><br><span class="line">	       ide_read(hd, part-&gt;start_lba + <span class="number">1</span>, sb_buf, <span class="number">1</span>);   </span><br><span class="line"></span><br><span class="line">	       <span class="comment">/* 只支持自己的文件系统.若磁盘上已经有文件系统就不再格式化了 */</span></span><br><span class="line">	       <span class="keyword">if</span> (sb_buf-&gt;magic == <span class="number">0x19590318</span>) &#123;</span><br><span class="line">		  printk(<span class="string">"%s has filesystem\n"</span>, part-&gt;name);</span><br><span class="line">	       &#125; <span class="keyword">else</span> &#123;			  <span class="comment">// 其它文件系统不支持,一律按无文件系统处理</span></span><br><span class="line">		  printk(<span class="string">"formatting %s`s partition %s......\n"</span>, hd-&gt;name, part-&gt;name);</span><br><span class="line">		  partition_format(part);</span><br><span class="line">	       &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	    part_idx++;</span><br><span class="line">	    part++;	<span class="comment">// 下一分区</span></span><br><span class="line">	 &#125;</span><br><span class="line">	 dev_no++;	<span class="comment">// 下一磁盘</span></span><br><span class="line">      &#125;</span><br><span class="line">      channel_no++;	<span class="comment">// 下一通道</span></span><br><span class="line">   &#125;</span><br><span class="line">   sys_free(sb_buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里只支持<code>partition_format</code>创建的文件系统，其魔数等于<code>0x19590318</code>，如果未发现魔数为<code>0x19590318</code>的文件系统就调用<code>partition_format</code>去创建。</p>
<h2 id="文件描述符简介"><a href="#文件描述符简介" class="headerlink" title="文件描述符简介"></a>文件描述符简介</h2><p>Linux 提供了称为<strong>文件结构</strong>的数据结构，专门用于记录与文件操作相关的信息，<strong>每次打开一个文件就会产生一个文件结构</strong>，多次打开该文件就为该文件生成多个文件结构，各自文件操作的偏移量分别记录在不同的文件结构中，从而实现了<strong>即使同一个文件被同时多次打开，各自操作的偏移量也互不影响</strong>的灵活性。Linux 把所有的“文件结构”组织到一起形成数组统一管理，该数组称为文件表。</p>
<p>在Linux 中<strong>每个进程都有单独的、完全相同的一套文件描述符</strong>，为避免文件表占用过大的内存空间，进程可打开的最大文件数有限。文件描述符数组中<br>的前3 个都是标准的文件描述符，如文件描述符<strong>0 表示标准输入</strong>，<strong>1 表示标准输出</strong>，<strong>2 表示标准错误</strong>。</p>
<p>文件结构中包含<strong>进程执行文件操作的偏移量</strong>，它属于<strong>与各个任务单独绑定的资源</strong>。当用户进程打开文件时，文件系统给用户进程返回的是<strong>该进程PCB 中文件描述符数组下标值</strong>，也就是文件描述符。<br><img src="/img/1597134858.jpg" alt></p>
<p>这涉及到以下三个数据结构，它们都是位于内存中的。</p>
<ol>
<li>PCB 中的文件描述符数组。</li>
<li>存储所有文件结构的文件表。</li>
<li>inode 队列，也就是inode 缓存。</li>
</ol>
<p>某进程把文件描述符作为参数提交给文件系统时，文件系统用此文件描述符在该进程的PCB 中的文件描述符数组中索引对应的元素，从该元素中获取对应的文件结构的下标，用该下标在文件表中索引相应的文件结构，从该文件结构中获取文件的inode，最终找到了文件的数据块。</p>
<p>其实open 操作的本质就是<strong>创建相应文件描述符的过程</strong>，创建文件描述符的过程就是逐层在这三个数据结构中找空位，在该空位填充好数据后返回该位置的地址，比如：</p>
<ol>
<li>在全局的inode 队列中新建一inode（这肯定是在空位置处新建），然后返回该inode 地址。</li>
<li>在全局的文件表中找一空位，在该位置填充文件结构，使其fd_inode 指向上一步中返回的inode地址，然后返回本文件结构在文件表中的下标值。</li>
<li>在PCB 中的文件描述符数组中找一空位，使该位置的值指向上一步中返回的文件结构下标，并返回本文件描述符在文件描述符数组中的下标值。</li>
</ol>
<p>我们不仅要添加单独的文件处理模块，还需要改进pcb。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_FILES_OPEN_PER_PROC 8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 进程或线程的pcb，程序控制块 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line">   <span class="keyword">uint32_t</span> elapsed_ticks;</span><br><span class="line">   <span class="keyword">int32_t</span> fd_table[MAX_FILES_OPEN_PER_PROC]; <span class="comment">// 文件描述符数组</span></span><br><span class="line">   <span class="comment">/* general_tag 的作用是用于线程在一般的队列中的结点 */</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span> <span class="title">general_tag</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>fd_table</code> 是任务的文件描述符数组，其类型是<code>int32_t</code>，即每个成员都是<code>int32_t</code>整数，其长度是宏<code>MAX_FILES_OPEN_PER_PROC</code>，此宏的值是8，也就是每个任务可以打开的文件数是8。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 初始化线程基本信息 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_thread</span><span class="params">(struct task_struct* pthread, <span class="keyword">char</span>* name, <span class="keyword">int</span> prio)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 预留标准输入输出*/</span></span><br><span class="line">   pthread-&gt;fd_table[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">   pthread-&gt;fd_table[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">   pthread-&gt;fd_table[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">   <span class="comment">/* 其余的全置为-1 */</span></span><br><span class="line">   <span class="keyword">uint8_t</span> fd_idx = <span class="number">3</span>;</span><br><span class="line">   <span class="keyword">while</span> (fd_idx &lt; MAX_FILES_OPEN_PER_PROC) &#123;</span><br><span class="line">      pthread-&gt;fd_table[fd_idx] = <span class="number">-1</span>;</span><br><span class="line">      fd_idx++;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   pthread-&gt;stack_magic = <span class="number">0x19870916</span>; <span class="comment">// 自定义的魔数</span></span><br></pre></td></tr></table></figure>
<p>三个标准的文件描述符，0 是标准输入，1 是标准输出，2 是标准错误。</p>
<h2 id="文件操作相关的基础函数"><a href="#文件操作相关的基础函数" class="headerlink" title="文件操作相关的基础函数"></a>文件操作相关的基础函数</h2><h3 id="inode-操作有关的函数"><a href="#inode-操作有关的函数" class="headerlink" title="inode 操作有关的函数"></a>inode 操作有关的函数</h3><p>与inode 实现相关的代码在<code>fs/inode.c</code>中，这是新创建的文件：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 用来存储inode位置 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode_position</span> &#123;</span></span><br><span class="line">   <span class="keyword">bool</span>	 two_sec;	<span class="comment">// inode是否跨扇区</span></span><br><span class="line">   <span class="keyword">uint32_t</span> sec_lba;	<span class="comment">// inode所在的扇区号</span></span><br><span class="line">   <span class="keyword">uint32_t</span> off_size;	<span class="comment">// inode在扇区内的字节偏移量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取inode所在的扇区和扇区内的偏移量 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inode_locate</span><span class="params">(struct partition* part, <span class="keyword">uint32_t</span> inode_no, struct inode_position* inode_pos)</span> </span>&#123;</span><br><span class="line">   <span class="comment">/* inode_table在硬盘上是连续的 */</span></span><br><span class="line">   ASSERT(inode_no &lt; <span class="number">4096</span>);</span><br><span class="line">   <span class="keyword">uint32_t</span> inode_table_lba = part-&gt;sb-&gt;inode_table_lba;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">uint32_t</span> inode_size = <span class="keyword">sizeof</span>(struct inode);</span><br><span class="line">   <span class="keyword">uint32_t</span> off_size = inode_no * inode_size;	    <span class="comment">// 第inode_no号I结点相对于inode_table_lba的字节偏移量</span></span><br><span class="line">   <span class="keyword">uint32_t</span> off_sec  = off_size / <span class="number">512</span>;		    <span class="comment">// 第inode_no号I结点相对于inode_table_lba的扇区偏移量</span></span><br><span class="line">   <span class="keyword">uint32_t</span> off_size_in_sec = off_size % <span class="number">512</span>;	    <span class="comment">// 待查找的inode所在扇区中的起始地址</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 判断此i结点是否跨越2个扇区 */</span></span><br><span class="line">   <span class="keyword">uint32_t</span> left_in_sec = <span class="number">512</span> - off_size_in_sec;</span><br><span class="line">   <span class="keyword">if</span> (left_in_sec &lt; inode_size ) &#123;	  <span class="comment">// 若扇区内剩下的空间不足以容纳一个inode,必然是I结点跨越了2个扇区</span></span><br><span class="line">      inode_pos-&gt;two_sec = <span class="literal">true</span>;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;				  <span class="comment">// 否则,所查找的inode未跨扇区</span></span><br><span class="line">      inode_pos-&gt;two_sec = <span class="literal">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   inode_pos-&gt;sec_lba = inode_table_lba + off_sec;</span><br><span class="line">   inode_pos-&gt;off_size = off_size_in_sec;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将inode写入到分区part */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inode_sync</span><span class="params">(struct partition* part, struct inode* inode, <span class="keyword">void</span>* io_buf)</span> </span>&#123;	 <span class="comment">// io_buf是用于硬盘io的缓冲区</span></span><br><span class="line">   <span class="keyword">uint8_t</span> inode_no = inode-&gt;i_no;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">inode_position</span> <span class="title">inode_pos</span>;</span></span><br><span class="line">   inode_locate(part, inode_no, &amp;inode_pos);	       <span class="comment">// inode位置信息会存入inode_pos</span></span><br><span class="line">   ASSERT(inode_pos.sec_lba &lt;= (part-&gt;start_lba + part-&gt;sec_cnt));</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* 硬盘中的inode中的成员inode_tag和i_open_cnts是不需要的,</span></span><br><span class="line"><span class="comment">    * 它们只在内存中记录链表位置和被多少进程共享 */</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> <span class="title">pure_inode</span>;</span></span><br><span class="line">   <span class="built_in">memcpy</span>(&amp;pure_inode, inode, <span class="keyword">sizeof</span>(struct inode));</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 以下inode的三个成员只存在于内存中,现在将inode同步到硬盘,清掉这三项即可 */</span></span><br><span class="line">   pure_inode.i_open_cnts = <span class="number">0</span>;</span><br><span class="line">   pure_inode.write_deny = <span class="literal">false</span>;	 <span class="comment">// 置为false,以保证在硬盘中读出时为可写</span></span><br><span class="line">   pure_inode.inode_tag.prev = pure_inode.inode_tag.next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">char</span>* inode_buf = (<span class="keyword">char</span>*)io_buf;</span><br><span class="line">   <span class="keyword">if</span> (inode_pos.two_sec) &#123;	    <span class="comment">// 若是跨了两个扇区,就要读出两个扇区再写入两个扇区</span></span><br><span class="line">   <span class="comment">/* 读写硬盘是以扇区为单位,若写入的数据小于一扇区,要将原硬盘上的内容先读出来再和新数据拼成一扇区后再写入  */</span></span><br><span class="line">      ide_read(part-&gt;my_disk, inode_pos.sec_lba, inode_buf, <span class="number">2</span>);	<span class="comment">// inode在format中写入硬盘时是连续写入的,所以读入2块扇区</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 开始将待写入的inode拼入到这2个扇区中的相应位置 */</span></span><br><span class="line">      <span class="built_in">memcpy</span>((inode_buf + inode_pos.off_size), &amp;pure_inode, <span class="keyword">sizeof</span>(struct inode));</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* 将拼接好的数据再写入磁盘 */</span></span><br><span class="line">      ide_write(part-&gt;my_disk, inode_pos.sec_lba, inode_buf, <span class="number">2</span>);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;			    <span class="comment">// 若只是一个扇区</span></span><br><span class="line">      ide_read(part-&gt;my_disk, inode_pos.sec_lba, inode_buf, <span class="number">1</span>);</span><br><span class="line">      <span class="built_in">memcpy</span>((inode_buf + inode_pos.off_size), &amp;pure_inode, <span class="keyword">sizeof</span>(struct inode));</span><br><span class="line">      ide_write(part-&gt;my_disk, inode_pos.sec_lba, inode_buf, <span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>程序开头定义的<code>struct inode_position</code>用于<strong>记录inode 所在的扇区地址及在扇区内的偏移量</strong>，<code>two_sec</code>用于标识inode 是否跨扇区。<code>sec_lba</code>是inode 的扇区地址，<code>off_size</code>是<strong>inode在扇区内的偏移字节</strong>。</p>
<p>函数<code>inode_locate</code>接受3 个参数，<strong>分区part</strong>、<strong>inode编号inode_no</strong>及<strong>inode_pos</strong>，<code>inode_pos</code>类型是上面提到的<code>struct inode_position</code>，用于<strong>记录inode 在硬盘上的位置</strong>，函数功能是<strong>定位inode 所在的扇区和扇区内的偏移量，将其写入inode_pos 中</strong>。</p>
<p>获取编号为inode_no 对应的inode 的位置，<code>off_sec</code>是该inode偏移扇区地址，<code>off_size_in_sec</code>是该inode 在扇区中的偏移字节，<code>off_sec</code>是相<br>对于<code>inode_table_lba</code>的扇区偏移量。<code>off_sec</code>是相对于<code>inode_table</code>的扇区偏移量，因此<code>inode</code>的绝对扇区地址<code>inode_pos-&gt;sec_lba</code>等于<code>inode_table_lba</code>加上<code>off_sec</code>，而inode 扇区内的字节偏移量<code>inode_pos-&gt;off_size</code>仍然等于<code>off_size_in_sec</code>。</p>
<p>下面是函数<code>inode_sync</code>，它接受3 个参数，<strong>分区part</strong>、<strong>待同步的inode 指针</strong>、<strong>操作缓冲区io_buf</strong>，函数功能是<strong>将inode 写入到磁盘分区part</strong>。io_buf 是主调函数提供的缓冲区。先通过函数<code>inode_locate</code>定位该inode 的位置，位置信息在<code>inode_pos</code>中保存。inode 中的三个成员<code>i_open_cnts</code>、<code>write_deny</code>和<code>inode_tag</code>，它们用于统计inode 操作状态，只在内存中有意义。<code>io_buf</code>转换为<code>inode_buf</code>，此缓冲区用于拼接同步的inode 数据；判断inode 是否跨扇区，如果<code>inode_pos.two_sec</code>为true，说明该inode 横跨两个扇区，因此读入2 个扇区到inode_buf；<code>memcpy</code>函数将pure_inode 拷贝到inode_buf 中的相应位置。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* 根据i结点号返回相应的i结点 */</span></span><br><span class="line"><span class="function">struct inode* <span class="title">inode_open</span><span class="params">(struct partition* part, <span class="keyword">uint32_t</span> inode_no)</span> </span>&#123;</span><br><span class="line">   <span class="comment">/* 先在已打开inode链表中找inode,此链表是为提速创建的缓冲区 */</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span>* <span class="title">elem</span> = <span class="title">part</span>-&gt;<span class="title">open_inodes</span>.<span class="title">head</span>.<span class="title">next</span>;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">inode</span>* <span class="title">inode_found</span>;</span></span><br><span class="line">   <span class="keyword">while</span> (elem != &amp;part-&gt;open_inodes.tail) &#123;</span><br><span class="line">      inode_found = elem2entry(struct inode, inode_tag, elem);</span><br><span class="line">      <span class="keyword">if</span> (inode_found-&gt;i_no == inode_no) &#123;</span><br><span class="line">	 inode_found-&gt;i_open_cnts++;</span><br><span class="line">	 <span class="keyword">return</span> inode_found;</span><br><span class="line">      &#125;</span><br><span class="line">      elem = elem-&gt;next;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/*由于open_inodes链表中找不到,下面从硬盘上读入此inode并加入到此链表 */</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">inode_position</span> <span class="title">inode_pos</span>;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* inode位置信息会存入inode_pos, 包括inode所在扇区地址和扇区内的字节偏移量 */</span></span><br><span class="line">   inode_locate(part, inode_no, &amp;inode_pos);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 为使通过sys_malloc创建的新inode被所有任务共享,</span></span><br><span class="line"><span class="comment"> * 需要将inode置于内核空间,故需要临时</span></span><br><span class="line"><span class="comment"> * 将cur_pbc-&gt;pgdir置为NULL */</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>* <span class="title">cur</span> = <span class="title">running_thread</span>();</span></span><br><span class="line">   <span class="keyword">uint32_t</span>* cur_pagedir_bak = cur-&gt;pgdir;</span><br><span class="line">   cur-&gt;pgdir = <span class="literal">NULL</span>;</span><br><span class="line">   <span class="comment">/* 以上三行代码完成后下面分配的内存将位于内核区 */</span></span><br><span class="line">   inode_found = (struct inode*)sys_malloc(<span class="keyword">sizeof</span>(struct inode));</span><br><span class="line">   <span class="comment">/* 恢复pgdir */</span></span><br><span class="line">   cur-&gt;pgdir = cur_pagedir_bak;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">char</span>* inode_buf;</span><br><span class="line">   <span class="keyword">if</span> (inode_pos.two_sec) &#123;	<span class="comment">// 考虑跨扇区的情况</span></span><br><span class="line">      inode_buf = (<span class="keyword">char</span>*)sys_malloc(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* i结点表是被partition_format函数连续写入扇区的,</span></span><br><span class="line"><span class="comment">    * 所以下面可以连续读出来 */</span></span><br><span class="line">      ide_read(part-&gt;my_disk, inode_pos.sec_lba, inode_buf, <span class="number">2</span>);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;	<span class="comment">// 否则,所查找的inode未跨扇区,一个扇区大小的缓冲区足够</span></span><br><span class="line">      inode_buf = (<span class="keyword">char</span>*)sys_malloc(<span class="number">512</span>);</span><br><span class="line">      ide_read(part-&gt;my_disk, inode_pos.sec_lba, inode_buf, <span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">memcpy</span>(inode_found, inode_buf + inode_pos.off_size, <span class="keyword">sizeof</span>(struct inode));</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 因为一会很可能要用到此inode,故将其插入到队首便于提前检索到 */</span></span><br><span class="line">   list_push(&amp;part-&gt;open_inodes, &amp;inode_found-&gt;inode_tag);</span><br><span class="line">   inode_found-&gt;i_open_cnts = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">   sys_free(inode_buf);</span><br><span class="line">   <span class="keyword">return</span> inode_found;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 关闭inode或减少inode的打开数 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inode_close</span><span class="params">(struct inode* inode)</span> </span>&#123;</span><br><span class="line">   <span class="comment">/* 若没有进程再打开此文件,将此inode去掉并释放空间 */</span></span><br><span class="line">   <span class="keyword">enum</span> intr_status old_status = intr_disable();</span><br><span class="line">   <span class="keyword">if</span> (--inode-&gt;i_open_cnts == <span class="number">0</span>) &#123;</span><br><span class="line">      list_remove(&amp;inode-&gt;inode_tag);	  <span class="comment">// 将I结点从part-&gt;open_inodes中去掉</span></span><br><span class="line">   <span class="comment">/* inode_open时为实现inode被所有进程共享,</span></span><br><span class="line"><span class="comment">    * 已经在sys_malloc为inode分配了内核空间,</span></span><br><span class="line"><span class="comment">    * 释放inode时也要确保释放的是内核内存池 */</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>* <span class="title">cur</span> = <span class="title">running_thread</span>();</span></span><br><span class="line">      <span class="keyword">uint32_t</span>* cur_pagedir_bak = cur-&gt;pgdir;</span><br><span class="line">      cur-&gt;pgdir = <span class="literal">NULL</span>;</span><br><span class="line">      sys_free(inode);</span><br><span class="line">      cur-&gt;pgdir = cur_pagedir_bak;</span><br><span class="line">   &#125;</span><br><span class="line">   intr_set_status(old_status);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化new_inode */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inode_init</span><span class="params">(<span class="keyword">uint32_t</span> inode_no, struct inode* new_inode)</span> </span>&#123;</span><br><span class="line">   new_inode-&gt;i_no = inode_no;</span><br><span class="line">   new_inode-&gt;i_size = <span class="number">0</span>;</span><br><span class="line">   new_inode-&gt;i_open_cnts = <span class="number">0</span>;</span><br><span class="line">   new_inode-&gt;write_deny = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 初始化块索引数组i_sector */</span></span><br><span class="line">   <span class="keyword">uint8_t</span> sec_idx = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span> (sec_idx &lt; <span class="number">13</span>) &#123;</span><br><span class="line">   <span class="comment">/* i_sectors[12]为一级间接块地址 */</span></span><br><span class="line">      new_inode-&gt;i_sectors[sec_idx] = <span class="number">0</span>;</span><br><span class="line">      sec_idx++;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数inode_open 接受两个参数，<strong>分区part</strong>及<strong>inode编号inode_no</strong>，函数功能是<strong>根据inode_no 返回相应的i 结点指针</strong>。在内存中为各分区创建了inode 队列，即<code>part-&gt;open_inodes</code>，这个队列为已打开的inode的缓存。如果找到后就执行<code>return inode_found</code>返回找到的inode 指针。如果inode 队列中没有该inode，先创建<code>inode_pos</code>，调用<code>inode_locate</code>定位该inode，位置存储到inode_pos 中。</p>
<p>我们从硬盘上获取到的inode，其所占的内存是我们<strong>用sys_malloc从堆中分配的</strong>。为了使inode 置于内核空间被所有任务共享，需要<strong>临时将当前任务<code>pcb-&gt;pgdir</code>置为NULL，待为inode 完成内存分配后再将任务的pgdir 恢复</strong>。先将当前任务的页表地址备份到变量<code>cur_pagedir_bak</code>中，将pgdir 置为NULL 后，接着调用<code>sys_malloc</code>分配1个inode 大小的内存，指针存入变量inode_found，它是我们为磁盘上的inode 所分配的内存变量。然后将<code>pgdir</code>恢复为<code>cur_pagedir_bak</code>。根据程序<strong>局部性原理</strong>，通常情况下此inode 会被再次使用到，因此通过<code>list_push</code>将它插入到<strong>inode 队列的最前面</strong>，以便下次更快被找到。将它的<code>i_open_cnts</code>置为1，表示目前此inode 仅被打开1 次。然后释放缓冲区inode_buf，返回inode_found 指针，至此inode_open 函数结束。</p>
<p>接下来是函数<code>inode_close</code>，它接受1 个参数，<strong>inode 指针inode</strong>，功能是<strong>关闭inode</strong>。关闭inode 的思路是<strong>将inode 的i_open_cnts 减1</strong>，若其值为0，则说明此inode 未被打开，此时可以将其从inode 队列中去掉并回收空间了。又将页表置为NULL，使<code>sys_free</code>正确释放内核中的<code>inode</code>。<code>sys_free</code>之后，再把页表换回来。</p>
<p>最后一个函数是<code>inode_init</code>，它接受2 个参数，<strong>inode编号inode_no</strong>及<strong>待初始化的inode指针new_inode</strong>，功能是<strong>初始化new_inode</strong>。初始化inode中的<code>i_no</code>为参数<code>inode_no</code>，<code>i_size</code>和<code>i_open_cnt</code>为0，<code>write_deny</code>为false。接下来是初始化<code>i_sectors</code>数组，该数组大小是13 个元素，前12 个是直接块地址，第13 个一级间接块索引表地址，在此统统置为0。</p>
<p>文件操作相关的函数我们定义在<code>fs/file.c</code>和<code>fs/file.h</code>中，<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 文件结构 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> &#123;</span></span><br><span class="line">   <span class="keyword">uint32_t</span> fd_pos;      <span class="comment">// 记录当前文件操作的偏移地址,以0为起始,最大为文件大小-1</span></span><br><span class="line">   <span class="keyword">uint32_t</span> fd_flag;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">inode</span>* <span class="title">fd_inode</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 标准输入输出描述符 */</span></span><br><span class="line"><span class="keyword">enum</span> std_fd &#123;</span><br><span class="line">   stdin_no,   <span class="comment">// 0 标准输入</span></span><br><span class="line">   stdout_no,  <span class="comment">// 1 标准输出</span></span><br><span class="line">   stderr_no   <span class="comment">// 2 标准错误</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 位图类型 */</span></span><br><span class="line"><span class="keyword">enum</span> bitmap_type &#123;</span><br><span class="line">   INODE_BITMAP,     <span class="comment">// inode位图</span></span><br><span class="line">   BLOCK_BITMAP	     <span class="comment">// 块位图</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_FILE_OPEN 32    <span class="comment">// 系统可打开的最大文件数</span></span></span><br></pre></td></tr></table></figure></p>
<p><code>struct file</code>就是所说的文件结构，其中的<code>fd_pos</code>用于<strong>记录当前文件操作的偏移地址</strong>，该值最小是0，最大为文件大小减1。<code>fd_flag</code>是文件操作标识，如<code>O_RDONLY</code>，<code>fd_inode</code>是inode 指针，用来指向inode 队列<code>part-&gt; open_inodes</code>中的inode。<code>enum std_fd</code>是<strong>标准文件描述符</strong>，<code>enum bitmap_type</code>是位图类型，包括<code>INODE_BITMAP</code>和<code>BLOCK_BITMAP</code>，宏<code>MAX_FILE_OPEN</code>的值是32，这是系统可打开的最大文件数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 文件表 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> <span class="title">file_table</span>[<span class="title">MAX_FILE_OPEN</span>];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 从文件表file_table中获取一个空闲位,成功返回下标,失败返回-1 */</span></span><br><span class="line"><span class="keyword">int32_t</span> get_free_slot_in_global(<span class="keyword">void</span>) &#123;</span><br><span class="line">   <span class="keyword">uint32_t</span> fd_idx = <span class="number">3</span>;</span><br><span class="line">   <span class="keyword">while</span> (fd_idx &lt; MAX_FILE_OPEN) &#123;</span><br><span class="line">      <span class="keyword">if</span> (file_table[fd_idx].fd_inode == <span class="literal">NULL</span>) &#123;</span><br><span class="line">	 <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      fd_idx++;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (fd_idx == MAX_FILE_OPEN) &#123;</span><br><span class="line">      printk(<span class="string">"exceed max open files\n"</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> fd_idx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将全局描述符下标安装到进程或线程自己的文件描述符数组fd_table中,</span></span><br><span class="line"><span class="comment"> * 成功返回下标,失败返回-1 */</span></span><br><span class="line"><span class="keyword">int32_t</span> pcb_fd_install(<span class="keyword">int32_t</span> globa_fd_idx) &#123;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>* <span class="title">cur</span> = <span class="title">running_thread</span>();</span></span><br><span class="line">   <span class="keyword">uint8_t</span> local_fd_idx = <span class="number">3</span>; <span class="comment">// 跨过stdin,stdout,stderr</span></span><br><span class="line">   <span class="keyword">while</span> (local_fd_idx &lt; MAX_FILES_OPEN_PER_PROC) &#123;</span><br><span class="line">      <span class="keyword">if</span> (cur-&gt;fd_table[local_fd_idx] == <span class="number">-1</span>) &#123;	<span class="comment">// -1表示free_slot,可用</span></span><br><span class="line">	 cur-&gt;fd_table[local_fd_idx] = globa_fd_idx;</span><br><span class="line">	 <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      local_fd_idx++;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (local_fd_idx == MAX_FILES_OPEN_PER_PROC) &#123;</span><br><span class="line">      printk(<span class="string">"exceed max open files_per_proc\n"</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> local_fd_idx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 分配一个i结点,返回i结点号 */</span></span><br><span class="line"><span class="keyword">int32_t</span> inode_bitmap_alloc(struct partition* part) &#123;</span><br><span class="line">   <span class="keyword">int32_t</span> bit_idx = bitmap_scan(&amp;part-&gt;inode_bitmap, <span class="number">1</span>);</span><br><span class="line">   <span class="keyword">if</span> (bit_idx == <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   bitmap_set(&amp;part-&gt;inode_bitmap, bit_idx, <span class="number">1</span>);</span><br><span class="line">   <span class="keyword">return</span> bit_idx;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="comment">/* 分配1个扇区,返回其扇区地址 */</span></span><br><span class="line"><span class="keyword">int32_t</span> block_bitmap_alloc(struct partition* part) &#123;</span><br><span class="line">   <span class="keyword">int32_t</span> bit_idx = bitmap_scan(&amp;part-&gt;block_bitmap, <span class="number">1</span>);</span><br><span class="line">   <span class="keyword">if</span> (bit_idx == <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   bitmap_set(&amp;part-&gt;block_bitmap, bit_idx, <span class="number">1</span>);</span><br><span class="line">   <span class="comment">/* 和inode_bitmap_malloc不同,此处返回的不是位图索引,而是具体可用的扇区地址 */</span></span><br><span class="line">   <span class="keyword">return</span> (part-&gt;sb-&gt;data_start_lba + bit_idx);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将内存中bitmap第bit_idx位所在的512字节同步到硬盘 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bitmap_sync</span><span class="params">(struct partition* part, <span class="keyword">uint32_t</span> bit_idx, <span class="keyword">uint8_t</span> btmp_type)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">uint32_t</span> off_sec = bit_idx / <span class="number">4096</span>;  <span class="comment">// 本i结点索引相对于位图的扇区偏移量</span></span><br><span class="line">   <span class="keyword">uint32_t</span> off_size = off_sec * BLOCK_SIZE;  <span class="comment">// 本i结点索引相对于位图的字节偏移量</span></span><br><span class="line">   <span class="keyword">uint32_t</span> sec_lba;</span><br><span class="line">   <span class="keyword">uint8_t</span>* bitmap_off;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 需要被同步到硬盘的位图只有inode_bitmap和block_bitmap */</span></span><br><span class="line">   <span class="keyword">switch</span> (btmp_type) &#123;</span><br><span class="line">      <span class="keyword">case</span> INODE_BITMAP:</span><br><span class="line">	 sec_lba = part-&gt;sb-&gt;inode_bitmap_lba + off_sec;</span><br><span class="line">	 bitmap_off = part-&gt;inode_bitmap.bits + off_size;</span><br><span class="line">	 <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> BLOCK_BITMAP: </span><br><span class="line">	 sec_lba = part-&gt;sb-&gt;block_bitmap_lba + off_sec;</span><br><span class="line">	 bitmap_off = part-&gt;block_bitmap.bits + off_size;</span><br><span class="line">	 <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   ide_write(part-&gt;my_disk, sec_lba, bitmap_off, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码中的<code>file_table</code>是文件结构数组，长度是<code>MAX_FILE_OPEN</code>，也就是<strong>最多可同时打开<code>MAX_FILE_OPEN</code>次文件</strong>，函数<code>get_free_slot_in_global</code>功能是<strong>从文件表<code>file_table</code>中获取一个空闲位</strong>，成功则返回空闲位下标，失败则返回−1。实现原理是<strong>遍历<code>file_table</code>，找出<code>fd_inode</code>为null 的数组元素，该元素表示为空，将其下标返回即可</strong>，<code>file_table</code>中的前3 个成员预留给标准输入、标准输出及标准错误。</p>
<p>函数<code>pcb_fd_install</code>接受1 个参数，全局描述符下标<code>globa_fd_idx</code>。函数功能是<strong>将<code>globa_fd_idx</code>安装到进程或线程自己的文件描述符数组fd_table 中，成功则返回fd_table 中空位的下标，失败则返回−1</strong>。函数<code>inode_bitmap_alloc</code>，功能是<strong>分配一个i 结点，返回i 结点号</strong>。函数<code>block_bitmap_alloc</code>功能是<strong>分配1 个扇区，返回其扇区地址</strong>。函数<code>bitmap_sync</code>功能是将内存中<code>bitmap</code>第<code>bit_idx</code>位所在的512 字节同步到硬盘。</p>
<p>有关目录操作的函数我们定义在<code>fs/dir.c</code>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dir</span> <span class="title">root_dir</span>;</span>             <span class="comment">// 根目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 打开根目录 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">open_root_dir</span><span class="params">(struct partition* part)</span> </span>&#123;</span><br><span class="line">   root_dir.inode = inode_open(part, part-&gt;sb-&gt;root_inode_no);</span><br><span class="line">   root_dir.dir_pos = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在分区part上打开i结点为inode_no的目录并返回目录指针 */</span></span><br><span class="line"><span class="function">struct dir* <span class="title">dir_open</span><span class="params">(struct partition* part, <span class="keyword">uint32_t</span> inode_no)</span> </span>&#123;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">dir</span>* <span class="title">pdir</span> = (<span class="title">struct</span> <span class="title">dir</span>*)<span class="title">sys_malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">dir</span>));</span></span><br><span class="line">   pdir-&gt;inode = inode_open(part, inode_no);</span><br><span class="line">   pdir-&gt;dir_pos = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">return</span> pdir;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在part分区内的pdir目录内寻找名为name的文件或目录,</span></span><br><span class="line"><span class="comment"> * 找到后返回true并将其目录项存入dir_e,否则返回false */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">search_dir_entry</span><span class="params">(struct partition* part, struct dir* pdir, \</span></span></span><br><span class="line"><span class="function"><span class="params">		     <span class="keyword">const</span> <span class="keyword">char</span>* name, struct dir_entry* dir_e)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">uint32_t</span> block_cnt = <span class="number">140</span>;	 <span class="comment">// 12个直接块+128个一级间接块=140块</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 12个直接块大小+128个间接块,共560字节 */</span></span><br><span class="line">   <span class="keyword">uint32_t</span>* all_blocks = (<span class="keyword">uint32_t</span>*)sys_malloc(<span class="number">48</span> + <span class="number">512</span>);</span><br><span class="line">   <span class="keyword">if</span> (all_blocks == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      printk(<span class="string">"search_dir_entry: sys_malloc for all_blocks failed"</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">uint32_t</span> block_idx = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span> (block_idx &lt; <span class="number">12</span>) &#123;</span><br><span class="line">      all_blocks[block_idx] = pdir-&gt;inode-&gt;i_sectors[block_idx];</span><br><span class="line">      block_idx++;</span><br><span class="line">   &#125;</span><br><span class="line">   block_idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (pdir-&gt;inode-&gt;i_sectors[<span class="number">12</span>] != <span class="number">0</span>) &#123;	<span class="comment">// 若含有一级间接块表</span></span><br><span class="line">      ide_read(part-&gt;my_disk, pdir-&gt;inode-&gt;i_sectors[<span class="number">12</span>], all_blocks + <span class="number">12</span>, <span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">/* 至此,all_blocks存储的是该文件或目录的所有扇区地址 */</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 写目录项的时候已保证目录项不跨扇区,</span></span><br><span class="line"><span class="comment">    * 这样读目录项时容易处理, 只申请容纳1个扇区的内存 */</span></span><br><span class="line">   <span class="keyword">uint8_t</span>* buf = (<span class="keyword">uint8_t</span>*)sys_malloc(SECTOR_SIZE);</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">dir_entry</span>* <span class="title">p_de</span> = (<span class="title">struct</span> <span class="title">dir_entry</span>*)<span class="title">buf</span>;</span>	    <span class="comment">// p_de为指向目录项的指针,值为buf起始地址</span></span><br><span class="line">   <span class="keyword">uint32_t</span> dir_entry_size = part-&gt;sb-&gt;dir_entry_size;</span><br><span class="line">   <span class="keyword">uint32_t</span> dir_entry_cnt = SECTOR_SIZE / dir_entry_size;   <span class="comment">// 1扇区内可容纳的目录项个数</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 开始在所有块中查找目录项 */</span></span><br><span class="line">   <span class="keyword">while</span> (block_idx &lt; block_cnt) &#123;		  </span><br><span class="line">   <span class="comment">/* 块地址为0时表示该块中无数据,继续在其它块中找 */</span></span><br><span class="line">      <span class="keyword">if</span> (all_blocks[block_idx] == <span class="number">0</span>) &#123;</span><br><span class="line">	 block_idx++;</span><br><span class="line">	 <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      ide_read(part-&gt;my_disk, all_blocks[block_idx], buf, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">uint32_t</span> dir_entry_idx = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">/* 遍历扇区中所有目录项 */</span></span><br><span class="line">      <span class="keyword">while</span> (dir_entry_idx &lt; dir_entry_cnt) &#123;</span><br><span class="line">	 <span class="comment">/* 若找到了,就直接复制整个目录项 */</span></span><br><span class="line">	 <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(p_de-&gt;filename, name)) &#123;</span><br><span class="line">	    <span class="built_in">memcpy</span>(dir_e, p_de, dir_entry_size);</span><br><span class="line">	    sys_free(buf);</span><br><span class="line">	    sys_free(all_blocks);</span><br><span class="line">	    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	 &#125;</span><br><span class="line">	 dir_entry_idx++;</span><br><span class="line">	 p_de++;</span><br><span class="line">      &#125;</span><br><span class="line">      block_idx++;</span><br><span class="line">      p_de = (struct dir_entry*)buf;  <span class="comment">// 此时p_de已经指向扇区内最后一个完整目录项了,需要恢复p_de指向为buf</span></span><br><span class="line">      <span class="built_in">memset</span>(buf, <span class="number">0</span>, SECTOR_SIZE);	  <span class="comment">// 将buf清0,下次再用</span></span><br><span class="line">   &#125;</span><br><span class="line">   sys_free(buf);</span><br><span class="line">   sys_free(all_blocks);</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>程序开头定义了<code>root_dir</code>，它是<strong>分区的根目录</strong>。函数<code>open_root_dir</code>接受一个参数，分区part，功能是<strong>打开分区part 的根目录</strong>。函数<code>dir_open</code>，它接受两个参数，<strong>分区part</strong>和<strong>inode 编号inode_no</strong>，功能是<strong>在分区part 上打开i 结点为inode_no 的目录并返回目录指针</strong>。</p>
<p>函数<code>search_dir_entry</code>接受4个参数，<strong>分区part</strong>、<strong>目录指针pdir</strong>、<strong>文件名name</strong>、<strong>目录项指针dir_e</strong>，函数功能是<strong>在part 分区内的pdir 目录内寻找名为name 的文件或目录，找到后返回true 并将其目录项存入dir_e，否则返回false</strong>。函数开头定义了变量<code>block_cnt</code>，<strong>表示inode 总的块数</strong>，其值为140，即12 个直接块+128 个一级间接块。为这140 个扇区地址申请内存，返回地址赋值给<code>all_blocks</code>。往目录中写目录项的时候，写入的都是完整的目录项，避免了目录项跨扇区的情况，因此<strong>在实际搜索目录项的时候每次只从硬盘读取一扇区就好了</strong>，所以我们为缓冲区buf 申请的内存大小是<code>SECTOR_SIZE</code>，即1 扇区。将缓冲区转换为目录项<code>struct dir_entry</code>类型，赋值给<code>p_de</code>，若判断<code>all_blocks[block_idx]</code>不为0，这表示已分配扇区地址了，于是从该扇区地址<code>all_blocks[block_idx]</code>读入1 扇区数据到buf，用目录项指针<code>p_de</code>遍历该扇区内的所有目录项，比较目录项的<code>p_de-&gt;filename</code>是否和待查找的文件名name 相等，若相等则表示找到该文件。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 关闭目录 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dir_close</span><span class="params">(struct dir* dir)</span> </span>&#123;</span><br><span class="line"><span class="comment">/*************      根目录不能关闭     ***************</span></span><br><span class="line"><span class="comment"> *1 根目录自打开后就不应该关闭,否则还需要再次open_root_dir();</span></span><br><span class="line"><span class="comment"> *2 root_dir所在的内存是低端1M之内,并非在堆中,free会出问题 */</span></span><br><span class="line">   <span class="keyword">if</span> (dir == &amp;root_dir) &#123;</span><br><span class="line">   <span class="comment">/* 不做任何处理直接返回*/</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   inode_close(dir-&gt;inode);</span><br><span class="line">   sys_free(dir);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在内存中初始化目录项p_de */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create_dir_entry</span><span class="params">(<span class="keyword">char</span>* filename, <span class="keyword">uint32_t</span> inode_no, <span class="keyword">uint8_t</span> file_type, struct dir_entry* p_de)</span> </span>&#123;</span><br><span class="line">   ASSERT(<span class="built_in">strlen</span>(filename) &lt;=  MAX_FILE_NAME_LEN);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 初始化目录项 */</span></span><br><span class="line">   <span class="built_in">memcpy</span>(p_de-&gt;filename, filename, <span class="built_in">strlen</span>(filename));</span><br><span class="line">   p_de-&gt;i_no = inode_no;</span><br><span class="line">   p_de-&gt;f_type = file_type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数<code>dir_close</code>接受1 个参数，目录指针dir，功能是关闭目录dir。关闭目录的本质是<strong>关闭目录的inode并释放目录占用的内存</strong>，根目录不能被真正地关闭，不做任何处理直接返回。原因是首先<strong>根目录始终应该是打开的，它是所有目录的父目录</strong>，查找文件时必须要从根目录开始找。其次是<strong>根目录root_dir 占用的是静态内存，它位于低端1MB 之内，并非是在堆中申请的，不能将其释放</strong>。函数<code>create_dir_entry</code>功能是<strong>在内存中创建目录项p_de</strong>。函数的实现就是在初始化目录项p_de：将文件名拷贝到目录项<code>p_de-&gt;filename</code>中，用<code>inode_no</code>为<code>p_de-&gt;i_no</code>赋值，用file_type 为p_de-&gt;f_type 赋值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 将目录项p_de写入父目录parent_dir中,io_buf由主调函数提供 */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">sync_dir_entry</span><span class="params">(struct dir* parent_dir, struct dir_entry* p_de, <span class="keyword">void</span>* io_buf)</span> </span>&#123;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">inode</span>* <span class="title">dir_inode</span> = <span class="title">parent_dir</span>-&gt;<span class="title">inode</span>;</span></span><br><span class="line">   <span class="keyword">uint32_t</span> dir_size = dir_inode-&gt;i_size;</span><br><span class="line">   <span class="keyword">uint32_t</span> dir_entry_size = cur_part-&gt;sb-&gt;dir_entry_size;</span><br><span class="line"></span><br><span class="line">   ASSERT(dir_size % dir_entry_size == <span class="number">0</span>);	 <span class="comment">// dir_size应该是dir_entry_size的整数倍</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">uint32_t</span> dir_entrys_per_sec = (<span class="number">512</span> / dir_entry_size);       <span class="comment">// 每扇区最大的目录项数目</span></span><br><span class="line">   <span class="keyword">int32_t</span> block_lba = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 将该目录的所有扇区地址(12个直接块+ 128个间接块)存入all_blocks */</span></span><br><span class="line">   <span class="keyword">uint8_t</span> block_idx = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">uint32_t</span> all_blocks[<span class="number">140</span>] = &#123;<span class="number">0</span>&#125;;	  <span class="comment">// all_blocks保存目录所有的块</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 将12个直接块存入all_blocks */</span></span><br><span class="line">   <span class="keyword">while</span> (block_idx &lt; <span class="number">12</span>) &#123;</span><br><span class="line">      all_blocks[block_idx] = dir_inode-&gt;i_sectors[block_idx];</span><br><span class="line">      block_idx++;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">dir_entry</span>* <span class="title">dir_e</span> = (<span class="title">struct</span> <span class="title">dir_entry</span>*)<span class="title">io_buf</span>;</span>	       <span class="comment">// dir_e用来在io_buf中遍历目录项</span></span><br><span class="line">   <span class="keyword">int32_t</span> block_bitmap_idx = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 开始遍历所有块以寻找目录项空位,若已有扇区中没有空闲位,</span></span><br><span class="line"><span class="comment">    * 在不超过文件大小的情况下申请新扇区来存储新目录项 */</span></span><br><span class="line">   block_idx = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span> (block_idx &lt; <span class="number">140</span>) &#123;  <span class="comment">// 文件(包括目录)最大支持12个直接块+128个间接块＝140个块</span></span><br><span class="line">      block_bitmap_idx = <span class="number">-1</span>;</span><br><span class="line">      <span class="keyword">if</span> (all_blocks[block_idx] == <span class="number">0</span>) &#123;   <span class="comment">// 在三种情况下分配块</span></span><br><span class="line">	 block_lba = block_bitmap_alloc(cur_part);</span><br><span class="line">	 <span class="keyword">if</span> (block_lba == <span class="number">-1</span>) &#123;</span><br><span class="line">	    printk(<span class="string">"alloc block bitmap for sync_dir_entry failed\n"</span>);</span><br><span class="line">	    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	 &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 每分配一个块就同步一次block_bitmap */</span></span><br><span class="line">	 block_bitmap_idx = block_lba - cur_part-&gt;sb-&gt;data_start_lba;</span><br><span class="line">	 ASSERT(block_bitmap_idx != <span class="number">-1</span>);</span><br><span class="line">	 bitmap_sync(cur_part, block_bitmap_idx, BLOCK_BITMAP);</span><br><span class="line"></span><br><span class="line">	 block_bitmap_idx = <span class="number">-1</span>;</span><br><span class="line">	 <span class="keyword">if</span> (block_idx &lt; <span class="number">12</span>) &#123;	    <span class="comment">// 若是直接块</span></span><br><span class="line">	    dir_inode-&gt;i_sectors[block_idx] = all_blocks[block_idx] = block_lba;</span><br><span class="line">	 &#125; <span class="keyword">else</span> <span class="keyword">if</span> (block_idx == <span class="number">12</span>) &#123;	  <span class="comment">// 若是尚未分配一级间接块表(block_idx等于12表示第0个间接块地址为0)</span></span><br><span class="line">	    dir_inode-&gt;i_sectors[<span class="number">12</span>] = block_lba;       <span class="comment">// 将上面分配的块做为一级间接块表地址</span></span><br><span class="line">	    block_lba = <span class="number">-1</span>;</span><br><span class="line">	    block_lba = block_bitmap_alloc(cur_part);	       <span class="comment">// 再分配一个块做为第0个间接块</span></span><br><span class="line">	    <span class="keyword">if</span> (block_lba == <span class="number">-1</span>) &#123;</span><br><span class="line">	       block_bitmap_idx = dir_inode-&gt;i_sectors[<span class="number">12</span>] - cur_part-&gt;sb-&gt;data_start_lba;</span><br><span class="line">	       bitmap_set(&amp;cur_part-&gt;block_bitmap, block_bitmap_idx, <span class="number">0</span>);</span><br><span class="line">	       dir_inode-&gt;i_sectors[<span class="number">12</span>] = <span class="number">0</span>;</span><br><span class="line">	       printk(<span class="string">"alloc block bitmap for sync_dir_entry failed\n"</span>);</span><br><span class="line">	       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	 <span class="comment">/* 每分配一个块就同步一次block_bitmap */</span></span><br><span class="line">	    block_bitmap_idx = block_lba - cur_part-&gt;sb-&gt;data_start_lba;</span><br><span class="line">	    ASSERT(block_bitmap_idx != <span class="number">-1</span>);</span><br><span class="line">	    bitmap_sync(cur_part, block_bitmap_idx, BLOCK_BITMAP);</span><br><span class="line"></span><br><span class="line">	    all_blocks[<span class="number">12</span>] = block_lba;</span><br><span class="line">	    <span class="comment">/* 把新分配的第0个间接块地址写入一级间接块表 */</span></span><br><span class="line">	    ide_write(cur_part-&gt;my_disk, dir_inode-&gt;i_sectors[<span class="number">12</span>], all_blocks + <span class="number">12</span>, <span class="number">1</span>);</span><br><span class="line">	 &#125; <span class="keyword">else</span> &#123;	   <span class="comment">// 若是间接块未分配</span></span><br><span class="line">	    all_blocks[block_idx] = block_lba;</span><br><span class="line">	    <span class="comment">/* 把新分配的第(block_idx-12)个间接块地址写入一级间接块表 */</span></span><br><span class="line">	    ide_write(cur_part-&gt;my_disk, dir_inode-&gt;i_sectors[<span class="number">12</span>], all_blocks + <span class="number">12</span>, <span class="number">1</span>);</span><br><span class="line">	 &#125;</span><br><span class="line"></span><br><span class="line">	 <span class="comment">/* 再将新目录项p_de写入新分配的间接块 */</span></span><br><span class="line">	 <span class="built_in">memset</span>(io_buf, <span class="number">0</span>, <span class="number">512</span>);</span><br><span class="line">	 <span class="built_in">memcpy</span>(io_buf, p_de, dir_entry_size);</span><br><span class="line">	 ide_write(cur_part-&gt;my_disk, all_blocks[block_idx], io_buf, <span class="number">1</span>);</span><br><span class="line">	 dir_inode-&gt;i_size += dir_entry_size;</span><br><span class="line">	 <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 若第block_idx块已存在,将其读进内存,然后在该块中查找空目录项 */</span></span><br><span class="line">      ide_read(cur_part-&gt;my_disk, all_blocks[block_idx], io_buf, <span class="number">1</span>); </span><br><span class="line">      <span class="comment">/* 在扇区内查找空目录项 */</span></span><br><span class="line">      <span class="keyword">uint8_t</span> dir_entry_idx = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> (dir_entry_idx &lt; dir_entrys_per_sec) &#123;</span><br><span class="line">	 <span class="keyword">if</span> ((dir_e + dir_entry_idx)-&gt;f_type == FT_UNKNOWN) &#123;	<span class="comment">// FT_UNKNOWN为0,无论是初始化或是删除文件后,都会将f_type置为FT_UNKNOWN.</span></span><br><span class="line">	    <span class="built_in">memcpy</span>(dir_e + dir_entry_idx, p_de, dir_entry_size);    </span><br><span class="line">	    ide_write(cur_part-&gt;my_disk, all_blocks[block_idx], io_buf, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	    dir_inode-&gt;i_size += dir_entry_size;</span><br><span class="line">	    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	 &#125;</span><br><span class="line">	 dir_entry_idx++;</span><br><span class="line">      &#125;</span><br><span class="line">      block_idx++;</span><br><span class="line">   &#125;   </span><br><span class="line">   printk(<span class="string">"directory is full!\n"</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>sync_dir_entry</code>接受3 个参数，<strong>父目录<code>parent_dir</code></strong>、<strong>目录项<code>p_de</code></strong>、<strong>缓冲区<code>io_buf</code></strong>，功能是<strong>将目录项p_de写入父目录parent_dir 中，其中io_buf 由主调函数提供</strong>。<strong>当inode 是目录时，其<code>i_size</code>是目录中目录项的大小之和</strong>，父目录的大小是<code>dir_inode-&gt;i_size</code>，获取了超级块的大小，存入变量<code>dir_entry_size</code>。计算1 扇区可容纳的完整的目录项数，结果写入变量<code>dir_entrys_per_sec</code>，使目录项指针<code>dir_e</code>指向缓冲区<code>io_buf</code>。</p>
<p>由于删除文件时会造成目录中存在空洞，所以在写入文件时，要<strong>逐个目录项查找空位</strong>，所以<strong>从头在这12 个扇区中找空闲目录项位置</strong>。之后先判断扇区是否分配，若未分配，通过函数<code>block_bitmap_alloc</code>为其分配一扇区，扇区地址写入变量<code>block_lba</code>。由于<code>block_bitmap_alloc</code>仅是操作内存中的块位图，为保持数据同步，现在要将块位图同步到硬盘，于是计算<code>block_lba</code>相对于<code>data_start_lba</code>的偏移，<strong>调用<code>bitmap_sync</code>将块位图同步到硬盘</strong>。判断当前为空的块是直接块，还是间接块，<strong>若块索引小于12，则属于直接块</strong>，故将分配的扇区地址写入<code>i_sectors[block_idx]</code>和<code>all_blocks[block_idx]</code>。若<strong>正好是第12 个块</strong>，即一级间接块索引表地址为空，该创建间接块，将刚才分配的扇区地址<code>block_lba</code>作为一级间接块索引表的地址写入<code>i_sectors[12]</code>，重新再分配一扇区，此时<code>block_lba</code>更新为新分配的扇区地址，<strong>该扇区地址将作为第0 个间接块</strong>，将新分配的<br>扇区地址更新到<code>all_blocks[12]</code>，这是第0 个间接块的地址，随后调用<code>ide_write</code>将间接块地址写入一级间接块索引表所在的扇区。<strong>处理块已存在，不需要分配块的情况</strong>也就是要在该扇区中寻找空闲的目录项，先将该扇区读到<code>io_buf</code>中，接着通过while 循环遍历<code>dir_entrys_per_sec</code>个目录项，判断若目录项的<code>f_type</code>为<code>FT_UNKNOWN</code>，这表示<strong>该目录项未分配</strong>，将目录项<code>p_de</code>写入<code>io_buf</code>，接着调用<code>ide_write</code><strong>将目录项同步到硬盘</strong>，最后使目录的<code>i_size</code>加上1 个目录项大小<code>dir_entry_size</code>。</p>
<p>继续完善fs.c，在其中添加文件搜索的功能，函数search_file。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_PATH_LEN 512	    <span class="comment">// 路径最大长度</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 文件类型 */</span></span><br><span class="line"><span class="keyword">enum</span> file_types &#123;</span><br><span class="line">   FT_UNKNOWN,	  <span class="comment">// 不支持的文件类型</span></span><br><span class="line">   FT_REGULAR,	  <span class="comment">// 普通文件</span></span><br><span class="line">   FT_DIRECTORY	  <span class="comment">// 目录</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 打开文件的选项 */</span></span><br><span class="line"><span class="keyword">enum</span> oflags &#123;</span><br><span class="line">   O_RDONLY,	  <span class="comment">// 只读</span></span><br><span class="line">   O_WRONLY,	  <span class="comment">// 只写</span></span><br><span class="line">   O_RDWR,	  <span class="comment">// 读写</span></span><br><span class="line">   O_CREAT = <span class="number">4</span>	  <span class="comment">// 创建</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 用来记录查找文件过程中已找到的上级路径,也就是查找文件过程中"走过的地方" */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">path_search_record</span> &#123;</span></span><br><span class="line">   <span class="keyword">char</span> searched_path[MAX_PATH_LEN];	    <span class="comment">// 查找过程中的父路径</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">dir</span>* <span class="title">parent_dir</span>;</span>		    <span class="comment">// 文件或目录所在的直接父目录</span></span><br><span class="line">   <span class="keyword">enum</span> file_types file_type;		    <span class="comment">// 找到的是普通文件还是目录,找不到将为未知类型(FT_UNKNOWN)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>宏<code>MAX_PATH_LEN</code> 表示路径名最大的长度，这里其值为512。枚举结构<code>enum oflags</code>是打开文件时的选项，可选的值一般有<code>O_RDONLY</code>、<code>O_WRONLY</code>、<code>O_RDWR</code>、<code>O_CREAT</code>、<code>O_EXCL</code>等，它们是定义在文件<code>/usr/include/asm-generic/fcntl.h</code>中的宏，如图：<br><img src="/img/1597195068.jpg" alt></p>
<p>定义了<code>struct path_search_record</code>，它是<strong>路径搜索记录</strong>，此结构用来记录查找文件过程中已处理过的上级路径，也就是<strong>查找文件过程中”走过的地方”</strong>。用此结构的目的是想获取路径中“断链”的部分，其中成员<code>searched_path</code>就是查找过程中不存在的路径。成员<code>parent_dir</code>用于<strong>记录文件或目录所在的直接父目录</strong>，成员<code>file_type</code>是找到的文件类型，若找不到文件的话，该值为未知类型<code>FT_UNKNOWN</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 搜索文件pathname,若找到则返回其inode号,否则返回-1 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">search_file</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* pathname, struct path_search_record* searched_record)</span> </span>&#123;</span><br><span class="line">   <span class="comment">/* 如果待查找的是根目录,为避免下面无用的查找,直接返回已知根目录信息 */</span></span><br><span class="line">   <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(pathname, <span class="string">"/"</span>) || !<span class="built_in">strcmp</span>(pathname, <span class="string">"/."</span>) || !<span class="built_in">strcmp</span>(pathname, <span class="string">"/.."</span>)) &#123;</span><br><span class="line">      searched_record-&gt;parent_dir = &amp;root_dir;</span><br><span class="line">      searched_record-&gt;file_type = FT_DIRECTORY;</span><br><span class="line">      searched_record-&gt;searched_path[<span class="number">0</span>] = <span class="number">0</span>;	   <span class="comment">// 搜索路径置空</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">uint32_t</span> path_len = <span class="built_in">strlen</span>(pathname);</span><br><span class="line">   <span class="comment">/* 保证pathname至少是这样的路径/x且小于最大长度 */</span></span><br><span class="line">   ASSERT(pathname[<span class="number">0</span>] == <span class="string">'/'</span> &amp;&amp; path_len &gt; <span class="number">1</span> &amp;&amp; path_len &lt; MAX_PATH_LEN);</span><br><span class="line">   <span class="keyword">char</span>* sub_path = (<span class="keyword">char</span>*)pathname;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">dir</span>* <span class="title">parent_dir</span> = &amp;<span class="title">root_dir</span>;</span>	</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">dir_entry</span> <span class="title">dir_e</span>;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 记录路径解析出来的各级名称,如路径"/a/b/c",</span></span><br><span class="line"><span class="comment">    * 数组name每次的值分别是"a","b","c" */</span></span><br><span class="line">   <span class="keyword">char</span> name[MAX_FILE_NAME_LEN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">   searched_record-&gt;parent_dir = parent_dir;</span><br><span class="line">   searched_record-&gt;file_type = FT_UNKNOWN;</span><br><span class="line">   <span class="keyword">uint32_t</span> parent_inode_no = <span class="number">0</span>;  <span class="comment">// 父目录的inode号</span></span><br><span class="line">   </span><br><span class="line">   sub_path = path_parse(sub_path, name);</span><br><span class="line">   <span class="keyword">while</span> (name[<span class="number">0</span>]) &#123;	   <span class="comment">// 若第一个字符就是结束符,结束循环</span></span><br><span class="line">      <span class="comment">/* 记录查找过的路径,但不能超过searched_path的长度512字节 */</span></span><br><span class="line">      ASSERT(<span class="built_in">strlen</span>(searched_record-&gt;searched_path) &lt; <span class="number">512</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 记录已存在的父目录 */</span></span><br><span class="line">      <span class="built_in">strcat</span>(searched_record-&gt;searched_path, <span class="string">"/"</span>);</span><br><span class="line">      <span class="built_in">strcat</span>(searched_record-&gt;searched_path, name);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 在所给的目录中查找文件 */</span></span><br><span class="line">      <span class="keyword">if</span> (search_dir_entry(cur_part, parent_dir, name, &amp;dir_e)) &#123;</span><br><span class="line">	 <span class="built_in">memset</span>(name, <span class="number">0</span>, MAX_FILE_NAME_LEN);</span><br><span class="line">	 <span class="comment">/* 若sub_path不等于NULL,也就是未结束时继续拆分路径 */</span></span><br><span class="line">	 <span class="keyword">if</span> (sub_path) &#123;</span><br><span class="line">	    sub_path = path_parse(sub_path, name);</span><br><span class="line">	 &#125;</span><br><span class="line"></span><br><span class="line">	 <span class="keyword">if</span> (FT_DIRECTORY == dir_e.f_type) &#123;   <span class="comment">// 如果被打开的是目录</span></span><br><span class="line">	    parent_inode_no = parent_dir-&gt;inode-&gt;i_no;</span><br><span class="line">	    dir_close(parent_dir);</span><br><span class="line">	    parent_dir = dir_open(cur_part, dir_e.i_no); <span class="comment">// 更新父目录</span></span><br><span class="line">	    searched_record-&gt;parent_dir = parent_dir;</span><br><span class="line">	    <span class="keyword">continue</span>;</span><br><span class="line">	 &#125; <span class="keyword">else</span> <span class="keyword">if</span> (FT_REGULAR == dir_e.f_type) &#123;	 <span class="comment">// 若是普通文件</span></span><br><span class="line">	    searched_record-&gt;file_type = FT_REGULAR;</span><br><span class="line">	    <span class="keyword">return</span> dir_e.i_no;</span><br><span class="line">	 &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;		   <span class="comment">//若找不到,则返回-1</span></span><br><span class="line">	 <span class="comment">/* 找不到目录项时,要留着parent_dir不要关闭,</span></span><br><span class="line"><span class="comment">	  * 若是创建新文件的话需要在parent_dir中创建 */</span></span><br><span class="line">	 <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 执行到此,必然是遍历了完整路径并且查找的文件或目录只有同名目录存在 */</span></span><br><span class="line">   dir_close(searched_record-&gt;parent_dir);	      </span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 保存被查找目录的直接父目录 */</span></span><br><span class="line">   searched_record-&gt;parent_dir = dir_open(cur_part, parent_inode_no);	   </span><br><span class="line">   searched_record-&gt;file_type = FT_DIRECTORY;</span><br><span class="line">   <span class="keyword">return</span> dir_e.i_no;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数<code>search_file</code>接受2 个参数，<strong>被检索的文件pathname</strong>和<strong>路径搜索记录指针searched_record</strong>，功能是<strong>搜索文件pathname，若找到则返回其inode 号，否则返回−1</strong>。判断如果待查找的是根目录，为避免后续无用的查找工作，直接在<code>searched_record</code>中写入根目录信息后返回。用指针<code>sub_path</code>指向路径名<code>pathname</code>，声明目录指针<code>parent_dir</code>指向根目录，我们要从根目录开始往下查找文件，然后声明了目录项dir_e。声明了数组<code>name[MAX_FILE_NAME_LEN]</code>，它用来存储路径解析中的各层路径名。从根目录开始解析路径，因此初始化<code>parent_inode_no</code>为根目录的inode 编号0。</p>
<p>下面开始搜索文件。搜索文件的原理是<strong>路径解析</strong>，也就是把路径按照分隔符’/‘拆分，每解析出一层路径名就去目录中确认相应的目录项，与目录项中的filename 比对，找到后继续路径解析，直到路径解析完成或找不到某个中间目录就返回。执行<code>sub_path = path_parse(sub_path, name)</code>开始路径解析，path_parse 返回后，最上层的路径名会存储在name 中，返回值存入sub_path，<strong>此时的sub_path 已经剥去了最上层的路径</strong>。使用while 循环处理各层路径，其判断条件是<code>name[0]</code>，只要<code>name[0]</code>不等于字符串结束符’\0’路径解析尚未结束。每次解析过的路径都会追加到<code>searched_record-&gt;searched_path</code>中，<code>searched_path</code>用于记录已解析的路径，由于是先调用<code>path_parse</code> 解析路径，再调用<code>search_dir_entry</code>去验证路径是否存在，因此<code>searched_record-&gt;searched_path</code>中的最后一级目录未必存在，其前的所有路径都是存在的。调用<code>search_dir_entry</code>判断<strong>解析出来的上层路径name 是否在父目录parent_dir 中存在</strong>，再次执行<code>sub_path = path_parse(sub_path, name)</code>进行下一步的路径解析。</p>
<p><code>dir_e</code>中已经是目录项的信息了，通过<code>if(FT_DIRECTORY == dir_e.f_type)</code>来<strong>判断解析出的最上层路径name 是否为目录</strong>，若是目录，就将父目录的inode 编号赋值给变量<code>parent_inode_no</code>，此变量用于<strong>备份父目录的inode 编号</strong>，它会在最后一级路径为目录的情况下用到。接下来把目录name打开，重新为<code>parent_dir</code>赋值，<code>parent_dir = dir_open(cur_part, dir_e.i_no)</code>。<code>searched_record-&gt;parent_dir = parent_dir</code>更新搜索记录中的父目录。</p>
<p>程序若能执行到dir_close，这说明两件事。</p>
<ol>
<li>路径pathname 已经被完整地解析过了，各级都存在。</li>
<li>pathname 的最后一层路径不是普通文件，而是目录。</li>
</ol>
<p>结论是待查找的目标是目录，如“/a/b/c”，c 是目录，不是普通文件。此时<code>searched_record-&gt; parent_dir</code>是路径pathname 中的最后一级目录c，并不是倒数第二级的父目录b，我们在任何时候都应该使<code>searched_record-&gt;parent_dir</code>是被查找目标的直接父目录。因此我们需要把<code>searched_record-&gt;parent_dir</code><strong>重新更新为父目录b</strong>。在重新打开父目录之前，为避免内存溢出，先调用dir_close 关闭目录<code>searched_record-&gt;parent_dir</code>。接下来是重新打开父目录，打开父目录并为<code>searched_record-&gt;parent_dir</code>赋值。然后在下一行更新成员<code>file_type</code>为<code>FT_DIRECTORY</code>，最后返回目录的inode 编号。</p>
<h2 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h2><p>创建文件需要考虑：</p>
<ol>
<li>创建文件的inode。这就涉及到向<code>inode_bitmap</code>申请位图来获得inode号，因此<code>inode_bitmap</code>会被更新，<code>inode_table</code>数组中的某项也会由新的inode 填充。</li>
<li><code>inode-&gt;i_sectors</code>是文件具体存储的扇区地址，这需要向<code>block_bitmap</code>申请可用位来获得可用的块，因此<code>block_bitmap</code>会被更新，分区的数据区<code>data_start_lba</code>以后的某个扇区会被分配。</li>
<li>新增加的文件必然存在于某个目录，所以该目录的<code>inode-&gt;i_size</code>会增加个目录项的大小。此新增加的文件对应的目录项需要写入该目录的<code>inode-&gt;i_sectors[]</code>中的某个扇区，原有扇区可能已满，所以有可能要申请新扇区来存储目录项。</li>
<li>若其中某步操作失败，需要回滚之前已成功的操作。</li>
<li><code>inode_bitmap</code>、<code>block_bitmap</code>、新文件的 inode 及文件所在目录的 inode，这些位于内存中已经被改变的数据要同步到硬盘。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 创建文件,若成功则返回文件描述符,否则返回-1 */</span></span><br><span class="line"><span class="keyword">int32_t</span> file_create(struct dir* parent_dir, <span class="keyword">char</span>* filename, <span class="keyword">uint8_t</span> flag) &#123;</span><br><span class="line">   <span class="comment">/* 后续操作的公共缓冲区 */</span></span><br><span class="line">   <span class="keyword">void</span>* io_buf = sys_malloc(<span class="number">1024</span>);</span><br><span class="line">   <span class="keyword">if</span> (io_buf == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      printk(<span class="string">"in file_creat: sys_malloc for io_buf failed\n"</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">uint8_t</span> rollback_step = <span class="number">0</span>;	       <span class="comment">// 用于操作失败时回滚各资源状态</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 为新文件分配inode */</span></span><br><span class="line">   <span class="keyword">int32_t</span> inode_no = inode_bitmap_alloc(cur_part); </span><br><span class="line">   <span class="keyword">if</span> (inode_no == <span class="number">-1</span>) &#123;</span><br><span class="line">      printk(<span class="string">"in file_creat: allocate inode failed\n"</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 此inode要从堆中申请内存,不可生成局部变量(函数退出时会释放)</span></span><br><span class="line"><span class="comment"> * 因为file_table数组中的文件描述符的inode指针要指向它.*/</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">inode</span>* <span class="title">new_file_inode</span> = (<span class="title">struct</span> <span class="title">inode</span>*)<span class="title">sys_malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">inode</span>));</span> </span><br><span class="line">   <span class="keyword">if</span> (new_file_inode == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      printk(<span class="string">"file_create: sys_malloc for inode failded\n"</span>);</span><br><span class="line">      rollback_step = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">goto</span> rollback;</span><br><span class="line">   &#125;</span><br><span class="line">   inode_init(inode_no, new_file_inode);	    <span class="comment">// 初始化i结点</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 返回的是file_table数组的下标 */</span></span><br><span class="line">   <span class="keyword">int</span> fd_idx = get_free_slot_in_global();</span><br><span class="line">   <span class="keyword">if</span> (fd_idx == <span class="number">-1</span>) &#123;</span><br><span class="line">      printk(<span class="string">"exceed max open files\n"</span>);</span><br><span class="line">      rollback_step = <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">goto</span> rollback;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   file_table[fd_idx].fd_inode = new_file_inode;</span><br><span class="line">   file_table[fd_idx].fd_pos = <span class="number">0</span>;</span><br><span class="line">   file_table[fd_idx].fd_flag = flag;</span><br><span class="line">   file_table[fd_idx].fd_inode-&gt;write_deny = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">dir_entry</span> <span class="title">new_dir_entry</span>;</span></span><br><span class="line">   <span class="built_in">memset</span>(&amp;new_dir_entry, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct dir_entry));</span><br><span class="line"></span><br><span class="line">   create_dir_entry(filename, inode_no, FT_REGULAR, &amp;new_dir_entry);	<span class="comment">// create_dir_entry只是内存操作不出意外,不会返回失败</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 同步内存数据到硬盘 */</span></span><br><span class="line">   <span class="comment">/* a 在目录parent_dir下安装目录项new_dir_entry, 写入硬盘后返回true,否则false */</span></span><br><span class="line">   <span class="keyword">if</span> (!sync_dir_entry(parent_dir, &amp;new_dir_entry, io_buf)) &#123;</span><br><span class="line">      printk(<span class="string">"sync dir_entry to disk failed\n"</span>);</span><br><span class="line">      rollback_step = <span class="number">3</span>;</span><br><span class="line">      <span class="keyword">goto</span> rollback;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">memset</span>(io_buf, <span class="number">0</span>, <span class="number">1024</span>);</span><br><span class="line">   <span class="comment">/* b 将父目录i结点的内容同步到硬盘 */</span></span><br><span class="line">   inode_sync(cur_part, parent_dir-&gt;inode, io_buf);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">memset</span>(io_buf, <span class="number">0</span>, <span class="number">1024</span>);</span><br><span class="line">   <span class="comment">/* c 将新创建文件的i结点内容同步到硬盘 */</span></span><br><span class="line">   inode_sync(cur_part, new_file_inode, io_buf);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* d 将inode_bitmap位图同步到硬盘 */</span></span><br><span class="line">   bitmap_sync(cur_part, inode_no, INODE_BITMAP);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* e 将创建的文件i结点添加到open_inodes链表 */</span></span><br><span class="line">   list_push(&amp;cur_part-&gt;open_inodes, &amp;new_file_inode-&gt;inode_tag);</span><br><span class="line">   new_file_inode-&gt;i_open_cnts = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">   sys_free(io_buf);</span><br><span class="line">   <span class="keyword">return</span> pcb_fd_install(fd_idx);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*创建文件需要创建相关的多个资源,若某步失败则会执行到下面的回滚步骤 */</span></span><br><span class="line">rollback:</span><br><span class="line">   <span class="keyword">switch</span> (rollback_step) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">	 <span class="comment">/* 失败时,将file_table中的相应位清空 */</span></span><br><span class="line">	 <span class="built_in">memset</span>(&amp;file_table[fd_idx], <span class="number">0</span>, <span class="keyword">sizeof</span>(struct file)); </span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">	 sys_free(new_file_inode);</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">	 <span class="comment">/* 如果新文件的i结点创建失败,之前位图中分配的inode_no也要恢复 */</span></span><br><span class="line">	 bitmap_set(&amp;cur_part-&gt;inode_bitmap, inode_no, <span class="number">0</span>);</span><br><span class="line">	 <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   sys_free(io_buf);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数<code>file_create</code>接受3 个参数，父目录partent_dir、文件名filename、创建标识flag，功能是<strong>在目录<code>parent_dir</code>中以模式flag 去创建普通文件filename，若成功则返回文件描述符，即pcb-&gt;fd_table 中的下标，否则返回−1</strong>。一般情况下硬盘操作都是一次读写一个扇区，考虑到有数据会跨扇区的情况，故<strong>申请2 个扇区大小的缓冲区</strong>，因此在函数开头就先申请了1024 字节的缓冲区io_buf。</p>
<p>创建文件包括多个修改资源的步骤，我们创建新文件的顺序是：<strong>创建文件i结点</strong>-&gt;<strong>文件描述符fd</strong>-&gt;<strong>目录项</strong>。这种“从后往前”创建步骤的好处是<strong>每一步创建失败时回滚操作少</strong>。用于回滚的代码在标签<strong>rollback</strong>处，从上到下依次是case 3、case2、case1，各case 之间没有break，它们是一种累加的回滚。调用<code>inode_bitmap_alloc</code>为新文件分配inode，为新文件的inode—<code>new_file_inode</code>申请内存，如果内存分配成功的话，执行<code>inode_init</code>初始化<code>new_file_inode</code>。调用<code>get_free_slot_in_global</code>从<code>file_talbe</code>中<strong>获取空闲文件结构的下标</strong>，写入变量<code>fd_idx</code>中。如果<code>file_table</code>中没有空闲位则返回−1。初始化文件表中的文件结构，为文件创建新目录项<code>new_dir_entry</code>，并将其清0，调用<code>create_dir_entry</code>用filename、inode_no 和<code>FT_REGULAR</code>填充<code>new_dir_entry</code>。函数<code>sync_dir_entry(parent_dir, &amp;new_dir_entry, io_buf)</code>将其写入到父目录<br>parent_dir 中。<code>sync_dir_entry</code>会改变父目录inode 中的信息，因此调用函数<code>inode_sync</code>将父目录inode 同步到硬盘。</p>
<p>分别将新文件的inode 同步到硬盘，将<code>inode_bitmap</code>位图同步到硬盘，新文件的inode 添加到inode 列表，也就是<code>cur_part-&gt;open_inodes</code>，随后在其i_open_cnts 置为1。将<code>io_buf</code>释放，然后调用<code>pcb_fd_install(fd_idx)</code>，在数组<code>pcb-&gt;fd_table</code>中找个空闲位安装<code>fd_idx</code>，若成功则返回空闲位的下标，若失败则返回−1，用return 将其返回值返回。</p>
<h1 id="系统交互"><a href="#系统交互" class="headerlink" title="系统交互"></a>系统交互</h1><h2 id="fork-的原理与实现"><a href="#fork-的原理与实现" class="headerlink" title="fork 的原理与实现"></a>fork 的原理与实现</h2><p>fork 函数原型是<code>pid_t fork(void)</code>，返回值是数字，该数字有可能是子进程的pid，有可能是0，也有可能是−1，fork 的任务就是克隆一个一模一样的进程出来，该进程拥有独立完整的程序体，是个独立的执行流。此fork 就是把某个进程的全部资源复制了一份，，然后让处理器的cs:eip寄存器指向新进程的指令部分。</p>
<p>在真正编写fork 代码之前，首先在<code>thread.h</code>的<code>task_struct</code>中增加了成员<code>int16_t parent_pid</code>，它位于<code>cwd_inode_nr</code>之后，表示<strong>父进程的pid</strong>。然后在<code>thread.c</code>中的<code>init_thread</code>函数中增加一句<code>pthread-&gt;parent_pid = −1;</code>。另外在<code>thread.c</code>中还为<code>fork</code>专门增加了个分配pid 的函数，其声明为<code>pid_t fork_pid(void)</code>，其实现是<code>return allocate_pid();</code>。</p>
<p>在<code>fork.c</code>中实现了<code>fork</code>的内核部分，<code>sys_fork</code>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">intr_exit</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将父进程的pcb、虚拟地址位图拷贝给子进程 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> int32_t <span class="title">copy_pcb_vaddrbitmap_stack0</span><span class="params">(struct task_struct* child_thread, struct task_struct* parent_thread)</span> </span>&#123;</span><br><span class="line"><span class="comment">/* a 复制pcb所在的整个页,里面包含进程pcb信息及特级0极的栈,里面包含了返回地址, 然后再单独修改个别部分 */</span></span><br><span class="line">   <span class="built_in">memcpy</span>(child_thread, parent_thread, PG_SIZE);</span><br><span class="line">   child_thread-&gt;pid = fork_pid();</span><br><span class="line">   child_thread-&gt;elapsed_ticks = <span class="number">0</span>;</span><br><span class="line">   child_thread-&gt;status = TASK_READY;</span><br><span class="line">   child_thread-&gt;ticks = child_thread-&gt;priority;   <span class="comment">// 为新进程把时间片充满</span></span><br><span class="line">   child_thread-&gt;parent_pid = parent_thread-&gt;pid;</span><br><span class="line">   child_thread-&gt;general_tag.prev = child_thread-&gt;general_tag.next = <span class="literal">NULL</span>;</span><br><span class="line">   child_thread-&gt;all_list_tag.prev = child_thread-&gt;all_list_tag.next = <span class="literal">NULL</span>;</span><br><span class="line">   block_desc_init(child_thread-&gt;u_block_desc);</span><br><span class="line"><span class="comment">/* b 复制父进程的虚拟地址池的位图 */</span></span><br><span class="line">   <span class="keyword">uint32_t</span> bitmap_pg_cnt = DIV_ROUND_UP((<span class="number">0xc0000000</span> - USER_VADDR_START) / PG_SIZE / <span class="number">8</span> , PG_SIZE);</span><br><span class="line">   <span class="keyword">void</span>* vaddr_btmp = get_kernel_pages(bitmap_pg_cnt);</span><br><span class="line">   <span class="keyword">if</span> (vaddr_btmp == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   <span class="comment">/* 此时child_thread-&gt;userprog_vaddr.vaddr_bitmap.bits还是指向父进程虚拟地址的位图地址</span></span><br><span class="line"><span class="comment">    * 下面将child_thread-&gt;userprog_vaddr.vaddr_bitmap.bits指向自己的位图vaddr_btmp */</span></span><br><span class="line">   <span class="built_in">memcpy</span>(vaddr_btmp, child_thread-&gt;userprog_vaddr.vaddr_bitmap.bits, bitmap_pg_cnt * PG_SIZE);</span><br><span class="line">   child_thread-&gt;userprog_vaddr.vaddr_bitmap.bits = vaddr_btmp;</span><br><span class="line">   <span class="comment">/* 调试用 */</span></span><br><span class="line">   ASSERT(<span class="built_in">strlen</span>(child_thread-&gt;name) &lt; <span class="number">11</span>);	<span class="comment">// pcb.name的长度是16,为避免下面strcat越界</span></span><br><span class="line">   <span class="built_in">strcat</span>(child_thread-&gt;name,<span class="string">"_fork"</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 复制子进程的进程体(代码和数据)及用户栈 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copy_body_stack3</span><span class="params">(struct task_struct* child_thread, struct task_struct* parent_thread, <span class="keyword">void</span>* buf_page)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">uint8_t</span>* vaddr_btmp = parent_thread-&gt;userprog_vaddr.vaddr_bitmap.bits;</span><br><span class="line">   <span class="keyword">uint32_t</span> btmp_bytes_len = parent_thread-&gt;userprog_vaddr.vaddr_bitmap.btmp_bytes_len;</span><br><span class="line">   <span class="keyword">uint32_t</span> vaddr_start = parent_thread-&gt;userprog_vaddr.vaddr_start;</span><br><span class="line">   <span class="keyword">uint32_t</span> idx_byte = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">uint32_t</span> idx_bit = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">uint32_t</span> prog_vaddr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 在父进程的用户空间中查找已有数据的页 */</span></span><br><span class="line">   <span class="keyword">while</span> (idx_byte &lt; btmp_bytes_len) &#123;</span><br><span class="line">      <span class="keyword">if</span> (vaddr_btmp[idx_byte]) &#123;</span><br><span class="line">	 idx_bit = <span class="number">0</span>;</span><br><span class="line">	 <span class="keyword">while</span> (idx_bit &lt; <span class="number">8</span>) &#123;</span><br><span class="line">	    <span class="keyword">if</span> ((BITMAP_MASK &lt;&lt; idx_bit) &amp; vaddr_btmp[idx_byte]) &#123;</span><br><span class="line">	       prog_vaddr = (idx_byte * <span class="number">8</span> + idx_bit) * PG_SIZE + vaddr_start;</span><br><span class="line">	 <span class="comment">/* 下面的操作是将父进程用户空间中的数据通过内核空间做中转,最终复制到子进程的用户空间 */</span></span><br><span class="line"></span><br><span class="line">	       <span class="comment">/* a 将父进程在用户空间中的数据复制到内核缓冲区buf_page,</span></span><br><span class="line"><span class="comment">	       目的是下面切换到子进程的页表后,还能访问到父进程的数据*/</span></span><br><span class="line">	       <span class="built_in">memcpy</span>(buf_page, (<span class="keyword">void</span>*)prog_vaddr, PG_SIZE);</span><br><span class="line"></span><br><span class="line">	       <span class="comment">/* b 将页表切换到子进程,目的是避免下面申请内存的函数将pte及pde安装在父进程的页表中 */</span></span><br><span class="line">	       page_dir_activate(child_thread);</span><br><span class="line">	       <span class="comment">/* c 申请虚拟地址prog_vaddr */</span></span><br><span class="line">	       get_a_page_without_opvaddrbitmap(PF_USER, prog_vaddr);</span><br><span class="line"></span><br><span class="line">	       <span class="comment">/* d 从内核缓冲区中将父进程数据复制到子进程的用户空间 */</span></span><br><span class="line">	       <span class="built_in">memcpy</span>((<span class="keyword">void</span>*)prog_vaddr, buf_page, PG_SIZE);</span><br><span class="line"></span><br><span class="line">	       <span class="comment">/* e 恢复父进程页表 */</span></span><br><span class="line">	       page_dir_activate(parent_thread);</span><br><span class="line">	    &#125;</span><br><span class="line">	    idx_bit++;</span><br><span class="line">	 &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      idx_byte++;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>函数<code>copy_pcb_vaddrbitmap_stack0</code>接受2 个参数，<strong>子进程child_thread</strong>、<strong>父进程parent_thread</strong>，功能是<strong>将父进程的pcb、虚拟地址位图拷贝给子进程</strong>。通过<code>memcpy</code>把父进程的pcb 及其内核栈一同复制给子进程。通过<code>fork_pid</code>函数<strong>为子进程分配新的pid</strong>。置子进程的<code>status</code>为<code>TASK_READY</code>，目的是<strong>让调试器schedule 安排其上CPU</strong>。还有<strong>将子进程时间片ticks 置为<code>child_thread-&gt;priority</code></strong>，为其加满时间片，以及将<code>parent_pid</code>置为<code>parent_thread-&gt;pid</code>等。用<code>child_thread-&gt;userprog_vaddr.vaddr_bitmap.bits</code>来<strong>管理进程的虚拟地址空间</strong>，子进程不能和父进程共用同一个虚拟地址位图，通过<code>block_desc_init(child_thread-&gt;u_block_desc)</code>初始化进程自己的内存块描述符，计算虚拟地址位图需要的页框数<code>bitmap_pg_cnt</code>，申请<code>bitmap_pg_cnt</code>一个内核页框来存储位图。</p>
<p>函数<code>copy_body_stack3</code>功能是<strong>复制子进程的进程体及用户栈</strong>。用户使用的内存是用虚拟内存池来管理的，也就是<strong>pcb中的 userprog_vaddr</strong>。这包括<strong>用户进程体占用的内存</strong>、<strong>堆中申请的内存</strong>和<strong>用户栈内存</strong>。堆从低地址往高地址发展，栈从<code>USER_STACK3_VADDR</code>，即<code>0xc0000000</code> - <code>0x1000</code>处往低地址发展。它们的分布不连续，因此我们要遍历虚拟地址位图中的每一位，这样才能找出进程正在使用的内存。</p>
<p>要想把数据从一个进程拷贝到另一个进程，必须要<strong>借助内核空间作为数据中转</strong>，即<strong>先将父进程用户空间中的数据复制到内核的<code>buf_page</code>中</strong>，然后再将<strong>buf_page 复制到子进程的用户空间中</strong>。<strong>在父进程虚拟地址空间中每找到一页占用的内存，就在子进程的虚拟地址空间中分配一页内存，然后将buf_page 中父进程的数据复制到为子进程新分配的虚拟地址空间页</strong>。在将<code>buf_page</code>的数据拷贝到子进程之前，一定要将页表替换为子进程的页表。</p>
<p>在父进程虚拟地址位图字节长度<code>btmp_bytes_len</code>的范围内逐字节查看位图，如果该字节不为0，也就是某位为1，即某个位有效，已分配，下面开始逐位查看该字节。通过if 判断，如果某位的值为1，就在第53 行<strong>将该位转换为虚拟地址<code>prog_vaddr</code></strong>，接下来通过<code>memcpy</code>将<code>prog_vaddr</code>处的1 页复制到buf_page。下面在为子进程分配内存之前，先调用<code>page_dir_activate(child_thread)</code>激活子进程的页表，然后再调用<code>get_a_page_without_opvaddrbitmap(PF_USER, prog_vaddr)</code>为子进程分配1 页，接着再调用<code>memcpy((void*)prog_vaddr,buf_page, PG_SIZE);</code>完成内核空间到子进程空间的复制，最后再调用<code>page_dir_activate(parent_thread)</code>将父进程的页表恢复。然后进入下一循环，继续寻找父进程占用的虚拟空间。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 为子进程构建thread_stack和修改返回值 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> int32_t <span class="title">build_child_stack</span><span class="params">(struct task_struct* child_thread)</span> </span>&#123;</span><br><span class="line"><span class="comment">/* a 使子进程pid返回值为0 */</span></span><br><span class="line">   <span class="comment">/* 获取子进程0级栈栈顶 */</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">intr_stack</span>* <span class="title">intr_0_stack</span> = (<span class="title">struct</span> <span class="title">intr_stack</span>*)((<span class="title">uint32_t</span>)<span class="title">child_thread</span> + <span class="title">PG_SIZE</span> - <span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">intr_stack</span>));</span></span><br><span class="line">   <span class="comment">/* 修改子进程的返回值为0 */</span></span><br><span class="line">   intr_0_stack-&gt;eax = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* b 为switch_to 构建 struct thread_stack,将其构建在紧临intr_stack之下的空间*/</span></span><br><span class="line">   <span class="keyword">uint32_t</span>* ret_addr_in_thread_stack  = (<span class="keyword">uint32_t</span>*)intr_0_stack - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/***   这三行不是必要的,只是为了梳理thread_stack中的关系 ***/</span></span><br><span class="line">   <span class="keyword">uint32_t</span>* esi_ptr_in_thread_stack = (<span class="keyword">uint32_t</span>*)intr_0_stack - <span class="number">2</span>; </span><br><span class="line">   <span class="keyword">uint32_t</span>* edi_ptr_in_thread_stack = (<span class="keyword">uint32_t</span>*)intr_0_stack - <span class="number">3</span>; </span><br><span class="line">   <span class="keyword">uint32_t</span>* ebx_ptr_in_thread_stack = (<span class="keyword">uint32_t</span>*)intr_0_stack - <span class="number">4</span>; </span><br><span class="line">   <span class="comment">/**********************************************************/</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* ebp在thread_stack中的地址便是当时的esp(0级栈的栈顶),</span></span><br><span class="line"><span class="comment">   即esp为"(uint32_t*)intr_0_stack - 5" */</span></span><br><span class="line">   <span class="keyword">uint32_t</span>* ebp_ptr_in_thread_stack = (<span class="keyword">uint32_t</span>*)intr_0_stack - <span class="number">5</span>; </span><br><span class="line"></span><br><span class="line">   <span class="comment">/* switch_to的返回地址更新为intr_exit,直接从中断返回 */</span></span><br><span class="line">   *ret_addr_in_thread_stack = (<span class="keyword">uint32_t</span>)intr_exit;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 下面这两行赋值只是为了使构建的thread_stack更加清晰,其实也不需要,</span></span><br><span class="line"><span class="comment">    * 因为在进入intr_exit后一系列的pop会把寄存器中的数据覆盖 */</span></span><br><span class="line">   *ebp_ptr_in_thread_stack = *ebx_ptr_in_thread_stack =\</span><br><span class="line">   *edi_ptr_in_thread_stack = *esi_ptr_in_thread_stack = <span class="number">0</span>;</span><br><span class="line">   <span class="comment">/*********************************************************/</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 把构建的thread_stack的栈顶做为switch_to恢复数据时的栈顶 */</span></span><br><span class="line">   child_thread-&gt;self_kstack = ebp_ptr_in_thread_stack;	    </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 更新inode打开数 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">update_inode_open_cnts</span><span class="params">(struct task_struct* thread)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int32_t</span> local_fd = <span class="number">3</span>, global_fd = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span> (local_fd &lt; MAX_FILES_OPEN_PER_PROC) &#123;</span><br><span class="line">      global_fd = thread-&gt;fd_table[local_fd];</span><br><span class="line">      ASSERT(global_fd &lt; MAX_FILE_OPEN);</span><br><span class="line">      <span class="keyword">if</span> (global_fd != <span class="number">-1</span>) &#123;</span><br><span class="line">	 file_table[global_fd].fd_inode-&gt;i_open_cnts++;</span><br><span class="line">      &#125;</span><br><span class="line">      local_fd++;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 拷贝父进程本身所占资源给子进程 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> int32_t <span class="title">copy_process</span><span class="params">(struct task_struct* child_thread, struct task_struct* parent_thread)</span> </span>&#123;</span><br><span class="line">   <span class="comment">/* 内核缓冲区,作为父进程用户空间的数据复制到子进程用户空间的中转 */</span></span><br><span class="line">   <span class="keyword">void</span>* buf_page = get_kernel_pages(<span class="number">1</span>);</span><br><span class="line">   <span class="keyword">if</span> (buf_page == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* a 复制父进程的pcb、虚拟地址位图、内核栈到子进程 */</span></span><br><span class="line">   <span class="keyword">if</span> (copy_pcb_vaddrbitmap_stack0(child_thread, parent_thread) == <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* b 为子进程创建页表,此页表仅包括内核空间 */</span></span><br><span class="line">   child_thread-&gt;pgdir = create_page_dir();</span><br><span class="line">   <span class="keyword">if</span>(child_thread-&gt;pgdir == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* c 复制父进程进程体及用户栈给子进程 */</span></span><br><span class="line">   copy_body_stack3(child_thread, parent_thread, buf_page);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* d 构建子进程thread_stack和修改返回值pid */</span></span><br><span class="line">   build_child_stack(child_thread);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* e 更新文件inode的打开数 */</span></span><br><span class="line">   update_inode_open_cnts(child_thread);</span><br><span class="line"></span><br><span class="line">   mfree_page(PF_KERNEL, buf_page, <span class="number">1</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* fork子进程,内核线程不可直接调用 */</span></span><br><span class="line"><span class="keyword">pid_t</span> sys_fork(<span class="keyword">void</span>) &#123;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>* <span class="title">parent_thread</span> = <span class="title">running_thread</span>();</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>* <span class="title">child_thread</span> = <span class="title">get_kernel_pages</span>(1);</span>    <span class="comment">// 为子进程创建pcb(task_struct结构)</span></span><br><span class="line">   <span class="keyword">if</span> (child_thread == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   ASSERT(INTR_OFF == intr_get_status() &amp;&amp; parent_thread-&gt;pgdir != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (copy_process(child_thread, parent_thread) == <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 添加到就绪线程队列和所有线程队列,子进程由调试器安排运行 */</span></span><br><span class="line">   ASSERT(!elem_find(&amp;thread_ready_list, &amp;child_thread-&gt;general_tag));</span><br><span class="line">   list_append(&amp;thread_ready_list, &amp;child_thread-&gt;general_tag);</span><br><span class="line">   ASSERT(!elem_find(&amp;thread_all_list, &amp;child_thread-&gt;all_list_tag));</span><br><span class="line">   list_append(&amp;thread_all_list, &amp;child_thread-&gt;all_list_tag);</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span> child_thread-&gt;pid;    <span class="comment">// 父进程返回子进程的pid</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数<code>build_child_stack</code>接受1 个参数，<strong>子进程<code>child_thread</code></strong>。功能是<strong>为子进程构建<code>thread_stack</code>和修改返回值</strong>。为了让子进程也能继续fork 之后的代码运行，必须也从中断退出，也就是要经过<code>intr_exit</code>。子进程是由调试器schedule 调度执行的，它要用到switch_to 函数，而<code>switch_to</code>函数要从栈<code>thread_stack</code>中恢复上下文，因此我们要想办法构建出合适的thread_stack。根据abi 约定，<strong>eax 寄存器中是函数返回值</strong>，因此<code>intr_stack</code>栈中的eax 置为0。下面构建一个<code>thread_stack</code>，把它的栈底放在<code>intr_stack</code>栈顶的下面，即<code>(uint32_t*)intr_0_stack - 1</code>，此地址是<strong>thread_stack栈中eip的位置</strong>，分别为<code>thread_stack</code>中的<code>esi</code>、<code>edi</code>、<code>ebx</code>、<code>ebp</code>安排位置，指针<code>ebp_ptr_in_thread_stack</code>是<code>thread_stack</code>的栈顶，我们必须把它的值存放在pcb 中偏移为0 的地方，即<code>task_struct</code>中的<code>self_kstack</code>处。将地址<code>ret_addr_in_thread_stack</code>处的值赋值为<code>intr_exit</code>的地址，也就是<code>thread_stack</code>中的<code>eip</code>是<code>intr_exit</code>，这就保证了子进程被调度时，可以直接从中断返回，也就是实现了从fork 之后的代码处继续执行的目的。最后把<code>ebp_ptr_in_thread_stack</code>的值，也就是<code>thread_stack</code>的栈顶记录在pcb 的<code>self_ kstack</code>处，这样<code>switch_to</code>便获得了<code>thread_stack</code>栈顶，从而使程序迈向<code>intr_exit</code>。</p>
<p>函数<code>update_inode_open_cnts</code>接受1个参数，<strong>线程thread</strong>，功能是<strong>fork 之后，更新线程thread的inode 打开数</strong>。遍历<code>fd_table</code>中所有文件描述符，从中获得全局文件表<code>file_table</code>的下标<code>global_fd</code>找到对应的文件结构，使相应文件结构中<code>fd_inode</code>的<code>i_open_cnts</code>加1。</p>
<p>copy_process函数接受2个参数，<strong>子进程child_thread</strong>和<strong>父进程parent_thread</strong>，功能是<strong>拷贝父进程本身所占资源给子进程</strong>。函数开头<strong>申请了1 页的内核空间作为内核缓冲区</strong>，即buf_page。调用函数<code>copy_pcb_vaddrbitmap_stack0</code>把<strong>父进程子的pcb、虚拟地址位图及内核栈复制给子进程</strong>，接着调用<code>create_page_dir</code>函数为子进程创建页表。然后调用函数<code>copy_body_stack3</code><strong>复制父进程进程体及用户栈给子进程</strong>，接着调用函数<code>build_child_stack</code><strong>为子进程构建thread_stack</strong>，随后调用<code>update_inode_open_cnts</code><strong>更新inode 的打开数</strong>，最后释放buf_page。</p>
<p>下面是函数<code>sys_fork</code>。功能是<strong>克隆当前进程</strong>。函数先调用<code>get_kernel_pages(1)</code>获得1 页内核空间作为子进程的pcb。接下来调用<code>copy_process</code>复制父进程的信息到子进程，将其加入到就绪队列和全部队列，最后返回子进程的pid。</p>
<h3 id="添加fork-系统调用与实现init-进程"><a href="#添加fork-系统调用与实现init-进程" class="headerlink" title="添加fork 系统调用与实现init 进程"></a>添加fork 系统调用与实现init 进程</h3><p>在Linux 中，init 是用户级进程，它是<strong>第一个启动的程序</strong>，因此它的pid是1，后续的所有进程都是它的孩子，故<strong>init 是所有进程的父进程</strong>，所以它还负责所有子进程的资源回收，要先完成fork 系统调用。系统调用的3 个步骤：</p>
<ol>
<li>在<code>syscall.h</code>中的<code>enum SYSCALL_NR</code> 结构中添加<code>SYS_FORK</code>。</li>
<li>在<code>syscall.c</code>中添加<code>fork()</code>，原型是<code>pid_t fork(void)</code>，实现是<code>return _syscall0(SYS_FORK);</code>。</li>
<li>在<code>syscall-init.c</code>中的函数<code>syscall_init</code>中，添加代码<code>syscall_table[SYS_FORK] = sys_fork;</code>。</li>
</ol>
<p><code>init</code>定义在<code>main.c</code>中<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* init 进程 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">uint32_t</span> ret_pid = fork();</span><br><span class="line">   <span class="keyword">if</span>(ret_pid) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"i am father, my pid is %d, child pid is %d\n"</span>, getpid(), ret_pid);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"i am child, my pid is %d, ret pid is %d\n"</span>, getpid(), ret_pid);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>init</code>是用户级进程，因此咱们要调用<code>process_execute</code>创建进程，在创建主线程的函数<code>make_main_thread</code>之前创建init，也就是在函数<code>thread_init</code>中完成。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 初始化线程环境 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">   put_str(<span class="string">"thread_init start\n"</span>);</span><br><span class="line"></span><br><span class="line">   list_init(&amp;thread_ready_list);</span><br><span class="line">   list_init(&amp;thread_all_list);</span><br><span class="line">   lock_init(&amp;pid_lock);</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* 先创建第一个用户进程:init */</span></span><br><span class="line">   process_execute(init, <span class="string">"init"</span>);         <span class="comment">// 放在第一个初始化,这是第一个进程,init进程的pid为1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将当前main函数创建为线程 */</span></span><br><span class="line">   make_main_thread();</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 创建idle线程 */</span></span><br><span class="line">   idle_thread = thread_start(<span class="string">"idle"</span>, <span class="number">10</span>, idle, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">   put_str(<span class="string">"thread_init done\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="添加-read-系统调用，获取键盘输入"><a href="#添加-read-系统调用，获取键盘输入" class="headerlink" title="添加 read 系统调用，获取键盘输入"></a>添加 read 系统调用，获取键盘输入</h2><p>Linux 中从键盘获取输入是利用read 系统调用，要改进sys_read，让其支持键盘。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 从文件描述符fd指向的文件中读取count个字节到buf,若成功则返回读出的字节数,到文件尾则返回-1 */</span></span><br><span class="line"><span class="keyword">int32_t</span> sys_read(<span class="keyword">int32_t</span> fd, <span class="keyword">void</span>* buf, <span class="keyword">uint32_t</span> count) &#123;</span><br><span class="line">   ASSERT(buf != <span class="literal">NULL</span>);</span><br><span class="line">   <span class="keyword">int32_t</span> ret = <span class="number">-1</span>;</span><br><span class="line">   <span class="keyword">if</span> (fd &lt; <span class="number">0</span> || fd == stdout_no || fd == stderr_no) &#123;</span><br><span class="line">      printk(<span class="string">"sys_read: fd error\n"</span>);</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fd == stdin_no) &#123;</span><br><span class="line">      <span class="keyword">char</span>* buffer = buf;</span><br><span class="line">      <span class="keyword">uint32_t</span> bytes_read = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> (bytes_read &lt; count) &#123;</span><br><span class="line">	 *buffer = ioq_getchar(&amp;kbd_buf);</span><br><span class="line">	 bytes_read++;</span><br><span class="line">	 buffer++;</span><br><span class="line">      &#125;</span><br><span class="line">      ret = (bytes_read == <span class="number">0</span> ? <span class="number">-1</span> : (<span class="keyword">int32_t</span>)bytes_read);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">uint32_t</span> _fd = fd_local2global(fd);</span><br><span class="line">      ret = file_read(&amp;file_table[_fd], buf, count);   </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>加入了标准输入<code>stdin_no</code>的处理。若发现fd是<code>stdin_no</code>，下面就通过while和<code>ioq_getchar(&amp;kbd_buf)</code>，每次从键盘缓冲区<code>kbd_buf</code>中获取1 个字符，直到获取了count 个字符为止。</p>
<p>下面<code>syscall.c</code>中添加read 的系统调用，Linux 中read 函数的原型是：<code>ssize_t read(int fd, void *buf, size_t count);</code>，这和<code>sys_read</code>接口是一样的，在<code>syscall.h</code>的<code>enum SYSCALL_NR</code>中添加<code>SYS_READ</code>后，在<code>syscall.c</code>中添加系统调用read 的实现<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 从文件描述符fd 中读取count 个字节到buf */</span></span><br><span class="line"><span class="keyword">int32_t</span> read(<span class="keyword">int32_t</span> fd, <span class="keyword">void</span>* buf, <span class="keyword">uint32_t</span> count) &#123;</span><br><span class="line">   <span class="keyword">return</span> _syscall3(SYS_READ, fd, buf, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后在<code>syscall_init.c</code>的<code>syscall_init</code>函数中添加代码<code>syscall_table[SYS_READ] = sys_read</code>，在<code>syscall_table</code>数组中把read 与<code>sys_read</code>绑定到一起就行了。</p>
<h2 id="添加-putchar、clear-系统调用"><a href="#添加-putchar、clear-系统调用" class="headerlink" title="添加 putchar、clear 系统调用"></a>添加 putchar、clear 系统调用</h2><p>系统调用<code>putchar</code>的原型是<code>int putchar(int c)</code>，若成功输出，则返回值为<code>(unsigned int)c</code>，若失败则返回<code>EOF</code>，EOF 通常为−1。清屏命令<code>clear</code>对应的内核部分叫<code>cls_screen</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">global cls_screen</span><br><span class="line">cls_screen:</span><br><span class="line">   pushad</span><br><span class="line">   ;;;;;;;;;;;;;;;</span><br><span class="line">	; 由于用户程序的cpl为3,显存段的dpl为0,故用于显存段的选择子gs在低于自己特权的环境中为0,</span><br><span class="line">	; 导致用户程序再次进入中断后,gs为0,故直接在put_str中每次都为gs赋值. </span><br><span class="line">   mov ax, SELECTOR_VIDEO	       ; 不能直接把立即数送入gs,须由ax中转</span><br><span class="line">   mov gs, ax</span><br><span class="line"></span><br><span class="line">   mov ebx, 0</span><br><span class="line">   mov ecx, 80*25</span><br><span class="line"> .cls:</span><br><span class="line">   mov word [gs:ebx], 0x0720		  ;0x0720是黑底白字的空格键</span><br><span class="line">   add ebx, 2</span><br><span class="line">   loop .cls </span><br><span class="line">   mov ebx, 0</span><br><span class="line"></span><br><span class="line"> .set_cursor:				  ;直接把set_cursor搬过来用,省事</span><br><span class="line">;;;;;;; 1 先设置高8位 ;;;;;;;;</span><br><span class="line">   mov dx, 0x03d4			  ;索引寄存器</span><br><span class="line">   mov al, 0x0e				  ;用于提供光标位置的高8位</span><br><span class="line">   out dx, al</span><br><span class="line">   mov dx, 0x03d5			  ;通过读写数据端口0x3d5来获得或设置光标位置 </span><br><span class="line">   mov al, bh</span><br><span class="line">   out dx, al</span><br><span class="line"></span><br><span class="line">;;;;;;; 2 再设置低8位 ;;;;;;;;;</span><br><span class="line">   mov dx, 0x03d4</span><br><span class="line">   mov al, 0x0f</span><br><span class="line">   out dx, al</span><br><span class="line">   mov dx, 0x03d5 </span><br><span class="line">   mov al, bl</span><br><span class="line">   out dx, al</span><br><span class="line">   popad</span><br><span class="line">   ret</span><br></pre></td></tr></table></figure></p>
<p>下面是系统调用putchar 和clear 的实现<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 输出一个字符 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">putchar</span><span class="params">(<span class="keyword">char</span> char_asci)</span> </span>&#123;</span><br><span class="line">   _syscall1(SYS_PUTCHAR, char_asci);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 清空屏幕 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">   _syscall0(SYS_CLEAR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这两个函数完成之后，还要在<code>syscall.h</code>的<code>enum SYSCALL_NR</code>结构中添加<code>SYS_PUTCHAR</code>和<code>SYS_CLEAR</code>，最后在<code>syscall-init.c</code>中增加初始化代码<code>syscall_table[SYS_PUTCHAR] = sys_putchar;</code>和<code>syscall_table[SYS_CLEAR] = cls_screen;</code>。</p>
<h2 id="实现一个简单的-shell"><a href="#实现一个简单的-shell" class="headerlink" title="实现一个简单的 shell"></a>实现一个简单的 shell</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> cmd_len 128	   <span class="comment">// 最大支持键入128个字符的命令行输入</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_ARG_NR 16	   <span class="comment">// 加上命令名外,最多支持15个参数</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 存储输入的命令 */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> cmd_line[cmd_len] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 用来记录当前目录,是当前目录的缓存,每次执行cd命令时会更新此内容 */</span></span><br><span class="line"><span class="keyword">char</span> cwd_cache[<span class="number">64</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出提示符 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_prompt</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"[rabbit@localhost %s]$ "</span>, cwd_cache);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 从键盘缓冲区中最多读入count个字节到buf。*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readline</span><span class="params">(<span class="keyword">char</span>* buf, <span class="keyword">int32_t</span> count)</span> </span>&#123;</span><br><span class="line">   assert(buf != <span class="literal">NULL</span> &amp;&amp; count &gt; <span class="number">0</span>);</span><br><span class="line">   <span class="keyword">char</span>* pos = buf;</span><br><span class="line">   <span class="keyword">while</span> (read(stdin_no, pos, <span class="number">1</span>) != <span class="number">-1</span> &amp;&amp; (pos - buf) &lt; count) &#123; <span class="comment">// 在不出错情况下,直到找到回车符才返回</span></span><br><span class="line">      <span class="keyword">switch</span> (*pos) &#123;</span><br><span class="line">       <span class="comment">/* 找到回车或换行符后认为键入的命令结束,直接返回 */</span></span><br><span class="line">	 <span class="keyword">case</span> <span class="string">'\n'</span>:</span><br><span class="line">	 <span class="keyword">case</span> <span class="string">'\r'</span>:</span><br><span class="line">	    *pos = <span class="number">0</span>;	   <span class="comment">// 添加cmd_line的终止字符0</span></span><br><span class="line">	    <span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">	    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	 <span class="keyword">case</span> <span class="string">'\b'</span>:</span><br><span class="line">	    <span class="keyword">if</span> (buf[<span class="number">0</span>] != <span class="string">'\b'</span>) &#123;		<span class="comment">// 阻止删除非本次输入的信息</span></span><br><span class="line">	       --pos;	   <span class="comment">// 退回到缓冲区cmd_line中上一个字符</span></span><br><span class="line">	       <span class="built_in">putchar</span>(<span class="string">'\b'</span>);</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	 <span class="comment">/* 非控制键则输出字符 */</span></span><br><span class="line">	 <span class="keyword">default</span>:</span><br><span class="line">	    <span class="built_in">putchar</span>(*pos);</span><br><span class="line">	    pos++;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"readline: can`t find enter_key in the cmd_line, max num of char is 128\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 简单的shell */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_shell</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">   cwd_cache[<span class="number">0</span>] = <span class="string">'/'</span>;</span><br><span class="line">   <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">      print_prompt(); </span><br><span class="line">      <span class="built_in">memset</span>(cmd_line, <span class="number">0</span>, cmd_len);</span><br><span class="line">      readline(cmd_line, cmd_len);</span><br><span class="line">      <span class="keyword">if</span> (cmd_line[<span class="number">0</span>] == <span class="number">0</span>) &#123;	 <span class="comment">// 若只键入了一个回车</span></span><br><span class="line">	 <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   panic(<span class="string">"my_shell: should not be here"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第11 行的<code>cmd_len</code>表示<strong>命令字符串最大的长度</strong>，其值为128，下一行的<code>MAX_ARG_NR</code>表示最大支持的参数个数。数组<code>cmd_line</code>用来<strong>存储键入的命令</strong>。数组<code>cwd_cache</code>用来<strong>存储当前目录名</strong>。函数<code>print_prompt</code>用于输出命令提示符，用<code>printf</code>函数输出<code>[rabbit@localhost %s]$</code>，函数<code>readline</code>接受2 个参数，缓冲区buf 和读入的字符数，功能是<strong>从键盘缓冲区中最多读入count 个字节到buf</strong>。字符指针pos 指向缓冲区buf，通过pos 往buf 中写数据。</p>
<p>函数体每次通过read 系统调用读入1 个字符到buf中。通过switch结构判断读入的字符<code>*pos</code>的值，前三个case 是处理控制键，分别是回车换行符及退格键。函数<code>my_shell</code>就是所实现的简单shell，函数中先<strong>将当前工作目录缓存cwd_cache 置为根目录’/‘</strong>，然后通过while 语句，循环调用print_prompt 输出命令提示符，然后调用readline 获取用户输入。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">   put_str(<span class="string">"I am kernel\n"</span>);</span><br><span class="line">   init_all();</span><br><span class="line">   cls_screen();</span><br><span class="line">   console_put_str(<span class="string">"[rabbit@localhost /]$ "</span>);</span><br><span class="line">   <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* init进程 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">uint32_t</span> ret_pid = fork();</span><br><span class="line">   <span class="keyword">if</span>(ret_pid) &#123;  <span class="comment">// 父进程</span></span><br><span class="line">      <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;	  <span class="comment">// 子进程</span></span><br><span class="line">      my_shell();</span><br><span class="line">   &#125;</span><br><span class="line">   panic(<span class="string">"init: should not be here"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在键盘驱动中：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/*****************  快捷键ctrl+l和ctrl+u的处理 *********************</span></span><br><span class="line"><span class="comment">    * 下面是把ctrl+l和ctrl+u这两种组合键产生的字符置为:</span></span><br><span class="line"><span class="comment">    * cur_char的asc码-字符a的asc码, 此差值比较小,</span></span><br><span class="line"><span class="comment">    * 属于asc码表中不可见的字符部分.故不会产生可见字符.</span></span><br><span class="line"><span class="comment">    * 我们在shell中将ascii值为l-a和u-a的分别处理为清屏和删除输入的快捷键*/</span></span><br><span class="line"><span class="keyword">if</span> ((ctrl_down_last &amp;&amp; cur_char == <span class="string">'l'</span>) || (ctrl_down_last &amp;&amp; cur_char == <span class="string">'u'</span>)) &#123;</span><br><span class="line">   cur_char -= <span class="string">'a'</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">/****************************************************************/</span></span><br></pre></td></tr></table></figure></p>
<p>变量<code>cur_char</code>中存储的是按键的ASCII 码，在<code>keyboard.c</code>将<code>ctrl+l</code>和<code>ctrl+u</code>组合键也转换为ASCII 码，不过此时<code>cur_char</code>中存储的是<strong>字符l 或字符u 的ASCII 码值减去字符a 的ASCII 码值的差</strong>。在ASCII 码表中，ASCII 码值为十进制0～31 和127 的字符是控制字符，它们不可见，因此字符l 和字符u 的ASCII 码值减去a 的ASCII 后的差会落到控制字符中，但并不是所有的控制字符都可占用，对于系统中已经处理的控制字符必须要保留。比如退格键‘\b’、换行符‘\n’和回车符‘\r’的ASCII 码分别是8、10 和13，咱们已经在shell.c 中针对它们做出了处理，因此要定义其他快捷键的话，要将这三个控制键的ASCII 码跨过去。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 从键盘缓冲区中最多读入count个字节到buf。*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readline</span><span class="params">(<span class="keyword">char</span>* buf, <span class="keyword">int32_t</span> count)</span> </span>&#123;</span><br><span class="line">   assert(buf != <span class="literal">NULL</span> &amp;&amp; count &gt; <span class="number">0</span>);</span><br><span class="line">   <span class="keyword">char</span>* pos = buf;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">while</span> (read(stdin_no, pos, <span class="number">1</span>) != <span class="number">-1</span> &amp;&amp; (pos - buf) &lt; count) &#123; <span class="comment">// 在不出错情况下,直到找到回车符才返回</span></span><br><span class="line">      <span class="keyword">switch</span> (*pos) &#123;</span><br><span class="line">       <span class="comment">/* 找到回车或换行符后认为键入的命令结束,直接返回 */</span></span><br><span class="line">	 <span class="keyword">case</span> <span class="string">'\n'</span>:</span><br><span class="line">	 <span class="keyword">case</span> <span class="string">'\r'</span>:</span><br><span class="line">	    *pos = <span class="number">0</span>;	   <span class="comment">// 添加cmd_line的终止字符0</span></span><br><span class="line">	    <span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">	    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	 <span class="keyword">case</span> <span class="string">'\b'</span>:</span><br><span class="line">	    <span class="keyword">if</span> (cmd_line[<span class="number">0</span>] != <span class="string">'\b'</span>) &#123;		<span class="comment">// 阻止删除非本次输入的信息</span></span><br><span class="line">	       --pos;	   <span class="comment">// 退回到缓冲区cmd_line中上一个字符</span></span><br><span class="line">	       <span class="built_in">putchar</span>(<span class="string">'\b'</span>);</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	 <span class="comment">/* ctrl+l 清屏 */</span></span><br><span class="line">	 <span class="keyword">case</span> <span class="string">'l'</span> - <span class="string">'a'</span>: </span><br><span class="line">	    <span class="comment">/* 1 先将当前的字符'l'-'a'置为0 */</span></span><br><span class="line">	    *pos = <span class="number">0</span>;</span><br><span class="line">	    <span class="comment">/* 2 再将屏幕清空 */</span></span><br><span class="line">	    clear();</span><br><span class="line">	    <span class="comment">/* 3 打印提示符 */</span></span><br><span class="line">	    print_prompt();</span><br><span class="line">	    <span class="comment">/* 4 将之前键入的内容再次打印 */</span></span><br><span class="line">	    <span class="built_in">printf</span>(<span class="string">"%s"</span>, buf);</span><br><span class="line">	    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	 <span class="comment">/* ctrl+u 清掉输入 */</span></span><br><span class="line">	 <span class="keyword">case</span> <span class="string">'u'</span> - <span class="string">'a'</span>:</span><br><span class="line">	    <span class="keyword">while</span> (buf != pos) &#123;</span><br><span class="line">	       <span class="built_in">putchar</span>(<span class="string">'\b'</span>);</span><br><span class="line">	       *(pos--) = <span class="number">0</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	 <span class="comment">/* 非控制键则输出字符 */</span></span><br><span class="line">	 <span class="keyword">default</span>:</span><br><span class="line">	    <span class="built_in">putchar</span>(*pos);</span><br><span class="line">	    pos++;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"readline: can`t find enter_key in the cmd_line, max num of char is 128\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把<code>ctrl+l</code>键处理为清屏操作，这分为四步来完成。</p>
<ul>
<li>先将pos 指向的字符置为0，也就是字符串结束符‘\0’。</li>
<li>调用clear 系统调用清屏。</li>
<li>然后调用print_prompt 函数重新输出命令提示符。</li>
<li>把buf 中的字符串通过printf 打印出来。</li>
</ul>
<p>处理快捷键“ctrl+u”的实现原理是通过while循环连续输出退格符，然后使指针pos逐步递减，并将对应位置为0，直到pos 指向了buf 的起始处。</p>
<h3 id="解析键入的字符"><a href="#解析键入的字符" class="headerlink" title="解析键入的字符"></a>解析键入的字符</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 分析字符串cmd_str中以token为分隔符的单词,将各单词的指针存入argv数组 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> int32_t <span class="title">cmd_parse</span><span class="params">(<span class="keyword">char</span>* cmd_str, <span class="keyword">char</span>** argv, <span class="keyword">char</span> token)</span> </span>&#123;</span><br><span class="line">   assert(cmd_str != <span class="literal">NULL</span>);</span><br><span class="line">   <span class="keyword">int32_t</span> arg_idx = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span>(arg_idx &lt; MAX_ARG_NR) &#123;</span><br><span class="line">      argv[arg_idx] = <span class="literal">NULL</span>;</span><br><span class="line">      arg_idx++;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">char</span>* next = cmd_str;</span><br><span class="line">   <span class="keyword">int32_t</span> argc = <span class="number">0</span>;</span><br><span class="line">   <span class="comment">/* 外层循环处理整个命令行 */</span></span><br><span class="line">   <span class="keyword">while</span>(*next) &#123;</span><br><span class="line">      <span class="comment">/* 去除命令字或参数之间的空格 */</span></span><br><span class="line">      <span class="keyword">while</span>(*next == token) &#123;</span><br><span class="line">	 next++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/* 处理最后一个参数后接空格的情况,如"ls dir2 " */</span></span><br><span class="line">      <span class="keyword">if</span> (*next == <span class="number">0</span>) &#123;</span><br><span class="line">	 <span class="keyword">break</span>; </span><br><span class="line">      &#125;</span><br><span class="line">      argv[argc] = next;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* 内层循环处理命令行中的每个命令字及参数 */</span></span><br><span class="line">      <span class="keyword">while</span> (*next &amp;&amp; *next != token) &#123;	  <span class="comment">// 在字符串结束前找单词分隔符</span></span><br><span class="line">	 next++;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 如果未结束(是token字符),使tocken变成0 */</span></span><br><span class="line">      <span class="keyword">if</span> (*next) &#123;</span><br><span class="line">	 *next++ = <span class="number">0</span>;	<span class="comment">// 将token字符替换为字符串结束符0,做为一个单词的结束,并将字符指针next指向下一个字符</span></span><br><span class="line">      &#125;</span><br><span class="line">   </span><br><span class="line">      <span class="comment">/* 避免argv数组访问越界,参数过多则返回0 */</span></span><br><span class="line">      <span class="keyword">if</span> (argc &gt; MAX_ARG_NR) &#123;</span><br><span class="line">	 <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      argc++;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> argc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>* argv[MAX_ARG_NR];    <span class="comment">// argv必须为全局变量，为了以后exec的程序可访问参数</span></span><br><span class="line"><span class="keyword">int32_t</span> argc = <span class="number">-1</span>;</span><br><span class="line"><span class="comment">/* 简单的shell */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_shell</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">   cwd_cache[<span class="number">0</span>] = <span class="string">'/'</span>;</span><br><span class="line">   <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">      print_prompt(); </span><br><span class="line">      <span class="built_in">memset</span>(final_path, <span class="number">0</span>, MAX_PATH_LEN);</span><br><span class="line">      <span class="built_in">memset</span>(cmd_line, <span class="number">0</span>, MAX_PATH_LEN);</span><br><span class="line">      readline(cmd_line, MAX_PATH_LEN);</span><br><span class="line">      <span class="keyword">if</span> (cmd_line[<span class="number">0</span>] == <span class="number">0</span>) &#123;	 <span class="comment">// 若只键入了一个回车</span></span><br><span class="line">	 <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      argc = <span class="number">-1</span>;</span><br><span class="line">      argc = cmd_parse(cmd_line, argv, <span class="string">' '</span>);</span><br><span class="line">      <span class="keyword">if</span> (argc == <span class="number">-1</span>) &#123;</span><br><span class="line">	 <span class="built_in">printf</span>(<span class="string">"num of arguments exceed %d\n"</span>, MAX_ARG_NR);</span><br><span class="line">	 <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">int32_t</span> arg_idx = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span>(arg_idx &lt; argc) &#123;</span><br><span class="line">	 <span class="built_in">printf</span>(<span class="string">"%s "</span>, argv[arg_idx]); </span><br><span class="line">	 arg_idx++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   panic(<span class="string">"my_shell: should not be here"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数<code>cmd_parse</code>接受3 个参数，<strong>用户键入的原始命令串cmd_str</strong>、<strong>参数字符串数组argv</strong>、<strong>分隔符token</strong>。功能是<strong>分析字符串cmd_str 中以token 为分隔符的单词，将解析出来的单词的指针存入argv 数组</strong>。指针next 指向cmd_str，next 用于处理每一个字符，while 外层循环处理整个命<br>令行cmd_str。<code>argv[argc] = next</code>，每找出一个字符串就将其在cmd_str 中的起始next 存储到argv 数组。</p>
<h3 id="添加系统调用"><a href="#添加系统调用" class="headerlink" title="添加系统调用"></a>添加系统调用</h3><p>按照添加系统调用的三个步骤：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> SYSCALL_NR &#123;</span><br><span class="line">   SYS_GETPID,</span><br><span class="line">   SYS_WRITE,</span><br><span class="line">   SYS_MALLOC,</span><br><span class="line">   SYS_FREE,</span><br><span class="line">   SYS_FORK,</span><br><span class="line">   SYS_READ,</span><br><span class="line">   SYS_PUTCHAR,</span><br><span class="line">   SYS_CLEAR,</span><br><span class="line">   SYS_GETCWD,</span><br><span class="line">   SYS_OPEN,</span><br><span class="line">   SYS_CLOSE,</span><br><span class="line">   SYS_LSEEK,</span><br><span class="line">   SYS_UNLINK,</span><br><span class="line">   SYS_MKDIR,</span><br><span class="line">   SYS_OPENDIR,</span><br><span class="line">   SYS_CLOSEDIR,</span><br><span class="line">   SYS_CHDIR,</span><br><span class="line">   SYS_RMDIR,</span><br><span class="line">   SYS_READDIR,</span><br><span class="line">   SYS_REWINDDIR,</span><br><span class="line">   SYS_STAT,</span><br><span class="line">   SYS_PS</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>以上定义的<code>enum SYSCALL_NR</code>是咱们系统中目前所支持的所有系统调用。下面是新增的系统调用实现。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 获取当前工作目录 */</span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">getcwd</span><span class="params">(<span class="keyword">char</span>* buf, <span class="keyword">uint32_t</span> size)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> (<span class="keyword">char</span>*)_syscall2(SYS_GETCWD, buf, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 以flag方式打开文件pathname */</span></span><br><span class="line"><span class="keyword">int32_t</span> open(<span class="keyword">char</span>* pathname, <span class="keyword">uint8_t</span> flag) &#123;</span><br><span class="line">   <span class="keyword">return</span> _syscall2(SYS_OPEN, pathname, flag);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 关闭文件fd */</span></span><br><span class="line"><span class="keyword">int32_t</span> close(<span class="keyword">int32_t</span> fd) &#123;</span><br><span class="line">   <span class="keyword">return</span> _syscall1(SYS_CLOSE, fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置文件偏移量 */</span></span><br><span class="line"><span class="keyword">int32_t</span> lseek(<span class="keyword">int32_t</span> fd, <span class="keyword">int32_t</span> offset, <span class="keyword">uint8_t</span> whence) &#123;</span><br><span class="line">   <span class="keyword">return</span> _syscall3(SYS_LSEEK, fd, offset, whence);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 删除文件pathname */</span></span><br><span class="line"><span class="keyword">int32_t</span> unlink(<span class="keyword">const</span> <span class="keyword">char</span>* pathname) &#123;</span><br><span class="line">   <span class="keyword">return</span> _syscall1(SYS_UNLINK, pathname);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建目录pathname */</span></span><br><span class="line"><span class="keyword">int32_t</span> mkdir(<span class="keyword">const</span> <span class="keyword">char</span>* pathname) &#123;</span><br><span class="line">   <span class="keyword">return</span> _syscall1(SYS_MKDIR, pathname);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 打开目录name */</span></span><br><span class="line"><span class="function">struct dir* <span class="title">opendir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> (struct dir*)_syscall1(SYS_OPENDIR, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 关闭目录dir */</span></span><br><span class="line"><span class="keyword">int32_t</span> closedir(struct dir* dir) &#123;</span><br><span class="line">   <span class="keyword">return</span> _syscall1(SYS_CLOSEDIR, dir);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 删除目录pathname */</span></span><br><span class="line"><span class="keyword">int32_t</span> rmdir(<span class="keyword">const</span> <span class="keyword">char</span>* pathname) &#123;</span><br><span class="line">   <span class="keyword">return</span> _syscall1(SYS_RMDIR, pathname);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 读取目录dir */</span></span><br><span class="line"><span class="function">struct dir_entry* <span class="title">readdir</span><span class="params">(struct dir* dir)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> (struct dir_entry*)_syscall1(SYS_READDIR, dir);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 回归目录指针 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rewinddir</span><span class="params">(struct dir* dir)</span> </span>&#123;</span><br><span class="line">   _syscall1(SYS_REWINDDIR, dir);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取path属性到buf中 */</span></span><br><span class="line"><span class="keyword">int32_t</span> stat(<span class="keyword">const</span> <span class="keyword">char</span>* path, struct stat* buf) &#123;</span><br><span class="line">   <span class="keyword">return</span> _syscall2(SYS_STAT, path, buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 改变工作目录为path */</span></span><br><span class="line"><span class="keyword">int32_t</span> chdir(<span class="keyword">const</span> <span class="keyword">char</span>* path) &#123;</span><br><span class="line">   <span class="keyword">return</span> _syscall1(SYS_CHDIR, path);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 显示任务列表 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ps</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">   _syscall0(SYS_PS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这些系统调用要在syscall_table 中注册：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 初始化系统调用 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">syscall_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">   put_str(<span class="string">"syscall_init start\n"</span>);</span><br><span class="line">   syscall_table[SYS_GETPID]     = sys_getpid;</span><br><span class="line">   syscall_table[SYS_WRITE]      = sys_write;</span><br><span class="line">   syscall_table[SYS_MALLOC]     = sys_malloc;</span><br><span class="line">   syscall_table[SYS_FREE]       = sys_free;</span><br><span class="line">   syscall_table[SYS_FORK]       = sys_fork;</span><br><span class="line">   syscall_table[SYS_READ]       = sys_read;</span><br><span class="line">   syscall_table[SYS_PUTCHAR]    = sys_putchar;</span><br><span class="line">   syscall_table[SYS_CLEAR]      = cls_screen;</span><br><span class="line">   syscall_table[SYS_GETCWD]     = sys_getcwd;</span><br><span class="line">   syscall_table[SYS_OPEN]       = sys_open;</span><br><span class="line">   syscall_table[SYS_CLOSE]      = sys_close;</span><br><span class="line">   syscall_table[SYS_LSEEK]	 = sys_lseek;</span><br><span class="line">   syscall_table[SYS_UNLINK]	 = sys_unlink;</span><br><span class="line">   syscall_table[SYS_MKDIR]	 = sys_mkdir;</span><br><span class="line">   syscall_table[SYS_OPENDIR]	 = sys_opendir;</span><br><span class="line">   syscall_table[SYS_CLOSEDIR]   = sys_closedir;</span><br><span class="line">   syscall_table[SYS_CHDIR]	 = sys_chdir;</span><br><span class="line">   syscall_table[SYS_RMDIR]	 = sys_rmdir;</span><br><span class="line">   syscall_table[SYS_READDIR]	 = sys_readdir;</span><br><span class="line">   syscall_table[SYS_REWINDDIR]	 = sys_rewinddir;</span><br><span class="line">   syscall_table[SYS_STAT]	 = sys_stat;</span><br><span class="line">   syscall_table[SYS_PS]	 = sys_ps;</span><br><span class="line">   put_str(<span class="string">"syscall_init done\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="加载用户进程"><a href="#加载用户进程" class="headerlink" title="加载用户进程"></a>加载用户进程</h2><p>exec 函数定义在userprog/exec.c 中：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">intr_exit</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint32_t</span> Elf32_Word, Elf32_Addr, Elf32_Off;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint16_t</span> Elf32_Half;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 32位elf头 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Elf32_Ehdr</span> &#123;</span></span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">char</span> e_ident[<span class="number">16</span>];</span><br><span class="line">   Elf32_Half    e_type;</span><br><span class="line">   Elf32_Half    e_machine;</span><br><span class="line">   Elf32_Word    e_version;</span><br><span class="line">   Elf32_Addr    e_entry;</span><br><span class="line">   Elf32_Off     e_phoff;</span><br><span class="line">   Elf32_Off     e_shoff;</span><br><span class="line">   Elf32_Word    e_flags;</span><br><span class="line">   Elf32_Half    e_ehsize;</span><br><span class="line">   Elf32_Half    e_phentsize;</span><br><span class="line">   Elf32_Half    e_phnum;</span><br><span class="line">   Elf32_Half    e_shentsize;</span><br><span class="line">   Elf32_Half    e_shnum;</span><br><span class="line">   Elf32_Half    e_shstrndx;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 程序头表Program header.就是段描述头 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Elf32_Phdr</span> &#123;</span></span><br><span class="line">   Elf32_Word p_type;		 <span class="comment">// 见下面的enum segment_type</span></span><br><span class="line">   Elf32_Off  p_offset;</span><br><span class="line">   Elf32_Addr p_vaddr;</span><br><span class="line">   Elf32_Addr p_paddr;</span><br><span class="line">   Elf32_Word p_filesz;</span><br><span class="line">   Elf32_Word p_memsz;</span><br><span class="line">   Elf32_Word p_flags;</span><br><span class="line">   Elf32_Word p_align;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 段类型 */</span></span><br><span class="line"><span class="keyword">enum</span> segment_type &#123;</span><br><span class="line">   PT_NULL,            <span class="comment">// 忽略</span></span><br><span class="line">   PT_LOAD,            <span class="comment">// 可加载程序段</span></span><br><span class="line">   PT_DYNAMIC,         <span class="comment">// 动态加载信息 </span></span><br><span class="line">   PT_INTERP,          <span class="comment">// 动态加载器名称</span></span><br><span class="line">   PT_NOTE,            <span class="comment">// 一些辅助信息</span></span><br><span class="line">   PT_SHLIB,           <span class="comment">// 保留</span></span><br><span class="line">   PT_PHDR             <span class="comment">// 程序头表</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>定义了<code>elf</code>相关的数据结构和一些以前缀<code>Elf32_</code>开头的变量，这是为了在名称上与elf 相关结构中的变量类型吻合，其实变量类型只是存储数值的空间大小而已，ELF 结构字段中的变量大小分别是4 字节和2 字节。结构体<code>struct Elf32_Ehdr</code>定义的是32 位elf 文件头。接下来是结构体<code>struct Elf32_Phdr</code>，它表示程序头表，也就是段头表。枚举类型<code>enum segment_type</code>表示可识别的段的类型，这里咱们只关注类型为<code>PT_LOAD</code>的段就可以了，它是可加载的段，也就是程序本身的程序体。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 将文件描述符fd指向的文件中,偏移为offset,大小为filesz的段加载到虚拟地址为vaddr的内存 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">segment_load</span><span class="params">(<span class="keyword">int32_t</span> fd, <span class="keyword">uint32_t</span> offset, <span class="keyword">uint32_t</span> filesz, <span class="keyword">uint32_t</span> vaddr)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">uint32_t</span> vaddr_first_page = vaddr &amp; <span class="number">0xfffff000</span>;    <span class="comment">// vaddr地址所在的页框</span></span><br><span class="line">   <span class="keyword">uint32_t</span> size_in_first_page = PG_SIZE - (vaddr &amp; <span class="number">0x00000fff</span>);     <span class="comment">// 加载到内存后,文件在第一个页框中占用的字节大小</span></span><br><span class="line">   <span class="keyword">uint32_t</span> occupy_pages = <span class="number">0</span>;</span><br><span class="line">   <span class="comment">/* 若一个页框容不下该段 */</span></span><br><span class="line">   <span class="keyword">if</span> (filesz &gt; size_in_first_page) &#123;</span><br><span class="line">      <span class="keyword">uint32_t</span> left_size = filesz - size_in_first_page;</span><br><span class="line">      occupy_pages = DIV_ROUND_UP(left_size, PG_SIZE) + <span class="number">1</span>;	     <span class="comment">// 1是指vaddr_first_page</span></span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      occupy_pages = <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 为进程分配内存 */</span></span><br><span class="line">   <span class="keyword">uint32_t</span> page_idx = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">uint32_t</span> vaddr_page = vaddr_first_page;</span><br><span class="line">   <span class="keyword">while</span> (page_idx &lt; occupy_pages) &#123;</span><br><span class="line">      <span class="keyword">uint32_t</span>* pde = pde_ptr(vaddr_page);</span><br><span class="line">      <span class="keyword">uint32_t</span>* pte = pte_ptr(vaddr_page);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 如果pde不存在,或者pte不存在就分配内存.</span></span><br><span class="line"><span class="comment">       * pde的判断要在pte之前,否则pde若不存在会导致</span></span><br><span class="line"><span class="comment">       * 判断pte时缺页异常 */</span></span><br><span class="line">      <span class="keyword">if</span> (!(*pde &amp; <span class="number">0x00000001</span>) || !(*pte &amp; <span class="number">0x00000001</span>)) &#123;</span><br><span class="line">	 <span class="keyword">if</span> (get_a_page(PF_USER, vaddr_page) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">	    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	 &#125;</span><br><span class="line">      &#125; <span class="comment">// 如果原进程的页表已经分配了,利用现有的物理页,直接覆盖进程体</span></span><br><span class="line">      vaddr_page += PG_SIZE;</span><br><span class="line">      page_idx++;</span><br><span class="line">   &#125;</span><br><span class="line">   sys_lseek(fd, offset, SEEK_SET);</span><br><span class="line">   sys_read(fd, (<span class="keyword">void</span>*)vaddr, filesz);</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数<code>segment_load</code>接受4 个参数，<strong>文件描述符fd</strong>、<strong>段在文件中的字节偏移量offset</strong>、<strong>段大小filesz</strong>、<strong>段被加载到的虚拟地址vaddr</strong>，函数功能是<strong>将文件描述符fd 指向的文件中，偏移为offset，大小为filesz 的段加载到虚拟地址为vaddr 的内存空间</strong>。变量<code>vaddr_first_page</code>用于<strong>获取虚拟地址vaddr 所在的页框起始地址</strong>。变量<code>size_in_first_page</code>就<strong>表示文件在第一个页框中占用的字节大小</strong>，变量<code>occupy_pages</code>表示<strong>该段占用的总页框数</strong>，如果段大小filesz 大于size_in_first_page，这表示一个页框容不下该段，计算该段占用的页框数并赋值给<code>occupy_pages</code>，如果段比较小，一个页框可以容纳该段，就将<code>occupy_pages</code>置为1。</p>
<p>下面是从文件系统上加载用户进程到刚刚分配好的内存中，先通过<code>sys_lseek</code>函数将<strong>文件指针定位到段在文件中的偏移地址</strong>，然后将该段读入到虚拟地<br>址vaddr 处。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 从文件系统上加载用户程序pathname,成功则返回程序的起始地址,否则返回-1 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> int32_t <span class="title">load</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* pathname)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int32_t</span> ret = <span class="number">-1</span>;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">Elf32_Ehdr</span> <span class="title">elf_header</span>;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">Elf32_Phdr</span> <span class="title">prog_header</span>;</span></span><br><span class="line">   <span class="built_in">memset</span>(&amp;elf_header, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct Elf32_Ehdr));</span><br><span class="line"></span><br><span class="line">   <span class="keyword">int32_t</span> fd = sys_open(pathname, O_RDONLY);</span><br><span class="line">   <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (sys_read(fd, &amp;elf_header, <span class="keyword">sizeof</span>(struct Elf32_Ehdr)) != <span class="keyword">sizeof</span>(struct Elf32_Ehdr)) &#123;</span><br><span class="line">      ret = <span class="number">-1</span>;</span><br><span class="line">      <span class="keyword">goto</span> done;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 校验elf头 */</span></span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">memcmp</span>(elf_header.e_ident, <span class="string">"\177ELF\1\1\1"</span>, <span class="number">7</span>) \</span><br><span class="line">      || elf_header.e_type != <span class="number">2</span> \</span><br><span class="line">      || elf_header.e_machine != <span class="number">3</span> \</span><br><span class="line">      || elf_header.e_version != <span class="number">1</span> \</span><br><span class="line">      || elf_header.e_phnum &gt; <span class="number">1024</span> \</span><br><span class="line">      || elf_header.e_phentsize != <span class="keyword">sizeof</span>(struct Elf32_Phdr)) &#123;</span><br><span class="line">      ret = <span class="number">-1</span>;</span><br><span class="line">      <span class="keyword">goto</span> done;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   Elf32_Off prog_header_offset = elf_header.e_phoff; </span><br><span class="line">   Elf32_Half prog_header_size = elf_header.e_phentsize;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 遍历所有程序头 */</span></span><br><span class="line">   <span class="keyword">uint32_t</span> prog_idx = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span> (prog_idx &lt; elf_header.e_phnum) &#123;</span><br><span class="line">      <span class="built_in">memset</span>(&amp;prog_header, <span class="number">0</span>, prog_header_size);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">/* 将文件的指针定位到程序头 */</span></span><br><span class="line">      sys_lseek(fd, prog_header_offset, SEEK_SET);</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* 只获取程序头 */</span></span><br><span class="line">      <span class="keyword">if</span> (sys_read(fd, &amp;prog_header, prog_header_size) != prog_header_size) &#123;</span><br><span class="line">	 ret = <span class="number">-1</span>;</span><br><span class="line">	 <span class="keyword">goto</span> done;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 如果是可加载段就调用segment_load加载到内存 */</span></span><br><span class="line">      <span class="keyword">if</span> (PT_LOAD == prog_header.p_type) &#123;</span><br><span class="line">	 <span class="keyword">if</span> (!segment_load(fd, prog_header.p_offset, prog_header.p_filesz, prog_header.p_vaddr)) &#123;</span><br><span class="line">	    ret = <span class="number">-1</span>;</span><br><span class="line">	    <span class="keyword">goto</span> done;</span><br><span class="line">	 &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 更新下一个程序头的偏移 */</span></span><br><span class="line">      prog_header_offset += elf_header.e_phentsize;</span><br><span class="line">      prog_idx++;</span><br><span class="line">   &#125;</span><br><span class="line">   ret = elf_header.e_entry;</span><br><span class="line">done:</span><br><span class="line">   sys_close(fd);</span><br><span class="line">   <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 用path指向的程序替换当前进程 */</span></span><br><span class="line"><span class="keyword">int32_t</span> sys_execv(<span class="keyword">const</span> <span class="keyword">char</span>* path, <span class="keyword">const</span> <span class="keyword">char</span>* argv[]) &#123;</span><br><span class="line">   <span class="keyword">uint32_t</span> argc = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span> (argv[argc]) &#123;</span><br><span class="line">      argc++;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">int32_t</span> entry_point = load(path);     </span><br><span class="line">   <span class="keyword">if</span> (entry_point == <span class="number">-1</span>) &#123;	 <span class="comment">// 若加载失败则返回-1</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>* <span class="title">cur</span> = <span class="title">running_thread</span>();</span></span><br><span class="line">   <span class="comment">/* 修改进程名 */</span></span><br><span class="line">   <span class="built_in">memcpy</span>(cur-&gt;name, path, TASK_NAME_LEN);</span><br><span class="line">   cur-&gt;name[TASK_NAME_LEN<span class="number">-1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">intr_stack</span>* <span class="title">intr_0_stack</span> = (<span class="title">struct</span> <span class="title">intr_stack</span>*)((<span class="title">uint32_t</span>)<span class="title">cur</span> + <span class="title">PG_SIZE</span> - <span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">intr_stack</span>));</span></span><br><span class="line">   <span class="comment">/* 参数传递给用户进程 */</span></span><br><span class="line">   intr_0_stack-&gt;ebx = (<span class="keyword">int32_t</span>)argv;</span><br><span class="line">   intr_0_stack-&gt;ecx = argc;</span><br><span class="line">   intr_0_stack-&gt;eip = (<span class="keyword">void</span>*)entry_point;</span><br><span class="line">   <span class="comment">/* 使新用户进程的栈地址为最高用户空间地址 */</span></span><br><span class="line">   intr_0_stack-&gt;esp = (<span class="keyword">void</span>*)<span class="number">0xc0000000</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* exec不同于fork,为使新进程更快被执行,直接从中断返回 */</span></span><br><span class="line">   <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(<span class="string">"movl %0, %%esp; jmp intr_exit"</span> : : <span class="string">"g"</span> (intr_0_stack) : <span class="string">"memory"</span>)</span></span>;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数<code>load</code>接受1个参数，<strong>可执行文件的绝对路径pathname</strong>，功能是<strong>从文件系统上加载用户程序pathname，成功则返回程序的起始地址，否则返回−1</strong>。先定义了elf头<code>elf_header</code>和程序头<code>prog_header</code>，读取可执行文件的elf头到<code>elf_header</code>。<strong>开始校验elf 头</strong>，判断加载的文件是否是elf 格式的。elf 头的<code>e_ident</code>字段是<strong>elf 格式的魔数</strong>，它是个16 字节的数组：</p>
<ul>
<li><code>e_ident[7～15]</code>暂时未用；</li>
<li>开头的4 个字节是固定不变的，它们分别是<code>0x7f</code>和字符串<code>ELF</code>的asc码<code>0x45 0x4c 0x46</code>。</li>
<li>成员<code>e_ident[4]</code>表示elf 是32 位，还是64 位，值为1 表示32 位，值为2 表示64 位。</li>
<li><code>e_ident[5]</code>表示字节序，值为1 表示小端字节序，值为2 表示大端字节序。</li>
<li><code>e_ident[6]</code>表示elf 版本信息，默认为1。</li>
<li><p><code>e_ident[0-6]</code>应该分别等于十六进制0x7F、0x45、0x4C、0x46、0x1、0x1 和0x1。</p>
</li>
<li><p><code>e_type</code>表示目标文件类型，其值应该为<code>ET_EXEC</code>，即等于2。</p>
</li>
<li><code>e_machine</code>表示体系结构，其值应该为<code>EM_386</code>，即等于3。</li>
<li><code>e_version</code>表示版本信息，其值应该为1。</li>
<li><code>e_phnum</code>用来指明程序头表中条目的数量，也就是段的个数，基值应该小于等于1024。</li>
<li><code>e_phentsize</code>用来指明程序头表中每个条目的字节大小，也就是每个用来描述段信息的数据结构的字节大小，该结构就是<code>struct Elf32_Phdr</code>，因此值应该为<code>sizeof (struct Elf32_Phdr)</code>。</li>
<li><strong>程序头的起始地址</strong>记录在<code>e_phoff</code>中，将其获取到变量<code>prog_header_offset</code>。程序头条目大小记录在<code>e_phentsize</code>中，将其获取到变量<code>prog_header_size</code>中。</li>
<li>程序头即段头，段的数量在<code>e_phnum</code>中记录，while 循环处理e_phnum 个段信息。</li>
</ul>
<h3 id="使用户进程支持参数"><a href="#使用户进程支持参数" class="headerlink" title="使用户进程支持参数"></a>使用户进程支持参数</h3><p>C 运行库也称为CRT（C RunTime library），它的实现也基于C 标准库，因此CRT 属于C 标准库的扩展。CRT 多是补充C 标准库中没有的功能，为适配本操作系统环境而定制开发的。因此CRT 并不通用，只适用于在本操作系统上运行的程序。其实CRT 代码才是用户程序的第一部分，我们的main 函数实质上是被夹在CRT 中执行的，它只是用户程序的中间部分，编译后的二进制可执行程序中还包括了 CRT 的指令。<br><img src="/img/1597306002.jpg" alt></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[bits 32]</span><br><span class="line">extern main</span><br><span class="line">section .text</span><br><span class="line">global _start</span><br><span class="line">_start:</span><br><span class="line">;下面这两个要和execv 中load 之后指定的寄存器一致</span><br><span class="line">   push ebx ;压入argv</span><br><span class="line">   push ecx ;压入argc</span><br><span class="line">   call main</span><br></pre></td></tr></table></figure>
<p>第2行通过<code>extern main</code>声明了外部函数main，即用户程序中的主函数main。第5行是标号<code>_start</code>，它是<strong>链接器默认的入口符号</strong>，如果ld 命令链接时未使用链接脚本或-e 参数指定入口符号的话，默认会以符号<code>_start</code>为程序入口。在文件<code>exec.c</code>中我们已经把新进程的参数压入内核栈中相应的寄存器，<code>sys_execv</code>执行完成从<code>intr_exit</code>返回后，<strong>寄存器ebx 是参数数组argv 的地址</strong>，<strong>寄存器ecx 是参数个数argc</strong>。因此将它们压入栈，此时的栈是用户栈，通过call 指令调用外部函数main，也就是用户程序开发人员所负责的主函数main。</p>
<h2 id="系统调用-wait-和exit"><a href="#系统调用-wait-和exit" class="headerlink" title="系统调用 wait 和exit"></a>系统调用 wait 和exit</h2><p>exit 的作用很直白，就是使进程“主动”退出。wait 的作用是<strong>阻塞父进程自己，直到任意一个子进程结束运行</strong>。wait 通常是由父进程调用的。尽管某个进程没有子进程，但<strong>只要它调用了wait 系统调用，该进程就被认为是父进程，内核就要去查找它的子进程</strong>，由于它没有子进程，此时wait会返回−1，表示其没有子进程。如果有子进程，这时候该进程就被阻塞，不再运行，内核就要去遍历其所有的子进程，查找哪个子进程退出了，并<strong>将子进程退出时的返回值传递给父进程，随后将父进程唤醒</strong>。</p>
<p>C 运行库中调用exit的形式就是<code>exit(子进程的返回值)</code>，那子进程直接调用<code>exit(返回值)</code>就可以了。<code>wait</code>的原型是<code>pid_t wait(int *status)</code>，其中<strong>status 是父进程用于存储子进程返回值的地址</strong>，父进程调用它之后，内核就会把子进程的返回值存储到status 指向的内存空间。</p>
<p>当父进程提前退出时，它所有的子进程还在运行，这些进程就称为<strong>孤儿进程</strong>。这时init 进程会成为这些子进程的新父亲，当子进程退出时会由init 负责为其“收尸”。<strong>僵尸进程</strong>也称为zombie。如果父进程在派生出子进程后<strong>并没有调用wait 等待接收子进程的返回值</strong>，这时某个子进程调用exit 退出了，其pcb 所占的空间不能释放，僵尸进程就是<strong>针对子进程的返回值是否成功提交给父进程而提出的</strong>，父进程不调用wait，就无法获知子进程的返回值，从而内核就无法回收子进程pcb 所占的空间，因此就会<strong>在队列中占据一个进程表项</strong>。僵尸进程是<strong>没有进程体的</strong>，因为其进程体已在调用exit 时被内核回收了，现在<strong>只剩下一个pcb还在进程队列中</strong>，它并不占太多的资源。</p>
<h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p><strong>管道</strong>是进程间通信的方式之一，<strong>管道也被视为文件</strong>，只是该文件并不存在于文件系统上，而是<strong>只存在于内存中</strong>，也要使用open、close、read、write 等方法来操作管道。管道通常被多个进程共享，而且存在于内存之中，因此共享的原理是<strong>所有进程在地址空间中都可以访问到它</strong>，其实就是<strong>内核空间中的内存缓冲区</strong>，指<strong>环形缓冲区</strong>。管道有两端，一端用于从管道中读入数据，另一端用于往管道中写入数据。这两端使用文件描述符的<br>方式来读取，故进程创建管道实际上是内核为其返回了用于读取管道缓冲区的文件描述符，一个描述符用于读，另一个描述符用于写。</p>
<p>通常情况下是<strong>用户进程为内核提供一个长度为2的文件描述符数组</strong>，<strong>内核会在该数组中写入管道操作的两个描述符</strong>，假设数组名为fd，那么<code>fd[0]</code> 用于读取管道，<code>fd[1]</code>用于写入管道，进程与管道的读写关系如图。<br><img src="/img/1597307751.jpg" alt></p>
<p>通常的用法是进程在创建管道之后，马上调用fork，克隆出一个子进程，子进程完全继承了父进程的一切，<strong>父子进程都可以通过文件描述符fd[1] 向管道中写数据*，通过文件描述符fd[0]从管道中读取数据</strong>。</p>
<p>管道分为两种：<strong>匿名管道</strong>和<strong>命名管道</strong>，匿名管道在创建之后只能通过内核为其返回的文件描述符来访问，此管道只对创建它的进程及其子进程可见，对其他进程不可见，因此除父子进程之外的其他进程便不知道此管道的存在，故匿名管道只能局限用于父子进程间的通信。有名管道是专门为解决匿名管道的局限性而生的，在Linux 中可以通过命令mkfifo 来创建命名管道。</p>
<h3 id="管道的设计"><a href="#管道的设计" class="headerlink" title="管道的设计"></a>管道的设计</h3><p>管道对于Linux 来说也是文件，因此它也需要用文件相关的数据结构来处理管道，Linux 是利用现有的文件结构和VFS 索引结点的inode 共同完成<br>管道的，并没有单独为管道创建新的数据结构，结构示意如图。<br><img src="/img/1597307924.png" alt></p>
<p>文件结构中的<code>f_inode</code>指向VFS 的<code>inode</code>，该<code>inode</code>指向1 个页框大小的内存区域，该区域便是<strong>管道用于存储数据的内存空间</strong>。也就是说，Linux 的管道大小是4096 字节。<code>f_op</code>用于指向操作（OPeration）方法。对于管道来说，<code>f_op</code>会指向<code>pipe_read</code>和<code>pipe_write</code>，<code>pipe_read</code>会从管道的 1 页内存中读取数据，<code>pipe_write</code>会往管道的1 页内存中写入数据。管道不需要inode，<code>fd_flags</code>的值将是<code>0xFFFF</code>，不再是<code>O_RDONLY</code>、<code>O_WRONLY</code>等值。把文件结构中的<code>fd_inode</code>指向管道的内存缓冲区。</p>
<p>无论进程的文件描述符是多少，只要使任意进程的文件描述符所指向的、位于<code>file_table</code>中的文件结构是同一个就行了。<br><img src="/img/1597310235.jpg" alt></p>
<p>为避免进程无限休眠的情况，我们让生产者和消费者每次只读写“适量”的数据，避免环形缓冲区满或空的情况，这样生产者或消费者进程就不会阻塞了。</p>
<p>在Linux 中创建管道的方法是系统调用<code>pipe</code>，其原型是<code>int pipe(int pipefd[2])</code>，成功返回0，失败返回−1，其中<code>pipefd[2]</code>是长度为2的整型数组，用来存储系统返回的文件描述符，文件描述符<code>fd[0]</code>用于读取管道，<code>fd[1]</code>用于写入管道。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 返回环形缓冲区中的数据长度 */</span></span><br><span class="line"><span class="keyword">uint32_t</span> ioq_length(struct ioqueue* ioq) &#123;</span><br><span class="line">   <span class="keyword">uint32_t</span> len = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">if</span> (ioq-&gt;head &gt;= ioq-&gt;tail) &#123;</span><br><span class="line">      len = ioq-&gt;head - ioq-&gt;tail;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      len = bufsize - (ioq-&gt;tail - ioq-&gt;head);     </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>函数ioq_length 接受1 个参数，环形缓冲区ioq，功能是<strong>返回环形缓冲区中的数据长度</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 判断文件描述符local_fd是否是管道 */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_pipe</span><span class="params">(<span class="keyword">uint32_t</span> local_fd)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">uint32_t</span> global_fd = fd_local2global(local_fd); </span><br><span class="line">   <span class="keyword">return</span> file_table[global_fd].fd_flag == PIPE_FLAG;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建管道,成功返回0,失败返回-1 */</span></span><br><span class="line"><span class="keyword">int32_t</span> sys_pipe(<span class="keyword">int32_t</span> pipefd[<span class="number">2</span>]) &#123;</span><br><span class="line">   <span class="keyword">int32_t</span> global_fd = get_free_slot_in_global();</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 申请一页内核内存做环形缓冲区 */</span></span><br><span class="line">   file_table[global_fd].fd_inode = get_kernel_pages(<span class="number">1</span>); </span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 初始化环形缓冲区 */</span></span><br><span class="line">   ioqueue_init((struct ioqueue*)file_table[global_fd].fd_inode);</span><br><span class="line">   <span class="keyword">if</span> (file_table[global_fd].fd_inode == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">/* 将fd_flag复用为管道标志 */</span></span><br><span class="line">   file_table[global_fd].fd_flag = PIPE_FLAG;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 将fd_pos复用为管道打开数 */</span></span><br><span class="line">   file_table[global_fd].fd_pos = <span class="number">2</span>;</span><br><span class="line">   pipefd[<span class="number">0</span>] = pcb_fd_install(global_fd);</span><br><span class="line">   pipefd[<span class="number">1</span>] = pcb_fd_install(global_fd);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 从管道中读数据 */</span></span><br><span class="line"><span class="keyword">uint32_t</span> pipe_read(<span class="keyword">int32_t</span> fd, <span class="keyword">void</span>* buf, <span class="keyword">uint32_t</span> count) &#123;</span><br><span class="line">   <span class="keyword">char</span>* buffer = buf;</span><br><span class="line">   <span class="keyword">uint32_t</span> bytes_read = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">uint32_t</span> global_fd = fd_local2global(fd);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 获取管道的环形缓冲区 */</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">ioqueue</span>* <span class="title">ioq</span> = (<span class="title">struct</span> <span class="title">ioqueue</span>*)<span class="title">file_table</span>[<span class="title">global_fd</span>].<span class="title">fd_inode</span>;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 选择较小的数据读取量,避免阻塞 */</span></span><br><span class="line">   <span class="keyword">uint32_t</span> ioq_len = ioq_length(ioq);</span><br><span class="line">   <span class="keyword">uint32_t</span> size = ioq_len &gt; count ? count : ioq_len;</span><br><span class="line">   <span class="keyword">while</span> (bytes_read &lt; size) &#123;</span><br><span class="line">      *buffer = ioq_getchar(ioq);</span><br><span class="line">      bytes_read++;</span><br><span class="line">      buffer++;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> bytes_read;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 往管道中写数据 */</span></span><br><span class="line"><span class="keyword">uint32_t</span> pipe_write(<span class="keyword">int32_t</span> fd, <span class="keyword">const</span> <span class="keyword">void</span>* buf, <span class="keyword">uint32_t</span> count) &#123;</span><br><span class="line">   <span class="keyword">uint32_t</span> bytes_write = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">uint32_t</span> global_fd = fd_local2global(fd);</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">ioqueue</span>* <span class="title">ioq</span> = (<span class="title">struct</span> <span class="title">ioqueue</span>*)<span class="title">file_table</span>[<span class="title">global_fd</span>].<span class="title">fd_inode</span>;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 选择较小的数据写入量,避免阻塞 */</span></span><br><span class="line">   <span class="keyword">uint32_t</span> ioq_left = bufsize - ioq_length(ioq);</span><br><span class="line">   <span class="keyword">uint32_t</span> size = ioq_left &gt; count ? count : ioq_left;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">char</span>* buffer = buf;</span><br><span class="line">   <span class="keyword">while</span> (bytes_write &lt; size) &#123;</span><br><span class="line">      ioq_putchar(ioq, *buffer);</span><br><span class="line">      bytes_write++;</span><br><span class="line">      buffer++;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> bytes_write;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先看下代码第二个函数<code>sys_pipe</code>，它接受1个参数，<strong>存储管道文件描述符的数组pipefd</strong>，功能是<strong>创建管道，成功后描述符pipefd[0] 可用于读取管道，pipefd[1] 可用于写入管道，然后返回值为0，否则返回−1</strong>。函数先调用<code>get_free_slot_in_global</code>从<code>file_table</code>中获得可用的文件结构空位下标，记为<code>global_fd</code>，然后为该文件结构中的<code>fd_inode</code>分配一页内核内存做管道的环形缓冲区。接着调用<code>ioqueue_init</code>初始化环形缓冲区。将该文件结构的<code>fd_flag</code>置为宏<code>PIPE_FLAG</code>，宏<code>PIPE_FLAG</code>定义在<code>pipe.h</code>中，代码是<code>#define PIPE_FLAG 0xFFFF</code>，正如我们在设计阶段所说的，复用了文件结构中的<code>fd_flag</code>成员，把该值置为<code>0xFFFF</code>来表示此文件结构对应的是管道。把<code>fd_pos</code>置为2，表示<strong>有两个文件描述符对应这个管道</strong>，描述符分别存储到<code>pipefd[0]</code>和<code>pipefd[1]</code>中，我们分别用它们来读取和写入管道。</p>
<p>函数<code>is_pipe</code>接受1 个参数，<strong>文件描述符<code>local_fd</code></strong>，功能是<strong>判断文件描述符<code>local_fd</code>是否是管道</strong>。判断的原理是<strong>先找出<code>local_fd</code>对应的<code>file_table</code>中的下标<code>global_fd</code>，然后判断文件表<code>file_talbe[global_fd]</code>的<code>fd_flag</code>的值是否为<code>PIPE_FLAG</code></strong>。函数<code>pipe_read</code>接受3 个参数，文件描述符fd、存储数据的缓冲区buf、读取数据的数量count，功能是<strong>从文件描述符fd 中读取count 字节到buf</strong>。函数<code>pipe_write</code>功能是<strong>把缓冲区buf 中的count 个字节写入管道对应的文件描述符fd</strong>。</p>
<h2 id="在shell-中支持管道"><a href="#在shell-中支持管道" class="headerlink" title="在shell 中支持管道"></a>在shell 中支持管道</h2><p>管道利用了输入输出重定向。如果命令的输入并不来自于键盘，而是来自于文件，这就称为<strong>输入重定向</strong>，如果命令的输出并不是屏幕，而是想写入到文件，这就称为<strong>输出重定向</strong>。利用输入输出重定向的原理，可以将一个命令的输出作为另一个命令的输入。因此命令行中若包括管道符，则将管道符左边<br>命令的输出作为管道符右边命令的输入。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 将文件描述符old_local_fd重定向为new_local_fd */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_fd_redirect</span><span class="params">(<span class="keyword">uint32_t</span> old_local_fd, <span class="keyword">uint32_t</span> new_local_fd)</span> </span>&#123;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>* <span class="title">cur</span> = <span class="title">running_thread</span>();</span></span><br><span class="line">   <span class="comment">/* 针对恢复标准描述符 */</span></span><br><span class="line">   <span class="keyword">if</span> (new_local_fd &lt; <span class="number">3</span>) &#123;</span><br><span class="line">      cur-&gt;fd_table[old_local_fd] = new_local_fd;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">uint32_t</span> new_global_fd = cur-&gt;fd_table[new_local_fd];</span><br><span class="line">      cur-&gt;fd_table[old_local_fd] = new_global_fd;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>函数<code>sys_fd_redirect</code>接受2 个参数，<strong>旧文件描述符<code>old_local_fd</code>、新文件描述符<code>new_local_fd</code></strong>，功能是**将文件描述符<code>old_local_fd</code>重定向为<code>new_local_fd</code>。将数组<code>fd_table</code>中下标为<code>old_local_fd</code>的元素的值用下标为<code>new_local_fd</code>的元素的值替换。另外，pcb 中文件描述符表<code>fd_table</code>和全局文件表<code>file_table</code>中的前3 个元素都是预留的，它们分别作为标准输入、标准输出和标准错误，因此，如果<code>new_local_fd</code>小于3 的话，不需要从<code>fd_table</code>中获取元素值，可以直接把<code>new_local_fd</code>赋值给<code>fd_table[old_local_fd]</code>，而这通常用于将输入输出恢复为标准的输入输出。获取了当前线程cur，对标准输入输出做了特殊处理，如果<code>new_local_fd</code>小于3，直接将<code>new_local_fd</code>给<code>cur-&gt;fd_table[old_local_fd]</code>赋值，否则先获得<code>new_local_fd</code>对应的<code>file_table</code>下标<code>new_global_fd</code>，然后将<code>new_global_fd</code>赋值给<code>cur-&gt;fd_table[old_local_fd]</code>，至此完成了重定向。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 执行命令 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cmd_execute</span><span class="params">(<span class="keyword">uint32_t</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(<span class="string">"ls"</span>, argv[<span class="number">0</span>])) &#123;</span><br><span class="line">      buildin_ls(argc, argv);</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(<span class="string">"cd"</span>, argv[<span class="number">0</span>])) &#123;</span><br><span class="line">      <span class="keyword">if</span> (buildin_cd(argc, argv) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">	 <span class="built_in">memset</span>(cwd_cache, <span class="number">0</span>, MAX_PATH_LEN);</span><br><span class="line">	 <span class="built_in">strcpy</span>(cwd_cache, final_path);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(<span class="string">"pwd"</span>, argv[<span class="number">0</span>])) &#123;</span><br><span class="line">      buildin_pwd(argc, argv);</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(<span class="string">"ps"</span>, argv[<span class="number">0</span>])) &#123;</span><br><span class="line">      buildin_ps(argc, argv);</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(<span class="string">"clear"</span>, argv[<span class="number">0</span>])) &#123;</span><br><span class="line">      buildin_clear(argc, argv);</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(<span class="string">"mkdir"</span>, argv[<span class="number">0</span>]))&#123;</span><br><span class="line">      buildin_mkdir(argc, argv);</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(<span class="string">"rmdir"</span>, argv[<span class="number">0</span>]))&#123;</span><br><span class="line">      buildin_rmdir(argc, argv);</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(<span class="string">"rm"</span>, argv[<span class="number">0</span>])) &#123;</span><br><span class="line">      buildin_rm(argc, argv);</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(<span class="string">"help"</span>, argv[<span class="number">0</span>])) &#123;</span><br><span class="line">      buildin_help(argc, argv);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;      <span class="comment">// 如果是外部命令,需要从磁盘上加载</span></span><br><span class="line">      <span class="keyword">int32_t</span> pid = fork();</span><br><span class="line">      <span class="keyword">if</span> (pid) &#123;	   <span class="comment">// 父进程</span></span><br><span class="line">	 <span class="keyword">int32_t</span> status;</span><br><span class="line">	 <span class="keyword">int32_t</span> child_pid = wait(&amp;status);          <span class="comment">// 此时子进程若没有执行exit,my_shell会被阻塞,不再响应键入的命令</span></span><br><span class="line">	 <span class="keyword">if</span> (child_pid == <span class="number">-1</span>) &#123;     <span class="comment">// 按理说程序正确的话不会执行到这句,fork出的进程便是shell子进程</span></span><br><span class="line">	    panic(<span class="string">"my_shell: no child\n"</span>);</span><br><span class="line">	 &#125;</span><br><span class="line">	 <span class="built_in">printf</span>(<span class="string">"child_pid %d, it's status: %d\n"</span>, child_pid, status);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;	   <span class="comment">// 子进程</span></span><br><span class="line">	 make_clear_abs_path(argv[<span class="number">0</span>], final_path);</span><br><span class="line">	 argv[<span class="number">0</span>] = final_path;</span><br><span class="line"></span><br><span class="line">	 <span class="comment">/* 先判断下文件是否存在 */</span></span><br><span class="line">	 <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">file_stat</span>;</span></span><br><span class="line">	 <span class="built_in">memset</span>(&amp;file_stat, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct stat));</span><br><span class="line">	 <span class="keyword">if</span> (stat(argv[<span class="number">0</span>], &amp;file_stat) == <span class="number">-1</span>) &#123;</span><br><span class="line">	    <span class="built_in">printf</span>(<span class="string">"my_shell: cannot access %s: No such file or directory\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">	    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	 &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	    execv(argv[<span class="number">0</span>], argv);</span><br><span class="line">	 &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>* argv[MAX_ARG_NR] = &#123;<span class="literal">NULL</span>&#125;;</span><br><span class="line"><span class="keyword">int32_t</span> argc = <span class="number">-1</span>;</span><br><span class="line"><span class="comment">/* 简单的shell */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_shell</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">   cwd_cache[<span class="number">0</span>] = <span class="string">'/'</span>;</span><br><span class="line">   <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">      print_prompt(); </span><br><span class="line">      <span class="built_in">memset</span>(final_path, <span class="number">0</span>, MAX_PATH_LEN);</span><br><span class="line">      <span class="built_in">memset</span>(cmd_line, <span class="number">0</span>, MAX_PATH_LEN);</span><br><span class="line">      readline(cmd_line, MAX_PATH_LEN);</span><br><span class="line">      <span class="keyword">if</span> (cmd_line[<span class="number">0</span>] == <span class="number">0</span>) &#123;	 <span class="comment">// 若只键入了一个回车</span></span><br><span class="line">	 <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 针对管道的处理 */</span></span><br><span class="line">      <span class="keyword">char</span>* pipe_symbol = <span class="built_in">strchr</span>(cmd_line, <span class="string">'|'</span>);</span><br><span class="line">      <span class="keyword">if</span> (pipe_symbol) &#123;</span><br><span class="line">   <span class="comment">/* 支持多重管道操作,如cmd1|cmd2|..|cmdn,</span></span><br><span class="line"><span class="comment">    * cmd1的标准输出和cmdn的标准输入需要单独处理 */</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/*1 生成管道*/</span></span><br><span class="line">	 <span class="keyword">int32_t</span> fd[<span class="number">2</span>] = &#123;<span class="number">-1</span>&#125;;	    <span class="comment">// fd[0]用于输入,fd[1]用于输出</span></span><br><span class="line">	 pipe(fd);</span><br><span class="line">	 <span class="comment">/* 将标准输出重定向到fd[1],使后面的输出信息重定向到内核环形缓冲区 */</span></span><br><span class="line">	 fd_redirect(<span class="number">1</span>,fd[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/*2 第一个命令 */</span></span><br><span class="line">	 <span class="keyword">char</span>* each_cmd = cmd_line;</span><br><span class="line">	 pipe_symbol = <span class="built_in">strchr</span>(each_cmd, <span class="string">'|'</span>);</span><br><span class="line">	 *pipe_symbol = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	 <span class="comment">/* 执行第一个命令,命令的输出会写入环形缓冲区 */</span></span><br><span class="line">	 argc = <span class="number">-1</span>;</span><br><span class="line">	 argc = cmd_parse(each_cmd, argv, <span class="string">' '</span>);</span><br><span class="line">	 cmd_execute(argc, argv);</span><br><span class="line"></span><br><span class="line">	 <span class="comment">/* 跨过'|',处理下一个命令 */</span></span><br><span class="line">	 each_cmd = pipe_symbol + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	 <span class="comment">/* 将标准输入重定向到fd[0],使之指向内核环形缓冲区*/</span></span><br><span class="line">	 fd_redirect(<span class="number">0</span>,fd[<span class="number">0</span>]);</span><br><span class="line">   <span class="comment">/*3 中间的命令,命令的输入和输出都是指向环形缓冲区 */</span></span><br><span class="line">	 <span class="keyword">while</span> ((pipe_symbol = <span class="built_in">strchr</span>(each_cmd, <span class="string">'|'</span>))) &#123; </span><br><span class="line">	    *pipe_symbol = <span class="number">0</span>;</span><br><span class="line">	    argc = <span class="number">-1</span>;</span><br><span class="line">	    argc = cmd_parse(each_cmd, argv, <span class="string">' '</span>);</span><br><span class="line">	    cmd_execute(argc, argv);</span><br><span class="line">	    each_cmd = pipe_symbol + <span class="number">1</span>;</span><br><span class="line">	 &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/*4 处理管道中最后一个命令 */</span></span><br><span class="line">	 <span class="comment">/* 将标准输出恢复屏幕 */</span></span><br><span class="line">         fd_redirect(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	 <span class="comment">/* 执行最后一个命令 */</span></span><br><span class="line">	 argc = <span class="number">-1</span>;</span><br><span class="line">	 argc = cmd_parse(each_cmd, argv, <span class="string">' '</span>);</span><br><span class="line">	 cmd_execute(argc, argv);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/*5  将标准输入恢复为键盘 */</span></span><br><span class="line">         fd_redirect(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/*6 关闭管道 */</span></span><br><span class="line">	 close(fd[<span class="number">0</span>]);</span><br><span class="line">	 close(fd[<span class="number">1</span>]);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;		<span class="comment">// 一般无管道操作的命令</span></span><br><span class="line">	 argc = <span class="number">-1</span>;</span><br><span class="line">	 argc = cmd_parse(cmd_line, argv, <span class="string">' '</span>);</span><br><span class="line">	 <span class="keyword">if</span> (argc == <span class="number">-1</span>) &#123;</span><br><span class="line">	    <span class="built_in">printf</span>(<span class="string">"num of arguments exceed %d\n"</span>, MAX_ARG_NR);</span><br><span class="line">	    <span class="keyword">continue</span>;</span><br><span class="line">	 &#125;</span><br><span class="line">	 cmd_execute(argc, argv);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   panic(<span class="string">"my_shell: should not be here"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把<code>shell.c</code>中原本判断内建、外部命令的一堆if else 封装到函数<code>cmd_execute</code>中。通过<code>strchr</code>函数在<code>cmd_line</code>中寻找管道字符’|’，如果找到，<code>pipe_symbol</code>的值则为字符’|’的地址。</p>
<p>除cmd1 的标准输入和cmdn 的标准输出不变外，其他命令的标准输入和输出都要重定向到管道。下面分六步来完成管道操作。</p>
<ul>
<li>第一步，生成管道，这是调用<code>pipe</code>系统调用完成的。调用<code>fd_redirect(1,fd[1])</code>将标准输出重定向到用于写管道的文件描述符<code>fd[1]</code>，至此程序的输出都写到管道中。</li>
<li>第二步，解析第1 个命令并执行。命令行中的各个命令是用指针<code>each_cmd</code>记录的，它指向各命令在<code>cmd_line</code>中的地址。解析出命令后调用<code>cmd_execute</code>执行，然后使<code>pipe_symbol</code>加1，跨过cmd_line 中的相应的’|’。在执行第2个命令之前，执行<code>fd_redirect(0,fd[0])</code>将标准输入重定向到管道，这样第2 个命令才能获得第1 个命令的输出。</li>
<li>第三步，循环处理cmd2~cmdn-1，此时它们的标准输入和输出都已指向管道，继续解析命令并执行。</li>
<li>第四步，调用<code>fd_redirect(1,1)</code>将标准输出恢复为屏幕，然后执行最后一个命令，此时命令的输出信息会在屏幕上显示。</li>
<li>第五步，调用<code>fd_redirect(0,0)</code>将标准输入恢复为键盘。</li>
<li>第六步，将管道关闭。</li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/操作系统/" rel="tag"># 操作系统</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/08/06/Linux select poll机制原理分析/" rel="next" title="Linux selectpoll机制原理分析">
                <i class="fa fa-chevron-left"></i> Linux selectpoll机制原理分析
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/08/12/Leetcode301_350/" rel="prev" title="Leetcode301 - 350">
                Leetcode301 - 350 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/header.jpg" alt="Hao Yu">
            
              <p class="site-author-name" itemprop="name">Hao Yu</p>
              <p class="site-description motion-element" itemprop="description">Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author</p>
          </div>
          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">338</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>
        	<audio controls="controls" loop="loop" preload="auto" src="/resource/xiaomeihao.mp3">
	        </audio>
	

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yuhao0102" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:yuh18@mails.tsinghua.edu.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#文件系统"><span class="nav-number">1.</span> <span class="nav-text">文件系统</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#文件系统概念简介"><span class="nav-number">1.1.</span> <span class="nav-text">文件系统概念简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#创建文件系统"><span class="nav-number">1.2.</span> <span class="nav-text">创建文件系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#创建超级块、i-结点、目录项"><span class="nav-number">1.2.1.</span> <span class="nav-text">创建超级块、i 结点、目录项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件描述符简介"><span class="nav-number">1.3.</span> <span class="nav-text">文件描述符简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件操作相关的基础函数"><span class="nav-number">1.4.</span> <span class="nav-text">文件操作相关的基础函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#inode-操作有关的函数"><span class="nav-number">1.4.1.</span> <span class="nav-text">inode 操作有关的函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#创建文件"><span class="nav-number">1.5.</span> <span class="nav-text">创建文件</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#系统交互"><span class="nav-number">2.</span> <span class="nav-text">系统交互</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#fork-的原理与实现"><span class="nav-number">2.1.</span> <span class="nav-text">fork 的原理与实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#添加fork-系统调用与实现init-进程"><span class="nav-number">2.1.1.</span> <span class="nav-text">添加fork 系统调用与实现init 进程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#添加-read-系统调用，获取键盘输入"><span class="nav-number">2.2.</span> <span class="nav-text">添加 read 系统调用，获取键盘输入</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#添加-putchar、clear-系统调用"><span class="nav-number">2.3.</span> <span class="nav-text">添加 putchar、clear 系统调用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实现一个简单的-shell"><span class="nav-number">2.4.</span> <span class="nav-text">实现一个简单的 shell</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#解析键入的字符"><span class="nav-number">2.4.1.</span> <span class="nav-text">解析键入的字符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#添加系统调用"><span class="nav-number">2.4.2.</span> <span class="nav-text">添加系统调用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#加载用户进程"><span class="nav-number">2.5.</span> <span class="nav-text">加载用户进程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用户进程支持参数"><span class="nav-number">2.5.1.</span> <span class="nav-text">使用户进程支持参数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#系统调用-wait-和exit"><span class="nav-number">2.6.</span> <span class="nav-text">系统调用 wait 和exit</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#管道"><span class="nav-number">2.7.</span> <span class="nav-text">管道</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#管道的设计"><span class="nav-number">2.7.1.</span> <span class="nav-text">管道的设计</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#在shell-中支持管道"><span class="nav-number">2.8.</span> <span class="nav-text">在shell 中支持管道</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>
  <div id="DvelopmentTarget">     
  </div>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart" aria-hidden="false"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>

  
</div>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_uv"> 
  本站访客数<span id="busuanzi_value_site_uv"></span>人次
</span>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  


  <script type="text/javascript" src="/js/src/love.js"></script>

</body>
</html>
