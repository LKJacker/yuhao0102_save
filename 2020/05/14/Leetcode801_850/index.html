<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zn-ch">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-center-simple.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Leetcode,">










<meta name="description" content="Leetcode802. Find Eventual Safe StatesWe start at some node in a directed graph, and every turn, we walk along a directed edge of the graph. If we reach a terminal node (that is, it has no outgoing di">
<meta name="keywords" content="Leetcode">
<meta property="og:type" content="article">
<meta property="og:title" content="Leetcode801 - 850">
<meta property="og:url" content="http://yoursite.com/2020/05/14/Leetcode801_850/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="Leetcode802. Find Eventual Safe StatesWe start at some node in a directed graph, and every turn, we walk along a directed edge of the graph. If we reach a terminal node (that is, it has no outgoing di">
<meta property="og:locale" content="zn-ch">
<meta property="og:image" content="http://yoursite.com/img/20210904105200.png">
<meta property="og:image" content="http://yoursite.com/img/1028_2.png">
<meta property="og:image" content="http://yoursite.com/img/1028_1.png">
<meta property="og:image" content="http://yoursite.com/img/1028.png">
<meta property="og:image" content="http://yoursite.com/img/1631001223.jpg">
<meta property="og:updated_time" content="2021-09-17T11:01:18.009Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Leetcode801 - 850">
<meta name="twitter:description" content="Leetcode802. Find Eventual Safe StatesWe start at some node in a directed graph, and every turn, we walk along a directed edge of the graph. If we reach a terminal node (that is, it has no outgoing di">
<meta name="twitter:image" content="http://yoursite.com/img/20210904105200.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/05/14/Leetcode801_850/">





  <title>Leetcode801 - 850 | Hao Yu's blog</title>
  








 
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zn-ch">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hao Yu's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">The program monkey was eaten by the siege lion.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/resume.pdf" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-mybetterhalf">
          <a href="/mybetterhalf/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>
            
            mybetterhalf
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/14/Leetcode801_850/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Leetcode801 - 850</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-14T00:41:00+08:00">
                2020-05-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Leetcode802-Find-Eventual-Safe-States"><a href="#Leetcode802-Find-Eventual-Safe-States" class="headerlink" title="Leetcode802. Find Eventual Safe States"></a>Leetcode802. Find Eventual Safe States</h1><p>We start at some node in a directed graph, and every turn, we walk along a directed edge of the graph. If we reach a terminal node (that is, it has no outgoing directed edges), we stop.</p>
<p>We define a starting node to be safe if we must eventually walk to a terminal node. More specifically, there is a natural number k, so that we must have stopped at a terminal node in less than k steps for any choice of where to walk.</p>
<p>Return an array containing all the safe nodes of the graph. The answer should be sorted in ascending order.</p>
<p>The directed graph has n nodes with labels from 0 to n - 1, where n is the length of graph. The graph is given in the following form: graph[i] is a list of labels j such that (i, j) is a directed edge of the graph, going from node i to node j.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Illustration of graph</span><br><span class="line">Input: graph = [[1,2],[2,3],[5],[0],[5],[],[]]</span><br><span class="line">Output: [2,4,5,6]</span><br><span class="line">Explanation: The given graph is shown above.</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/20210904105200.png" alt></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: graph = [[1,2,3,4],[1,2],[3,4],[0,4],[]]</span><br><span class="line">Output: [4]</span><br></pre></td></tr></table></figure></p>
<p>深度优先搜索。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>: <span class="comment">// -1: unknow, 1: safe, 2: visiting, 3: unsafe</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; eventualSafeNodes(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = graph.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; safe(size, <span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (helper(graph, safe, i) == <span class="number">1</span>)</span><br><span class="line">                res.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; safe, <span class="keyword">int</span> cur)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (safe[cur] == <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> safe[cur] = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span> (safe[cur] != <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> safe[cur];</span><br><span class="line">        safe[cur] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph[cur].size(); i ++)</span><br><span class="line">            <span class="keyword">if</span> (helper(graph, safe, graph[cur][i]) == <span class="number">3</span>)</span><br><span class="line">                <span class="keyword">return</span> safe[cur] = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">return</span> safe[cur] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode804-Unique-Morse-Code-Words"><a href="#Leetcode804-Unique-Morse-Code-Words" class="headerlink" title="Leetcode804. Unique Morse Code Words"></a>Leetcode804. Unique Morse Code Words</h1><p>International Morse Code defines a standard encoding where each letter is mapped to a series of dots and dashes, as follows: “a” maps to “.-“, “b” maps to “-…”, “c” maps to “-.-.”, and so on.</p>
<p>For convenience, the full table for the 26 letters of the English alphabet is given below:</p>
<p>[“.-“,”-…”,”-.-.”,”-..”,”.”,”..-.”,”–.”,”….”,”..”,”.—“,”-.-“,”.-..”,”–”,”-.”,”—“,”.–.”,”–.-“,”.-.”,”…”,”-“,”..-“,”…-“,”.–”,”-..-“,”-.–”,”–..”]<br>Now, given a list of words, each word can be written as a concatenation of the Morse code of each letter. For example, “cba” can be written as “-.-..–…”, (which is the concatenation “-.-.” + “-…” + “.-“). We’ll call such a concatenation, the transformation of a word.</p>
<p>Return the number of different transformations among all words we have.</p>
<p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: words = [&quot;gin&quot;, &quot;zen&quot;, &quot;gig&quot;, &quot;msg&quot;]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: </span><br><span class="line">The transformation of each word is:</span><br><span class="line">&quot;gin&quot; -&gt; &quot;--...-.&quot;</span><br><span class="line">&quot;zen&quot; -&gt; &quot;--...-.&quot;</span><br><span class="line">&quot;gig&quot; -&gt; &quot;--...--.&quot;</span><br><span class="line">&quot;msg&quot; -&gt; &quot;--...--.&quot;</span><br></pre></td></tr></table></figure></p>
<p>There are 2 different transformations, “–…-.” and “–…–.”.<br>Note:</p>
<ul>
<li>The length of words will be at most 100.</li>
<li>Each words[i] will have length in range [1, 12].</li>
<li>words[i] will only consist of lowercase letters.</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniqueMorseRepresentations</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> <span class="built_in">map</span>[<span class="number">26</span>] = &#123;<span class="string">".-"</span>,<span class="string">"-..."</span>,<span class="string">"-.-."</span>,<span class="string">"-.."</span>,<span class="string">"."</span>,<span class="string">"..-."</span>,<span class="string">"--."</span>,<span class="string">"...."</span>,<span class="string">".."</span>,<span class="string">".---"</span>,<span class="string">"-.-"</span>,<span class="string">".-.."</span>,<span class="string">"--"</span>,<span class="string">"-."</span>,<span class="string">"---"</span>,<span class="string">".--."</span>,<span class="string">"--.-"</span>,<span class="string">".-."</span>,<span class="string">"..."</span>,<span class="string">"-"</span>,<span class="string">"..-"</span>,<span class="string">"...-"</span>,<span class="string">".--"</span>,<span class="string">"-..-"</span>,<span class="string">"-.--"</span>,<span class="string">"--.."</span>&#125;;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; result;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.size(); i ++) &#123;</span><br><span class="line">            <span class="built_in">string</span> temp = <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; words[i].length(); j ++)</span><br><span class="line">                temp += <span class="built_in">map</span>[words[i][j] - <span class="string">'a'</span>];</span><br><span class="line">            result.insert(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>借助set和数组辅助，遍历保存结果，最后统计哈希表的大小</p>
<h1 id="Leetcode806-Number-of-Lines-To-Write-String"><a href="#Leetcode806-Number-of-Lines-To-Write-String" class="headerlink" title="Leetcode806. Number of Lines To Write String"></a>Leetcode806. Number of Lines To Write String</h1><p>We are to write the letters of a given string S, from left to right into lines. Each line has maximum width 100 units, and if writing a letter would cause the width of the line to exceed 100 units, it is written on the next line. We are given an array widths, an array where widths[0] is the width of ‘a’, widths[1] is the width of ‘b’, …, and widths[25] is the width of ‘z’.</p>
<p>Now answer two questions: how many lines have at least one character from S, and what is the width used by the last such line? Return your answer as an integer list of length 2.</p>
<p>Example :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">widths = [10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10]</span><br><span class="line">S = &quot;abcdefghijklmnopqrstuvwxyz&quot;</span><br><span class="line">Output: [3, 60]</span><br><span class="line">Explanation: </span><br><span class="line">All letters have the same length of 10. To write all 26 letters,</span><br><span class="line">we need two full lines and one line with 60 units.</span><br></pre></td></tr></table></figure></p>
<p>Example :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">widths = [4,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10]</span><br><span class="line">S = &quot;bbbcccdddaaa&quot;</span><br><span class="line">Output: [2, 4]</span><br><span class="line">Explanation: </span><br><span class="line">All letters except &apos;a&apos; have the same length of 10, and </span><br><span class="line">&quot;bbbcccdddaa&quot; will cover 9 * 10 + 2 * 4 = 98 units.</span><br><span class="line">For the last &apos;a&apos;, it is written on the second line because</span><br><span class="line">there is only 2 units left in the first line.</span><br><span class="line">So the answer is 2 lines, plus 4 units in the second line.</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>The length of S will be in the range [1, 1000].</li>
<li>S will only contain lowercase letters.</li>
<li>widths is an array of length 26.</li>
<li>widths[i] will be in the range of [2, 10].</li>
</ul>
<p>好坑啊，一个字母还不能拆开放。。。。现在的行长度是cur，如果cur加上当前的字母长度超过100了，则从下一行开始，cur变为当前的字母长度。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numberOfLines(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; widths, <span class="built_in">string</span> S) &#123;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> cur=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;S.length();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> width = widths[S[i]-<span class="string">'a'</span>];</span><br><span class="line">            res = cur + width &gt; <span class="number">100</span> ? res+<span class="number">1</span> : res; </span><br><span class="line">            cur = cur + width &gt; <span class="number">100</span> ? width : cur+width;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;res,cur&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode807-Max-Increase-to-Keep-City-Skyline"><a href="#Leetcode807-Max-Increase-to-Keep-City-Skyline" class="headerlink" title="Leetcode807. Max Increase to Keep City Skyline"></a>Leetcode807. Max Increase to Keep City Skyline</h1><p>In a 2 dimensional array grid, each value grid[i][j] represents the height of a building located there. We are allowed to increase the height of any number of buildings, by any amount (the amounts can be different for different buildings). Height 0 is considered to be a building as well. </p>
<p>At the end, the “skyline” when viewed from all four directions of the grid, i.e. top, bottom, left, and right, must be the same as the skyline of the original grid. A city’s skyline is the outer contour of the rectangles formed by all the buildings when viewed from a distance. See the following example.</p>
<p>What is the maximum total sum that the height of the buildings can be increased?</p>
<p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Input: grid = [[3,0,8,4],[2,4,5,7],[9,2,6,3],[0,3,1,0]]</span><br><span class="line">Output: 35</span><br><span class="line">Explanation: </span><br><span class="line">The grid is:</span><br><span class="line">[ [3, 0, 8, 4], </span><br><span class="line">  [2, 4, 5, 7],</span><br><span class="line">  [9, 2, 6, 3],</span><br><span class="line">  [0, 3, 1, 0] ]</span><br><span class="line"></span><br><span class="line">The skyline viewed from top or bottom is: [9, 4, 8, 7]</span><br><span class="line">The skyline viewed from left or right is: [8, 7, 9, 3]</span><br><span class="line"></span><br><span class="line">The grid after increasing the height of buildings without affecting skylines is:</span><br><span class="line"></span><br><span class="line">gridNew = [ [8, 4, 8, 7],</span><br><span class="line">            [7, 4, 7, 7],</span><br><span class="line">            [9, 4, 8, 7],</span><br><span class="line">            [3, 3, 3, 3] ]</span><br></pre></td></tr></table></figure></p>
<p>Notes:</p>
<ol>
<li>1 &lt; grid.length = grid[0].length &lt;= 50.</li>
<li>All heights grid[i][j] are in the range [0, 100].</li>
<li>All buildings in grid[i][j] occupy the entire grid cell: that is, they are a 1 x 1 x grid[i][j] rectangular prism.</li>
</ol>
<p>这道题非常简单，首先找到每行每列的最大值，然后每个元素要小于对应的最大值中的小者，比如grid[0][0]要小于topmax[0]和leftmax[0]之中的最小值，grid[0][1]要小于topmax[0]和leftmax[1]之中的最小值。为什么花了这么长时间呢，是因为傻逼了，max数组设成了4爆了。。。煞笔。。。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxIncreaseKeepingSkyline</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span>* topmax,*leftmax;</span><br><span class="line">        topmax = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*length);</span><br><span class="line">        leftmax = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*length);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i ++)</span><br><span class="line">            topmax[i] = leftmax[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i ++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; length; j ++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] &gt; topmax[i])</span><br><span class="line">                    topmax[i] = grid[i][j];</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] &gt; leftmax[j])</span><br><span class="line">                    leftmax[j] = grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i ++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; length; j ++)</span><br><span class="line">                result += ((leftmax[j] &gt; topmax[i] ? topmax[i] : leftmax[j]) - grid[i][j]);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode808-Soup-Servings"><a href="#Leetcode808-Soup-Servings" class="headerlink" title="Leetcode808. Soup Servings"></a>Leetcode808. Soup Servings</h1><p>There are two types of soup: type A and type B. Initially we have N ml of each type of soup. There are four kinds of operations:</p>
<ul>
<li>Serve 100 ml of soup A and 0 ml of soup B</li>
<li>Serve 75 ml of soup A and 25 ml of soup B</li>
<li>Serve 50 ml of soup A and 50 ml of soup B</li>
<li>Serve 25 ml of soup A and 75 ml of soup B</li>
</ul>
<p>When we serve some soup, we give it to someone and we no longer have it.  Each turn, we will choose from the four operations with equal probability 0.25. If the remaining volume of soup is not enough to complete the operation, we will serve as much as we can.  We stop once we no longer have some quantity of both types of soup.</p>
<p>Note that we do not have the operation where all 100 ml’s of soup B are used first.  </p>
<p>Return the probability that soup A will be empty first, plus half the probability that A and B become empty at the same time.</p>
<p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: N = 50</span><br><span class="line">Output: 0.625</span><br><span class="line">Explanation: </span><br><span class="line">If we choose the first two operations, A will become empty first. For the third operation, A and B will become empty at the same time. For the fourth operation, B will become empty first. So the total probability of A becoming empty first plus half the probability that A and B become empty at the same time, is 0.25 * (1 + 1 + 0.5 + 0) = 0.625.</span><br></pre></td></tr></table></figure></p>
<p>Notes:</p>
<ul>
<li>0 &lt;= N &lt;= 10^9. </li>
<li>Answers within 10^-6 of the true value will be accepted as correct.</li>
</ul>
<p>自己当初写的代码的思路是对的，但是细节实现上没考虑周全。这里还是参考了网上代码的总结：</p>
<p>我们在这里采用的方法严格来讲是DFS + memorization，也就是需要计算一个子问题的时候，我们首先在表格中查找，看看原来有没有被计算过，如果被计算过，则直接返回结果，否则就再重新计算，并将结果保存在表格中。这样的好处是没必要计算每个子问题，只计算递归过程中用到的子问题。如果我们定义f(a, b)表示有a毫升的A和b毫升的B时符合条件的概率，那么容易知道递推公式就是：<code>f(a, b) = 0.25 * (f(a - 4, b) + f(a - 3, b - 1) + f(a - 2, b - 2) + f(a - 1, b - 3))</code>，其中平凡条件是：</p>
<p>当a &lt; 0 &amp;&amp; b &lt; 0时，f(a, b) = 0.5，表示A和B同时用完；</p>
<p>当a &lt;= 0 &amp;&amp; b &gt; 0时，f(a, b) = 1.0，表示A先用完；</p>
<p>当a &gt; 0 &amp;&amp; b&lt;= 0时，f(a, b) = 0.0，表示B先用完。</p>
<p>所以当遇到这三种情况的时候，我们直接返回对应的平凡值；否则就首先查表，看看原来有没有计算过，如果已经计算过了，就直接返回；否则才开始按照递推公式计算。</p>
<p>1）如果A或者B不足25ml，但是又大于0ml，那么我们需要把它当做完整的25ml来对待。另外，由于A和B serve的最小单位是25ml，所以我们在f(a, b)中约定a和b是25ml的倍数，具体在实现中，我们需要首先对n做<code>n = ceil(N / 25.0)</code>的处理。</p>
<p>2）题目中给出N的范围是[0, 10^9]，这是一个特别大的数字了。另外又提到当我们返回的结果与真实误差小于10^6的时候，就算正确。直觉告诉我们，当N趋向于无穷大时，A先被serve完以及A和B同时被serve完的概率会无限接近于1。经过严格计算我们知道当N &gt;= 4800之后，返回的概率值与1的差距就小于10^6了。所以当N &gt;= 4800的时候，我们就直接返回1。如果不这样做的话，就会导致memo需要开辟的内容特别大，引起MLE。</p>
<p>代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">soupServings</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="built_in">ceil</span>(N / <span class="number">25.0</span>);</span><br><span class="line">        <span class="keyword">return</span> N &gt;= <span class="number">4800</span> ?  <span class="number">1.0</span> : f(n, n);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a &lt;= <span class="number">0</span> &amp;&amp; b &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0.5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (b &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (memo[a][b] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> memo[a][b];</span><br><span class="line">        &#125;</span><br><span class="line">        memo[a][b] = <span class="number">0.25</span> * (f(a - <span class="number">4</span>, b) + f(a - <span class="number">3</span>, b - <span class="number">1</span>) + f(a - <span class="number">2</span>, b - <span class="number">2</span>) + f(a - <span class="number">1</span>, b - <span class="number">3</span>));</span><br><span class="line">        <span class="keyword">return</span> memo[a][b];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> memo[<span class="number">200</span>][<span class="number">200</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode809-Expressive-Words"><a href="#Leetcode809-Expressive-Words" class="headerlink" title="Leetcode809. Expressive Words"></a>Leetcode809. Expressive Words</h1><p>Sometimes people repeat letters to represent extra feeling. For example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;hello&quot; -&gt; &quot;heeellooo&quot;</span><br><span class="line">&quot;hi&quot; -&gt; &quot;hiiii&quot;</span><br></pre></td></tr></table></figure></p>
<p>In these strings like “heeellooo”, we have groups of adjacent letters that are all the same: “h”, “eee”, “ll”, “ooo”.</p>
<p>You are given a string s and an array of query strings words. A query word is stretchy if it can be made to be equal to s by any number of applications of the following extension operation: choose a group consisting of characters c, and add some number of characters c to the group so that the size of the group is three or more.</p>
<p>For example, starting with “hello”, we could do an extension on the group “o” to get “hellooo”, but we cannot get “helloo” since the group “oo” has a size less than three. Also, we could do another extension like “ll” -&gt; “lllll” to get “helllllooo”. If s = “helllllooo”, then the query word “hello” would be stretchy because of these two extension operations: query = “hello” -&gt; “hellooo” -&gt; “helllllooo” = s.<br>Return the number of query strings that are stretchy.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;heeellooo&quot;, words = [&quot;hello&quot;, &quot;hi&quot;, &quot;helo&quot;]</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: </span><br><span class="line">We can extend &quot;e&quot; and &quot;o&quot; in the word &quot;hello&quot; to get &quot;heeellooo&quot;.</span><br><span class="line">We can&apos;t extend &quot;helo&quot; to get &quot;heeellooo&quot; because the group &quot;ll&quot; is not size 3 or more.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;zzzzzyyyyy&quot;, words = [&quot;zzyy&quot;,&quot;zy&quot;,&quot;zyy&quot;]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure></p>
<p>依次按顺序统计s与各个单词的字母个数，如果相同顺序（连续相等字母算顺序中的一位）的字母不相等，则不符合条件，如果s的字母个数小于3且s与单词的字母个数不等，不符合条件，如果s的字母个数大于等于3且小于单词的字母个数，不符合条件，执行到某个字符串结束，如果没都达到最后，则不符合条件，否则满足条件。Version 2只统计s一次，然后再比对。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">expressiveWords</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> legal = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">string</span> word : words) &#123;</span><br><span class="line">            <span class="keyword">int</span> len2 = word.length();</span><br><span class="line">            legal = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (len &lt; len2)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> p1 = <span class="number">0</span>, p2 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (p1 &lt; len &amp;&amp; p2 &lt; len2) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[p1] == word[p2]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> t1 = <span class="number">1</span>, t2 = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">while</span> (p1 &lt; len<span class="number">-1</span> &amp;&amp; s[p1] == s[p1+<span class="number">1</span>]) &#123;</span><br><span class="line">                        t1 ++; p1 ++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">while</span> (p2 &lt; len2<span class="number">-1</span> &amp;&amp; word[p2] == word[p2+<span class="number">1</span>]) &#123;</span><br><span class="line">                        t2 ++; p2 ++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (t1 == <span class="number">2</span> &amp;&amp; t1 - t2 == <span class="number">1</span>)</span><br><span class="line">                        legal = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> ((t1 &lt; <span class="number">3</span> &amp;&amp; t1 != t2) || t1 &lt; t2)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p1 ++;</span><br><span class="line">                p2 ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (p1 == len &amp;&amp; p2 == word.size() &amp;&amp; legal)</span><br><span class="line">                res ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode811-Subdomain-Visit-Count"><a href="#Leetcode811-Subdomain-Visit-Count" class="headerlink" title="Leetcode811. Subdomain Visit Count"></a>Leetcode811. Subdomain Visit Count</h1><p>A website domain like “discuss.leetcode.com” consists of various subdomains. At the top level, we have “com”, at the next level, we have “leetcode.com”, and at the lowest level, “discuss.leetcode.com”. When we visit a domain like “discuss.leetcode.com”, we will also visit the parent domains “leetcode.com” and “com” implicitly.</p>
<p>Now, call a “count-paired domain” to be a count (representing the number of visits this domain received), followed by a space, followed by the address. An example of a count-paired domain might be “9001 discuss.leetcode.com”.</p>
<p>We are given a list cpdomains of count-paired domains. We would like a list of count-paired domains, (in the same format as the input, and in any order), that explicitly counts the number of visits to each subdomain.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">[&quot;9001 discuss.leetcode.com&quot;]</span><br><span class="line">Output: </span><br><span class="line">[&quot;9001 discuss.leetcode.com&quot;, &quot;9001 leetcode.com&quot;, &quot;9001 com&quot;]</span><br><span class="line">Explanation: </span><br><span class="line">We only have one website domain: &quot;discuss.leetcode.com&quot;. As discussed above, the subdomain &quot;leetcode.com&quot; and &quot;com&quot; will also be visited. So they will all be visited 9001 times.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">[&quot;900 google.mail.com&quot;, &quot;50 yahoo.com&quot;, &quot;1 intel.mail.com&quot;, &quot;5 wiki.org&quot;]</span><br><span class="line">Output: </span><br><span class="line">[&quot;901 mail.com&quot;,&quot;50 yahoo.com&quot;,&quot;900 google.mail.com&quot;,&quot;5 wiki.org&quot;,&quot;5 org&quot;,&quot;1 intel.mail.com&quot;,&quot;951 com&quot;]</span><br><span class="line">Explanation: </span><br><span class="line">We will visit &quot;google.mail.com&quot; 900 times, &quot;yahoo.com&quot; 50 times, &quot;intel.mail.com&quot; once and &quot;wiki.org&quot; 5 times. For the subdomains, we will visit &quot;mail.com&quot; 900 + 1 = 901 times, &quot;com&quot; 900 + 50 + 1 = 951 times, and &quot;org&quot; 5 times.</span><br></pre></td></tr></table></figure></p>
<p>这个题就是非常简单的统计字符串，如果用java和python做的话几分钟就出来了，但是用了原生C++，没有用高级功能，自己手写的一些函数，就当熟悉熟悉了。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; subdomainVisits(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; cpdomains) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cpdomains.size();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">string</span> domain=cpdomains[i];</span><br><span class="line">            <span class="keyword">int</span> domain_len = domain.length();</span><br><span class="line">            <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(domain[j]!=<span class="string">' '</span>) </span><br><span class="line">                j++;</span><br><span class="line">         </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;j;i++)</span><br><span class="line">                num = num *<span class="number">10</span> + (domain[i]-<span class="string">'0'</span>);</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; temp;</span><br><span class="line">            <span class="keyword">int</span> part_end=j+<span class="number">1</span>;</span><br><span class="line">            <span class="built_in">string</span> tt;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=j+<span class="number">1</span>;i&lt;domain_len;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(domain[i]==<span class="string">'.'</span>)&#123;</span><br><span class="line"> 	               tt = domain.substr(part_end,part_end-i+<span class="number">1</span>);</span><br><span class="line">	               temp.push_back(tt);</span><br><span class="line">                   part_end=i+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            tt=domain.substr(part_end,domain_len-part_end);</span><br><span class="line">            temp.push_back(tt);</span><br><span class="line">		        </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;temp.size();i++)</span><br><span class="line">                <span class="keyword">if</span>(m.find(temp[i])==m.end())&#123;</span><br><span class="line">                    m.insert(pair&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;(temp[i],num));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    m[temp[i]]+=num;           </span><br><span class="line">        &#125;</span><br><span class="line">	    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">        <span class="keyword">for</span>(it=m.begin();it!=m.end();it++)&#123;</span><br><span class="line">            <span class="built_in">string</span> ddd = to_string(it-&gt;second)+<span class="string">" "</span>+it-&gt;first;</span><br><span class="line">            res.push_back(ddd);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>贴一下其他解法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; subdomainVisits(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; cpdomains) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; domains;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">string</span> s:cpdomains)&#123;</span><br><span class="line">            <span class="keyword">int</span> count = stoi(s.substr(<span class="number">0</span>, s.find(<span class="string">' '</span>)));</span><br><span class="line">            domains[s.substr(s.find(<span class="string">' '</span>) + <span class="number">1</span>)] += count;</span><br><span class="line">            domains[s.substr(s.find(<span class="string">'.'</span>) + <span class="number">1</span>)] += count;</span><br><span class="line">            <span class="comment">// try to find the second '.'</span></span><br><span class="line">            <span class="built_in">string</span> sub = s.substr(s.find(<span class="string">'.'</span>) + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(sub.find(<span class="string">'.'</span>) != <span class="number">-1</span>)&#123;</span><br><span class="line">                domains[sub.substr(sub.find(<span class="string">'.'</span>) + <span class="number">1</span>)] += count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it = domains.begin(); it!= domains.end(); ++it)&#123;</span><br><span class="line">            ans.push_back(to_string(it-&gt;second) + <span class="string">" "</span> + it-&gt;first);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>python版本的：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subdomainVisits</span><span class="params">(self, cpdomains)</span>:</span></span><br><span class="line">        ans = collections.Counter()</span><br><span class="line">        <span class="keyword">for</span> domain <span class="keyword">in</span> cpdomains:</span><br><span class="line">            count, domain = domain.split()</span><br><span class="line">            count = int(count)</span><br><span class="line">            frags = domain.split(<span class="string">'.'</span>)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> xrange(len(frags)):</span><br><span class="line">	            ans[<span class="string">"."</span>.join(frags[i:])] += count</span><br><span class="line">        <span class="keyword">return</span> [<span class="string">"&#123;&#125; &#123;&#125;"</span>.format(ct, dom) <span class="keyword">for</span> dom, ct <span class="keyword">in</span> ans.items()]</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode812-Largest-Triangle-Area"><a href="#Leetcode812-Largest-Triangle-Area" class="headerlink" title="Leetcode812. Largest Triangle Area"></a>Leetcode812. Largest Triangle Area</h1><p>You have a list of points in the plane. Return the area of the largest triangle that can be formed by any 3 of the points.</p>
<p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: points = [[0,0],[0,1],[1,0],[0,2],[2,0]]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure></p>
<p>Explanation:<br>The five points are show in the figure below. The red triangle is the largest.</p>
<p>给定包含多个点的集合，从其中取三个点组成三角形，返回能组成的最大三角形的面积。</p>
<p>示例:输入: points = [[0,0],[0,1],[1,0],[0,2],[2,0]] 输出: 2</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getLength</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y1, <span class="keyword">int</span> y2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sqrt</span>((<span class="keyword">double</span>)(x1-x2)*(x1-x2)+(<span class="keyword">double</span>)(y1-y2)*(y1-y2));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">largestTriangleArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> result = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">double</span> a, b, c, q;</span><br><span class="line">        <span class="keyword">int</span> n = points.size();</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j ++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k ++) &#123;</span><br><span class="line">                     <span class="keyword">double</span> area = <span class="number">0.5</span> * <span class="built_in">abs</span>(points[i][<span class="number">0</span>] * points[j][<span class="number">1</span>] + points[j][<span class="number">0</span>] * points[k][<span class="number">1</span>] + points[k][<span class="number">0</span>] * points[i][<span class="number">1</span>] -points[i][<span class="number">0</span>] * points[k][<span class="number">1</span>] - points[k][<span class="number">0</span>] * points[j][<span class="number">1</span>] - points[j][<span class="number">0</span>] * points[i][<span class="number">1</span>]);</span><br><span class="line">                    result = max(result, area);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode813-Largest-Sum-of-Averages"><a href="#Leetcode813-Largest-Sum-of-Averages" class="headerlink" title="Leetcode813. Largest Sum of Averages"></a>Leetcode813. Largest Sum of Averages</h1><p>We partition a row of numbers A into at most K adjacent (non-empty) groups, then our score is the sum of the average of each group. What is the largest score we can achieve?</p>
<p>Note that our partition must use every number in A, and that scores are not necessarily integers.</p>
<p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">A = [9,1,2,3,9]</span><br><span class="line">K = 3</span><br><span class="line">Output: 20</span><br><span class="line">Explanation: </span><br><span class="line">The best choice is to partition A into [9], [1, 2, 3], [9]. The answer is 9 + (1 + 2 + 3) / 3 + 9 = 20.</span><br><span class="line">We could have also partitioned A into [9, 1], [2], [3, 9], for example.</span><br><span class="line">That partition would lead to a score of 5 + 2 + 6 = 13, which is worse.</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>1 &lt;= A.length &lt;= 100.</li>
<li>1 &lt;= A[i] &lt;= 10000.</li>
<li>1 &lt;= K &lt;= A.length.</li>
<li>Answers within 10^-6 of the correct answer will be accepted as correct. </li>
</ul>
<p>首先来考虑dp数组的定义，dp数组不把K加进去的话就不知道当前要分几组，这个Hidden Information是解题的关键。这是DP中比较难的一类，有些DP题的隐藏信息藏的更深，不挖出来就无法解题。这道题的dp数组应该是个二维数组，其中dp[i][k]表示范围是[i, n-1]的子数组分成k组的最大得分。那么这里你就会纳闷了，为啥范围是[i, n-1]而不是[0, i]，为啥要取后半段呢。由于把[i, n-1]范围内的子数组分成k组，那么suppose我们已经知道了任意范围内分成k-1组的最大分数，这是此类型题目的破题关键所在，要求状态k，一定要先求出所有的状态k-1，那么问题就转换成了从k-1组变成k组，即多分出一组，那么在范围[i, n-1]多分出一组，实际上就是将其分成两部分，一部分是一组，另一部分是k-1组，怎么分，就用一个变量j，遍历范围(i, n-1)中的每一个位置，那么分成的这两部分的分数如何计算呢？第一部分[i, j)，由于是一组，那么直接求出平均值即可，另一部分由于是k-1组，由于我们已经知道了所有k-1的情况，可以直接从cache中读出来dp[j][k-1]，二者相加即可 avg(i, j) + dp[j][k-1]，所以我们可以得出状态转移方程如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][k] = max(avg(i, n) + max_&#123;j &gt; i&#125; (avg(i, j) + dp[j][k-1]))</span><br></pre></td></tr></table></figure></p>
<p>这里的avg(i, n)是其可能出现的情况，由于是至多分为k组，所以我们可以不分组，所以直接计算范围[i, n-1]内的平均值，然后用j来遍历区间(i, n-1)中的每一个位置，最终得到的dp[i][k]就即为所求。注意这里我们通过建立累加和数组sums来快速计算某个区间之和。前面提到了dp[i][k]表示的是范围[i, n-1]的子数组分成k组的最大得分，现在想想貌似定义为[0, i]范围内的子数组分成k组的最大得分应该也是可以的，那么此时j就是遍历(0, i)中的每个位置了，好像也没什么不妥的地方，有兴趣的童鞋可以尝试的写一下～</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">largestSumOfAverages</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; sums(n + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&gt; dp(n, <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;(K));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            sums[i + <span class="number">1</span>] = sums[i] + A[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = (sums[n] - sums[i]) / (n - i);</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; K; ++k) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                    dp[i][k] = max(dp[i][k], (sums[j] - sums[i]) / (j - i) + dp[j][k - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][K - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们可以对空间进行优化，由于每次的状态k，只跟前一个状态k-1有关，所以我们不需要将所有的状态都保存起来，只需要保存前一个状态的值就行了，那么我们就用一个一维数组就可以了，不断的进行覆盖，从而达到了节省空间的目的，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">largestSumOfAverages</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; sums(n + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; dp(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            sums[i + <span class="number">1</span>] = sums[i] + A[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            dp[i] = (sums[n] - sums[i]) / (n - i);</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; K; ++k) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                    dp[i] = max(dp[i], (sums[j] - sums[i]) / (j - i) + dp[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们也可以是用递归加记忆数组的方式来实现，记忆数组的运作原理和DP十分类似，也是一种cache，将已经计算过的结果保存起来，用的时候直接取即可，避免了大量的重复计算，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">largestSumOfAverages</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&gt; memo(<span class="number">101</span>, <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;(<span class="number">101</span>));</span><br><span class="line">        <span class="keyword">double</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            cur += A[i];</span><br><span class="line">            memo[i + <span class="number">1</span>][<span class="number">1</span>] = cur / (i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> helper(A, K, n, memo);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> k, <span class="keyword">int</span> j, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&gt;&amp; memo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (memo[j][k] &gt; <span class="number">0</span>) <span class="keyword">return</span> memo[j][k];</span><br><span class="line">        <span class="keyword">double</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = j - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">            cur += A[i];</span><br><span class="line">            memo[j][k] = max(memo[j][k], helper(A, k - <span class="number">1</span>, i, memo) + cur / (j - i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[j][k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode814-Binary-Tree-Pruning"><a href="#Leetcode814-Binary-Tree-Pruning" class="headerlink" title="Leetcode814. Binary Tree Pruning"></a>Leetcode814. Binary Tree Pruning</h1><p>We are given the head node root of a binary tree, where additionally every node’s value is either a 0 or a 1.</p>
<p>Return the same tree where every subtree (of the given tree) not containing a 1 has been removed.</p>
<p>(Recall that the subtree of a node X is X, plus every node that is a descendant of X.)</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,null,0,0,1]</span><br><span class="line">Output: [1,null,0,null,1]</span><br></pre></td></tr></table></figure></p>
<p>Explanation:<br>Only the red nodes satisfy the property “every subtree not containing a 1”.<br>The diagram on the right represents the answer.<br><img src="/img/1028_2.png" alt></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,0,1,0,0,0,1]</span><br><span class="line">Output: [1,null,1,null,1]</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/1028_1.png" alt></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,1,0,1,1,0,1,0]</span><br><span class="line">Output: [1,1,0,1,1,null,1]</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/1028.png" alt></p>
<p>删掉子树里没有1的，返回这棵树。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dele</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">bool</span> a1 = dele(root-&gt;left);</span><br><span class="line">        <span class="keyword">bool</span> a2 = dele(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(!a1) root-&gt;left=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(!a2) root-&gt;right=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> root-&gt;val==<span class="number">1</span> || a1 || a2;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode* <span class="title">pruneTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dele(root)?root:<span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode816-Ambiguous-Coordinates"><a href="#Leetcode816-Ambiguous-Coordinates" class="headerlink" title="Leetcode816. Ambiguous Coordinates"></a>Leetcode816. Ambiguous Coordinates</h1><p>We had some 2-dimensional coordinates, like “(1, 3)” or “(2, 0.5)”.  Then, we removed all commas, decimal points, and spaces, and ended up with the string S.  Return a list of strings representing all possibilities for what our original coordinates could have been.</p>
<p>Our original representation never had extraneous zeroes, so we never started with numbers like “00”, “0.0”, “0.00”, “1.0”, “001”, “00.01”, or any other number that can be represented with less digits.  Also, a decimal point within a number never occurs without at least one digit occuring before it, so we never started with numbers like “.1”.</p>
<p>The final answer list can be returned in any order.  Also note that all coordinates in the final answer have exactly one space between them (occurring after the comma.)</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;(123)&quot;</span><br><span class="line">Output: [&quot;(1, 23)&quot;, &quot;(12, 3)&quot;, &quot;(1.2, 3)&quot;, &quot;(1, 2.3)&quot;]</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;(00011)&quot;</span><br><span class="line">Output:  [&quot;(0.001, 1)&quot;, &quot;(0, 0.011)&quot;]</span><br><span class="line">Explanation: </span><br><span class="line">0.0, 00, 0001 or 00.01 are not allowed.</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;(0123)&quot;</span><br><span class="line">Output: [&quot;(0, 123)&quot;, &quot;(0, 12.3)&quot;, &quot;(0, 1.23)&quot;, &quot;(0.1, 23)&quot;, &quot;(0.1, 2.3)&quot;, &quot;(0.12, 3)&quot;]</span><br></pre></td></tr></table></figure></p>
<p>Example 4:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;(100)&quot;</span><br><span class="line">Output: [(10, 0)]</span><br><span class="line">Explanation: </span><br><span class="line">1.0 is not allowed.</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>4 &lt;= S.length &lt;= 12.</li>
<li>S[0] = “(“, S[S.length - 1] = “)”, and the other elements in S are digits.</li>
</ul>
<p>这道题给了我们一个模糊坐标，括号里面很只有一个数字字符串，没有逗号也没有小数点，让我们自己添加逗号和小数点，让把所有可能的组合都返回。题目中给了很多例子，理解起题意来很容易。这道题的难点是如何合理的拆分，很多拆分是不合法的，题目举了很多不合法的例子，比如 “00”, “0.0”, “0.00”, “1.0”, “001”, “00.01”。那么我们需要归纳出所有不合法的corner case，然后剩下一般情况比如123，我们就按位加小数点即可。那么我们再来看一下那些非法的例子，我们发现一眼望去好多0，不错，0就是trouble maker，首先不能有0开头的长度大于1的整数，比如00， 001。其次，不能有0结尾的小数，比如0.0，0.00，1.0等。还有，小数的整数位上也不能有0开头的长度大于1的整数。那么我们来归纳一下吧，首先如果字符串为空，那么直接返回空集合。然后如果字符串长度大于1，且首尾字符都是0的话，那么不可分，比如 0xxx0，因为整数长度大于1的话不能以0开头，中间也没法加小数点，因为小数最后一位不能是0。如果长度大于1，第一位是0，但最后一位不是0，那我们可以在第一个0后面加个小数点返回，这时就必须要加小数点了，因为长度大于1的整数不能以0开头。再之后，如果最后一位是0，说明不能加小数点，直接把当前值返回即可。最后就是一般情况了，我们先把原数加入结果res，然后遍历中间的每个位置，都加个小数点，所有情况归纳如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if S == “”: return []</span><br><span class="line">if S == “0”: return [S]</span><br><span class="line">if S == “0XXX0”: return []</span><br><span class="line">if S == “0XXX”: return [“0.XXX”]</span><br><span class="line">if S == “XXX0”: return [S]</span><br><span class="line">return [S, “X.XXX”, “XX.XX”, “XXX.X”…]</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ambiguousCoordinates(<span class="built_in">string</span> S) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="keyword">int</span> n = S.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; A = findAll(S.substr(<span class="number">1</span>, i)), B = findAll(S.substr(i + <span class="number">1</span>, n - <span class="number">2</span> - i));</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;a : A) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;b : B) &#123;</span><br><span class="line">                    res.push_back(<span class="string">"("</span> + a + <span class="string">", "</span> + b + <span class="string">")"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; findAll(<span class="built_in">string</span> S) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = S.size();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span> || (n &gt; <span class="number">1</span> &amp;&amp; S[<span class="number">0</span>] == <span class="string">'0'</span> &amp;&amp; S[n - <span class="number">1</span>] == <span class="string">'0'</span>)) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">1</span> &amp;&amp; S[<span class="number">0</span>] == <span class="string">'0'</span>) <span class="keyword">return</span> &#123;<span class="string">"0."</span> + S.substr(<span class="number">1</span>)&#125;;</span><br><span class="line">        <span class="keyword">if</span> (S[n - <span class="number">1</span>] == <span class="string">'0'</span>) <span class="keyword">return</span> &#123;S&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res&#123;S&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) res.push_back(S.substr(<span class="number">0</span>, i) + <span class="string">"."</span> + S.substr(i));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode817-Linked-List-Components"><a href="#Leetcode817-Linked-List-Components" class="headerlink" title="Leetcode817. Linked List Components"></a>Leetcode817. Linked List Components</h1><p>We are given head, the head node of a linked list containing unique integer values.</p>
<p>We are also given the list G, a subset of the values in the linked list.</p>
<p>Return the number of connected components in G, where two values are connected if they appear consecutively in the linked list.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">head: 0-&gt;1-&gt;2-&gt;3</span><br><span class="line">G = [0, 1, 3]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: </span><br><span class="line">0 and 1 are connected, so [0, 1] and [3] are the two connected components.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">head: 0-&gt;1-&gt;2-&gt;3-&gt;4</span><br><span class="line">G = [0, 3, 1, 4]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: </span><br><span class="line">0 and 1 are connected, 3 and 4 are connected, so [0, 1] and [3, 4] are the two connected components.</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>If N is the length of the linked list given by head, 1 &lt;= N &lt;= 10000.</li>
<li>The value of each node in the linked list will be in the range [0, N - 1].</li>
<li>1 &lt;= G.length &lt;= 10000.</li>
<li>G is a subset of all values in the linked list.</li>
</ul>
<p>这道题给了我们一个链表，又给了我们一个结点值数组，里面不一定包括了链表中所有的结点值。让我们返回结点值数组中有多少个相连的组件，因为缺失的结点值会将原链表断开，实际上就是让我们求有多少个相连的子链表，题目中给的例子很好的说明题意。这道题并不需要什么特别高深的技巧，难懂的算法，直接按题目的要求来找就可以了。首先，为了快速的在结点值数组中查找某个结点值是否存在，我们可以将所有的结点值放到一个HashSet中，这样我们就能在常数级的时间复杂度中查找。然后我们就可以来遍历链表了，对于遍历到的每个结点值，我们只有两种情况，在或者不在HashSet中。不在HashSet中的情况比较好办，说明此时断开了，而在HashSet中的结点，有可能是该连续子链表的起始点，或者是中间的某个点，而我们的计数器对该子链表只能自增1，所以我们需要想办法来hanlde这种情况。博主最先想到的办法是先处理不在HashSet中的结点，处理方法就是直接跳到下一个结点。那么对于在HashSet中的结点，我们首先将计数器res自增1，然后再来个循环，将之后所有在集合中的结点都遍历完，这样才不会对同一个子链表多次增加计数器，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numComponents</span><span class="params">(ListNode* head, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; G)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; nodeSet(G.begin(), G.end());</span><br><span class="line">        <span class="keyword">while</span> (head) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!nodeSet.count(head-&gt;val)) &#123;</span><br><span class="line">                head = head-&gt;next;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ++res;</span><br><span class="line">            <span class="keyword">while</span> (head &amp;&amp; nodeSet.count(head-&gt;val)) &#123;</span><br><span class="line">                head = head-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode819-Most-Common-Word"><a href="#Leetcode819-Most-Common-Word" class="headerlink" title="Leetcode819. Most Common Word"></a>Leetcode819. Most Common Word</h1><p>Given a paragraph and a list of banned words, return the most frequent word that is not in the list of banned words.  It is guaranteed there is at least one word that isn’t banned, and that the answer is unique.</p>
<p>Words in the list of banned words are given in lowercase, and free of punctuation.  Words in the paragraph are not case sensitive.  The answer is in lowercase.</p>
<p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">paragraph = &quot;Bob hit a ball, the hit BALL flew far after it was hit.&quot;</span><br><span class="line">banned = [&quot;hit&quot;]</span><br><span class="line">Output: &quot;ball&quot;</span><br></pre></td></tr></table></figure></p>
<p>Explanation:<br>“hit” occurs 3 times, but it is a banned word.<br>“ball” occurs twice (and no other word does), so it is the most frequent non-banned word in the paragraph.<br>Note that words in the paragraph are not case sensitive,<br>that punctuation is ignored (even if adjacent to words, such as “ball,”),<br>and that “hit” isn’t the answer even though it occurs more because it is banned.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">mostCommonWord</span><span class="params">(<span class="built_in">string</span> paragraph, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; banned)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; mapp;</span><br><span class="line">        <span class="built_in">string</span> temp;</span><br><span class="line">        <span class="keyword">int</span> length = paragraph.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i ++)</span><br><span class="line">            <span class="keyword">if</span>(paragraph[i]&gt;=<span class="string">'A'</span> &amp;&amp; paragraph[i]&lt;=<span class="string">'Z'</span>)</span><br><span class="line">                paragraph[i] -= (<span class="string">'A'</span>-<span class="string">'a'</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length;i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(paragraph[i]==<span class="string">' '</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;length &amp;&amp; paragraph[i]&gt;=<span class="string">'a'</span> &amp;&amp; paragraph[i]&lt;=<span class="string">'z'</span>) </span><br><span class="line">                temp += paragraph[i++];</span><br><span class="line">            <span class="keyword">if</span> (mapp.find(temp) == mapp.end()) &#123;</span><br><span class="line">                mapp[temp] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                mapp[temp] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxx = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">string</span> result = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;::iterator iter = mapp.begin(); iter != mapp.end(); iter ++ ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (iter-&gt;second &gt; maxx &amp;&amp; find(banned.begin(), banned.end(), iter-&gt;first) == banned.end()) &#123;</span><br><span class="line">                result = iter-&gt;first;</span><br><span class="line">                maxx = iter-&gt;second;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">mostCommonWord</span><span class="params">(<span class="built_in">string</span> p, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; banned)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; ban(banned.begin(), banned.end());</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; count;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; c: p) c = <span class="built_in">isalpha</span>(c) ? <span class="built_in">tolower</span>(c) : <span class="string">' '</span>;</span><br><span class="line">        <span class="function"><span class="built_in">istringstream</span> <span class="title">iss</span><span class="params">(p)</span></span>;</span><br><span class="line">        <span class="built_in">string</span> w;</span><br><span class="line">        pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; res (<span class="string">""</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span> (iss &gt;&gt; w)</span><br><span class="line">            <span class="keyword">if</span> (ban.find(w) == ban.end() &amp;&amp; ++count[w] &gt; res.second)</span><br><span class="line">                res = make_pair(w, count[w]);</span><br><span class="line">        <span class="keyword">return</span> res.first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">mostCommonWord</span><span class="params">(<span class="built_in">string</span> paragraph, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; banned)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; paragraph.size();)&#123;</span><br><span class="line">            <span class="built_in">string</span> s = <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; paragraph.size() &amp;&amp; <span class="built_in">isalpha</span>(paragraph[i])) s.push_back(<span class="built_in">tolower</span>(paragraph[i++]));</span><br><span class="line">            <span class="keyword">while</span>(i &lt; paragraph.size() &amp;&amp; !<span class="built_in">isalpha</span>(paragraph[i])) i++;</span><br><span class="line">            m[s]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x: banned) m[x] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">string</span> res = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x: m)</span><br><span class="line">            <span class="keyword">if</span>(x.second &gt; count) res = x.first, count = x.second;</span><br><span class="line">        <span class="keyword">return</span> res;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode820-Short-Encoding-of-Words"><a href="#Leetcode820-Short-Encoding-of-Words" class="headerlink" title="Leetcode820. Short Encoding of Words"></a>Leetcode820. Short Encoding of Words</h1><p>A valid encoding of an array of words is any reference string s and array of indices indices such that:</p>
<ul>
<li>words.length == indices.length</li>
<li>The reference string s ends with the ‘#’ character.</li>
<li>For each index indices[i], the substring of s starting from indices[i] and up to (but not including) the next ‘#’ character is equal to words[i].</li>
</ul>
<p>Given an array of words, return the length of the shortest reference string s possible of any valid encoding of words.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: words = [&quot;time&quot;, &quot;me&quot;, &quot;bell&quot;]</span><br><span class="line">Output: 10</span><br><span class="line">Explanation: A valid encoding would be s = &quot;time#bell#&quot; and indices = [0, 2, 5].</span><br><span class="line">words[0] = &quot;time&quot;, the substring of s starting from indices[0] = 0 to the next &apos;#&apos; is underlined in &quot;time#bell#&quot;</span><br><span class="line">words[1] = &quot;me&quot;, the substring of s starting from indices[1] = 2 to the next &apos;#&apos; is underlined in &quot;time#bell#&quot;</span><br><span class="line">words[2] = &quot;bell&quot;, the substring of s starting from indices[2] = 5 to the next &apos;#&apos; is underlined in &quot;time#bell#&quot;</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: words = [&quot;t&quot;]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: A valid encoding would be s = &quot;t#&quot; and indices = [0].</span><br></pre></td></tr></table></figure></p>
<p>这道题给了我们一个单词数组，让我们对其编码，不同的单词之间加入#号，每个单词的起点放在一个坐标数组内，终点就是#号，能合并的单词要进行合并，问输入字符串的最短长度。题意不难理解，难点在于如何合并单词，我们观察题目的那个例子，me和time是能够合并的，只要标清楚其实位置，time的起始位置是0，me的起始位置是2，那么根据#号位置的不同就可以顺利的取出me和time。需要注意的是，如果me换成im，或者tim的话，就不能合并了，因为我们是要从起始位置到#号之前所有的字符都要取出来。搞清楚了这一点之后，我们在接着观察，由于me是包含在time中的，所以我们处理的顺序应该是先有time#，然后再看能否包含me，而不是先生成了me#之后再处理time，所以我们可以得出结论，应该先处理长单词，那么就给单词数组按长度排序一下就行，自己重写一个comparator就行。然后我们遍历数组，对于每个单词，我们都在编码字符串查找一下，如果没有的话，直接加上这个单词，再加一个#号，如果有的话，就可以得到出现的位置。比如在time#中查找me，得到found=2，然后我们要验证该单词后面是否紧跟着一个#号，所以我们直接访问<code>found+word.size()</code>这个位置，如果不是#号，说明不能合并，我们还是要加上这个单词和#号。最后返回编码字符串的长度即可，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumLengthEncoding</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res = <span class="string">""</span>;</span><br><span class="line">        sort(words.begin(), words.end(), [](<span class="built_in">string</span> &amp;a, <span class="built_in">string</span> &amp;b)&#123; <span class="keyword">return</span> a.length() &gt; b.length();&#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">string</span> word : words) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = <span class="number">0</span>, <span class="keyword">prev_t</span> = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>((t=res.find(word, t))!=<span class="built_in">string</span>::npos) &#123;</span><br><span class="line">                <span class="keyword">prev_t</span> = t;</span><br><span class="line">                t++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">prev_t</span> == <span class="number">-1</span> || res[<span class="keyword">prev_t</span> + word.length()] != <span class="string">'#'</span>)</span><br><span class="line">                res += (word + <span class="string">'#'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.length();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode821-Shortest-Distance-to-a-Character"><a href="#Leetcode821-Shortest-Distance-to-a-Character" class="headerlink" title="Leetcode821. Shortest Distance to a Character"></a>Leetcode821. Shortest Distance to a Character</h1><p>Given a string S and a character C, return an array of integers representing the shortest distance from the character C in the string.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: S = &quot;loveleetcode&quot;, C = &apos;e&apos;</span><br><span class="line">Output: [3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0]</span><br></pre></td></tr></table></figure></p>
<p>简单题，这里是对于每个是字符C的位置，然后分别像左右两边扩散，不停是更新距离，这样当所有的字符C的点都扩散完成之后，每个非字符C位置上的数字就是到字符C的最短距离了，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; shortestToChar(<span class="built_in">string</span> S, <span class="keyword">char</span> C) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = S.length();</span><br><span class="line">        <span class="keyword">int</span> signal[len];</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(len,INT_MAX);</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(S[i] == C)&#123;</span><br><span class="line">                res[i]=<span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;len;j++)</span><br><span class="line">                res[j]=min(res[j],j-i);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">                res[j]=min(res[j],i-j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>下面这种方法也是建立距离场的思路，不过更加巧妙一些，只需要正反两次遍历就行。首先进行正向遍历，若当前位置是字符C，那么直接赋0，否则看如果不是首位置，那么当前位置的值等于前一个位置的值加1。这里不用和当前的值进行比较，因为这个算出来的值不会大于初始化的值。然后再进行反向遍历，要从倒数第二个值开始往前遍历，用后一个值加1来更新当前位置的值，此时就要和当前值做比较，取较小的那个，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; shortestToChar(<span class="built_in">string</span> S, <span class="keyword">char</span> C) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(S.size(), S.size());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (S[i] == C) res[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; <span class="number">0</span>) res[i] = res[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = (<span class="keyword">int</span>)S.size() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            res[i] = min(res[i], res[i + <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode822-Card-Flipping-Game"><a href="#Leetcode822-Card-Flipping-Game" class="headerlink" title="Leetcode822. Card Flipping Game"></a>Leetcode822. Card Flipping Game</h1><p>On a table are N cards, with a positive integer printed on the front and back of each card (possibly different).</p>
<p>We flip any number of cards, and after we choose one card. </p>
<p>If the number X on the back of the chosen card is not on the front of any card, then this number X is good.</p>
<p>What is the smallest number that is good?  If no number is good, output 0.</p>
<p>Here, fronts[i] and backs[i] represent the number on the front and back of card i. </p>
<p>A flip swaps the front and back numbers, so the value on the front is now on the back and vice versa.</p>
<p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: fronts = [1,2,4,4,7], backs = [1,3,4,1,3]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: If we flip the second card, the fronts are [1,3,4,4,7] and the backs are [1,2,4,1,3].</span><br><span class="line">We choose the second card, which has number 2 on the back, and it isn&apos;t on the front of any card, so 2 is good.</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>1 &lt;= fronts.length == backs.length &lt;= 1000.</li>
<li>1 &lt;= fronts[i] &lt;= 2000.</li>
<li>1 &lt;= backs[i] &lt;= 2000.</li>
</ul>
<p>给了一些正反都有正数的卡片，可以翻面，让我们找到一个最小的数字，在卡的背面，且要求其他卡正面上均没有这个数字。简而言之，就是要在backs数组找一个最小数字，使其不在fronts数组中。我们想，既然不能在fronts数组中，说明卡片背面的数字肯定跟其正面的数字不相同，否则翻来翻去都是相同的数字，肯定会在fronts数组中。那么我们可以先把正反数字相同的卡片都找出来，将数字放入一个HashSet，也方便我们后面的快速查找。现在其实我们只需要在其他的数字中找到一个最小值即可，因为正反数字不同，就算fronts中其他卡片的正面还有这个最小值，我们可以将那张卡片翻面，使得相同的数字到backs数组，总能使得fronts数组不包含有这个最小值，就像题目中给的例子一样，数字2在第二张卡的背面，就算其他卡面也有数字2，只要其不是正反都是2，我们都可以将2翻到背面去，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">flipgame</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; fronts, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; backs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = INT_MAX, n = fronts.size();</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; same;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fronts[i] == backs[i]) same.insert(fronts[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> front : fronts) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!same.count(front)) res = min(res, front);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> back : backs) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!same.count(back)) res = min(res, back);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (res == INT_MAX) ? <span class="number">0</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode823-Binary-Trees-With-Factors"><a href="#Leetcode823-Binary-Trees-With-Factors" class="headerlink" title="Leetcode823. Binary Trees With Factors"></a>Leetcode823. Binary Trees With Factors</h1><p>Given an array of unique integers, each integer is strictly greater than 1.</p>
<p>We make a binary tree using these integers and each number may be used for any number of times.</p>
<p>Each non-leaf node’s value should be equal to the product of the values of it’s children.</p>
<p>How many binary trees can we make?  Return the answer modulo 10 ** 9 + 7.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [2, 4]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: We can make these trees: [2], [4], [4, 2, 2]</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [2, 4, 5, 10]</span><br><span class="line">Output: 7</span><br><span class="line">Explanation: We can make these trees: [2], [4], [5], [10], [4, 2, 2], [10, 2, 5], [10, 5, 2].</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>1 &lt;= A.length &lt;= 1000.</li>
<li>2 &lt;= A[i] &lt;= 10 ^ 9.</li>
</ul>
<p>两个难点，定义dp表达式跟推导状态转移方程。怎么简单怎么来呗，我们用一个一维dp数组，其中dp[i]表示值为i的结点做根结点时，能够形成的符合题意的二叉树的个数。这样我们将数组A中每个结点的dp值都累加起来就是最终的结果了。好了，有了定义式，接下来就是最大的难点了，推导状态转移方程。题目中的要求是根结点的值必须是左右子结点值的乘积，那么根结点的dp值一定是跟左右子结点的dp值有关的，是要加上左右子结点的dp值的乘积的，为啥是乘呢，比如有两个球，一个有2种颜色，另一个有3种颜色，问两个球放一起总共能有多少种不同的颜色组合，当然是相乘啦。每个结点的dp值初始化为1，因为就算是当个光杆司令的叶结点，也是符合题意的，所以至少是1。然后就要找其左右两个子结点了，怎么找，有点像 Two Sum 的感觉，先确定一个，然后在HashMap中快速定位另一个，想到了这一层的话，我们的dp定义式就需要做个小修改，之前说的是用一个一维dp数组，现在看来就不太合适了，因为我们需要快速查找某个值，所以这里我们用一个HashMap来定义dp。好，继续，既然要先确定一个结点，由于都是大于1的正数，那么这个结点肯定要比根结点值小，为了遍历方便，我们想把小的放前面，那么我们就需要给数组A排个序，这样就可以遍历之前较小的数字了，那么如何快速定位另一个子结点呢，我们只要用根结点值对遍历值取余，若为0，说明可以整除，然后再在HashMap中查找这个商是否存在，在的话，说明存在这样的两个结点，其结点值之积等于结点A[i]，然后我们将这两个结点值之积加到dp[A[i]]中即可，注意还要对超大数取余，防止溢出。最后当所有结点的dp值都更新完成了，将其和算出来返回即可，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numFactoredBinaryTrees</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> res = <span class="number">0</span>, M = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">long</span>&gt; dp;</span><br><span class="line">        sort(A.begin(), A.end());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size(); ++i) &#123;</span><br><span class="line">            dp[A[i]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (A[i] % A[j] == <span class="number">0</span> &amp;&amp; dp.count(A[i] / A[j])) &#123;</span><br><span class="line">                    dp[A[i]] = (dp[A[i]] + dp[A[j]] * dp[A[i] / A[j]]) % M;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> a : dp) res = (res + a.second) % M;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode824-Goat-Latin"><a href="#Leetcode824-Goat-Latin" class="headerlink" title="Leetcode824. Goat Latin"></a>Leetcode824. Goat Latin</h1><p>A sentence S is given, composed of words separated by spaces. Each word consists of lowercase and uppercase letters only.</p>
<p>We would like to convert the sentence to “Goat Latin” (a made-up language similar to Pig Latin.)</p>
<p>The rules of Goat Latin are as follows:</p>
<ul>
<li>If a word begins with a vowel (a, e, i, o, or u), append “ma” to the end of the word.<br>For example, the word ‘apple’ becomes ‘applema’.</li>
<li>If a word begins with a consonant (i.e. not a vowel), remove the first letter and append it to the end, then add “ma”.<br>For example, the word “goat” becomes “oatgma”.</li>
<li>Add one letter ‘a’ to the end of each word per its word index in the sentence, starting with 1.<br>For example, the first word gets “a” added to the end, the second word gets “aa” added to the end and so on.<br>Return the final sentence representing the conversion from S to Goat Latin. </li>
</ul>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;I speak Goat Latin&quot;</span><br><span class="line">Output: &quot;Imaa peaksmaaa oatGmaaaa atinLmaaaaa&quot;</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;The quick brown fox jumped over the lazy dog&quot;</span><br><span class="line">Output: &quot;heTmaa uickqmaaa rownbmaaaa oxfmaaaaa umpedjmaaaaaa overmaaaaaaa hetmaaaaaaaa azylmaaaaaaaaa ogdmaaaaaaaaaa&quot;</span><br></pre></td></tr></table></figure></p>
<p>Notes:</p>
<ol>
<li>S contains only uppercase, lowercase and spaces. Exactly one space between each word.</li>
<li>1 &lt;= S.length &lt;= 150.</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isvowel</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="string">'A'</span> || c == <span class="string">'a'</span> || c == <span class="string">'E'</span> || c == <span class="string">'e'</span> || c == <span class="string">'I'</span> || c == <span class="string">'i'</span> || c == <span class="string">'O'</span> || c == <span class="string">'o'</span> || c == <span class="string">'U'</span> || c == <span class="string">'u'</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">toGoatLatin</span><span class="params">(<span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; words;</span><br><span class="line">        <span class="built_in">string</span> result, temp;</span><br><span class="line">        <span class="keyword">int</span> length = S.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i ++) &#123;</span><br><span class="line">            temp = <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">while</span>(S[i] != <span class="string">' '</span> &amp;&amp; i &lt; length) &#123;</span><br><span class="line">                temp += S[i++];</span><br><span class="line">            &#125;</span><br><span class="line">            words.push_back(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.size(); i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(isvowel(words[i][<span class="number">0</span>]))</span><br><span class="line">                result = result + words[i] + <span class="string">"ma"</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                result = result + words[i].substr(<span class="number">1</span>) + words[i][<span class="number">0</span>] + <span class="string">"ma"</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i + <span class="number">1</span>; j ++)</span><br><span class="line">                result += <span class="string">'a'</span>;</span><br><span class="line">            result += <span class="string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.substr(<span class="number">0</span>, result.length()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">toGoatLatin</span><span class="params">(<span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">stringstream</span> <span class="title">ss</span><span class="params">(S)</span></span>;</span><br><span class="line">        <span class="built_in">string</span> word;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">char</span>&gt; vowels&#123;<span class="string">'a'</span>, <span class="string">'e'</span>, <span class="string">'i'</span>, <span class="string">'o'</span>, <span class="string">'u'</span>, <span class="string">'A'</span>, <span class="string">'E'</span>, <span class="string">'I'</span>, <span class="string">'O'</span>, <span class="string">'U'</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (ss &gt;&gt; word) &#123;</span><br><span class="line">            count += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (!vowels.count(word[<span class="number">0</span>])) &#123;</span><br><span class="line">                <span class="built_in">std</span>::reverse(word.begin(), word.end());</span><br><span class="line">                <span class="built_in">std</span>::reverse(word.begin(), word.end() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            res += word + <span class="string">"ma"</span> + <span class="built_in">string</span>(count, <span class="string">'a'</span>) + <span class="string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> space_pos = res.find_last_of(<span class="string">' '</span>);</span><br><span class="line">        res = res.substr(<span class="number">0</span>, space_pos);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode825-Friends-Of-Appropriate-Ages"><a href="#Leetcode825-Friends-Of-Appropriate-Ages" class="headerlink" title="Leetcode825. Friends Of Appropriate Ages"></a>Leetcode825. Friends Of Appropriate Ages</h1><p>Some people will make friend requests. The list of their ages is given and ages[i] is the age of the ith person. </p>
<p>Person A will NOT friend request person B (B != A) if any of the following conditions are true:</p>
<ul>
<li><code>age[B] &lt;= 0.5 * age[A] + 7</code></li>
<li><code>age[B] &gt; age[A]</code></li>
<li><code>age[B] &gt; 100 &amp;&amp; age[A] &lt; 100</code></li>
</ul>
<p>Otherwise, A will friend request B.</p>
<p>Note that if A requests B, B does not necessarily request A.  Also, people will not friend request themselves.</p>
<p>How many total friend requests are made?</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [16,16]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: 2 people friend request each other.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [16,17,18]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: Friend requests are made 17 -&gt; 16, 18 -&gt; 17.</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [20,30,100,110,120]</span><br><span class="line">Output: </span><br><span class="line">Explanation: Friend requests are made 110 -&gt; 100, 120 -&gt; 110, 120 -&gt; 100.</span><br></pre></td></tr></table></figure></p>
<p>Notes:</p>
<ul>
<li>1 &lt;= ages.length &lt;= 20000.</li>
<li>1 &lt;= ages[i] &lt;= 120.</li>
</ul>
<p>这道题是关于好友申请的，说是若A想要加B的好友，下面三个条件一个都不能满足才行：</p>
<ol>
<li>B的年龄小于等于A的年龄的一半加7。</li>
<li>B的年龄大于A的年龄。</li>
<li>B大于100岁，且A小于100岁。</li>
</ol>
<p>实际上如果你仔细看条件3，B要是大于100岁，A小于100岁，那么B一定大于A，这就跟条件2重复了。那么由于只能给比自己小的人发送好友请求，那么博主就想到我们可以献给所有人拍个序，然后从后往前遍历，对于每个遍历到的人，再遍历所有比他小的人，这样第二个条件就满足了，前面说了，第三个条件可以不用管了，那么只要看满足第一个条件就可以了，还有要注意的，假如两个人年龄相同，那么满足了前两个条件后，其实是可以互粉的，所以要额外的加1，这样才不会漏掉任何一个好友申请，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numFriendRequests</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; ages)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, n = ages.size();</span><br><span class="line">        sort(ages.begin(), ages.end());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ages[j] &lt;= <span class="number">0.5</span> * ages[i] + <span class="number">7</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (ages[i] == ages[j]) ++res;</span><br><span class="line">                ++res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个方法会超时。</p>
<p>我们可以来优化一下上面的解法，根据上面的分析，其实题目给的这三个条件可以归纳成一个条件，若A想加B的好友，那么B的年龄必须在 <code>(A*0.5+7, A]</code> 这个范围内，由于区间要有意义的话，A0.5+7 &lt; A 必须成立，解出 A &gt; 14，那么A最小就只能取15了。意思说你不能加小于15岁的好友（青少年成长保护？？？）。我们的优化思路是对于每一个年龄，我们都只要求出上面那个区间范围内的个数，就是符合题意的。那么既然是求区域和，建立累加数组就是一个很好的选择了，首先我们先建立一个统计数组numInAge，范围是[0, 120]，用来统计在各个年龄点上有多少人，然后再建立累加和数组sumInAge。这个都建立好了以后，我们就可以开始遍历，由于之前说了不能加小于15的好友，所以我们从15开始遍历，如果某个年龄点没有人，直接跳过。然后就是统计出 <code>(A*0.5+7, A]</code> 这个范围内有多少人，可以通过累计和数组来快速求的，由于当前时间点的人可以跟这个区间内的所有发好友申请，而当前时间点可能还有多人，所以二者相乘，但由于我们但区间里还包括但当前年龄点本身，所以还要减去当前年龄点上的人数，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numFriendRequests</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; ages)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numInAge(<span class="number">121</span>), sumInAge(<span class="number">121</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> age : ages) ++numInAge[age];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">120</span>; ++i) &#123;</span><br><span class="line">            sumInAge[i] = numInAge[i] + sumInAge[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">15</span>; i &lt;= <span class="number">120</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (numInAge[i] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> cnt = sumInAge[i] - sumInAge[i * <span class="number">0.5</span> + <span class="number">7</span>];</span><br><span class="line">            res += cnt * numInAge[i] - numInAge[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode826-Most-Profit-Assigning-Work"><a href="#Leetcode826-Most-Profit-Assigning-Work" class="headerlink" title="Leetcode826. Most Profit Assigning Work"></a>Leetcode826. Most Profit Assigning Work</h1><p>You have n jobs and m workers. You are given three arrays: difficulty, profit, and worker where:</p>
<p><code>difficulty[i]</code>and <code>profit[i]</code> are the difficulty and the profit of the ith job, and <code>worker[j]</code> is the ability of jth worker (i.e., the jth worker can only complete a job with difficulty at most <code>worker[j]</code>).</p>
<p>Every worker can be assigned at most one job, but one job can be completed multiple times.</p>
<p>For example, if three workers attempt the same job that pays $1, then the total profit will be $3. If a worker cannot complete any job, their profit is $0. Return the maximum profit we can achieve after assigning the workers to the jobs.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: difficulty = [2,4,6,8,10], profit = [10,20,30,40,50], worker = [4,5,6,7]</span><br><span class="line">Output: 100</span><br><span class="line">Explanation: Workers are assigned jobs of difficulty [4,4,6,6] and they get a profit of [20,20,30,30] separately.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: difficulty = [85,47,57], profit = [24,66,99], worker = [40,25,25]</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure></p>
<p>贪心的策略是给每个工人计算在他的能力范围内，他能获得的最大收益，把这样的工作分配给他。</p>
<p>做的方法是先把困难程度和收益压缩排序，然后对工人排序，再对每个工人，通过从左到右的遍历确定其能获得收益最大值。由于工作和工人都已经排好序了，每次只需要从上次停止的位置继续即可，因此各自只需要遍历一次。</p>
<p>你可能会想到，每个工作的收益和其困难程度可能不是正相关的，可能存在某个工作难度小，但是收益反而很大，这种怎么处理呢？其实这也就是这个算法妙的地方，curMax并不是在每个工人查找其满足条件的工作时初始化的，而是在一开始就初始化了，这样一直保持的是所有的工作难度小于工人能力的工作中，能获得的收益最大值。</p>
<p>也就是说在查找满足条件的工作的时候，curMax有可能不更新，其保存的是目前为止的最大。res加的也就是在满足工人能力情况下的最大收益了。</p>
<p>时间复杂度是O(M+N)，空间复杂度是O(MN)。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfitAssignment</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; difficulty, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; profit, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; worker)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, curmax = <span class="number">0</span>, curwork = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = difficulty.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; v;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i ++)</span><br><span class="line">            v.push_back(make_pair(difficulty[i], profit[i]));</span><br><span class="line">        sort(v.begin(), v.end(), [](pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp; a,pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp; b)&#123; <span class="keyword">return</span> a.first &lt; b.first; &#125;);</span><br><span class="line">        sort(worker.begin(), worker.end());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; worker.size(); i ++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; len) &#123;</span><br><span class="line">                <span class="keyword">if</span> (worker[i] &lt; v[j].first) </span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                curmax = max(curmax, v[j].second);</span><br><span class="line">                j ++;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            res += curmax;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode830-Positions-of-Large-Groups"><a href="#Leetcode830-Positions-of-Large-Groups" class="headerlink" title="Leetcode830. Positions of Large Groups"></a>Leetcode830. Positions of Large Groups</h1><p>In a string S of lowercase letters, these letters form consecutive groups of the same character. For example, a string like S = “abbxxxxzyy” has the groups “a”, “bb”, “xxxx”, “z” and “yy”.</p>
<p>Call a group large if it has 3 or more characters.  We would like the starting and ending positions of every large group. The final answer should be in lexicographic order.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;abbxxxxzzy&quot;</span><br><span class="line">Output: [[3,6]]</span><br><span class="line">Explanation: &quot;xxxx&quot; is the single large group with starting  3 and ending positions 6.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;abc&quot;</span><br><span class="line">Output: []</span><br><span class="line">Explanation: We have &quot;a&quot;,&quot;b&quot; and &quot;c&quot; but no large group.</span><br></pre></td></tr></table></figure></p>
<p>找到长度大于3的子串。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; largeGroupPositions(<span class="built_in">string</span> S) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">int</span> len = S.length();</span><br><span class="line">        <span class="keyword">int</span> begin, end;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i ++) &#123;</span><br><span class="line">            begin = i;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; len<span class="number">-1</span> &amp;&amp; S[i] == S[i+<span class="number">1</span>])</span><br><span class="line">                i ++;</span><br><span class="line">            <span class="keyword">if</span>(i - begin + <span class="number">1</span> &gt;= <span class="number">3</span>)</span><br><span class="line">                res.push_back(&#123;begin, i&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode831-Masking-Personal-Information"><a href="#Leetcode831-Masking-Personal-Information" class="headerlink" title="Leetcode831. Masking Personal Information"></a>Leetcode831. Masking Personal Information</h1><p>We are given a personal information string S, which may represent either an email address or a phone number.</p>
<p>We would like to mask this personal information according to the following rules:</p>
<ul>
<li>Email address:<ul>
<li>We define a name to be a string of length ≥ 2consisting of only lowercase letters a-z or uppercase letters A-Z.</li>
<li>An email address starts with a name, followed by the symbol ‘@’, followed by a name, followed by the dot ‘.’ and followed by a name. </li>
<li>All email addresses are guaranteed to be valid and in the format of “<a href="mailto:name1@name2.name3" target="_blank" rel="noopener">name1@name2.name3</a>“.</li>
<li>To mask an email, all names must be converted to lowercase and all letters between the first and last letter of the first name must be replaced by 5 asterisks ‘*’.</li>
</ul>
</li>
<li>Phone number:<ul>
<li>A phone number is a string consisting of only the digits 0-9or the characters from the set {‘+’, ‘-‘, ‘(‘, ‘)’, ‘ ‘}. You may assume a phone number contains 10 to 13 digits.</li>
<li>The last 10 digits make up the local number, while the digits before those make up the country code. Note that the country code is optional. We want to expose only the last 4 digits and mask all other digits.</li>
<li>The local number should be formatted and masked as <code>***-***-1111</code>, where 1 represents the exposed digits.</li>
<li>To mask a phone number with country code like <code>+111 111 111 1111</code>, we write it in the form <code>+***-***-***-1111</code>. The ‘+’ sign and the first ‘-‘ sign before the local number should only exist if there is a country code.  For example, a 12 digit phone number mask should start with “+**-“.</li>
</ul>
</li>
</ul>
<p>Note that extraneous characters like “(“, “)”, “ “, as well as extra dashes or plus signs not part of the above formatting scheme should be removed.</p>
<p>Return the correct “mask” of the information provided.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;LeetCode@LeetCode.com&quot;</span><br><span class="line">Output: &quot;l*****e@leetcode.com&quot;</span><br><span class="line">Explanation: All names are converted to lowercase, and the letters between the</span><br><span class="line">             first and last letter of the first name is replaced by 5 asterisks.</span><br><span class="line">             Therefore, &quot;leetcode&quot; -&gt; &quot;l*****e&quot;.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;AB@qq.com&quot;</span><br><span class="line">Output: &quot;a*****b@qq.com&quot;</span><br><span class="line">Explanation: There must be 5 asterisks between the first and last letter </span><br><span class="line">             of the first name &quot;ab&quot;. Therefore, &quot;ab&quot; -&gt; &quot;a*****b&quot;.</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;1(234)567-890&quot;</span><br><span class="line">Output: &quot;***-***-7890&quot;</span><br><span class="line">Explanation: 10 digits in the phone number, which means all digits make up the local number.</span><br></pre></td></tr></table></figure></p>
<p>Example 4:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;86-(10)12345678&quot;</span><br><span class="line">Output: &quot;+**-***-***-5678&quot;</span><br><span class="line">Explanation: 12 digits, 2 digits for country code and 10 digits for local number.</span><br></pre></td></tr></table></figure></p>
<p>这道题让我们给个人信息打码。这里对邮箱和电话分别进行了不同的打码方式，对于邮箱来说，只保留用户名的首尾两个字符，然后中间固定加上五个星号，还有就是所有的字母转小写。对于电话来说，有两种方式，有和没有国家代号，有的话其前面必须有加号，跟后面的区域号用短杠隔开，后面的10个电话号分为三组，个数分别为3，3，4。每组之间还是用短杠隔开，除了最后一组的数字保留之外，其他的都用星号代替。弄清楚了题意，就开始解题吧。既然是字符串的题目，那么肯定要遍历这个字符串了，我们关心的主要是数字和字母，所以要用个变量str来保存遍历到的数字和字母，所以判断，如果是数字或者小写字母的话，直接加入str中，若是大写字母的话，转成小写字母再加入str，如果遇到了 ‘@’ 号，那么表示当前处理的是邮箱，而此时的用户已经全部读入str了，那直接就取出首尾字符，然后中间加五个星号，并再加上 ‘@’ 号存入结果res中，并把str清空。若遇到了点，说明此时是邮箱的后半段，因为题目中限制了用户名中不会有点存在，那么我们将str和点一起加入结果res，并将str清空。当遍历结束时，若此时结果res不为空，说明我们处理的是邮箱，那么返回结果res加上str，因为str中存的是 “com”，还没有来得及加入结果res。若res为空，说明处理的是电话号码，所有的数字都已经加入了str，由于国家代号可能有也可能没有，所以判断一下存入的数字的个数，如果超过10个了，说明有国家代号，那么将超过的部分取出来拼装一下，前面加 ‘+’ 号，后面加短杠。然后再将10位号码的前六位的星号格式加上，并加上最后四个数字即可，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">tolower</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">'A'</span> &lt;= c &amp;&amp; c &lt;= <span class="string">'Z'</span>)</span><br><span class="line">            <span class="keyword">return</span> c + (<span class="string">'a'</span>-<span class="string">'A'</span>);</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">maskPII</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> t, res = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">bool</span> is_email = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> _size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> aa = <span class="number">0</span>, bb = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">'@'</span> == s[i]) &#123;</span><br><span class="line">                is_email = <span class="literal">true</span>;</span><br><span class="line">                aa = i<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">'-'</span> == s[i])</span><br><span class="line">                _size ++;</span><br><span class="line">            <span class="keyword">if</span> (_size == <span class="number">1</span> &amp;&amp; bb == <span class="number">-1</span> &amp;&amp; <span class="string">'-'</span> == s[i])</span><br><span class="line">                bb = i;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">'+'</span> == s[i] || <span class="string">'-'</span> == s[i] || <span class="string">'('</span> == s[i] || <span class="string">')'</span> == s[i] || <span class="string">' '</span> == s[i])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            t.push_back(<span class="built_in">tolower</span>(s[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (is_email) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.length(); i ++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                    res += t[i];</span><br><span class="line">                    res += <span class="string">"*****"</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (i &gt;= aa)</span><br><span class="line">                    res += t[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> length = t.length();</span><br><span class="line">            <span class="keyword">if</span> (length &gt; <span class="number">10</span>) &#123;</span><br><span class="line">                res += <span class="string">"+"</span>;</span><br><span class="line">                res += <span class="built_in">string</span>(length<span class="number">-10</span>, <span class="string">'*'</span>);</span><br><span class="line">                res += <span class="string">"-"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res += <span class="string">"***-***-"</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = length<span class="number">-4</span>; i &lt; length; i ++)</span><br><span class="line">                res += t[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode832-Flipping-an-Image"><a href="#Leetcode832-Flipping-an-Image" class="headerlink" title="Leetcode832. Flipping an Image"></a>Leetcode832. Flipping an Image</h1><p>Given a binary matrix A, we want to flip the image horizontally, then invert it, and return the resulting image.</p>
<p>To flip an image horizontally means that each row of the image is reversed.  For example, flipping [1, 1, 0] horizontally results in [0, 1, 1].</p>
<p>To invert an image means that each 0 is replaced by 1, and each 1 is replaced by 0. For example, inverting [0, 1, 1] results in [1, 0, 0].</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,1,0],[1,0,1],[0,0,0]]</span><br><span class="line">Output: [[1,0,0],[0,1,0],[1,1,1]]</span><br><span class="line">Explanation: First reverse each row: [[0,1,1],[1,0,1],[0,0,0]].</span><br><span class="line">Then, invert the image: [[1,0,0],[0,1,0],[1,1,1]]</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]]</span><br><span class="line">Output: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]</span><br><span class="line">Explanation: First reverse each row: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]].</span><br><span class="line">Then invert the image: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]</span><br></pre></td></tr></table></figure></p>
<p>没啥好说的，普通的矩阵操作。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; flipAndInvertImage(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;&amp; A) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size(); i ++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>, k = A[i].size()<span class="number">-1</span>; j &lt; A[i].size() / <span class="number">2</span>; j ++, k --)&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = A[i][j];</span><br><span class="line">                A[i][j] = A[i][k];</span><br><span class="line">                A[i][k] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>, k = A[i].size()<span class="number">-1</span>; j &lt; A[i].size(); j ++, k --)&#123;</span><br><span class="line">                A[i][j] = <span class="number">1</span> - A[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode833-Find-And-Replace-in-String"><a href="#Leetcode833-Find-And-Replace-in-String" class="headerlink" title="Leetcode833. Find And Replace in String"></a>Leetcode833. Find And Replace in String</h1><p>To some string S, we will perform some replacement operations that replace groups of letters with new ones (not necessarily the same size).</p>
<p>Each replacement operation has 3 parameters: a starting index i, a source word x and a target word y.  The rule is that if x starts at position i in the original string S, then we will replace that occurrence of x with y.  If not, we do nothing.</p>
<p>For example, if we have S = “abcd” and we have some replacement operation i = 2, x = “cd”, y = “ffff”, then because “cd” starts at position 2 in the original string S, we will replace it with “ffff”.</p>
<p>Using another example on S = “abcd”, if we have both the replacement operation i = 0, x = “ab”, y = “eee”, as well as another replacement operation i = 2, x = “ec”, y = “ffff”, this second operation does nothing because in the original string S[2] = ‘c’, which doesn’t match x[0] = ‘e’.</p>
<p>All these operations occur simultaneously.  It’s guaranteed that there won’t be any overlap in replacement: for example, S = “abc”, indexes = [0, 1], sources = [“ab”,”bc”] is not a valid test case.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: S = &quot;abcd&quot;, indexes = [0,2], sources = [&quot;a&quot;,&quot;cd&quot;], targets = [&quot;eee&quot;,&quot;ffff&quot;]</span><br><span class="line">Output: &quot;eeebffff&quot;</span><br><span class="line">Explanation: &quot;a&quot; starts at index 0 in S, so it&apos;s replaced by &quot;eee&quot;.</span><br><span class="line">&quot;cd&quot; starts at index 2 in S, so it&apos;s replaced by &quot;ffff&quot;.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: S = &quot;abcd&quot;, indexes = [0,2], sources = [&quot;ab&quot;,&quot;ec&quot;], targets = [&quot;eee&quot;,&quot;ffff&quot;]</span><br><span class="line">Output: &quot;eeecd&quot;</span><br><span class="line">Explanation: &quot;ab&quot; starts at index 0 in S, so it&apos;s replaced by &quot;eee&quot;. </span><br><span class="line">&quot;ec&quot; doesn&apos;t starts at index 2 in the original S, so we do nothing.</span><br></pre></td></tr></table></figure></p>
<p>Notes:</p>
<ul>
<li>0 &lt;= indexes.length = sources.length = targets.length &lt;= 100</li>
<li>0 &lt; indexes[i] &lt; S.length &lt;= 1000</li>
<li>All characters in given inputs are lowercase letters.</li>
</ul>
<p>这道题给了我们一个字符串S，并给了一个坐标数组，还有一个源字符串数组，还有目标字符串数组，意思是若某个坐标位置起，源字符串数组中对应位置的字符串出现了，将其替换为目标字符串。此题的核心操作就两个，查找和替换，需要注意的是，由于替换操作会改变原字符串，但是我们查找始终是基于最初始的S。</p>
<p>首先我们需要给indexes数组排个序，因为可能不是有序的，但是却不能直接排序，这样会丢失和sources，targets数组的对应关系，这很麻烦。所以我们新建了一个保存pair对儿的数组，将indexes数组中的数字跟其位置坐标组成pair对儿，加入新数组v中，然后给这个新数组按从大到小的方式排序。</p>
<p>下面就要开始遍历新数组v了，对于遍历到的pair对儿，取出第一个数字，保存到i，表示S中需要查找的位置，取出第二个数字，然后根据这个位置分别到sources和targets数组中取出源字符串和目标字符串，然后我们在S中的i位置，向后取出和源字符串长度相同的子串，然后比较，若正好和源字符串相等，则将其替换为目标字符串即可，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">findReplaceString</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; indices, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; sources, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; targets)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; v;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; indices.size(); ++i) &#123;</span><br><span class="line">            v.push_back(&#123;indices[i], i&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(v.begin(), v.end());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="built_in">string</span> res = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> p1 = <span class="number">0</span>, p2 = <span class="number">0</span>, i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; len &amp;&amp; p1 &lt; v.size()) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = i, j = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; indices[v[p1].second])</span><br><span class="line">                p1 ++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i == indices[v[p1].second]) &#123;</span><br><span class="line">                <span class="keyword">int</span> len2 = sources[v[p1].second].length();</span><br><span class="line">                <span class="keyword">while</span>(j &lt; len2 &amp;&amp; tmp &lt; len)  &#123;</span><br><span class="line">                    <span class="keyword">if</span> (sources[v[p1].second][j] != s[tmp]) </span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    j ++; tmp++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j == len2) &#123;</span><br><span class="line">                    res += targets[v[p1].second];</span><br><span class="line">                    p1 ++;</span><br><span class="line">                    i += len2;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    res += s[i++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i &lt; len)  </span><br><span class="line">                res += s[i++];</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; len)</span><br><span class="line">            res += s[i++];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode835-Image-Overlap"><a href="#Leetcode835-Image-Overlap" class="headerlink" title="Leetcode835. Image Overlap"></a>Leetcode835. Image Overlap</h1><p>You are given two images, img1 and img2, represented as binary, square matrices of size n x n. A binary matrix has only 0s and 1s as values.</p>
<p>We translate one image however we choose by sliding all the 1 bits left, right, up, and/or down any number of units. We then place it on top of the other image. We can then calculate the overlap by counting the number of positions that have a 1 in both images.</p>
<p>Note also that a translation does not include any kind of rotation. Any 1 bits that are translated outside of the matrix borders are erased.</p>
<p>Return the largest possible overlap.</p>
<p><img src="/img/1631001223.jpg" alt></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: img1 = [[1]], img2 = [[1]]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: img1 = [[0]], img2 = [[0]]</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure></p>
<p>经过观察</p>
<p>(0,0)-&gt;(1,1)-&gt;(0,0)-(1,1)=(-1,-1)</p>
<p>(0,1)-&gt;(1,2)-&gt;(0,1)-(1,2)=(-1,-1)</p>
<p>(1,1)-&gt;(2,2)-&gt;(1,1)-(2,2)=(-1,-1)</p>
<p>从A对应到B是把整个矩阵的坐标x轴-1， y轴-1；</p>
<p>变相就是在求所有A矩阵1的点到B矩阵1的点的X轴和Y轴距离;</p>
<p>所有坐标的取值范围在(-N—N)之间;</p>
<p>实际上就是把一个一维求距离的easy的题换成了二维的题目;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestOverlap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; A, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, n = A.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; m_map(<span class="number">2</span>*n+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>*n+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (A[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> ii = <span class="number">0</span>; ii &lt; n; ++ii) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> jj = <span class="number">0</span>; jj &lt; n; ++jj) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (B[ii][jj] == <span class="number">1</span>)</span><br><span class="line">                                ++m_map[i-ii+n][j-jj+n];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_map.size(); i ++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m_map[<span class="number">0</span>].size(); j++)</span><br><span class="line">                res = max(m_map[i][j], res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode836-Rectangle-Overlap"><a href="#Leetcode836-Rectangle-Overlap" class="headerlink" title="Leetcode836. Rectangle Overlap"></a>Leetcode836. Rectangle Overlap</h1><p>A rectangle is represented as a list [x1, y1, x2, y2], where (x1, y1) are the coordinates of its bottom-left corner, and (x2, y2) are the coordinates of its top-right corner.</p>
<p>Two rectangles overlap if the area of their intersection is positive.  To be clear, two rectangles that only touch at the corner or edges do not overlap.</p>
<p>Given two (axis-aligned) rectangles, return whether they overlap.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: rec1 = [0,0,2,2], rec2 = [1,1,3,3]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: rec1 = [0,0,1,1], rec2 = [1,0,2,1]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></p>
<p>这道题让我们求两个矩形是否是重叠，矩形的表示方法是用两个点，左下和右上点来定位的。下面的讲解是参见网友大神jayesch的帖子来的，首先，返璞归真，在玩 2D 之前，先看下 1D 上是如何运作的。对于两条线段，它们相交的话可以是如下情况：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">          x3             x4</span><br><span class="line">          |--------------|</span><br><span class="line">|--------------|</span><br><span class="line">x1             x2</span><br></pre></td></tr></table></figure></p>
<p>我们可以直观的看出一些关系： x1 &lt; x3 &lt; x2 &amp;&amp; x3 &lt; x2 &lt; x4，可以稍微化简一下：x1 &lt; x4 &amp;&amp; x3 &lt; x2。就算是调换个位置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">          x1             x2</span><br><span class="line">          |--------------|</span><br><span class="line">|--------------|</span><br><span class="line">x3             x4</span><br></pre></td></tr></table></figure></p>
<p>还是能得到同样的关系：x3 &lt; x2 &amp;&amp; x1 &lt; x4。好，下面我们进军 2D 的世界，实际上 2D 的重叠就是两个方向都同时满足 1D 的重叠条件即可。由于题目中说明了两个矩形的重合面积为正才算 overlap，就是说挨着边的不算重叠，那么两个矩形重叠主要有这四种情况：</p>
<p>1）两个矩形在矩形1的右上角重叠：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">          ____________________x4,y4</span><br><span class="line">         |                   |</span><br><span class="line">  _______|______x2,y2        |</span><br><span class="line"> |       |______|____________|</span><br><span class="line"> |      x3,y3   |</span><br><span class="line"> |______________|</span><br><span class="line">x1,y1</span><br></pre></td></tr></table></figure></p>
<p>满足的条件为：x1 &lt; x4 &amp;&amp; x3 &lt; x2 &amp;&amp; y1 &lt; y4 &amp;&amp; y3 &lt; y2</p>
<p>2）两个矩形在矩形1的左上角重叠：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   ___________________  x4,y4</span><br><span class="line">  |                   |</span><br><span class="line">  |            _______|____________x2,y2</span><br><span class="line">  |___________|_______|           |</span><br><span class="line">x3,y3         |                   | </span><br><span class="line">              |___________________|</span><br><span class="line">            x1,y1</span><br></pre></td></tr></table></figure></p>
<p>满足的条件为：x3 &lt; x2 &amp;&amp; x1 &lt; x4 &amp;&amp; y1 &lt; y4 &amp;&amp; y3 &lt; y2</p>
<p>3）两个矩形在矩形1的左下角重叠：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">          ____________________x2,y2</span><br><span class="line">         |                   |</span><br><span class="line">  _______|______x4,y4        |</span><br><span class="line"> |       |______|____________|</span><br><span class="line"> |      x1,y1   |</span><br><span class="line"> |______________|</span><br><span class="line">x3,y3</span><br></pre></td></tr></table></figure></p>
<p>满足的条件为：x3 &lt; x2 &amp;&amp; x1 &lt; x4 &amp;&amp; y3 &lt; y2 &amp;&amp; y1 &lt; y4</p>
<p>4）两个矩形在矩形1的右下角重叠：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   ___________________  x2,y2</span><br><span class="line">  |                   |</span><br><span class="line">  |            _______|____________x4,y4</span><br><span class="line">  |___________|_______|           |</span><br><span class="line">x1,y1         |                   | </span><br><span class="line">              |___________________|</span><br><span class="line">            x3,y3</span><br></pre></td></tr></table></figure></p>
<p>满足的条件为：x1 &lt; x4 &amp;&amp; x3 &lt; x2 &amp;&amp; y3 &lt; y2 &amp;&amp; y1 &lt; y4</p>
<p>仔细观察可以发现，上面四种情况的满足条件其实都是相同的，只不过顺序调换了位置，所以我们只要一行就可以解决问题了，碉堡了。。。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isRectangleOverlap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; rec1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; rec2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rec1[<span class="number">0</span>] &lt; rec2[<span class="number">2</span>] &amp;&amp; rec2[<span class="number">0</span>] &lt; rec1[<span class="number">2</span>] &amp;&amp; rec1[<span class="number">1</span>] &lt; rec2[<span class="number">3</span>] &amp;&amp; rec2[<span class="number">1</span>] &lt; rec1[<span class="number">3</span>];</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode838-Push-Dominoes"><a href="#Leetcode838-Push-Dominoes" class="headerlink" title="Leetcode838. Push Dominoes"></a>Leetcode838. Push Dominoes</h1><p>There are N dominoes in a line, and we place each domino vertically upright.</p>
<p>In the beginning, we simultaneously push some of the dominoes either to the left or to the right.</p>
<p>After each second, each domino that is falling to the left pushes the adjacent domino on the left.</p>
<p>Similarly, the dominoes falling to the right push their adjacent dominoes standing on the right.</p>
<p>When a vertical domino has dominoes falling on it from both sides, it stays still due to the balance of the forces.</p>
<p>For the purposes of this question, we will consider that a falling domino expends no additional force to a falling or already fallen domino.</p>
<p>Given a string “S” representing the initial state. S[i] = ‘L’, if the i-th domino has been pushed to the left; S[i] = ‘R’, if the i-th domino has been pushed to the right; S[i] = ‘.’, if the i-th domino has not been pushed.</p>
<p>Return a string representing the final state. </p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;.L.R...LR..L..&quot;</span><br><span class="line">Output: &quot;LL.RR.LLRRLL..&quot;</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;RR.L&quot;</span><br><span class="line">Output: &quot;RR.L&quot;</span><br><span class="line">Explanation: The first domino expends no additional force on the second domino.</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>0 &lt;= N &lt;= 10^5</li>
<li>String dominoes contains only ‘L‘, ‘R’ and ‘.’</li>
</ul>
<p>这道题给我们摆好了一个多米诺骨牌阵列，但是与一般的玩法不同的是，这里没有从一头开始推，而是在很多不同的位置分别往两个方向推，结果是骨牌各自向不同的方向倒下了，而且有的骨牌由于左右两边受力均等，依然屹立不倒，这样的话骨牌就很难受了，能不能让哥安心的倒下去？！生而为骨牌，总是要倒下去啊，就像漫天飞舞的樱花，秒速五厘米的落下，回到最终归宿泥土里。喂，不要给骨牌强行加戏好么！～ 某个位置的骨牌会不会倒，并且朝哪个方向倒，是由左右两边受到的力的大小决定的，那么可以分为下列四种情况：</p>
<p>1）R….R  -&gt;  RRRRRR</p>
<p>这是当两个向右推的操作连在一起时，那么中间的骨牌毫无悬念的都要向右边倒去。</p>
<p>2）L….L  -&gt;  LLLLLL</p>
<p>同理，</p>
<p>当两个向左推的操作连在一起时，那么中间的骨牌毫无悬念的都要向左边倒去。</p>
<p>3）L….R  -&gt;  L….R</p>
<p>当左边界的骨牌向左推，右边界的骨牌向右推，那么中间的骨牌不会收到力，所以依然保持坚挺。</p>
<p>4）R….L  -&gt; RRRLLL   or   R…..L  -&gt;  RRR.LLL</p>
<p>当左边界的骨牌向右推，右边界的骨牌向左推时，就要看中间的骨牌个数了，若是偶数，那么对半分，若是奇数，那么最中间的骨牌保持站立，其余的对半分。 </p>
<p>由于上述四种情况包含了所有的情况，所以我们的目标就是在字符串中找出中间是‘点’的小区间，为了便于我们一次遍历就处理完，我们在dominoes字符串左边加个L，右边加个R，这并不会影响骨牌倒下的情况。我们使用双指针来遍历，其中i初始化为0，j初始化为1，当j指向‘点’时，我们就跳过，目标是i指向小区间的左边界，j指向右边界，然后用 j-i-1 算出中间‘点’的个数，为0表示中间没有点。若此时 i&gt;0，则将左边界加入结果res中。若左右边界相同，那么中间的点都填成左边界，这是上述的情况一和二；若左边界是L，右边界是R，则是上述的情况三，中间还是保持点不变；若左边界是R，右边界是L，则是情况四，那么先加 mid/2 个R，再加 mid%2 个点，最后加 mid/2 个L即可。然后i更新为j，继续循环即可，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">pushDominoes</span><span class="params">(<span class="built_in">string</span> dominoes)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res = <span class="string">""</span>;</span><br><span class="line">        dominoes = <span class="string">"L"</span> + dominoes + <span class="string">"R"</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">1</span>; j &lt; dominoes.size(); ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dominoes[j] == <span class="string">'.'</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> mid = j - i - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span>) res += dominoes[i];</span><br><span class="line">            <span class="keyword">if</span> (dominoes[i] == dominoes[j]) res += <span class="built_in">string</span>(mid, dominoes[i]);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (dominoes[i] == <span class="string">'L'</span> &amp;&amp; dominoes[j] == <span class="string">'R'</span>) res += <span class="built_in">string</span>(mid, <span class="string">'.'</span>);</span><br><span class="line">            <span class="keyword">else</span> res += <span class="built_in">string</span>(mid / <span class="number">2</span>, <span class="string">'R'</span>) + <span class="built_in">string</span>(mid % <span class="number">2</span>, <span class="string">'.'</span>) + <span class="built_in">string</span>(mid / <span class="number">2</span>, <span class="string">'L'</span>);</span><br><span class="line">            i = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>下面这种解法遍历了两次字符串，第一次遍历是先把R后面的点全变成R，同时累加一个cnt数组，其中cnt[i]表示在dominoes数组中i位置时R连续出现的个数，那么拿题目中的例子1来说，第一次遍历之后，原dominoes数组，修改后的dominoes数组，以及cnt数组分别为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.L.R...LR..L..</span><br><span class="line">.L.RRRRLRRRL..</span><br><span class="line">00001230012000</span><br></pre></td></tr></table></figure></p>
<p>我们可以发现cnt数字记录的是R连续出现的个数，第一次遍历只模拟了所有往右推倒的情况，很明显不是最终答案，因为还需要往左推，那么就要把某些点变成L，已经把某些R变成点或者L，这时我们的cnt数组就非常重要，因为它相当于记录了往右推的force的大小。第二次遍历是从右往左，我们找所有L前面的位置，若其为点，则直接变为L。若其为R，那么也有可能变L，此时就要计算往左的force，通过 cnt[i+1] + 1 获得，然后跟往右的force比较，若此位置往右的force大，说明当前骨牌应该往左倒，更新此时cnt[i]为往左的force。若此时左右force相等了，说明当前骨牌不会向任意一遍倒，改为点即可，最终修改后的dominoes数组和cnt数组分别为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LL.RR.LLRRLL..</span><br><span class="line">10001210011000</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">pushDominoes</span><span class="params">(<span class="built_in">string</span> dominoes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = dominoes.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cnt(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dominoes[i - <span class="number">1</span>] == <span class="string">'R'</span> &amp;&amp; dominoes[i] == <span class="string">'.'</span>) &#123;</span><br><span class="line">                dominoes[i] = <span class="string">'R'</span>;</span><br><span class="line">                cnt[i] = cnt[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">2</span>, cur = <span class="number">0</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dominoes[i + <span class="number">1</span>] != <span class="string">'L'</span>) <span class="keyword">continue</span>;</span><br><span class="line">            cur = cnt[i + <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (dominoes[i] == <span class="string">'.'</span> || cnt[i] &gt; cur) &#123;</span><br><span class="line">                dominoes[i] = <span class="string">'L'</span>;</span><br><span class="line">                cnt[i] = cur;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dominoes[i] == <span class="string">'R'</span> &amp;&amp; cnt[i] == cur) &#123;</span><br><span class="line">                dominoes[i] = <span class="string">'.'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dominoes;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode840-Magic-Squares-In-Grid"><a href="#Leetcode840-Magic-Squares-In-Grid" class="headerlink" title="Leetcode840. Magic Squares In Grid"></a>Leetcode840. Magic Squares In Grid</h1><p>A 3 x 3 magic square is a 3 x 3 grid filled with distinct numbers from 1 to 9 such that each row, column, and both diagonals all have the same sum.</p>
<p>Given an grid of integers, how many 3 x 3 “magic square” subgrids are there?  (Each subgrid is contiguous).</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Input: [[4,3,8,4],</span><br><span class="line">        [9,5,1,9],</span><br><span class="line">        [2,7,6,2]]</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: </span><br><span class="line">The following subgrid is a 3 x 3 magic square:</span><br><span class="line">438</span><br><span class="line">951</span><br><span class="line">276</span><br><span class="line"></span><br><span class="line">while this one is not:</span><br><span class="line">384</span><br><span class="line">519</span><br><span class="line">762</span><br></pre></td></tr></table></figure></p>
<p>In total, there is only one magic square inside the given grid.</p>
<p>幻方的特点是，全体数和=3X幻和，幻和=3×中心数。在基本三阶幻方中，幻和=1+2+…+9=45/3=15，所以中心数=5。因此只要从[1,1]开始判断中间数为5，再进一步判断是否为幻方。进一步判断：首先可使用二进制数来判断是否该矩阵是由1～9的组成。再判断通过中心的4组对角值和为10，&amp;&amp; 第一行和第一列和为15。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMagic</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> chknum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> a=i<span class="number">-1</span>; a&lt;=i+<span class="number">1</span>; a++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> b=j<span class="number">-1</span>; b&lt;=j+<span class="number">1</span>; b++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[a][b]&gt;<span class="number">0</span> &amp;&amp; grid[a][b]&lt;<span class="number">10</span>)</span><br><span class="line">                chknum |= <span class="number">1</span>&lt;&lt;(grid[a][b]<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(chknum!=<span class="number">0b111111111</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(grid[i<span class="number">-1</span>][j<span class="number">-1</span>]+grid[i+<span class="number">1</span>][j+<span class="number">1</span>]==<span class="number">10</span> &amp;&amp; grid[i][j<span class="number">-1</span>]+grid[i][j+<span class="number">1</span>]==<span class="number">10</span> &amp;&amp;</span><br><span class="line">          grid[i<span class="number">-1</span>][j]+grid[i+<span class="number">1</span>][j]==<span class="number">10</span> &amp;&amp; grid[i<span class="number">-1</span>][j+<span class="number">1</span>]+grid[i+<span class="number">1</span>][j<span class="number">-1</span>]==<span class="number">10</span> &amp;&amp;</span><br><span class="line">          grid[i<span class="number">-1</span>][j<span class="number">-1</span>]+grid[i<span class="number">-1</span>][j]+grid[i<span class="number">-1</span>][j+<span class="number">1</span>]==<span class="number">15</span> &amp;&amp;</span><br><span class="line">          grid[i<span class="number">-1</span>][j<span class="number">-1</span>]+grid[i][j<span class="number">-1</span>]+grid[i+<span class="number">1</span>][j<span class="number">-1</span>]==<span class="number">15</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numMagicSquaresInside</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N=grid.size();</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;N<span class="number">-1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;N<span class="number">-1</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j]==<span class="number">5</span> &amp;&amp; isMagic(i,j,grid))&#123;</span><br><span class="line">                    res++;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode841-Keys-and-Rooms"><a href="#Leetcode841-Keys-and-Rooms" class="headerlink" title="Leetcode841. Keys and Rooms"></a>Leetcode841. Keys and Rooms</h1><p>There are N rooms and you start in room 0.  Each room has a distinct number in 0, 1, 2, …, N-1, and each room may have some keys to access the next room. </p>
<p>Formally, each room i has a list of keys rooms[i], and each key rooms[i][j] is an integer in [0, 1, …, N-1] where N = rooms.length.  A key rooms[i][j] = v opens the room with number v.</p>
<p>Initially, all the rooms start locked (except for room 0). </p>
<p>You can walk back and forth between rooms freely.</p>
<p>Return true if and only if you can enter every room.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1],[2],[3],[]]</span><br><span class="line">Output: true</span><br><span class="line">Explanation:  </span><br><span class="line">We start in room 0, and pick up key 1.</span><br><span class="line">We then go to room 1, and pick up key 2.</span><br><span class="line">We then go to room 2, and pick up key 3.</span><br><span class="line">We then go to room 3.  Since we were able to go to every room, we return true.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,3],[3,0,1],[2],[0]]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: We can&apos;t enter the room with number 2.</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>1 &lt;= rooms.length &lt;= 1000</li>
<li>0 &lt;= rooms[i].length &lt;= 1000</li>
<li>The number of keys in all rooms combined is at most 3000.</li>
</ul>
<p>这道题给了我们一些房间，房间里有一些钥匙，用钥匙可以打开对应的房间，说是起始时在房间0，问最终是否可以打开所有的房间。这不由得让博主想起了惊悚片《万能钥匙》，还真是头皮发麻啊。赶紧扯回来，这是一道典型的有向图的遍历的题，邻接链表都已经建立好了，这里直接遍历就好了，这里先用 BFS 来遍历。使用一个 HashSet 来记录访问过的房间，先把0放进去，然后使用 queue 来辅助遍历，同样将0放入。之后进行典型的 BFS 遍历，取出队首的房间，然后遍历其中的所有钥匙，若该钥匙对应的房间已经遍历过了，直接跳过，否则就将钥匙加入 HashSet。此时看若 HashSet 中的钥匙数已经等于房间总数了，直接返回 true，因为这表示所有房间已经访问过了，否则就将钥匙加入队列继续遍历。最后遍历结束后，就看 HashSet 中的钥匙数是否和房间总数相等即可，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canVisitAllRooms</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; rooms)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; visited&#123;&#123;<span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q&#123;&#123;<span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = q.front(); q.pop();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> key : rooms[t]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (visited.count(key)) <span class="keyword">continue</span>;</span><br><span class="line">                visited.insert(key);</span><br><span class="line">                <span class="keyword">if</span> (visited.size() == rooms.size()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                q.push(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> visited.size() == rooms.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>我自己的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canVisitAllRooms</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; rooms)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = rooms.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; visited(len, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        q.push(<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            visited[t] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rooms[t].size(); i ++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (visited[rooms[t][i]])</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                q.push(rooms[t][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i ++)</span><br><span class="line">            <span class="keyword">if</span> (!visited[i])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode844-Backspace-String-Compare"><a href="#Leetcode844-Backspace-String-Compare" class="headerlink" title="Leetcode844. Backspace String Compare"></a>Leetcode844. Backspace String Compare</h1><p>Given two strings S and T, return if they are equal when both are typed into empty text editors. # means a backspace character.</p>
<p>Note that after backspacing an empty text, the text will continue empty.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: S = &quot;ab#c&quot;, T = &quot;ad#c&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: Both S and T become &quot;ac&quot;.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: S = &quot;ab##&quot;, T = &quot;c#d#&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: Both S and T become &quot;&quot;.</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: S = &quot;a##c&quot;, T = &quot;#a#c&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: Both S and T become &quot;c&quot;.</span><br></pre></td></tr></table></figure></p>
<p>Example 4:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: S = &quot;a#c&quot;, T = &quot;b&quot;</span><br><span class="line">Output: false</span><br><span class="line">Explanation: S becomes &quot;c&quot; while T becomes &quot;b&quot;.</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">backspaceCompare</span><span class="params">(<span class="built_in">string</span> S, <span class="built_in">string</span> T)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; a, b;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S.length(); i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(S[i] != <span class="string">'#'</span>)</span><br><span class="line">                a.push(S[i]);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!a.empty())</span><br><span class="line">                a.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> r1 = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">while</span>(!a.empty()) &#123;</span><br><span class="line">            r1 += a.top();</span><br><span class="line">            a.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; T.length(); i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(T[i] != <span class="string">'#'</span>)</span><br><span class="line">                a.push(T[i]);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!a.empty())</span><br><span class="line">                a.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> r2 = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">while</span>(!a.empty()) &#123;</span><br><span class="line">            r2 += a.top();</span><br><span class="line">            a.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r1 == r2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>一种更好的做法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">backspaceCompare</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k=<span class="number">0</span>,p=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">'#'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                k--;</span><br><span class="line">                k=max(<span class="number">0</span>,k);</span><br><span class="line">            &#125;</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">           &#123;</span><br><span class="line">               s[k]=s[i];</span><br><span class="line">               k++;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;t.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(t[i]==<span class="string">'#'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                p--;</span><br><span class="line">                p=max(<span class="number">0</span>,p);</span><br><span class="line">            &#125;</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">           &#123;</span><br><span class="line">               t[p]=t[i];</span><br><span class="line">               p++;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k!=p)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i]!=t[i])</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode845-Longest-Mountain-in-Array-数组中最长的山"><a href="#Leetcode845-Longest-Mountain-in-Array-数组中最长的山" class="headerlink" title="Leetcode845. Longest Mountain in Array 数组中最长的山"></a>Leetcode845. Longest Mountain in Array 数组中最长的山</h1><p>Let’s call any (contiguous) subarray B (of A) a mountain if the following properties hold:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">B.length &gt;= 3</span><br></pre></td></tr></table></figure></p>
<p>There exists some <code>0 &lt; i &lt; B.length - 1</code> such that <code>B[0] &lt; B[1] &lt; ... B[i-1] &lt; B[i] &gt; B[i+1] &gt; ... &gt; B[B.length - 1]</code><br>(Note that B could be any subarray of A, including the entire array A.)</p>
<p>Given an array A of integers, return the length of the longest mountain. </p>
<p>Return 0 if there is no mountain.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,1,4,7,3,2,5]</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: The largest mountain is [1,4,7,3,2] which has length 5.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,2,2]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: There is no mountain.</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>0 &lt;= A.length &lt;= 10000</li>
<li>0 &lt;= A[i] &lt;= 10000</li>
</ul>
<p>这道题给了我们一个数组，然后定义了一种像山一样的子数组，就是先递增再递减的子数组，注意这里是强行递增或者递减的，并不存在相等的情况。那么实际上这道题就是让在数组中寻找一个位置，使得以此位置为终点的递增数组和以此位置为起点的递减数组的长度最大。而以某个位置为起点的递减数组，如果反个方向来看，其实就是就该位置为终点的递增数列，那么既然都是求最长的递增数列，我们可以分别用两个 dp 数组 up 和 down，其中<code>up[i]</code>表示以<code>i</code>位置为终点的最长递增数列的个数，<code>down[i]</code>表示以<code>i</code>位置为起点的最长递减数列的个数，这样我们正向更新<code>up</code>数组，反向更新<code>down</code>数组即可。先反向更新好了<code>down</code>之后，在正向更新<code>up</code>数组的同时，也可以更新结果<code>res</code>，当某个位置的<code>up[i]</code>和<code>down[i]</code>均大于0的时候，那么就可以用<code>up[i] + down[i] + 1</code>来更新结果<code>res</code>了，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestMountain</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, n = A.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; up(n), down(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i] &gt; A[i + <span class="number">1</span>]) down[i] = down[i + <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i] &gt; A[i - <span class="number">1</span>]) up[i] = up[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (up[i] &gt; <span class="number">0</span> &amp;&amp; down[i] &gt; <span class="number">0</span>) res = max(res, up[i] + down[i] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们可以对空间进行优化，不必使用两个数组来记录所有位置的信息，而是只用两个变量 up 和 down 来分别记录以当前位置为终点的最长递增数列的长度，和以当前位置为终点的最长递减数列的长度。 我们从 i=1 的位置开始遍历，因为山必须要有上坡和下坡，所以 i=0 的位置永远不可能成为 peak。此时再看，如果当前位置跟前面的位置相等了，那么当前位置的 up 和 down 都要重置为0，从当前位置开始找新的山，和之前的应该断开。或者是当 down 不为0，说明此时是在下坡，如果当前位置大于之前的了，突然变上坡了，那么之前的累计也需要重置为0。然后当前位置再进行判断，若大于前一个位置，则是上坡，up 自增1，若小于前一个位置，是下坡，down 自增1。当 up 和 down 同时为正数，则用 up+down+1 来更新结果 res 即可，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestMountain</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, up = <span class="number">0</span>, down = <span class="number">0</span>, n = A.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((down &amp;&amp; A[i - <span class="number">1</span>] &lt; A[i]) || (A[i - <span class="number">1</span>] == A[i])) &#123;</span><br><span class="line">                up = down = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (A[i - <span class="number">1</span>] &lt; A[i]) ++up;</span><br><span class="line">            <span class="keyword">if</span> (A[i - <span class="number">1</span>] &gt; A[i]) ++down;</span><br><span class="line">            <span class="keyword">if</span> (up &gt; <span class="number">0</span> &amp;&amp; down &gt; <span class="number">0</span>) res = max(res, up + down + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode848-Shifting-Letters"><a href="#Leetcode848-Shifting-Letters" class="headerlink" title="Leetcode848. Shifting Letters"></a>Leetcode848. Shifting Letters</h1><p>You are given a string s of lowercase English letters and an integer array shifts of the same length.</p>
<p>Call the shift() of a letter, the next letter in the alphabet, (wrapping around so that ‘z’ becomes ‘a’).</p>
<p>For example, shift(‘a’) = ‘b’, shift(‘t’) = ‘u’, and shift(‘z’) = ‘a’.<br>Now for each shifts[i] = x, we want to shift the first i + 1 letters of s, x times.</p>
<p>Return the final string after all such shifts to s are applied.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;abc&quot;, shifts = [3,5,9]</span><br><span class="line">Output: &quot;rpl&quot;</span><br><span class="line">Explanation: We start with &quot;abc&quot;.</span><br><span class="line">After shifting the first 1 letters of s by 3, we have &quot;dbc&quot;.</span><br><span class="line">After shifting the first 2 letters of s by 5, we have &quot;igc&quot;.</span><br><span class="line">After shifting the first 3 letters of s by 9, we have &quot;rpl&quot;, the answer.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;aaa&quot;, shifts = [1,2,3]</span><br><span class="line">Output: &quot;gfd&quot;</span><br></pre></td></tr></table></figure></p>
<p>题目大意：给定一组反转数，要求你将字母向前翻转（字母范围a~z）（z反转为a）</p>
<p>思路方法：这题用前缀和处理，一次性求出每个字母需要翻转的次数，否则会超时，当然要防止数据溢出，所以要将过程取余。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">shiftingLetters</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; shifts)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = shifts.size();</span><br><span class="line">        <span class="keyword">if</span> (shifts.size() == <span class="number">0</span> || s == <span class="string">""</span>)</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sums(len, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = len<span class="number">-2</span>; i &gt;= <span class="number">0</span>; i --)</span><br><span class="line">            shifts[i] = (shifts[i+<span class="number">1</span>]%<span class="number">26</span> + shifts[i]%<span class="number">26</span>) %<span class="number">26</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = len<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i --)</span><br><span class="line">            s[i] = <span class="string">'a'</span> + (s[i] - <span class="string">'a'</span> + shifts[i]%<span class="number">26</span>) % <span class="number">26</span>;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode849-Maximize-Distance-to-Closest-Person"><a href="#Leetcode849-Maximize-Distance-to-Closest-Person" class="headerlink" title="Leetcode849. Maximize Distance to Closest Person"></a>Leetcode849. Maximize Distance to Closest Person</h1><p>In a row of seats, 1 represents a person sitting in that seat, and 0 represents that the seat is empty. </p>
<p>There is at least one empty seat, and at least one person sitting.</p>
<p>Alex wants to sit in the seat such that the distance between him and the closest person to him is maximized. </p>
<p>Return that maximum distance to closest person.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,0,0,0,1,0,1]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: </span><br><span class="line">If Alex sits in the second open seat (seats[2]), then the closest person has distance 2.</span><br><span class="line">If Alex sits in any other open seat, the closest person has distance 1.</span><br><span class="line">Thus, the maximum distance to the closest person is 2.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,0,0,0]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: </span><br><span class="line">If Alex sits in the last seat, the closest person is 3 seats away.</span><br><span class="line">This is the maximum distance possible, so the answer is 3.</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ol>
<li>1 &lt;= seats.length &lt;= 20000</li>
<li>seats contains only 0s or 1s, at least one 0, and at least one 1.</li>
</ol>
<p>这道题给了我们一个只有0和1且长度为n的数组，代表n个座位，其中0表示空座位，1表示有人座。现在说是爱丽丝想找个位置坐下，但是希望能离最近的人越远越好，这个不难理解，就是想左右两边尽量跟人保持距离，让我们求这个距离最近的人的最大距离。来看题目中的例子1，有三个空位连在一起，那么爱丽丝肯定是坐在中间的位置比较好，这样跟左右两边人的距离都是2。例子2有些特别，当空位连到了末尾的时候，这里可以想像成靠墙，那么靠墙坐肯定离最远啦，所以例子2中爱丽丝坐在最右边的位子上距离左边的人距离最远为3。那么不难发现，爱丽丝肯定需要先找出最大的连续空位长度，若连续空位靠着墙了，那么就直接挨着墙坐，若两边都有人，那么就坐到空位的中间位置。如何能快速知道连续空位的长度呢，只要知道了两边人的位置，相减就是中间连续空位的个数。所以博主最先使用的方法是用一个数组来保存所有1的位置，即有人坐的位置，然后用相邻的两个位置相减，就可以得到连续空位的长度。当然，靠墙这种特殊情况要另外处理一下。当把所有1位置存入数组 nums 之后，开始遍历 nums 数组，第一个人的位置有可能不靠墙，那么他的位置坐标就是他左边靠墙的连续空位个数，直接更新结果 res 即可，因为靠墙连续空位的个数就是离右边人的最远距离。然后对于其他的位置，我们减去前一个人的位置坐标，然后除以2，更新结果 res。还有最右边靠墙的情况也要处理一下，就用 n-1 减去最后一个人的位置坐标，然后更新结果 res 即可，参见代码如下：</p>
<p>解法一：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDistToClosest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; seats)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = seats.size(), res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (seats[i] == <span class="number">1</span>) nums.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) res = max(res, nums[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">else</span> res = max(res, (nums[i] - nums[i - <span class="number">1</span>]) / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!nums.empty()) </span><br><span class="line">			res = max(res, n - <span class="number">1</span> - nums.back());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>我们也可以只用一次遍历，那么就需要在遍历的过程中统计出连续空位的个数，即连续0的个数。那么采用双指针来做，start 指向连续0的起点，初始化为0，i为当前遍历到的位置。遍历 seats 数组，跳过0的位置，当遇到1的时候，此时先判断下 start 的值，若是0的话，表明当前这段连续的空位是靠着墙的，所以要用连续空位的长度 i-start 来直接更新结果 res，否则的话就是两头有人的中间的空位，那么用长度加1除以2来更新结果 res，此时 start 要更新为 i+1，指向下一段连续空位的起始位置。for 循环退出后，还是要处理最右边靠墙的位置，用 n-start 来更新结果 res 即可，参见代码如下：</p>
<p>解法二：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDistToClosest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; seats)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = seats.size(), start = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (seats[i] != <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (start == <span class="number">0</span>) res = max(res, i - start);</span><br><span class="line">            <span class="keyword">else</span> res = max(res, (i - start + <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">            start = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res = max(res, n - start);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>讨论：这道题的一个很好的 follow up 是让我们返回爱丽丝坐下的位置，那么要在结果 res 可以被更新的时候，同时还应该记录下连续空位的起始位置 start，这样有了 start 和 最大距离 res，那么就可以定位出爱丽丝的座位了。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Leetcode/" rel="tag"># Leetcode</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/05/12/Leetcode651_700/" rel="next" title="Leetcode651 - 700">
                <i class="fa fa-chevron-left"></i> Leetcode651 - 700
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/05/15/Leetcode51_100/" rel="prev" title="Leetcode51 - 100">
                Leetcode51 - 100 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/header.jpg" alt="Hao Yu">
            
              <p class="site-author-name" itemprop="name">Hao Yu</p>
              <p class="site-description motion-element" itemprop="description">Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author</p>
          </div>
          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">348</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>
        	<audio controls="controls" loop="loop" preload="auto" src="/resource/xiaomeihao.mp3">
	        </audio>
	

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yuhao0102" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:yuh18@mails.tsinghua.edu.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode802-Find-Eventual-Safe-States"><span class="nav-number">1.</span> <span class="nav-text">Leetcode802. Find Eventual Safe States</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode804-Unique-Morse-Code-Words"><span class="nav-number">2.</span> <span class="nav-text">Leetcode804. Unique Morse Code Words</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode806-Number-of-Lines-To-Write-String"><span class="nav-number">3.</span> <span class="nav-text">Leetcode806. Number of Lines To Write String</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode807-Max-Increase-to-Keep-City-Skyline"><span class="nav-number">4.</span> <span class="nav-text">Leetcode807. Max Increase to Keep City Skyline</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode808-Soup-Servings"><span class="nav-number">5.</span> <span class="nav-text">Leetcode808. Soup Servings</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode809-Expressive-Words"><span class="nav-number">6.</span> <span class="nav-text">Leetcode809. Expressive Words</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode811-Subdomain-Visit-Count"><span class="nav-number">7.</span> <span class="nav-text">Leetcode811. Subdomain Visit Count</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode812-Largest-Triangle-Area"><span class="nav-number">8.</span> <span class="nav-text">Leetcode812. Largest Triangle Area</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode813-Largest-Sum-of-Averages"><span class="nav-number">9.</span> <span class="nav-text">Leetcode813. Largest Sum of Averages</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode814-Binary-Tree-Pruning"><span class="nav-number">10.</span> <span class="nav-text">Leetcode814. Binary Tree Pruning</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode816-Ambiguous-Coordinates"><span class="nav-number">11.</span> <span class="nav-text">Leetcode816. Ambiguous Coordinates</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode817-Linked-List-Components"><span class="nav-number">12.</span> <span class="nav-text">Leetcode817. Linked List Components</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode819-Most-Common-Word"><span class="nav-number">13.</span> <span class="nav-text">Leetcode819. Most Common Word</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode820-Short-Encoding-of-Words"><span class="nav-number">14.</span> <span class="nav-text">Leetcode820. Short Encoding of Words</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode821-Shortest-Distance-to-a-Character"><span class="nav-number">15.</span> <span class="nav-text">Leetcode821. Shortest Distance to a Character</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode822-Card-Flipping-Game"><span class="nav-number">16.</span> <span class="nav-text">Leetcode822. Card Flipping Game</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode823-Binary-Trees-With-Factors"><span class="nav-number">17.</span> <span class="nav-text">Leetcode823. Binary Trees With Factors</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode824-Goat-Latin"><span class="nav-number">18.</span> <span class="nav-text">Leetcode824. Goat Latin</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode825-Friends-Of-Appropriate-Ages"><span class="nav-number">19.</span> <span class="nav-text">Leetcode825. Friends Of Appropriate Ages</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode826-Most-Profit-Assigning-Work"><span class="nav-number">20.</span> <span class="nav-text">Leetcode826. Most Profit Assigning Work</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode830-Positions-of-Large-Groups"><span class="nav-number">21.</span> <span class="nav-text">Leetcode830. Positions of Large Groups</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode831-Masking-Personal-Information"><span class="nav-number">22.</span> <span class="nav-text">Leetcode831. Masking Personal Information</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode832-Flipping-an-Image"><span class="nav-number">23.</span> <span class="nav-text">Leetcode832. Flipping an Image</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode833-Find-And-Replace-in-String"><span class="nav-number">24.</span> <span class="nav-text">Leetcode833. Find And Replace in String</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode835-Image-Overlap"><span class="nav-number">25.</span> <span class="nav-text">Leetcode835. Image Overlap</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode836-Rectangle-Overlap"><span class="nav-number">26.</span> <span class="nav-text">Leetcode836. Rectangle Overlap</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode838-Push-Dominoes"><span class="nav-number">27.</span> <span class="nav-text">Leetcode838. Push Dominoes</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode840-Magic-Squares-In-Grid"><span class="nav-number">28.</span> <span class="nav-text">Leetcode840. Magic Squares In Grid</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode841-Keys-and-Rooms"><span class="nav-number">29.</span> <span class="nav-text">Leetcode841. Keys and Rooms</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode844-Backspace-String-Compare"><span class="nav-number">30.</span> <span class="nav-text">Leetcode844. Backspace String Compare</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode845-Longest-Mountain-in-Array-数组中最长的山"><span class="nav-number">31.</span> <span class="nav-text">Leetcode845. Longest Mountain in Array 数组中最长的山</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode848-Shifting-Letters"><span class="nav-number">32.</span> <span class="nav-text">Leetcode848. Shifting Letters</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode849-Maximize-Distance-to-Closest-Person"><span class="nav-number">33.</span> <span class="nav-text">Leetcode849. Maximize Distance to Closest Person</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>
  <div id="DvelopmentTarget">     
  </div>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart" aria-hidden="false"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>

  
</div>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_uv"> 
  本站访客数<span id="busuanzi_value_site_uv"></span>人次
</span>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  


  <script type="text/javascript" src="/js/src/love.js"></script>

</body>
</html>
