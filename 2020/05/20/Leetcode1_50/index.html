<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zn-ch">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-center-simple.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Leetcode,">










<meta name="description" content="Leetcode1.Two SumGiven an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may n">
<meta name="keywords" content="Leetcode">
<meta property="og:type" content="article">
<meta property="og:title" content="Leetcode1 - 50">
<meta property="og:url" content="http://yoursite.com/2020/05/20/Leetcode1_50/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="Leetcode1.Two SumGiven an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may n">
<meta property="og:locale" content="zn-ch">
<meta property="og:image" content="http://yoursite.com/img/20200424000800.jpg">
<meta property="og:image" content="http://yoursite.com/img/20200424001500.webp">
<meta property="og:image" content="http://yoursite.com/img/20200424001600.webp">
<meta property="og:image" content="http://yoursite.com/img/20200424001601.webp">
<meta property="og:image" content="http://yoursite.com/img/20200424001602.webp">
<meta property="og:image" content="http://yoursite.com/img/20200506154600.png">
<meta property="og:updated_time" content="2020-05-26T16:02:39.932Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Leetcode1 - 50">
<meta name="twitter:description" content="Leetcode1.Two SumGiven an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may n">
<meta name="twitter:image" content="http://yoursite.com/img/20200424000800.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/05/20/Leetcode1_50/">





  <title>Leetcode1 - 50 | Hao Yu's blog</title>
  








 
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zn-ch">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hao Yu's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">The program monkey was eaten by the siege lion.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-mybetterhalf">
          <a href="/mybetterhalf/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>
            
            mybetterhalf
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="Searching..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/20/Leetcode1_50/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Leetcode1 - 50</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-20T12:56:00+08:00">
                2020-05-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Leetcode1-Two-Sum"><a href="#Leetcode1-Two-Sum" class="headerlink" title="Leetcode1.Two Sum"></a>Leetcode1.Two Sum</h1><p>Given an array of integers, return indices of the two numbers such that they add up to a specific target.</p>
<p>You may assume that each input would have exactly one solution, and you may not use the same element twice.</p>
<p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Given nums = [2, 7, 11, 15], target = 9,</span><br><span class="line"></span><br><span class="line">Because nums[0] + nums[1] = 2 + 7 = 9,</span><br><span class="line"></span><br><span class="line">return [0, 1].</span><br></pre></td></tr></table></figure></p>
<p>也十分简单，不知道啥时候做的了，现在补上。就是找一对数，使二者之和等于target，可以暴力，也可以用巧妙的方法，下边有巧妙方法，是从solution中找的。</p>
<p>我的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        vector&lt;int&gt; result;</span><br><span class="line">        int length = nums.size(),j=-1;</span><br><span class="line">        for(int i=0;i&lt;length;i++)&#123;</span><br><span class="line">            for(j=i+1;j&lt;length;j++)</span><br><span class="line">                if(nums[j]==target-nums[i])&#123;</span><br><span class="line">                    result.push_back(i);</span><br><span class="line">                    result.push_back(j);</span><br><span class="line">                    return result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>跟我一样的方法，用java实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public int[] twoSum(int[] nums, int target) &#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">    for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">        map.put(nums[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">        int complement = target - nums[i];</span><br><span class="line">        if (map.containsKey(complement) &amp;&amp; map.get(complement) != i) &#123;</span><br><span class="line">            return new int[] &#123; i, map.get(complement) &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    throw new IllegalArgumentException(&quot;No two sum solution&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第三种方法：One-pass Hash Table<br>It turns out we can do it in one-pass. While we iterate and inserting elements into the table, we also look back to check if current element’s complement already exists in the table. If it exists, we have found a solution and return immediately.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public int[] twoSum(int[] nums, int target) &#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">    for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">        int complement = target - nums[i];</span><br><span class="line">        if (map.containsKey(complement)) &#123;</span><br><span class="line">            return new int[] &#123; map.get(complement), i &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(nums[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    throw new IllegalArgumentException(&quot;No two sum solution&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>反正都是很简单的。。。</p>
<h1 id="Leetcode2-Add-Two-Numbers"><a href="#Leetcode2-Add-Two-Numbers" class="headerlink" title="Leetcode2. Add Two Numbers"></a>Leetcode2. Add Two Numbers</h1><p>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p>
<p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p>
<p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">Output: 7 -&gt; 0 -&gt; 8</span><br><span class="line">Explanation: 342 + 465 = 807.</span><br></pre></td></tr></table></figure></p>
<p>非常简单，给两个链表，相当于两个数，不过是倒着的，然后求这两个数的和再转换成链表。只是第一次用类的方法做题，不太习惯，然后对链表的使用也快忘光了，这是一个良好的开始吧。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123;</span><br><span class="line">        long int ll1=0,ll2=0,result = 0;</span><br><span class="line">        ListNode* head=new ListNode(0);</span><br><span class="line">        ListNode* curr=head;</span><br><span class="line">        int t=0;//jinwei</span><br><span class="line">        while(l1 != NULL || l2 != NULL)&#123;</span><br><span class="line">            ll1 = (l1!=NULL)? l1-&gt;val:0;</span><br><span class="line">            ll2 = (l2!=NULL)? l2-&gt;val:0;</span><br><span class="line">            int sum=t+ll1+ll2;</span><br><span class="line">            t=sum/10;</span><br><span class="line">            curr-&gt;next=new ListNode(sum%10);</span><br><span class="line">            curr=curr-&gt;next;</span><br><span class="line">            if(l1!=NULL) l1=l1-&gt;next;</span><br><span class="line">            if(l2!=NULL) l2=l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        if(t&gt;0)</span><br><span class="line">        &#123;</span><br><span class="line">            curr-&gt;next=new ListNode(t);</span><br><span class="line">        &#125;</span><br><span class="line">        return head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode5-Longest-Palindromic-Substring"><a href="#Leetcode5-Longest-Palindromic-Substring" class="headerlink" title="Leetcode5. Longest Palindromic Substring"></a>Leetcode5. Longest Palindromic Substring</h1><p>Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.</p>
<p>Example 1:</p>
<p>Input: “babad”<br>Output: “bab”<br>Note: “aba” is also a valid answer.<br>Example 2:</p>
<p>Input: “cbbd”<br>Output: “bb”</p>
<p>dp[i][i]=1;//单个字符是回文串<br>dp[i][i+1]=1 if s[i]=s[i+1];//连续两个相同字符是回文串</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string longestPalindrome(string s) &#123;</span><br><span class="line">        int len = s.size();</span><br><span class="line">        if(len==0 || len==1)</span><br><span class="line">            return s;</span><br><span class="line">        int start = 0;</span><br><span class="line">        int max = 1;</span><br><span class="line">        </span><br><span class="line">        int dp[len][len];</span><br><span class="line">        memset(dp,0,sizeof(dp));</span><br><span class="line">        for(int i=0;i&lt;len;i++)&#123;</span><br><span class="line">            dp[i][i]=1;</span><br><span class="line">            if(i&lt;len-1 &amp;&amp; s[i]==s[i+1])&#123;</span><br><span class="line">                dp[i][i+1]=1;</span><br><span class="line">                max=2;</span><br><span class="line">                start=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">	//l表示检索的子串长度，等于3表示先检索长度为3的子串        </span><br><span class="line">        for(int l=3;l&lt;=len;l++)</span><br><span class="line">            for(int i=0;i+l-1&lt;len;i++)&#123;</span><br><span class="line">                int j=l+i-1;   //终止字符位置</span><br><span class="line">                if(s[i]==s[j] &amp;&amp; dp[i+1][j-1]==1)&#123; //状态转移</span><br><span class="line">                    dp[i][j]=1;</span><br><span class="line">                    start = i;</span><br><span class="line">                    max = l;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        return s.substr(start,max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode8-String-to-Integer-atoi"><a href="#Leetcode8-String-to-Integer-atoi" class="headerlink" title="Leetcode8. String to Integer (atoi)"></a>Leetcode8. String to Integer (atoi)</h1><p>Implement atoi which converts a string to an integer.</p>
<p>The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value.</p>
<p>The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function.</p>
<p>If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed.</p>
<p>If no valid conversion could be performed, a zero value is returned.</p>
<p>Note:</p>
<p>Only the space character ‘ ‘ is considered as whitespace character.<br>Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. If the numerical value is out of the range of representable values, INT_MAX (231 − 1) or INT_MIN (−231) is returned.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;42&quot;</span><br><span class="line">Output: 42</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;   -42&quot;</span><br><span class="line">Output: -42</span><br><span class="line">Explanation: The first non-whitespace character is &apos;-&apos;, which is the minus sign.</span><br><span class="line">             Then take as many numerical digits as possible, which gets 42.</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;4193 with words&quot;</span><br><span class="line">Output: 4193</span><br><span class="line">Explanation: Conversion stops at digit &apos;3&apos; as the next character is not a numerical digit.</span><br></pre></td></tr></table></figure></p>
<p>Example 4:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;words and 987&quot;</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: The first non-whitespace character is &apos;w&apos;, which is not a numerical </span><br><span class="line">             digit or a +/- sign. Therefore no valid conversion could be performed.</span><br></pre></td></tr></table></figure></p>
<p>Example 5:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;-91283472332&quot;</span><br><span class="line">Output: -2147483648</span><br><span class="line">Explanation: The number &quot;-91283472332&quot; is out of the range of a 32-bit signed integer.</span><br><span class="line">             Thefore INT_MIN (−231) is returned.</span><br></pre></td></tr></table></figure></p>
<p>Example 6:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;+1&quot;</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure></p>
<p>实现一个字符串转数字的函数。只需要返回位于字符串前缀最长的一个数字，如-12a就返回-12。除了正常情况还有很多的corner case，下面列举一下可能的情况：</p>
<ul>
<li>忽略前缀空格；</li>
<li>一个数字前只能有一个单元运算符（负号或者正号）；</li>
<li>读到非数字之后的余串忽略；</li>
<li>当数字不小于2147483647，认为正溢出，直接返回2147483647；</li>
<li>当数字不大于-2147483648，认为负溢出，直接返回-2147483648；</li>
<li>最好用long long存储数据避免溢出。</li>
</ul>
<p>本来是直接处理的，没想到corner case太多了，所以学习人家的办法先过滤一下前缀再处理。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">int myAtoi(string str) &#123;</span><br><span class="line">    long long result=0;</span><br><span class="line">    int i=0;</span><br><span class="line">    while(i&lt;str.length() &amp;&amp; str[i]==&apos; &apos;)</span><br><span class="line">        i++;</span><br><span class="line">     if (!isdigit (str[i]) &amp;&amp; str[i] != &apos;+&apos; &amp;&amp; str[i] != &apos;-&apos;)</span><br><span class="line">        return 0;</span><br><span class="line">    bool islittle = (str[i] == &apos;-&apos; ? true : false);</span><br><span class="line">    if (!isdigit(str[i]))</span><br><span class="line">        i++;</span><br><span class="line">    for(;i&lt;str.length();i++) &#123;</span><br><span class="line">        if(str[i]&lt;&apos;0&apos; || str[i]&gt;&apos;9&apos;)</span><br><span class="line">            break;</span><br><span class="line">        if(str[i]&gt;=&apos;0&apos; &amp;&amp; str[i]&lt;=&apos;9&apos;) &#123;</span><br><span class="line">            result = result * 10 + str[i]-&apos;0&apos;;</span><br><span class="line">            if (!islittle &amp;&amp; result &gt;= 2147483647) return 2147483647;</span><br><span class="line">            if (islittle &amp;&amp; -result &lt;= -2147483648) return -2147483648;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(islittle)</span><br><span class="line">        result = -result;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode9-Palindrome-Number"><a href="#Leetcode9-Palindrome-Number" class="headerlink" title="Leetcode9. Palindrome Number"></a>Leetcode9. Palindrome Number</h1><p>Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 121</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: -121</span><br><span class="line">Output: false</span><br><span class="line">Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 10</span><br><span class="line">Output: false</span><br><span class="line">Explanation: Reads 01 from right to left. Therefore it is not a palindrome.</span><br></pre></td></tr></table></figure></p>
<p>Follow up:</p>
<p>Could you solve it without converting the integer to a string?</p>
<p>回文数，如果是负数直接返回false，正数的话转成string再判断。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isPalindrome(int x) &#123;</span><br><span class="line">        int i=0;</span><br><span class="line">        if(x&lt;0)</span><br><span class="line">            return false;</span><br><span class="line">        int length = 0;</span><br><span class="line">        int str[100000];</span><br><span class="line">        while(x&gt;0)&#123;</span><br><span class="line">            str[i++]=(x%10);</span><br><span class="line">            x/=10;</span><br><span class="line">        &#125;</span><br><span class="line">        int middle = i/2;</span><br><span class="line">        int j=0;</span><br><span class="line">        while(j&lt;middle)&#123;</span><br><span class="line">            if(str[j]!=str[i-1-j])</span><br><span class="line">                return false;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode11-Container-With-Most-Water"><a href="#Leetcode11-Container-With-Most-Water" class="headerlink" title="Leetcode11. Container With Most Water"></a>Leetcode11. Container With Most Water</h1><p>Given n non-negative integers a1, a2, …, an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.</p>
<p>Note: You may not slant the container and n is at least 2.<br><img src="/img/20200424000800.jpg" alt></p>
<p>The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.</p>
<p>Example:</p>
<p>Input: [1,8,6,2,5,4,8,3,7]<br>Output: 49</p>
<p>给定 n 个非负整数 (a1, a2, …, an)，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条竖直线，竖直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p>
<p>说明： 你不能倾斜容器，且 n 的值至少为 2。</p>
<p>图中垂直线代表输入数组 [3,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</p>
<p>这道题在 LeetCode 中排序很靠前，相信你们都见过这道题目。题意理解起来很简单，但要做出来并不容易，尤其是得到O(n)时间复杂度的解法。即使看了答案知道了 O(n) 解法怎么做，也不一定能证明它的正确性。</p>
<p>从复杂度倒推解法：本题的暴力解法很容易得到，只需要穷举所有柱子的两两组合，对每个组合都计算一次容纳水的面积即可。暴力法的时间复杂度是 。</p>
<p>很显然，这个暴力法不会是最终的正确答案。那么我们必须做到比  的时间复杂度更小，基本上只可能是  或  的复杂度。</p>
<p>如果是  的话，肯定是使用分治法。但是分治法需要把问题规模切分，而大量的柱子两两组合落在切分后的左右两侧，不好处理。所以分治法不好做。</p>
<p>如果是  的话，我们首先会想到动态规划解法。但是动态规划的子问题之间似乎没什么关系。容纳水的面积只和左右的两个柱子的高度有关，和其他柱子没什么关系。既然找不到子问题之间的关系，我们也就不好使用动态规划方法。</p>
<p>看起来似乎走投无路了？没关系，我们还有一招双指针方法，这个方法在上篇文章中刚刚讲过。</p>
<p>双指针解法：和 Two Sum II 类似，这道题的搜索空间大小是 O(n^2) 数量级。暴力法一次考察搜索空间中的一个情况，时间复杂度自然也是 O(n^2) 。而我们希望用一种方法，一次排除多个情况，从而减少时间复杂度。</p>
<p>在一开始，我们考虑相距最远的两个柱子所能容纳水的面积。水的宽度是两根柱子之间的距离 d=8；水的高度取决于两根柱子之间较短的那个，即左边柱子的高度 h=3 。水的面积就是 8*3=24。<br><img src="/img/20200424001500.webp" alt></p>
<p>如果选择固定一根柱子，另外一根变化，水的面积会有什么变化吗？稍加思考可得：</p>
<ul>
<li>当前柱子是最两侧的柱子，水的宽度  为最大，其他的组合，水的宽度都比这个小。</li>
<li>左边柱子较短，决定了水的高度为 3。如果移动左边的柱子，新的水面高度不确定，一定不会超过右边的柱子高度 7。</li>
<li>如果移动右边的柱子，新的水面高度一定不会超过左边的柱子高度 3，也就是不会超过现在的水面高度。</li>
</ul>
<p><img src="/img/20200424001600.webp" alt></p>
<p>由此可见，如果固定左边的柱子，移动右边的柱子，那么水的高度一定不会增加，且宽度一定减少，所以水的面积一定减少。这个时候，左边的柱子和任意一个其他柱子的组合，其实都可以排除了。也就是我们可以排除掉左边的柱子了。</p>
<p>排除左边这个柱子的操作，对应于双指针解法的代码，就是指针向右移动一位。对应于搜索空间，就是削减了一行的搜索空间，如下图所示。<br><img src="/img/20200424001601.webp" alt><br>削减一行的搜索空间</p>
<p>可以看到，这个搜索空间的削减方式和 Two Sum II 问题中的形状如出一辙（其实就是我把上一篇文章里的图直接搬过来了），如果你理解了 Two Sum II 问题，那一定能秒懂这道题。</p>
<p>同样的道理，假设两根柱子是右边的较短，我们就可以排除掉右边的柱子，削减一列的搜索空间，如下图所示。</p>
<p><img src="/img/20200424001602.webp" alt><br>削减一列的搜索空间</p>
<p>这样，经过  步以后，我们就能排除所有的搜索空间，检查完所有的可能性。</p>
<p>那么，我们最终就写出了这样的双指针代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public int maxArea(int[] height) &#123;</span><br><span class="line">    int res = 0;</span><br><span class="line">    int i = 0;</span><br><span class="line">    int j = height.length - 1;</span><br><span class="line">    while (i &lt; j) &#123;</span><br><span class="line">        int area = (j - i) * Math.min(height[i], height[j]);</span><br><span class="line">        res = Math.max(res, area);</span><br><span class="line">        if (height[i] &lt; height[j]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>实话说，很少有人能在第一次接触到这一题的时候就立即想出这样巧妙的双指针解法，所以刷题提升的过程一定是伴随着“记答案”的。但是我们同时还要善于归纳和总结，因为死记硬背是个苦工夫，只有理解了思想，才能记得快、记得牢。</p>
<p>就比如 167 题的 Two Sum II 和这道题。两者都是用这样的双指针解法，从代码上看非常相似，但它们究竟为何相似呢？实际上，两道题就是因为削减搜索空间的原理相通，解题思路实际上是一模一样的。如果你能洞察这一点，那么距离举一反三也就不远了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxArea(vector&lt;int&gt;&amp; height) &#123;</span><br><span class="line">        int res = 0, i = 0, j = height.size() - 1;</span><br><span class="line">        while (i &lt; j) &#123;</span><br><span class="line">            int h = min(height[i], height[j]);</span><br><span class="line">            res = max(res, h * (j - i));</span><br><span class="line">            while (i &lt; j &amp;&amp; h == height[i]) ++i;</span><br><span class="line">            while (i &lt; j &amp;&amp; h == height[j]) --j;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode13-Roman-to-Integer"><a href="#Leetcode13-Roman-to-Integer" class="headerlink" title="Leetcode13. Roman to Integer"></a>Leetcode13. Roman to Integer</h1><p>Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.</p>
<p>Symbol       Value<br>I             1<br>V             5<br>X             10<br>L             50<br>C             100<br>D             500<br>M             1000<br>For example, two is written as II in Roman numeral, just two one’s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.</p>
<p>Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:</p>
<p>I can be placed before V (5) and X (10) to make 4 and 9.<br>X can be placed before L (50) and C (100) to make 40 and 90.<br>C can be placed before D (500) and M (1000) to make 400 and 900.<br>Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;III&quot;</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;IV&quot;</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;IX&quot;</span><br><span class="line">Output: 9</span><br></pre></td></tr></table></figure></p>
<p>Example 4:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;LVIII&quot;</span><br><span class="line">Output: 58</span><br><span class="line">Explanation: L = 50, V= 5, III = 3.</span><br></pre></td></tr></table></figure></p>
<p>Example 5:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;MCMXCIV&quot;</span><br><span class="line">Output: 1994</span><br><span class="line">Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.</span><br></pre></td></tr></table></figure></p>
<p>题目描述：通过给定Roman数字，得到我们的Integer  </p>
<p>解题思路：首先给出Roman计数规则  计数规则：  相同的数字连写，所表示的数等于这些数字相加得到的数，例如：III = 3  小的数字在大的数字右边，所表示的数等于这些数字相加得到的数，例如：VIII = 8  小的数字，限于（I、X和C）在大的数字左边，所表示的数等于大数减去小数所得的数，  例如：IV = 4  正常使用时，连续的数字重复不得超过三次  在一个数的上面画横线，表示这个数扩大1000倍（本题只考虑3999以内的数，所以用不到这条规则）  </p>
<p>罗马数字共有7个，即I（1）、V（5）、X（10）、L（50）、C（100）、D（500）和M（1000）。按照下述的规则可以表示任意正整数。需要注意的是罗马数字中没有“0”，与进位制无关。一般认为罗马数字只用来记数，而不作演算。</p>
<p>重复数次：一个罗马数字重复几次，就表示这个数的几倍。右加左减：在较大的罗马数字的右边记上较小的罗马数字，表示大数字加小数字。在较大的罗马数字的左边记上较小的罗马数字，表示大数字减小数字。左减的数字有限制，仅限于I、X、C。比如45不可以写成VL，只能是XLV但是，左减时不可跨越一个位数。比如，99不可以用IC（）表示，而是用XCIX（）表示。（等同于阿拉伯数字每位数字分别表示。）左减数字必须为一位，比如8写成VIII，而非IIX。右加数字不可连续超过三位，比如14写成XIV，而非XIIII。（见下方“数码限制”一项。）加线乘千：在罗马数字的上方加上一条横线或者加上下标的Ⅿ，表示将这个数乘以1000，即是原数的1000倍。同理，如果上方有两条横线，即是原数的1000000（）倍。数码限制：同一数码最多只能出现三次，如40不可表示为XXXX，而要表示为XL。例外：由于IV是古罗马神话主神朱庇特（即IVPITER，古罗马字母里没有J和U）的首字，因此有时用IIII代替IV。</p>
<p>这道题好就好在没有让我们来验证输入字符串是不是罗马数字，这样省掉不少功夫。需要用到 HashMap 数据结构，来将罗马数字的字母转化为对应的整数值，因为输入的一定是罗马数字，那么只要考虑两种情况即可：<br>第一，如果当前数字是最后一个数字，或者之后的数字比它小的话，则加上当前数字。<br>第二，其他情况则减去这个数字。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int romanToInt(string s) &#123;</span><br><span class="line">        map&lt;char, int&gt; big;</span><br><span class="line">        int res = 0;</span><br><span class="line">        big.insert(pair&lt;char, int&gt;(&apos;I&apos;,1));</span><br><span class="line">        big.insert(pair&lt;char, int&gt;(&apos;V&apos;,2));</span><br><span class="line">        big.insert(pair&lt;char, int&gt;(&apos;X&apos;,3));</span><br><span class="line">        big.insert(pair&lt;char, int&gt;(&apos;L&apos;,4));</span><br><span class="line">        big.insert(pair&lt;char, int&gt;(&apos;C&apos;,5));</span><br><span class="line">        big.insert(pair&lt;char, int&gt;(&apos;D&apos;,6));</span><br><span class="line">        big.insert(pair&lt;char, int&gt;(&apos;M&apos;,7));</span><br><span class="line">        int small[7]=&#123;1, 5, 10, 50, 100, 500, 1000&#125;;</span><br><span class="line">        </span><br><span class="line">        for(int i=0;i&lt;s.size()-1;i++) &#123;</span><br><span class="line">            if(big[s[i]] &gt;= big[s[i+1]])</span><br><span class="line">                res += small[big[s[i]]-1];</span><br><span class="line">            else</span><br><span class="line">                res -= small[big[s[i]]-1];</span><br><span class="line">        &#125;</span><br><span class="line">        res += small[big[s[s.size()-1]]-1];</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int romanToInt(string s) &#123;</span><br><span class="line">        int map[26];</span><br><span class="line">        map[&apos;I&apos;-&apos;A&apos;] = 1; map[&apos;V&apos;-&apos;A&apos;] = 5; map[&apos;X&apos;-&apos;A&apos;] = 10; map[&apos;L&apos;-&apos;A&apos;] = 50; </span><br><span class="line">        map[&apos;C&apos;-&apos;A&apos;] = 100; map[&apos;D&apos;-&apos;A&apos;] = 500; map[&apos;M&apos;-&apos;A&apos;] = 1000;</span><br><span class="line">        int res = 0, n = s.size();</span><br><span class="line">        s.push_back(s[n-1]);</span><br><span class="line">        for(int i = 0; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(map[s[i]-&apos;A&apos;] &gt;= map[s[i+1]-&apos;A&apos;])</span><br><span class="line">                res += map[s[i]-&apos;A&apos;];</span><br><span class="line">            else res -= map[s[i]-&apos;A&apos;];</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode15-3Sum"><a href="#Leetcode15-3Sum" class="headerlink" title="Leetcode15. 3Sum"></a>Leetcode15. 3Sum</h1><p>Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.</p>
<p>Note:</p>
<p>The solution set must not contain duplicate triplets.</p>
<p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Given array nums = [-1, 0, 1, 2, -1, -4],</span><br><span class="line"></span><br><span class="line">A solution set is:</span><br><span class="line">[</span><br><span class="line">  [-1, 0, 1],</span><br><span class="line">  [-1, -1, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>给定一个数组A，要求从A中找出这么三个元素a,b,c使得a + b + c = 0，返回由这样的a、b、c构成的三元组，且要保证三元组是唯一的。(即任意的两个三元组，它们里面的元素不能完全相同)</p>
<p>三.题解：</p>
<p>　　我们知道3和问题是由2和问题演化而来的，所以说我们可以根据2和问题的求法，来间接求解三和问题。常见的2和问题的求解方法，主要包括两种那：利用哈希表或者两用双指针。</p>
<p>而三和问题，我们可以看成是在2和问题外面加上一层for循环，所以3和问题的常用解法也是分为两种：即利用哈希表和利用双指针。下面具体介绍两种方法：</p>
<p>方法1：利用哈希表</p>
<p>这种方法的基本思想是，将数组中每个元素和它的下标构成一个键值对存入到哈希表中，在寻找的过程中对于数组中的某两个元素a、b只需在哈希表中判断是否存在-a-b即可，由于在哈希表中的查找操作的时间复杂度为O(1)，在数组中寻找寻任意的找两个元素a、b需要O(n^2)，故总的时间复杂度为O(N^2)。代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; threeSum(vector&lt;int&gt; &amp;num)</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; rs;</span><br><span class="line">        int len = num.size();</span><br><span class="line">        if(len == 0)</span><br><span class="line">            return rs;</span><br><span class="line">        sort(num.begin(),num.end());//排序是为了不重复处理后续重复出现的元素</span><br><span class="line">        for(int i = 0; i &lt; len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(i != 0 &amp;&amp; num[i] == num[i - 1])//i重复出现时不重复处理</span><br><span class="line">                continue;</span><br><span class="line">            unordered_map&lt;int,int&gt; _map;//注意建立_map的位置</span><br><span class="line">            for(int j = i + 1; j &lt; len; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(_map.find(-num[i]-num[j]) != _map.end())</span><br><span class="line">                &#123;</span><br><span class="line">                    rs.push_back(&#123;num[i],num[j],-num[i]-num[j]&#125;);</span><br><span class="line">                    while(j + 1 &lt; len &amp;&amp; num[j] == num[j + 1])//j重复出现时不重复处理</span><br><span class="line">                        j++;</span><br><span class="line">                &#125;</span><br><span class="line">                _map.insert(&#123;num[j],j&#125;);//注意_map插入的元素是根据j来的不是根据i来的</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return rs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这种方法先对数组nums进行排序，然后在双重for循环中对哈希表进行操作，时间复杂度为O(N*logN)+O(N^2)，所以总的时间复杂度为O(N^2)，空间复杂度为O(N)，典型的以时间换空间的策略。但是，有几个重要的点一定要掌握：</p>
<p>1.为什么要事先对数组nums进行排序？</p>
<p>这是因为由于题目要求的是返回的三元组必须是重复的，如果直接利用哈希表不进行特殊处理的话，最终的三元组一定会包含重复的情况，所以我们对数组进行排序是为了对最终的结果进行去重，其中去重包括i重复的情况和j重复的情况分，不注意两种情况的处理方式是不同的，i是判断与i-1是否相同；而j是判断与j+1是否相同。</p>
<p>2.关于对三元组进行去重，实际上有两种方式：</p>
<p>(1)按照本例中的形式，先对数组进行排序，在遍历的过程中遇到重复元素的情况就跳过。</p>
<p>(2)不对数组事先排序，在遍历过程中不进行特殊的处理，在得到整个三元组集合后，在对集合中的三元组进行去重，删去重复的三元组。(一个简单的思路是对集合中每个三元组进行排序，然后逐个元素进行比较来判断三元组是否重复)。(这种思路可能会比本例中的方法性能更优一些)</p>
<p>3.注意哈希表建立的位置，是首先确定i的位置后，才开始创建哈希表的；而不是先建立哈希表，再根据i和j进行遍历。此外，哈希表中存储的元素是根据j的位置来决定的，相当于每次先固定一个i，然后建立一个新的哈希表，然后在遍历j，并根据j判断哈希表。(这个过程并不难理解，自己举个例子，画个图应该就明白了)</p>
<p>然而，我利用这种方法(上述代码)，在leetcode上提交居然超时了！！！即方法1在leetcode没通过啊。</p>
<p>方法2：利用两个指针</p>
<p>这种方法是最常用的方法(leetcode上AC的代码大多都是这种方法)，主要的思想是：必须先对数组进行排序(不排序的话，就不能利用双指针的思想了，所以说对数组进行排序是个大前提)，每次固定i的位置，并利用两个指针j和k，分别指向数组的i+1位置和数组的尾元素，通过判断num[j]+num[k]与-num[i]的大小，来决定如何移动指针j和k，和leetcode上最大容器的拿到题目的思想类似。具体代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; threeSum(vector&lt;int&gt; &amp;num)</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; rs;</span><br><span class="line">        int len = num.size();</span><br><span class="line">        if(len == 0)</span><br><span class="line">            return rs;</span><br><span class="line">        sort(num.begin(),num.end());</span><br><span class="line">        for(int i = 0; i &lt; len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            int j = i + 1;</span><br><span class="line">            int k = len - 1;</span><br><span class="line">            if(i != 0 &amp;&amp; num[i] == num[i - 1])//如果遇到重复元素的情况，避免多次考虑</span><br><span class="line">                continue;</span><br><span class="line">            while(j &lt; k)//对于每一个num[i]从i之后的元素中,寻找对否存在三者之和为0的情况</span><br><span class="line">            &#123;</span><br><span class="line">                if(num[i] + num[j] +num[k] == 0)//当三者之和为0的情况</span><br><span class="line">                &#123;</span><br><span class="line">                    rs.push_back(&#123;num[i],num[j],num[k]&#125;);</span><br><span class="line">                    j++;//当此处的j,k满足时，别忘了向前/向后移动，判断下一个是否也满足</span><br><span class="line">                    k--;</span><br><span class="line">                    while(j &lt; k &amp;&amp; num[j] == num[j - 1])//如果遇到j重复的情况，也要避免重复考虑</span><br><span class="line">                        j++;</span><br><span class="line">                    while(j &lt; k &amp;&amp; num[k] == num[k + 1])//如果遇到k重复的情况，也要避免重复考虑</span><br><span class="line">                        k--;</span><br><span class="line">                &#125;</span><br><span class="line">                else if(num[i] + num[j] + num[k] &lt; 0)//三者之和小于0的情况，说明num[j]太小了，需要向后移动</span><br><span class="line">                    j++;</span><br><span class="line">                else//三者之和大于0的情况，说明num[k]太大了，需要向前移动</span><br><span class="line">                    k--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return rs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>该方法的时间复杂度为O(N*logN)+O(N^2)=O(N^2)和方法1实际上是一个数量级的，但是空间复杂度为O(1)，所以说综合比较的话，还是方法2的性能更好一些。同样地，这种方法也有几个需要注意的点：</p>
<ol>
<li>需要先对数组进行排序，一开始的时候也强调了，不排序的话整个思路就是错的；这种方法的一切都是建立在有序数组的前提下。</li>
<li>每次找到符合条件的num[j]和num[k]时，这时候，j指针要往前移动一次，同时k指针向后移动一次，避免重复操作，从而判断下个元素是否也符合</li>
<li>和方法1一样，都需要去重(且去重时，一般都是在找到满足条件的元素时才执行)，由于该方法一定要求数组是有序的，所以就按照第一种去重方法来去重就好了。但是需要注意下与第1种方法去重的不同之处：<ul>
<li>(1)i指针的去重同方法1一样，都是判断当前位置的元素与前一个位置的元素是否相同，如果相同，就忽略。这是因为前一个位置的元素已经处理过了，如果当前位置的元素与之相同的话，就没必要处理了，否则就会造成重复。</li>
<li>(2)j指针(还有k指针)的去重方法同方法1是不同的。先分析下方法1：</li>
</ul>
</li>
</ol>
<p>如果num[j]是符合条件的元素的话，并且下一个元素同num[j]相同的话，那么就没必要再去判断了，直接跳过就行了。那如果把<code>nums[j] == num[j+1]</code>改成<code>num[j] == num[j-1]</code>行吗？显然不行啊，举个例子就行，假如<code>num[j] == 1</code>且此时1正好符合，那么对于序列1,1….的话，当判断第一个1时，会把结果存入数组；如果改成<code>num[j] == num[j-1]</code>的话，判断第二个1的时候，会先把元素存入数组，然后再判断和前一个元素是否相同；即实际上这样已经发生重复操作了，如果是<code>nums[j] == num[j+1]</code>就是直接判断下一个元素，就是先判断在存储，就不会重复操作了。(也可以这样理解：由于去重操作只在找到重复元素的时候才进行，当<code>num[j]</code>满足时，如果<code>num[j+1]</code>也满足，则一定不用再判断了；而如果<code>num[j-1]与num[j]</code>相同的话，反而会把<code>num[j-1]</code>和<code>num[j]</code>都存进去了)</p>
<p>分析下方法2：</p>
<p>对于方法2中的j指针和k指针，就比较好理解了；由于在判断是满足条件的元素的话，就会j++,k–，此时j和k的位置都发生了变化，就不知道是不是满足了，所以要根据前一个元素来判断，如果现在的元素与前一个元素(对于j来说就是j-1，对于k来说就是K+1)相同的话，就直接跳过，从而避免了重复操作。</p>
<p>与方法1中的j是不同的，方法1中的j并没有执行j++操作(或者说是后执行的j++)。方法2最终在leetcode上AC了，以后还是优先使用这种的方法吧！</p>
<p>以上问题都是针对2sum和3sum，那么对于4sum。。。ksum，上述解法也是可行的。所以对于Ksum问题来讲，通常有两种思路：</p>
<ol>
<li>利用双指针。</li>
<li>利用哈希表。</li>
</ol>
<p>这两种方法的本质都是，在外层有k-2层循环嵌套，最内层循环中采用双指针或者哈希表，所以总的时间复杂度为O(N^k-1)。对于Ksum问题，如果题目要求结果不能重复的话，一定要考虑去重，去重方法，上面第一个例子也讲了。</p>
<p>实际上，对于4sum问题，还有更优的解法。主要是利用哈希表，其中哈希表类为<code>&lt;int,vector&lt;pair&lt;int,int&gt;&gt;&gt;</code>型，其中key表示的是数组中任意来年各个元素的和，value表示的这两个元素对应下标构成的pair，即pair&lt;i,j&gt;，由于对于两组不同的元素(共4个)可能存在重复的和，即key值相同，所以value对应的是一个pair构成的数组。这样的话，后面只需要两次循环找出<code>hash[target - num[i] - num[j]]</code>即可，所以总的时间复杂为<code>O(N^2)</code>,空间复杂度也为<code>O(N^2)</code>。(由于<code>pair&lt;int,int&gt;</code>本质就是个哈希表，所以这种方法的实质就是嵌套哈希表)</p>
<h1 id="Leetcode16-3Sum-Closest"><a href="#Leetcode16-3Sum-Closest" class="headerlink" title="Leetcode16. 3Sum Closest"></a>Leetcode16. 3Sum Closest</h1><p>Given an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution.</p>
<p>Example:</p>
<p>Given array nums = [-1, 2, 1, -4], and target = 1.</p>
<p>The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).</p>
<p>题目分析：首先想到的是暴力解法，遍历出所有从数组中取不同的三个数的情况，比较它们与target的距离（可以用绝对值表示），然后将距离最小的一组的和输出即可。这种方法是超时的，简单分析一下，可以知道时间复杂度为O(n^3). </p>
<p>通过分析，我们可以想到一种时间复杂度为<code>O(n^2)</code>的解法：假设数组中有len个元素，首先我们将数组中的元素按照从小到大的顺序进行排序。其次，看最终取出的三个数中的第一个数，若数组长度为n，那么有n种取法。假设取的第一个数是<code>A[i]</code>，那么第二三两个数从<code>A[i+1]~A[len]</code>中取出。找到“第一个数为<code>A[i]</code>固定，后两个数在<code>A[i]</code>后面元素中取。并且三数之和离target最近的情况。”这时，我们用两个指针j,k分别指向<code>A[i+1]</code>和<code>A[len]</code>，如果此时三数之和<code>A[i]+A[j]+A[k]&lt;target</code>，说明三数之和小了，我们将j后移一格；反之，若和大于target，则将k前移一格；直到j和k相遇为止。在这期间，保留与target最近的三数之和。一旦发现有“和等于target的情况”,立即输出即可。</p>
<p>由于取的第一个数可以是<code>A[0]</code>，<code>A[1]</code>，<code>A[2]</code>，……, <code>A[len-1]</code>，所以需要重复以上步骤n次。</p>
<p>为什么第一个数取了<code>A[i]</code>之后，第二三两个数只能在<code>A[i+1]~A[len]</code>中取呢？ 因为这样可以避免重复。假设第二个数取了<code>A[i-2]</code>，那么这样情况势必会包含在第一个数取<code>A[i-2]</code>的情况中。因为取出的三个数之间是没有顺序关系的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        int result = nums[0]+nums[1]+nums[2];</span><br><span class="line">        int dis = abs(result - target);</span><br><span class="line">        int len = nums.size();</span><br><span class="line">        if(len &lt; 3)</span><br><span class="line">            return target;</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        for (int i = 0; i &lt; len; i ++) &#123;</span><br><span class="line">            int j = i+1, k = len-1;</span><br><span class="line">            while ( j &lt; k ) &#123;</span><br><span class="line">                int temp = abs(nums[i]+nums[j]+nums[k]-target);</span><br><span class="line">                if (temp &lt; dis) &#123;</span><br><span class="line">                    dis = temp;</span><br><span class="line">                    result = nums[i]+nums[j]+nums[k];</span><br><span class="line">                &#125;                    </span><br><span class="line">                if (nums[i]+nums[j]+nums[k]&lt;target) </span><br><span class="line">                    j ++;</span><br><span class="line">                else if (nums[i]+nums[j]+nums[k]&gt;target) </span><br><span class="line">                    k --;</span><br><span class="line">                else</span><br><span class="line">                    return target;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcod17-Letter-Combinations-of-a-Phone-Number"><a href="#Leetcod17-Letter-Combinations-of-a-Phone-Number" class="headerlink" title="Leetcod17. Letter Combinations of a Phone Number"></a>Leetcod17. Letter Combinations of a Phone Number</h1><p>Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent.</p>
<p>A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.</p>
<p>Example:</p>
<p>Input: “23”<br>Output: [“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”].</p>
<p>这道题让我们求电话号码的字母组合，即数字2到9中每个数字可以代表若干个字母，然后给一串数字，求出所有可能的组合。这里可以用递归 Recursion 来解，需要建立一个字典，用来保存每个数字所代表的字符串，然后还需要一个变量 level，记录当前生成的字符串的字符个数，实现套路和上述那些题十分类似。在递归函数中首先判断 level，如果跟 digits 中数字的个数相等了，将当前的组合加入结果 res 中，然后返回。我们通过 digits 中的数字到 dict 中取出字符串，然后遍历这个取出的字符串，将每个字符都加到当前的组合后面，并调用递归函数即可，参见代码如下：</p>
<p>简单深度优先搜索，别忘了调用完dfs之后还原就行………………<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;string&gt; dict;</span><br><span class="line">    void work(string digits, vector&lt;string&gt;&amp; result, int cur, string&amp; temp) &#123;</span><br><span class="line">        if(cur == digits.length()) &#123;</span><br><span class="line">            result.push_back(temp);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=0;i&lt;dict[digits[cur]-&apos;0&apos;].length();i++) &#123;</span><br><span class="line">            temp+=dict[digits[cur]-&apos;0&apos;][i];</span><br><span class="line">            work(digits, result, cur+1, temp);</span><br><span class="line">            temp.erase(temp.length() - 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    vector&lt;string&gt; letterCombinations(string digits) &#123;</span><br><span class="line">        vector&lt;string&gt; result;</span><br><span class="line">        dict.push_back(&quot;&quot;);</span><br><span class="line">        dict.push_back(&quot;&quot;);</span><br><span class="line">        dict.push_back(&quot;abc&quot;);</span><br><span class="line">        dict.push_back(&quot;def&quot;);</span><br><span class="line">        dict.push_back(&quot;ghi&quot;);</span><br><span class="line">        dict.push_back(&quot;jkl&quot;);</span><br><span class="line">        dict.push_back(&quot;mno&quot;);</span><br><span class="line">        dict.push_back(&quot;pqrs&quot;);</span><br><span class="line">        dict.push_back(&quot;tuv&quot;);</span><br><span class="line">        dict.push_back(&quot;wxyz&quot;);</span><br><span class="line">        if(digits.length() == 0) &#123;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        string temp=&quot;&quot;;</span><br><span class="line">        work(digits, result, 0, temp);</span><br><span class="line">        </span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode18-4Sum"><a href="#Leetcode18-4Sum" class="headerlink" title="Leetcode18. 4Sum"></a>Leetcode18. 4Sum</h1><p>Given an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.</p>
<p>Note:</p>
<p>The solution set must not contain duplicate quadruplets.</p>
<p>Example:</p>
<p>Given array nums = [1, 0, -1, 0, -2, 2], and target = 0.</p>
<p>A solution set is:<br>[<br>  [-1,  0, 0, 1],<br>  [-2, -1, 1, 2],<br>  [-2,  0, 0, 2]<br>]</p>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>中文描述  给定一个数列 S ，包含 n 个整数.在 S 中找到四个元素 a, b, c, d 使得 a + b + c + d = target . 找到所有的独特的满足上述条件的四元组.  注意: 结果集包含的四元组不重复.  </p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>算法及复杂度(45 ms)  本题与第 15 题 (3Sum) 比较类似，第 15 题是求三个数的和，本题是求四个数的和.建议先去练习第 15 题.  首先，为了避免结果的重复，先对数列进行排序.依照在 15 题中提到的: 在一段数列上找到和为固定值的两个数的复杂度可以为 O(n).于是，很简单的思路是: 先固定前两个数 nums[l1], nums[l2]（使用两重循环），这样后两个数的和是固定的 target - nums[l1] - nums[l2] ，只需要在 (l2, len) 上进行和为固定值的两个数的寻找就可以了.  需要注意的是: 在算法运行过程中注意保证求出的结果不重复，控制方法参考AC代码。其实可以看出，即使求出的结果重复也可以在求出所有的结果后很容易找出所有不重复的结果,原因是根据求出的四元组的有序性。  在实现过程中，在一段数列上找到和为固定值的两个数直接使用了第 15 题中的 twoSum 函数。  时间复杂度: O(n ^ 3) . n 是数列的长度的, 排序时间复杂度为 O(nlogn) , 求解过程中:前两个数两重循环复杂度为 O(n ^ 2) , 后两个数查找过程复杂度为 O(n) , 总的时间复杂度为 O(nlogn) + O(n ^ 2) * O(n) , 即 O(n ^ 3) .  </p>
<h2 id="算法正确性"><a href="#算法正确性" class="headerlink" title="算法正确性"></a>算法正确性</h2><p>正确性证明  算法的正确性等同于枚举的正确性。  举个例子      </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 给定数列和target</span><br><span class="line">nums = [1,0,-1,0,-2,2]</span><br><span class="line">target = 0</span><br><span class="line"></span><br><span class="line">//排序数列</span><br><span class="line">nums = [-2, -1, 0, 0, 1, 2]</span><br><span class="line"></span><br><span class="line">//i = 0, j = 1, l = 2, r = 5</span><br><span class="line">nums[i] + num[j] + num[l] + num[r] = -1 &lt; target, l ++</span><br><span class="line"></span><br><span class="line">//i = 0, j = 1, l = 3, r = 5</span><br><span class="line">nums[i] + num[j] + num[l] + num[r] = -1 &lt; target, l ++</span><br><span class="line"></span><br><span class="line">//i = 0, j = 1, l = 4, r = 5</span><br><span class="line">nums[i] + num[j] + num[l] + num[r] = 0 == target, l ++ , r--, 此时l !&lt; r ,因此 j ++</span><br><span class="line"></span><br><span class="line">之后的步骤和之前类似</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        int len = nums.size();</span><br><span class="line">        for(int i=0;i&lt;len-3;i++) &#123;</span><br><span class="line">            for(int j=i+1;j&lt;len-2;j++) &#123;</span><br><span class="line">                int left = j+1, right = len-1;</span><br><span class="line">                while(left &lt; right)&#123;</span><br><span class="line">                    int sum = nums[i]+nums[j]+nums[right]+nums[left];</span><br><span class="line">                    if(sum == target) &#123;</span><br><span class="line">                        vector&lt;int&gt; out&#123;nums[i], nums[j], nums[left], nums[right]&#125;;</span><br><span class="line">                        res.push_back(out);</span><br><span class="line">                        left ++;</span><br><span class="line">                        right--;</span><br><span class="line">                        while(left&lt;right &amp;&amp; nums[left]==nums[left-1]) left++;   // 很重要的去重！</span><br><span class="line">                        while(left&lt;right &amp;&amp; nums[right]==nums[right+1]) right--;// 很重要的去重！</span><br><span class="line">                    &#125; else if(sum &gt; target) &#123;</span><br><span class="line">                        right --;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        left ++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                while(j+1&lt;len-2 &amp;&amp; nums[j]==nums[j+1]) j++;</span><br><span class="line">            &#125;</span><br><span class="line">            while(i+1&lt;len-3 &amp;&amp; nums[i]==nums[i+1]) i++;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode19-Remove-Nth-Node-From-End-of-List"><a href="#Leetcode19-Remove-Nth-Node-From-End-of-List" class="headerlink" title="Leetcode19. Remove Nth Node From End of List"></a>Leetcode19. Remove Nth Node From End of List</h1><p>Given a linked list, remove the n-th node from the end of list and return its head.</p>
<p>Example:</p>
<p>Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.</p>
<p>After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5.<br>Note:</p>
<p>Given n will always be valid.</p>
<p>Follow up:</p>
<p>Could you do this in one pass?</p>
<p>这道题让我们移除链表倒数第n个节点，限定n一定是有效的，即n不会大于链表中的元素总数。还有题目要求一次遍历解决问题，那么就得想些比较巧妙的方法了。比如首先要考虑的时，如何找到倒数第n个节点，由于只允许一次遍历，所以不能用一次完整的遍历来统计链表中元素的个数，而是遍历到对应位置就应该移除了。那么就需要用<strong>两个指针</strong>来帮助解题，pre 和 cur 指针。首先 cur 指针先向前走N步，如果此时 cur 指向空，说明N为链表的长度，则需要移除的为首元素，那么此时返回 <code>head-&gt;next</code> 即可，如果 cur 存在，再继续往下走，此时 pre 指针也跟着走，直到 cur 为最后一个元素时停止，此时 pre 指向要移除元素的前一个元素，再修改指针跳过需要移除的元素即可，pre相当于计数器了，参见代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* removeNthFromEnd(ListNode* head, int n) &#123;</span><br><span class="line">        if(!head-&gt;next) return NULL;</span><br><span class="line">        ListNode* pre=head, *cur=head;</span><br><span class="line">        for(int i=0;i&lt;n;i++)</span><br><span class="line">            cur=cur-&gt;next;</span><br><span class="line">        if(!cur) return head-&gt;next;</span><br><span class="line">        while(cur-&gt;next) &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        pre-&gt;next = pre-&gt;next-&gt;next;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode20-Valid-Parentheses"><a href="#Leetcode20-Valid-Parentheses" class="headerlink" title="Leetcode20. Valid Parentheses"></a>Leetcode20. Valid Parentheses</h1><p>Given a string containing just the characters ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[‘ and ‘]’, determine if the input string is valid.</p>
<p>An input string is valid if:</p>
<ul>
<li>Open brackets must be closed by the same type of brackets.</li>
<li>Open brackets must be closed in the correct order.</li>
<li>Note that an empty string is also considered valid.</li>
</ul>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;()&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;()[]&#123;&#125;&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;(]&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></p>
<p>Example 4:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;([)]&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></p>
<p>Example 5:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;&#123;[]&#125;&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p>
<p>算法及复杂度 (3 ms)   本题就是验证括号的顺序是否能保证正确匹配，通过自己简单的模拟就会发现：在括号的匹配过程中，右括号才是最重要的.每个右括号能且只能对应前边的一个左括号，因此每个右括号对应的左括号一定在前边出现，并且位置是确定的. </p>
<p>因此就萌生了一种模拟的思路:  遇到左括号就存起来，遇到右括号就进行匹配.  本题为什么想到用stack进行实现？在左括号的存储过程有很多结构进行实现，主要仔细分析右括号的匹配过程.不妨举个例子 s = “((()))”, 先用某种方式把左括号存起来，那么存储结果是 “(((“, 遇到第一个右括号，与前一个符号进行比对，发现是左括号（如果不是对应的左括号，就可以直接return false了，原因根据正确括号序列的定义），这样就进行了匹配，匹配成功之后，显然这一对括号已经没有作用了，因此就可以把这对括号覆盖掉或者删除掉，这里使用stack通过弹出顶部元素（即对应左括号）达到这个效果.  </p>
<p>时间复杂度: O(n). n 表示括号序列的长度，只需要一次遍历就可以完成，因此是 O(n) 的复杂度.  </p>
<p>正确性证明  模拟的思想，根据题目提供的方法在进行操作，提供的已知条件保证了算法的正确性.  举个例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//输入序列</span><br><span class="line">s = &quot;([&#123;)&quot;</span><br><span class="line"></span><br><span class="line">//分析s[0],左括号，入栈st</span><br><span class="line">st = &quot;(&quot;</span><br><span class="line"></span><br><span class="line">//分析s[1],左括号，入栈st</span><br><span class="line">st = &quot;([&quot;</span><br><span class="line"></span><br><span class="line">//分析s[2],左括号，入栈st</span><br><span class="line">st = &quot;([&#123;&quot;</span><br><span class="line"></span><br><span class="line">//分析s[3],右括号，尝试匹配st.top(),返现不匹配，返回false</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isValid(string s) &#123;</span><br><span class="line">        if(s[0] == &apos;)&apos; || s[0] == &apos;&#125;&apos; || s[0] == &apos;]&apos;) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125; else if(s.length() == 0) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        stack&lt;char&gt;st;</span><br><span class="line">        </span><br><span class="line">        st.push(s[0]);</span><br><span class="line">        for(int i = 1; i &lt; s.length(); i ++) &#123;</span><br><span class="line">            if(s[i] == &apos;)&apos;) &#123;</span><br><span class="line">                if(!st.empty() &amp;&amp; st.top() == &apos;(&apos;) &#123;</span><br><span class="line">                    st.pop();</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else if(!st.empty() &amp;&amp; s[i] == &apos;&#125;&apos;) &#123;</span><br><span class="line">                if(st.top() == &apos;&#123;&apos;) &#123;</span><br><span class="line">                    st.pop();</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else if(!st.empty() &amp;&amp; s[i] == &apos;]&apos;) &#123;</span><br><span class="line">                if(st.top() == &apos;[&apos;) &#123;</span><br><span class="line">                    st.pop();</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                st.push(s[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(st.size() == 0) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode21-Merge-Two-Sorted-Lists"><a href="#Leetcode21-Merge-Two-Sorted-Lists" class="headerlink" title="Leetcode21. Merge Two Sorted Lists"></a>Leetcode21. Merge Two Sorted Lists</h1><p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.</p>
<p>Example:</p>
<p>Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br>Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">  * Definition for singly-linked list.</span><br><span class="line">  * struct ListNode &#123;</span><br><span class="line">  *     int val;</span><br><span class="line">  *     ListNode *next;</span><br><span class="line">  *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="line">  *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="line">  *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="line">  * &#125;;</span><br><span class="line">  */</span><br><span class="line">class Solution &#123;</span><br><span class="line">	public:</span><br><span class="line">    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123;</span><br><span class="line">	        </span><br><span class="line">        ListNode* result = new ListNode(-1);</span><br><span class="line">        ListNode* cur = result;</span><br><span class="line">        while(l1 != NULL &amp;&amp; l2 != NULL) &#123;</span><br><span class="line">            if(l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">                cur-&gt;next = l1;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                cur-&gt;next = l2;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        while(l1) &#123;</span><br><span class="line">            cur-&gt;next = l1;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        while(l2) &#123;</span><br><span class="line">            cur-&gt;next = l2;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        // 上边两个while可以用这一句话代替。</span><br><span class="line">		// cur-&gt;next = l1 ? l1 : l2;</span><br><span class="line">	    return result-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode22-Generate-Parentheses"><a href="#Leetcode22-Generate-Parentheses" class="headerlink" title="Leetcode22. Generate Parentheses"></a>Leetcode22. Generate Parentheses</h1><p>Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.</p>
<p>For example, given n = 3, a solution set is:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &quot;((()))&quot;,</span><br><span class="line">  &quot;(()())&quot;,</span><br><span class="line">  &quot;(())()&quot;,</span><br><span class="line">  &quot;()(())&quot;,</span><br><span class="line">  &quot;()()()&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>这道题给定一个数字n，让生成共有n个括号的所有正确的形式，对于这种列出所有结果的题首先还是考虑用递归 Recursion 来解，由于字符串只有左括号和右括号两种字符，而且最终结果必定是左括号3个，右括号3个，所以这里定义两个变量 left 和 right 分别表示剩余左右括号的个数。</p>
<p>如果在某次递归时，左括号的个数大于右括号的个数，说明此时生成的字符串中右括号的个数大于左括号的个数，即会出现 ‘)(‘ 这样的非法串，所以这种情况直接返回，不继续处理。</p>
<p>如果 left 和 right 都为0，则说明此时生成的字符串已有3个左括号和3个右括号，且字符串合法，则存入结果中后返回。如果以上两种情况都不满足，若此时 left 大于0，则调用递归函数，注意参数的更新，若 right 大于0，则调用递归函数，同样要更新参数，参见代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;string&gt; result;</span><br><span class="line">    </span><br><span class="line">    void dfs(int left, int right, string temp) &#123;</span><br><span class="line">        if(left &gt; right) return;</span><br><span class="line">        if(left == 0 &amp;&amp; right == 0) </span><br><span class="line">            result.push_back(temp);</span><br><span class="line">        if(left &gt; 0) dfs(left-1, right, temp+&quot;(&quot;);</span><br><span class="line">        if(right &gt; 0) dfs(left, right-1, temp+&quot;)&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;string&gt; generateParenthesis(int n) &#123;    </span><br><span class="line">        dfs(n, n, &quot;&quot;);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode25-Reverse-Nodes-in-k-Group"><a href="#Leetcode25-Reverse-Nodes-in-k-Group" class="headerlink" title="Leetcode25. Reverse Nodes in k-Group"></a>Leetcode25. Reverse Nodes in k-Group</h1><p>Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.</p>
<p>k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.</p>
<p>Example:</p>
<p>Given this linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5</p>
<p>For k = 2, you should return: 2-&gt;1-&gt;4-&gt;3-&gt;5</p>
<p>For k = 3, you should return: 3-&gt;2-&gt;1-&gt;4-&gt;5</p>
<p>Note:</p>
<p>Only constant extra memory is allowed.<br>You may not alter the values in the list’s nodes, only nodes itself may be changed.</p>
<p>给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</p>
<p>把一个很长的链表分成很多个小链表，每一份的长度都是 k (最后一份的长度如果小于 k 则不需要反转)，然后对每个小链表进行反转，最后将所有反转后的小链表按之前的顺序拼接在一起。</p>
<ul>
<li>第一，在反转子链表的时候，上一个子链表的尾必须知道</li>
<li>第二，下一个子链表的头也必须知道</li>
<li>第三，当前反转的链表的头尾都必须知道</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* reverseKGroup(ListNode* head, int k) &#123;</span><br><span class="line">        if(head==NULL || head-&gt;next==NULL || k&lt;=1)&#123;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* dummy = new ListNode(0);</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        ListNode* pointer = dummy;</span><br><span class="line">        // 强行找一个前驱，整个链表的前驱</span><br><span class="line">        </span><br><span class="line">        while(pointer != NULL)&#123;</span><br><span class="line">            ListNode* lastGroup = pointer;</span><br><span class="line">            // 记录上一个子链表的尾</span><br><span class="line">            int i;</span><br><span class="line">            for(i=0;i&lt;k;i++)&#123;</span><br><span class="line">                pointer = pointer-&gt;next;</span><br><span class="line">                if(pointer==NULL)</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        	// 如果当前子链表的节点数满足 k, 就进行反转</span><br><span class="line">        	// 反之，说明程序到尾了，节点数不够，不用反转  </span><br><span class="line">        	// 每次进行交换时记得把这个子链表前一个和后一个记下来          </span><br><span class="line">            if(i==k)&#123;</span><br><span class="line">            	// 记录下一个子链表的头，作为反转时的“哨兵”</span><br><span class="line">            	// 并且在反转完之后把反转完之后的链表接起来</span><br><span class="line">                ListNode* nextGroup = pointer-&gt;next;</span><br><span class="line">                </span><br><span class="line">                // 反转当前子链表，reverse 函数返回反转后子链表的头</span><br><span class="line">                ListNode* reversedList = reverse(lastGroup-&gt;next, nextGroup);</span><br><span class="line"></span><br><span class="line">            	// lastGroup 是上一个子链表的尾，其 next 指向当前反转子链表的头</span><br><span class="line">            	// 但是因为当前链表已经被反转，所以它指向的是反转后的链表的尾                </span><br><span class="line">                pointer = lastGroup-&gt;next;</span><br><span class="line"></span><br><span class="line">                // 将上一个链表的尾连向反转后链表的头</span><br><span class="line">                lastGroup-&gt;next = reversedList;</span><br><span class="line"></span><br><span class="line">                // 当前反转后的链表的尾连向下一个子链表的头</span><br><span class="line">                pointer-&gt;next = nextGroup;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ListNode* reverse(ListNode* head, ListNode* tail) &#123;</span><br><span class="line">        if(head==NULL || head-&gt;next==NULL)&#123;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* prev = NULL, *temp = NULL;</span><br><span class="line">        while(head!=NULL &amp;&amp; head!=tail)&#123;</span><br><span class="line">            temp = head-&gt;next;</span><br><span class="line">            head-&gt;next = prev;</span><br><span class="line">            prev = head;</span><br><span class="line">            head = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        return prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode26-Remove-Duplicates-from-Sorted-Array"><a href="#Leetcode26-Remove-Duplicates-from-Sorted-Array" class="headerlink" title="Leetcode26. Remove Duplicates from Sorted Array"></a>Leetcode26. Remove Duplicates from Sorted Array</h1><p>Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Given nums = [1,1,2],</span><br><span class="line"></span><br><span class="line">Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.</span><br><span class="line"></span><br><span class="line">It doesn&apos;t matter what you leave beyond the returned length.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Given nums = [0,0,1,1,1,2,2,3,3,4],</span><br><span class="line"></span><br><span class="line">Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.</span><br><span class="line"></span><br><span class="line">It doesn&apos;t matter what values are set beyond the returned length.</span><br></pre></td></tr></table></figure></p>
<p>Clarification:</p>
<p>Confused why the returned value is an integer but your answer is an array?</p>
<p>Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well.</p>
<p>Internally you can think of this:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// nums is passed in by reference. (i.e., without making a copy)</span><br><span class="line">int len = removeDuplicates(nums);</span><br><span class="line"></span><br><span class="line">// any modification to nums in your function would be known by the caller.</span><br><span class="line">// using the length returned by your function, it prints the first len elements.</span><br><span class="line">for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>真的是非常简单的一道题，但是因为某种原因WA了好几次。。。去掉重复的数并返回去重之后的长度。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int length=nums.size();</span><br><span class="line">        if(length==0)</span><br><span class="line">            return 0;</span><br><span class="line">        int j=0;</span><br><span class="line">        for(int i=1;i&lt;length;i++)&#123;</span><br><span class="line">           if(nums[i]!=nums[j])&#123;</span><br><span class="line">                j++;</span><br><span class="line">                nums[j]=nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return j+1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode35-Search-Insert-Position"><a href="#Leetcode35-Search-Insert-Position" class="headerlink" title="Leetcode35. Search Insert Position"></a>Leetcode35. Search Insert Position</h1><p>Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.</p>
<p>You may assume no duplicates in the array.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,3,5,6], 5</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,3,5,6], 2</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,3,5,6], 7</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure></p>
<p>Example 4:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,3,5,6], 0</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure></p>
<p>只是搜索需要插入的位置罢了，很简单，遍历或者二分都行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">	public:</span><br><span class="line">    int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        if(target &lt;= nums[0])</span><br><span class="line">            return 0;</span><br><span class="line">        for(int i = 1; i &lt; nums.size(); i ++) &#123;</span><br><span class="line">            if(target &lt;= nums[i])</span><br><span class="line">                return i;</span><br><span class="line">        &#125;</span><br><span class="line">        return nums.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">	public:</span><br><span class="line">    int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        if(target &lt;= nums[0])</span><br><span class="line">            return 0;</span><br><span class="line">        int l = 0, r = nums.size(), mid;</span><br><span class="line">        while(l &lt; r) &#123;</span><br><span class="line">            mid = (l + r) / 2;</span><br><span class="line">            if(nums[mid] &gt;= target)</span><br><span class="line">                r = mid;</span><br><span class="line">            else</span><br><span class="line">                l = mid + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode36-Valid-Sudoku"><a href="#Leetcode36-Valid-Sudoku" class="headerlink" title="Leetcode36. Valid Sudoku"></a>Leetcode36. Valid Sudoku</h1><p>Determine if a 9x9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:</p>
<p>Each row must contain the digits 1-9 without repetition.<br>Each column must contain the digits 1-9 without repetition.<br>Each of the 9 3x3 sub-boxes of the grid must contain the digits 1-9 without repetition.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">  [&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],</span><br><span class="line">  [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],</span><br><span class="line">  [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]</span><br><span class="line">]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">  [&quot;8&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],</span><br><span class="line">  [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],</span><br><span class="line">  [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]</span><br><span class="line">]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></p>
<p>Explanation: Same as Example 1, except with the 5 in the top left corner being<br>    modified to 8. Since there are two 8’s in the top left 3x3 sub-box, it is invalid.<br>Note:</p>
<p>A Sudoku board (partially filled) could be valid but is not necessarily solvable.<br>Only the filled cells need to be validated according to the mentioned rules.<br>The given board contain only digits 1-9 and the character ‘.’.<br>The given board size is always 9x9.</p>
<p>横向、纵向不能存在重复的，而这道题目还加上了每一个<code>3*3</code>的九宫格也不能存在重复元素。根据上述分析，比较自然的可以想到创建三个列表储存目标数据，然而进行比较是否存在重复元素，进而进行相关判断。其中对于3*3的九宫格的索引值计算是一个需要思考的点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123;</span><br><span class="line">        int block_num, digit;</span><br><span class="line">        bool map[3][9][9];</span><br><span class="line">        for(int i=0;i&lt;3;i++)</span><br><span class="line">            for(int j=0;j&lt;9;j++)</span><br><span class="line">                for(int k=0;k&lt;9;k++)</span><br><span class="line">                    map[i][j][k]=false;</span><br><span class="line">        </span><br><span class="line">        for(int i=0;i&lt;9;i++)</span><br><span class="line">            for(int j=0;j&lt;9;j++)</span><br><span class="line">                if(board[i][j]!=&apos;.&apos;) &#123;</span><br><span class="line">                    block_num = i/3*3+j/3;</span><br><span class="line">                    digit = board[i][j]-&apos;1&apos;;</span><br><span class="line">                    if(map[0][i][digit]==true || map[1][j][digit]==true || map[2][block_num][digit]==true) </span><br><span class="line">                        return false;</span><br><span class="line">                    map[0][i][digit] = true;</span><br><span class="line">                    map[1][j][digit] = true;</span><br><span class="line">                    map[2][block_num][digit] = true;</span><br><span class="line">                &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode39-Combination-Sum"><a href="#Leetcode39-Combination-Sum" class="headerlink" title="Leetcode39. Combination Sum"></a>Leetcode39. Combination Sum</h1><p>Given a set of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.</p>
<p>The same repeated number may be chosen from candidates unlimited number of times.</p>
<p>Note:</p>
<p>All numbers (including target) will be positive integers.<br>The solution set must not contain duplicate combinations.<br>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: candidates = [2,3,6,7], target = 7,</span><br><span class="line">A solution set is:</span><br><span class="line">[</span><br><span class="line">  [7],</span><br><span class="line">  [2,2,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: candidates = [2,3,5], target = 8,</span><br><span class="line">A solution set is:</span><br><span class="line">[</span><br><span class="line">  [2,2,2,2],</span><br><span class="line">  [2,3,3],</span><br><span class="line">  [3,5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>本题采用回溯算法。</p>
<ol>
<li>基本思路是先排好序，这样做的目的是为了对数组后面不可能出现的情况进行排除，有利于减少查找时间，即剪枝操作</li>
<li>外层循环对数组元素依次进行遍历，依次将 nums 中的元素加入中间集，一旦满足条件，就将中间集加入结果集</li>
<li>然后每次递归中把剩下的元素一一加到结果集合中，并且把目标减去加入的元素，然后把剩下元素（包括当前加入的元素）放到下一层递归中解决子问题。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; result;</span><br><span class="line">    </span><br><span class="line">    void dfs(vector&lt;int&gt;&amp; candidates, vector&lt;int&gt; cur, int start, int target) &#123;</span><br><span class="line">        if(target == 0) &#123;</span><br><span class="line">            result.push_back(cur);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = start; i &lt; candidates.size(); i ++) &#123;</span><br><span class="line">            if(candidates[i] &gt; target) </span><br><span class="line">                break;</span><br><span class="line">            cur.push_back(candidates[i]);</span><br><span class="line">            dfs(candidates, cur, i, target - candidates[i]);</span><br><span class="line">            cur.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) &#123;</span><br><span class="line">        sort(candidates.begin(), candidates.end());</span><br><span class="line">        dfs(candidates, vector&lt;int&gt;(), 0, target);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode40-Combination-Sum-II"><a href="#Leetcode40-Combination-Sum-II" class="headerlink" title="Leetcode40. Combination Sum II"></a>Leetcode40. Combination Sum II</h1><p>Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.</p>
<p>Each number in candidates may only be used once in the combination.</p>
<p>Note:</p>
<ul>
<li>All numbers (including target) will be positive integers.</li>
<li>The solution set must not contain duplicate combinations.</li>
</ul>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: candidates = [10,1,2,7,6,1,5], target = 8,</span><br><span class="line">	A solution set is:</span><br><span class="line">	[</span><br><span class="line">	  [1, 7],</span><br><span class="line">	  [1, 2, 5],</span><br><span class="line">	  [2, 6],</span><br><span class="line">	  [1, 1, 6]</span><br><span class="line">	]</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: candidates = [2,5,2,1,2], target = 5,</span><br><span class="line">A solution set is:</span><br><span class="line">[</span><br><span class="line">  [1,2,2],</span><br><span class="line">  [5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>我的dfs，一开始没有剪枝，所以很慢，首先排序，然后在dfs的时候，如果有必要就return，如果碰到相同的跳过。排序很重要：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution&#123;</span><br><span class="line">    public:</span><br><span class="line">    </span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; result;</span><br><span class="line">    </span><br><span class="line">    void dfs(vector&lt;int&gt; candidates, int i, int length, vector&lt;int&gt; res, int current)&#123;</span><br><span class="line">        if(current == 0) &#123;</span><br><span class="line">            result.push_back(res);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(current &lt; 0)</span><br><span class="line">            return;</span><br><span class="line">        for(int ii = i; ii &lt; length; ii ++)&#123;</span><br><span class="line">            if(ii &gt; i &amp;&amp; candidates[ii] == candidates[ii-1])</span><br><span class="line">                continue;</span><br><span class="line">            res.push_back(candidates[ii]);</span><br><span class="line">            dfs(candidates, ii+1, length, res, current - candidates[ii]);</span><br><span class="line">            res.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target)&#123;</span><br><span class="line">        sort(candidates.begin(), candidates.end());</span><br><span class="line">        dfs(candidates, 0, candidates.size(), vector&lt;int&gt;&#123;&#125;, target);</span><br><span class="line">        return result;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>大佬的做法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution&#123;</span><br><span class="line">    public:</span><br><span class="line">    </span><br><span class="line">	vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) &#123;</span><br><span class="line">	    vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">    	vector&lt;int&gt; current;</span><br><span class="line">	    sort(candidates.begin(),candidates.end());</span><br><span class="line">    	backTracking(candidates.begin(),current,res,candidates,target);</span><br><span class="line">    	return res;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	void backTracking(vector&lt;int&gt;::iterator n, vector&lt;int&gt;&amp; current, vector&lt;vector&lt;int&gt;&gt;&amp; res, const vector&lt;int&gt;&amp; candidates, int target)&#123;</span><br><span class="line">    	if(!target) </span><br><span class="line">			res.push_back(current);</span><br><span class="line">    	else if(target &gt; 0)&#123;</span><br><span class="line">        	for( ; n != candidates.end() &amp;&amp; *n &lt;= target; ++ n)&#123;</span><br><span class="line">            	current.push_back(*n);</span><br><span class="line">	            backTracking(n+1, current, res, candidates, target-*n);</span><br><span class="line">    	        current.pop_back();</span><br><span class="line">        	    while(n + 1 != candidates.end() &amp;&amp; *(n+1) == *n) </span><br><span class="line">					++n;</span><br><span class="line">        	&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode41-First-Missing-Positive"><a href="#Leetcode41-First-Missing-Positive" class="headerlink" title="Leetcode41. First Missing Positive"></a>Leetcode41. First Missing Positive</h1><p>Given an unsorted integer array, find the smallest missing positive integer.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,0]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,4,-1,1]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [7,8,9,11,12]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<p>Your algorithm should run in O(n) time and uses constant extra space.</p>
<p>把出现的数值放到与下标一致的位置，再判断什么位置最先出现不连续的数值，就是答案了。</p>
<p>在判断的时候，只要是已经到位了的元素即：<code>A[i] - 1 == i</code>了，那么判断如果有重复元素两个位置交换就最好考虑好两个位置出现的可能情况。考虑问题全面，两个条件都考虑好。</p>
<p>增加i!=A[i]表示i位置没到位，A[A[i]-1] != A[i]表示A[i]-1位置没到位，两个位置都判断也很好的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int firstMissingPositive(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        for(int i = 0;i &lt; n; i ++) &#123;</span><br><span class="line">            if( nums[i] &gt; 0 &amp;&amp; nums[i] &lt; n ) &#123;</span><br><span class="line">                if( nums[i] != nums[nums[i] - 1]) &#123;</span><br><span class="line">                    swap(nums[i], nums[nums[i] - 1]);</span><br><span class="line">                    i--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int j = 0; j &lt; n; j ++) &#123;</span><br><span class="line">			if (nums[j] - 1 != j)</span><br><span class="line">				return j + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return n + 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode42-Trapping-Rain-Water"><a href="#Leetcode42-Trapping-Rain-Water" class="headerlink" title="Leetcode42. Trapping Rain Water"></a>Leetcode42. Trapping Rain Water</h1><p>Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.</p>
<p><img src="/img/20200506154600.png" alt></p>
<p>The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Thanks Marcos for contributing this image!</p>
<p>Example:</p>
<p>Input: [0,1,0,2,1,0,1,3,2,1,2,1]<br>Output: 6</p>
<p>给你n个非负整数表示n个连续区域各自的海拔，每个区域宽度为1，问一场足够大的雨后有多少单位的水能储存在里面。也可以理解成在一个有若干黑块和白块的矩形中，有多少个白块的左边和右边（不一定相邻）都至少有一个黑块。</p>
<p>解题思路（1）：<br>可以开个二维矩阵存每个位置是黑块还是白块，然后一行一行扫描，记下最左和左右的黑块位置l、r和总黑块数cnt，这一行的答案就为r-l-cnt+2，最终答案就是每一行的答案和。这种方法时空复杂度都为O(n*max(height))，当数据很大的时候这种方法是不能接受的。</p>
<p>解题思路（2）：<br>开两个栈，一个栈s存海拔，另一个栈id存该海拔对应的位置。对n个海拔从左往右扫描，对第i个海拔为height[i]的区域，初始化之前海拔变量pre为0，检查栈顶，当栈不空且s栈的栈顶海拔<code>s.top()&lt;=height[i]</code>的时候，重复下列操作：答案增加<code>(i-id.top()-1)*(s.top()-pre)</code>，然后pre更新为<code>s.top()</code>，弹出两个栈的栈顶。需要注意的是退出来后如果栈不空则还要增加答案<code>(i-id.top()-1)*(height[i]-pre)</code>，然后再把<code>height[i]</code>和i分别压入s和id栈。这个思路时空复杂度均为O(n)，完全可以接受。</p>
<p>算法正确性：<br>算法的关键点在于栈的存储和答案计算的部分。关于栈的存储，由于扫描是从左往右进行的，因此如果出现一个高海拔区域会把左边所有低海拔区域都挡住，后面的计算就不需要用到这些低海拔的区域了，所以从栈底到栈顶海拔逐渐减小。关于答案计算，可以理解为从低到高依次计算一个小矩形的面积，长为当前区域和栈顶区域的距离，宽为栈顶或当前区域与上次计算区域的高度差。</p>
<p>下面举一个简单例子走一遍算法帮助理解：[2,1,0,4,2,3]。初始时s栈和id栈均为空，答案ans为0。</p>
<p>第一步：height[0]=2，pre置为0，检查栈顶，栈s为空，直接将2压入s栈，0压入id栈；</p>
<p>第二步：height[1]=1，pre置为0，检查栈顶，s.top()=2&gt;1，直接将1压入s栈，1压入id栈；</p>
<p>第三步：height[2]=0，pre置为0，检查栈顶，s.top()=1&gt;0，直接将0压入s栈，2压入id栈；</p>
<p>第四步：height[3]=4，pre置为0，检查栈顶，s.top()=0&lt;4，ans增加<code>(i-id.top()-1)(s.top()-pre)=0</code>，<code>pre=s.top()=0</code>，弹出s和id栈的栈顶，继续；</p>
<p>检查栈顶，<code>s.top()=1&lt;4</code>，ans增加<code>(i-id.top()-1)(s.top()-pre)=1</code>，<code>pre=s.top()=1</code>，弹出s和id栈的栈顶，继续；</p>
<p>检查栈顶，<code>s.top()=2&lt;4</code>，ans增加<code>(i-id.top()-1)(s.top()-pre)=2</code>，<code>pre=s.top()=2</code>，弹出s和id栈的栈顶，继续；</p>
<p>检查栈顶，栈s为空，直接将4压入s栈，3压入id栈；</p>
<p>第五步：height[4]=2，pre置为0，检查栈顶，s.top()=4&gt;2，直接将2压入s栈，4压入id栈；</p>
<p>第六步：height[5]=3，pre置为0，检查栈顶，s.top()=2&lt;3，ans增加<code>(i-id.top()-1)(s.top()-pre)=0</code>，<code>pre=s.top()=0</code>，弹出s和id栈的栈顶，继续；</p>
<p>检查栈顶，s.top()=4&lt;3，跳出，ans增加<code>(i-id.top()-1)*(s.top()-pre)=1</code>，<code>pre=s.top()=2</code>，将3压入s栈，5压入id栈。</p>
<p>最终ans为4。</p>
<p>CPP代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">int trap(vector&lt;int&gt;&amp; height)</span><br><span class="line">&#123;</span><br><span class="line">    int ans=0;</span><br><span class="line">    stack&lt;int&gt; s,id;</span><br><span class="line">    int len=height.size();</span><br><span class="line">    for(int i=0;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int pre=0;//前一次计算的海拔，初始化为0</span><br><span class="line">        while(!s.empty()&amp;&amp;height[i]&gt;=s.top())//栈不空且当前海拔不小于栈顶海拔</span><br><span class="line">        &#123;</span><br><span class="line">            ans=ans+(i-id.top()-1)*(s.top()-pre);//更新答案</span><br><span class="line">            pre=s.top();//更新上一次计算的海拔</span><br><span class="line">            s.pop();</span><br><span class="line">            id.pop();//栈顶元素弹出</span><br><span class="line">        &#125;</span><br><span class="line">        if(!s.empty())//退出后如果栈不空还需要再计算一次</span><br><span class="line">        &#123;</span><br><span class="line">            ans=ans+(i-id.top()-1)*(height[i]-pre);</span><br><span class="line">            pre=s.top();</span><br><span class="line">        &#125;</span><br><span class="line">        s.push(height[i]);</span><br><span class="line">        id.push(i);//压栈</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode45-Jump-Game-II"><a href="#Leetcode45-Jump-Game-II" class="headerlink" title="Leetcode45. Jump Game II"></a>Leetcode45. Jump Game II</h1><p>Given an array of non-negative integers, you are initially positioned at the first index of the array.</p>
<p>Each element in the array represents your maximum jump length at that position.</p>
<p>Your goal is to reach the last index in the minimum number of jumps.</p>
<p>Example:</p>
<p>Input: [2,3,1,1,4]<br>Output: 2<br>Explanation: The minimum number of jumps to reach the last index is 2.<br>    Jump 1 step from index 0 to 1, then 3 steps to the last index.<br>Note:</p>
<p>You can assume that you can always reach the last index.</p>
<p>关键的问题1：到底什么时候总步数+1呢？</p>
<ul>
<li>回答：假设到遍历到数组index=i的位置，在此之前jump到的位置为k；在位置k最远可以到达的范围是<code>[k,reach]</code>，如果<code>reach&lt;i</code>，说明<code>[k-reach]</code>之间必须再jump一次，这样才能保证i在可以reach的范围内！</li>
</ul>
<p>关键问题2：那究竟在<code>[k-reach]</code>的哪个位置再次jump呢？</p>
<ul>
<li>回答：根据贪心算法，应该挑可以reach范围最远的那个点，如果需要求jump game的最短次数的jump路径，就需要记录这个点了。</li>
</ul>
<p>定义两个变量，一个是reach，记下来可以到达的最远距离，另一个是lastreach，是上一步到达的最远距离。对每一个i，代表可以到达的位置，这个位置一定是小于reach的，如果i比上次能够到达的位置大了，就更新。在更新当前的i能够到达的最远位置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int jump(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int res = 0, cur=0;</span><br><span class="line">        int reach=nums[0], lastreach=0;</span><br><span class="line">        for(int i = 0;i &lt;= reach &amp;&amp; i &lt; nums.size(); i ++) &#123;</span><br><span class="line">            if (i &gt; lastreach) &#123;</span><br><span class="line">                res++;</span><br><span class="line">                lastreach = reach;</span><br><span class="line">            &#125;</span><br><span class="line">            reach = max(reach, i + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Leetcode/" rel="tag"># Leetcode</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/05/15/Leetcode51_100/" rel="next" title="Leetcode51 - 100">
                <i class="fa fa-chevron-left"></i> Leetcode51 - 100
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/header.jpg" alt="Hao Yu">
            
              <p class="site-author-name" itemprop="name">Hao Yu</p>
              <p class="site-description motion-element" itemprop="description">Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author</p>
          </div>
          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">237</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>
        	<audio controls="controls" loop="loop" preload="auto" src="/resource/xiaomeihao.mp3">
	        </audio>
	

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yuhao0102" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:yuh18@mails.tsinghua.edu.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1-Two-Sum"><span class="nav-number">1.</span> <span class="nav-text">Leetcode1.Two Sum</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode2-Add-Two-Numbers"><span class="nav-number">2.</span> <span class="nav-text">Leetcode2. Add Two Numbers</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode5-Longest-Palindromic-Substring"><span class="nav-number">3.</span> <span class="nav-text">Leetcode5. Longest Palindromic Substring</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode8-String-to-Integer-atoi"><span class="nav-number">4.</span> <span class="nav-text">Leetcode8. String to Integer (atoi)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode9-Palindrome-Number"><span class="nav-number">5.</span> <span class="nav-text">Leetcode9. Palindrome Number</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode11-Container-With-Most-Water"><span class="nav-number">6.</span> <span class="nav-text">Leetcode11. Container With Most Water</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode13-Roman-to-Integer"><span class="nav-number">7.</span> <span class="nav-text">Leetcode13. Roman to Integer</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode15-3Sum"><span class="nav-number">8.</span> <span class="nav-text">Leetcode15. 3Sum</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode16-3Sum-Closest"><span class="nav-number">9.</span> <span class="nav-text">Leetcode16. 3Sum Closest</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcod17-Letter-Combinations-of-a-Phone-Number"><span class="nav-number">10.</span> <span class="nav-text">Leetcod17. Letter Combinations of a Phone Number</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode18-4Sum"><span class="nav-number">11.</span> <span class="nav-text">Leetcode18. 4Sum</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题意"><span class="nav-number">11.1.</span> <span class="nav-text">题意</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#题解"><span class="nav-number">11.2.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算法正确性"><span class="nav-number">11.3.</span> <span class="nav-text">算法正确性</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode19-Remove-Nth-Node-From-End-of-List"><span class="nav-number">12.</span> <span class="nav-text">Leetcode19. Remove Nth Node From End of List</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode20-Valid-Parentheses"><span class="nav-number">13.</span> <span class="nav-text">Leetcode20. Valid Parentheses</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode21-Merge-Two-Sorted-Lists"><span class="nav-number">14.</span> <span class="nav-text">Leetcode21. Merge Two Sorted Lists</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode22-Generate-Parentheses"><span class="nav-number">15.</span> <span class="nav-text">Leetcode22. Generate Parentheses</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode25-Reverse-Nodes-in-k-Group"><span class="nav-number">16.</span> <span class="nav-text">Leetcode25. Reverse Nodes in k-Group</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode26-Remove-Duplicates-from-Sorted-Array"><span class="nav-number">17.</span> <span class="nav-text">Leetcode26. Remove Duplicates from Sorted Array</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode35-Search-Insert-Position"><span class="nav-number">18.</span> <span class="nav-text">Leetcode35. Search Insert Position</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode36-Valid-Sudoku"><span class="nav-number">19.</span> <span class="nav-text">Leetcode36. Valid Sudoku</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode39-Combination-Sum"><span class="nav-number">20.</span> <span class="nav-text">Leetcode39. Combination Sum</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode40-Combination-Sum-II"><span class="nav-number">21.</span> <span class="nav-text">Leetcode40. Combination Sum II</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode41-First-Missing-Positive"><span class="nav-number">22.</span> <span class="nav-text">Leetcode41. First Missing Positive</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode42-Trapping-Rain-Water"><span class="nav-number">23.</span> <span class="nav-text">Leetcode42. Trapping Rain Water</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode45-Jump-Game-II"><span class="nav-number">24.</span> <span class="nav-text">Leetcode45. Jump Game II</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>
  <div id="DvelopmentTarget">     
  </div>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart" aria-hidden="false"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>

  
</div>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_uv"> 
  本站访客数<span id="busuanzi_value_site_uv"></span>人次
</span>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  


  <script type="text/javascript" src="/js/src/love.js"></script>

</body>
</html>
