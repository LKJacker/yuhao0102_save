<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zn-ch">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-center-simple.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Leetcode,">










<meta name="description" content="Leetcode1103. Distribute Candies to PeopleWe distribute some number of candies, to a row of n = num_people people in the following way: We then give 1 candy to the first person, 2 candies to the secon">
<meta name="keywords" content="Leetcode">
<meta property="og:type" content="article">
<meta property="og:title" content="Leetcode1101 - 1150">
<meta property="og:url" content="http://yoursite.com/2020/05/05/Leetcode1101_1150/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="Leetcode1103. Distribute Candies to PeopleWe distribute some number of candies, to a row of n = num_people people in the following way: We then give 1 candy to the first person, 2 candies to the secon">
<meta property="og:locale" content="zn-ch">
<meta property="og:image" content="http://yoursite.com/img/20190813008.png">
<meta property="og:image" content="http://yoursite.com/img/20220127160100.png">
<meta property="og:updated_time" content="2022-01-29T07:25:41.915Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Leetcode1101 - 1150">
<meta name="twitter:description" content="Leetcode1103. Distribute Candies to PeopleWe distribute some number of candies, to a row of n = num_people people in the following way: We then give 1 candy to the first person, 2 candies to the secon">
<meta name="twitter:image" content="http://yoursite.com/img/20190813008.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/05/05/Leetcode1101_1150/">





  <title>Leetcode1101 - 1150 | Hao Yu's blog</title>
  








 
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zn-ch">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hao Yu's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">The program monkey was eaten by the siege lion.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/resume.pdf" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-mybetterhalf">
          <a href="/mybetterhalf/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>
            
            mybetterhalf
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/05/Leetcode1101_1150/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Leetcode1101 - 1150</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-05T15:09:00+08:00">
                2020-05-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Leetcode1103-Distribute-Candies-to-People"><a href="#Leetcode1103-Distribute-Candies-to-People" class="headerlink" title="Leetcode1103. Distribute Candies to People"></a>Leetcode1103. Distribute Candies to People</h1><p>We distribute some number of candies, to a row of n = num_people people in the following way:</p>
<p>We then give 1 candy to the first person, 2 candies to the second person, and so on until we give n candies to the last person.</p>
<p>Then, we go back to the start of the row, giving n + 1 candies to the first person, n + 2 candies to the second person, and so on until we give 2 * n candies to the last person.</p>
<p>This process repeats (with us giving one more candy each time, and moving to the start of the row after we reach the end) until we run out of candies.  The last person will receive all of our remaining candies (not necessarily one more than the previous gift).</p>
<p>Return an array (of length num_people and sum candies) that represents the final distribution of candies.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: candies = 7, num_people = 4</span><br><span class="line">Output: [1,2,3,1]</span><br><span class="line">Explanation:</span><br><span class="line">On the first turn, ans[0] += 1, and the array is [1,0,0,0].</span><br><span class="line">On the second turn, ans[1] += 2, and the array is [1,2,0,0].</span><br><span class="line">On the third turn, ans[2] += 3, and the array is [1,2,3,0].</span><br><span class="line">On the fourth turn, ans[3] += 1 (because there is only one candy left), and the final array is [1,2,3,1].</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: candies = 10, num_people = 3</span><br><span class="line">Output: [5,2,3]</span><br><span class="line">Explanation: </span><br><span class="line">On the first turn, ans[0] += 1, and the array is [1,0,0].</span><br><span class="line">On the second turn, ans[1] += 2, and the array is [1,2,0].</span><br><span class="line">On the third turn, ans[2] += 3, and the array is [1,2,3].</span><br><span class="line">On the fourth turn, ans[0] += 4, and the final array is [5,2,3].</span><br></pre></td></tr></table></figure></p>
<p>只考虑每次分配的糖果数，分配的糖果数为1,2,3,4,5,…, 依次加1。再考虑到分配的轮数，可以利用 i % num_people 来求得第i次应该分配到第几个人。</p>
<p>最后要注意的是，如果当前糖果数小于本应该分配的糖果数，则将当前糖果全部给予，也就是要判断剩余糖果数 candies 与本该分配糖果数 i+1 的大小，谁小分配谁</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; distributeCandies(<span class="keyword">int</span> candies, <span class="keyword">int</span> num_people) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(num_people, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">1</span>, i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(candies &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            res[i%num_people] += min(candies, i+<span class="number">1</span>);</span><br><span class="line">            candies -= min(candies, i+<span class="number">1</span>);</span><br><span class="line">            i ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode1104-Path-In-Zigzag-Labelled-Binary-Tree"><a href="#Leetcode1104-Path-In-Zigzag-Labelled-Binary-Tree" class="headerlink" title="Leetcode1104. Path In Zigzag Labelled Binary Tree"></a>Leetcode1104. Path In Zigzag Labelled Binary Tree</h1><p>In an infinite binary tree where every node has two children, the nodes are labelled in row order.</p>
<p>In the odd numbered rows (ie., the first, third, fifth,…), the labelling is left to right, while in the even numbered rows (second, fourth, sixth,…), the labelling is right to left.</p>
<p><img src="/img/20190813008.png" alt></p>
<p>Given the label of a node in this tree, return the labels in the path from the root of the tree to the node with that label.</p>
<p>Example 1:</p>
<p>Input: label = 14<br>Output: [1,3,4,14]<br>Example 2:</p>
<p>Input: label = 26<br>Output: [1,2,6,10,26]</p>
<p>Constraints:</p>
<p>1 &lt;= label &lt;= 10^6</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pathInZigZagTree(<span class="keyword">int</span> label) &#123;</span><br><span class="line">        build(label);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> label)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> level;</span><br><span class="line">        <span class="keyword">int</span> lastMin;</span><br><span class="line">        res.insert(res.begin(), label);</span><br><span class="line">        <span class="keyword">if</span>(label != <span class="number">1</span>)&#123;</span><br><span class="line">            level = (<span class="keyword">int</span>)(<span class="built_in">log</span>(label)/<span class="built_in">log</span>(<span class="number">2</span>));</span><br><span class="line">            lastMin = <span class="built_in">pow</span>(<span class="number">2</span>, level)/<span class="number">2</span>;</span><br><span class="line">            build( lastMin + (lastMin*<span class="number">2</span>)<span class="number">-1</span> - label/<span class="number">2</span> );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>因为不管是奇数行还是偶数行，该行与上一行的方向都是反着来的</p>
<p>可以先求出顺着来时这个结点对应的父结点，再求出对应父结点在它所在行对称的结点</p>
<p>这里有个求对称的方法：按顺序排列且每个数都能找到对称数的一系列数，每一对对陈数的和都相同，所以求某个数的在某一行的对称数，只用找出这一行两端的数，求出和，再减去这个数就能得到这个数的对称数</p>
<p>所以只用从传进来的这个结点递归，每次递归求出自己对应的父结点，递归到1时结束，每次递归记录一次当前结点的号码</p>
<p>最后得到的一系列结点号码就是路径</p>
<h1 id="Leetcode1105-Filling-Bookcase-Shelves"><a href="#Leetcode1105-Filling-Bookcase-Shelves" class="headerlink" title="Leetcode1105. Filling Bookcase Shelves"></a>Leetcode1105. Filling Bookcase Shelves</h1><p>You are given an array books where books[i] = [thicknessi, heighti] indicates the thickness and height of the ith book. You are also given an integer shelfWidth.</p>
<p>We want to place these books in order onto bookcase shelves that have a total width shelfWidth.</p>
<p>We choose some of the books to place on this shelf such that the sum of their thickness is less than or equal to shelfWidth, then build another level of the shelf of the bookcase so that the total height of the bookcase has increased by the maximum height of the books we just put down. We repeat this process until there are no more books to place.</p>
<p>Note that at each step of the above process, the order of the books we place is the same order as the given sequence of books.</p>
<p>For example, if we have an ordered list of 5 books, we might place the first and second book onto the first shelf, the third book on the second shelf, and the fourth and fifth book on the last shelf.<br>Return the minimum possible height that the total bookshelf can be after placing shelves in this manner.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: books = [[1,1],[2,3],[2,3],[1,1],[1,1],[1,1],[1,2]], shelf_width = 4</span><br><span class="line">Output: 6</span><br><span class="line">Explanation:</span><br><span class="line">The sum of the heights of the 3 shelves is 1 + 3 + 2 = 6.</span><br><span class="line">Notice that book number 2 does not have to be on the first shelf.</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/20220127160100.png" alt></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: books = [[1,3],[2,4],[3,2]], shelfWidth = 6</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure></p>
<p>这道题说是让用书来填书架，每本书有其固定的宽和高，需要按给定的顺序来排列书，要么排在新的一行，要么排在之前的层，注意每层的宽度不能超过给定的 shelf_width 的限制，每层的高度按照最高的那本书来计算，问怎么安排才能使得整个书架的高度最小。这种数组玩极值的题目，大概率就是贪婪算法或者动态规划 Dynamic Programming，但是这里贪婪算法就不太合适，因为书的高度是不确定的，就算尽量每行尽可能的多放书，并不能保证整体的高度是最小的。所以只能祭出动态规划了，先来定义 DP 数组，这里使用一个一维的 dp 数组，其中<code>dp[i]</code>表示前i本书可以组成的最小高度，大小初始化为<code>n+1</code>。接下来找动态转移方程，对于每一本新的书，最差的结果就是放到新的一行中，这样整个高度就增加了当前书的高度，所以<code>dp[i]</code>可以先赋值为<code>dp[i-1] + height</code>，然后再进行优化。方法是不停加上之前的书，条件是总宽度不能超过给定值，高度选其中最高的一个，每次用<code>dp[j] + height</code>来更新<code>dp[i]</code>，最终返回<code>dp[n]</code>即可，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minHeightShelves</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; books, <span class="keyword">int</span> sw)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = books.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(len+<span class="number">1</span>, INT_MAX);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i ++) &#123;</span><br><span class="line">            <span class="keyword">int</span> h = <span class="number">0</span>, w = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= <span class="number">0</span>; j --) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((w += books[j][<span class="number">0</span>]) &gt; sw)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                h = max(h, books[j][<span class="number">1</span>]);</span><br><span class="line">                dp[i] = min(dp[i], (j == <span class="number">0</span> ? <span class="number">0</span> : dp[j<span class="number">-1</span>]) + h);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1108-Defanging-an-IP-Address"><a href="#Leetcode1108-Defanging-an-IP-Address" class="headerlink" title="Leetcode1108. Defanging an IP Address"></a>Leetcode1108. Defanging an IP Address</h1><p>Given a valid (IPv4) IP address, return a defanged version of that IP address.</p>
<p>A defanged IP address replaces every period “.” with “[.]”.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: address = &quot;1.1.1.1&quot;</span><br><span class="line">Output: &quot;1[.]1[.]1[.]1&quot;</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: address = &quot;255.100.50.0&quot;</span><br><span class="line">Output: &quot;255[.]100[.]50[.]0&quot;</span><br></pre></td></tr></table></figure></p>
<p>Constraints:</p>
<ul>
<li>The given address is a valid IPv4 address.</li>
</ul>
<p>把IP地址中的“.”换成“[.]”，没有难度。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">defangIPaddr</span><span class="params">(<span class="built_in">string</span> address)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">string</span> <span class="title">answer</span><span class="params">(address.length()+<span class="number">6</span>,<span class="string">'\0'</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>;i&lt;address.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(address[i]==<span class="string">'.'</span>)&#123;</span><br><span class="line">                answer[j++]=<span class="string">'['</span>;</span><br><span class="line">                answer[j++]=<span class="string">'.'</span>;</span><br><span class="line">                answer[j++]=<span class="string">']'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">				answer[j++]=address[i];</span><br><span class="line">	    &#125;</span><br><span class="line">	<span class="keyword">return</span> answer;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode1109-Corporate-Flight-Bookings"><a href="#Leetcode1109-Corporate-Flight-Bookings" class="headerlink" title="Leetcode1109. Corporate Flight Bookings"></a>Leetcode1109. Corporate Flight Bookings</h1><p>There are n flights that are labeled from 1 to n.</p>
<p>You are given an array of flight bookings bookings, where bookings[i] = [firsti, lasti, seatsi] represents a booking for flights firsti through lasti (inclusive) with seatsi seats reserved for each flight in the range.</p>
<p>Return <em>an array answer of length n, where answer[i] is the total number of seats reserved for flight </em>i.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: bookings = [[1,2,10],[2,3,20],[2,5,25]], n = 5</span><br><span class="line">Output: [10,55,45,25,25]</span><br><span class="line">Explanation:</span><br><span class="line">Flight labels:        1   2   3   4   5</span><br><span class="line">Booking 1 reserved:  10  10</span><br><span class="line">Booking 2 reserved:      20  20</span><br><span class="line">Booking 3 reserved:      25  25  25  25</span><br><span class="line">Total seats:         10  55  45  25  25</span><br><span class="line">Hence, answer = [10,55,45,25,25]</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: bookings = [[1,2,10],[2,2,15]], n = 2</span><br><span class="line">Output: [10,25]</span><br><span class="line">Explanation:</span><br><span class="line">Flight labels:        1   2</span><br><span class="line">Booking 1 reserved:  10  10</span><br><span class="line">Booking 2 reserved:      15</span><br><span class="line">Total seats:         10  25</span><br><span class="line">Hence, answer = [10,25]</span><br></pre></td></tr></table></figure></p>
<p>Constraints:</p>
<ul>
<li>1 &lt;= n &lt;= 2 * 104</li>
<li>1 &lt;= bookings.length &lt;= 2 * 104</li>
<li>bookings[i].length == 3</li>
<li>1 &lt;= firsti &lt;= lasti &lt;= n</li>
<li>1 &lt;= seatsi &lt;= 104</li>
</ul>
<p>这道题说是有n个航班，标号从1到n，每次公司可以连续预定多个航班上的座位，用一个三元数组 [i, j, k]，表示分别预定航班i到j上的k个座位，最后问每个航班上总共被预定了多少个座位。博主先试了一下暴力破解，毫无意外的超时了，想想为啥会超时，因为对于每个预定的区间，都遍历一次的话，最终可能达到n的平方级的复杂度。所以就需要想一些节省运算时间的办法，其实这道的解法很巧妙，先来想想，假如只有一个预定，是所有航班上均订k个座位，那么暴力破解的方法就是从1遍历到n，然后每个都加上k，但还有一种方法，就是只在第一天加上k，然后计算累加和数组，这样之后的每一天都会被加上k。如果是预定前一半的航班，那么暴力破解的方法就是从1遍历到 n/2，而这里的做法是在第一个天加上k，在第 n/2 + 1 天减去k，这样再求累加和数组时，后一半的航班就不会加上k了。对于所有的预定都可以采用这种做法，在起始位置加上k，在结束位置加1处减去k，最后再整体算累加和数组，这样就把平方级的时间复杂度缩小到了线性，完美通过 OJ，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; corpFlightBookings(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; bookings, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> booking : bookings) &#123;</span><br><span class="line">            res[booking[<span class="number">0</span>] - <span class="number">1</span>] += booking[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span> (booking[<span class="number">1</span>] &lt; n) res[booking[<span class="number">1</span>]] -= booking[<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            res[i] += res[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode1110-Delete-Nodes-And-Return-Forest"><a href="#Leetcode1110-Delete-Nodes-And-Return-Forest" class="headerlink" title="Leetcode1110. Delete Nodes And Return Forest"></a>Leetcode1110. Delete Nodes And Return Forest</h1><p>Given the root of a binary tree, each node in the tree has a distinct value.</p>
<p>After deleting all nodes with a value in to_delete, we are left with a forest (a disjoint union of trees).</p>
<p>Return the roots of the trees in the remaining forest. You may return the result in any order.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [1,2,3,4,5,6,7], to_delete = [3,5]</span><br><span class="line">Output: [[1,2,null,4],[6],[7]]</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [1,2,4,null,3], to_delete = [3]</span><br><span class="line">Output: [[1,2,4]]</span><br></pre></td></tr></table></figure></p>
<p>Constraints:</p>
<ul>
<li>The number of nodes in the given tree is at most 1000.</li>
<li>Each node has a distinct value between 1 and 1000.</li>
<li>to_delete.length &lt;= 1000</li>
<li>to_delete contains distinct values between 1 and 1000.</li>
</ul>
<p>这道题给了一棵二叉树，说了每个结点值均不相同，现在让删除一些结点，由于删除某些位置的结点会使原来的二叉树断开，从而会形成多棵二叉树，形成一片森林，让返回森林中所有二叉树的根结点。对于二叉树的题，十有八九都是用递归来做的，这道题也不例外，先来想一下这道题的难点在哪里，去掉哪些点会形成新树，显而易见的是，去掉根结点的话，左右子树若存在的话一定会形成新树，同理，去掉子树的根结点，也可能会形成新树，只有去掉叶结点时才不会生成新树，所以当前结点是不是根结点就很重要了，这个需要当作一个参数传入。由于需要知道当前结点是否需要被删掉，每次都遍历 to_delete 数组显然不高效，那就将其放入一个 HashSet 中，从而到达常数级的搜索时间。这样递归函数就需要四个参数，当前结点，是否是根结点的布尔型变量，HashSet，还有结果数组 res。在递归函数中，首先判空，然后判断当前结点值是否在 HashSet，用一个布尔型变量 deleted 来记录。若当前是根结点，且不需要被删除，则将这个结点加入结果 res 中。然后将左子结点赋值为对左子结点调用递归函数的返回值，右子结点同样赋值为对右子结点调用递归的返回值，最后判断当前结点是否被删除了，是的话返回空指针，否则就返回当前指针，这样的话每棵树的根结点都在递归的过程中被存入结果 res 中了，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;TreeNode*&gt; delNodes(TreeNode* root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; to_delete) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt; res;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; st(to_delete.begin(), to_delete.end());</span><br><span class="line">        helper(root, <span class="literal">true</span>, st, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">helper</span><span class="params">(TreeNode* node, <span class="keyword">bool</span> is_root, <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt;&amp; st, <span class="built_in">vector</span>&lt;TreeNode*&gt;&amp; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">bool</span> deleted = st.count(node-&gt;val);</span><br><span class="line">        <span class="keyword">if</span> (is_root &amp;&amp; !deleted) res.push_back(node);</span><br><span class="line">        node-&gt;left = helper(node-&gt;left, deleted, st, res);</span><br><span class="line">        node-&gt;right = helper(node-&gt;right, deleted, st, res);</span><br><span class="line">        <span class="keyword">return</span> deleted ? <span class="literal">nullptr</span> : node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1111-Maximum-Nesting-Depth-of-Two-Valid-Parentheses-Strings"><a href="#Leetcode1111-Maximum-Nesting-Depth-of-Two-Valid-Parentheses-Strings" class="headerlink" title="Leetcode1111. Maximum Nesting Depth of Two Valid Parentheses Strings"></a>Leetcode1111. Maximum Nesting Depth of Two Valid Parentheses Strings</h1><p>A string is a valid parentheses string (denoted VPS) if and only if it consists of “(“ and “)” characters only, and:</p>
<p>It is the empty string, or</p>
<ul>
<li>It can be written as AB (A concatenated with B), where A and B are VPS’s, or</li>
<li>It can be written as (A), where A is a VPS.</li>
</ul>
<p>We can similarly define the nesting depth depth(S) of any VPS S as follows:</p>
<ul>
<li>depth(“”) = 0</li>
<li>depth(A + B) = max(depth(A), depth(B)), where A and B are VPS’s</li>
<li>depth(“(“ + A + “)”) = 1 + depth(A), where A is a VPS.</li>
</ul>
<p>For example,  “”, “()()”, and “()(()())” are VPS’s (with nesting depths 0, 1, and 2), and “)(“ and “(()” are not VPS’s.</p>
<p>Given a VPS seq, split it into two disjoint subsequences A and B, such that A and B are VPS’s (and A.length + B.length = seq.length).</p>
<p>Now choose any such A and B such that max(depth(A), depth(B)) is the minimum possible value.</p>
<p>Return an answer array (of length seq.length) that encodes such a choice of A and B:  answer[i] = 0 if seq[i] is part of A, else answer[i] = 1.  Note that even though multiple answers may exist, you may return any of them.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: seq = &quot;(()())&quot;</span><br><span class="line">Output: [0,1,1,1,1,0]</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: seq = &quot;()(())()&quot;</span><br><span class="line">Output: [0,0,0,1,1,0,1,1]</span><br></pre></td></tr></table></figure></p>
<p>Constraints:</p>
<ul>
<li>1 &lt;= seq.size &lt;= 10000</li>
</ul>
<p>题目很简单，就是将一个集合拆分为两个depth最接近的两个集合。所以我们需要先计算出总的depth(S)是多少，然后将其除2就得到了其中一个集合的depth(A)，然后就可以计算出另外一个集合的depth(B)=depth(S)-depth(A)。</p>
<p>接着考虑如何将两个集合挑选出来，也是非常容易的，我们只需要再次遍历seq，记录遍历的’(‘的数目，如果’(‘的数目超过了As（A集合的depth）的话，我们就将对应的字符标记为B集合的即可（也就是标记为1）。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; maxDepthAfterSplit(<span class="built_in">string</span> seq) &#123;</span><br><span class="line">        <span class="keyword">int</span> ds=<span class="number">0</span>,cur=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;seq.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(seq[i]==<span class="string">'('</span>)&#123;</span><br><span class="line">                cur+=<span class="number">1</span>;</span><br><span class="line">                ds=max(ds,cur);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cur-=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> as=ds/<span class="number">2</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(seq.length(),<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;seq.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(seq[i]==<span class="string">'('</span>)&#123;</span><br><span class="line">                cur+=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(cur&gt;as)</span><br><span class="line">                    res[i]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(cur&gt;as)</span><br><span class="line">                    res[i]=<span class="number">1</span>;</span><br><span class="line">                cur-=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1114-Print-in-Order"><a href="#Leetcode1114-Print-in-Order" class="headerlink" title="Leetcode1114. Print in Order"></a>Leetcode1114. Print in Order</h1><p>Suppose we have a class:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Foo &#123;</span><br><span class="line">  public void first() &#123; print(&quot;first&quot;); &#125;</span><br><span class="line">  public void second() &#123; print(&quot;second&quot;); &#125;</span><br><span class="line">  public void third() &#123; print(&quot;third&quot;); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>The same instance of Foo will be passed to three different threads. Thread A will call first(), thread B will call second(), and thread C will call third(). Design a mechanism and modify the program to ensure that second() is executed after first(), and third() is executed after second().</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3]</span><br><span class="line">Output: &quot;firstsecondthird&quot;</span><br><span class="line">Explanation: There are three threads being fired asynchronously. The input [1,2,3] means thread A calls first(), thread B calls second(), and thread C calls third(). &quot;firstsecondthird&quot; is the correct output.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,3,2]</span><br><span class="line">Output: &quot;firstsecondthird&quot;</span><br><span class="line">Explanation: The input [1,3,2] means thread A calls first(), thread B calls third(), and thread C calls second(). &quot;firstsecondthird&quot; is the correct output.</span><br></pre></td></tr></table></figure></p>
<p>现在三个线程，每个线程分别调用三个函数中的一个。无论线程的产生和调用关系怎么样，最终输出的结果要求都是”firstsecondthird”。如何设计是三个函数。这个是Leetcode的新题型，也就是说并发类型，我觉得很实用，工作中能用到。一般情况下，最简单的协调不同线程之间的调度关系，都可以使用mutex来做，本质是信号量。</p>
<p><code>std::mutex</code>的成员函数有四个：</p>
<ul>
<li>构造函数，std::mutex不允许拷贝构造，也不允许 move 拷贝，最初产生的 mutex 对象是处于 unlocked 状态的。</li>
<li><code>lock()</code>，调用线程将锁住该互斥量。线程调用该函数会发生下面 3 种情况：<ul>
<li>(1). 如果该互斥量当前没有被锁住，则调用线程将该互斥量锁住，直到调用 unlock之前，该线程一直拥有该锁。</li>
<li>(2). 如果当前互斥量被其他线程锁住，则当前的调用线程被阻塞住。</li>
<li>(3). 如果当前互斥量被当前调用线程锁住，则会产生死锁(deadlock)。</li>
</ul>
</li>
<li><code>unlock()</code>， 解锁，释放对互斥量的所有权。</li>
<li><code>try_lock()</code>，尝试锁住互斥量，如果互斥量被其他线程占有，则当前线程也不会被阻塞。线程调用该函数也会出现下面 3 种情况，<ul>
<li>(1). 如果当前互斥量没有被其他线程占有，则该线程锁住互斥量，直到该线程调用 unlock 释放互斥量。</li>
<li>(2). 如果当前互斥量被其他线程锁住，则当前调用线程返回 false，而并不会被阻塞掉。</li>
<li>(3). 如果当前互斥量被当前调用线程锁住，则会产生死锁(deadlock)。</li>
</ul>
</li>
</ul>
<p>也就是说一个锁能控制两个线程的执行顺序。这个题中我们需要保持三个函数是按顺序执行的，则需要两个锁m1和m2。在开始的时候，两个锁都锁起来。first()可以直接执行，second()等待m1释放之后执行，third()等待m2释放之后执行。first()结束之后释放m1，second()结束之后释放m2.因此三个的顺序都协调一致了。C++代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">    mutex m1, m2;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    Foo() &#123;</span><br><span class="line">	        m1.lock();</span><br><span class="line">	        m2.lock();</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">first</span><span class="params">(function&lt;<span class="keyword">void</span>()&gt; printFirst)</span> </span>&#123;</span><br><span class="line">	        <span class="comment">// printFirst() outputs "first". Do not change or remove this line.</span></span><br><span class="line">	        printFirst();</span><br><span class="line">	        m1.unlock();</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">second</span><span class="params">(function&lt;<span class="keyword">void</span>()&gt; printSecond)</span> </span>&#123;</span><br><span class="line">	        m1.lock();</span><br><span class="line">	        <span class="comment">// printSecond() outputs "second". Do not change or remove this line.</span></span><br><span class="line">	        printSecond();</span><br><span class="line">	        m1.unlock();</span><br><span class="line">	        m2.unlock();</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">third</span><span class="params">(function&lt;<span class="keyword">void</span>()&gt; printThird)</span> </span>&#123;</span><br><span class="line">	        m2.lock();</span><br><span class="line">	        <span class="comment">// printThird() outputs "third". Do not change or remove this line.</span></span><br><span class="line">	        printThird();</span><br><span class="line">	        m2.unlock();</span><br><span class="line">	    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1122-Relative-Sort-Array"><a href="#Leetcode1122-Relative-Sort-Array" class="headerlink" title="Leetcode1122. Relative Sort Array"></a>Leetcode1122. Relative Sort Array</h1><p>Given two arrays arr1 and arr2, the elements of arr2 are distinct, and all elements in arr2 are also in arr1.</p>
<p>Sort the elements of arr1 such that the relative ordering of items in arr1 are the same as in arr2.  Elements that don’t appear in arr2 should be placed at the end of arr1 in ascending order.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: arr1 = [2,3,1,3,2,4,6,7,9,2,19], arr2 = [2,1,4,3,9,6]</span><br><span class="line">Output: [2,2,2,1,4,3,3,9,6,7,19]</span><br></pre></td></tr></table></figure></p>
<p>Constraints:</p>
<ul>
<li>arr1.length, arr2.length &lt;= 1000</li>
<li>0 &lt;= arr1[i], arr2[i] &lt;= 1000</li>
<li>Each arr2[i] is distinct.</li>
<li>Each arr2[i] is in arr1.</li>
</ul>
<p>arr2 中的元素各不相同，arr2 中的每个元素都出现在 arr1 中，对 arr1 中的元素进行排序，使 arr1 中项的相对顺序和 arr2 中的相对顺序相同。未在 arr2 中出现过的元素需要按照升序放在 arr1 的末尾。</p>
<p>基本思路是：</p>
<ol>
<li>首先题目的意思是按照arr2的元素顺序返回arr1的元素，假定返回的新数组为arr3，然后把剩余的arr1元素按照升序顺序拼接到arr3后边返回</li>
<li>遍历一遍arr1使用map [Int:Int] 记录每一个元素的次数</li>
<li>遍历arr2，把在arr2出现的元素当做key取出value值，arr3 add value次key值</li>
<li>把剩余的字典键值对所对应的key值排序，添加到arr3后边</li>
<li>时间复杂度 O(nlogn)</li>
<li>空间复杂度 O(n)</li>
</ol>
<p><strong>注意map是有序的，内部是用平衡树存储，而unordered_map是用hash做的，也不能保证插入的顺序</strong>，因此这里使用了大佬的做法<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; relativeSortArray(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr2) &#123;</span><br><span class="line">        <span class="keyword">int</span> count_arr[<span class="number">1001</span>];</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="built_in">memset</span>(count_arr, <span class="number">0</span>, <span class="keyword">sizeof</span>(count_arr));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr1.size();i++)</span><br><span class="line">            count_arr[arr1[i]]++;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr2.size();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> len = count_arr[arr2[i]];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;len;j++)</span><br><span class="line">                ans.push_back(arr2[i]);</span><br><span class="line">            count_arr[arr2[i]]=<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr1.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(count_arr[arr1[i]] &gt; <span class="number">0</span>) s.push_back(arr1[i]);</span><br><span class="line">        &#125;        </span><br><span class="line">        sort(s.begin(), s.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.size();i++)</span><br><span class="line">            ans.push_back(s[i]);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1123-Lowest-Common-Ancestor-of-Deepest-Leaves"><a href="#Leetcode1123-Lowest-Common-Ancestor-of-Deepest-Leaves" class="headerlink" title="Leetcode1123. Lowest Common Ancestor of Deepest Leaves"></a>Leetcode1123. Lowest Common Ancestor of Deepest Leaves</h1><p>Given a rooted binary tree, return the lowest common ancestor of its deepest leaves.</p>
<p>Recall that:</p>
<ul>
<li>The node of a binary tree is a leaf if and only if it has no children</li>
<li>The depth of the root of the tree is 0, and if the depth of a node is d, the depth of each of its children is d+1.</li>
<li>The lowest common ancestor of a set S of nodes is the node A with the largest depth such that every node in S is in the subtree with root A.</li>
</ul>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [1,2,3]</span><br><span class="line">Output: [1,2,3]</span><br><span class="line">Explanation: </span><br><span class="line">The deepest leaves are the nodes with values 2 and 3.</span><br><span class="line">The lowest common ancestor of these leaves is the node with value 1.</span><br><span class="line">The answer returned is a TreeNode object (not an array) with serialization &quot;[1,2,3]&quot;.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [1,2,3,4]</span><br><span class="line">Output: [4]</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [1,2,3,4,5]</span><br><span class="line">Output: [2,4,5]</span><br></pre></td></tr></table></figure></p>
<p>Constraints:</p>
<ul>
<li>The given tree will have between 1 and 1000 nodes.</li>
<li>Each node of the tree will have a distinct value between 1 and 1000.</li>
</ul>
<p>写一个递归函数，返回(LCA, 最大深度)，然后对左右子树分别调用这个函数。如果两棵子树的高度不同，则显然最大深度的叶子只存在更深的子树中，那么另一棵子树就不用管了，LCA也不变；否则LCA是当前树根。</p>
<p>就是，他不是要求最大深度公共子树么，就求左右子树的深度，如果相等了，说明找到了，因为是从上往下的，这就是最大的深度；否则的话对左右子树分别搞一搞。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + max(solve(root-&gt;left), solve(root-&gt;right));</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode* <span class="title">lcaDeepestLeaves</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l = solve(root-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> r = solve(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(l == r)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span>(l &lt; r)</span><br><span class="line">            <span class="keyword">return</span> lcaDeepestLeaves(root-&gt;right);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> lcaDeepestLeaves(root-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1124-Longest-Well-Performing-Interval"><a href="#Leetcode1124-Longest-Well-Performing-Interval" class="headerlink" title="Leetcode1124. Longest Well-Performing Interval"></a>Leetcode1124. Longest Well-Performing Interval</h1><p>We are given hours, a list of the number of hours worked per day for a given employee.</p>
<p>A day is considered to be a tiring day if and only if the number of hours worked is (strictly) greater than 8.</p>
<p>A well-performing interval is an interval of days for which the number of tiring days is strictly larger than the number of non-tiring days.</p>
<p>Return the length of the longest well-performing interval.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: hours = [9,9,6,0,6,6,9]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The longest well-performing interval is [9,9,6].</span><br></pre></td></tr></table></figure></p>
<p>Constraints:</p>
<ul>
<li>1 &lt;= hours.length &lt;= 10000</li>
<li>0 &lt;= hours[i] &lt;= 16</li>
</ul>
<p>把所有大于8的转成1，小于8的转成-1，找到最长的字串，字串的和大于等于1，<strong>最优解的字串的和肯定是1</strong>，因为如果大于1的话肯定可以往后走。</p>
<p>存储可能的target_sum的序列。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestWPI</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; hours)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;hours.size();i++)</span><br><span class="line">            hours[i]=hours[i]&gt;<span class="number">8</span>?<span class="number">1</span>:<span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; idx;</span><br><span class="line">        <span class="keyword">int</span> r = <span class="number">0</span>,inx=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> last=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxx=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;hours.size();i++)&#123;</span><br><span class="line">            r += hours[i];</span><br><span class="line">            <span class="keyword">if</span>(r&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                maxx = i+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!idx.count(r)) </span><br><span class="line">                idx[r] = i;</span><br><span class="line">            <span class="keyword">if</span> (idx.count(r - <span class="number">1</span>))</span><br><span class="line">                maxx = max(maxx, i - idx[r - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode1128-Number-of-Equivalent-Domino-Pairs"><a href="#Leetcode1128-Number-of-Equivalent-Domino-Pairs" class="headerlink" title="Leetcode1128. Number of Equivalent Domino Pairs"></a>Leetcode1128. Number of Equivalent Domino Pairs</h1><p>Given a list of dominoes, dominoes[i] = [a, b] is equivalent to dominoes[j] = [c, d] if and only if either (a==c and b==d), or (a==d and b==c) - that is, one domino can be rotated to be equal to another domino.</p>
<p>Return the number of pairs (i, j) for which 0 &lt;= i &lt; j &lt; dominoes.length, and dominoes[i] is equivalent to dominoes[j].</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: dominoes = [[1,2],[2,1],[3,4],[5,6]]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure></p>
<p>给你一个由一些多米诺骨牌组成的列表 dominoes。如果其中某一张多米诺骨牌可以通过旋转 0 度或 180 度得到另一张多米诺骨牌，我们就认为这两张牌是等价的。形式上，dominoes[i] = [a, b] 和 dominoes[j] = [c, d]，等价的前提是 a==c 且 b==d，或是 a==d 且 b==c。在 0 &lt;= i &lt; j &lt; dominoes.length 的前提下，找出满足 dominoes[i] 和 dominoes[j] 等价的骨牌对 (i, j) 的数量。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numEquivDominoPairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; dominoes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dominoes.size(); i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(dominoes[i][<span class="number">0</span>] &gt; dominoes[i][<span class="number">1</span>]) &#123;</span><br><span class="line">                temp = dominoes[i][<span class="number">0</span>];</span><br><span class="line">                dominoes[i][<span class="number">0</span>] = dominoes[i][<span class="number">1</span>];</span><br><span class="line">                dominoes[i][<span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = dominoes[i][<span class="number">0</span>]*<span class="number">10</span> + dominoes[i][<span class="number">1</span>];</span><br><span class="line">            mp[temp] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; i : mp) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = i.second;</span><br><span class="line">            ans += (v*(v<span class="number">-1</span>))/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode1129-Shortest-Path-with-Alternating-Colors"><a href="#Leetcode1129-Shortest-Path-with-Alternating-Colors" class="headerlink" title="Leetcode1129. Shortest Path with Alternating Colors"></a>Leetcode1129. Shortest Path with Alternating Colors</h1><p>Consider a directed graph, with nodes labelled 0, 1, …, n-1.  In this graph, each edge is either red or blue, and there could be self-edges or parallel edges.</p>
<p>Each [i, j] in red_edges denotes a red directed edge from node i to node j.  Similarly, each [i, j] in blue_edges denotes a blue directed edge from node i to node j.</p>
<p>Return an array answer of length n, where each answer[X] is the length of the shortest path from node 0 to node X such that the edge colors alternate along the path (or -1 if such a path doesn’t exist).</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 3, red_edges = [[0,1],[1,2]], blue_edges = []</span><br><span class="line">Output: [0,1,-1]</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 3, red_edges = [[0,1]], blue_edges = [[2,1]]</span><br><span class="line">Output: [0,1,-1]</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 3, red_edges = [[1,0]], blue_edges = [[2,1]]</span><br><span class="line">Output: [0,-1,-1]</span><br></pre></td></tr></table></figure></p>
<p>Example 4:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 3, red_edges = [[0,1]], blue_edges = [[1,2]]</span><br><span class="line">Output: [0,1,2]</span><br></pre></td></tr></table></figure></p>
<p>Example 5:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 3, red_edges = [[0,1],[0,2]], blue_edges = [[1,0]]</span><br><span class="line">Output: [0,1,1]</span><br></pre></td></tr></table></figure></p>
<p>Constraints:</p>
<ul>
<li>1 &lt;= n &lt;= 100</li>
<li>red_edges.length &lt;= 400</li>
<li>blue_edges.length &lt;= 400</li>
<li>red_edges[i].length == blue_edges[i].length == 2</li>
<li>0 &lt;= red_edges[i][j], blue_edges[i][j] &lt; n</li>
</ul>
<p>这道题给了一个有向图，跟以往不同的是，这里的边分为两种不同颜色，红和蓝，现在让求从结点0到所有其他结点的最短距离，并且要求路径必须是红蓝交替，即不能有相同颜色的两条边相连。这种遍历图求最短路径的题目的首选解法应该是广度优先遍历 Breadth-first Search，就像迷宫遍历的问题一样，由于其遍历的机制，当其第一次到达某个结点时，当前的步数一定是最少的。不过这道题还有一个难点，就是如何保证路径是红蓝交替的，这就跟以往有些不同了，必须要建立两个图的结构，分别保存红边和蓝边，为了方便起见，使用一个二维数组，最外层用0表示红边，1表示蓝边。内层是一个大小为n的数组，因为有n个结点，数组中的元素是一个 HashSet，因为每个结点可能可以连到多个其他的结点，这个图的结构可以说是相当的复杂了。</p>
<p>接下来就是给图结构赋值了，分别遍历红边和蓝边的数组，将对应的结点连上，就是将相连的结点加到 HashSet 中。由于到达每个结点可能通过红边或者蓝边，所以就有两个状态，这里用一个二维的 dp 数组来记录这些状态，其中 dp[i][j] 表示最后由颜色i的边到达结点j的最小距离，除了结点0之外，均初始化为 2n，因为即便是有向图，到达某个结点的最小距离也不可能大于 2n。由于是 BFS 遍历，需要用到 queue，这里的 queue 中的元素需要包含两个信息，当前的结点值，到达该点的边的颜色，所以初始化时分别将 (0,0) 和 (0,1) 放进去，前一个0表示结点值，后一个表示到达该点的边的颜色。接下来就可以进行 BFS 遍历了，进行 while 循环，将队首元素取出，将结点值 cur 和颜色值 color 取出。由于到达当前结点的边的颜色是 color，接下来就只能选另一种颜色了，则可以用 1-color 来选另一种颜色，并且在该颜色下遍历和 cur 相连的所有结点，若其对应的 dp 值仍为 2n，说明是第一次到达该结点，可用当前 dp 值加1来更新其 dp 值，并且将新的结点值与其颜色加入到队列中以便下次遍历其相连结点。当循环结束之后，只需要遍历一次 dp 值，将每个结点值对应的两个 dp 值中的较小的那个放到结果 res 中即可，注意要进行一下判断，若 dp 值仍为 2n，说明无法到达该结点，需要换成 -1，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; shortestAlternatingPaths(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; red_edges, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; blue_edges) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(n);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(<span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n));</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt;&gt;&gt; graph(<span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt;&gt;(n));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;edge : red_edges) &#123;</span><br><span class="line">            graph[<span class="number">0</span>][edge[<span class="number">0</span>]].insert(edge[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;edge : blue_edges) &#123;</span><br><span class="line">            graph[<span class="number">1</span>][edge[<span class="number">0</span>]].insert(edge[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = <span class="number">2</span> * n;</span><br><span class="line">            dp[<span class="number">1</span>][i] = <span class="number">2</span> * n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        q.push(&#123;<span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">        q.push(&#123;<span class="number">0</span>, <span class="number">1</span>&#125;);</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> cur = q.front()[<span class="number">0</span>], color = q.front()[<span class="number">1</span>]; q.pop();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> next : graph[<span class="number">1</span> - color][cur]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dp[<span class="number">1</span> - color][next] == <span class="number">2</span> * n) &#123;</span><br><span class="line">                    dp[<span class="number">1</span> - color][next] = <span class="number">1</span> + dp[color][cur];</span><br><span class="line">                    q.push(&#123;next, <span class="number">1</span> - color&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> val = min(dp[<span class="number">0</span>][i], dp[<span class="number">1</span>][i]);</span><br><span class="line">            res[i] = val == <span class="number">2</span> * n ? <span class="number">-1</span> : val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1130-Minimum-Cost-Tree-From-Leaf-Values"><a href="#Leetcode1130-Minimum-Cost-Tree-From-Leaf-Values" class="headerlink" title="Leetcode1130. Minimum Cost Tree From Leaf Values"></a>Leetcode1130. Minimum Cost Tree From Leaf Values</h1><p>Given an array arr of positive integers, consider all binary trees such that:</p>
<ul>
<li>Each node has either 0 or 2 children;</li>
<li>The values of arr correspond to the values of each leaf in an in-order traversal of the tree.   (Recall that a node is a leaf if and only if it has 0 children.)</li>
<li>The value of each non-leaf node is equal to the product of the largest leaf value in its left and right subtree respectively.</li>
</ul>
<p>Among all possible binary trees considered, return the smallest possible sum of the values of each non-leaf node.  It is guaranteed this sum fits into a 32-bit integer.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: arr = [6,2,4]</span><br><span class="line">Output: 32</span><br><span class="line">Explanation:</span><br><span class="line">There are two possible trees.  The first has non-leaf node sum 36, and the second has non-leaf node sum 32.</span><br><span class="line"></span><br><span class="line">    24            24</span><br><span class="line">   /  \          /\</span><br><span class="line">  12   4        6    8</span><br><span class="line"> /  \               /\</span><br><span class="line">6    2             2   4</span><br></pre></td></tr></table></figure></p>
<p>Constraints:</p>
<ul>
<li>2 &lt;= arr.length &lt;= 40</li>
<li>1 &lt;= arr[i] &lt;= 15</li>
<li>It is guaranteed that the answer fits into a 32-bit signed integer (ie. it is less than 2^31).</li>
</ul>
<p>这道题给了一个数组，说是里面都是一棵树的叶结点，说是其组成的树是一棵满二叉树，且这些叶结点值是通过中序遍历得到的，树中的非叶结点值是是其左右子树中最大的两个叶结点值的乘积，满足这些条件的二叉树可能不止一个，现在让找出非叶结点值之和最小的那棵树，并返回这个最小值。</p>
<p>通过观察例子，可以发现叶结点值 6，2，4 的顺序是不能变的，但是其组合方式可能很多，若有很多个叶结点，那么其组合方式就非常的多了。题目中给的提示是用动态规划 Dynamic Programming 来做，用一个二维的 dp 数组，其中 dp[i][j] 表示在区间 [i, j] 内的子数组组成的二叉树得到非叶结点值之和的最小值，接下来想状态转移方程怎么写。首先，若只有一个叶结点的话，是没法形成非叶结点的，所以 dp[i][i] 是0，最少得有两个叶结点，才有非0的值，即<code>dp[i][i+1] = arr[i] * arr[i+1]</code>，而一旦区间再大一些，就要遍历其中所有的小区间的情况，用其中的最小值来更新大区间的 dp 值。</p>
<p>这种用区间dp做，第一层循环是区间长度，第二层枚举起点，第三层枚举终点。这里的区间长度从1到n，长度为1，表示至少有两个叶结点，i从0遍历到 n-len，j可以直接确定出来为 i+len，然后用k来将区间 [i, j] 分为两个部分，由于分开的小区间在之前都已经更新过了，所以其 dp 值可以直接得到，然后再加上这两个区间中各自的最大结点值的乘积。为了不每次都遍历小区间来获得最大值，可以提前计算好任意区间的最大值，保存在 maxVec 中，这样就可以快速获取了，最后返回的结果保存在 dp[0][n-1] 中，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mctFromLeafValues</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n));</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; maxVec(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> curMax = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; n; ++j) &#123;</span><br><span class="line">                curMax = max(curMax, arr[j]);</span><br><span class="line">                maxVec[i][j] = curMax;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">1</span>; len &lt; n; ++len) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i + len &lt; n; ++i) &#123;</span><br><span class="line">                <span class="keyword">int</span> j = i + len;</span><br><span class="line">                dp[i][j] = INT_MAX;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt; j; ++k) &#123;</span><br><span class="line">                    dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + <span class="number">1</span>][j] + maxVec[i][k] * maxVec[k + <span class="number">1</span>][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>下面的这种解法是参见了大神 lee215 的帖子，是一种利用单调栈来解的方法，将时间复杂度优化到了线性，惊为天人。思路是这样的，当两个叶结点生成一个父结点值，较小的那个数字使用过一次之后就不再被使用了，因为之后形成的结点是要子树中最大的那个结点值。所以问题实际上可以转化为在一个数组中，每次选择两个相邻的数字a和b，移除较小的那个数字，代价是 a*b，问当移除到数组只剩下一个数字的最小的代价。Exactly same problem，所以b是有可能复用的，要尽可能的 minimize，数字a可以是一个局部最小值，那么b就是a两边的那个较小的数字，这里使用一个单调栈来做是比较方便的。关于单调栈，博主之前也有写过一篇总结 LeetCode Monotonous Stack Summary 单调栈小结，在 LeetCode 中的应用也非常多，是一种必须要掌握的方法。这里维护一个最小栈，当前栈顶的元素是最小的，一旦遍历到一个较大的数字，此时当前栈顶的元素其实是一个局部最小值，它就需要跟旁边的一个较小的值组成一个左右叶结点，这样形成的父结点才是最小的，然后将较小的那个数字移除，符合上面的分析。然后继续比较新的栈顶元素，若还是小，则继续相同的操作，否则退出循环，将当前的数字压入栈中。最后若栈中还有数字剩余，则一定是从大到小的，只需将其按顺序两两相乘即可，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mctFromLeafValues</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, n = arr.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; st&#123;INT_MAX&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : arr) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!st.empty() &amp;&amp; st.back() &lt;= num) &#123;</span><br><span class="line">                <span class="keyword">int</span> mid = st.back();</span><br><span class="line">                st.pop_back();</span><br><span class="line">                res += mid * min(st.back(), num);</span><br><span class="line">            &#125;</span><br><span class="line">            st.push_back(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; st.size(); ++i) &#123;</span><br><span class="line">            res += st[i] * st[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode1137-N-th-Tribonacci-Number"><a href="#Leetcode1137-N-th-Tribonacci-Number" class="headerlink" title="Leetcode1137. N-th Tribonacci Number"></a>Leetcode1137. N-th Tribonacci Number</h1><p>The Tribonacci sequence Tn is defined as follows:  T0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n &gt;= 0. Given n, return the value of Tn.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 4</span><br><span class="line">Output: 4</span><br><span class="line">Explanation:</span><br><span class="line">T_3 = 0 + 1 + 1 = 2</span><br><span class="line">T_4 = 1 + 1 + 2 = 4</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 25</span><br><span class="line">Output: 1389537</span><br></pre></td></tr></table></figure></p>
<p>类似斐波那契数列。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">tribonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v(n+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        v[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        v[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        v[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> v[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">            v[i] = v[i<span class="number">-1</span>] + v[i<span class="number">-2</span>] + v[i<span class="number">-3</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1138-Alphabet-Board-Path"><a href="#Leetcode1138-Alphabet-Board-Path" class="headerlink" title="Leetcode1138. Alphabet Board Path"></a>Leetcode1138. Alphabet Board Path</h1><p>On an alphabet board, we start at position (0, 0), corresponding to character board[0][0].</p>
<p>Here, board = [“abcde”, “fghij”, “klmno”, “pqrst”, “uvwxy”, “z”], as shown in the diagram below.</p>
<p>We may make the following moves:</p>
<ul>
<li>‘U’ moves our position up one row, if the position exists on the board;</li>
<li>‘D’ moves our position down one row, if the position exists on the board;</li>
<li>‘L’ moves our position left one column, if the position exists on the board;</li>
<li>‘R’ moves our position right one column, if the position exists on the board;</li>
<li>‘!’ adds the character board[r][c] at our current position (r, c) to the answer.</li>
</ul>
<p>(Here, the only positions that exist on the board are positions with letters on them.)</p>
<p>Return a sequence of moves that makes our answer equal to target in the minimum number of moves.  You may return any path that does so.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: target = &quot;leet&quot;</span><br><span class="line">Output: &quot;DDR!UURRR!!DDD!&quot;</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: target = &quot;code&quot;</span><br><span class="line">Output: &quot;RR!DDRR!UUL!R!&quot;</span><br></pre></td></tr></table></figure></p>
<p>Constraints:</p>
<ul>
<li>1 &lt;= target.length &lt;= 100</li>
<li>target consists only of English lowercase letters.</li>
</ul>
<p>这道题给了一个字母表盘，就是 26 个小写字母按每行五个排列，形成一个二维数组，共有六行，但第六行只有一个字母z。然后给了一个字符串 target，起始位置是在a，现在让分别按顺序走到 target 上的所有字符，问经过的最短路径是什么。</p>
<p>由于表盘上的字母位置是固定的，所以不需要进行遍历来找特定的字母，而是可以根据字母直接确定其在表盘的上的坐标，这样当前字母和目标字母的坐标都确定了，就可以直接找路径了，其实就是个曼哈顿距离。由于路径有很多条，只要保证距离最短都对，那么就可以先走横坐标，或先走纵坐标。其实这里选方向挺重要，因为有个很 tricky 的情况，就是字母z，因为最后一行只有一个字母z，其不能往右走，只能往上走，所以这里定一个规则，就是先往上走，再向右走。同理，从别的字母到z的话，也应该先往左走到头，再往下走。顺序确定好了，就可以想怎么正确的生成路径，往上的走的话，说明目标点在上方，则说明当前的x坐标大，则用 curX - x，由于不一定需要向上走，所以这个差值有可能是负数，则需要跟0比较大小，取较大的那个。其他情况，都是同理的，往右走用目标y坐标减去当前y坐标；往左走，用当前y坐标减去目标y坐标；往下走，用目标x坐标减去当前x坐标，最后再加上感叹号。结束一轮后，别忘了更新 curX 和 curY，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">alphabetBoardPath</span><span class="params">(<span class="built_in">string</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">int</span> curX = <span class="number">0</span>, curY = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : target) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = (c - <span class="string">'a'</span>) / <span class="number">5</span>, y = (c - <span class="string">'a'</span>) % <span class="number">5</span>;</span><br><span class="line">            res += <span class="built_in">string</span>(max(<span class="number">0</span>, curX - x), <span class="string">'U'</span>) + <span class="built_in">string</span>(max(<span class="number">0</span>, y - curY), <span class="string">'R'</span>) + <span class="built_in">string</span>(max(<span class="number">0</span>, curY - y), <span class="string">'L'</span>) + <span class="built_in">string</span>(max(<span class="number">0</span>, x - curX), <span class="string">'D'</span>) + <span class="string">'!'</span>;</span><br><span class="line">            curX = x;</span><br><span class="line">            curY = y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1139-Largest-1-Bordered-Square"><a href="#Leetcode1139-Largest-1-Bordered-Square" class="headerlink" title="Leetcode1139. Largest 1-Bordered Square"></a>Leetcode1139. Largest 1-Bordered Square</h1><p>Given a 2D grid of 0s and 1s, return the number of elements in the largest square subgrid that has all 1s on its border, or 0 if such a subgrid doesn’t exist in the grid.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: grid = [[1,1,1],[1,0,1],[1,1,1]]</span><br><span class="line">Output: 9</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: grid = [[1,1,0,0]]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure></p>
<p>Constraints:</p>
<ul>
<li>1 &lt;= grid.length &lt;= 100</li>
<li>1 &lt;= grid[0].length &lt;= 100</li>
<li>grid[i][j] is 0 or 1</li>
</ul>
<p>这道题给了一个只有0和1的二维数组 grid，现在让找出边长均为1的最大正方形的元素个数，实际上就是这个正方形的面积，也就是边长的平方。给定的 grid 不一定是个正方形，首先来想，如何确定一个正方形，由于边长的是相同的，只要知道了边长，和其中的一个顶点，那么这个正方形也就确定了。如何才能快速的知道其边长是否均为1呢，每次都一个一个的遍历检查的确太不高效了，比较好的方法是统计连续1的个数，注意这里不是累加和数组，而且到当前位置为止的连续1的个数，需要分为两个方向，水平和竖直。这里用<code>left</code>表示水平，<code>top</code>表示竖直。若<code>left[i][j]</code>为k，则表示从<code>grid[i][j-k]</code>到<code>grid[i][j]</code>的数字均为1，同理，若<code>top[i][j]</code>为k，则表示<code>grid[i-k][j]</code>到<code>grid[i][j]</code>的数字均为1，则表示找到了一个边长为k的正方形。由于<code>grid</code>不一定是正方形，那么其可以包含的最大的正方形的边长为<code>grid</code>的长和宽中的较小值。边长确定了，只要遍历左上顶点的就行了，然后通过连续1数组<code>top</code>和<code>left</code>来快速判断四条边是否为1，只要找到了这个正方形，就可以直接返回了，否则就将边长减少1，继续查找，参见代码如下：</p>
<p>解法一：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largest1BorderedSquare</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.size(), n = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; left(m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n)), top(m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                left[i][j] = j == <span class="number">0</span> ? <span class="number">1</span> : left[i][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                top[i][j] = i == <span class="number">0</span> ? <span class="number">1</span> : top[i - <span class="number">1</span>][j] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> len = min(m, n); len &gt; <span class="number">0</span>; --len) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m - len + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n - len + <span class="number">1</span>; ++j) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (top[i + len - <span class="number">1</span>][j] &gt;= len &amp;&amp; top[i + len - <span class="number">1</span>][j + len - <span class="number">1</span>] &gt;= len &amp;&amp; left[i][j + len - <span class="number">1</span>] &gt;= len &amp;&amp; left[i + len - <span class="number">1</span>][j + len - <span class="number">1</span>] &gt;= len) <span class="keyword">return</span> len * len;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>上面的方法是根据边长进行遍历，若数组很大，而其中的1很少，这种遍历方法将不是很高效。我们从 grid 数组的右下角往左上角遍历，即从每个潜在的正方形的右下角开始遍历，根据右下顶点的位置取到的 top 和 left 值，分别是正方形的右边和下边的边长，取其中较小的那个为目标正方形的边长，然后现在就要确定是否存在相应的左边和上边，存在话的更新 mx，否则将目标边长减1，继续查找，直到目标边长小于 mx 了停止。继续这样的操作直至遍历完所有的右下顶点，这种遍历的方法要高效不少，参见代码如下：</p>
<p>解法二：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largest1BorderedSquare</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mx = <span class="number">0</span>, m = grid.size(), n = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; left(m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n)), top(m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                left[i][j] = j == <span class="number">0</span> ? <span class="number">1</span> : left[i][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                top[i][j] = i == <span class="number">0</span> ? <span class="number">1</span> : top[i - <span class="number">1</span>][j] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = m - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">                <span class="keyword">int</span> small = min(left[i][j], top[i][j]);</span><br><span class="line">                <span class="keyword">while</span> (small &gt; mx) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (top[i][j - small + <span class="number">1</span>] &gt;= small &amp;&amp; left[i - small + <span class="number">1</span>][j] &gt;= small) mx = small;</span><br><span class="line">                    --small;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mx * mx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1140-Stone-Game-II"><a href="#Leetcode1140-Stone-Game-II" class="headerlink" title="Leetcode1140. Stone Game II"></a>Leetcode1140. Stone Game II</h1><p>Alice and Bob continue their games with piles of stones.  There are a number of piles arranged in a row, and each pile has a positive integer number of stones piles[i].  The objective of the game is to end with the most stones.</p>
<p>Alice and Bob take turns, with Alice starting first.  Initially, M = 1.</p>
<p>On each player’s turn, that player can take all the stones in the first X remaining piles, where 1 &lt;= X &lt;= 2M.  Then, we set M = max(M, X).</p>
<p>The game continues until all the stones have been taken.</p>
<p>Assuming Alice and Bob play optimally, return the maximum number of stones Alice can get.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: piles = [2,7,9,4,4]</span><br><span class="line">Output: 10</span><br><span class="line">Explanation:  If Alice takes one pile at the beginning, Bob takes two piles, then Alice takes 2 piles again. Alice can get 2 + 4 + 4 = 10 piles in total. If Alice takes two piles at the beginning, then Bob can take all three piles left. In this case, Alice get 2 + 7 = 9 piles in total. So we return 10 since it&apos;s larger.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: piles = [1,2,3,4,5,100]</span><br><span class="line">Output: 104</span><br></pre></td></tr></table></figure></p>
<p>Constraints:</p>
<ul>
<li>1 &lt;= piles.length &lt;= 100</li>
<li>1 &lt;= piles[i] &lt;= 104</li>
</ul>
<p>这道题是石头游戏系列的第二道，跟之前那道 Stone Game 不同的是终于换回了 Alice 和 Bob！还有就是取石子的方法，不再是只能取首尾两端的石子堆，而是可以取 [1, 2M] 范围内的任意X堆，M是个变化的量，初始化为1，每次取完X堆后，更新为 M = max(M, X)。这种取石子的方法比之前的要复杂很多，由于X的值非常的多，而且其不同的选择还可能影响到M值，那么整体的情况就特别的多，暴力搜索基本上是行不通的。这种不同状态之间转移的问题用动态规划 Dynamic Programming 是比较合适的，首先来考虑 DP 数组的定义，题目要求的是 Alice 最多能拿到的石子个数，拿石子的方式是按顺序的，不能跳着拿，所以决定某个状态的是两个变量，一个是当前还剩多少石子堆，可以通过当前位置坐标i来表示，另一个是当前的m值，只有知道了当前的m值，那么选手才知道能拿的堆数的范围，所以 DP 就是个二维数组，其 dp[i][m] 表示的意义在上面已经解释了。接下来考虑状态转移方程，由于在某个状态时已经知道了m值，则当前选手能拿的堆数在范围 [1, 2m] 之间，为了更新这个 dp 值，所有x的情况都要遍历一遍，即在剩余堆数中拿x堆，但此时x堆必须小于等于剩余的堆数，即 i + x &lt;= n，i为当前的位置。由于每个选手都是默认选最优解的，若能知道下一个选手该拿的最大石子个数，就能知道当前选手能拿的最大石子个数了，因为二者之和为当前剩余的石子个数。由于当前选手拿了x堆，则下个选手的位置是 i+x，且m更新为 max(m,x)，所以其 dp 值为 dp[i + x][max(m, x)])。为了快速得知当前剩余的石子总数，需要建立累加和数组，注意这里是建立反向的累加和数组，其中 sums[i] 表示范围 [i, n-1] 之和。分析到这里就可以写出状态状态转移方程如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][m] = max(dp[i][m], sums[i] - dp[i + x][max(m, x)])</span><br></pre></td></tr></table></figure></p>
<p>接下来就是一些初始化和边界定义的问题需要注意的了，dp 数组大小为 n+1 by n+1，因为选手是可能一次将n堆都拿了，比如 n=1 时，所以 dp[i][n] 是存在的，且需要用 sums[i] 来初始化。更新 dp 时需要用三个 for 循环，分别控制i，m，和 x，注意更新从后往前遍历i和m，因为我们要先更新小区间，再更新大区间。x的范围要设定为 x &lt;= 2 * m &amp;&amp; i + x &lt;= n，前面也讲过原因了，最后的答案保存在 dp[0][1] 中返回即可，参见代码如下：</p>
<p>解法一：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">stoneGameII</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; piles)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = piles.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sums = piles;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            sums[i] += sums[i + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            dp[i][n] = sums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> m = n - <span class="number">1</span>; m &gt;= <span class="number">1</span>; --m) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= <span class="number">2</span> * m &amp;&amp; i + x &lt;= n; ++x) &#123;</span><br><span class="line">                    dp[i][m] = max(dp[i][m], sums[i] - dp[i + x][max(m, x)]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>我们再来用递归加记忆数组的方式来实现一下，其实核心思想跟上面完全一样，这里就不过多的讲解了，直接看代码吧：</p>
<p>解法二：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">stoneGameII</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; piles)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = piles.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sums = piles;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; memo(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            sums[i] += sums[i + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> helper(sums, <span class="number">0</span>, <span class="number">1</span>, memo);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; sums, <span class="keyword">int</span> i, <span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; memo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i + <span class="number">2</span> * m &gt;= sums.size()) <span class="keyword">return</span> sums[i];</span><br><span class="line">        <span class="keyword">if</span> (memo[i][m] &gt; <span class="number">0</span>) <span class="keyword">return</span> memo[i][m];</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= <span class="number">2</span> * m; ++x) &#123;</span><br><span class="line">            <span class="keyword">int</span> cur = sums[i] - sums[i + x];</span><br><span class="line">            res = max(res, cur + sums[i + x] - helper(sums, i + x, max(x, m), memo));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[i][m] = res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1143-Longest-Common-Subsequence"><a href="#Leetcode1143-Longest-Common-Subsequence" class="headerlink" title="Leetcode1143. Longest Common Subsequence"></a>Leetcode1143. Longest Common Subsequence</h1><p>Given two strings text1 and text2, return the length of their longest common subsequence.</p>
<p>A subsequence of a string is a new string generated from the original string with some characters(can be none) deleted without changing the relative order of the remaining characters. (eg, “ace” is a subsequence of “abcde” while “aec” is not). A common subsequence of two strings is a subsequence that is common to both strings.</p>
<p>If there is no common subsequence, return 0.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: text1 = &quot;abcde&quot;, text2 = &quot;ace&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The longest common subsequence is &quot;ace&quot; and its length is 3.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: text1 = &quot;abc&quot;, text2 = &quot;abc&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The longest common subsequence is &quot;abc&quot; and its length is 3.</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: text1 = &quot;abc&quot;, text2 = &quot;def&quot;</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: There is no such common subsequence, so the result is 0.</span><br></pre></td></tr></table></figure></p>
<p>Constraints:</p>
<ul>
<li>1 &lt;= text1.length &lt;= 1000</li>
<li>1 &lt;= text2.length &lt;= 1000</li>
<li>The input strings consist of lowercase English characters only.</li>
</ul>
<p>这道题让求最长相同的子序列。使用一个二维数组 dp，其中<code>dp[i][j]</code>表示<code>text1</code>的前i个字符和<code>text2</code>的前j个字符的最长相同的子序列的字符个数，这里大小初始化为<code>(m+1)x(n+1)</code>，这里的m和n分别是<code>text1</code>和<code>text2</code>的长度。接下来就要找状态转移方程了，如何来更新<code>dp[i][j]</code>，若二者对应位置的字符相同，表示当前的LCS又增加了一位，所以可以用<code>dp[i-1][j-1] + 1</code>来更新<code>dp[i][j]</code>。否则若对应位置的字符不相同，由于是子序列，还可以错位比较，可以分别从<code>text1</code>或者<code>text2</code>去掉一个当前字符，那么其dp值就是<code>dp[i-1][j]</code>和<code>dp[i][j-1]</code>，取二者中的较大值来更新<code>dp[i][j]</code>即可，最终的结果保存在了<code>dp[m][n]</code>中，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(<span class="built_in">string</span> word1, <span class="built_in">string</span> word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = word1.length(), n = word2.length();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(m+<span class="number">1</span>, <span class="built_in">vector</span>(n+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++) </span><br><span class="line">                <span class="keyword">if</span> (word1[i<span class="number">-1</span>] == word2[j<span class="number">-1</span>])</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = max(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>]);</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1144-Decrease-Elements-To-Make-Array-Zigzag"><a href="#Leetcode1144-Decrease-Elements-To-Make-Array-Zigzag" class="headerlink" title="Leetcode1144. Decrease Elements To Make Array Zigzag"></a>Leetcode1144. Decrease Elements To Make Array Zigzag</h1><p>Given an array nums of integers, a move consists of choosing any element and decreasing it by 1.</p>
<p>An array A is a zigzag array if either:</p>
<p>Every even-indexed element is greater than adjacent elements, ie. A[0] &gt; A[1] &lt; A[2] &gt; A[3] &lt; A[4] &gt; …<br>OR, every odd-indexed element is greater than adjacent elements, ie. A[0] &lt; A[1] &gt; A[2] &lt; A[3] &gt; A[4] &lt; …<br>Return the minimum number of moves to transform the given array nums into a zigzag array.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,2,3]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: We can decrease 2 to 0 or 3 to 1.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [9,6,1,6,2]</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure></p>
<p>Constraints:</p>
<ul>
<li>1 &lt;= nums.length &lt;= 1000</li>
<li>1 &lt;= nums[i] &lt;= 1000</li>
</ul>
<p>这道题说是每次可以给数组中的任意数字减小1，现在想将数组变为之字形，就是数字大和小交替出现，有两种，一种是偶数坐标的数字均大于其相邻两个位置的数字，一种是奇数坐标的数字均大于其相邻的两个位置的数字。对于第一种情况来说，其奇数坐标位置的数字就均小于其相邻两个位置的数字，同理，对于第二种情况，其偶数坐标位置的数字就均小于其相邻两个位置的数字。这里我们可以分两种情况来统计减少次数，一种是减小所有奇数坐标上的数字，另一种是减小所有偶数坐标上的数字。减小的方法是找到相邻的两个数字中的较小那个，然后比其小1即可，即可用 nums[i] - min(left, right) + 1 来得到，若得到了个负数，说明当前数字已经比左右的数字小了，不需要再减小了，所以需要跟0比较，取较大值。这里用了一个大小为2的 res 数组，这用直接根据当前坐标i，通过 i%2 就可以更新对应的次数了，最终取二者中的较小值返回即可，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">movesToMakeZigzag</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size(), res[<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> left = i &gt; <span class="number">0</span> ? nums[i - <span class="number">1</span>] : <span class="number">1001</span>;</span><br><span class="line">            <span class="keyword">int</span> right = i &lt; n - <span class="number">1</span> ? nums[i + <span class="number">1</span>] : <span class="number">1001</span>;</span><br><span class="line">            res[i % <span class="number">2</span>] += max(<span class="number">0</span>, nums[i] - min(left, right) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min(res[<span class="number">0</span>], res[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode1146-Snapshot-Array"><a href="#Leetcode1146-Snapshot-Array" class="headerlink" title="Leetcode1146. Snapshot Array"></a>Leetcode1146. Snapshot Array</h1><p>Implement a SnapshotArray that supports the following interface:</p>
<p>SnapshotArray(int length) initializes an array-like data structure with the given length.  Initially, each element equals 0.</p>
<ul>
<li><code>void set(index, val)</code> sets the element at the given index to be equal to val.</li>
<li><code>int snap()</code> takes a snapshot of the array and returns the snap_id: the total number of times we called snap() minus 1.</li>
<li><code>int get(index, snap_id)</code> returns the value at the given index, at the time we took the snapshot with the given snap_id</li>
</ul>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;SnapshotArray&quot;,&quot;set&quot;,&quot;snap&quot;,&quot;set&quot;,&quot;get&quot;]</span><br><span class="line">[[3],[0,5],[],[0,6],[0,0]]</span><br><span class="line">Output: [null,null,0,null,5]</span><br><span class="line">Explanation:</span><br><span class="line">SnapshotArray snapshotArr = new SnapshotArray(3); // set the length to be 3</span><br><span class="line">snapshotArr.set(0,5);  // Set array[0] = 5</span><br><span class="line">snapshotArr.snap();  // Take a snapshot, return snap_id = 0</span><br><span class="line">snapshotArr.set(0,6);</span><br><span class="line">snapshotArr.get(0,0);  // Get the value of array[0] with snap_id = 0, return 5</span><br></pre></td></tr></table></figure></p>
<p>Constraints:</p>
<ul>
<li>1 &lt;= length &lt;= 50000</li>
<li>At most 50000 calls will be made to set, snap, and get.</li>
<li>0 &lt;= index &lt; length</li>
<li>0 &lt;= snap_id &lt; (the total number of times we call snap())</li>
<li>0 &lt;= val &lt;= 10^9</li>
</ul>
<p>这道题让实现一个 SnapshotArray 的类，具有给数组拍照的功能，就是说在某个时间点<code>spapId</code>拍照后，当前数组的值需要都记录下来，同理，每一次调用<code>snap()</code>函数时，都需要记录整个数组的状态，这是为了之后可以查询任意一个时间点上的任意一个位置上的值。最简单粗暴的方法当前就是用一个二维数组，每次拍照的时候，都把整个数组都存到二维数组中，其坐标就是<code>snapId</code>。但是这种方法不高效，而且占用了巨大的空间，被 OJ 豪不留情的抹杀掉了。来分析一下不高效的原因，这是因为每次拍照时，可能数组的大部分数据并没有变动，每次都再存一遍整个数组是浪费的。这里我们关心的是调用<code>set()</code>函数，因为这会改变数组的值，若能建立<code>snapId</code>和更新值之间的映射，就可以根据二分法来快速定位某一个<code>snapId</code>的值了，因为<code>snapId</code>是按顺序递增的。这样就可以用一个Vector of Map 或者 Map of Map 的数据结构来实现，外层的 TreeMap 是映射建立数组坐标到内层 TreeMap 之间的映射，内层的 TreeMap 是建立 snapId 和更新值之间的映射。初始化时，要将 0-&gt;0 这个映射对儿加到每一个位置，因为初始化时数组的每个元素都是0。在<code>set()</code>函数中就可以更新<code>HashMap</code>中的映射值，<code>snap()</code>就直接累加<code>snapId</code>，比较麻烦的就是<code>get()</code>函数，给定的<code>snapId</code>可能在内层的<code>HashMap</code>中不存在，需要查找第一个不大于给定<code>snapId</code>的映射值，那么就先找第一个大于<code>snapId</code>的位置，再回退一位就好了，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SnapshotArray</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SnapshotArray(<span class="keyword">int</span> length) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">            snapMap[i] = &#123;&#123;<span class="number">0</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        snapMap[index][snapId] = val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">snap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> snapId++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> snap_id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> it = snapMap[index].upper_bound(snap_id);</span><br><span class="line">        --it;</span><br><span class="line">        <span class="keyword">return</span> it-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> snapId = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; snapMap;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode1147-Longest-Chunked-Palindrome-Decomposition"><a href="#Leetcode1147-Longest-Chunked-Palindrome-Decomposition" class="headerlink" title="Leetcode1147. Longest Chunked Palindrome Decomposition"></a>Leetcode1147. Longest Chunked Palindrome Decomposition</h1><p>You are given a string text. You should split it to k substrings (subtext1, subtext2, …, subtextk) such that:</p>
<ul>
<li>subtexti is a non-empty string.</li>
<li>The concatenation of all the substrings is equal to text (i.e., subtext1 + subtext2 + … + subtextk == text).</li>
<li>subtexti == subtextk - i + 1 for all valid values of i (i.e., 1 &lt;= i &lt;= k).</li>
</ul>
<p>Return the largest possible value of k.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: text = &quot;ghiabcdefhelloadamhelloabcdefghi&quot;</span><br><span class="line">Output: 7</span><br><span class="line">Explanation: We can split the string on &quot;(ghi)(abcdef)(hello)(adam)(hello)(abcdef)(ghi)&quot;.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: text = &quot;merchant&quot;</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: We can split the string on &quot;(merchant)&quot;.</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: text = &quot;antaprezatepzapreanta&quot;</span><br><span class="line">Output: 11</span><br><span class="line">Explanation: We can split the string on &quot;(a)(nt)(a)(pre)(za)(tpe)(za)(pre)(a)(nt)(a)&quot;.</span><br></pre></td></tr></table></figure></p>
<p>Example 4:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: text = &quot;aaa&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: We can split the string on &quot;(a)(a)(a)&quot;.</span><br></pre></td></tr></table></figure></p>
<p>Constraints:</p>
<ul>
<li>1 &lt;= text.length &lt;= 1000</li>
<li>text consists only of lowercase English characters.</li>
</ul>
<p>这道题是关于段式回文的，想必大家对回文串都不陌生，就是前后字符对应相同的字符串，比如 noon 和 bob。这里的段式回文相等的不一定是单一的字符，而是可以是字串，参见题目中的例子，现在给了一个字符串，问可以得到的段式回文串的最大长度是多少。由于段式回文的特点，你可以把整个字符串都当作一个子串，则可以得到一个长度为1的段式回文，所以答案至少是1，不会为0。而最好情况就是按字符分别相等，那就变成了一般的回文串，则长度就是原字符串的长度。比较的方法还是按照经典的验证回文串的方式，用双指针来做，一前一后。不同的是遇到不相等的字符不是立马退出，而是累加两个子串 left 和 right，每累加一个字符，都比较一下 left 和 right 是否相等，这样可以保证尽可能多的分出来相等的子串，一旦分出了相等的子串，则 left 和 right 重置为空串，再次从小到大比较，参见代码如下：</p>
<p>解法一：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestDecomposition</span><span class="params">(<span class="built_in">string</span> text)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, n = text.size();</span><br><span class="line">        <span class="built_in">string</span> left, right;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            left += text[i], right = text[n - i - <span class="number">1</span>] + right;</span><br><span class="line">            <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">                ++res;</span><br><span class="line">                left = right = <span class="string">""</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>我们也可以使用递归来做，写法更加简洁一些，i从1遍历到 n/2，代表的是子串的长度，一旦超过一半了，说明无法分为两个了，最终做个判断即可。为了不每次都提取出子串直接进行比较，这里可以先做个快速的检测，即判断两个子串的首尾字符是否对应相等，只有相等了才会提取整个子串进行比较，这样可以省掉一些不必要的计算，参见代码如下：</p>
<p>解法二：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">is_equal</span><span class="params">(<span class="built_in">string</span> text, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i ++)</span><br><span class="line">            <span class="keyword">if</span> (text[x+i] != text[y+i])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestDecomposition</span><span class="params">(<span class="built_in">string</span> text)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = text.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n/<span class="number">2</span>; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (is_equal(text, <span class="number">0</span>, n-i, i))</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2</span> + longestDecomposition(text.substr(i, n-i*<span class="number">2</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n &gt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Leetcode/" rel="tag"># Leetcode</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/04/29/Leetcode451_500/" rel="next" title="Leetcode451 - 500">
                <i class="fa fa-chevron-left"></i> Leetcode451 - 500
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/05/05/Leetcode101_150/" rel="prev" title="Leetcode101 - 150">
                Leetcode101 - 150 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/header.jpg" alt="Hao Yu">
            
              <p class="site-author-name" itemprop="name">Hao Yu</p>
              <p class="site-description motion-element" itemprop="description">Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author</p>
          </div>
          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">273</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>
        	<audio controls="controls" loop="loop" preload="auto" src="/resource/xiaomeihao.mp3">
	        </audio>
	

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yuhao0102" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:yuh18@mails.tsinghua.edu.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1103-Distribute-Candies-to-People"><span class="nav-number">1.</span> <span class="nav-text">Leetcode1103. Distribute Candies to People</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1104-Path-In-Zigzag-Labelled-Binary-Tree"><span class="nav-number">2.</span> <span class="nav-text">Leetcode1104. Path In Zigzag Labelled Binary Tree</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1105-Filling-Bookcase-Shelves"><span class="nav-number">3.</span> <span class="nav-text">Leetcode1105. Filling Bookcase Shelves</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1108-Defanging-an-IP-Address"><span class="nav-number">4.</span> <span class="nav-text">Leetcode1108. Defanging an IP Address</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1109-Corporate-Flight-Bookings"><span class="nav-number">5.</span> <span class="nav-text">Leetcode1109. Corporate Flight Bookings</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1110-Delete-Nodes-And-Return-Forest"><span class="nav-number">6.</span> <span class="nav-text">Leetcode1110. Delete Nodes And Return Forest</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1111-Maximum-Nesting-Depth-of-Two-Valid-Parentheses-Strings"><span class="nav-number">7.</span> <span class="nav-text">Leetcode1111. Maximum Nesting Depth of Two Valid Parentheses Strings</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1114-Print-in-Order"><span class="nav-number">8.</span> <span class="nav-text">Leetcode1114. Print in Order</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1122-Relative-Sort-Array"><span class="nav-number">9.</span> <span class="nav-text">Leetcode1122. Relative Sort Array</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1123-Lowest-Common-Ancestor-of-Deepest-Leaves"><span class="nav-number">10.</span> <span class="nav-text">Leetcode1123. Lowest Common Ancestor of Deepest Leaves</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1124-Longest-Well-Performing-Interval"><span class="nav-number">11.</span> <span class="nav-text">Leetcode1124. Longest Well-Performing Interval</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1128-Number-of-Equivalent-Domino-Pairs"><span class="nav-number">12.</span> <span class="nav-text">Leetcode1128. Number of Equivalent Domino Pairs</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1129-Shortest-Path-with-Alternating-Colors"><span class="nav-number">13.</span> <span class="nav-text">Leetcode1129. Shortest Path with Alternating Colors</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1130-Minimum-Cost-Tree-From-Leaf-Values"><span class="nav-number">14.</span> <span class="nav-text">Leetcode1130. Minimum Cost Tree From Leaf Values</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1137-N-th-Tribonacci-Number"><span class="nav-number">15.</span> <span class="nav-text">Leetcode1137. N-th Tribonacci Number</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1138-Alphabet-Board-Path"><span class="nav-number">16.</span> <span class="nav-text">Leetcode1138. Alphabet Board Path</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1139-Largest-1-Bordered-Square"><span class="nav-number">17.</span> <span class="nav-text">Leetcode1139. Largest 1-Bordered Square</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1140-Stone-Game-II"><span class="nav-number">18.</span> <span class="nav-text">Leetcode1140. Stone Game II</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1143-Longest-Common-Subsequence"><span class="nav-number">19.</span> <span class="nav-text">Leetcode1143. Longest Common Subsequence</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1144-Decrease-Elements-To-Make-Array-Zigzag"><span class="nav-number">20.</span> <span class="nav-text">Leetcode1144. Decrease Elements To Make Array Zigzag</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1146-Snapshot-Array"><span class="nav-number">21.</span> <span class="nav-text">Leetcode1146. Snapshot Array</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1147-Longest-Chunked-Palindrome-Decomposition"><span class="nav-number">22.</span> <span class="nav-text">Leetcode1147. Longest Chunked Palindrome Decomposition</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>
  <div id="DvelopmentTarget">     
  </div>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart" aria-hidden="false"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>

  
</div>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_uv"> 
  本站访客数<span id="busuanzi_value_site_uv"></span>人次
</span>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  


  

  


  <script type="text/javascript" src="/js/src/love.js"></script>

</body>
</html>
