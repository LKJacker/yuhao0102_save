<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zn-ch">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-center-simple.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Leetcode,">










<meta name="description" content="Leetcode53. Maximum SubarrayGiven an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum. Example:123Input: [-2,1,-3,4,-1,2,1">
<meta name="keywords" content="Leetcode">
<meta property="og:type" content="article">
<meta property="og:title" content="Leetcode51 - 100">
<meta property="og:url" content="http://yoursite.com/2020/05/15/Leetcode51_100/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="Leetcode53. Maximum SubarrayGiven an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum. Example:123Input: [-2,1,-3,4,-1,2,1">
<meta property="og:locale" content="zn-ch">
<meta property="og:updated_time" content="2020-06-12T02:01:31.936Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Leetcode51 - 100">
<meta name="twitter:description" content="Leetcode53. Maximum SubarrayGiven an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum. Example:123Input: [-2,1,-3,4,-1,2,1">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/05/15/Leetcode51_100/">





  <title>Leetcode51 - 100 | Hao Yu's blog</title>
  








 
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zn-ch">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hao Yu's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">The program monkey was eaten by the siege lion.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-mybetterhalf">
          <a href="/mybetterhalf/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>
            
            mybetterhalf
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="Searching..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/15/Leetcode51_100/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Leetcode51 - 100</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-15T01:41:00+08:00">
                2020-05-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Leetcode53-Maximum-Subarray"><a href="#Leetcode53-Maximum-Subarray" class="headerlink" title="Leetcode53. Maximum Subarray"></a>Leetcode53. Maximum Subarray</h1><p>Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.</p>
<p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [-2,1,-3,4,-1,2,1,-5,4],</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: [4,-1,2,1] has the largest sum = 6.</span><br></pre></td></tr></table></figure></p>
<p>这道题让求最大子数组之和，并且要用两种方法来解，分别是 O(n) 的解法，还有用分治法 Divide and Conquer Approach，这个解法的时间复杂度是 O(nlgn)，那就先来看 O(n) 的解法，定义两个变量 res 和max_local，其中 res 保存最终要返回的结果，即最大的子数组之和，max_local 初始值为0，每遍历一个数字 num，比较 max_local + num 和 num 中的较大值存入 max_local，然后再把 res 和 max_local 中的较大值存入 res，以此类推直到遍历完整个数组，可得到最大子数组的值存在 res 中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int res = INT_MIN, sum = 0;</span><br><span class="line">        int size = nums.size();</span><br><span class="line">        int max_local = 0;</span><br><span class="line">        for(int i = 0; i &lt; size; i ++) &#123;</span><br><span class="line">            max_local = max(max_local+nums[i], nums[i]);</span><br><span class="line">            res = max(max_local, res);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>题目还要求我们用分治法 Divide and Conquer Approach 来解，这个分治法的思想就类似于二分搜索法，需要把数组一分为二，分别找出左边和右边的最大子数组之和，然后还要从中间开始向左右分别扫描，求出的最大值分别和左右两边得出的最大值相比较取最大的那一个。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">/*        int res = INT_MIN, sum = 0;</span><br><span class="line">        int size = nums.size();</span><br><span class="line">        int max_local = 0;</span><br><span class="line">        for(int i = 0; i &lt; size; i ++) &#123;</span><br><span class="line">            max_local = max(max_local+nums[i], nums[i]);</span><br><span class="line">            res = max(max_local, res);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">*/</span><br><span class="line">        if (nums.empty()) </span><br><span class="line">            return 0;</span><br><span class="line">        return helper(nums, 0, nums.size()-1);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int helper(vector&lt;int&gt;&amp; nums, int left, int right) &#123;</span><br><span class="line">        if(left &gt;= right)</span><br><span class="line">            return nums[left];</span><br><span class="line">        int mid = (left + right) / 2;</span><br><span class="line">        int lmax = helper(nums, left, mid - 1);</span><br><span class="line">        int rmax = helper(nums, mid + 1, right);</span><br><span class="line">        int mmax = nums[mid], t = mmax;</span><br><span class="line">        for (int i = mid - 1; i &gt;= left; --i) &#123;</span><br><span class="line">            t += nums[i];</span><br><span class="line">            mmax = max(mmax, t);</span><br><span class="line">        &#125;</span><br><span class="line">        t = mmax;</span><br><span class="line">        for (int i = mid + 1; i &lt;= right; ++i) &#123;</span><br><span class="line">            t += nums[i];</span><br><span class="line">            mmax = max(mmax, t);</span><br><span class="line">        &#125;</span><br><span class="line">        return max(mmax, max(lmax, rmax));</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode55-Jump-Game"><a href="#Leetcode55-Jump-Game" class="headerlink" title="Leetcode55. Jump Game"></a>Leetcode55. Jump Game</h1><p>Given an array of non-negative integers, you are initially positioned at the first index of the array.</p>
<p>Each element in the array represents your maximum jump length at that position.</p>
<p>Determine if you are able to reach the last index.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [2,3,1,1,4]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [3,2,1,0,4]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index.</span><br></pre></td></tr></table></figure></p>
<p>Constraints:</p>
<p>1 &lt;= nums.length &lt;= 3 * 10^4<br>0 &lt;= nums[i][j] &lt;= 10^5</p>
<p>给出一串n个非负数的序列nums，其中nums[i]表示你当前在第i个数时最多能前进num[i]步，初始时你在第1个数，问：最后能否到第n个数？举例说明：A = [2,3,1,1,4], return true. A = [3,2,1,0,4], return false.</p>
<p>解题思路：<br>根据题意可知，对于点i，在该点能到达的最远位置为i+nums[i]，前提是，能到达点i。这样我们可以从左到右遍历，维护一个当前所能到达的最大边界reach，始终保持当前遍历的点i &lt;= reach，这样点i都是可以到达的，再根据nums[i]+i来更新reach的大小。若最后能遍历到点n，返回true，否则返回false。</p>
<p>算法正确性：<br>每次遍历都是在已经能到达的范围内，接着计算的结果可以更新边界。保证走出的每一步都是可以到达的，故算法正确。算法复杂度O(n)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool canJump(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int result = 0;</span><br><span class="line">        for(int i = 0; i &lt; nums.size(); i ++) &#123;</span><br><span class="line">            result = max(nums[i] + i, result);</span><br><span class="line">        &#125;</span><br><span class="line">        return result == nums.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode56-Merge-Intervals"><a href="#Leetcode56-Merge-Intervals" class="headerlink" title="Leetcode56. Merge Intervals"></a>Leetcode56. Merge Intervals</h1><p>Given a collection of intervals, merge all overlapping intervals.<br>一些区间，要求合并重叠的区间，返回一个vector保存结果。</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,3],[2,6],[8,10],[15,18]]</span><br><span class="line">Output: [[1,6],[8,10],[15,18]]</span><br><span class="line">Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,4],[4,5]]</span><br><span class="line">Output: [[1,5]]</span><br><span class="line">Explanation: Intervals [1,4] and [4,5] are considered overlapping.</span><br></pre></td></tr></table></figure></p>
<p>贪心思路，将初始区间序列ins按照左端点的从小到大排序，接着遍历ins。 一开始将第一个区间ins[0]放入结果区间序列res，接着每次遍历到一个新的区间[l,r]，将其与当前合并后的最后一个区间[L,R]比较：</p>
<blockquote>
<p>若l &lt;= R，说明新区间与当前最有一个区间有重叠，应该将这两个区间合并，也就需要修改当前最后一个区间为[L，max(r,R)]。<br>若l &gt; R，说明新区间与当前最后一个区间没有重叠，所以不需要合并，直接将新区间加入结果序列res，成为新的最后一个区间。</p>
</blockquote>
<p>算法正确性：</p>
<p>在上述贪心思路中，只考虑了新区间的左端点与最后一个区间的右端点的大小比较，最后只会对最后区间的右端点进行修改，却不会修改左端点。之所以不考虑左端点，是因为初始化时已经将ins按照左端点排序，保证后遍历的左端点l &gt;= 之前遍历过的左端点L。 算法复杂度为O(nlogn)。</p>
<p>我的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for an interval.</span><br><span class="line"> * struct Interval &#123;</span><br><span class="line"> *     int start;</span><br><span class="line"> *     int end;</span><br><span class="line"> *     Interval() : start(0), end(0) &#123;&#125;</span><br><span class="line"> *     Interval(int s, int e) : start(s), end(e) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    static bool comp(const Interval &amp;a, const Interval &amp;b) &#123;</span><br><span class="line">        return a.start &lt; b.start;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    vector&lt;Interval&gt; merge(vector&lt;Interval&gt;&amp; intervals) &#123;</span><br><span class="line">        vector&lt;Interval&gt; answer;</span><br><span class="line">        if(intervals.size() == 0)</span><br><span class="line">            return answer;</span><br><span class="line">        sort(intervals.begin(), intervals.end(), comp);</span><br><span class="line">        Interval ttt(intervals[0].start, intervals[0].end);</span><br><span class="line">        vector&lt;Interval&gt;::iterator it = intervals.begin();</span><br><span class="line">        it ++;</span><br><span class="line">        for(; it != intervals.end(); it++)&#123;</span><br><span class="line">            if(ttt.end &gt;= it-&gt;start)&#123;</span><br><span class="line">                if(ttt.end &lt; it-&gt;end)</span><br><span class="line">                    ttt.end = it-&gt;end;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(ttt.end &lt; it-&gt;start)&#123;</span><br><span class="line">                answer.push_back(ttt);</span><br><span class="line">                ttt.start = it-&gt;start;</span><br><span class="line">                ttt.end = it-&gt;end;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        answer.push_back(ttt);</span><br><span class="line">        return answer;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>题解的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public:</span><br><span class="line">        static bool cmp(const Interval &amp;a, const Interval &amp;b) &#123;</span><br><span class="line">            return a.start &lt; b.start;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;Interval&gt; merge(vector&lt;Interval&gt;&amp; ins) &#123;</span><br><span class="line">            vector &lt;Interval&gt; res;</span><br><span class="line">            if (ins.empty()) return res;</span><br><span class="line">            sort(ins.begin(), ins.end(), cmp);</span><br><span class="line">            res.push_back(ins[0]);</span><br><span class="line">            int cnt = ins.size();</span><br><span class="line">            for (int i = 1; i &lt; cnt; i++) &#123;</span><br><span class="line">                if (ins[i].start &lt;= res.back().end) &#123;</span><br><span class="line">                    res.back().end = max(res.back().end, ins[i].end);</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    res.push_back(ins[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>Solution<br>Approach 1: Connected Components<br>Intuition</p>
<p>If we draw a graph (with intervals as nodes) that contains undirected edges between all pairs of intervals that overlap, then all intervals in each connected component of the graph can be merged into a single interval.</p>
<p>Algorithm</p>
<p>With the above intuition in mind, we can represent the graph as an adjacency list, inserting directed edges in both directions to simulate undirected edges. Then, to determine which connected component each node is it, we perform graph traversals from arbitrary unvisited nodes until all nodes have been visited. To do this efficiently, we store visited nodes in a Set, allowing for constant time containment checks and insertion. Finally, we consider each connected component, merging all of its intervals by constructing a new Interval with start equal to the minimum start among them and end equal to the maximum end.</p>
<p>This algorithm is correct simply because it is basically the brute force solution. We compare every interval to every other interval, so we know exactly which intervals overlap. The reason for the connected component search is that two intervals may not directly overlap, but might overlap indirectly via a third interval. See the example below to see this more clearly.</p>
<p>Components Example</p>
<p>Although (1, 5) and (6, 10) do not directly overlap, either would overlap with the other if first merged with (4, 7). There are two connected components, so if we merge their nodes, we expect to get the following two merged intervals:</p>
<p>(1, 10), (15, 20)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    private Map&lt;Interval, List&lt;Interval&gt; &gt; graph;</span><br><span class="line">    private Map&lt;Integer, List&lt;Interval&gt; &gt; nodesInComp;</span><br><span class="line">    private Set&lt;Interval&gt; visited;</span><br><span class="line"></span><br><span class="line">    // return whether two intervals overlap (inclusive)</span><br><span class="line">    private boolean overlap(Interval a, Interval b) &#123;</span><br><span class="line">        return a.start &lt;= b.end &amp;&amp; b.start &lt;= a.end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // build a graph where an undirected edge between intervals u and v exists</span><br><span class="line">    // iff u and v overlap.</span><br><span class="line">    private void buildGraph(List&lt;Interval&gt; intervals) &#123;</span><br><span class="line">        graph = new HashMap&lt;&gt;();</span><br><span class="line">        for (Interval interval : intervals) &#123;</span><br><span class="line">            graph.put(interval, new LinkedList&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (Interval interval1 : intervals) &#123;</span><br><span class="line">            for (Interval interval2 : intervals) &#123;</span><br><span class="line">                if (overlap(interval1, interval2)) &#123;</span><br><span class="line">                    graph.get(interval1).add(interval2);</span><br><span class="line">                    graph.get(interval2).add(interval1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def merge(self, intervals):</span><br><span class="line">        intervals.sort(key=lambda x: x.start)</span><br><span class="line"></span><br><span class="line">        merged = []</span><br><span class="line">        for interval in intervals:</span><br><span class="line">            # if the list of merged intervals is empty or if the current</span><br><span class="line">            # interval does not overlap with the previous, simply append it.</span><br><span class="line">            if not merged or merged[-1].end &lt; interval.start:</span><br><span class="line">                merged.append(interval)</span><br><span class="line">            else:</span><br><span class="line">            # otherwise, there is overlap, so we merge the current and previous</span><br><span class="line">            # intervals.</span><br><span class="line">                merged[-1].end = max(merged[-1].end, interval.end)</span><br><span class="line"></span><br><span class="line">        return merged</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode57-Insert-Interval"><a href="#Leetcode57-Insert-Interval" class="headerlink" title="Leetcode57. Insert Interval"></a>Leetcode57. Insert Interval</h1><p>Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary). You may assume that the intervals were initially sorted according to their start times.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: intervals = [[1,3],[6,9]], newInterval = [2,5]</span><br><span class="line">Output: [[1,5],[6,9]]</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]</span><br><span class="line">Output: [[1,2],[3,10],[12,16]]</span><br><span class="line">Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].</span><br></pre></td></tr></table></figure></p>
<p>NOTE: input types have been changed on April 15, 2019. Please reset to default code definition to get new method signature.</p>
<p>这道题让我们在一系列非重叠的区间中插入一个新的区间，可能还需要和原有的区间合并，可以对给定的区间集进行一个一个的遍历比较，那么会有两种情况，重叠或是不重叠，不重叠的情况最好，直接将新区间插入到对应的位置即可，重叠的情况比较复杂，有时候会有多个重叠，需要更新新区间的范围以便包含所有重叠，之后将新区间加入结果 res，最后将后面的区间再加入结果 res 即可。具体思路是，用一个变量 cur 来遍历区间，如果当前 cur 区间的结束位置小于要插入的区间的起始位置的话，说明没有重叠，则将 cur 区间加入结果 res 中，然后 cur 自增1。直到有 cur 越界或有重叠 while 循环退出，然后再用一个 while 循环处理所有重叠的区间，每次用取两个区间起始位置的较小值，和结束位置的较大值来更新要插入的区间，然后 cur 自增1。直到 cur 越界或者没有重叠时 while 循环退出。之后将更新好的新区间加入结果 res，然后将 cur 之后的区间再加入结果 res 中即可，参见代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; insert(vector&lt;vector&lt;int&gt;&gt;&amp; intervals, vector&lt;int&gt;&amp; newInterval) &#123;</span><br><span class="line">        int length = intervals.size();</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; result;</span><br><span class="line">        int begin, end, last_end, i=0;</span><br><span class="line">        while(i &lt; length &amp;&amp; intervals[i][1] &lt; newInterval[0]) &#123;</span><br><span class="line">            result.push_back(intervals[i]);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        while(i &lt; length &amp;&amp; intervals[i][0] &lt;= newInterval[1]) &#123;</span><br><span class="line">            newInterval[0] = min(intervals[i][0],newInterval[0]);</span><br><span class="line">            newInterval[1] = max(intervals[i][1],newInterval[1]);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        result.push_back(newInterval);</span><br><span class="line">        while(i &lt; length) &#123;</span><br><span class="line">            result.push_back(intervals[i]);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;    </span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode58-Length-of-Last-Word"><a href="#Leetcode58-Length-of-Last-Word" class="headerlink" title="Leetcode58. Length of Last Word"></a>Leetcode58. Length of Last Word</h1><p>Given a string s consists of upper/lower-case alphabets and empty space characters ‘ ‘, return the length of last word (last word means the last appearing word if we loop from left to right) in the string.<br>If the last word does not exist, return 0.</p>
<p>Note: A word is defined as a maximal substring consisting of non-space characters only.</p>
<p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;Hello World&quot;</span><br><span class="line">Output: 5</span><br></pre></td></tr></table></figure></p>
<p>找到一个字符串里的最后一个单词，有很多的特殊样例：比如<code>&quot; &quot;</code>，<code>&quot;      &quot;</code>，<code>&quot;a &quot;</code>，<code>&quot;&quot;</code>等等吧，错了好几次。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int lengthOfLastWord(string s) &#123;</span><br><span class="line">        int size = s.length();</span><br><span class="line">        if(size == 0 || size == 1 &amp;&amp; s[0] == &apos; &apos;)</span><br><span class="line">            return 0;</span><br><span class="line">        int res = 0, i = size - 1;</span><br><span class="line">        while(i &gt;= 0 &amp;&amp; s[i] == &apos; &apos;)</span><br><span class="line">            i--;</span><br><span class="line">        for(; i &gt;= 0 &amp;&amp; s[i] != &apos; &apos;; i --) &#123;</span><br><span class="line">                res ++;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode59-Spiral-Matrix-II"><a href="#Leetcode59-Spiral-Matrix-II" class="headerlink" title="Leetcode59. Spiral Matrix II"></a>Leetcode59. Spiral Matrix II</h1><p>Given a positive integer n, generate a square matrix filled with elements from 1 to n^2 in spiral order.</p>
<p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: 3</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line"> [ 1, 2, 3 ],</span><br><span class="line"> [ 8, 9, 4 ],</span><br><span class="line"> [ 7, 6, 5 ]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>先清空矩阵，把数字从小到大填进去，那么就是一直往前走的一条线，每次这条线到尽头或者到一个填过的点就右转（初始在[0,0]位置方向向右）。那么就可以直接拿x方向的增量和y方向的增量来模拟，每次试着从上一次的增量方向前进，如果到了边界外或者到过的点，就修正方向（右转），并继续前进，直至填的数字大于n*n。</p>
<p>如n=2的情况，初始化：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[0, 0],</span><br><span class="line">[0, 0]</span><br></pre></td></tr></table></figure></p>
<p>当前位置[0,0]，x增量0，y增量1，填的数字是1<br>填充，前进一步：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1, 0],</span><br><span class="line">[0, 0]</span><br></pre></td></tr></table></figure></p>
<p>当前位置[0,1]，x增量0，y增量1，填的数字是2<br>填充，试着前进一步，发现出了边界，修正方向为向下。重新前进一步：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1, 2],</span><br><span class="line">[0, 0]</span><br></pre></td></tr></table></figure></p>
<p>当前位置[1,1]，x增量1，y增量0，填的数字是3<br>填充，试着前进一步，发现出了边界，修正方向为向左。重新前进一步：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1, 2],</span><br><span class="line">[0, 3]</span><br></pre></td></tr></table></figure></p>
<p>当前位置[1,0]，x增量0，y增量-1，填的数字是4<br>填充，填完后填的数字变成了5，大于2*2，结束。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1, 2],</span><br><span class="line">[4, 3]</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void turn(int &amp;x, int &amp;y) &#123;</span><br><span class="line">        if(x==0 &amp;&amp; y==1)</span><br><span class="line">            x=1,y=0;</span><br><span class="line">        else if(x==0 &amp;&amp; y==-1) </span><br><span class="line">            x=-1,y=0;</span><br><span class="line">        else if(x==1 &amp;&amp; y==0)</span><br><span class="line">            x=0,y=-1;</span><br><span class="line">        else if(x==-1 &amp;&amp; y==0)</span><br><span class="line">            x=0,y=1;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; generateMatrix(int n) &#123;</span><br><span class="line">        int x_dir = 0, y_dir = 1;</span><br><span class="line">        int x = 0, y = 0;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; result(n, vector&lt;int&gt;(n, 0));</span><br><span class="line">        for(int i = 1; i &lt;= n*n; i ++) &#123;</span><br><span class="line">            result[x][y] = i;</span><br><span class="line">            if(x+x_dir&lt;0 || x+x_dir&gt;=n || y+y_dir&lt;0 || y+y_dir&gt;=n || result[x+x_dir][y+y_dir])</span><br><span class="line">                turn(x_dir, y_dir);</span><br><span class="line">            x += x_dir;</span><br><span class="line">            y += y_dir;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode62-Unique-Paths"><a href="#Leetcode62-Unique-Paths" class="headerlink" title="Leetcode62. Unique Paths"></a>Leetcode62. Unique Paths</h1><p>A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below).</p>
<p>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below).</p>
<p>How many possible unique paths are there?</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: m = 3, n = 2</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure></p>
<p>Explanation:<br>From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:</p>
<ol>
<li>Right -&gt; Right -&gt; Down</li>
<li>Right -&gt; Down -&gt; Right</li>
<li>Down -&gt; Right -&gt; Right</li>
</ol>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: m = 7, n = 3</span><br><span class="line">Output: 28</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int uniquePaths(int m, int n) &#123;</span><br><span class="line">        int dp[m+1][n+1];</span><br><span class="line">        for(int i=0;i&lt;=m;i++)</span><br><span class="line">            dp[i][0] = 0;</span><br><span class="line">        for(int i=0;i&lt;=n;i++)</span><br><span class="line">            dp[0][i] = 0;</span><br><span class="line">        </span><br><span class="line">        for(int i = 1; i &lt;= m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int j = 1; j &lt;= n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                if(i==1 &amp;&amp; j==1)</span><br><span class="line">                    dp[i][j]=1;</span><br><span class="line">                else</span><br><span class="line">                    dp[i][j] = dp[i-1][j] + dp[i][j - 1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode63-Unique-Paths-II"><a href="#Leetcode63-Unique-Paths-II" class="headerlink" title="Leetcode63. Unique Paths II"></a>Leetcode63. Unique Paths II</h1><p>A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below).</p>
<p>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below).</p>
<p>Now consider if some obstacles are added to the grids. How many unique paths would there be?</p>
<p>Note: m and n will be at most 100.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">  [0,0,0],</span><br><span class="line">  [0,1,0],</span><br><span class="line">  [0,0,0]</span><br><span class="line">]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure></p>
<p>Explanation:<br>There is one obstacle in the middle of the 3x3 grid above.</p>
<p>There are two ways to reach the bottom-right corner:</p>
<ol>
<li>Right -&gt; Right -&gt; Down -&gt; Down</li>
<li>Down -&gt; Down -&gt; Right -&gt; Right</li>
</ol>
<p>第62题（Unique Paths）的升级版.  现在需要考虑如果表格中存在一些障碍，那么所要求的路径数还有多少条？  在表格表示中，1表示此位置有障碍，0表示没有.  例如在一个3 x 3的表格中存在一个障碍物，  </p>
<p>[<br>   [0,0,0],<br>   [0,1,0],<br>   [0,0,0]<br>]<br>求得最终的路径数为2.  注意：m 和 n 均不超过100.  </p>
<p>题解<br>算法及复杂度（3 ms）  本题解法参考第62题（Unique Paths）.本题和62题的唯一区别是存在了障碍物.但是这个对于算法是没有影响的.  在62题算法的基础上，在求解的过程中，每个点判断本点是否是障碍物，如果是则将dpi置0即可.  参考代码中与62题代码只添加了4行.  时间复杂度: O(mn)，表格中每个位置进行一次计算即可.  代码参见本文件夹下solution.cpp  </p>
<p>算法正确性<br>正确性证明  UniquePaths  举个例子  </p>
<p>// 输入数据<br>obstacleGrid = [<br>   [0,0,0],<br>   [0,1,0],<br>   [0,0,0]<br>]</p>
<p>//初始化m = 3, n = 3, p[0][0:n] = 0, dp[0:m][0] = 0, dp[1][1] = 1</p>
<p>//求解<br>dp[1][2] = dp[0][2] + dp[1][1] = 1<br>dp[1][3] = dp[0][3] + dp[1][2] = 1<br>dp[2][1] = dp[1][1] + dp[2][0] = 1<br>dp[2][2] = dp[1][2] + dp[2][1] = 2,由于obstacleGrid[1][1]位置为1，经过换算，也就是此位置为1，则dp[2][2] = 0<br>dp[2][3] = dp[1][3] + dp[2][2] = 1<br>dp[3][1] = dp[2][1] + dp[3][0] = 1<br>dp[3][2] = dp[2][2] + dp[3][1] = 1<br>dp[3][3] = dp[2][3] + dp[3][2] = 2</p>
<p>//return 2</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) &#123;</span><br><span class="line">        int m = obstacleGrid.size();</span><br><span class="line">        if(m == 0)</span><br><span class="line">            return 0;</span><br><span class="line">        int n = obstacleGrid[0].size();</span><br><span class="line">        if(n == 0)</span><br><span class="line">            return 0;</span><br><span class="line">        int dp[m+1][n+1];</span><br><span class="line">        for(int i = 0; i &lt;= m; i ++)</span><br><span class="line">            for(int j = 0; j &lt;= n; j ++)</span><br><span class="line">                dp[i][j] = 0;</span><br><span class="line">        for(int i = 0; i &lt;= m; i ++) dp[i][0] = 0;</span><br><span class="line">        for(int i = 0; i &lt;= n; i ++) dp[0][i] = 0;</span><br><span class="line">        </span><br><span class="line">        for(int i = 1; i &lt;= m; i ++) &#123;</span><br><span class="line">            for(int j = 1; j &lt;= n; j ++) &#123;</span><br><span class="line">                if(i == 1 &amp;&amp; j == 1)</span><br><span class="line">                    dp[i][j] = 1;</span><br><span class="line">                else</span><br><span class="line">                    dp[i][j] = dp[i][j-1] + dp[i-1][j];</span><br><span class="line">                if(obstacleGrid[i-1][j-1] == 1)</span><br><span class="line">                    dp[i][j] = 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode66-Plus-One"><a href="#Leetcode66-Plus-One" class="headerlink" title="Leetcode66. Plus One"></a>Leetcode66. Plus One</h1><p>Given a non-empty array of digits representing a non-negative integer, plus one to the integer.</p>
<p>The digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit. You may assume the integer does not contain any leading zero, except the number 0 itself.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3]</span><br><span class="line">Output: [1,2,4]</span><br><span class="line">Explanation: The array represents the integer 123.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [4,3,2,1]</span><br><span class="line">Output: [4,3,2,2]</span><br><span class="line">Explanation: The array represents the integer 4321.</span><br></pre></td></tr></table></figure></p>
<p>加一的操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; plusOne(vector&lt;int&gt;&amp; digits) &#123;</span><br><span class="line">        digits[digits.size() - 1] += 1;</span><br><span class="line">        for(int i = digits.size() - 1; i &gt;= 1; i --) &#123;</span><br><span class="line">            if(digits[i] == 10) &#123;</span><br><span class="line">                digits[i] = 0;</span><br><span class="line">                digits[i-1] ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(digits[0] == 10) &#123;</span><br><span class="line">            digits.insert(digits.begin(), 1);</span><br><span class="line">            digits[1] = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        return digits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode67-Add-Binary"><a href="#Leetcode67-Add-Binary" class="headerlink" title="Leetcode67. Add Binary"></a>Leetcode67. Add Binary</h1><p>Given two binary strings, return their sum (also a binary string). The input strings are both non-empty and contains only characters 1 or 0.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: a = &quot;11&quot;, b = &quot;1&quot;</span><br><span class="line">Output: &quot;100&quot;</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: a = &quot;1010&quot;, b = &quot;1011&quot;</span><br><span class="line">Output: &quot;10101&quot;</span><br></pre></td></tr></table></figure></p>
<p>设置一个进位标志。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string addBinary(string a, string b) &#123;</span><br><span class="line">        string res = &quot;&quot;;</span><br><span class="line">        int aa = a.length() - 1;</span><br><span class="line">        int bb = b.length() - 1;</span><br><span class="line">        int carry = 0;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        while(aa &gt;= 0 || bb &gt;= 0 || carry) &#123;</span><br><span class="line">            sum = carry;</span><br><span class="line">            if(aa &gt;= 0)</span><br><span class="line">                sum += (a[aa--] - &apos;0&apos;);</span><br><span class="line">            if(bb &gt;= 0)</span><br><span class="line">                sum += (b[bb--] - &apos;0&apos;);</span><br><span class="line">            res = to_string(sum%2) + res;</span><br><span class="line">            carry = sum / 2;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode69-Sqrt-x"><a href="#Leetcode69-Sqrt-x" class="headerlink" title="Leetcode69. Sqrt(x)"></a>Leetcode69. Sqrt(x)</h1><p>Implement int sqrt(int x). Compute and return the square root of x, where x is guaranteed to be a non-negative integer.</p>
<p>Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned.</p>
<p>Example 1:</p>
<p>Input: 4<br>Output: 2<br>Example 2:</p>
<p>Input: 8<br>Output: 2<br>Explanation: The square root of 8 is 2.82842…, and since<br>             the decimal part is truncated, 2 is returned.</p>
<p>二分求一个数的开方，做的恶心，垃圾题，浪费时间。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    </span><br><span class="line">    int mySqrt(int x) &#123;</span><br><span class="line">        int low = 0,  high = x, mid;</span><br><span class="line">        if(x&lt;2) return x; // to avoid mid = 0</span><br><span class="line">        while(low&lt;high)</span><br><span class="line">        &#123;</span><br><span class="line">            mid = (low + high)/2;</span><br><span class="line">            if(x/mid &gt;= mid) low = mid+1;</span><br><span class="line">            else high = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        return high-1;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode70-Climbing-Stairs"><a href="#Leetcode70-Climbing-Stairs" class="headerlink" title="Leetcode70. Climbing Stairs"></a>Leetcode70. Climbing Stairs</h1><p>You are climbing a stair case. It takes n steps to reach to the top.</p>
<p>Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?</p>
<p>Note: Given n will be a positive integer.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: 2</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: There are two ways to climb to the top.</span><br><span class="line">1. 1 step + 1 step</span><br><span class="line">2. 2 steps</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: 3</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: There are three ways to climb to the top.</span><br><span class="line">1. 1 step + 1 step + 1 step</span><br><span class="line">2. 1 step + 2 steps</span><br><span class="line">3. 2 steps + 1 step</span><br></pre></td></tr></table></figure></p>
<p>试着倒推想一下,就能发现这个问题可以被分解为一些包含最优子结构的子问题,它的最优解可以从其子问题<br>的最优解来有效地构建,因此我们可以使用动态规划解决这个问题.</p>
<p>第 i 阶可以由以下两种方法得到：</p>
<ul>
<li>在第 (i - 1) 阶后向上爬 1 阶。</li>
<li>在第 (i - 2) 阶后向上爬 2 阶</li>
<li>所以到达第 i 阶的方法总数就是到第 (i - 1) 阶和第 (i - 2) 阶的方法数之和。</li>
</ul>
<p>dp[i]dp[i] 表示能到达第 i 阶的方法总数,那么DP推导公式就是:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i] = dp[i − 1] + dp[i − 2]</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int climbStairs(int n) &#123;</span><br><span class="line">        int dp[n+1];</span><br><span class="line">        if (n==1 || n==2)</span><br><span class="line">            return n;</span><br><span class="line">        dp[1]=1;</span><br><span class="line">        dp[2]=2;</span><br><span class="line">        for(int i=3;i&lt;=n;i++) &#123;</span><br><span class="line">            dp[i] = dp[i-1]+dp[i-2];</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>进一步优化：根据推导公式不难发现,我们要求的结果就是数组的最后一项,而最后一项又是前面数值叠加起来的,那么我们只需要两个变量保存 i - 1 和 i - 2 的值就可以了.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * JavaScript 描述</span><br><span class="line"> */</span><br><span class="line">var climbStairs = function(n) &#123;</span><br><span class="line">    if (n == 1) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    let first = 1,</span><br><span class="line">        second = 2;</span><br><span class="line">    for (let i = 3; i &lt;= n; i++) &#123;</span><br><span class="line">       let third = first + second;</span><br><span class="line">       first = second;</span><br><span class="line">       second = third;</span><br><span class="line">    &#125;</span><br><span class="line">    return second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>复杂度分析</p>
<ul>
<li>时间复杂度：O(n)，单循环到 n。</li>
<li>空间复杂度：O(1)，用到了常量的空间。</li>
</ul>
<h1 id="Leetcode71-Simplify-Path"><a href="#Leetcode71-Simplify-Path" class="headerlink" title="Leetcode71. Simplify Path"></a>Leetcode71. Simplify Path</h1><p>Given an absolute path for a file (Unix-style), simplify it. Or in other words, convert it to the canonical path.</p>
<p>In a UNIX-style file system, a period . refers to the current directory. Furthermore, a double period .. moves the directory up a level.</p>
<p>Note that the returned canonical path must always begin with a slash /, and there must be only a single slash / between two directory names. The last directory name (if it exists) must not end with a trailing /. Also, the canonical path must be the shortest string representing the absolute path.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;/home/&quot;</span><br><span class="line">Output: &quot;/home&quot;</span><br><span class="line">Explanation: Note that there is no trailing slash after the last directory name.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;/../&quot;</span><br><span class="line">Output: &quot;/&quot;</span><br><span class="line">Explanation: Going one level up from the root directory is a no-op, as the root level is the highest level you can go.</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;/home//foo/&quot;</span><br><span class="line">Output: &quot;/home/foo&quot;</span><br><span class="line">Explanation: In the canonical path, multiple consecutive slashes are replaced by a single one.</span><br></pre></td></tr></table></figure></p>
<p>Example 4:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;/a/./b/../../c/&quot;</span><br><span class="line">Output: &quot;/c&quot;</span><br></pre></td></tr></table></figure></p>
<p>Example 5:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;/a/../../b/../c//.//&quot;</span><br><span class="line">Output: &quot;/c&quot;</span><br></pre></td></tr></table></figure></p>
<p>Example 6:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;/a//b////c/d//././/..&quot;</span><br><span class="line">Output: &quot;/a/b/c&quot;</span><br></pre></td></tr></table></figure></p>
<p>算法及复杂度 (6 ms) ：本题主要的处理对象分为: “.”, “..”, “/“, 普通文件或目录名.其中”.”的作用是保持当前的目录，”..”的作用是退回上一级目录，”/“的作用的分隔符, 普通文件或目录名不需要进行特殊处理.  很容易的思路（模拟），根据”/“对所有字符串进行分割，得到不同的三类字符串: “.”, “..”, 普通文件或目录名.分割过程是比较容易实现的，就是简单的读取字符串，然后分割.  由于”..”有回退的作用，因此可以考虑使用stack进行实现.在上一段中叙述的分割的过程中进行处理：</p>
<ul>
<li>遇到普通目录名就进行压栈；</li>
<li>遇到”.”就跳过不处理；</li>
<li>遇到”..”就对栈进行弹出（保证栈不为空的情况下）.  </li>
</ul>
<p>存在问题的几点: </p>
<ul>
<li>输入字符串为空字符串，则返回空字符串，而不是根目录”/“；</li>
<li>输入字符串的第一个字符一定是’/‘，而不是任意的（leetcode的参考程序会报错）；</li>
<li>存在”…”, “….”这样的路径，在本题中被认为是普通的目录或文件名.   </li>
</ul>
<p>时间复杂度: O(n). n 表示输入字符串的长度，只需要一次遍历就可以完成，因此是 O(n) 的复杂度. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">	public:</span><br><span class="line">    string simplifyPath(string path) &#123;</span><br><span class="line">        string temp, result;</span><br><span class="line">        int length = path.length();</span><br><span class="line">        stack&lt;string&gt; s;</span><br><span class="line">        for(int i = 0; i &lt; length; i ++) &#123;</span><br><span class="line">            temp = &quot;&quot;;</span><br><span class="line">            while(i &lt; length &amp;&amp; path[i] != &apos;/&apos;)</span><br><span class="line">                temp += path[i++];</span><br><span class="line">            if(temp == &quot;.&quot; || temp == &quot;&quot;)</span><br><span class="line">                continue;</span><br><span class="line">            else if(temp == &quot;..&quot;) &#123;</span><br><span class="line">                if(!s.empty())</span><br><span class="line">                    s.pop();</span><br><span class="line">                else</span><br><span class="line">                    continue;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                s.push(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        string ans = &quot;&quot;;</span><br><span class="line">        while(!s.empty()) &#123;</span><br><span class="line">            ans = &quot;/&quot; + s.top() + ans;</span><br><span class="line">            s.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        if(ans.length() == 0) &#123;</span><br><span class="line">            ans = &quot;/&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode72-Edit-Distance"><a href="#Leetcode72-Edit-Distance" class="headerlink" title="Leetcode72. Edit Distance"></a>Leetcode72. Edit Distance</h1><p>Given two words word1 and word2, find the minimum number of operations required to convert word1 to word2.</p>
<p>You have the following 3 operations permitted on a word:</p>
<p>Insert a character<br>Delete a character<br>Replace a character<br>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: word1 = &quot;horse&quot;, word2 = &quot;ros&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: </span><br><span class="line">horse -&gt; rorse (replace &apos;h&apos; with &apos;r&apos;)</span><br><span class="line">rorse -&gt; rose (remove &apos;r&apos;)</span><br><span class="line">rose -&gt; ros (remove &apos;e&apos;)</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: word1 = &quot;intention&quot;, word2 = &quot;execution&quot;</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: </span><br><span class="line">intention -&gt; inention (remove &apos;t&apos;)</span><br><span class="line">inention -&gt; enention (replace &apos;i&apos; with &apos;e&apos;)</span><br><span class="line">enention -&gt; exention (replace &apos;n&apos; with &apos;x&apos;)</span><br><span class="line">exention -&gt; exection (replace &apos;n&apos; with &apos;c&apos;)</span><br><span class="line">exection -&gt; execution (insert &apos;u&apos;)</span><br></pre></td></tr></table></figure></p>
<p>一道好久不做的dp题，过段时间闲下来复习下dp</p>
<p>给你word1、word2两个字符串，问最少需要几步才能把word1变成word2，下面每种操作都是一步：a)添加一个字符；b)添加一个字符；c)把一个字符用另一个字符代替。</p>
<p>解题思路：</p>
<p>动态规划。用dp[i][j]表示把word1的前i个字符变成word2的前j个字符所需的步数，word1的前i个字符变成word2的前j个字符可以由三种方法得到：</p>
<ol>
<li>word1先删去最后一个字符，然后把word1的前i-1个字符变成word2的前j个字符；</li>
<li>word1的前i个字符先变成word2的前j-1个字符；然后word2最后添上一个字符；</li>
<li>word1的前i-1个字符先变成word2的前j-1个字符；然后word1的最后一个字符和word2的最后一个字符匹配上。</li>
</ol>
<p>因此有状态转移方程：<br>当word1[i-1]==word2[j-1]时dp[i][j]=dp[i-1][j-1]，<br>否则dp[i][j]=min(dp[i-1][j]+1,dp[i][j-1]+1,dp[i-1][j-1]+1)。</p>
<p>另外边界需要初始化：dp[0][0]=0，dp[i][0]=i对于i从1到len1，dp[0][i]=i对于i从1到len2,。<br>最终答案为dp[len1][len2]，算法复杂度为O(len1*len2)。</p>
<p>算法正确性：</p>
<p>算法的关键点在于是否可以用动态规划的思想把问题拆分成一个个子问题。可以这么考虑：当你能确定用了若干步把word1的前i个字母变成word2的前j个字母后，接下来就可以处理相邻的状态。<br>对于删除字母，可以把word1的第i+1个字母先删掉，然后再执行那若干步，这样可以得到把word1的前i+1个字母变成word2的前j个字母的步数；<br>对于添加字母，可以先执行那若干步，再加上word2的第j+1个字母，这样可以得到把word1的前i个字母变成word2的前j+1个字母的步数；<br>对于代替字母，可以先执行那若干步，再把word1的第i+1个字母和word2的第j+1个字母匹配上，这样可以得到把word1的前i+1个字母变成word2的前j+1个字母的步数。因此上述算法是正确的。</p>
<p>下面举一个简单例子走一遍算法帮助理解：word1=”ad”，word2=”abc”。<br>初始化：dp[0][0]=0，dp[1][0]=1，dp[2][0]=2，dp[0][1]=1，dp[0][2]=2，dp[0][3]=3；<br>i=1，j=1，word1[0]==word2[0]，dp[1][1]=min(dp[0][1]+1,dp[1][0]+1,dp[0][0])=0；<br>i=1，j=2，word1[0]!=word2[1]，dp[1][2]=min(dp[0][2]+1,dp[1][1]+1,dp[0][1]+1)=2；<br>i=1，j=3，word1[0]!=word2[2]，dp[1][3]=min(dp[0][3]+1,dp[1][2]+1,dp[0][2]+1)=3；<br>i=2，j=1，word1[1]!=word2[0]，dp[2][1]=min(dp[1][1]+1,dp[2][0]+1,dp[1][0]+1)=1；<br>i=2，j=2，word1[1]!=word2[1]，dp[2][2]=min(dp[1][2]+1,dp[2][1]+1,dp[1][1]+1)=1；<br>i=2，j=3，word1[1]!=word2[2]，dp[2][3]=min(dp[1][3]+1,dp[2][2]+1,dp[1][2]+1)=2；<br>最终结果为dp[2][3]=3。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minDistance(string word1, string word2) &#123;</span><br><span class="line">        int len1=word1.size(),len2=word2.size();</span><br><span class="line">        int dp[len1+1][len2+1];</span><br><span class="line">        for(int i=0;i&lt;len1+1;i++)</span><br><span class="line">            dp[i][0]=i;</span><br><span class="line">        for(int i=0;i&lt;len2+1;i++)</span><br><span class="line">           dp[0][i]=i;</span><br><span class="line">        for(int i=1;i&lt;len1+1;i++)</span><br><span class="line">            for(int j=1;j&lt;len2+1;j++)&#123;</span><br><span class="line">                if(word1[i-1]==word2[j-1])</span><br><span class="line">                    dp[i][j]=dp[i-1][j-1];//两个字符相等</span><br><span class="line">                else</span><br><span class="line">                    dp[i][j]=min(dp[i-1][j]+1,min(dp[i][j-1]+1,dp[i-1][j-1]+1));//两个字符不相等</span><br><span class="line">            &#125;</span><br><span class="line">        return dp[len1][len2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode73-Set-Matrix-Zeroes"><a href="#Leetcode73-Set-Matrix-Zeroes" class="headerlink" title="Leetcode73. Set Matrix Zeroes"></a>Leetcode73. Set Matrix Zeroes</h1><p>Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in-place.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">[</span><br><span class="line">  [1,1,1],</span><br><span class="line">  [1,0,1],</span><br><span class="line">  [1,1,1]</span><br><span class="line">]</span><br><span class="line">Output: </span><br><span class="line">[</span><br><span class="line">  [1,0,1],</span><br><span class="line">  [0,0,0],</span><br><span class="line">  [1,0,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">[</span><br><span class="line">  [0,1,2,0],</span><br><span class="line">  [3,4,5,2],</span><br><span class="line">  [1,3,1,5]</span><br><span class="line">]</span><br><span class="line">Output: </span><br><span class="line">[</span><br><span class="line">  [0,0,0,0],</span><br><span class="line">  [0,4,5,0],</span><br><span class="line">  [0,3,1,0]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>Follow up:</p>
<ul>
<li>A straight forward solution using O(mn) space is probably a bad idea.</li>
<li>A simple improvement uses O(m + n) space, but still not the best solution.</li>
<li>Could you devise a constant space solution?</li>
</ul>
<p>我的慢出屎来的代码，如果一行中有0，那么这一行就都是0，如果一列中有0，那么这一列就都是0：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">	public:</span><br><span class="line">    void setZeroes(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        int m = matrix.size(), n = matrix[0].size();</span><br><span class="line">        vector&lt;int&gt; flags(m, 0);</span><br><span class="line">        for(int i = 0; i &lt; m; i ++) &#123;</span><br><span class="line">            for(int j = 0; j &lt; n; j ++) &#123;</span><br><span class="line">                if(matrix[i][j] == 0) &#123;</span><br><span class="line">                    flags[i] = 1;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;int&gt; flags2(n, 0);</span><br><span class="line">        for(int i = 0; i &lt; n; i ++) &#123;</span><br><span class="line">            for(int j = 0; j &lt; m; j ++) &#123;</span><br><span class="line">                if(matrix[j][i] == 0) &#123;</span><br><span class="line">                    flags2[i] = 1;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0; i &lt; m; i ++)</span><br><span class="line">            if(flags[i] == 1) </span><br><span class="line">                for(int j = 0; j &lt; n; j ++) </span><br><span class="line">                    matrix[i][j] = 0;</span><br><span class="line">	    for(int i = 0; i &lt; n; i ++)</span><br><span class="line">            if(flags2[i] == 1)</span><br><span class="line">                for(int j = 0; j &lt; m; j ++)</span><br><span class="line">                    matrix[j][i] = 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode75-Sort-Colors"><a href="#Leetcode75-Sort-Colors" class="headerlink" title="Leetcode75. Sort Colors"></a>Leetcode75. Sort Colors</h1><p>Given an array with n objects colored red, white or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white and blue.</p>
<p>Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.</p>
<p>Note: You are not suppose to use the library sort function for this problem.</p>
<p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,0,2,1,1,0]</span><br><span class="line">Output: [0,0,1,1,2,2]</span><br></pre></td></tr></table></figure></p>
<p>Follow up:</p>
<ul>
<li>A rather straight forward solution is a two-pass algorithm using counting sort.</li>
<li>First, iterate the array counting number of 0s, 1s, and 2s, then overwrite array with total number of 0s, then 1s and followed by 2s.</li>
<li>Could you come up with a one-pass algorithm using only constant space?</li>
</ul>
<p>这道题的本质还是一道排序的题，题目中给出提示说可以用计数排序，需要遍历数组两遍，那么先来看这种方法，因为数组中只有三个不同的元素，所以实现起来很容易。</p>
<ul>
<li>首先遍历一遍原数组，分别记录 0，1，2 的个数。</li>
<li>然后更新原数组，按个数分别赋上 0，1，2。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">	public:</span><br><span class="line">    void sortColors(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int f[3] = &#123;0, 0, 0&#125;;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        for(int i = 0; i &lt; n; i ++) &#123;</span><br><span class="line">            f[nums[i]] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        nums.clear();</span><br><span class="line">        for(int i = 0; i &lt; 3; i ++) &#123;</span><br><span class="line">            for(int j = 0; j &lt; f[i]; j ++)</span><br><span class="line">                nums.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>题目中还要让只遍历一次数组来求解，那么就需要用双指针来做，分别从原数组的首尾往中心移动。</p>
<ul>
<li>定义 red 指针指向开头位置，blue 指针指向末尾位置。</li>
<li>从头开始遍历原数组，如果遇到0，则交换该值和 red 指针指向的值，并将 red 指针后移一位。若遇到2，则交换该值和 blue 指针指向的值，并将 blue 指针前移一位。若遇到1，则继续遍历。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">	public:</span><br><span class="line">    void sortColors(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int red = 0, blue = (int)nums.size() - 1;</span><br><span class="line">        for (int i = 0; i &lt;= blue; ++i) &#123;</span><br><span class="line">            if (nums[i] == 0) &#123;</span><br><span class="line">                swap(nums[i], nums[red++]);</span><br><span class="line">            &#125; else if (nums[i] == 2) &#123;</span><br><span class="line">                swap(nums[i--], nums[blue--]);</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode76-Minimum-Window-Substring"><a href="#Leetcode76-Minimum-Window-Substring" class="headerlink" title="Leetcode76. Minimum Window Substring"></a>Leetcode76. Minimum Window Substring</h1><p>Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).</p>
<p>Example:</p>
<p>Input: S = “ADOBECODEBANC”, T = “ABC”<br>Output: “BANC”</p>
<p>这道题给了我们一个原字符串S，还有一个目标字符串T，让在S中找到一个最短的子串，使得其包含了T中的所有的字母，并且限制了时间复杂度为 O(n)。这道题的要求是要在 O(n) 的时间度里实现找到这个最小窗口字串，暴力搜索 Brute Force 肯定是不能用的，因为遍历所有的子串的时间复杂度是平方级的。那么来想一下，时间复杂度卡的这么严，说明必须在一次遍历中完成任务，当然遍历若干次也是 O(n)，但不一定有这个必要，尝试就一次遍历拿下！那么再来想，既然要包含T中所有的字母，那么对于T中的每个字母，肯定要快速查找是否在子串中，既然总时间都卡在了 O(n)，肯定不想在这里还浪费时间，就用空间换时间（也就算法题中可以这么干了，七老八十的富翁就算用大别野也换不来时间啊。依依东望，望的就是时间呐 T.T），使用 HashMap，建立T中每个字母与其出现次数之间的映射，那么你可能会有疑问，为啥不用 HashSet 呢，别急，讲到后面你就知道用 HashMap 有多妙，简直妙不可言～</p>
<p>目前在脑子一片浆糊的情况下，我们还是从简单的例子来分析吧，题目例子中的S有点长，换个短的 S = “ADBANC”，T = “ABC”，那么肉眼遍历一遍S呗，首先第一个是A，嗯很好，T中有，第二个是D，T中没有，不理它，第三个是B，嗯很好，T中有，第四个又是A，多了一个，礼多人不怪嘛，收下啦，第五个是N，一边凉快去，第六个终于是C了，那么貌似好像需要整个S串，其实不然，注意之前有多一个A，就算去掉第一个A，也没事，因为第四个A可以代替之，第二个D也可以去掉，因为不在T串中，第三个B就不能再去掉了，不然就没有B了。所以最终的答案就”BANC”了。通过上面的描述，你有没有发现一个有趣的现象，先扩展，再收缩，就好像一个窗口一样，先扩大右边界，然后再收缩左边界，上面的例子中右边界无法扩大了后才开始收缩左边界，实际上对于复杂的例子，有可能是扩大右边界，然后缩小一下左边界，然后再扩大右边界等等。这就很像一个不停滑动的窗口了，这就是大名鼎鼎的滑动窗口 Sliding Window 了，简直是神器啊，能解很多子串，子数组，子序列等等的问题，是必须要熟练掌握的啊！</p>
<p>下面来考虑用代码来实现，先来回答一下前面埋下的伏笔，为啥要用 HashMap，而不是 HashSet，现在应该很显而易见了吧，因为要统计T串中字母的个数，而不是仅仅看某个字母是否在T串中出现。统计好T串中字母的个数了之后，开始遍历S串，对于S中的每个遍历到的字母，都在 HashMap 中的映射值减1，如果减1后的映射值仍大于等于0，说明当前遍历到的字母是T串中的字母，使用一个计数器 cnt，使其自增1。当 cnt 和T串字母个数相等时，说明此时的窗口已经包含了T串中的所有字母，此时更新一个 minLen 和结果 res，这里的 minLen 是一个全局变量，用来记录出现过的包含T串所有字母的最短的子串的长度，结果 res 就是这个最短的子串。然后开始收缩左边界，由于遍历的时候，对映射值减了1，所以此时去除字母的时候，就要把减去的1加回来，此时如果加1后的值大于0了，说明此时少了一个T中的字母，那么 cnt 值就要减1了，然后移动左边界 left。你可能会疑问，对于不在T串中的字母的映射值也这么加呀减呀的，真的大丈夫（带胶布）吗？其实没啥事，因为对于不在T串中的字母，减1后，变-1，cnt 不会增加，之后收缩左边界的时候，映射值加1后为0，cnt 也不会减少，所以并没有什么影响啦，下面是具体的步骤啦：</p>
<ul>
<li><p>先扫描一遍T，把对应的字符及其出现的次数存到 HashMap 中。</p>
</li>
<li><p>然后开始遍历S，就把遍历到的字母对应的 HashMap 中的 value 减一，如果减1后仍大于等于0，cnt 自增1。</p>
</li>
<li><p>如果 cnt 等于T串长度时，开始循环，纪录一个字串并更新最小字串值。然后将子窗口的左边界向右移，如果某个移除掉的字母是T串中不可缺少的字母，那么 cnt 自减1，表示此时T串并没有完全匹配。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">	public:</span><br><span class="line">    string minWindow(string s, string t) &#123;</span><br><span class="line">        int left = 0, right = 0, minLen = INT_MAX;</span><br><span class="line">        string res = &quot;&quot;;</span><br><span class="line">        unordered_map&lt;char, int&gt; letter;</span><br><span class="line">        for(char c : t) </span><br><span class="line">            letter[c] ++;</span><br><span class="line">        for(int i = 0; i &lt; s.size(); i ++) &#123;</span><br><span class="line">            if(--letter[s[i]] &gt;= 0)</span><br><span class="line">                right ++;</span><br><span class="line">            while(right == t.size()) &#123;</span><br><span class="line">                if(minLen &gt; i + 1 - left) &#123;</span><br><span class="line">                    minLen = i + 1 - left;</span><br><span class="line">                    res = s.substr(left, minLen);</span><br><span class="line">                &#125;</span><br><span class="line">                if(++letter[s[left]] &gt; 0)</span><br><span class="line">                    right --;</span><br><span class="line">	                left ++;</span><br><span class="line">	            &#125;</span><br><span class="line">	        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode78-Subsets"><a href="#Leetcode78-Subsets" class="headerlink" title="Leetcode78. Subsets"></a>Leetcode78. Subsets</h1><p>Given a set of distinct integers, nums, return all possible subsets (the power set).</p>
<p>Note: The solution set must not contain duplicate subsets.</p>
<p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,2,3]</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [1],</span><br><span class="line">  [2],</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>可以一位一位的网上叠加，比如对于题目中给的例子 [1,2,3] 来说，最开始是空集，那么我们现在要处理1，就在空集上加1，为 [1]，现在我们有两个自己 [] 和 [1]，下面我们来处理2，我们在之前的子集基础上，每个都加个2，可以分别得到 [2]，[1, 2]，那么现在所有的子集合为 [], [1], [2], [1, 2]，同理处理3的情况可得 [3], [1, 3], [2, 3], [1, 2, 3], 再加上之前的子集就是所有的子集合了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">	public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt; &gt; res;</span><br><span class="line">        res.push_back(&#123;&#125;);</span><br><span class="line">        for(int i = 0; i &lt; nums.size(); i ++) &#123;</span><br><span class="line">            int size = res.size();</span><br><span class="line">            for(int j = 0; j &lt; size; j ++) &#123;</span><br><span class="line">                vector&lt;int&gt; temp = res[j];</span><br><span class="line">                temp.push_back(nums[i]);</span><br><span class="line">                res.push_back(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode79-Word-Search"><a href="#Leetcode79-Word-Search" class="headerlink" title="Leetcode79. Word Search"></a>Leetcode79. Word Search</h1><p>Given a 2D board and a word, find if the word exists in the grid.</p>
<p>The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.</p>
<p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">board =</span><br><span class="line">[</span><br><span class="line">  [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;E&apos;],</span><br><span class="line">  [&apos;S&apos;,&apos;F&apos;,&apos;C&apos;,&apos;S&apos;],</span><br><span class="line">  [&apos;A&apos;,&apos;D&apos;,&apos;E&apos;,&apos;E&apos;]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">Given word = &quot;ABCCED&quot;, return true.</span><br><span class="line">Given word = &quot;SEE&quot;, return true.</span><br><span class="line">Given word = &quot;ABCB&quot;, return false.</span><br></pre></td></tr></table></figure></p>
<p>Constraints:</p>
<ul>
<li>board and word consists only of lowercase and uppercase English letters.</li>
<li>1 &lt;= board.length &lt;= 200</li>
<li>1 &lt;= board[i].length &lt;= 200</li>
<li>1 &lt;= word.length &lt;= 10^3</li>
</ul>
<p>典型的深度优先遍历 DFS 的应用，原二维数组就像是一个迷宫，可以上下左右四个方向行走，我们以二维数组中每一个数都作为起点和给定字符串做匹配，我们还需要一个和原数组等大小的 visited 数组，是 bool 型的，用来记录当前位置是否已经被访问过，因为题目要求一个 cell 只能被访问一次。如果二维数组 board 的当前字符和目标字符串 word 对应的字符相等，则对其上下左右四个邻字符分别调用 DFS 的递归函数，只要有一个返回 true，那么就表示可以找到对应的字符串，否则就不能找到。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">	public:</span><br><span class="line">    int m, n;</span><br><span class="line">    bool search(vector&lt;vector&lt;char&gt;&gt;&amp; board, int i, int j, int k, string word, vector&lt;vector&lt;bool&gt;&gt;&amp; visited) &#123;</span><br><span class="line">        if(word.length() == k) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        int m = board.size(), n = board[0].size();</span><br><span class="line">        if (i &lt; 0 || j &lt; 0 || i &gt;= m || j &gt;= n || visited[i][j] || board[i][j] != word[k]) </span><br><span class="line">            return false;</span><br><span class="line">        visited[i][j] = true;</span><br><span class="line">        bool res = search(board, i - 1, j, k + 1, word, visited) </span><br><span class="line">                || search(board, i + 1, j, k + 1, word, visited)</span><br><span class="line">                || search(board, i, j - 1, k + 1, word, visited)</span><br><span class="line">                || search(board, i, j + 1, k + 1, word, visited);</span><br><span class="line">        visited[i][j] = false;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) &#123;</span><br><span class="line">        m = board.size(), n = board[0].size();</span><br><span class="line">        vector&lt;vector&lt;bool&gt;&gt; visited(m, vector&lt;bool&gt;(n));</span><br><span class="line">        for(int i = 0; i &lt; m; i ++)</span><br><span class="line">            for(int j = 0; j &lt; n; j ++)</span><br><span class="line">                visited[i][j] = false;</span><br><span class="line">        for(int i = 0; i &lt; m; i ++)</span><br><span class="line">            for(int j = 0; j &lt; n; j ++)</span><br><span class="line">                if(search(board, i, j, 0, word, visited))</span><br><span class="line">                    return true;</span><br><span class="line">        return false;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode80-Remove-Duplicates-from-Sorted-Array-II"><a href="#Leetcode80-Remove-Duplicates-from-Sorted-Array-II" class="headerlink" title="Leetcode80. Remove Duplicates from Sorted Array II"></a>Leetcode80. Remove Duplicates from Sorted Array II</h1><p>Given a sorted array nums, remove the duplicates in-place such that duplicates appeared at most twice and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.</p>
<p>Example 1: Given nums = [1,1,1,2,2,3], Your function should return length = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively. It doesn not matter what you leave beyond the returned length.</p>
<p>Example 2: Given nums = [0,0,1,1,1,1,2,3,3], Your function should return length = 7, with the first seven elements of nums being modified to 0, 0, 1, 1, 2, 3 and 3 respectively.</p>
<p>Clarification: Confused why the returned value is an integer but your answer is an array? Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well. Internally you can think of this:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// nums is passed in by reference. (i.e., without making a copy)</span><br><span class="line">int len = removeDuplicates(nums);</span><br><span class="line"></span><br><span class="line">// any modification to nums in your function would be known by the caller.</span><br><span class="line">// using the length returned by your function, it prints the first len elements.</span><br><span class="line">for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">	print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>遍历一遍，记下来每次遍历开始的数，如果这个数的数量大于2了，一直i++。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">	public:</span><br><span class="line">    int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        if(nums.size() &lt;= 2)</span><br><span class="line">            return nums.size();</span><br><span class="line">        int prev_i = 0, prev;</span><br><span class="line">        int count = 0;</span><br><span class="line">        for(int i = 0; i &lt; nums.size();) &#123;</span><br><span class="line">            count = 0;</span><br><span class="line">            nums[prev_i] = nums[i];</span><br><span class="line">            prev = nums[i];</span><br><span class="line">            while(count &lt; 2 &amp;&amp; i &lt; nums.size() &amp;&amp; prev == nums[i])</span><br><span class="line">                nums[prev_i++] = nums[i], count ++, i++;</span><br><span class="line">            while(i &lt; nums.size() &amp;&amp; prev == nums[i])</span><br><span class="line">                i ++;</span><br><span class="line">        &#125;</span><br><span class="line">        return prev_i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>另一种方法是交换：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">	public:</span><br><span class="line">    int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        if (nums.size() &lt; 3) &#123;</span><br><span class="line">            return nums.size();</span><br><span class="line">        &#125;</span><br><span class="line">        int arrow = 2;</span><br><span class="line">        for (int i = 2; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            if (nums[arrow-2] != nums[i]) &#123;</span><br><span class="line">                swap(nums[arrow], nums[i]);</span><br><span class="line">                arrow++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return arrow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode81-Search-in-Rotated-Sorted-Array-II"><a href="#Leetcode81-Search-in-Rotated-Sorted-Array-II" class="headerlink" title="Leetcode81. Search in Rotated Sorted Array II"></a>Leetcode81. Search in Rotated Sorted Array II</h1><p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p>
<p>(i.e., [0,0,1,2,2,5,6] might become [2,5,6,0,0,1,2]).</p>
<p>You are given a target value to search. If found in the array return true, otherwise return false.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [2,5,6,0,0,1,2], target = 0</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [2,5,6,0,0,1,2], target = 3</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></p>
<p>本题采用二分法实现，但是比较挠头的是边界问题，而且元素有重复，相比纯粹递增的数组难度要大得多，要解决这个问题，首先要对所有可能情况进行分类，然后对每种可能的类别进行相应的处理。 </p>
<p>暂且不考虑nums[mid] = nums[left]的情况，本题大致可以简化为两种情况，可能的情况划分出来，那么解决本题就比较容易了：</p>
<ul>
<li>当 nums[mid] = nums[left] 时，这时由于很难判断 target 会落在哪，那么只能采取 left++</li>
<li>当 nums[mid] &gt; nums[left] 时，这时可以分为两种情况，判断左半部比较简单（如果target不在左边这部分，那么我们是可以直接去掉左边这部分的）</li>
<li>当 nums[mid] &lt; nums[left] 时，这时可以分为两种情况，判断右半部比较简单(如果target不在右边这部分，那么我们也是可以直接去掉右边这部分的)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">	public:</span><br><span class="line">    bool search(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        int left = 0, right = nums.size() - 1;</span><br><span class="line">        while(left &lt;= right) &#123;</span><br><span class="line">            int mid = (left + right) / 2;</span><br><span class="line">            if(nums[mid] == target) </span><br><span class="line">                return true;</span><br><span class="line">            if(nums[mid] == nums[left])</span><br><span class="line">                left ++;</span><br><span class="line">            else if(nums[mid] &gt; nums[left]) </span><br><span class="line">                if(nums[left] &lt;= target &amp;&amp; target &lt; nums[mid])</span><br><span class="line">                    right = mid - 1;</span><br><span class="line">                else</span><br><span class="line">                    left = mid + 1;</span><br><span class="line">            else  </span><br><span class="line">                if(nums[mid] &lt; target &amp;&amp; target &lt;= nums[right])</span><br><span class="line">                    left = mid + 1;</span><br><span class="line">                else</span><br><span class="line">                    right = mid - 1;    </span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode82-Remove-Duplicates-from-Sorted-List-II"><a href="#Leetcode82-Remove-Duplicates-from-Sorted-List-II" class="headerlink" title="Leetcode82. Remove Duplicates from Sorted List II"></a>Leetcode82. Remove Duplicates from Sorted List II</h1><p>Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list.</p>
<p>Return the linked list sorted as well.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5</span><br><span class="line">Output: 1-&gt;2-&gt;5</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1-&gt;1-&gt;1-&gt;2-&gt;3</span><br><span class="line">Output: 2-&gt;3</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">	public:</span><br><span class="line">    ListNode* deleteDuplicates(ListNode* head) &#123;</span><br><span class="line">        if(head == NULL || head-&gt;next == NULL)</span><br><span class="line">            return head;</span><br><span class="line">        ListNode* res = new ListNode(-1);</span><br><span class="line">        res-&gt;next = head;</span><br><span class="line">        ListNode* temp = res, *tempn;</span><br><span class="line">        while(temp != NULL &amp;&amp; temp-&gt;next != NULL) &#123;</span><br><span class="line">            ListNode* tempn = temp-&gt;next;</span><br><span class="line">            if(tempn-&gt;next &amp;&amp; tempn-&gt;next-&gt;val == tempn-&gt;val) &#123;</span><br><span class="line">                ListNode* tempp;</span><br><span class="line">                while(tempn-&gt;next &amp;&amp; tempn-&gt;next-&gt;val == tempn-&gt;val) &#123;</span><br><span class="line">                    tempp = tempn-&gt;next;</span><br><span class="line">                    tempn-&gt;next = tempp-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                temp-&gt;next = tempn-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">                temp = temp-&gt;next;</span><br><span class="line">	        &#125;</span><br><span class="line">        return res-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode83-Remove-Duplicates-from-Sorted-List"><a href="#Leetcode83-Remove-Duplicates-from-Sorted-List" class="headerlink" title="Leetcode83. Remove Duplicates from Sorted List"></a>Leetcode83. Remove Duplicates from Sorted List</h1><p>Given a sorted linked list, delete all duplicates such that each element appear only once.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1-&gt;1-&gt;2</span><br><span class="line">Output: 1-&gt;2</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1-&gt;1-&gt;2-&gt;3-&gt;3</span><br><span class="line">Output: 1-&gt;2-&gt;3</span><br></pre></td></tr></table></figure></p>
<p>删掉链表中重复多余的数字<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   * Definition for singly-linked list.</span><br><span class="line">   * struct ListNode &#123;</span><br><span class="line">   *     int val;</span><br><span class="line">   *     ListNode *next;</span><br><span class="line">   *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="line">   *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="line">   *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="line">   * &#125;;</span><br><span class="line">   */</span><br><span class="line">class Solution &#123;</span><br><span class="line">	public:</span><br><span class="line">    ListNode* deleteDuplicates(ListNode* head) &#123;</span><br><span class="line">        ListNode* temp = head;</span><br><span class="line">        ListNode* res = new ListNode(-1);</span><br><span class="line">        ListNode* cur = res;</span><br><span class="line">        if(temp != NULL &amp;&amp; temp-&gt;next == NULL)</span><br><span class="line">            return head;</span><br><span class="line">        while(temp != NULL &amp;&amp; temp-&gt;next != NULL) &#123;</span><br><span class="line">            while(temp-&gt;next != NULL &amp;&amp; temp-&gt;val == temp-&gt;next-&gt;val)</span><br><span class="line">                temp = temp-&gt;next;</span><br><span class="line">            cur-&gt;next = temp;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return res-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode88-Merge-Sorted-Array"><a href="#Leetcode88-Merge-Sorted-Array" class="headerlink" title="Leetcode88. Merge Sorted Array"></a>Leetcode88. Merge Sorted Array</h1><p>Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.</p>
<p>Note:</p>
<p>The number of elements initialized in nums1 and nums2 are m and n respectively.<br>You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2.<br>Example:</p>
<p>Input:<br>nums1 = [1,2,3,0,0,0], m = 3<br>nums2 = [2,5,6],       n = 3</p>
<p>Output: [1,2,2,3,5,6]</p>
<p>给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。很简单</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123;</span><br><span class="line">        if(n==0)</span><br><span class="line">            return;</span><br><span class="line">        if(m==0) &#123;</span><br><span class="line">            for(int i=0;i&lt;n;i++)</span><br><span class="line">                nums1[i] = nums2[i];</span><br><span class="line">            return ;</span><br><span class="line">        &#125;</span><br><span class="line">        int pointer = 0;</span><br><span class="line">        for(int i = 0; i &lt; n; i ++) &#123;</span><br><span class="line">            for(; pointer &lt; m; pointer ++)</span><br><span class="line">                if(nums2[i] &lt; nums1[pointer])</span><br><span class="line">                    break;</span><br><span class="line">            for(int ii = m; ii &gt; pointer; ii --) </span><br><span class="line">                nums1[ii] = nums1[ii - 1]; </span><br><span class="line">            m++;</span><br><span class="line">            nums1[pointer] = nums2[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123;</span><br><span class="line">        int i = m - 1;</span><br><span class="line">        int j = n - 1;</span><br><span class="line">        int k = m + n - 1;</span><br><span class="line">        while(i &gt;= 0 &amp;&amp; j &gt;= 0) &#123;</span><br><span class="line">            if(nums1[i] &gt;= nums2[j])</span><br><span class="line">                nums1[k--] = nums1[i--];</span><br><span class="line">            else</span><br><span class="line">                nums1[k--] = nums2[j--];</span><br><span class="line">        &#125;</span><br><span class="line">        while(j &gt;= 0)</span><br><span class="line">            nums1[k--] = nums2[j--];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode90-Subsets-II"><a href="#Leetcode90-Subsets-II" class="headerlink" title="Leetcode90. Subsets II"></a>Leetcode90. Subsets II</h1><p>Given a collection of integers that might contain duplicates, nums, return all possible subsets (the power set).</p>
<p>Note: The solution set must not contain duplicate subsets.</p>
<p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,2]</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [2],</span><br><span class="line">  [1],</span><br><span class="line">  [1,2,2],</span><br><span class="line">  [2,2],</span><br><span class="line">  [1,2],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>由于数组事先已经过排序，因此不需要再用额外的unordered_set去判断重复元素，直接判断nums[i]和nums[i - 1]是否相等就行了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    </span><br><span class="line">    void search(int start, vector&lt;int&gt;&amp; sub, vector&lt;vector&lt;int&gt;&gt;&amp; res, vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        res.push_back(sub);</span><br><span class="line">        for(int i = start; i &lt; nums.size(); i ++) &#123;</span><br><span class="line">            if(i == start || nums[i] != nums[i - 1])&#123;</span><br><span class="line">                sub.push_back(nums[i]);</span><br><span class="line">                search(i + 1, sub, res, nums);</span><br><span class="line">                sub.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        vector&lt;int&gt; sub;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        search(0, sub, res, nums);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode94-Binary-Tree-Inorder-Traversal"><a href="#Leetcode94-Binary-Tree-Inorder-Traversal" class="headerlink" title="Leetcode94. Binary Tree Inorder Traversal"></a>Leetcode94. Binary Tree Inorder Traversal</h1><p>Given a binary tree, return the inorder traversal of its nodes’ values.</p>
<p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,null,2,3]</span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    /</span><br><span class="line">   3</span><br><span class="line">Output: [1,3,2]</span><br></pre></td></tr></table></figure></p>
<p>需要用栈来做，思路是从根节点开始，先将根节点压入栈，然后再将其所有左子结点压入栈，然后取出栈顶节点，保存节点值，再将当前指针移到其右子节点上，若存在右子节点，则在下次循环时又可将其所有左子结点压入栈中。这样就保证了访问顺序为左-根-右。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">	public:</span><br><span class="line">    vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        if(root == NULL) </span><br><span class="line">            return &#123;&#125;;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        stack&lt;TreeNode*&gt; q;</span><br><span class="line">        TreeNode* temp = root;</span><br><span class="line">        while(temp || !q.empty()) &#123;</span><br><span class="line">            while(temp) &#123;</span><br><span class="line">                q.push(temp);</span><br><span class="line">                temp = temp-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = q.top();</span><br><span class="line">            q.pop();</span><br><span class="line">            res.push_back(temp-&gt;val);</span><br><span class="line">            temp = temp-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode96-Unique-Binary-Search-Trees"><a href="#Leetcode96-Unique-Binary-Search-Trees" class="headerlink" title="Leetcode96. Unique Binary Search Trees"></a>Leetcode96. Unique Binary Search Trees</h1><p>Given n, how many structurally unique BST’s (binary search trees) that store values 1 … n?</p>
<p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: 3</span><br><span class="line">Output: 5</span><br><span class="line">Explanation:</span><br><span class="line">Given n = 3, there are a total of 5 unique BST&apos;s:</span><br><span class="line"></span><br><span class="line">   1         3     3      2      1</span><br><span class="line">    \       /     /      / \      \</span><br><span class="line">     3     2     1      1   3      2</span><br><span class="line">    /     /       \                 \</span><br><span class="line">   2     1         2                 3</span><br></pre></td></tr></table></figure></p>
<p>思路：对于选定结点的元素，左边的元素构成左子树，右边的元素构成右子树，左子树和右子树构成种树的乘积就是总的个数。考虑根节点，设对于任意根节点k，有f(k)种树的可能。比k小的k-1个元素构成k的左子树。则左子树有f(k-1)种情况。比k大的n-k个元素构成k的右子树。则右子树有f(n-k)种情况。</p>
<p>易知，左右子树相互独立，所以f(k)=f(k-1)*f(n-k)。综上，对于n，结果为k取1,2,3,…,n时，所有f(k)的和。</p>
<p>代码思路：根据上述思路可以用简单的递归方法快速解决。现在考虑动态规划求解算法，用数组记录每个f(i)的值，记f(0)=1,f(1)=1。根据公式：f(k)=f(k-1)*f(n-k)，访问数组中的元素。循环求和，结果更新到数组中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">	public:</span><br><span class="line">    int numTrees(int n) &#123;</span><br><span class="line">        if(n &lt;= 1) </span><br><span class="line">            return 1;</span><br><span class="line">        int dp[n + 1];</span><br><span class="line">        dp[0] = 1;</span><br><span class="line">        dp[1] = 1;</span><br><span class="line">        for(int i = 2; i &lt;= n ; i ++) &#123;</span><br><span class="line">            dp[i] = 0;</span><br><span class="line">            for(int j = 1; j &lt;= i; j ++)</span><br><span class="line">                dp[i] += dp[i - j] * dp[j - 1];</span><br><span class="line">	        &#125;</span><br><span class="line">        return dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode97-Interleaving-String"><a href="#Leetcode97-Interleaving-String" class="headerlink" title="Leetcode97. Interleaving String"></a>Leetcode97. Interleaving String</h1><p>Given s1, s2, s3, find whether s3 is formed by the interleaving of s1 and s2.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s1 = &quot;aabcc&quot;, s2 = &quot;dbbca&quot;, s3 = &quot;aadbbcbcac&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s1 = &quot;aabcc&quot;, s2 = &quot;dbbca&quot;, s3 = &quot;aadbbbaccc&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></p>
<p>这道求交织相错的字符串，只要是遇到字符串的子序列或是匹配问题直接就上动态规划 Dynamic Programming，其他的都不要考虑，什么递归呀的都是浮云（当然带记忆数组的递归写法除外，因为这也可以算是 DP 的一种），千辛万苦的写了递归结果拿到 OJ 上妥妥 Time Limit Exceeded，能把人气昏了，所以还是直接就考虑 DP 解法省事些。一般来说字符串匹配问题都是更新一个二维 dp 数组，核心就在于找出状态转移方程。那么我们还是从题目中给的例子出发吧，手动写出二维数组 dp 如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Ø d b b c a</span><br><span class="line">Ø T F F F F F</span><br><span class="line">a T F F F F F</span><br><span class="line">a T T T T T F</span><br><span class="line">b F T T F T F</span><br><span class="line">c F F T T T T</span><br><span class="line">c F F F T F T</span><br></pre></td></tr></table></figure></p>
<p>  首先，这道题的大前提是字符串 s1 和 s2 的长度和必须等于 s3 的长度，如果不等于，肯定返回 false。那么当 s1 和 s2 是空串的时候，s3 必然是空串，则返回 true。所以直接给 dp[0][0] 赋值 true，然后若 s1 和 s2 其中的一个为空串的话，那么另一个肯定和 s3 的长度相等，则按位比较，若相同且上一个位置为 True，赋 True，其余情况都赋 False，这样的二维数组 dp 的边缘就初始化好了。下面只需要找出状态转移方程来更新整个数组即可，我们发现，在任意非边缘位置 dp[i][j] 时，它的左边或上边有可能为 True 或是 False，两边都可以更新过来，只要有一条路通着，那么这个点就可以为 True。那么我们得分别来看，如果左边的为 True，那么我们去除当前对应的 s2 中的字符串 s2[j - 1] 和 s3 中对应的位置的字符相比（计算对应位置时还要考虑已匹配的s1中的字符），为 s3[j - 1 + i], 如果相等，则赋 True，反之赋 False。 而上边为 True 的情况也类似，所以可以求出状态转移方程为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = (dp[i - 1][j] &amp;&amp; s1[i - 1] == s3[i - 1 + j]) || (dp[i][j - 1] &amp;&amp; s2[j - 1] == s3[j - 1 + i]);</span><br></pre></td></tr></table></figure></p>
<p>其中 dp[i][j] 表示的是 s2 的前 i 个字符和 s1 的前 j 个字符是否匹配 s3 的前 i+j 个字符，根据以上分析，可写出代码如下：</p>
<p>解法一：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">	public:</span><br><span class="line">    bool isInterleave(string s1, string s2, string s3) &#123;</span><br><span class="line">        int n1 = s1.size(), n2 = s2.size(), n3 = s3.size();</span><br><span class="line">        if(n1 + n2 != n3)</span><br><span class="line">            return false;</span><br><span class="line">        bool dp[n1+1][n2+1];</span><br><span class="line">        dp[0][0] = true;</span><br><span class="line">        for(int i = 1; i &lt;= n1; i ++)</span><br><span class="line">            dp[i][0] = dp[i-1][0] &amp;&amp; s1[i-1] == s3[i-1];</span><br><span class="line">        for(int i = 1; i &lt;= n2; i ++)</span><br><span class="line">            dp[0][i] = dp[0][i-1] &amp;&amp; s2[i-1] == s3[i-1];</span><br><span class="line">        for(int i = 1; i &lt;= n1; i ++)</span><br><span class="line">            for(int j = 1; j &lt;= n2; j ++)</span><br><span class="line">                dp[i][j] = (dp[i-1][j] &amp;&amp; s1[i-1] == s3[i-1+j]) ||</span><br><span class="line">                           (dp[i][j-1] &amp;&amp; s2[j-1] == s3[j-1+i]);</span><br><span class="line">        return dp[n1][n2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>我们也可以把for循环合并到一起，用if条件来处理边界情况，整体思路和上面的解法没有太大的区别，参见代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">	public:</span><br><span class="line">    bool isInterleave(string s1, string s2, string s3) &#123;</span><br><span class="line">        if (s1.size() + s2.size() != s3.size()) return false;</span><br><span class="line">        int n1 = s1.size(), n2 = s2.size();</span><br><span class="line">        vector&lt;vector&lt;bool&gt;&gt; dp(n1 + 1, vector&lt;bool&gt; (n2 + 1, false)); </span><br><span class="line">        for (int i = 0; i &lt;= n1; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt;= n2; ++j) &#123;</span><br><span class="line">                if (i == 0 &amp;&amp; j == 0) &#123;</span><br><span class="line">                    dp[i][j] = true;</span><br><span class="line">                &#125; else if (i == 0) &#123;</span><br><span class="line">                    dp[i][j] = dp[i][j - 1] &amp;&amp; s2[j - 1] == s3[i + j - 1];</span><br><span class="line">                &#125; else if (j == 0) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - 1][j] &amp;&amp; s1[i - 1] == s3[i + j - 1];</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                   dp[i][j] = (dp[i - 1][j] &amp;&amp; s1[i - 1] == s3[i + j - 1]) || (dp[i][j - 1] &amp;&amp; s2[j - 1] == s3[i + j - 1]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n1][n2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode98-Validate-Binary-Search-Tree"><a href="#Leetcode98-Validate-Binary-Search-Tree" class="headerlink" title="Leetcode98. Validate Binary Search Tree"></a>Leetcode98. Validate Binary Search Tree</h1><p>Given a binary tree, determine if it is a valid binary search tree (BST).</p>
<p>Assume a BST is defined as follows:</p>
<p>The left subtree of a node contains only nodes with keys less than the node’s key.<br>The right subtree of a node contains only nodes with keys greater than the node’s key.<br>Both the left and right subtrees must also be binary search trees.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    2</span><br><span class="line">   / \</span><br><span class="line">  1   3</span><br><span class="line">Input: [2,1,3]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">     5</span><br><span class="line">    / \</span><br><span class="line">   1   4</span><br><span class="line">      / \</span><br><span class="line">     3   6</span><br><span class="line">Input: [5,1,4,null,null,3,6]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: The root node&apos;s value is 5 but its right child&apos;s value is 4.</span><br></pre></td></tr></table></figure></p>
<p>可以利用它本身的性质来做，即左&lt;根&lt;右，也可以通过利用中序遍历结果为有序数列来做，下面我们先来看最简单的一种，就是利用其本身性质来做，初始化时带入系统最大值和最小值，在递归过程中换成它们自己的节点值，用long代替int就是为了包括int的边界条件。</p>
<h1 id="Leetcode100-Same-Tree"><a href="#Leetcode100-Same-Tree" class="headerlink" title="Leetcode100. Same Tree"></a>Leetcode100. Same Tree</h1><p>Given two binary trees, write a function to check if they are the same or not. Two binary trees are considered the same if they are structurally identical and the nodes have the same value.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input:     1         1</span><br><span class="line">          / \       / \</span><br><span class="line">         2   3     2   3</span><br><span class="line"></span><br><span class="line">        [1,2,3],   [1,2,3]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input:     1         1</span><br><span class="line">          /           \</span><br><span class="line">         2             2</span><br><span class="line"></span><br><span class="line">        [1,2],     [1,null,2]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input:     1         1</span><br><span class="line">          / \       / \</span><br><span class="line">         2   1     1   2</span><br><span class="line"></span><br><span class="line">        [1,2,1],   [1,1,2]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></p>
<p>递归判断两个树是不是一样的，简单。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isSameTree(TreeNode* p, TreeNode* q) &#123; </span><br><span class="line">        if(p == NULL &amp;&amp; q == NULL) return true;</span><br><span class="line">        if(p == NULL || q == NULL) return false;</span><br><span class="line">        if(p-&gt;val != q-&gt;val) return false;</span><br><span class="line">        else return isSameTree(p-&gt;left, q-&gt;left) &amp;&amp; isSameTree(p-&gt;right, q-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Leetcode/" rel="tag"># Leetcode</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/05/14/Leetcode801_850/" rel="next" title="Leetcode801 - 850">
                <i class="fa fa-chevron-left"></i> Leetcode801 - 850
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/05/20/Leetcode1_50/" rel="prev" title="Leetcode1 - 50">
                Leetcode1 - 50 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/header.jpg" alt="Hao Yu">
            
              <p class="site-author-name" itemprop="name">Hao Yu</p>
              <p class="site-description motion-element" itemprop="description">Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author</p>
          </div>
          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">235</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>
        	<audio controls="controls" loop="loop" preload="auto" src="/resource/xiaomeihao.mp3">
	        </audio>
	

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yuhao0102" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:yuh18@mails.tsinghua.edu.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode53-Maximum-Subarray"><span class="nav-number">1.</span> <span class="nav-text">Leetcode53. Maximum Subarray</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode55-Jump-Game"><span class="nav-number">2.</span> <span class="nav-text">Leetcode55. Jump Game</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode56-Merge-Intervals"><span class="nav-number">3.</span> <span class="nav-text">Leetcode56. Merge Intervals</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode57-Insert-Interval"><span class="nav-number">4.</span> <span class="nav-text">Leetcode57. Insert Interval</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode58-Length-of-Last-Word"><span class="nav-number">5.</span> <span class="nav-text">Leetcode58. Length of Last Word</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode59-Spiral-Matrix-II"><span class="nav-number">6.</span> <span class="nav-text">Leetcode59. Spiral Matrix II</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode62-Unique-Paths"><span class="nav-number">7.</span> <span class="nav-text">Leetcode62. Unique Paths</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode63-Unique-Paths-II"><span class="nav-number">8.</span> <span class="nav-text">Leetcode63. Unique Paths II</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode66-Plus-One"><span class="nav-number">9.</span> <span class="nav-text">Leetcode66. Plus One</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode67-Add-Binary"><span class="nav-number">10.</span> <span class="nav-text">Leetcode67. Add Binary</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode69-Sqrt-x"><span class="nav-number">11.</span> <span class="nav-text">Leetcode69. Sqrt(x)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode70-Climbing-Stairs"><span class="nav-number">12.</span> <span class="nav-text">Leetcode70. Climbing Stairs</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode71-Simplify-Path"><span class="nav-number">13.</span> <span class="nav-text">Leetcode71. Simplify Path</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode72-Edit-Distance"><span class="nav-number">14.</span> <span class="nav-text">Leetcode72. Edit Distance</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode73-Set-Matrix-Zeroes"><span class="nav-number">15.</span> <span class="nav-text">Leetcode73. Set Matrix Zeroes</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode75-Sort-Colors"><span class="nav-number">16.</span> <span class="nav-text">Leetcode75. Sort Colors</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode76-Minimum-Window-Substring"><span class="nav-number">17.</span> <span class="nav-text">Leetcode76. Minimum Window Substring</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode78-Subsets"><span class="nav-number">18.</span> <span class="nav-text">Leetcode78. Subsets</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode79-Word-Search"><span class="nav-number">19.</span> <span class="nav-text">Leetcode79. Word Search</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode80-Remove-Duplicates-from-Sorted-Array-II"><span class="nav-number">20.</span> <span class="nav-text">Leetcode80. Remove Duplicates from Sorted Array II</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode81-Search-in-Rotated-Sorted-Array-II"><span class="nav-number">21.</span> <span class="nav-text">Leetcode81. Search in Rotated Sorted Array II</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode82-Remove-Duplicates-from-Sorted-List-II"><span class="nav-number">22.</span> <span class="nav-text">Leetcode82. Remove Duplicates from Sorted List II</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode83-Remove-Duplicates-from-Sorted-List"><span class="nav-number">23.</span> <span class="nav-text">Leetcode83. Remove Duplicates from Sorted List</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode88-Merge-Sorted-Array"><span class="nav-number">24.</span> <span class="nav-text">Leetcode88. Merge Sorted Array</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode90-Subsets-II"><span class="nav-number">25.</span> <span class="nav-text">Leetcode90. Subsets II</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode94-Binary-Tree-Inorder-Traversal"><span class="nav-number">26.</span> <span class="nav-text">Leetcode94. Binary Tree Inorder Traversal</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode96-Unique-Binary-Search-Trees"><span class="nav-number">27.</span> <span class="nav-text">Leetcode96. Unique Binary Search Trees</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode97-Interleaving-String"><span class="nav-number">28.</span> <span class="nav-text">Leetcode97. Interleaving String</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode98-Validate-Binary-Search-Tree"><span class="nav-number">29.</span> <span class="nav-text">Leetcode98. Validate Binary Search Tree</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode100-Same-Tree"><span class="nav-number">30.</span> <span class="nav-text">Leetcode100. Same Tree</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>
  <div id="DvelopmentTarget">     
  </div>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart" aria-hidden="false"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>

  
</div>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_uv"> 
  本站访客数<span id="busuanzi_value_site_uv"></span>人次
</span>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  


  <script type="text/javascript" src="/js/src/love.js"></script>

</body>
</html>
