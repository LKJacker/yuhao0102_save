<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zn-ch">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-center-simple.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="积累,">










<meta name="description" content="编译调度使用编译技术提高流水线性能，减少因为数据冒险导致的阻塞和分支预测。 假定使用5站流水线，已经完全流水，如果没有相关性则会顺畅地流下去，没有任何阻塞；如果有分支指令则在分支指令及其前一个指令之间有1拍延迟，整数部件load有1拍延迟，整数部件无延迟。 如果是分支指令，取指令1拍，指令译码1拍，产生结果得到分支目标1拍，这个结果不经过任何过程再返回。如果采用锁定机制（发现是分支指令就不取下下一">
<meta name="keywords" content="积累">
<meta property="og:type" content="article">
<meta property="og:title" content="国防科技大学 - 计算机体系结构笔记2">
<meta property="og:url" content="http://yoursite.com/2020/02/26/国防科技大学计算机体系结构2/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="编译调度使用编译技术提高流水线性能，减少因为数据冒险导致的阻塞和分支预测。 假定使用5站流水线，已经完全流水，如果没有相关性则会顺畅地流下去，没有任何阻塞；如果有分支指令则在分支指令及其前一个指令之间有1拍延迟，整数部件load有1拍延迟，整数部件无延迟。 如果是分支指令，取指令1拍，指令译码1拍，产生结果得到分支目标1拍，这个结果不经过任何过程再返回。如果采用锁定机制（发现是分支指令就不取下下一">
<meta property="og:locale" content="zn-ch">
<meta property="og:image" content="http://yoursite.com/img/20200229001.jpg">
<meta property="og:image" content="http://yoursite.com/img/20190229002.jpg">
<meta property="og:updated_time" content="2020-03-03T09:53:08.266Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="国防科技大学 - 计算机体系结构笔记2">
<meta name="twitter:description" content="编译调度使用编译技术提高流水线性能，减少因为数据冒险导致的阻塞和分支预测。 假定使用5站流水线，已经完全流水，如果没有相关性则会顺畅地流下去，没有任何阻塞；如果有分支指令则在分支指令及其前一个指令之间有1拍延迟，整数部件load有1拍延迟，整数部件无延迟。 如果是分支指令，取指令1拍，指令译码1拍，产生结果得到分支目标1拍，这个结果不经过任何过程再返回。如果采用锁定机制（发现是分支指令就不取下下一">
<meta name="twitter:image" content="http://yoursite.com/img/20200229001.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/02/26/国防科技大学计算机体系结构2/">





  <title>国防科技大学 - 计算机体系结构笔记2 | Hao Yu's blog</title>
  








 
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zn-ch">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hao Yu's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">The program monkey was eaten by the siege lion.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-mybetterhalf">
          <a href="/mybetterhalf/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>
            
            mybetterhalf
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="Searching..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/26/国防科技大学计算机体系结构2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">国防科技大学 - 计算机体系结构笔记2</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-02-26T12:43:00+08:00">
                2020-02-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="编译调度"><a href="#编译调度" class="headerlink" title="编译调度"></a>编译调度</h1><p>使用编译技术提高流水线性能，减少因为数据冒险导致的阻塞和分支预测。</p>
<p>假定使用5站流水线，已经完全流水，如果没有相关性则会顺畅地流下去，没有任何阻塞；如果有分支指令则在分支指令及其前一个指令之间有1拍延迟，整数部件load有1拍延迟，整数部件无延迟。</p>
<p>如果是分支指令，取指令1拍，指令译码1拍，产生结果得到分支目标1拍，这个结果不经过任何过程再返回。如果采用锁定机制（发现是分支指令就不取下下一条指令了），这时已经到指令译码了，刚好已经取进来一条了，这就叫做分支延迟槽，再往后的指令先停下，跟进来的这条指令就允许向下流，或者更彻底，只要发现了是分支指令，跟着进来的那个也不管了，这会导致两拍的开销。</p>
<p>循环展开、指令调度、寄存器重命名。</p>
<ul>
<li>确定指令的调整是否是有效的，移动的指令不影响执行结果；</li>
<li>确定循环和循环之间不存在相关性；</li>
<li>使用不同寄存器避免在使用相同寄存器时的不必要约束；</li>
<li>在循环展开时注意处理结尾的迭代；</li>
<li>明确load和store在循环展开时是否可以交换，不同迭代的load/store相互独立，分析内存地址明确是否是同一地址</li>
<li>如果存在相关性，必须确定和原始代码的相关性一致。</li>
</ul>
<p>通过使用寄存器重命名，在两次迭代之间减少相关性，而不影响一个迭代内部的相关性，也有代价，比如多用几个寄存器，或者代码体积会增大，编译器更复杂。</p>
<p>有的情况下编译时就能预测分支是否成功，它的成功率分布很离散，从9%到59%。改成基于方向的，如果程序到了分支，如果程序往前走（可能是if），认为不成功的概率居多，如果往回走（循环），成功的概率居多，猜错率在30%-40%。</p>
<p>改一下，使用程序的上下文信息，每次预测的时候使用上一次预测的结果，可能会生成更精确的预测；再进一步地，基于统计信息，先得到一些统计信息，基于统计预测分支的走向，这种方法的指导性很不强。</p>
<p>超长指令字机器，首先要确定机器的最大并行度，全靠软件做，先把指令打包，确定封装包之间的相关性，在所有的指令中间，确定一条指令跟正在被处理的所有指令是否相关。</p>
<p>静态超标量通过编译器调度来帮助处理器达到更高的性能，动态超标量不需要编译器调度，但是需要硬件的开销。</p>
<p>超长指令字是对编译器及其依赖的一种技术，最小化潜在的数据冒险延迟，将一些指令封装进一个流出包中，也不需要检查潜在的相关性，执行中认为去拿的数据一定是对的，如果没有一定的保障，则可能会拿不对的数据，需要编译器进行控制，编译器需要控制指令包内、包之间的相关性，好处就是硬件会很简单，不需要考虑前瞻和相关性，仍然能达到很高的性能，VLIW使用多个独立的功能部件，把一组指令按某种方式组合，构成一个长指令字向外发送。</p>
<p>每一个VLIW功能部件需要16-24个二进制位来表述功能部件完成的工作和寄存器。可能包含七个部件：2个整型部件，2个浮点部件，2个内存，1个分支部件。一个长指令字里出去的指令应该都是无关的，部件之间不存在数据交换通道。</p>
<p>早期超长指令字格式非常死板，这个地方是一个整数就是一个整数，指令部件就是一条一条往运行部件送，代码二进制不兼容，必须要依靠硬件和软件的适配。所以很难见到超长指令字机器。如果打包的时候没有要求的操作往里填，则填空指令，指令槽的利用率可能会比较低。</p>
<p>VLIW问题：</p>
<ul>
<li>代码数量增加了；</li>
<li>每个指令之间是互锁的，在执行的时候如果一个指令被卡住，后边都会被卡住；</li>
<li>二进制代码不兼容，如果有部件的增删，则要重新编译代码。</li>
<li>VLIW对循环展开的次数要求很高，可能不够展开的；</li>
<li>对功能部件利用率比较低，需要插入很多的空指令。</li>
</ul>
<p>VLIW有压缩的余地：把立即数提出来生成一个立即数域；程序在执行之前可以压缩，从存储器中取出来的时候再解压缩。</p>
<p>互锁机制：所有功能部件操作是同步的，不用判断数据相关，编译器解决，硬件就不用解决了，有一条指令阻塞了，其他的都会被堵住。如果在访存的时候碰到了，访存时间可能很长，指令之间的互锁机制会使性能不可忍受。很多机器在处理时将一些部件从互锁机制解开了，编译器也会解决互锁。对指令流出之后，可以不同步执行。</p>
<p>二进制代码的兼容性跟指令集、流水线结构、功能部件的结构/数量相关，这是超标量机器占主导的主要原因。</p>
<p>代码迁移过程：实用的是对代码进行调整和转换，例如在执行的时候把串行转换成VLIW。</p>
<p>指令的多流出和向量处理器：成本是相当的，向量处理器性能高些；多指令流出对代码要求比较低，不需要向量化，且多存储器的带宽要求比较低。向量往往作为处理器的加速部件。</p>
<h1 id="开发ILP的高级编译技术"><a href="#开发ILP的高级编译技术" class="headerlink" title="开发ILP的高级编译技术"></a>开发ILP的高级编译技术</h1><p>通过一部分硬件的支持（前瞻），通过软件技术的方法（编译）提高并行性。</p>
<ul>
<li>循环级并行：检测和减少迭代之间的依赖，找到并行性。</li>
<li>软件流水线：一种循环展开的过程，解决面向不同应用的问题，不用根据体系结构进行优化。</li>
<li>路径调度：控制指令相关的调度策略，将执行过程看成一个路径。</li>
</ul>
<p>检测相关性：</p>
<ul>
<li>进行代码调度</li>
<li>检测循环是否有并行性，检测在执行中时间上的概念</li>
<li>减少名相关</li>
</ul>
<p>一旦涉及到循环，数组和指针是最头疼的，一个有效工作的循环一般都有数组和指针，也就存在别名（alias）问题，这往往因为数组或向量下标引起的。也需要去找是否存在环状的相关性。</p>
<p>相关发生在两遍循环之间的问题经常存在，一次迭代使用了上一次迭代的结果。只要不存在这种相关性，即使存在其他的相关性，也可以同时流出。</p>
<p>如果一个for循环存在两边循环之间的相关，需要破坏掉相关才能实现并行性，如果没有相关环的话就可以破坏，如果能把上一遍循环的计算拉到这一次循环中计算，这样就能不依赖于另外一次循环。对于两次相关的爹地啊，相关的语句放到一起，不相关的语句拆开放到两次迭代中。语句之间影响并行的因素就清除掉了，但是循环之间必须保存的有序性也要保存。</p>
<p>相关性的检测：可以获得的并行性收到循环次数的限制，循环展开的次数越多越好，有的循环没有那么多次可以供你展开，循环展开也需要更多的硬件资源。需要知道循环不同遍之间是不是访问的相同的地址？更复杂的分析需要知道两次访存是不是请求的相同的（多个）地址。</p>
<p>递归：存在某种相关性，关联很确定，存在比较多的并行性。</p>
<p>两边循环出现循环相关的距离即为相关元素的间隔。相关距离越大，相关的冒险越小，导致机器阻塞的概率也越小，通过循环展开获得的潜在并行性也越大。如果相关距离是5，那可以循环展开得到4个副本，循环距离变为1，如果把循环距离为1的循环展开的话，循环距离不会改变。 </p>
<p>如果展开的话可能会增加一些相关性，因为要把一些计算提前，越是循环次数远的，相关性就越长，这样就给并行以机会。</p>
<p>编译器检测相关性：水平极其有限，假设下标函数构成仿射函数，就是一个线性函数，被写成<code>a ( x * i + b)</code>的形式，a和b是常数。</p>
<p>检测循环中是否有相关性，即检测可能数据相关的两个语句所代表的两个仿射函数是否有整数解，如果有，则可能相关。</p>
<p>从理论上说，编译时不能确定认为变量相关，可能会存在一组整数解，但是可能取不到这一组解，可能与加载的运行负载有关。相关检测可能会成本很高，基本就是程序执行的一个过程，每一次迭代之间都可能存在这个问题。</p>
<p>GCD Test：如果不是存在整数解，而在两个仿射函数<code>a ( x * i + b)</code>和<code>c ( x * i + d)</code>中，GCD(c, a)能被(d-b)整除，则可能存在相关性。</p>
<p>编译器如何工作：在检测相关性时进行分类，识别名相关并通过重命名或副本技术消除掉，在分析时主要分析真相关（先写后读相关）、输出相关（写后写相关）、反相关（先读后写相关），其他的都是伪相关。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for (i = 1; i &lt;= 100; i++) &#123;</span><br><span class="line">	Y[i] = X[i] / c;  /* S1 */</span><br><span class="line">	X[i] = X[i] + c;  /* S2 */</span><br><span class="line">	Z[i] = Y[i] + c;  /* S3 */</span><br><span class="line">	Y[i] = c - Y[i];  /* S4 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Y[i]存在很多相关，写后读、写后写等，S1 S3与S4中的Y[i]存在相关，可以消除，S1中的Y[i]使用中间变量替代；X[i]存在读后写相关，S2中的左边X[i]是最终结果了，不能用临时变量替换，要生成一个临时数组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for (i = 1; i &lt;= 100; i++) &#123;</span><br><span class="line">	T[i] = X[i] / c;  /* S1 */</span><br><span class="line">	X1[i] = X[i] + c;  /* S2 */</span><br><span class="line">	Z[i] = T[i] + c;  /* S3 */</span><br><span class="line">	Y[i] = c - T[i];  /* S4 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在的结果是都用了数组，其实对Y的处理可以使用临时变量。编译器可以把替换Y的临时变量使用寄存器搞。</p>
<p>编译器可以：做指令的相关性分析，确定访存地址和循环展开的成本；对循环级并行，是不是循环有利于并行；访存是不是存在相关。</p>
<h1 id="软件流水和路径调度"><a href="#软件流水和路径调度" class="headerlink" title="软件流水和路径调度"></a>软件流水和路径调度</h1><p>对硬件需求少。<br>软件流水是一种展开技术，相关性更少一些，得到更大的并行性。是一种对循环的重组技术，从每一遍循环里面提取公用的指令，构成新的循环，这个循环过程中间，从循环体来看，看不到一遍一遍的循环展开，但是从执行上看是在一遍一遍循环执行。</p>
<p>循环的每次迭代是一个指令序列，按照每个循环指令序列平行展开，认为一次循环内的相关指令的相关距离小于两次循环之间的相关指令的相关距离。<br><img src="/img/20200229001.jpg" alt></p>
<p>竖着的四条指令更可能相关，横着的四条指令相关指令距离更大，相关距离越大则相关冒险更小，所以可以横着实现并行且指令的顺序跟竖着是一样的。对循环重组，横向取指令，总的想法是把原本竖着的循环翻转过来。构成了一个像新的循环像流水线一样的相关距离更大的循环。</p>
<p><img src="/img/20190229002.jpg" alt><br>把“load、add、store”三条指令展开，开始三句是补偿代码，称为填充期，最后三句称为排空期。循环指令越多，排空期和填充期的指令也就越多。一边循环的指令的长度决定了补偿代码的长度，第一遍循环的最后一条指令作为软件循环的第一条指令，所以第一遍循环的前边所有指令作为补偿代码，类似的，后边作为排空代码。都有一个问题是偏移量的计算都必须要单独计算。</p>
<p>两条指令之间由于一条指令延迟过长，耽误了下一条指令的计算，就可以用常规循环展开进行展开。</p>
<p>软件流水的代码空间比循环展开小一些，没有大量的展开。循环展开有效的减少控制变量造成的损耗，软件流水降低空转、阻塞。</p>
<p>循环展开减少了循环控制变量的修正，如果是多层嵌套的循环，会乘上上一层循环的循环次数，更优化。软件流水主要减少每次循环引发的阻塞，在机器以峰值计算的时候更有效，腾出更多的空间使两条指令的相关距离更大。</p>
<p>基本代码调度：基本块本身是没有分支的程序块，超越基本块研究指令集并行。全局代码调度是跨越分支指令的调度，在循环体内部存在分支指令，调动循环体内部的控制流，从非循环的指令之间也存在并行性，对内部非循环控制流的代码比控制指令调度更复杂。</p>
<p>关键路径：全局代码调度的目的是把代码压缩，压缩到最短的指令序列，不包含分支指令的序列，形成的代码就叫关键路径，这段代码的所有指令会以最大概率从头到尾顺一遍，最可能没有分支指令。</p>
<p>代码的调度：数据的生产消费关系流（写后读）不能改变，代码的例外特征不能改变。在全局指令调度的时候，尽量减少可能产生例外的指令的调度。</p>
<p>全局代码调度实际上需要权衡，是否将一个语句调度到前方，需要进一步分析变量的依赖，这种调度可能会好，可能会坏。</p>
<p>路径调度产生一段可以并行执行的代码，针对分支，首先把程序中的分支抽离，剩下的是路径，这样找到了一个主干，认为主干有并行性，真正执行效果跟程序有关。路径调度比循环展开更进一步，发现跨越分支指令的并行性。路径调度的主要原因是每一拍都要流出大量的指令。</p>
<p>第一步是路径选择，选到一条路分为两步，路径选择大概有一条指令序列可以产生最短指令代码序列完成功能，经过选择的这一段代码就是路径，如果把循环连着控制指令一起展开，如果不成功就出去，呐循环展开本身就是一个关机按路径，产生一个代码序列，如果把控制变量去掉，则变成代码块；第二步是路径压缩，进行代码调整等一系列的修正，得到一串代码，就是可以执行的代码，之后压缩完的代码可以组合成超长指令字的指令包，它是一个全局的代码调度过程，在产生关键路径的中间，保证相关性不被破坏。</p>
<p>路径调度比简单的流水线调度获得更高的并发性，在控制相关上有特点；通过代码的调度跨越非循环的分支指令来预测程序的分支特征。如果对分支指令的信息足够精确，就能够得到非常快的代码。</p>
<p>路径选择第一步需要选择可能正确的路径，认为为真的概率比较高。代码不管经过什么调整，保证结果正确。</p>
<p>路径压缩需要挑出一个指令序列，填满机器所需要的指令。做分支指令调度的时候，有分支指令做好代码补偿，在路径的出入口做好。其中一个关键假设是关键路径执行概率最高，否则做代码补偿就得不偿失。</p>
<p>代码的移动可能导致控制相关的局部特征发生变化，导致某些指令的控制相关性发生变化。</p>
<p>软件ILP策略：</p>
<ul>
<li>循环展开</li>
<li>软件流水</li>
<li>路径调度</li>
</ul>
<p>编译器完成指令级并行的实现所需要的硬件支持，把精力集中到分支指令上。软件需要更多了解分支指令的特征，分支指令的特征并不好预测，它的执行是动态的，硬件可以提供一定的支持，例如前瞻性的执行，特别是对指令出故障的时候，对故障断定很精确，也提供一种机制，需要软件来执行这种机制，入条件指令，把if语句转成单条的指令，可以消除相关，把控制相关转成数据相关，在分支指令出现的代码段中也不出现调度问题了，只是数据操作问题，也没有相关问题。最后一种支持是前瞻的，一种是静态的在编译时就处理，设置抑制标志，不让前瞻性的过程扩散，如果扩散了则挂起，或者硬件提供寄存器，软件使用寄存器；动态调度是前边讲的算法。</p>
<p>条件指令是使用编译克服分支相关的一种方法，任何一条指令都带一个条件，如果条件是真的话就执行，是假的话就是一个空操作。这个过程内含了一个控制分支，完成后边数据的操作与前边相关，不再存在控制相关，而是转变成数据相关。第二个是把程序条件处理变成后端。</p>
<p>条件分支指令不允许产生意外，仍然占用运行时间，控制变量必须要预先产生，只有一个条件，只能做很简单的操作，最后是导致机器总体性能受影响。大部分机器支持条件传送指令。</p>
<p>指令作废：程序在执行时，条件应该尽早产生，以避免数据冒险等问题，否则应该作废。</p>
<p>条件指令的限制：</p>
<ul>
<li>作废的指令依然占用资源</li>
<li>指令的控制变量应该尽早产生</li>
<li>只能对简单的指令采用条件指令</li>
<li>产生性能阻碍</li>
</ul>
<p>前瞻操作的三种功能：</p>
<ul>
<li>数据流正确性</li>
<li>例外正确处理</li>
<li>访存的冲突应该被正确识别</li>
</ul>
<p>执行前瞻的四种方法：</p>
<ul>
<li>硬件和OS对指令前瞻执行，对某些应用很难实现，需要OS作标志</li>
<li>前瞻指令不允许产生意外，需要编译器在编译时确认哪条指令是前瞻指令</li>
<li>一定范围的指令，如果是前瞻的话，打上指令，抑制影响范围</li>
<li>后援机制，在执行的时候，把结果放到后援存储中，数据也不最终写回，直到前瞻被确认。</li>
</ul>
<p>指令进行全局调度的时候，例外和相关性不能改变，如果前瞻出现错误且对机器状态产生影响了，那这个前瞻就不能被采纳。</p>
<p>例外大概两种，一种是终止性的，程序不能被继续执行，如访存的保护错误；一种是可恢复的，当例外发生后，机器的机制对其处理，处理完之后可以正常执行，比如缺页。</p>
<p>软硬件联合前瞻，由操作系统和硬件可以处理可恢复的故障。如果前瞻的指令导致了一次终止性的故障，那就返回一个没有定义的值，当OS因为前瞻的故障发现返回一个无意义的值，则认为这是一个不可恢复的故障，进行一系列处理。如果引起终止的指令不是前瞻的，且引起了终止性的意外，那就终止。</p>
<p>既然是前瞻的过程，那最后的时候被前瞻的指令可能会系统忽视掉，它引发的终止性意外也可能被忽视掉。正常情况下一个程序返回一个无定义的值，则会崩掉；但是前瞻执行的时候会加上一个标志，增加确认过程，不会遇到例外就终止。或者加上一个前缀，当加上前缀之后，说明这条指令是前瞻的。或者所有寄存器加上抑制标志，每一条指令都有一条附加标志，告诉系统是不是前瞻的，如果是前瞻的，当碰到例外的时候，这个例外并不是马上就处理，先放一会，一直放到前瞻指令被确认的时候再处理。</p>
<p>这个例外在执行的时候可能会影响到一大批寄存器，也可能带来例外，但是这里的例外只能在指令被确认的时候再处理，所以记录下已经影响到的寄存器，如果一个前瞻指令使用了抑制位被置为抑制的寄存器，即某个操作数被抑制，那这个指令的另一个操作数也会被抑制，这是抑制的传递关系。如果正常指令访问被抑制的寄存器，机器就出故障了。</p>
<p>抑制位带来问题：操作系统需要单独指令控制抑制位。</p>
<p>后援问题：在分支指令之间调整指令，把这条指令定义为前瞻，提供一个reorder buffer，指令执行结束之后进行确认，把结果送到寄存器中。</p>
<p>设置专用check指令，用它顶替要进行前瞻执行的load，这个load就可以到处挪，这个check和load是一对，check检查保存在手里的load的地址和之前的地址，看前边是不是有写后读地址。</p>
<h1 id="多处理器和线程级并行"><a href="#多处理器和线程级并行" class="headerlink" title="多处理器和线程级并行"></a>多处理器和线程级并行</h1><p>并行体系结构的分类：</p>
<ul>
<li>single instruction stream, single data stream(SISD)</li>
<li>single instruction stream, multiple data stream(SIMD)</li>
<li>multiple instruction stream, single data stream(MISD)</li>
<li>multiple instruction stream, multiple data stream(MIMD)</li>
</ul>
<p>多指令流多数据流处理机采用的通用的芯片，提供了一种灵活性，通过软件和硬件的支持，对操作者来讲等价于一个单用户的多处理机，通过多个芯片提供很高的加速比，由于有多个处理器，对n个处理器来说至少有n个线程才能发挥处理能力。</p>
<p>依据互联策略，现有的MIMD有两类，一个是集中共享存储器体系结构，对于处理器和存储器，采用共享特征，多个处理器采用共享的存储器，总线把处理器和存储器联系在一起。由于多个处理器共享存储器，在时间和优先权上是一样的，因此总线采用仲裁机制判断哪个处理器使用了存储器，表现出一种对称。通过对称的策略，把这种机器叫做对称多处理机（SMP），实现了均匀访问，又可以叫做UMA。</p>
<p>把多个存储器分布到节点上，多个节点互联形成机器，带来的系统规模和可扩展性比较好，每个处理器访问存储器的时候大部分时候访问节点上局部的存储器，只有有必要的时候才访问远程存储器，远程访问经过互联网络，有较大时延，每个节点都有处理器、存储器、IO、互连网络接口，形成一个大的存储空间。两个好处：扩大带宽规模，局部存储器的访问是整个系统的大部分，远程访问量小得多，充分利用节点上的带宽，延迟小。缺陷是处理器之间的通信通过互联网络完成，变得比较复杂且有比较大的延迟。</p>
<p>多个处理器之间通信的话，一个是共享地址空间进行通信，多个处理器访问同一个地址单元，假如物理存储器是分布的，则叫做distributed shared memory（DSM），也叫做NUMA，对存储器访问不一样。</p>
<p>对共享地址空间来说，地址空间是共享的，一个空间只有一个地址单元，访问所采用的指令就是直接操作。对于多个地址空间来说，一个逻辑地址可能指的是多个地址空间，实际上是信息传递的多处理器，通过显式的数据传输完成。</p>
<p>对信息传递来说，通过同步方式实现，首先要传送一个请求，才得到一个应答。从另外一种角度，先把数据写过去再发送通知，当处理器之间的通信比较清楚的时候这种方式更简洁，这是异步的方式，提高运行效率。</p>
<p>通讯结构的性能问题：三个影响性能的主要因素：</p>
<ul>
<li>通信带宽，有处理器、内存和互联机构影响</li>
<li>通信延迟，包括发送开销（数据送上通信的端口）、飞行时间（第一个二进制位从发送端口到接收端口的时间）、传送时间（所有数据除以速率）、接收开销。</li>
<li>通信延迟隐藏，假如是一个串行程序改成并行，在通信延迟期间做其他的事情，把通信延迟隐藏掉，这个隐藏过程是一个重叠过程，把通信延迟的影响降到最低。</li>
</ul>
<p>算法决定了各个处理器之间的通信量，通常计算和通信之比随着处理器数量增加逐渐降低，处理器数量增加了，通信代价大了。处理的数据增大的时候，计算量增大，通信量也增大，二者之比增大。</p>
<p>小规模时，集中共享存储器是最简单的；围绕处理共享数据解决同步问题。</p>
<p>通过多级cache解决提高整体性能，私有数据一定要进cache，共享数据涉及多个处理器共享，在多个cache都有拷贝，需要解决cache相关性问题，着重从多个备份之间的关系。</p>
<p>如果系统是相关的，必须可以读出最近写入的正确数据，两个方面，相关性（能够读出来哪个值，指的是内容的问题，正确的还是错误的？）和一致性（什么时候能把写进去的值读出来，时间上的问题）。</p>
<p>满足以下条件一个存储系统才是相关的：</p>
<ul>
<li>一个处理器P对x进行写之后进行读，其他处理器不对x进行写操作，这时返回的数据是P写进去的。</li>
<li>一个处理器对x进行读是在另一个处理器对x进行写之后，两次操作相隔时间很长且没有其他处理器对x进行写操作，读出来的值是另一个处理器写进去的值。</li>
<li>对同一个单元的写必须是串行化的，同一单元被两个不同的处理器执行的两个<br>写被所有处理器看上去都是相同的顺序。</li>
</ul>
<p>相关性（coherence）定义了对同一单元的读和写问题，指内容上的问题，一致性（consistency）定义了读和写相对于其他存储单元的访问的行为问题，指时间上的问题。</p>
<p>读可以是乱序，但是写必须是按照程序规定顺序的。</p>
<p>相关性cache提供了迁移功能，是指数据项能够从远程移动到局部的cache中使用，为了减低延迟和带宽需求。复制指的是把当前的数据拷贝同时在多个cache中存在，也能从降低延迟方面获得好处。</p>
<p>cache相关性协议的关键问题是跟踪任何共享数据的状态，根据状态采取策略，有两类协议。首先是基于目录的方法，专门有一个物理存储器用于保留共享数据状态，查阅目录存储器就能找到共享数据的状态，适合分布式共享存储器结构。snooping（监听）使cache块中既存在数据，又包含了状态，状态是分布式存放的。</p>
<p>通过两种方式完成跟踪，维护相关性，为了保证处理器在对数据进行写之前，进入“专有”状态，把除了我要写的拷贝之外的所有其他拷贝都作废，称为“写作废”，当前要写的处理器对当前要写的数据进行专有访问。由于这是最简单的方法，广泛使用。可以用于监听或目录策略。专有状态保证没有其他的处理器可以读写，所有其他的cache拷贝都作废。通过仲裁把多个要写的请求进行仲裁，把其他的拷贝进行作废，其他的处理器重新读入一个拷贝，基于新写入的数据再写。强制所有的写操作串行化。</p>
<p>写广播（写更新）方式：当新的数据项写入一个拷贝的时候，要更新所有其他的拷贝，这里需要把所有的拷贝都更新。</p>
<p>对于同一个字的多次写，写广播代价大，每次写都要广播，对写作废来说只需要一次广播，这时已经进入独占状态，再次写的话不需要广播了。对于cache块中间的每一个字的写，在写更新协议中多次广播，在写作废中只有第一次需要写。不管是对一个字的多次写还是对多个字的写，写作废都只需要一次广播。</p>
<p>读和写一个数值之间，一个处理器写进入，另一个处理器要看到的话，写广播的延迟比较短，写作废需要重新调入数据块，更慢。</p>
<p>写广播占用带宽多，写作废的带宽需求比较小。</p>
<p>为了完成写作废，首先完成总线的访问，并且把共享数据地址送上总线，让其他的拷贝作废掉，其他处理机监听总线，检测到这个地址在其他处理机的cache内存在，则作废掉。对总线的访问串行化导致了对写的串行化。对共享数据的写要等到获得总线访问权之后。</p>
<p>对于写直达cache，写进数据之后存储器也要生效，如果其他的处理机获得最新值比较容易，从存储器里边取到最新值送到需要的处理器上。</p>
<p>写回cache，大部分最新的数据保存在cache中，存储器和cache不一样。监听总线上的地址，处理器发现总线上的地址和内部的一个cache一致，就把已经修改的数据提供给需要的存储器，因为现在数据已经被修改了，这里的是最新的。</p>
<p>通常的cache块都有自己的tag，标志当前的共享数据状态。有个无效位，说明是不是有效的。增加一个额外的共享状态位表示这个块是否是共享的，增加一个脏位看是否被修改过。</p>
<p>当只有一个拷贝时，这个处理器就是这个cache块的拥有者。cache地址和总线地址需要对比，地址的对比是串行的，cache只能满足一个的请求，所以监听控制器的操作会影响访问速度，如何提高对比速度，分成两份，一份由CPU对比，一份由总线对比；或者多级cache，CPU访问一级cache，总线访问其他cache，CPU和总线互不干扰，提高效率。</p>
<p>如果CPU操作了一级cache，总线可以操作其他cache。基于总线的相关性协议通过有限状态控制器实现的，控制器分布在每一个节点上，相应来自处理器和总线的不同请求，对两边的不同操作进行处理，并比较地址。对写命中和写失效都要出现总线事务，合并起来共同看作写失效的状态，减少要处理的事务。</p>
<p>最重要的是事务的处理是原子性的，操作必须是一气呵成不能中断的，全部过程不能有其他的插入。非原子性的事务可能会引入死锁风险。只要保证原子性的逻辑性，中间可以插入其他操作，只要不改变数据值，特别是写操作。为了充分利用并行性，且保证原子性，执行一些状态转移操作。</p>
<p>把状态变迁用状态转移图表示出来。</p>
<p>处理机之间的通信引起的失效叫相关性失效，可以分成两个部分，真共享失效、假共享失效，区别在于对同一块中间同一个字/不同一个字的共享，因为cache的共享是基于块的。</p>
<p>失效可分为三种：</p>
<ul>
<li>强制性失效：第一次读入这个块的时候一定会失效</li>
<li>相关性失效：对相关数据处理引起的失效</li>
<li>容量失效：cache容量不足导致替换引起的失效</li>
</ul>
<p>cache增大失效率降低，块大的话失效率也降低。</p>
<p>在监听协议里，每一个cache的状态分布到每一个cache块中，这种情况对分布可变规模的存储器有影响，因为分布可变的存储器使用互连网络，再使用监听协议就不适合了。一种可能的替代方法是目录存储器，把所有存储器共享的状态存下来。</p>
<p>现有的目录协议将每个块设置一个目录项，目录项的数量是存储块和存储器数量的乘积。为了防止目录成为整个系统的瓶颈，把目录存储器分布到系统中间，每个节点增加一个目录存储器。</p>
<p>目录协议两种必须实现的操作：处理读失效，处理对于共享的干净的cache的写，处理对共享块的写失效是上述二者的结合。目录要跟踪cache块的状态。首先在共享状态下，一个或多个处理器都有拷贝，未缓冲状态没有处理器有这个cache块的拷贝，专有状态是只有一个处理器有这个cache块的拷贝，如果这时候写的话，存储器的拷贝就是旧的，写完之后处理器是这个块的拥有者。</p>
<p>考虑到要写，分布共享存储器结构中，更需要写作废的支持，因为通过互联网络进行广播的话代价更大。共享状态最简单的支持是位向量，当块被共享的时候，每一位都标志出这个处理机是否有这个块的拷贝。</p>
<p>使用互连网络无法使用仲裁功能，仲裁是总线特有的；互连网络是面向信息传递的，总线是面向事务的，因此互连网络必须采用发送确认的方法。</p>
<p>局部节点是请求产生的节点。home节点是请求的存储单元和目录项所在的节点。远程节点是有cache块拷贝的节点。物理地址空间是竞态分布的，存储器地址清楚的话，节点号也清楚了。例如，地址高位代表节点号，低位代表位移。</p>
<p>目录协议的实现：目录存储器中，cache状态是反应数据状态的真实状态的，为了解决相关性，存储器中每个数据项变化时都引起目录项的变化，所以分布共享存储器中目录的操作占了总操作数的一半。送到目录中的信息导致2个操作，首先是更新目录的状态，由共享进入专有等；然后发送相应的信息，以满足请求。存储块可能是未缓冲的，可能是有多个缓冲的，或者专有的。三个状态下，目录所执行的操作不同。</p>
<p>未缓冲时，即在数据块还在存储器中时，读失效的时候，请求的处理器要求存储器将数据送到处理器cache中，置为唯一共享节点，块置为共享状态。当写失效时，首先要送给请求方处理器这个数据块的值，把它在共享集合上置1，变成共享状态。</p>
<p>处于共享状态时：读失效时，请求处理器从存储器中收到数据，请求的处理器被添加到共享集合中，写失效时，请求的处理器要进行写，首先拿到数据，所有在共享集合中的处理器收到失效信息，只留下请求的这个处理器，共享集合仅包含请求的处理器。</p>
<p>在专有状态下，所有处理器中只有一个拷贝。读失效意味着这个数据块将进入共享状态，发送取数据信息到拥有这个块的处理器，导致了块的状态变成共享状态，拥有者把数据发送到存储器，在从存储器把数据发送到请求的处理器，把标识进行更新。数据写回执行把cache中的脏数据写回到存储器中，拥有者把块送回地址所在的节点，这个块成了未缓冲的。写失效意味着专有的写状态要转移到另一个处理器，这个块将有一个新的拥有者，首先要发送信息到老的拥有者，使得cache作废，然后把原来的数值送回到目录，在把数据送回到请求方，请求方拿到了数据，成为新的拥有者。</p>
<p>当块处在专有状态时，读写失效时，先把数据送回到目录，从目录再存储再送到请求的节点。为了提高效率，把数据直接送到请求节点，再送到存储器节点，这个操作可以把间接的变成直接的，但是在实现中增加了复杂性，同时使得死锁可能性增加了，在送给使用方的同时送给存储器。</p>
<p>基于目录的方法用空间换时间，减少了访问量但是增加了目录存储器，大小与系统规模N的平方成正比，为了改进，提出了有限映射和链式结构两种。</p>
<ul>
<li>有限映射假定在不同cache中的拷贝数量小于一个常数，可以通过比较少的位向量标识块，但是有m个的限制。</li>
<li>链表结构不存在有限映射中m的限制。</li>
</ul>
<p>数据分布引起整个系统中的带宽使用效率的不同。</p>
<h1 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h1><p>多个处理器在时间上协调一致。典型的同步机构时系统在硬件原语的支持下通过软件实现的例程。高竞争状态中同步起到一致协调的作用，也成为系统的瓶颈。</p>
<p>硬件原语是面对用户的一些汇编指令，与基本指令不同的是涉及硬件操作多。实现同步的最主要能力是使用一组硬件原语，自动读取修改共享数据。硬件原语是构成面向用户的同步操作的主要组成。对存储单元的读写需要多条语句，如果在这多条语句中插入其他的指令，可能会造成同步失败，使用原语可以降低出错减少时间。</p>
<p>典型的硬件原语操作是“自动交换”，把寄存器的数据和存储单元的数据交换，通过交换，把存储单元中的数值拿到。假设建立一个锁，0代表这个锁可用，1代表不可用，要实现最后读出来是0，表明得到了锁。</p>
<p>存储单元的读写通过仲裁，只能有一个首先完成，多个处理器竞争单元时不会产生冲突。</p>
<p>使用交换指令使用原语的根源在这个原语的操作是一气呵成的，没有其他间隔打断。读和写这两点在实现同步上是不可缺的，如果没有这两点构成一个同步原语，不能实现的。</p>
<p>test-and-set：首先读出来一个数据，测试是不是满足，如果满足则置入一个新数据。</p>
<p>fetch-and-increment：取出来单元数据，自动加一，然后再写进去。</p>
<p>使用一致性实现一个旋转锁，一个处理器不停的测试看是否能获得锁，直至成功，修改锁为占有状态。旋转的过程通常在用户希望这个锁持有的时间很短，低延迟使用时间短的时候适合旋转锁。</p>
<p>很多处理器竞争一个锁的延迟和复杂度不是线性增长的，几乎是二次方，也造成比较大的流量。串行化是锁开销大的最主要原因。竞争大的时候降低串行化，形成有序的通信。软件实现的方法：所有进程争抢这个锁但是只有一个进程能抢到，第一次获得锁失败的话第二次就要延迟一会再去试探。</p>
<p>或者排队锁方法，通过软件构造等待处理器队列，通过队列进行排序，通过顺序有序使用资源。</p>
<p>组合树方法：在软件上实现对大规模机器同步的方法，把大量的竞争化解为对多个小点的竞争，使用n元树结构，一般来说使用k表示树的扇入（fan-in）。在k元树的最底层开始同步，逐级向上，直至根节点。如16个节点的话，就是一个二层的树，之前的代价是16的平方，现在是两倍的4的平方。</p>
<p>总线上10个处理器，同时完成对锁的竞争，假设每个总线事务100个时钟周期，忽略读写占用时间，只计算在竞争锁的时候的代价，对10个处理器获得锁的时候要占用多少总线事务。当i个处理器在竞争时，有i个链取获得锁、i个条件写来尝试获得锁，1个写，一共2i+1个总线事务，要全部通过要进行累加，对n个处理器来说，一共n(n+1)个总线事务。在同步点上进行同步造成相当长的延迟，同时影响了总线的访问。</p>
<p>栅栏同步（barrier）：强制所有进程等待，直到所有进程到达栅栏，再一起释放。这个过程通过两个旋转锁实现，一个是保护计数器，计算到达栅栏的进程数；一个是用于把所有进程卡在这，一旦所有进程都到了就释放。可能会出现进程组中的一个进程永远离不开barrier。</p>
<p>通过sense-reversing区分不同进程到达的barrier是否是同一次进入barrier，如果不是同一次的话可能会造成死锁。</p>
<p>硬件对大规模同步的支持：有些机器通过硬件实现了栅栏同步，类似组合树的方法。保存关于同步的处理器并对其排队，叫做排队锁，硬件上使用位阵列，把先后到达的每一个处理器进行排队，通常是与目录结构结合在一起。</p>
<p>排队锁：当对锁变量第一次失效的时候，这次失效被送同步控制器，如果锁被释放，直接从队列里返回下一个处理器，如果锁不可用则创建一个排队记录。当锁释放的时候，选择下一个处理器进入使用状态，把下一个处理器拿到队列前端。</p>
<p>区别是首次访问锁还是一直在锁里边，这样可以实现排队操作或者释放锁的操作；</p>
<p>另外一个原语是fetch-and-incement，自动取出一个变量并增加数值。这个指令会使barrier指令有改进的空间，因为它将取并增量两个操作结合在一起。现有的MPP机器都采用的是硬件barrier方法。</p>
<p>一致性问题：什么时候能看到被其他处理器更新过的数字，什么时间生效，通常使用共享变量通信。通过读出被写进去的数据来检测是否已经更新过。</p>
<p>两个代码段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">P1:</span><br><span class="line">A = 0;</span><br><span class="line">...</span><br><span class="line">A = 1;</span><br><span class="line"></span><br><span class="line">L1:</span><br><span class="line">if (B==0) ...</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">P2:</span><br><span class="line">B = 0;</span><br><span class="line">...</span><br><span class="line">B = 1;</span><br><span class="line"></span><br><span class="line">L2:</span><br><span class="line">if (A==0) ...</span><br></pre></td></tr></table></figure>
<p>如果这个程序能同步正确执行的话，A和B都在cache里，如果写总是能马上生效，那两个if都绝不可能同时为真，因为如果到达两个if，A和B都被赋值为1了。假设写作废被延迟，处理机允许继续向前推进，可能出现P1和P2两个都没看到作废，这种情况就与预计的正确程序行为相违背。</p>
<p>最简单的一致性模型是顺序一致性，需要任何访存顺序一致的程序运行结果一致，它消除了含糊的执行方式，处理器延迟对任何存储器访问的过程，直到所有的写生效；同样的可以将下次访存延迟直到本次访存结束。</p>
<p>一致性涉及到不同变量和不同时间的问题，因此对两个变量的访问必须按照一定的顺序。</p>
<p>在上边的代码中，必须在写操作完成后在进行读A或B，在顺序一致性中也不能简单地把写放到缓存中而已就继续往下执行。</p>
<p>一个处理机对变量的写和另一个处理机对变量的访问通过一对同步操作进行排序，意味着同步操作把数据引用进行了排序，同步把顺序定下来，这就确定了一致性，两个处理器的操作通过同步确定了顺序。如果没有同步操作，变量在读写期间出现顺序不定的情况，称为数据竞争，因为此时对数据的访问基于处理器之间的相对速度，输出是不可预计的，结果正确性不能保证。</p>
<p>同步原语在实现上提供了较为宽松的顺序一致性，即便系统提供了较为宽松的一致性模型，一个同步的程序也会按照标准顺序一致性那样执行，这实际上提供了一种时间上的重叠，为并行的开发提供了条件。</p>
<p>松弛一致性模型的主要思想是允许读写无序进行，而是使用同步操作来强制实现有序，这样的话处理器的操作就像顺序一致性一样。依据松弛的情况分为3种主要的类型。</p>
<p>写后读：写完全生效之后才能进行读，这叫做全存序模型，或者处理器一致性，因为只保留了写的一致性，许多程序在这个模型下保持顺序一致性。旁路和写缓冲是两种主要方法。写缓冲中如果有要读的地址，就先在缓冲中拿到。</p>
<p>写后写：多次写的一个模型，部分存序，在流水线中，第一个写还没有完成的时候第二个写已经启动，两个写之间存在并行，因为两个写之间存在节拍的差距。</p>
<p>读后读/写：弱排序模型。</p>
<p>顺序松弛可以使处理器获得明显的性能提升，在实现上需要硬件的支撑。</p>
<h1 id="线程级并行"><a href="#线程级并行" class="headerlink" title="线程级并行"></a>线程级并行</h1><p>多线程使多个线程共享处理机，处理机必须对每个线程的状态进行复制，便于进程切换，没有硬件支撑条件也谈不上多线程并行。比如，对线程所需要的文件来说，有寄存器文件，分开的PC等，提供对不同线程的切换能力，不同节拍可以切换到不同线程，线程切换也要比进程切换更快。</p>
<p>通常有两种方式实现多线程，一个是细粒度的，在指令之间就能完成线程的切换，使多线程的执行是交错的，切换经常采用时间片轮转的方式，优点是隐藏吞吐率上的损失，充分利用CPU的时间，如果线程执行IO时就可以先被切换先来，但是它的总执行时间被延长了。粗粒度的线程级并行在比较长的停顿出现时才进行切换，比如局部cache的失效，它依赖于程序执行的特点，缺点是受限于吞吐率，在有比较大的输入输出时才切换，没有办法充分利用短停顿。粗粒度多线程经常要填充流水线，产生一个起步时间，存在局限性，只有在停顿时间比较长的时候才有效。</p>
<p>SMT（simultaneous multithreading）是多线程的一种，使用处理器的多流出和动态调度能力，在指令级并行的同时实现线程级并行。SMT的基础是处理器有多个功能部件可以并行执行。寄存器换名和动态调度是为了支持不同线程的指令级并行。同时多线程是在多流出支持下，每拍流出的指令可以是来自多个线程的，第一拍是来自两个不同的线程，第二拍是来自另外的线程，以此类推，在线程和指令两个层面实现并行。</p>
<p>有多少个活跃的线程？有多少缓冲区？取指能力是否能满足流水线的需要？等都是SMT的问题，不能完全百分百的利用每一个流水槽。每个线程都要有自己的寄存器组、缓冲等。各个线程的指令要能够独立提交，结果要回到各个线程本身，这要求在逻辑上要提供每个线程的独立重排序缓冲区。</p>
<p>优先线程基于同时多线程，把执行的时间最小化，在多个线程并行的时候，只要有可能，首先流出的就是优先线程的指令，优先线程调度不出的空槽填充其他线程的指令。为最大化单个线程的性能，优先线程的取指、分支预测等应尽可能往前。如果有两个优先线程的话，两个线程就都要优先，两条指令流都要优先服务。</p>
<p>多线程每个都有寄存器，寄存器文件需要很大，保存多现场；保持系统低开销，优先线程需要优先取指；由SMT引起的cache冲突上需要良好处理，引起系统性能下降反而得不偿失。</p>
<h1 id="交叉问题"><a href="#交叉问题" class="headerlink" title="交叉问题"></a>交叉问题</h1><p>许多多处理器使用多级cache较少对全局通信的需求，如果cache提供了多级包含特性，即近一级的cache一定是远一级cache的子集，一级cache中的内容一定是二级cache中的子集。</p>
<p>如果L2是L1容量的4倍，在L2中1个起始地址的块，在L1中是4个块。如果L1中的块大小是b，L2中的块大小是4b，则如果在L2中作废一个块x，需要作废以x，x+b，x+2b，x+3b为起始地址的小块（这在L2中被看作是一个块，在L1中被看作是4个块），在L1中同样要作废起始地址为x的一个块，但是没有作废起始地址为x+b的块（如果有的话），这就违背了包含原则。任何时候都要遵守包含特性。</p>
<p>非封锁cache和延迟隐藏：多处理机的失效处罚比较大，延迟也较大，这意味着有更大的延迟可以被隐藏，还有因为流水线失效的延迟可以被隐藏；cache使用非封锁cache支撑了弱一致性模型实现，弱一致性模型可以实现对访存的重排序，重复利用；非封锁cache对实现预取很有必要，利用尽可能空的时候实现存储的迁移，充分利用时间，实现多端口的并行访问。</p>
<p>非绑定是指一个cache的数值要根据其最新数值的变化而变化，不跟随某一个局部拷贝，对全局来说都是一致的。如果是预取到寄存器中，就是绑定的，因为如果数据进入了寄存器就是脱离了地址空间，跟存储地址空间的数据就没有关系了，存储器里的变化跟寄存器里没有关联了。非绑定是在硬件预取设计中不可获取的，只能在地址空间中实现预取。</p>
<p>有几个问题：局部节点需要对多个未完成的访问进行跟踪，跟踪预取地址；流出请求之前，节点必须保证在流出请求之前，对同一个块没有流出其他请求。</p>
<p>定义一个内存一致性模型的另一个原因是针对共享数据，确定合法的编译优化范围。最简单的来说是实现同步（硬件支撑下的对存储器访问的同步）。</p>
<p>通过虚拟存储器实现共享内存，不必从物理内存上考虑容量。共享数据如何从共享cache块移向更大的单元。通过OS进行调度页面。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/积累/" rel="tag"># 积累</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/02/20/国防科技大学计算机体系结构1/" rel="next" title="国防科技大学 - 计算机体系结构笔记1">
                <i class="fa fa-chevron-left"></i> 国防科技大学 - 计算机体系结构笔记1
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/03/03/剑指offer题解/" rel="prev" title="剑指offer Python题解">
                剑指offer Python题解 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/header.jpg" alt="Hao Yu">
            
              <p class="site-author-name" itemprop="name">Hao Yu</p>
              <p class="site-description motion-element" itemprop="description">Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author</p>
          </div>
          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">286</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>
        	<audio controls="controls" loop="loop" preload="auto" src="/resource/xiaomeihao.mp3">
	        </audio>
	

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yuhao0102" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:yuh18@mails.tsinghua.edu.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#编译调度"><span class="nav-number">1.</span> <span class="nav-text">编译调度</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#开发ILP的高级编译技术"><span class="nav-number">2.</span> <span class="nav-text">开发ILP的高级编译技术</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#软件流水和路径调度"><span class="nav-number">3.</span> <span class="nav-text">软件流水和路径调度</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#多处理器和线程级并行"><span class="nav-number">4.</span> <span class="nav-text">多处理器和线程级并行</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#同步"><span class="nav-number">5.</span> <span class="nav-text">同步</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#线程级并行"><span class="nav-number">6.</span> <span class="nav-text">线程级并行</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#交叉问题"><span class="nav-number">7.</span> <span class="nav-text">交叉问题</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>
  <div id="DvelopmentTarget">     
  </div>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart" aria-hidden="false"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>

  
</div>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_uv"> 
  本站访客数<span id="busuanzi_value_site_uv"></span>人次
</span>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  


  <script type="text/javascript" src="/js/src/love.js"></script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
