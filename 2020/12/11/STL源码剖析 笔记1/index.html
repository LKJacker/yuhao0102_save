<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zn-ch">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-center-simple.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="C++,">










<meta name="description" content="第一章：STL概论和版本简介STL六大组件 容器：各种数据结构，如：vector、list、deque、set、map、主要用来存放数据。 算法：各种常见算法，如：sort、search、copy、erase 迭代器：扮演算法和容器中的中介。迭代器是一种将operator*、operator-&amp;gt;、operator++、operator--等指针相关操作予以重载的class template。">
<meta name="keywords" content="C++">
<meta property="og:type" content="article">
<meta property="og:title" content="STL 源码剖析 笔记1">
<meta property="og:url" content="http://yoursite.com/2020/12/11/STL源码剖析 笔记1/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="第一章：STL概论和版本简介STL六大组件 容器：各种数据结构，如：vector、list、deque、set、map、主要用来存放数据。 算法：各种常见算法，如：sort、search、copy、erase 迭代器：扮演算法和容器中的中介。迭代器是一种将operator*、operator-&amp;gt;、operator++、operator--等指针相关操作予以重载的class template。">
<meta property="og:locale" content="zn-ch">
<meta property="og:image" content="http://yoursite.com/img/1607703761.jpg">
<meta property="og:image" content="http://yoursite.com/img/1608811144.jpg">
<meta property="og:image" content="http://yoursite.com/img/1608949666.jpg">
<meta property="og:image" content="http://yoursite.com/img/1608949943.jpg">
<meta property="og:image" content="http://yoursite.com/img/1608952882.jpg">
<meta property="og:image" content="http://yoursite.com/img/1608952929.jpg">
<meta property="og:image" content="http://yoursite.com/img/1608954958.jpg">
<meta property="og:image" content="http://yoursite.com/2020/12/11/STL源码剖析%20笔记1/1608955300.jpg">
<meta property="og:image" content="http://yoursite.com/img/1608957050.jpg">
<meta property="og:image" content="http://yoursite.com/img/1608959629.jpg">
<meta property="og:image" content="http://yoursite.com/img/20180524164335567.png">
<meta property="og:updated_time" content="2021-01-04T14:09:56.726Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="STL 源码剖析 笔记1">
<meta name="twitter:description" content="第一章：STL概论和版本简介STL六大组件 容器：各种数据结构，如：vector、list、deque、set、map、主要用来存放数据。 算法：各种常见算法，如：sort、search、copy、erase 迭代器：扮演算法和容器中的中介。迭代器是一种将operator*、operator-&amp;gt;、operator++、operator--等指针相关操作予以重载的class template。">
<meta name="twitter:image" content="http://yoursite.com/img/1607703761.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/12/11/STL源码剖析 笔记1/">





  <title>STL 源码剖析 笔记1 | Hao Yu's blog</title>
  








 
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zn-ch">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hao Yu's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">The program monkey was eaten by the siege lion.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-mybetterhalf">
          <a href="/mybetterhalf/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>
            
            mybetterhalf
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="Searching..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/11/STL源码剖析 笔记1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">STL 源码剖析 笔记1</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-12-11T09:13:00+08:00">
                2020-12-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="第一章：STL概论和版本简介"><a href="#第一章：STL概论和版本简介" class="headerlink" title="第一章：STL概论和版本简介"></a>第一章：STL概论和版本简介</h1><h2 id="STL六大组件"><a href="#STL六大组件" class="headerlink" title="STL六大组件"></a>STL六大组件</h2><ol>
<li>容器：各种数据结构，如：vector、list、deque、set、map、主要用来存放数据。</li>
<li>算法：各种常见算法，如：sort、search、copy、erase</li>
<li>迭代器：扮演算法和容器中的中介。迭代器是一种将<code>operator*</code>、<code>operator-&gt;</code>、<code>operator++</code>、<code>operator--</code>等指针相关操作予以重载的class template。所有的容器均有自己独特的迭代器，实现对容器内数据的访问</li>
<li>仿函数：行为类似函数，可作为算法的某种策略。仿函数是一种重载了<code>operator()</code>的class或class template。一般指针函数可视为狭义的仿函数。</li>
<li>配接器（adapters）: 修饰容器、仿函数、迭代器接口。例如STL提供的queue和stack，虽然看似容器，但是只能算一种容器配接器，因为它们的底部完全借助deque，所有操作都由底层的deque供应。</li>
<li>配置器（allocators）：负责空间配置和管理，配置器是一个实现了动态空间配置、空间管理、空间释放的class template.</li>
</ol>
<h3 id="各组件间的关系"><a href="#各组件间的关系" class="headerlink" title="各组件间的关系"></a>各组件间的关系</h3><p><img src="/img/1607703761.jpg" alt></p>
<p>由于STL已成为C++标准程序库的大脉系，因此：目前所有的C++编译器一定支持有一份STL。STL并非以二进制代码面貌出现，而是以源代码面貌供应。某些STL版本同时存在具扩展名和无扩展名的两份文件，例如Visual C++的版本同时具备<code>&lt;vectorr.h&gt;</code>和<code>&lt;vector&gt;</code>。某些STL版本只存在具扩展名的头文件，例如C++ Builder的RaugeWave版本只有<code>&lt;vector.h&gt;</code>。某些STL版本不仅有一线装配，还有二线装配，例如GNU C++的SGI版本不但有一线的<code>&lt;vector.h&gt;</code>和<code>&lt;vector&gt;</code>，还有二线的<code>&lt;stl_vector.h&gt;</code>。</p>
<p>Container通过Allocator取得数据储存空间，Algorithm通过Iterator存取Container内容，Functor可以协助Algorithm完成不同的策略变化，Adapter可以修饰或套接Functor。</p>
<h2 id="SGI-STL头文件分布"><a href="#SGI-STL头文件分布" class="headerlink" title="SGI STL头文件分布"></a>SGI STL头文件分布</h2><ul>
<li>C++标准规范下的C头文件：cstdio，csyflib，cstring，…</li>
<li>C++标准程序库中不属于STL范畴者：stream，string，…</li>
<li>STL标准头文件(无扩展名)：vector，deque，list，map，…</li>
<li>C++标准定案前，HP所规范的STL头文件：vector.h，deque.h，list.h，…</li>
<li>SGI STL内部文件(STL真正实现与此)：stl_vector.h，stl_deque.h，stl_algo.h，…</li>
</ul>
<p>不同的编译器对C++语言的支持程度不尽相同。作为一个希望具备广泛移植能力的程序库，SGI STL准备了一个环境组态文件<code>&lt;stl_config.h&gt;</code>，其中定义了许多常量，标示某些组态的成立与否，所有STL头文件都会直接或间接包含这个组态文件，并以条件式写法，让预处理器根据各个常量决定取舍哪一段程序代码，例如：<br><img src="/img/1608811144.jpg" alt></p>
<p><code>&lt;stl_config.h&gt;</code>文件起始处有一份常量定义说明，针对各家不同的编译器及可能的版本给予常量设定。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Filename:    stl_config.h  </span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * Copyright (c) 1996-1997 </span></span><br><span class="line"><span class="comment"> * Silicon Graphics Computer Systems, Inc. </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Permission to use, copy, modify, distribute and sell this software </span></span><br><span class="line"><span class="comment"> * and its documentation for any purpose is hereby granted without fee, </span></span><br><span class="line"><span class="comment"> * provided that the above copyright notice appear in all copies and </span></span><br><span class="line"><span class="comment"> * that both that copyright notice and this permission notice appear </span></span><br><span class="line"><span class="comment"> * in supporting documentation.  Silicon Graphics makes no </span></span><br><span class="line"><span class="comment"> * representations about the suitability of this software for any </span></span><br><span class="line"><span class="comment"> * purpose.  It is provided "as is" without express or implied warranty. </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/* <span class="doctag">NOTE:</span> This is an internal header file, included by other STL headers. </span></span><br><span class="line"><span class="comment"> *   You should not attempt to use it directly. </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __STL_CONFIG_H  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __STL_CONFIG_H  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">//  本配置文件功能表:  </span></span><br><span class="line"><span class="comment">//  (1)  如果不编译器没有定义bool, true, false则定义  </span></span><br><span class="line"><span class="comment">//  (2)  如果编译器不支持drand48()函数则定义__STL_NO_DRAND48  </span></span><br><span class="line"><span class="comment">//       注: drand48产生双精度的伪随机数, 因为采用了48bit计算, 故名drand48  </span></span><br><span class="line"><span class="comment">//  (3)  如果编译器不支持static members of template classes(模板类静态成员),  </span></span><br><span class="line"><span class="comment">//       则定义__STL_STATIC_TEMPLATE_MEMBER_BUG  </span></span><br><span class="line"><span class="comment">//  (4)  如果编译器不支持'typename'关键字, 则将'typename'定义为空(null macro)  </span></span><br><span class="line"><span class="comment">//  (5)  如果编译器支持partial specialization of class templates(模板类偏特化),  </span></span><br><span class="line"><span class="comment">//       则定义__STL_CLASS_PARTIAL_SPECIALIZATION  </span></span><br><span class="line"><span class="comment">//       参考文献: http://msdn.microsoft.com/en-us/library/9w7t3kf1(v=VS.71).aspx  </span></span><br><span class="line"><span class="comment">//  (6)  如果编译器支持partial ordering of function templates(模板函数特化优先级),  </span></span><br><span class="line"><span class="comment">//       则定义__STL_FUNCTION_TMPL_PARTIAL_ORDER  </span></span><br><span class="line"><span class="comment">//       参考资料: http://msdn.microsoft.com/zh-cn/library/zaycz069.aspx  </span></span><br><span class="line"><span class="comment">//  (7)  如果编译器支持calling a function template by providing its template  </span></span><br><span class="line"><span class="comment">//       arguments explicitly(显式指定调用模板函数的模板参数)  </span></span><br><span class="line"><span class="comment">//       则定义__STL_EXPLICIT_FUNCTION_TMPL_ARGS  </span></span><br><span class="line"><span class="comment">//  (8)  如果编译器支持template members of classes(类模板成员),  </span></span><br><span class="line"><span class="comment">//       则定义__STL_MEMBER_TEMPLATES  </span></span><br><span class="line"><span class="comment">//  (9)  如果编译器不支持'explicit'关键字, 则将'explicit'定义为空(null macro)  </span></span><br><span class="line"><span class="comment">//  (10) 如果编译器不能根据前一个模板参数设定后面的默认模板参数,  </span></span><br><span class="line"><span class="comment">//       则定义__STL_LIMITED_DEFAULT_TEMPLATES  </span></span><br><span class="line"><span class="comment">//  (11) 如果编译器处理模板函数的non-type模板参数类型推断有困难,  </span></span><br><span class="line"><span class="comment">//       则定义__STL_NON_TYPE_TMPL_PARAM_BUG  </span></span><br><span class="line"><span class="comment">//  (12) 如果编译器不支持迭代器使用'-&gt;'操作符,  </span></span><br><span class="line"><span class="comment">//       则定义__SGI_STL_NO_ARROW_OPERATOR  </span></span><br><span class="line"><span class="comment">//  (13) 如果编译器(在当前编译模式下)支持异常,  </span></span><br><span class="line"><span class="comment">//       则定义__STL_USE_EXCEPTIONS  </span></span><br><span class="line"><span class="comment">//  (14) 如果我们将STL放进命名空间中,  </span></span><br><span class="line"><span class="comment">//       则定义__STL_USE_NAMESPACES  </span></span><br><span class="line"><span class="comment">//  (15) 如果本STL在SGI的编译器上编译, 并且用户没有选择pthreads或者no threads,  </span></span><br><span class="line"><span class="comment">//       则默认使用__STL_SGI_THREADS  </span></span><br><span class="line"><span class="comment">//       注: POSIX thread 简称为pthread, Posix线程是一个POSIX标准线程.  </span></span><br><span class="line"><span class="comment">//  (16) 如果本STL在Win32平台的编译器上使用多线程模式编译,  </span></span><br><span class="line"><span class="comment">//       则定义__STL_WIN32THREADS  </span></span><br><span class="line"><span class="comment">//  (17) 适当的定义命名空间相关的宏(__STD, __STL_BEGIN_NAMESPACE, 等)  </span></span><br><span class="line"><span class="comment">//  (18) 适当的定义异常相关的宏(__STL_TRY, __STL_UNWIND, 等)  </span></span><br><span class="line"><span class="comment">//  (19) 根据是否定义__STL_ASSERTIONS, 将__stl_assert定义为断言或者空(null macro)  </span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _PTHREADS  </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_PTHREADS  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// 如果编译器不提供本STL需要的一些功能,则定义__STL_NEED_XXX  </span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> defined(__sgi) &amp;&amp; !defined(__GNUC__)  </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">if</span> !defined(_BOOL)  </span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_NEED_BOOL  </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span>  </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">if</span> !defined(_TYPENAME_IS_KEYWORD)  </span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_NEED_TYPENAME  </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span>  </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">ifdef</span> _PARTIAL_SPECIALIZATION_OF_CLASS_TEMPLATES  </span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_CLASS_PARTIAL_SPECIALIZATION  </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span>  </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">ifdef</span> _MEMBER_TEMPLATES  </span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_MEMBER_TEMPLATES  </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span>  </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">if</span> !defined(_EXPLICIT_IS_KEYWORD)  </span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_NEED_EXPLICIT  </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span>  </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">ifdef</span> __EXCEPTIONS  </span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_USE_EXCEPTIONS  </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span>  </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">if</span> (_COMPILER_VERSION &gt;= 721) &amp;&amp; defined(_NAMESPACES)  </span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_USE_NAMESPACES  </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span>  </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">if</span> !defined(_NOTHREADS) &amp;&amp; !defined(__STL_PTHREADS)  </span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_SGI_THREADS  </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span>  </span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifdef</span> __GNUC__  </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">include</span> <span class="meta-string">&lt;_G_config.h&gt;  </span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">if</span> __GNUC__ &lt; 2 || (__GNUC__ == 2 &amp;&amp; __GNUC_MINOR__ &lt; 8)  </span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_STATIC_TEMPLATE_MEMBER_BUG  </span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_NEED_TYPENAME  </span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_NEED_EXPLICIT  </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">else</span>  </span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_CLASS_PARTIAL_SPECIALIZATION  </span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_FUNCTION_TMPL_PARTIAL_ORDER  </span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_EXPLICIT_FUNCTION_TMPL_ARGS  </span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_MEMBER_TEMPLATES  </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span>  </span></span><br><span class="line">    <span class="comment">/* glibc pre 2.0 is very buggy. We have to disable thread for it. </span></span><br><span class="line"><span class="comment">       It should be upgraded to glibc 2.0 or later. */</span>  </span><br><span class="line"><span class="meta">#   <span class="meta-keyword">if</span> !defined(_NOTHREADS) &amp;&amp; __GLIBC__ &gt;= 2 &amp;&amp; defined(_G_USING_THUNKS)  </span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_PTHREADS  </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span>  </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">ifdef</span> __EXCEPTIONS  </span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_USE_EXCEPTIONS  </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span>  </span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// Sun C++ compiler  </span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> defined(__SUNPRO_CC)  </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_NEED_BOOL  </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_NEED_TYPENAME  </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_NEED_EXPLICIT  </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_USE_EXCEPTIONS  </span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> defined(__COMO__)  </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_MEMBER_TEMPLATES  </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_CLASS_PARTIAL_SPECIALIZATION  </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_USE_EXCEPTIONS  </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_USE_NAMESPACES  </span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// _MSC_VER 定义微软编译器的版本  </span></span><br><span class="line"><span class="comment">// MS VC++ 10.0 _MSC_VER = 1600  </span></span><br><span class="line"><span class="comment">// MS VC++ 9.0 _MSC_VER = 1500  </span></span><br><span class="line"><span class="comment">// MS VC++ 8.0 _MSC_VER = 1400  </span></span><br><span class="line"><span class="comment">// MS VC++ 7.1 _MSC_VER = 1310  </span></span><br><span class="line"><span class="comment">// MS VC++ 7.0 _MSC_VER = 1300  </span></span><br><span class="line"><span class="comment">// MS VC++ 6.0 _MSC_VER = 1200  </span></span><br><span class="line"><span class="comment">// MS VC++ 5.0 _MSC_VER = 1100  </span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> defined(_MSC_VER)  </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">if</span> _MSC_VER &gt; 1000  </span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">include</span> <span class="meta-string">&lt;yvals.h&gt;  </span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">else</span>  </span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_NEED_BOOL  </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span>  </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_NO_DRAND48  </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_NEED_TYPENAME  </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">if</span> _MSC_VER &lt; 1100  </span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_NEED_EXPLICIT  </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span>  </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_NON_TYPE_TMPL_PARAM_BUG  </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __SGI_STL_NO_ARROW_OPERATOR  </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">ifdef</span> _CPPUNWIND  </span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_USE_EXCEPTIONS  </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span>  </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">ifdef</span> _MT  </span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_WIN32THREADS  </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span>  </span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> defined(__BORLANDC__)  </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_NO_DRAND48  </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_NEED_TYPENAME  </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_LIMITED_DEFAULT_TEMPLATES  </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __SGI_STL_NO_ARROW_OPERATOR  </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_NON_TYPE_TMPL_PARAM_BUG  </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">ifdef</span> _CPPUNWIND  </span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_USE_EXCEPTIONS  </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span>  </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">ifdef</span> __MT__  </span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">define</span> __STL_WIN32THREADS  </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span>  </span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span>  </span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> defined(__STL_NEED_BOOL)  </span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">int</span> <span class="keyword">bool</span>;  </span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> true 1  </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> false 0  </span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifdef</span> __STL_NEED_TYPENAME  </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> typename  </span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifdef</span> __STL_NEED_EXPLICIT  </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> explicit  </span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifdef</span> __STL_EXPLICIT_FUNCTION_TMPL_ARGS  </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_NULL_TMPL_ARGS <span class="meta-string">&lt;&gt;  </span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">else</span>  </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_NULL_TMPL_ARGS  </span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifdef</span> __STL_CLASS_PARTIAL_SPECIALIZATION  </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_TEMPLATE_NULL template<span class="meta-string">&lt;&gt;  </span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">else</span>  </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_TEMPLATE_NULL  </span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// __STL_NO_NAMESPACES is a hook so that users can disable namespaces  </span></span><br><span class="line"><span class="comment">// without having to edit library headers.  </span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> defined(__STL_USE_NAMESPACES) &amp;&amp; !defined(__STL_NO_NAMESPACES)  </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STD std  </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_BEGIN_NAMESPACE namespace std &#123;  </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_END_NAMESPACE &#125;  </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_USE_NAMESPACE_FOR_RELOPS  </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_BEGIN_RELOPS_NAMESPACE namespace std &#123;  </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_END_RELOPS_NAMESPACE &#125;  </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STD_RELOPS std  </span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">else</span>  </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STD  </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_BEGIN_NAMESPACE  </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_END_NAMESPACE  </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">undef</span>  __STL_USE_NAMESPACE_FOR_RELOPS  </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_BEGIN_RELOPS_NAMESPACE  </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_END_RELOPS_NAMESPACE  </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STD_RELOPS  </span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifdef</span> __STL_USE_EXCEPTIONS  </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_TRY try  </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_CATCH_ALL catch(...)  </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_RETHROW throw  </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_NOTHROW throw()  </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_UNWIND(action) catch(...) &#123; action; throw; &#125;  </span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">else</span>  </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_TRY  </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_CATCH_ALL <span class="meta-keyword">if</span> (false)  </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_RETHROW  </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_NOTHROW  </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __STL_UNWIND(action)  </span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __STL_ASSERTIONS  </span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __stl_assert(expr) \  </span></span><br><span class="line">    <span class="keyword">if</span> (!(expr)) &#123; <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s:%d STL assertion failure: %s\n"</span>, \  </span><br><span class="line">              __FILE__, __LINE__, # expr); <span class="built_in">abort</span>(); &#125;  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span>  </span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __stl_assert(expr)  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __STL_CONFIG_H */</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// Local Variables:  </span></span><br><span class="line"><span class="comment">// mode:C++  </span></span><br><span class="line"><span class="comment">// End:</span></span><br></pre></td></tr></table></figure></p>
<h2 id="可能困惑的C-语法"><a href="#可能困惑的C-语法" class="headerlink" title="可能困惑的C++语法"></a>可能困惑的C++语法</h2><h3 id="stl-config-h中的各种组态（configuration）"><a href="#stl-config-h中的各种组态（configuration）" class="headerlink" title="stl_config.h中的各种组态（configuration）"></a>stl_config.h中的各种组态（configuration）</h3><p>组态3<code>__STL_STATIC_TEMPLATE_MEMBER_BUG</code>。如果编译器无法处理static member of template classes(模板类静态成员)就定义<br>。即对于模板类中，模板类型不同时的静态变量不同。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> _data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> test&lt;<span class="keyword">int</span>&gt;::_data=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> test&lt;<span class="keyword">char</span>&gt;::_data=<span class="number">2</span>;</span><br></pre></td></tr></table></figure></p>
<p>组态5<code>__STL_CLASS_PARTIAL_SPECIALIZATION</code>。如果编译器支持 partial specialization of class templates(模板类偏特化)就定义。在模板类一般化设计之外（全特化），针对某些template做特殊设计。“所谓的partial specialization的另一个意思是提供另一份template定义式,而其本身仍是templatized”。全特化就是所有的模板都为具体的类。<code>T*</code>特化允许用指针类型匹配的模式（也只能匹配指针类型）。<code>const T*</code>特化允许使用指向const的指针类型匹配（也只能匹配指向const的指针）。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一般化设计，非特化情况均使用这个</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>,<span class="title">class</span> <span class="title">O</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">test</span>&#123;</span></span><br><span class="line">	test() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"I, O"</span> &lt;&lt;<span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//特殊化设计1（偏特化1）</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">test</span> &lt;T* ,T*&gt; &#123;</span></span><br><span class="line">	test() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"T* ,T*"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//特殊化设计2（偏特化2）</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">test</span> &lt;const T* ,T*&gt; &#123;</span></span><br><span class="line">	test() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"const T* ,T*"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	test&lt;<span class="keyword">int</span>, <span class="keyword">char</span>&gt; obj1;         <span class="comment">//I, O</span></span><br><span class="line">	test&lt;<span class="keyword">int</span>*, <span class="keyword">int</span>*&gt; obj2;        <span class="comment">//T*, T*</span></span><br><span class="line">	test&lt;<span class="keyword">const</span> <span class="keyword">int</span>*, <span class="keyword">int</span>*&gt; obj3;  <span class="comment">//const T*, T*</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>组态6<code>__STL_FUNCTION_TMPL_PARTIAL_ORDER</code>。如果编译器支持partial ordering of function templates或者说partial specialization of function templates就定义。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>,<span class="title">class</span> <span class="title">Alloc</span>=<span class="title">alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">vec</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(vec&lt;T, Alloc&gt;&amp;)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"swap1()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __STL_FUNCTION_TMPL_PARTIAL_ORDER</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span> = <span class="title">alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">swap</span>(<span class="title">vec</span>&lt;T, Alloc&gt;&amp; <span class="title">a</span>, <span class="title">vec</span>&lt;T, Alloc&gt;&amp; <span class="title">b</span>) &#123;</span> a.swap(b); &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vec&lt;<span class="keyword">int</span>&gt; a, b;</span><br><span class="line">	swap(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>组态8<code>__STL_MEMBER_TEMPLATES</code>。如果编译器支持template members of classes（模板类内嵌套模板） 就定义。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">vec</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> T value_type;</span><br><span class="line">	<span class="keyword">typedef</span> value_type* iterator;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>&gt;</span></span><br><span class="line"><span class="class">	<span class="title">void</span> <span class="title">insert</span>(<span class="title">iterator</span> <span class="title">position</span>, <span class="title">I</span> <span class="title">first</span>, <span class="title">I</span> <span class="title">last</span>) &#123;</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"insert()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ia[<span class="number">5</span>] = &#123; <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> &#125;;</span><br><span class="line">	vec&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line">	vec&lt;<span class="keyword">int</span>&gt;::iterator ite;</span><br><span class="line">	a.insert(ite, ia, ia + <span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>组态10<code>__STL_LIMITED_DEFAULT_TEMPLATES</code>。如果编译器支持一个template参数可以根据前一个template的参数设置就定义。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>,<span class="title">class</span> <span class="title">Alloc</span>=<span class="title">alloc</span>,<span class="title">size_t</span> <span class="title">BufSiz</span>=0&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">deque</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">deque</span>() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="built_in">deque</span>() &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>,<span class="title">class</span> <span class="title">Sequence</span>=<span class="title">deque</span>&lt;T&gt;&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">stack</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">stack</span>() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Stack"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Sequence c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>组态11<code>__STL_NON_TYPE_TMPL_PARAM_BUG</code>。测试类模板是否使用非类型模板参数（non-type template parameters） 。当以类型(type)作为模板参数的时候，代码中未决定的是类型；</p>
<p>当以一般的数字(non-type)作为模板参数的时候，代码中待定的内容便是某些数值。使用者这种模板必须要显示指定数值，模板才能实例化。通常它们只能是常数整数（constant integral values ）包括枚举，或者是指向外部链接的指针。不能把float，class-type类型的对象，内部链接(internal linkage )对象,作为非类型模板参数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>,<span class="title">class</span> <span class="title">Alloc</span>=<span class="title">alloc</span>,<span class="title">size_t</span> <span class="title">BufSiz</span>=0&gt;  //<span class="title">BufSiz</span>即为非类型模板。</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">deque</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">deque</span>() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="built_in">deque</span>() &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>__STL_NULL_TMPL_ARGS</code>。直接理解为若允许<strong>bound friend template(约束模板友元)</strong>则定义为 &lt;&gt; ，否则为空。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">friend</span> <span class="keyword">bool</span> ooperator== __STL_NULL_TMPL_ARGS(<span class="keyword">const</span> <span class="built_in">stack</span>&amp;,<span class="keyword">const</span> <span class="built_in">stack</span>&amp;);</span><br></pre></td></tr></table></figure></p>
<p>展开后变成<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">friend</span> <span class="keyword">bool</span> ooperator== &lt;&gt;(<span class="keyword">const</span> <span class="built_in">stack</span>&amp;,<span class="keyword">const</span> <span class="built_in">stack</span>&amp;);</span><br></pre></td></tr></table></figure></p>
<p><strong>bound friend template(约束模板友元)</strong>即友元类型取决于类被初始化时的类型，但程序必须在类外为友元提供模板定义。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>,<span class="title">class</span> <span class="title">Sequence</span>=<span class="title">deque</span>&lt;T&gt;&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">stack</span> &#123;</span></span><br><span class="line">	<span class="comment">//最标准的写法</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>== &lt;T&gt;(<span class="keyword">const</span> <span class="built_in">stack</span>&lt;T&gt;&amp;, <span class="keyword">const</span> <span class="built_in">stack</span>&lt;T&gt;&amp;);</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt; &lt;T&gt;(<span class="keyword">const</span> <span class="built_in">stack</span>&lt;T&gt;&amp;, <span class="keyword">const</span> <span class="built_in">stack</span>&lt;T&gt;&amp;);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//参数列表中的&lt;T&gt;实际上可以忽略</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>== &lt;T&gt;(<span class="keyword">const</span> <span class="built_in">stack</span>&amp;, <span class="keyword">const</span> <span class="built_in">stack</span>&amp;);</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt; &lt;T&gt;(<span class="keyword">const</span> <span class="built_in">stack</span>&amp;, <span class="keyword">const</span> <span class="built_in">stack</span>&amp;);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//当可以从参数中推断出模板类型时，可以改用&lt;&gt;</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>== &lt;&gt;(<span class="keyword">const</span> <span class="built_in">stack</span>&amp;, <span class="keyword">const</span> <span class="built_in">stack</span>&amp;);</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt; &lt;&gt;(<span class="keyword">const</span> <span class="built_in">stack</span>&amp;, <span class="keyword">const</span> <span class="built_in">stack</span>&amp;);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//下面用法是错误的！</span></span><br><span class="line">	<span class="comment">//friend bool operator== (const stack&amp;, const stack&amp;);</span></span><br><span class="line">	<span class="comment">//friend bool operator&lt; (const stack&amp;, const stack&amp;);</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">stack</span>() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Stack"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Sequence c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//定义部分懒得写了，但必须要写！</span></span><br></pre></td></tr></table></figure></p>
<p><code>__STL_TEMPLATE_NULL</code>即<code>template &lt;&gt;</code>显示的模板特化 。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __STL_CLASS_PARTIAL_SPECIALIZATION</span></span><br><span class="line"><span class="meta">#	 <span class="meta-keyword">define</span> __STL_TEMPLATE_NULL template<span class="meta-string">&lt;&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#	 <span class="meta-keyword">define</span> __STL_TEMPLATE_NULL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p><strong>模板特化(class template explicit specialization)</strong>即指定一种或多种模板形参的实际值或实际类型，作为特殊情况。（与模板类型偏特化不同！）<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">type</span>&gt; <span class="title">struct</span> __<span class="title">type_traits</span>&#123;</span> ...&#125;;<span class="comment">//非特化情况均使用这个</span></span><br><span class="line">__STL_TEMPLATE_NULL <span class="class"><span class="keyword">struct</span> __<span class="title">type_traits</span>&lt;char&gt; &#123;</span> ... &#125;;<span class="comment">//特化char情况</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>&gt; <span class="title">struct</span> <span class="title">hash</span> &#123;</span> &#125;;<span class="comment">//非特化情况均使用这个</span></span><br><span class="line">__STL_TEMPLATE_NULL <span class="class"><span class="keyword">struct</span> <span class="title">hash</span>&lt;char&gt; &#123;</span> ... &#125;;<span class="comment">//特化char情况</span></span><br><span class="line">__STL_TEMPLATE_NULL <span class="class"><span class="keyword">struct</span> <span class="title">hash</span>&lt;unsgned char&gt; &#123;</span> ... &#125;;<span class="comment">//特化unsigned char情况</span></span><br></pre></td></tr></table></figure></p>
<p>经展开后：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">type</span>&gt; <span class="title">struct</span> __<span class="title">type_traits</span>&#123;</span> ...&#125;;<span class="comment">//非特化情况均使用这个</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="class"><span class="keyword">struct</span> __<span class="title">type_traits</span>&lt;char&gt; &#123;</span> ... &#125;;<span class="comment">//特化char情况</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>&gt; <span class="title">struct</span> <span class="title">hash</span> &#123;</span> &#125;;<span class="comment">//非特化情况均使用这个</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="class"><span class="keyword">struct</span> <span class="title">hash</span>&lt;char&gt; &#123;</span> ... &#125;;<span class="comment">//特化char情况</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="class"><span class="keyword">struct</span> <span class="title">hash</span>&lt;unsgned char&gt; &#123;</span> ... &#125;;<span class="comment">//特化unsigned char情况</span></span><br></pre></td></tr></table></figure></p>
<h3 id="临时对象的产生与应用"><a href="#临时对象的产生与应用" class="headerlink" title="临时对象的产生与应用"></a>临时对象的产生与应用</h3><p>刻意制造一些临时对象，在类型名之后直接加一对()，并指定初值，使用时相当于调用该类的临时对象的()操作。常用于仿函数与算法的搭配上。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">print</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T&amp; elem)</span> </span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; elem &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">plus</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">T <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T&amp; x, <span class="keyword">const</span> T&amp; y)</span><span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> x + y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ai(&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;);</span><br><span class="line">	for_each(ai.begin(), ai.end(), print&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">5</span>, b = <span class="number">3</span>;</span><br><span class="line">	print&lt;<span class="keyword">int</span>&gt;()(plus&lt;<span class="keyword">int</span>&gt;()(a, b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后一行便是产生“function template具现体”<code>print&lt;int&gt;</code>的一个临时对象。这个对象将被传入进<code>for_each()</code>中。</p>
<h3 id="静态常量整数成员在class内部直接初始化"><a href="#静态常量整数成员在class内部直接初始化" class="headerlink" title="静态常量整数成员在class内部直接初始化"></a>静态常量整数成员在class内部直接初始化</h3><p>如果class内含const static integral data member，那么根据C++规格，我们可以在class之内直接给予初值。所谓integral泛指所有的整数型别（包括浮点数），不单只是指int，下面是一个例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">testClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">double</span> _datai=<span class="number">1.2</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">long</span> _datal=<span class="number">3L</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> _datac=<span class="string">'c'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;testClass&lt;<span class="keyword">int</span>&gt;::_datai&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;testClass&lt;<span class="keyword">int</span>&gt;::_datal&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;testClass&lt;<span class="keyword">int</span>&gt;::_datac&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一般，非const的static数据成员是不能在类的内部初始化，但是，我们可以为静态成员提供const整数类型的类内初始值。</p>
<p>例如，下面的情况会报错：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">testClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">double</span> _datai=<span class="number">1.2</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">long</span> _datal=<span class="number">3L</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> _datac=<span class="string">'c'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;testClass&lt;<span class="keyword">int</span>&gt;::_datai&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;testClass&lt;<span class="keyword">int</span>&gt;::_datal&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;testClass&lt;<span class="keyword">int</span>&gt;::_datac&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果加了const 或者constexpr之后，就可以在类内进行初始化了。</p>
<p>对于static成员，如果在类的内部提供了一个初值，则成员在类外的定义不能再指定一个初始值了。例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">testClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">double</span> _datai=<span class="number">1.2</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">long</span> _datal=<span class="number">3L</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> _datac=<span class="string">'c'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> testClass&lt;T&gt;::_datai=<span class="number">8.8</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;testClass&lt;<span class="keyword">int</span>&gt;::_datai&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;testClass&lt;<span class="keyword">int</span>&gt;::_datal&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;testClass&lt;<span class="keyword">int</span>&gt;::_datac&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面的情况是允许的，直接在定义的时候提供初始值或者在类内提供初始值之后只在类外定义但不提供初始值。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">testClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">double</span> _datai;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">long</span> _datal=<span class="number">3L</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> _datac=<span class="string">'c'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> testClass&lt;T&gt;::_datai=<span class="number">8.8</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;testClass&lt;<span class="keyword">int</span>&gt;::_datai&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;testClass&lt;<span class="keyword">int</span>&gt;::_datal&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;testClass&lt;<span class="keyword">int</span>&gt;::_datac&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>或者<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">testClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">double</span> _datai=<span class="number">1.2</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">long</span> _datal=<span class="number">3L</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> _datac=<span class="string">'c'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> testClass&lt;T&gt;::_datai;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;testClass&lt;<span class="keyword">int</span>&gt;::_datai&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;testClass&lt;<span class="keyword">int</span>&gt;::_datal&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;testClass&lt;<span class="keyword">int</span>&gt;::_datac&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="increment-decrement-dereference操作符"><a href="#increment-decrement-dereference操作符" class="headerlink" title="increment/decrement/dereference操作符"></a>increment/decrement/dereference操作符</h3><p>increment/dereference操作符在迭代器的实现上占有非常重要的地位，因为任何一个迭代器都必须实现出前进（increment，operator++）和取值（dereference，operator*）功能，前者还分为前置式（prefix）和后置式（Postfix）两种。有写迭代器具备双向移动功能，那么就必须再提供decrement操作符（也分前置式和后置式），下面是一个例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">INT</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,<span class="keyword">const</span> INT&amp; i);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    INT(<span class="keyword">int</span> i):m_i(i)&#123;&#125;</span><br><span class="line">    INT&amp; <span class="keyword">operator</span>++()</span><br><span class="line">    &#123;</span><br><span class="line">        ++(<span class="keyword">this</span>-&gt;m_i);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> INT <span class="keyword">operator</span>++(<span class="keyword">int</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        INT temp=*<span class="keyword">this</span>;</span><br><span class="line">        ++(*<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    INT&amp; <span class="keyword">operator</span>--()</span><br><span class="line">    &#123;</span><br><span class="line">        --(<span class="keyword">this</span>-&gt;m_i);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> INT <span class="keyword">operator</span>--(<span class="keyword">int</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        INT temp=*<span class="keyword">this</span>;</span><br><span class="line">        --(*<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>&amp;)m_i;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_i;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,<span class="keyword">const</span> INT &amp;i)</span><br><span class="line">&#123;</span><br><span class="line">    os&lt;&lt;<span class="string">'['</span>&lt;&lt;i.m_i&lt;&lt;<span class="string">']'</span>;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">INT <span class="title">I</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;I++;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;++I;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;I--;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;--I;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;*I;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="前闭后开区间表示法"><a href="#前闭后开区间表示法" class="headerlink" title="前闭后开区间表示法"></a>前闭后开区间表示法</h3><p>任何一个STL算法，都需要获得由一对迭代器（泛型指针）所标示的区间，用以表示操作范围，这一对迭代器所标示的是个所谓的前闭后开区间，以[first,last)表示，也就是说，整个实际范围从first开始，直到last-1.迭代器last所指的是“最后一个元素的下一位置”。这种off by one（偏移一格，或说pass the end）的标示法，带来了很多方便，例如下面两个STL算法的循环设计，就显得干净利落：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>,<span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">InputIterator</span> <span class="title">find</span>(<span class="title">InputIterator</span> <span class="title">first</span>,<span class="title">InputIterator</span> <span class="title">last</span>,<span class="title">const</span> <span class="title">T</span>&amp;<span class="title">value</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">while</span>(first!=last&amp;&amp;*first!=value) ++first;</span><br><span class="line">    <span class="keyword">return</span> first; <span class="comment">//返回迭代器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>,<span class="title">class</span> <span class="title">Function</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">Function</span> <span class="title">for_each</span>(<span class="title">InputIterator</span> <span class="title">first</span>,<span class="title">InputIterator</span> <span class="title">last</span>,<span class="title">Function</span> <span class="title">f</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">for</span>(;first!=last;++first)</span><br><span class="line">        f(*first);</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="function-call-操作符"><a href="#function-call-操作符" class="headerlink" title="function call 操作符"></a>function call 操作符</h3><p>函数调用操作（C++语法中的左右小括号）也可以被重载。</p>
<p>许多STL算法都提供了两个版本，一个用于一般情况（例如排序时以递增方式排列），一个用于特殊情况（例如排序时由使用者指定以何种特殊关系进行排列），像这种情况，需要用户指定某个条件或某个策略，而条件或策略的背后由一整组操作构成，便需要某种特殊的东西来代表这“一整组操作”。</p>
<p>代表“一整组操作“的，当然是函数，过去C语言时代，欲将函数当做参数传递，唯有通过函数指针才能达成，例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* elem1,<span class="keyword">const</span> <span class="keyword">void</span>* elem2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ia[<span class="number">10</span>]=&#123;<span class="number">32</span>,<span class="number">92</span>,<span class="number">67</span>,<span class="number">58</span>,<span class="number">10</span>,<span class="number">4</span>,<span class="number">25</span>,<span class="number">52</span>,<span class="number">59</span>,<span class="number">54</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ia[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    qsort(ia,<span class="keyword">sizeof</span>(ia)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>),<span class="keyword">sizeof</span>(<span class="keyword">int</span>),fcmp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ia[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* elem1,<span class="keyword">const</span> <span class="keyword">void</span>* elem2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> *i1=(<span class="keyword">const</span> <span class="keyword">int</span>*)elem1;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> *i2=(<span class="keyword">const</span> <span class="keyword">int</span>*)elem2;</span><br><span class="line">    <span class="keyword">if</span>(*i1&lt;*i2)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(*i1==*i2)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(*i1&gt;*i2)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是函数指针有缺点，最重要的是它无法持有自己的状态（所谓局部状态，local states），也无法达到组件技术中的可适配性（adaptability）——也就是无法再将某些修饰条件加诸于其上面而改变其状态。</p>
<p>为此，STL算法的特殊版本所接受的所谓“条件”或“策略”或“一整组操作”，都以仿函数形式呈现。所谓仿函数（functor）就是使用起来像函数一样的东西。如果你针对么某个class进行<code>operator()</code>重载，它就是一个仿函数，至于要成为一个可配接的仿函数，还需要做一些额外的努力。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//注意，不能使用using namespace std 不然plus和minus会有歧义</span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">plus</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function">T <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T&amp; x,<span class="keyword">const</span> T&amp; y)</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> x+y;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">minus</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function">T <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T&amp; x,<span class="keyword">const</span> T&amp; y)</span><span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> x-y;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    plus&lt;<span class="keyword">int</span>&gt; plusObj;</span><br><span class="line">    minus&lt;<span class="keyword">int</span>&gt; minusObj;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;plusObj(<span class="number">3</span>,<span class="number">5</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;minusObj(<span class="number">3</span>,<span class="number">5</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//注意下面的调用，不要忘记调用默认构造函数的小括号以及函数对象调用参数的小括号</span></span><br><span class="line">　　<span class="comment">//以下直接产生仿函数的临时对象（第一对小括号），并调用之（第二对小括号）</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;plus&lt;<span class="keyword">int</span>&gt;()(<span class="number">43</span>,<span class="number">50</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;minus&lt;<span class="keyword">int</span>&gt;()(<span class="number">43</span>,<span class="number">50</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="空间配置器"><a href="#空间配置器" class="headerlink" title="空间配置器"></a>空间配置器</h1><p>以STL的运用角度而言，空间配置器是最不需要介绍的东西，它总是隐藏在一切组件（更具体地说是指容器，container）的背后，默默工作，默默付出。但若以STL的实现角度而言，第一个需要介绍的就是空间配置器，因为整个STL的操作对象（所有的数据）都存放在容器之内，而容器一定需要配置空间以置放资料。</p>
<p>为什么不说allocator是内存配置器而说它是空间配置器呢？因为空间不一定是内存，空间也可以是磁盘或其它辅助存储介质。是的，你可以一个allocator，直接向硬盘取空间，以下介绍的是SGI STL提供的配置器，配置的对象是内存。</p>
<h2 id="空间配置器的标准接口"><a href="#空间配置器的标准接口" class="headerlink" title="空间配置器的标准接口"></a>空间配置器的标准接口</h2><p>根据STL的规范，以下是allocator的必要接口：</p>
<ul>
<li><code>allocator::value_type</code></li>
<li><code>allocator::pointer</code></li>
<li><code>allocator::const_pointer</code></li>
<li><code>allocator::reference</code></li>
<li><code>allocator::const_reference</code></li>
<li><code>allocator::size_type</code></li>
<li><code>allocator::difference_type</code></li>
<li><code>allocator::rebind</code>：一个嵌套的class template，<code>class rebind&lt;U&gt;</code>拥有唯一的成员other，那是一个typedef，代表<code>allocator&lt;U&gt;</code></li>
<li><code>allocator::allocator()</code>：default constuctor</li>
<li><code>allocator::allocator(const allocator&amp;)</code>：copy constructor</li>
<li><code>template&lt;class U&gt;allocator::allocator(const allocator&lt;U&gt;&amp;)</code>：泛化的copy constructor</li>
<li><code>allocator::~allocator()</code>：destructor</li>
<li><code>pointer allocator::address(reference x)const</code>：返回某个对象的地址，算式<code>a.address(x)</code>等同于<code>&amp;x</code></li>
<li><code>const_pointer allocator::address(const_reference x)const</code>：返回某个const对象的地址，算式<code>a.address(x)</code>等同于<code>&amp;x</code></li>
<li><code>pointer allocator::allocate(size_type n,const void* =0)</code>：配置空间，足以存储n个T对象，第二参数是个提示，实际上可能会利用它来增进区域性，或完全忽略之</li>
<li><code>void allocator::deallocate(pointer p,size_type n)</code>：归还先前配置的空间</li>
<li><code>size_type allocator::max_size() const</code>：返回可成功分配的最大量</li>
<li><code>void allocator::construct(pointer p,const T&amp; x)</code>：等同于<code>new((void*)p) T(x)</code></li>
<li><code>void allocator::destroy(pointer p)</code>：等同于<code>p-&gt;~T()</code></li>
</ul>
<h3 id="设计一个简单的空间配置器-JJ-allocator"><a href="#设计一个简单的空间配置器-JJ-allocator" class="headerlink" title="设计一个简单的空间配置器, JJ::allocator"></a>设计一个简单的空间配置器, JJ::allocator</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;new&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstddef&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> JJ</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> T* _allocate(<span class="keyword">ptrdiff_t</span> size, T*)</span><br><span class="line">&#123;</span><br><span class="line">	set_new_handler(<span class="number">0</span>);</span><br><span class="line">	T* tmp = (T*)(::<span class="keyword">operator</span> <span class="keyword">new</span>((<span class="keyword">size_t</span>)(size *<span class="keyword">sizeof</span>(T))));</span><br><span class="line">	<span class="keyword">if</span> (tmp == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cerr</span> &lt;&lt; <span class="string">"out of memory!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _deallocate(T* buffer)</span><br><span class="line">&#123;</span><br><span class="line">	::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(buffer)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1,<span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _construct(T1* p,<span class="keyword">const</span> T2&amp; value)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">new</span>(p) T1(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _destroy(T* ptr)</span><br><span class="line">&#123;</span><br><span class="line">	ptr-&gt;T();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">allocator</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> T value_type;</span><br><span class="line">	<span class="keyword">typedef</span> T* pointer;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">const</span> T* const_pointer;</span><br><span class="line">	<span class="keyword">typedef</span> T&amp; reference;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">const</span> T&amp; const_reference;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rebind</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		<span class="keyword">typedef</span> allocator&lt;U&gt; other;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function">pointer <span class="title">allocate</span><span class="params">(size_type n, <span class="keyword">const</span> <span class="keyword">void</span> *hint=<span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> _allocate((difference_type)n, (pointer)<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(pointer p, size_type n)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		_deallocate(p);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">construct</span><span class="params">(pointer p, <span class="keyword">const</span> T&amp; value)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		_construct(p,value);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">(pointer p)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		_destroy(p);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function">pointer <span class="title">address</span><span class="params">(reference x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (pointer)&amp;x;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function">const_pointer <span class="title">const_address</span><span class="params">(const_reference x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (const_pointer)&amp;x;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function">size_type <span class="title">max_size</span><span class="params">()</span><span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> size_type(UINT_MAX/<span class="keyword">sizeof</span>(T));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ia[<span class="number">5</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> i;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>,JJ::allocator&lt;<span class="keyword">int</span>&gt;&gt; ivv(ia,ia+<span class="number">5</span>);</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>,<span class="built_in">std</span>::allocator&lt;<span class="keyword">int</span>&gt; &gt; iv(ia,ia+<span class="number">5</span>);</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; iv.size(); ++i)</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; iv[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="具备次配置力的-SGI-空间配置器"><a href="#具备次配置力的-SGI-空间配置器" class="headerlink" title="具备次配置力的 SGI 空间配置器"></a>具备次配置力的 SGI 空间配置器</h2><p>SGI STL的配置器与众不同，它与标准规范不同，其名称是alloc而非allocator。如果要在程序中明白采用SGI配置器，那么应该这样写：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::alloc&gt; iv; <span class="comment">//gcc编译器</span></span><br></pre></td></tr></table></figure></p>
<p>配置器名字为alloc，不接受任何参数。标准配置器的名字是allocator，而且可以接受参数。比如VC中写法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::allocator&lt;<span class="keyword">int</span>&gt; &gt; iv; <span class="comment">//VC编译器</span></span><br></pre></td></tr></table></figure></p>
<p>SGI STL的每一个容器都已经指定了缺省配置其alloc。我们很少需要自己去指定空间配置器。比如vector容器的声明：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span> = <span class="title">alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">vector</span> &#123;</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="SGI标准的空间配置器allocator"><a href="#SGI标准的空间配置器allocator" class="headerlink" title="SGI标准的空间配置器allocator"></a>SGI标准的空间配置器allocator</h3><p>其实SGI也定义了一个符合部分标准，名为allocator的配置器，但是它自己不使用，也不建议我们使用，主要原因是效率不佳。它只是把C++的操作符<code>::operator new</code>和<code>::operator delete</code>做了一层简单的封装而已。下面仅仅贴出代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> DEFALLOC_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFALLOC_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;new.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algobase.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//仅仅是简单的封装了operator new</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">T</span>* <span class="title">allocate</span>(<span class="title">ptrdiff_t</span> <span class="title">size</span>, <span class="title">T</span>*) &#123;</span></span><br><span class="line">    set_new_handler(<span class="number">0</span>);</span><br><span class="line">    T* tmp = (T*)(::<span class="keyword">operator</span> <span class="keyword">new</span>((<span class="keyword">size_t</span>)(size * <span class="keyword">sizeof</span>(T))));</span><br><span class="line">    <span class="keyword">if</span> (tmp == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">cerr</span> &lt;&lt; <span class="string">"out of memory"</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//仅仅是简单的封装了operator::delete</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">deallocate</span>(<span class="title">T</span>* <span class="title">buffer</span>) &#123;</span></span><br><span class="line">    ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(buffer)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">allocator</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line">    <span class="keyword">typedef</span> T* pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">const</span> T* const_pointer;</span><br><span class="line">    <span class="keyword">typedef</span> T&amp; reference;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">const</span> T&amp; const_reference;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type;</span><br><span class="line"></span><br><span class="line">    <span class="function">pointer <span class="title">allocate</span><span class="params">(size_type n)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> ::allocate((difference_type)n, (pointer)<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(pointer p)</span> </span>&#123; ::deallocate(p); &#125;</span><br><span class="line">    <span class="function">pointer <span class="title">address</span><span class="params">(reference x)</span> </span>&#123; <span class="keyword">return</span> (pointer)&amp;x; &#125;</span><br><span class="line">    <span class="function">const_pointer <span class="title">const_address</span><span class="params">(const_reference x)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> (const_pointer)&amp;x; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">size_type <span class="title">init_page_size</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> max(size_type(<span class="number">1</span>), size_type(<span class="number">4096</span>/<span class="keyword">sizeof</span>(T))); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> max(size_type(<span class="number">1</span>), size_type(UINT_MAX/<span class="keyword">sizeof</span>(T))); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 特化版本</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">allocator</span>&lt;void&gt; &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">void</span>* pointer;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<h3 id="SGI特殊的空间配置器std-alloc"><a href="#SGI特殊的空间配置器std-alloc" class="headerlink" title="SGI特殊的空间配置器std::alloc"></a>SGI特殊的空间配置器std::alloc</h3><p>一般而言，我们所习惯的C++内存配置器操作和释放操作时这样的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FOO</span> &#123;</span> ...&#125;;</span><br><span class="line">FOO* pf=<span class="keyword">new</span> FOO;  <span class="comment">//配置内存，然后构造对象</span></span><br><span class="line"><span class="keyword">delete</span> pf;  <span class="comment">//将对象析构，然后释放内存</span></span><br></pre></td></tr></table></figure></p>
<p>这其中的new算式内含两个阶段操作：</p>
<ol>
<li>调用<code>::operator new</code>配置内存</li>
<li>调用<code>FOO::FOO()</code>构造对象内容</li>
</ol>
<p>delete算式也内含两个阶段操作：</p>
<ol>
<li>调用<code>FOO::~FOO()</code>对对象析构</li>
<li>调用<code>::operator delete</code>释放内存</li>
</ol>
<p>为了精密分工，SGI allocator将两个阶段分开：</p>
<p>内存配置操作由<code>alloc:allocate</code>负责，内存释放由<code>alloc:deallocate</code>负责；对象构造操作由<code>::contructor()</code>负责，对象析构由<code>::destroy()</code>负责。</p>
<p>STL标准告诉我们，配置器定义在头文件<code>&lt;memory&gt;</code>中，它里面又包括两个文件：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stl_alloc.h&gt;		// 负责内存空间的配置和器释放</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stl_construct.h&gt;		// 负责对象的构造和析构</span></span></span><br></pre></td></tr></table></figure></p>
<p>内存空间的配置/释放与对象内容的构造/析构，分别落在这两个文件身上。其中<code>&lt;stl_construct.h&gt;</code>定义了两个基本函数：构造用的<code>construct()</code>和析构用的<code>destroy()</code>。</p>
<p>下图显示了其结构：<br><img src="/img/1608949666.jpg" alt></p>
<h3 id="构造函数析构的基本工具：construct-和destroy"><a href="#构造函数析构的基本工具：construct-和destroy" class="headerlink" title="构造函数析构的基本工具：construct()和destroy()"></a>构造函数析构的基本工具：construct()和destroy()</h3><p>下面是<code>&lt;stl_constuct.h&gt;</code>的部分内容：</p>
<p>函数<code>construct()</code>使用了定位new操作符，其源代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="title">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">construct</span>(<span class="title">T1</span>* <span class="title">p</span>, <span class="title">const</span> <span class="title">T2</span>&amp; <span class="title">value</span>) &#123;</span></span><br><span class="line">  <span class="keyword">new</span> (p) T1(value);     <span class="comment">// 定为new操作符placement new; 在指针p所指处构造对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>函数destroy则有两个版本。</p>
<p>第一个版本较简单，接受一个指针作为参数，直接调用对象的析构函数即可，其源代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">destroy</span>(<span class="title">T</span>* <span class="title">pointer</span>) &#123;</span></span><br><span class="line">    pointer-&gt;~T();    <span class="comment">// 调用析构函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第二个版本，其参数接受两个迭代器，将两个迭代器所指范围内的所有对象析构掉。而且，它采用了一种特别的技术：依据元素的型别，判断其是否有trivial destructor（无用的析构函数）进行不同的处理。这也是为了效率考虑。因为如果每个对象的析构函数都是trivial的，那么调用这些毫无作用的析构函数会对效率造成影响。</p>
<p>下面看其源代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下是 destroy() 第二版本，接受两个迭代器。它会设法找出元素的数值型別，</span></span><br><span class="line"><span class="comment">// 进而利用 __type_traits&lt;&gt; 求取最适当措施。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">destroy</span>(<span class="title">ForwardIterator</span> <span class="title">first</span>, <span class="title">ForwardIterator</span> <span class="title">last</span>) &#123;</span></span><br><span class="line">  __destroy(first, last, value_type(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断元素的数值型別（value type）是否有 trivial destructor，分别调用上面的函数进行不同的处理</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> __<span class="title">destroy</span>(<span class="title">ForwardIterator</span> <span class="title">first</span>, <span class="title">ForwardIterator</span> <span class="title">last</span>, <span class="title">T</span>*) &#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> __type_traits&lt;T&gt;::has_trivial_destructor trivial_destructor;</span><br><span class="line">  __destroy_aux(first, last, trivial_destructor());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果元素的数值型別（value type）有 trivial destructor…</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> __<span class="title">destroy_aux</span>(<span class="title">ForwardIterator</span>, <span class="title">ForwardIterator</span>, __<span class="title">true_type</span>) &#123;</span>&#125;<span class="comment">//不调用析构函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果元素的数值型別（value type）有 non-trivial destructor…</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span></span></span><br><span class="line"><span class="class">__<span class="title">destroy_aux</span>(<span class="title">ForwardIterator</span> <span class="title">first</span>, <span class="title">ForwardIterator</span> <span class="title">last</span>, __<span class="title">false_type</span>) &#123;</span></span><br><span class="line">  <span class="keyword">for</span> ( ; first &lt; last; ++first)</span><br><span class="line">    destroy(&amp;*first);<span class="comment">//调用析构函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第二版本还针对迭代器为<code>char*</code>和<code>wchar_t*</code>定义了特化版本：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">(<span class="keyword">char</span>*, <span class="keyword">char</span>*)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">(<span class="keyword">wchar_t</span>*, <span class="keyword">wchar_t</span>*)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>图二显示了这两个函数的结构和功能。他们被包含在头文件<code>stl_construct.h</code>中。<br><img src="/img/1608949943.jpg" alt></p>
<p>这两个作为构造、析构之用的函数被设计为全局函数，符合STL的规范。此外，STL还规定配置器必须拥有名为<code>construct()</code>和<code>destroy()</code>的两个成员函数。</p>
<p>上述<code>construct()</code>接收一个指针p和一个初值value，该函数的用途就是将初值设定到指针所指的空间上。C++的<code>placement new</code>运算可用来完成这一任务。</p>
<p><code>destroy()</code>有两个版本，第一版本接受一个指针，准备将该指针所指之物析构掉。这很简单，直接调用该对象的析构函数即可。第二版本接受first和last迭代器，准备将[first,last)范围内的所以对象析构掉。我们不知道这个范围有多大，万一很大，而每个对象的析构函数都无关痛痒（所谓的trivial destructor），那么一次次调用这些无关痛痒的析构函数，对效率是一种伤害。因此，这里先利用<code>value_type()</code>获得迭代器所指对象的型别，再利用<code>_type_traits&lt;T&gt;</code>判断该型别的析构函数是否无关痛痒。若是（<code>_true_type</code>），则什么也不做就结束；若否，（<code>_false_type</code>），这才以循环方式巡访整个范围，并在循环中每经历一个对象就调用一个版本的<code>destroy()</code>。</p>
<h3 id="空间的配置和释放，std-alloc"><a href="#空间的配置和释放，std-alloc" class="headerlink" title="空间的配置和释放，std::alloc"></a>空间的配置和释放，std::alloc</h3><p>对象构造前的空间配置和对象析构后的空间释放，由<code>&lt;stl_alloc.h&gt;</code>负责，SGI对此的设计哲学如下：</p>
<ul>
<li>向system heap要求空间</li>
<li>考虑多线程状态</li>
<li>考虑内存不足时的应变措施</li>
<li>考虑过多“小型区块”可能造成的内存碎片问题</li>
</ul>
<p>C++的内存配置基本操作是<code>::operator new()</code>，内存释放基本操作是<code>::operator delete()</code>。这两个全局函数相当于C的<code>malloc()</code>和<code>free()</code>函数。是的，正是如此，SGI正是以<code>malloc()</code>和<code>free()</code>完成内存的配置和释放。</p>
<p>考虑到小型区块所可能造成的内存碎片问题。SGI设计了双层配置器，第一级配置器直接使用<code>malloc()</code>和<code>free()</code>，第二级配置器则视情况采用不同的策略；当配置区块超过128bytes时，视之为“足够大”，便调用第一级配置器；当配置区块小于128bytes时，视之为“过小”，为了降低额外负担，便采用复杂的memory pool整理方式，而不再求助于第一级配置器。整个设计究竟是开放第一级配置器或是同时开放第二级配置器，取决于<code>_USE_MALLOC</code>是否被定义：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">ifdef</span> __USE_MALLOC </span></span><br><span class="line">... </span><br><span class="line"><span class="keyword">typedef</span> __malloc_alloc_template&lt;<span class="number">0</span>&gt; malloc_alloc;<span class="comment">//令 alloc为第一级配置器</span></span><br><span class="line"><span class="keyword">typedef</span> malloc_alloc alloc; </span><br><span class="line"><span class="meta"># <span class="meta-keyword">else</span> </span></span><br><span class="line">... </span><br><span class="line"><span class="comment">//令 alloc 为第二级配置器 </span></span><br><span class="line"><span class="keyword">typedef</span> __default_alloc_template&lt;__NODE_ALLOCATOR_THREADS, <span class="number">0</span>&gt; alloc; </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* ! __USE_MALLOC */</span></span></span><br></pre></td></tr></table></figure></p>
<p>其中<code>__malloc_alloc_template</code>就是第一级配置器，<code>__default_alloc_template</code>就是第二级配置器。</p>
<p>无论alloc被定义为第一级或者是第二级配置器，SGI还为它包装一个接口如下，使配置器的接口能够符合STL规格：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">simple_alloc</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> T *<span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function">                </span>&#123; <span class="keyword">return</span> <span class="number">0</span> == n? <span class="number">0</span> : (T*) Alloc::allocate(n * <span class="keyword">sizeof</span> (T)); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> T *<span class="title">allocate</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">                </span>&#123; <span class="keyword">return</span> (T*) Alloc::allocate(<span class="keyword">sizeof</span> (T)); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(T *p, <span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function">                </span>&#123; <span class="keyword">if</span> (<span class="number">0</span> != n) Alloc::deallocate(p, n * <span class="keyword">sizeof</span> (T)); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(T *p)</span></span></span><br><span class="line"><span class="function">                </span>&#123; Alloc::deallocate(p, <span class="keyword">sizeof</span> (T)); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>其内部四个成员函数其实都是弹单纯的转调用，调用传递给配置器（可能是第一级也可能是第二级）的成员函数。这个接口使配置器的配置单位从bytes转为个别元素的大小（<code>sizeof(T)</code>）。SGI STL容器全都用这个<code>simple_alloc</code>接口。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span> = <span class="title">alloc</span>&gt; // 缺省使用<span class="title">alloc</span>为配置器</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">vector</span> &#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">typedef</span> simple_alloc&lt;value_type, Alloc&gt; data_allocator;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deallocate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (...)</span><br><span class="line">            data_allocator::deallocate(start, end_of_storage - start);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>一、二级配置器的关系如下：<br><img src="/img/1608952882.jpg" alt></p>
<p>第一级和第二级配置器的包装接口和运用方式如下：<br><img src="/img/1608952929.jpg" alt></p>
<h3 id="第一级配置器-malloc-alloc-template剖析"><a href="#第一级配置器-malloc-alloc-template剖析" class="headerlink" title="第一级配置器__malloc_alloc_template剖析"></a>第一级配置器__malloc_alloc_template剖析</h3><p>首先我们观察第一级配置器：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0 </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">include</span> <span class="meta-string">&lt;new&gt; </span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span>  __THROW_BAD_ALLOC throw bad_alloc </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> !defined(__THROW_BAD_ALLOC) </span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream.h&gt; </span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span>  __THROW_BAD_ALLOC cerr &lt;&lt; <span class="meta-string">"out of memory"</span> &lt;&lt; endl; exit(1) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> </span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// malloc-based allocator. 通常比稍后介绍的 default alloc 速度慢， </span></span><br><span class="line"><span class="comment">//一般而言是 thread-safe，并且对于空间的运用比较高效（efficient）。 </span></span><br><span class="line"><span class="comment">//以下是第一级配置器。 </span></span><br><span class="line"><span class="comment">//注意，无「template 型别参数」。至于「非型别参数」inst，完全没派上用场。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> inst&gt;   </span><br><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">malloc_alloc_template</span> &#123;</span> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line"><span class="comment">//以下都是函式指标，所代表的函式将用来处理内存不足的情况。 </span></span><br><span class="line"><span class="comment">// oom : out of memory. </span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">oom_malloc</span><span class="params">(<span class="keyword">size_t</span>)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">oom_realloc</span><span class="params">(<span class="keyword">void</span> *, <span class="keyword">size_t</span>)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">void</span> <span class="params">(* __malloc_alloc_oom_handler)</span><span class="params">()</span></span>; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> * <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> n)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">void</span>  *result =<span class="built_in">malloc</span>(n);<span class="comment">//第一级配置器直接使用 malloc() </span></span><br><span class="line">    <span class="comment">// 以下，无法满足需求时，改用 oom_malloc() </span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == result) result = oom_malloc(n); </span><br><span class="line">    <span class="keyword">return</span>  result; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span> *p, <span class="keyword">size_t</span> <span class="comment">/* n */</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="built_in">free</span>(p); <span class="comment">//第一级配置器直接使用 free() </span></span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> * <span class="title">reallocate</span><span class="params">(<span class="keyword">void</span> *p, <span class="keyword">size_t</span> <span class="comment">/* old_sz */</span>, <span class="keyword">size_t</span> new_sz)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">void</span>  *  result  =<span class="built_in">realloc</span>(p, new_sz);<span class="comment">//第一级配置器直接使用 rea</span></span><br><span class="line">    <span class="comment">// 以下，无法满足需求时，改用 oom_realloc() </span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == result) result = oom_realloc(p, new_sz); </span><br><span class="line">    <span class="keyword">return</span>  result; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">//以下模拟 C++的 set_new_handler(). 换句话说，你可以透过它， </span></span><br><span class="line"><span class="comment">//指定你自己的 out-of-memory handler </span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">void</span> <span class="params">(* set_malloc_handler(<span class="keyword">void</span> (*f)()))</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">void</span>  (*  old)()  =  __malloc_alloc_oom_handler; </span><br><span class="line">__malloc_alloc_oom_handler = f; </span><br><span class="line">    <span class="keyword">return</span>(old); </span><br><span class="line">&#125; </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="comment">// malloc_alloc out-of-memory handling </span></span><br><span class="line"><span class="comment">//初值为 0。有待客端设定。 </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> inst&gt; </span><br><span class="line"><span class="keyword">void</span> (* __malloc_alloc_template&lt;inst&gt;::__malloc_alloc_oom_handler)() = <span class="number">0</span>; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> inst&gt; </span><br><span class="line"><span class="keyword">void</span> * __malloc_alloc_template&lt;inst&gt;::oom_malloc(<span class="keyword">size_t</span> n) </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">void</span>  (* my_malloc_handler)(); </span><br><span class="line">    <span class="keyword">void</span>  *result; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (;;)  &#123; </span><br><span class="line">        <span class="comment">//不断尝试释放、配置、再释放、再配置… </span></span><br><span class="line">        my_malloc_handler = __malloc_alloc_oom_handler; </span><br><span class="line">        <span class="keyword">if</span>  (<span class="number">0</span>  ==  my_malloc_handler)  &#123;  __THROW_BAD_ALLOC; &#125; </span><br><span class="line">        (*my_malloc_handler)();<span class="comment">//呼叫处理例程，企图释放内存。 </span></span><br><span class="line">        result = <span class="built_in">malloc</span>(n);  <span class="comment">//再次尝试配置内存。 </span></span><br><span class="line">        <span class="keyword">if</span>  (result)  <span class="keyword">return</span>(result); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> inst&gt; </span><br><span class="line"><span class="keyword">void</span> * __malloc_alloc_template&lt;inst&gt;::oom_realloc(<span class="keyword">void</span> *p, <span class="keyword">size_t</span> n) </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">void</span>  (* my_malloc_handler)(); </span><br><span class="line">    <span class="keyword">void</span>  *result; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (;;)  &#123;  <span class="comment">//不断尝试释放、配置、再释放、再配置… </span></span><br><span class="line">        my_malloc_handler = __malloc_alloc_oom_handler; </span><br><span class="line">        <span class="keyword">if</span>  (<span class="number">0</span>  ==  my_malloc_handler)  &#123;  __THROW_BAD_ALLOC; &#125; </span><br><span class="line">        (*my_malloc_handler)();<span class="comment">//呼叫处理例程，企图释放内存。 </span></span><br><span class="line">        result = <span class="built_in">realloc</span>(p, n);<span class="comment">//再次尝试配置内存。 </span></span><br><span class="line">        <span class="keyword">if</span>  (result)  <span class="keyword">return</span>(result); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">//注意，以下直接将参数 inst指定为 0。 </span></span><br><span class="line"><span class="keyword">typedef</span> __malloc_alloc_template&lt;<span class="number">0</span>&gt; malloc_alloc;</span><br></pre></td></tr></table></figure></p>
<p>第一级配置器直接使用<code>malloc()</code>，<code>free()</code>，<code>realloc()</code>等C函数执行实际的内存配置、释放、重配置操作，并实现出类似C++ new handler机制。它有独特的out-of-memory内存处理机制：在抛出<code>std::bad_alloc</code>异常之前，调用内存不足处理例程尝试释放空间，如果用户没有定义相应的内存不足处理例程，那么还是会抛出异常。</p>
<p>所谓C++ new handler机制是，你可以要求系统在内存配置要求无法被满足时，调用一个你所指定的函数。换句话说，一旦::operator new无法完成任务，在丢出<code>std::bad_alloc</code>异常状态之前，会先调用由客户端指定的处理例程，该处理例程通常即被称为new-handler。new-handler解决内存不足的做法有特定的模式。</p>
<p>请注意，SGI第一级配置器的<code>allocate()</code>和<code>realloc()</code>都是在调用<code>malloc()</code>和<code>realloc()</code>不成功后，改调用<code>oom_malloc()</code>和<code>oom_realloc()</code>。后两者都有内循环，不断调用“内存不足处理例程”，期望在某次调用之后，获得足够的内存而圆满完成任务。但如果“内存不足处理例程”并未被客户端设定，<code>oom_malloc()</code>和<code>oom_realloc()</code>便老实不客气地调用<code>__THROW_BAD_ALLOC</code>，丢出<code>bad_alloc</code>异常信息，或利用<code>exit(1)</code>硬生生中止程序。</p>
<p>记住，设计“内存不足处理例程”是客端的责任，设定“内存不足处理例程”也是客端的责任。</p>
<h3 id="第二级配置器-default-alloc-template剖析"><a href="#第二级配置器-default-alloc-template剖析" class="headerlink" title="第二级配置器__default_alloc_template剖析"></a>第二级配置器__default_alloc_template剖析</h3><p>相比第一级配置器，第二级配置器多了一些机制，避免小额区块造成内存的碎片。不仅仅是碎片的问题，配置时的额外负担也是一个大问题。因为区块越小，额外负担所占的比例就越大。</p>
<p>额外负担是指<strong>动态分配内存块的时候，位于其头部的额外信息，包括记录内存块大小的信息以及内存保护区（判断是否越界）</strong>。要想了解详细信息，请参考MSVC或者其他malloc实现。</p>
<p>SGI STL第二级配置器具体实现思想如下：</p>
<ul>
<li>如果要分配的区块大于128bytes，则移交给第一级配置器处理。</li>
<li>如果要分配的区块小于128bytes，则以内存池管理（memory pool），又称之次层配置（sub-allocation）：每次配置一大块内存，并维护对应的自由链表（free-list）。下次若有相同大小的内存需求，则直接从free-list中取。如果有小额区块被释放，则由配置器回收到free-list中——是的，别忘了，配置器除了负责配置，也负责回收。</li>
</ul>
<p>在第二级配置器中，小额区块内存需求大小都被上调至8的倍数，比如需要分配的大小是30bytes，就自动调整为32bytes。系统中总共维护16个free-lists，各自管理大小为8,16，…，128bytes的小额区块。</p>
<p>为了维护链表，需要额外的指针，为了避免造成另外一种额外的负担，这里采用了一种技术：用union表示链表节点结构：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> obj &#123;</span><br><span class="line">      <span class="keyword">union</span> obj * free_list_link;<span class="comment">//指向下一个节点</span></span><br><span class="line">      <span class="keyword">char</span> client_data[<span class="number">1</span>];    <span class="comment">/* The client sees this. */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>union能够实现一物二用的效果，当节点所指的内存块是空闲块时，obj被视为一个指针，指向另一个节点。当节点已被分配时，被视为一个指针，指向实际区块。</p>
<p><img src="/img/1608954958.jpg" alt></p>
<p>下面是第二级配置器的部分实现内容：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;__ALIGN=<span class="number">8</span>&#125;; <span class="comment">//小型区块的上调上界</span></span><br><span class="line"><span class="keyword">enum</span> &#123;__MAX_BYTES=<span class="number">128</span>&#125;;  <span class="comment">//小型区块的上限</span></span><br><span class="line"><span class="keyword">enum</span> &#123;__NFREELISTS=__MAX_BYRES/__ALIGN&#125;;  <span class="comment">//free-lists个数</span></span><br></pre></td></tr></table></figure></p>
<p>以下是第二级配置器总体实现代码概览：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">default_alloc_template</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// 實際上我們應該使用 static const int x = N</span></span><br><span class="line">  <span class="comment">// 來取代 enum &#123; x = N &#125;, 但目前支援該性質的編譯器還不多。</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifndef</span> __SUNPRO_CC</span></span><br><span class="line">    <span class="keyword">enum</span> &#123;__ALIGN = <span class="number">8</span>&#125;;</span><br><span class="line">    <span class="keyword">enum</span> &#123;__MAX_BYTES = <span class="number">128</span>&#125;;</span><br><span class="line">    <span class="keyword">enum</span> &#123;__NFREELISTS = __MAX_BYTES/__ALIGN&#125;;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> size_t <span class="title">ROUND_UP</span><span class="params">(<span class="keyword">size_t</span> bytes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (((bytes) + __ALIGN<span class="number">-1</span>) &amp; ~(__ALIGN - <span class="number">1</span>));</span><br><span class="line">  &#125;</span><br><span class="line">__PRIVATE:</span><br><span class="line">  <span class="keyword">union</span> obj &#123;</span><br><span class="line">        <span class="keyword">union</span> obj * free_list_link;</span><br><span class="line">        <span class="keyword">char</span> client_data[<span class="number">1</span>];    <span class="comment">/* The client sees this. */</span></span><br><span class="line">  &#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifdef</span> __SUNPRO_CC</span></span><br><span class="line">    <span class="keyword">static</span> obj * __VOLATILE free_list[]; </span><br><span class="line">        <span class="comment">// Specifying a size results in duplicate def for 4.1</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">static</span> obj * __VOLATILE free_list[__NFREELISTS]; </span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="function"><span class="keyword">static</span>  size_t <span class="title">FREELIST_INDEX</span><span class="params">(<span class="keyword">size_t</span> bytes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (((bytes) + __ALIGN<span class="number">-1</span>)/__ALIGN - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Returns an object of size n, and optionally adds to size n free list.</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">refill</span><span class="params">(<span class="keyword">size_t</span> n)</span></span>;</span><br><span class="line">  <span class="comment">// Allocates a chunk for nobjs of size "size".  nobjs may be reduced</span></span><br><span class="line">  <span class="comment">// if it is inconvenient to allocate the requested number.</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">char</span> *<span class="title">chunk_alloc</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">int</span> &amp;nobjs)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Chunk allocation state.</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">char</span> *start_free;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">char</span> *end_free;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">size_t</span> heap_size;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* n must be &gt; 0      */</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> * <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> n)</span></span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* p may not be 0 */</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span> *p, <span class="keyword">size_t</span> n)</span></span>&#123;...&#125;</span><br><span class="line"> <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> * <span class="title">reallocate</span><span class="params">(<span class="keyword">void</span> *p, <span class="keyword">size_t</span> old_sz, <span class="keyword">size_t</span> new_sz)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="keyword">char</span> *__default_alloc_template&lt;threads, inst&gt;::start_free = <span class="number">0</span>;<span class="comment">//内存池起始位置</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="keyword">char</span> *__default_alloc_template&lt;threads, inst&gt;::end_free = <span class="number">0</span>;<span class="comment">//内存池结束位置</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="keyword">size_t</span> __default_alloc_template&lt;threads, inst&gt;::heap_size = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;</span><br><span class="line">__default_alloc_template&lt;threads, inst&gt;::obj * __VOLATILE</span><br><span class="line">__default_alloc_template&lt;threads, inst&gt; ::free_list[</span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifdef</span> __SUNPRO_CC</span></span><br><span class="line">    __NFREELISTS</span><br><span class="line"><span class="meta"># <span class="meta-keyword">else</span></span></span><br><span class="line">    __default_alloc_template&lt;threads, inst&gt;::__NFREELISTS</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line">] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, &#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="空间配置函数allocate"><a href="#空间配置函数allocate" class="headerlink" title="空间配置函数allocate()"></a>空间配置函数allocate()</h3><p><code>__default_alloc_template</code>拥有配置器的标准接口函数<code>allocate()</code>，此函数首先判断区块大小，要分配的区块小于128bytes，调用第一级配置器。否则，向对应的free-list寻求帮助。对应的free list有可用的区块，直接拿过来用。如果没有可用的区块，调用函数<code>refill()</code>为`free list重新填充空间。代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/* n must be &gt; 0      */</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> * <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    obj * __VOLATILE * my_free_list;</span><br><span class="line">    obj * __RESTRICT result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n &gt; (<span class="keyword">size_t</span>) __MAX_BYTES) &#123;</span><br><span class="line">        <span class="keyword">return</span>(malloc_alloc::allocate(n));</span><br><span class="line">    &#125;</span><br><span class="line">    my_free_list = free_list + FREELIST_INDEX(n);</span><br><span class="line">    <span class="comment">// Acquire the lock here with a constructor call.</span></span><br><span class="line">    <span class="comment">// This ensures that it is released in exit or during stack</span></span><br><span class="line">    <span class="comment">// unwinding.</span></span><br><span class="line"><span class="meta">#       <span class="meta-keyword">ifndef</span> _NOTHREADS</span></span><br><span class="line">        <span class="comment">/*REFERENCED*/</span></span><br><span class="line">        lock lock_instance;</span><br><span class="line"><span class="meta">#       <span class="meta-keyword">endif</span></span></span><br><span class="line">    result = *my_free_list;</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">void</span> *r = refill(ROUND_UP(n));</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    *my_free_list = result -&gt; free_list_link;</span><br><span class="line">    <span class="keyword">return</span> (result);</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure></p>
<p>这里需要注意的是，每次都是从对应的free list的头部取出可用的内存块。图示如下：<br><img src="1608955300.jpg" alt></p>
<h3 id="空间释放函数"><a href="#空间释放函数" class="headerlink" title="空间释放函数"></a>空间释放函数</h3><p>身为一个配置器，<code>__default_alloc_template</code>拥有配置器的标准接口函数<code>deallocate()</code>，此函数首先判断区块大小，大于128bytes调用第一级配置器。否则，找出对应的free list，将区块回收。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// p 不可以为0</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span>* p, <span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    obj *q = (obj *)p;</span><br><span class="line">    obj * <span class="keyword">volatile</span> * my_free_list;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 大于128就调用一级配置器</span></span><br><span class="line">    <span class="keyword">if</span> (n &gt; (<span class="keyword">size_t</span>) __MAX_BYTES) &#123;</span><br><span class="line">        malloc_alloc::deallocate(p, n);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 寻找对应的free list</span></span><br><span class="line">    my_free_list = free_list + FREELIST_INDEX(n);</span><br><span class="line">    <span class="comment">// 调整free list，收回区块</span></span><br><span class="line">    q-&gt;free_list_link = *my_free_list;</span><br><span class="line">    *my_free_list = q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/1608957050.jpg" alt></p>
<h3 id="为free-list填充空间"><a href="#为free-list填充空间" class="headerlink" title="为free list填充空间"></a>为free list填充空间</h3><p>当发现对应的free list没有可用的空闲区块时，就需要调用<code>refill()</code>函数重新填充空间。新的空间将取自于内存池（将经由<code>chunk_alloc()</code>完成）。缺省取得20个新节点（新区块），但万一内存池空间不足，获得的节点数（区块数）可能小于20，内存池的管理后面会讲到。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Returns an object of size n, and optionally adds to size n free list.*/</span></span><br><span class="line"><span class="comment">/* We assume that n is properly aligned.                                */</span></span><br><span class="line"><span class="comment">/* We hold the allocation lock.                                         */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="keyword">void</span>* __default_alloc_template&lt;threads, inst&gt;::refill(<span class="keyword">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> nobjs = <span class="number">20</span>;</span><br><span class="line">    <span class="comment">//调用chunk_alloc()，尝试取得nobjs个区块作为free list的新节点，注意参数nobjs是pass by reference</span></span><br><span class="line">    <span class="keyword">char</span> * chunk = chunk_alloc(n, nobjs);</span><br><span class="line">    obj * __VOLATILE * my_free_list;</span><br><span class="line">    obj * result;</span><br><span class="line">    obj * current_obj, * next_obj;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> == nobjs) <span class="keyword">return</span>(chunk);</span><br><span class="line">    my_free_list = free_list + FREELIST_INDEX(n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Build free list in chunk */</span></span><br><span class="line">      result = (obj *)chunk;</span><br><span class="line">      *my_free_list = next_obj = (obj *)(chunk + n);</span><br><span class="line">      <span class="keyword">for</span> (i = <span class="number">1</span>; ; i++) &#123;<span class="comment">//将各节点串接起来（注意，索引为0的返回给客端使用）</span></span><br><span class="line">        current_obj = next_obj;</span><br><span class="line">        next_obj = (obj *)((<span class="keyword">char</span> *)next_obj + n);</span><br><span class="line">        <span class="keyword">if</span> (nobjs - <span class="number">1</span> == i) &#123;</span><br><span class="line">            current_obj -&gt; free_list_link = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            current_obj -&gt; free_list_link = next_obj;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">return</span>(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="内存池"><a href="#内存池" class="headerlink" title="内存池"></a>内存池</h3><p>从内存池中取空间供free list使用，是<code>chunk_alloc()</code>的工作。具体实现思想如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* We allocate memory in large chunks in order to avoid fragmenting     */</span></span><br><span class="line"><span class="comment">/* the malloc heap too much.                                            */</span></span><br><span class="line"><span class="comment">/* We assume that size is properly aligned.                             */</span></span><br><span class="line"><span class="comment">/* We hold the allocation lock.                                         */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="keyword">char</span>*</span><br><span class="line">__default_alloc_template&lt;threads, inst&gt;::chunk_alloc(<span class="keyword">size_t</span> size, <span class="keyword">int</span>&amp; nobjs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> * result;</span><br><span class="line">    <span class="keyword">size_t</span> total_bytes = size * nobjs;</span><br><span class="line">    <span class="keyword">size_t</span> bytes_left = end_free - start_free;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bytes_left &gt;= total_bytes) &#123;</span><br><span class="line">        result = start_free;</span><br><span class="line">        start_free += total_bytes;</span><br><span class="line">        <span class="keyword">return</span>(result);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bytes_left &gt;= size) &#123;</span><br><span class="line">        nobjs = bytes_left/size;</span><br><span class="line">        total_bytes = size * nobjs;</span><br><span class="line">        result = start_free;</span><br><span class="line">        start_free += total_bytes;</span><br><span class="line">        <span class="keyword">return</span>(result);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">size_t</span> bytes_to_get = <span class="number">2</span> * total_bytes + ROUND_UP(heap_size &gt;&gt; <span class="number">4</span>);<span class="comment">//注意此处申请的空间的大小</span></span><br><span class="line">        <span class="comment">// Try to make use of the left-over piece.</span></span><br><span class="line">        <span class="keyword">if</span> (bytes_left &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            obj * __VOLATILE * my_free_list =</span><br><span class="line">                        free_list + FREELIST_INDEX(bytes_left);</span><br><span class="line"></span><br><span class="line">            ((obj *)start_free) -&gt; free_list_link = *my_free_list;</span><br><span class="line">            *my_free_list = (obj *)start_free;</span><br><span class="line">        &#125;</span><br><span class="line">        start_free = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(bytes_to_get);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == start_free) &#123;</span><br><span class="line">            <span class="keyword">int</span> i;</span><br><span class="line">            obj * __VOLATILE * my_free_list, *p;</span><br><span class="line">            <span class="comment">// Try to make do with what we have.  That can't</span></span><br><span class="line">            <span class="comment">// hurt.  We do not try smaller requests, since that tends</span></span><br><span class="line">            <span class="comment">// to result in disaster on multi-process machines.</span></span><br><span class="line">            <span class="keyword">for</span> (i = size; i &lt;= __MAX_BYTES; i += __ALIGN) &#123;</span><br><span class="line">                my_free_list = free_list + FREELIST_INDEX(i);</span><br><span class="line">                p = *my_free_list;</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">0</span> != p) &#123;</span><br><span class="line">                    *my_free_list = p -&gt; free_list_link;</span><br><span class="line">                    start_free = (<span class="keyword">char</span> *)p;</span><br><span class="line">                    end_free = start_free + i;</span><br><span class="line">                    <span class="keyword">return</span>(chunk_alloc(size, nobjs));</span><br><span class="line">                    <span class="comment">// Any leftover piece will eventually make it to the</span></span><br><span class="line">                    <span class="comment">// right free list.</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        end_free = <span class="number">0</span>;    <span class="comment">// In case of exception.</span></span><br><span class="line">            start_free = (<span class="keyword">char</span> *)malloc_alloc::allocate(bytes_to_get);</span><br><span class="line">            <span class="comment">// This should either throw an</span></span><br><span class="line">            <span class="comment">// exception or remedy the situation.  Thus we assume it</span></span><br><span class="line">            <span class="comment">// succeeded.</span></span><br><span class="line">        &#125;</span><br><span class="line">        heap_size += bytes_to_get;</span><br><span class="line">        end_free = start_free + bytes_to_get;</span><br><span class="line">        <span class="keyword">return</span>(chunk_alloc(size, nobjs));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>chunk_alloc()</code>函数以<code>end_free - start_free</code>来判断内存池的数量：</p>
<ul>
<li>内存池剩余空间完全满足20个区块的需求量，则直接取出对应大小的空间。</li>
<li>内存池剩余空间不能完全满足20个区块的需求量，但是足够供应一个及一个以上的区块，则取出能够满足条件的区块个数的空间。</li>
<li>内存池剩余空间不能满足一个区块的大小，则需要利用<code>malloc()</code>从heap中配置内存，为内存池注入活水。</li>
</ul>
<p>举个例子，见图2-7，假设程序一开始，客端就调用<code>chunk_alloc(32,2O)</code>，于是<code>malloc()</code>配置40个32 bytes区块，其中第1个交出，另19个交给<code>free_list[3]</code>维护，余20个留给内存池。接下来客端调用<code>chunk_alloc(64,20)</code>，此时<code>free_1ist[7]</code>空空如也，必须向内存池要求支持，内存池只够供应<code>(32*20)/M = 10</code>个64 bytes区块，就把这10个区块返回，第1个交给客端、余9个由<code>free_list[7]</code>维护。此时内存池全空，接下来再调用<code>chunk_alloc(96, 20)</code>，此时<code>free_list[11]</code>空空如也，必须向内存池要求支持，而内存池此时也是空的，于是以<code>malloc()</code>配置40+n（附加量）个96 bytes区块， 其中第1个交出，另19个交给<code>free_list[11]</code>维护，余20+n（附加量）个区块留给内存池。</p>
<p>万一山穷水尽，整个system heap空问都不够了（以至无法为内存池注入活水源头），<code>malloc()</code>行动失败，<code>chunk_alloc()</code>就四处寻找有无“尚有未用区块，且区块够大”之free lists。找到了就挖一块交出，找不到就调用第一级配置器，第一级配置器其实也是使用<code>malloc()</code>来配置内存，但它有out-of-memory处理机制（类似new-handler机制），或许有机会释放其它的内存拿来此处使用。如果可以，就成功，否则发出<code>bad_alloc</code>异常。 </p>
<p>以上便是整个第二级空间配置器的设计。 </p>
<p><img src="/img/1608959629.jpg" alt></p>
<p>回想一些那个提供配置器标准接口的simple_alloc：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">simple_alloc</span>&#123;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>SGI容器通常以这种方式来使用配置器：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>,<span class="title">class</span> <span class="title">Alloc</span>=<span class="title">alloc</span>&gt; //缺省使用<span class="title">alloc</span>配置器</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">vector</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">//专属之空间配置器，每次配置一个元素大小</span></span><br><span class="line">    <span class="keyword">typedef</span> simple_alloc&lt;value_type,Alloc&gt; data_allocator;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>其中第二个template参数所使用的缺省参数alloc，可以是第一级配置器也可以是第二级配置器。不过，SGI STL已经把它设为第二级配置器。</p>
<h3 id="deallocate"><a href="#deallocate" class="headerlink" title="deallocate()"></a>deallocate()</h3><p>如果需要回收的区块大于128bytes，则调用第一级配置器。如果需要回收的区块小于128bytes，找到对应的free-list，将区块回收。注意是将区块放入free -list的头部。SGI STL源代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/* p may not be 0 */</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span> *p, <span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    obj *q = (obj *)p;</span><br><span class="line">    obj * __VOLATILE * my_free_list;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n &gt; (<span class="keyword">size_t</span>) __MAX_BYTES) &#123;</span><br><span class="line">        malloc_alloc::deallocate(p, n);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    my_free_list = free_list + FREELIST_INDEX(n);</span><br><span class="line">    <span class="comment">// acquire lock</span></span><br><span class="line"><span class="meta">#       <span class="meta-keyword">ifndef</span> _NOTHREADS</span></span><br><span class="line">        <span class="comment">/*REFERENCED*/</span></span><br><span class="line">        lock lock_instance;</span><br><span class="line"><span class="meta">#       <span class="meta-keyword">endif</span> <span class="comment">/* _NOTHREADS */</span></span></span><br><span class="line">    q -&gt; free_list_link = *my_free_list;</span><br><span class="line">    *my_free_list = q;</span><br><span class="line">    <span class="comment">// lock is released here</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="内存基本处理工具"><a href="#内存基本处理工具" class="headerlink" title="内存基本处理工具"></a>内存基本处理工具</h2><p>STL定义有五个全局函数，作用于未初始化空间上，这样的功能对于容器的实现很有帮助。前两个函数是用于构造的<code>construct()</code>和用于析构的<code>destroy()</code>，另三个函数是<code>uninitialized_copy()</code>，<code>uninitialized_fill()</code>，<code>uninitialized_fill_n</code>，分别对应于高层次函数<code>copy()</code>、<code>fill()</code>、<code>fill_n()</code>——这些都是STL算法。</p>
<h3 id="uninitialized-copy"><a href="#uninitialized-copy" class="headerlink" title="uninitialized_copy"></a>uninitialized_copy</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>,<span class="title">class</span> <span class="title">ForwardIterator</span>&gt;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">ForwardIterator</span> <span class="title">uninitialized_copy</span>(<span class="title">InputIterator</span> <span class="title">first</span>,<span class="title">InputIterator</span> <span class="title">last</span>,<span class="title">ForwardIterator</span> <span class="title">result</span>);</span></span><br></pre></td></tr></table></figure>
<p><code>uninitialized_copy()</code>使我们能够将内存的配置和对象的构造行为分离开来，如果作为输出目的地的<code>[result,result+(last-first))</code>范围内的每一个迭代器都指向为初始化区域，则<code>uninitialized_copy()</code>会使用copy constructor，给身为输入来源之<code>[first,last)</code>范围内的每一个对象产生一份复制品，放进输出范围中。换句话说，针对输入范围内的每一个迭代器i，该函数会调用<code>construct(&amp;*(result+(i-first)),*i)</code>，产生<code>*i</code>的复制品，放置于输出范围的相对位置上。</p>
<p>如果你需要实现一个容器，<code>uninitialized_copy()</code>这样的函数会为你带来很大的帮助，因为容器的全区间构造函数通常以两个步骤完成：</p>
<ul>
<li>配置内存块，足以包含范围内的所有元素</li>
<li>使用<code>uninitialized_copy()</code>，在该内存区块上构造元素。</li>
</ul>
<p>C++标志规格书要求<code>uninitialized_copy()</code>具有“commit or rollback”语意，意思是要么“构造出所有必要的元素”，要么（当有任何一个copy constructor失败时）“不构造任何东西。</p>
<h3 id="uninitialized-fill"><a href="#uninitialized-fill" class="headerlink" title="uninitialized_fill"></a>uninitialized_fill</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>,<span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">ForwardIterator</span> <span class="title">uninitialized_fill</span>(<span class="title">ForwardIterator</span> <span class="title">first</span>,<span class="title">ForwardIterator</span> <span class="title">last</span>,<span class="title">const</span> <span class="title">T</span>&amp; <span class="title">x</span>);</span></span><br></pre></td></tr></table></figure>
<p><code>uninitialized_fill()</code>也能够使我们将内存配置与对象的构造行为分离开来。如果<code>[first,last)</code>范围内的每个迭代器都指向未初始化的内存，那么<code>uninitialized_fill()</code>会在该范围内产生x（上式第三个参数）的复制品。换句话说，<code>uninitialized_fill()</code>会针对操作范围内的每个迭代器<code>i</code>，调用<code>construct(&amp;*i,x)</code>，在i所指之处产生x的复制品。</p>
<p>与<code>uninitialized_copy()</code>一样，<code>uninitialized_fill()</code>必须具备“commit or rollback”语意，换句话说，它要么产生出所有必要元素，要么不产生任何元素，如果有任何一个copy constructor丢出异常（exception），<code>uninitialized_fill()</code>，必须能够将已产生的所有元素析构掉。</p>
<h3 id="uninitialized-fill-n"><a href="#uninitialized-fill-n" class="headerlink" title="uninitialized_fill_n"></a>uninitialized_fill_n</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>,<span class="title">class</span> <span class="title">Size</span>,<span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">ForwardIterator</span> <span class="title">uninitialized_fill_n</span>(<span class="title">ForwardIterator</span> <span class="title">first</span>,<span class="title">Size</span> <span class="title">n</span>,<span class="title">const</span> <span class="title">T</span>&amp; <span class="title">x</span>);</span></span><br></pre></td></tr></table></figure>
<p><code>uninitialized_fill_n()</code>能使我们将内存配置与对象构造行为分离开来，它会为指定范围内的所有元素设定相同的初值。</p>
<p>如果<code>[first,first+n)</code>范围内的每一个迭代器都指向未初始化的内存，那么<code>uninitialized_fill_n()</code>会调用 copy constructor，在该范围内产生<code>x</code>（上式第三个参数——的复制品。也就是说，面对<code>[first,first+n)</code>范围内的每个迭代器<code>i</code>，<code>uninitialized_fill_n()</code>会调用<code>construct(&amp;*i,x)</code>，在对应位置产生x的复制品。</p>
<p><code>uninitialized_fill_n()</code>也具有“commit or rollback”语意：要么产生所有必要的元素，否则就不产生任何元素。如果任何一个copy constructor丢出异常（exception），<code>uninitialized_fill_n()</code>必须析构已产生的所有元素。</p>
<p>以下分别介绍这三个函数的实现法，其中所呈现的<code>iterators</code>（迭代器）、<code>value_type()</code>、<code>_type_traits</code>、<code>_true_type</code>、<code>_false_type</code>、<code>is_POD_type</code>等实现技术，都在后面介绍。</p>
<h4 id="uninitialized-fill-n-1"><a href="#uninitialized-fill-n-1" class="headerlink" title="uninitialized_fill_n()"></a>uninitialized_fill_n()</h4><p>本函数接受三个参数：</p>
<ul>
<li>迭代器first指向欲初始化空间的起始处；n表示欲初始化空间的大小；x表示初值。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>,<span class="title">class</span> <span class="title">Size</span>,<span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">ForwardInterator</span> <span class="title">uninitialized_fill_n</span>(<span class="title">ForwardIterator</span> <span class="title">first</span>, <span class="title">Size</span> <span class="title">n</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">x</span>) &#123;</span></span><br><span class="line">    <span class="keyword">return</span> __uninitialized_fill_n(first, n, x, value_type(first));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数的逻辑是，首先萃取出迭代器first的value_type，然后判断是否是POD型别：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>, <span class="title">class</span> <span class="title">Size</span>, <span class="title">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">T1</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">ForwardInterator</span> __<span class="title">uninitialized_fill_n</span>(<span class="title">ForwardIterator</span> <span class="title">first</span>, <span class="title">Size</span> <span class="title">n</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">x</span>, <span class="title">T1</span>*) &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> __type_traits&lt;T1&gt;::is_POD_type is_POD;</span><br><span class="line">    <span class="keyword">return</span> __uninitialized_fill_n_aux(first, n, x, is_POD());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>POD意为Plain Old Data，也就是标量型别，或传统的C struct型别，可以用最有效率的初值填写手法，而对non_POD型别采取最保险的做法。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果copy construction等同于assignment，而且destructor是trivial，以下就有效</span></span><br><span class="line"><span class="comment">// 如果是POD型别，执行流程就会转进到以下函数，这借由function template的参数推导机制而得</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>,<span class="title">class</span> <span class="title">Size</span>,<span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">ForwardInterator</span> __<span class="title">uninitialized_fill_n_aux</span>(<span class="title">ForwardIterator</span> <span class="title">first</span>, <span class="title">Size</span> <span class="title">n</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">x</span>, __<span class="title">true_type</span>) &#123;</span></span><br><span class="line">    <span class="keyword">return</span> fill_n(first, n, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果不是POD型别，就会转进到以下函数，这借由function template的参数推导机制而得</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>,<span class="title">class</span> <span class="title">Size</span>,<span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">ForwardInterator</span> __<span class="title">uninitialized_fill_n_aux</span>(<span class="title">ForwardIterator</span> <span class="title">first</span>, <span class="title">Size</span> <span class="title">n</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">x</span>, __<span class="title">false_type</span>) &#123;</span></span><br><span class="line">    ForwardIterator cur = first;</span><br><span class="line">    <span class="keyword">for</span> (; n &gt; <span class="number">0</span>; --n, ++ cur)</span><br><span class="line">        construct(&amp;*cur, x);</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="uninitialized-copy-1"><a href="#uninitialized-copy-1" class="headerlink" title="uninitialized_copy()"></a>uninitialized_copy()</h4><p><code>uninitialized_copy()</code>接受三个函数：</p>
<ul>
<li>迭代器first指向输入端的起始位置</li>
<li>迭代器last指向输入端的结束位置</li>
<li>迭代器rsult指向输出端（欲初始化空间）的起始处</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">ForwardIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">ForwardInterator</span> <span class="title">uninitialized_copy</span>(<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>, <span class="title">ForwardIterator</span> <span class="title">result</span>) &#123;</span></span><br><span class="line">    <span class="keyword">return</span> __uninitialized_copy(first, last, result, value_type(result));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数的逻辑是，首先萃取出迭代器result的value_type，然后判断是否是POD型别：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">ForwardIterator</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">ForwardInterator</span> __<span class="title">uninitialized_copy</span>(<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>, <span class="title">ForwardIterator</span> <span class="title">result</span>, <span class="title">T</span>*) &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> __type_traits&lt;T&gt;::is_POD_type is_POD;</span><br><span class="line">    <span class="keyword">return</span> __uninitialized_copy_aux(first, last, result, is_POD());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>POD可以用最有效率的初值填写手法，而对non_POD型别采取最保险的做法。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果copy construction等同于assignment，而且destructor是trivial，以下就有效</span></span><br><span class="line"><span class="comment">// 如果是POD型别，执行流程就会转进到以下函数，这借由function template的参数推导机制而得</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">ForwardIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">ForwardInterator</span> __<span class="title">uninitialized_copy_aux</span>(<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>, <span class="title">ForwardIterator</span> <span class="title">result</span>, __<span class="title">true_type</span>) &#123;</span></span><br><span class="line">    <span class="keyword">return</span> copy(first, last, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果不是POD型别，就会转进到以下函数，这借由function template的参数推导机制而得</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">ForwardIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">ForwardInterator</span> __<span class="title">uninitialized_copy_aux</span>(<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>, <span class="title">ForwardIterator</span> <span class="title">result</span>, __<span class="title">false_type</span>) &#123;</span></span><br><span class="line">    ForwardIterator cur = first;</span><br><span class="line">    <span class="keyword">for</span> (; first != last; ++ first, ++ cur)</span><br><span class="line">        construct(&amp;*cur, *first);</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>针对<code>char*</code>和<code>wchar_t*</code>两种型别，可以采用最具效率的做法<code>memmove</code>执行复制行为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">char</span>* <span class="title">uninitialized_copy</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* first, <span class="keyword">const</span> <span class="keyword">char</span>* last, <span class="keyword">char</span>* result)</span> </span>&#123;</span><br><span class="line">    memmove(rseult, first, last-first);</span><br><span class="line">    <span class="keyword">return</span> result + (last - first);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> wchar_t* <span class="title">uninitialized_copy</span><span class="params">(<span class="keyword">const</span> <span class="keyword">wchar_t</span>* first, <span class="keyword">const</span> <span class="keyword">wchar_t</span>* last, <span class="keyword">wchar_t</span>* result)</span> </span>&#123;</span><br><span class="line">    memmove(rseult, first, <span class="keyword">sizeof</span>(<span class="keyword">wchar_t</span>) * (last-first));</span><br><span class="line">    <span class="keyword">return</span> result + (last - first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="uninitialized-fill-n-2"><a href="#uninitialized-fill-n-2" class="headerlink" title="uninitialized_fill_n()"></a>uninitialized_fill_n()</h4><p>本函数接受三个参数：</p>
<ul>
<li>迭代器first指向欲初始化空间的起始处；</li>
<li>迭代器last指向输出端的结束处；</li>
<li>x表示初值。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">uninitialized_fill</span>(<span class="title">ForwardIterator</span> <span class="title">first</span>, <span class="title">ForwardIterator</span> <span class="title">last</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">x</span>) &#123;</span></span><br><span class="line">    __uninitialized_fill(first, last, x, value_type(first));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数的逻辑是，首先萃取出迭代器first的value_type，然后判断是否是POD型别：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>, <span class="title">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">T1</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> __<span class="title">uninitialized_fill</span>(<span class="title">ForwardIterator</span> <span class="title">first</span>, <span class="title">ForwardIterator</span> <span class="title">last</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">x</span>, <span class="title">T1</span>*) &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> __type_traits&lt;T1&gt;::is_POD_type is_POD;</span><br><span class="line">    <span class="keyword">return</span> __uninitialized_fill_aux(first, last, x, is_POD());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>POD意为Plain Old Data，也就是标量型别，或传统的C struct型别，可以用最有效率的初值填写手法，而对non_POD型别采取最保险的做法。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果copy construction等同于assignment，而且destructor是trivial，以下就有效</span></span><br><span class="line"><span class="comment">// 如果是POD型别，执行流程就会转进到以下函数，这借由function template的参数推导机制而得</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> __<span class="title">uninitialized_fill_aux</span>(<span class="title">ForwardIterator</span> <span class="title">first</span>, <span class="title">ForwardIterator</span> <span class="title">last</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">x</span>, __<span class="title">true_type</span>) &#123;</span></span><br><span class="line">    fill(first, last, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果不是POD型别，就会转进到以下函数，这借由function template的参数推导机制而得</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>,<span class="title">class</span> <span class="title">Size</span>,<span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> __<span class="title">uninitialized_fill_aux</span>(<span class="title">ForwardIterator</span> <span class="title">first</span>, <span class="title">ForwardIterator</span> <span class="title">last</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">x</span>, __<span class="title">false_type</span>) &#123;</span></span><br><span class="line">    ForwardIterator cur = first;</span><br><span class="line">    <span class="keyword">for</span> (; cur != last; ++ cur)</span><br><span class="line">        construct(&amp;*cur, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/20180524164335567.png" alt></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/C/" rel="tag"># C++</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/11/29/深度探索cpp对象模型 笔记3/" rel="next" title="深度探索C++对象模型 笔记3">
                <i class="fa fa-chevron-left"></i> 深度探索C++对象模型 笔记3
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/12/30/STL源码剖析 笔记2/" rel="prev" title="STL 源码剖析 笔记2">
                STL 源码剖析 笔记2 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/header.jpg" alt="Hao Yu">
            
              <p class="site-author-name" itemprop="name">Hao Yu</p>
              <p class="site-description motion-element" itemprop="description">Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author</p>
          </div>
          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">289</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>
        	<audio controls="controls" loop="loop" preload="auto" src="/resource/xiaomeihao.mp3">
	        </audio>
	

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yuhao0102" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:yuh18@mails.tsinghua.edu.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#第一章：STL概论和版本简介"><span class="nav-number">1.</span> <span class="nav-text">第一章：STL概论和版本简介</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#STL六大组件"><span class="nav-number">1.1.</span> <span class="nav-text">STL六大组件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#各组件间的关系"><span class="nav-number">1.1.1.</span> <span class="nav-text">各组件间的关系</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SGI-STL头文件分布"><span class="nav-number">1.2.</span> <span class="nav-text">SGI STL头文件分布</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#可能困惑的C-语法"><span class="nav-number">1.3.</span> <span class="nav-text">可能困惑的C++语法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#stl-config-h中的各种组态（configuration）"><span class="nav-number">1.3.1.</span> <span class="nav-text">stl_config.h中的各种组态（configuration）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#临时对象的产生与应用"><span class="nav-number">1.3.2.</span> <span class="nav-text">临时对象的产生与应用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#静态常量整数成员在class内部直接初始化"><span class="nav-number">1.3.3.</span> <span class="nav-text">静态常量整数成员在class内部直接初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#increment-decrement-dereference操作符"><span class="nav-number">1.3.4.</span> <span class="nav-text">increment/decrement/dereference操作符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#前闭后开区间表示法"><span class="nav-number">1.3.5.</span> <span class="nav-text">前闭后开区间表示法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#function-call-操作符"><span class="nav-number">1.3.6.</span> <span class="nav-text">function call 操作符</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#空间配置器"><span class="nav-number">2.</span> <span class="nav-text">空间配置器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#空间配置器的标准接口"><span class="nav-number">2.1.</span> <span class="nav-text">空间配置器的标准接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#设计一个简单的空间配置器-JJ-allocator"><span class="nav-number">2.1.1.</span> <span class="nav-text">设计一个简单的空间配置器, JJ::allocator</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#具备次配置力的-SGI-空间配置器"><span class="nav-number">2.2.</span> <span class="nav-text">具备次配置力的 SGI 空间配置器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#SGI标准的空间配置器allocator"><span class="nav-number">2.2.1.</span> <span class="nav-text">SGI标准的空间配置器allocator</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SGI特殊的空间配置器std-alloc"><span class="nav-number">2.2.2.</span> <span class="nav-text">SGI特殊的空间配置器std::alloc</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#构造函数析构的基本工具：construct-和destroy"><span class="nav-number">2.2.3.</span> <span class="nav-text">构造函数析构的基本工具：construct()和destroy()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#空间的配置和释放，std-alloc"><span class="nav-number">2.2.4.</span> <span class="nav-text">空间的配置和释放，std::alloc</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第一级配置器-malloc-alloc-template剖析"><span class="nav-number">2.2.5.</span> <span class="nav-text">第一级配置器__malloc_alloc_template剖析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第二级配置器-default-alloc-template剖析"><span class="nav-number">2.2.6.</span> <span class="nav-text">第二级配置器__default_alloc_template剖析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#空间配置函数allocate"><span class="nav-number">2.2.7.</span> <span class="nav-text">空间配置函数allocate()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#空间释放函数"><span class="nav-number">2.2.8.</span> <span class="nav-text">空间释放函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#为free-list填充空间"><span class="nav-number">2.2.9.</span> <span class="nav-text">为free list填充空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内存池"><span class="nav-number">2.2.10.</span> <span class="nav-text">内存池</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#deallocate"><span class="nav-number">2.2.11.</span> <span class="nav-text">deallocate()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内存基本处理工具"><span class="nav-number">2.3.</span> <span class="nav-text">内存基本处理工具</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#uninitialized-copy"><span class="nav-number">2.3.1.</span> <span class="nav-text">uninitialized_copy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#uninitialized-fill"><span class="nav-number">2.3.2.</span> <span class="nav-text">uninitialized_fill</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#uninitialized-fill-n"><span class="nav-number">2.3.3.</span> <span class="nav-text">uninitialized_fill_n</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#uninitialized-fill-n-1"><span class="nav-number">2.3.3.1.</span> <span class="nav-text">uninitialized_fill_n()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#uninitialized-copy-1"><span class="nav-number">2.3.3.2.</span> <span class="nav-text">uninitialized_copy()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#uninitialized-fill-n-2"><span class="nav-number">2.3.3.3.</span> <span class="nav-text">uninitialized_fill_n()</span></a></li></ol></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>
  <div id="DvelopmentTarget">     
  </div>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart" aria-hidden="false"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>

  
</div>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_uv"> 
  本站访客数<span id="busuanzi_value_site_uv"></span>人次
</span>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  


  <script type="text/javascript" src="/js/src/love.js"></script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
